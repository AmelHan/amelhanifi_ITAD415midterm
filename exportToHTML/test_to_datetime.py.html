<html>
<head>
<title>test_to_datetime.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_to_datetime.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; test to_datetime &quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">calendar</span>
<span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">deque</span>
<span class="s2">from </span><span class="s1">datetime </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">date</span><span class="s2">,</span>
    <span class="s1">datetime</span><span class="s2">,</span>
    <span class="s1">timedelta</span><span class="s2">,</span>
    <span class="s1">timezone</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">decimal </span><span class="s2">import </span><span class="s1">Decimal</span>
<span class="s2">import </span><span class="s1">locale</span>

<span class="s2">from </span><span class="s1">dateutil.parser </span><span class="s2">import </span><span class="s1">parse</span>
<span class="s2">from </span><span class="s1">dateutil.tz.tz </span><span class="s2">import </span><span class="s1">tzoffset</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pytest</span>
<span class="s2">import </span><span class="s1">pytz</span>

<span class="s2">from </span><span class="s1">pandas._libs </span><span class="s2">import </span><span class="s1">tslib</span>
<span class="s2">from </span><span class="s1">pandas._libs.tslibs </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">iNaT</span><span class="s2">,</span>
    <span class="s1">parsing</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.errors </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">OutOfBoundsDatetime</span><span class="s2">,</span>
    <span class="s1">OutOfBoundsTimedelta</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">import </span><span class="s1">pandas.util._test_decorators </span><span class="s2">as </span><span class="s1">td</span>

<span class="s2">from </span><span class="s1">pandas.core.dtypes.common </span><span class="s2">import </span><span class="s1">is_datetime64_ns_dtype</span>

<span class="s2">import </span><span class="s1">pandas </span><span class="s2">as </span><span class="s1">pd</span>
<span class="s2">from </span><span class="s1">pandas </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">DataFrame</span><span class="s2">,</span>
    <span class="s1">DatetimeIndex</span><span class="s2">,</span>
    <span class="s1">Index</span><span class="s2">,</span>
    <span class="s1">NaT</span><span class="s2">,</span>
    <span class="s1">Series</span><span class="s2">,</span>
    <span class="s1">Timestamp</span><span class="s2">,</span>
    <span class="s1">date_range</span><span class="s2">,</span>
    <span class="s1">isna</span><span class="s2">,</span>
    <span class="s1">to_datetime</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">import </span><span class="s1">pandas._testing </span><span class="s2">as </span><span class="s1">tm</span>
<span class="s2">from </span><span class="s1">pandas.core.arrays </span><span class="s2">import </span><span class="s1">DatetimeArray</span>
<span class="s2">from </span><span class="s1">pandas.core.tools </span><span class="s2">import </span><span class="s1">datetimes </span><span class="s2">as </span><span class="s1">tools</span>
<span class="s2">from </span><span class="s1">pandas.core.tools.datetimes </span><span class="s2">import </span><span class="s1">start_caching_at</span>

<span class="s1">PARSING_ERR_MSG = (</span>
    <span class="s3">r&quot;You might want to try:\n&quot;</span>
    <span class="s3">r&quot;    - passing `format` if your strings have a consistent format;\n&quot;</span>
    <span class="s3">r&quot;    - passing `format=\'ISO8601\'` if your strings are all ISO8601 &quot;</span>
    <span class="s3">r&quot;but not necessarily in exactly the same format;\n&quot;</span>
    <span class="s3">r&quot;    - passing `format=\'mixed\'`, and the format will be inferred &quot;</span>
    <span class="s3">r&quot;for each element individually. You might want to use `dayfirst` &quot;</span>
    <span class="s3">r&quot;alongside this.&quot;</span>
<span class="s1">)</span>


<span class="s1">@pytest.fixture(params=[</span><span class="s2">True, False</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">cache(request):</span>
    <span class="s0">&quot;&quot;&quot; 
    cache keyword to pass to to_datetime. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">request.param</span>


<span class="s2">class </span><span class="s1">TestTimeConversionFormats:</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;readonly&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_readonly(self</span><span class="s2">, </span><span class="s1">readonly):</span>
        <span class="s4"># GH#34857</span>
        <span class="s1">arr = np.array([]</span><span class="s2">, </span><span class="s1">dtype=object)</span>
        <span class="s2">if </span><span class="s1">readonly:</span>
            <span class="s1">arr.setflags(write=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">result = to_datetime(arr)</span>
        <span class="s1">expected = to_datetime([])</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;format, expected&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">[</span>
                <span class="s3">&quot;%d/%m/%Y&quot;</span><span class="s2">,</span>
                <span class="s1">[Timestamp(</span><span class="s3">&quot;20000101&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;20000201&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;20000301&quot;</span><span class="s1">)]</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s3">&quot;%m/%d/%Y&quot;</span><span class="s2">,</span>
                <span class="s1">[Timestamp(</span><span class="s3">&quot;20000101&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;20000102&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;20000103&quot;</span><span class="s1">)]</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_format(self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">index_or_series</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s1">expected):</span>
        <span class="s1">values = index_or_series([</span><span class="s3">&quot;1/1/2000&quot;</span><span class="s2">, </span><span class="s3">&quot;1/2/2000&quot;</span><span class="s2">, </span><span class="s3">&quot;1/3/2000&quot;</span><span class="s1">])</span>
        <span class="s1">result = to_datetime(values</span><span class="s2">, </span><span class="s1">format=format</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected = index_or_series(expected)</span>
        <span class="s2">if </span><span class="s1">isinstance(expected</span><span class="s2">, </span><span class="s1">Series):</span>
            <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;arg, expected, format&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s3">&quot;1/1/2000&quot;</span><span class="s2">, </span><span class="s3">&quot;20000101&quot;</span><span class="s2">, </span><span class="s3">&quot;%d/%m/%Y&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;1/1/2000&quot;</span><span class="s2">, </span><span class="s3">&quot;20000101&quot;</span><span class="s2">, </span><span class="s3">&quot;%m/%d/%Y&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;1/2/2000&quot;</span><span class="s2">, </span><span class="s3">&quot;20000201&quot;</span><span class="s2">, </span><span class="s3">&quot;%d/%m/%Y&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;1/2/2000&quot;</span><span class="s2">, </span><span class="s3">&quot;20000102&quot;</span><span class="s2">, </span><span class="s3">&quot;%m/%d/%Y&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;1/3/2000&quot;</span><span class="s2">, </span><span class="s3">&quot;20000301&quot;</span><span class="s2">, </span><span class="s3">&quot;%d/%m/%Y&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;1/3/2000&quot;</span><span class="s2">, </span><span class="s3">&quot;20000103&quot;</span><span class="s2">, </span><span class="s3">&quot;%m/%d/%Y&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_format_scalar(self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">format):</span>
        <span class="s1">result = to_datetime(arg</span><span class="s2">, </span><span class="s1">format=format</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected = Timestamp(expected)</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_format_YYYYMMDD(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s1">ser = Series([</span><span class="s5">19801222</span><span class="s2">, </span><span class="s5">19801222</span><span class="s1">] + [</span><span class="s5">19810105</span><span class="s1">] * </span><span class="s5">5</span><span class="s1">)</span>
        <span class="s1">expected = Series([Timestamp(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">ser.apply(str)])</span>

        <span class="s1">result = to_datetime(ser</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%Y%m%d&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = to_datetime(ser.apply(str)</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%Y%m%d&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_format_YYYYMMDD_with_nat(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># Explicit cast to float to explicit cast when setting np.nan</span>
        <span class="s1">ser = Series([</span><span class="s5">19801222</span><span class="s2">, </span><span class="s5">19801222</span><span class="s1">] + [</span><span class="s5">19810105</span><span class="s1">] * </span><span class="s5">5</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;float&quot;</span><span class="s1">)</span>
        <span class="s4"># with NaT</span>
        <span class="s1">expected = Series(</span>
            <span class="s1">[Timestamp(</span><span class="s3">&quot;19801222&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;19801222&quot;</span><span class="s1">)] + [Timestamp(</span><span class="s3">&quot;19810105&quot;</span><span class="s1">)] * </span><span class="s5">5</span>
        <span class="s1">)</span>
        <span class="s1">expected[</span><span class="s5">2</span><span class="s1">] = np.nan</span>
        <span class="s1">ser[</span><span class="s5">2</span><span class="s1">] = np.nan</span>

        <span class="s1">result = to_datetime(ser</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%Y%m%d&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s4"># string with NaT</span>
        <span class="s1">ser2 = ser.apply(str)</span>
        <span class="s1">ser2[</span><span class="s5">2</span><span class="s1">] = </span><span class="s3">&quot;nat&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(</span>
            <span class="s1">ValueError</span><span class="s2">,</span>
            <span class="s1">match=(</span>
                <span class="s3">'unconverted data remains when parsing with format &quot;%Y%m%d&quot;: &quot;.0&quot;, '</span>
                <span class="s3">&quot;at position 0&quot;</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">):</span>
            <span class="s4"># https://github.com/pandas-dev/pandas/issues/50051</span>
            <span class="s1">to_datetime(ser2</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%Y%m%d&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_format_YYYYMM_with_nat(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># https://github.com/pandas-dev/pandas/issues/50237</span>
        <span class="s4"># Explicit cast to float to explicit cast when setting np.nan</span>
        <span class="s1">ser = Series([</span><span class="s5">198012</span><span class="s2">, </span><span class="s5">198012</span><span class="s1">] + [</span><span class="s5">198101</span><span class="s1">] * </span><span class="s5">5</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;float&quot;</span><span class="s1">)</span>
        <span class="s1">expected = Series(</span>
            <span class="s1">[Timestamp(</span><span class="s3">&quot;19801201&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;19801201&quot;</span><span class="s1">)] + [Timestamp(</span><span class="s3">&quot;19810101&quot;</span><span class="s1">)] * </span><span class="s5">5</span>
        <span class="s1">)</span>
        <span class="s1">expected[</span><span class="s5">2</span><span class="s1">] = np.nan</span>
        <span class="s1">ser[</span><span class="s5">2</span><span class="s1">] = np.nan</span>
        <span class="s1">result = to_datetime(ser</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%Y%m&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_format_YYYYMMDD_ignore(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># coercion</span>
        <span class="s4"># GH 7930, GH 14487</span>
        <span class="s1">ser = Series([</span><span class="s5">20121231</span><span class="s2">, </span><span class="s5">20141231</span><span class="s2">, </span><span class="s5">99991231</span><span class="s1">])</span>
        <span class="s1">result = to_datetime(ser</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%Y%m%d&quot;</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected = Series(</span>
            <span class="s1">[</span><span class="s5">20121231</span><span class="s2">, </span><span class="s5">20141231</span><span class="s2">, </span><span class="s5">99991231</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">dtype=object</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_format_YYYYMMDD_ignore_with_outofbounds(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># https://github.com/pandas-dev/pandas/issues/26493</span>
        <span class="s1">result = to_datetime(</span>
            <span class="s1">[</span><span class="s3">&quot;15010101&quot;</span><span class="s2">, </span><span class="s3">&quot;20150101&quot;</span><span class="s2">, </span><span class="s1">np.nan]</span><span class="s2">,</span>
            <span class="s1">format=</span><span class="s3">&quot;%Y%m%d&quot;</span><span class="s2">,</span>
            <span class="s1">errors=</span><span class="s3">&quot;ignore&quot;</span><span class="s2">,</span>
            <span class="s1">cache=cache</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">expected = Index([</span><span class="s3">&quot;15010101&quot;</span><span class="s2">, </span><span class="s3">&quot;20150101&quot;</span><span class="s2">, </span><span class="s1">np.nan])</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_format_YYYYMMDD_coercion(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># coercion</span>
        <span class="s4"># GH 7930</span>
        <span class="s1">ser = Series([</span><span class="s5">20121231</span><span class="s2">, </span><span class="s5">20141231</span><span class="s2">, </span><span class="s5">99991231</span><span class="s1">])</span>
        <span class="s1">result = to_datetime(ser</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%Y%m%d&quot;</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected = Series([</span><span class="s3">&quot;20121231&quot;</span><span class="s2">, </span><span class="s3">&quot;20141231&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;M8[ns]&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;input_s&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s4"># Null values with Strings</span>
            <span class="s1">[</span><span class="s3">&quot;19801222&quot;</span><span class="s2">, </span><span class="s3">&quot;20010112&quot;</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;19801222&quot;</span><span class="s2">, </span><span class="s3">&quot;20010112&quot;</span><span class="s2">, </span><span class="s1">np.nan]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;19801222&quot;</span><span class="s2">, </span><span class="s3">&quot;20010112&quot;</span><span class="s2">, </span><span class="s1">NaT]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;19801222&quot;</span><span class="s2">, </span><span class="s3">&quot;20010112&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s4"># Null values with Integers</span>
            <span class="s1">[</span><span class="s5">19801222</span><span class="s2">, </span><span class="s5">20010112</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s5">19801222</span><span class="s2">, </span><span class="s5">20010112</span><span class="s2">, </span><span class="s1">np.nan]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s5">19801222</span><span class="s2">, </span><span class="s5">20010112</span><span class="s2">, </span><span class="s1">NaT]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s5">19801222</span><span class="s2">, </span><span class="s5">20010112</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_format_YYYYMMDD_with_none(self</span><span class="s2">, </span><span class="s1">input_s):</span>
        <span class="s4"># GH 30011</span>
        <span class="s4"># format='%Y%m%d'</span>
        <span class="s4"># with None</span>
        <span class="s1">expected = Series([Timestamp(</span><span class="s3">&quot;19801222&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;20010112&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">NaT])</span>
        <span class="s1">result = Series(to_datetime(input_s</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%Y%m%d&quot;</span><span class="s1">))</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;input_s, expected&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s4"># NaN before strings with invalid date values</span>
            <span class="s1">[</span>
                <span class="s1">Series([</span><span class="s3">&quot;19801222&quot;</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s3">&quot;20010012&quot;</span><span class="s2">, </span><span class="s3">&quot;10019999&quot;</span><span class="s1">])</span><span class="s2">,</span>
                <span class="s1">Series([Timestamp(</span><span class="s3">&quot;19801222&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan])</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s4"># NaN after strings with invalid date values</span>
            <span class="s1">[</span>
                <span class="s1">Series([</span><span class="s3">&quot;19801222&quot;</span><span class="s2">, </span><span class="s3">&quot;20010012&quot;</span><span class="s2">, </span><span class="s3">&quot;10019999&quot;</span><span class="s2">, </span><span class="s1">np.nan])</span><span class="s2">,</span>
                <span class="s1">Series([Timestamp(</span><span class="s3">&quot;19801222&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan])</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s4"># NaN before integers with invalid date values</span>
            <span class="s1">[</span>
                <span class="s1">Series([</span><span class="s5">20190813</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s5">20010012</span><span class="s2">, </span><span class="s5">20019999</span><span class="s1">])</span><span class="s2">,</span>
                <span class="s1">Series([Timestamp(</span><span class="s3">&quot;20190813&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan])</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s4"># NaN after integers with invalid date values</span>
            <span class="s1">[</span>
                <span class="s1">Series([</span><span class="s5">20190813</span><span class="s2">, </span><span class="s5">20010012</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s5">20019999</span><span class="s1">])</span><span class="s2">,</span>
                <span class="s1">Series([Timestamp(</span><span class="s3">&quot;20190813&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan])</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_format_YYYYMMDD_overflow(self</span><span class="s2">, </span><span class="s1">input_s</span><span class="s2">, </span><span class="s1">expected):</span>
        <span class="s4"># GH 25512</span>
        <span class="s4"># format='%Y%m%d', errors='coerce'</span>
        <span class="s1">result = to_datetime(input_s</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%Y%m%d&quot;</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;data, format, expected&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">([pd.NA]</span><span class="s2">, </span><span class="s3">&quot;%Y%m%d%H%M%S&quot;</span><span class="s2">, </span><span class="s1">DatetimeIndex([</span><span class="s3">&quot;NaT&quot;</span><span class="s1">]))</span><span class="s2">,</span>
            <span class="s1">([pd.NA]</span><span class="s2">, None, </span><span class="s1">DatetimeIndex([</span><span class="s3">&quot;NaT&quot;</span><span class="s1">]))</span><span class="s2">,</span>
            <span class="s1">(</span>
                <span class="s1">[pd.NA</span><span class="s2">, </span><span class="s3">&quot;20210202202020&quot;</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s3">&quot;%Y%m%d%H%M%S&quot;</span><span class="s2">,</span>
                <span class="s1">DatetimeIndex([</span><span class="s3">&quot;NaT&quot;</span><span class="s2">, </span><span class="s3">&quot;2021-02-02 20:20:20&quot;</span><span class="s1">])</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">([</span><span class="s3">&quot;201010&quot;</span><span class="s2">, </span><span class="s1">pd.NA]</span><span class="s2">, </span><span class="s3">&quot;%y%m%d&quot;</span><span class="s2">, </span><span class="s1">DatetimeIndex([</span><span class="s3">&quot;2020-10-10&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s1">]))</span><span class="s2">,</span>
            <span class="s1">([</span><span class="s3">&quot;201010&quot;</span><span class="s2">, </span><span class="s1">pd.NA]</span><span class="s2">, </span><span class="s3">&quot;%d%m%y&quot;</span><span class="s2">, </span><span class="s1">DatetimeIndex([</span><span class="s3">&quot;2010-10-20&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s1">]))</span><span class="s2">,</span>
            <span class="s1">([</span><span class="s2">None, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">pd.NA]</span><span class="s2">, None, </span><span class="s1">DatetimeIndex([</span><span class="s3">&quot;NaT&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s1">]))</span><span class="s2">,</span>
            <span class="s1">([</span><span class="s2">None, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">pd.NA]</span><span class="s2">, </span><span class="s3">&quot;%Y%m%d&quot;</span><span class="s2">, </span><span class="s1">DatetimeIndex([</span><span class="s3">&quot;NaT&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s1">]))</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_with_NA(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s1">expected):</span>
        <span class="s4"># GH#42957</span>
        <span class="s1">result = to_datetime(data</span><span class="s2">, </span><span class="s1">format=format)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_with_NA_with_warning(self):</span>
        <span class="s4"># GH#42957</span>
        <span class="s1">result = to_datetime([</span><span class="s3">&quot;201010&quot;</span><span class="s2">, </span><span class="s1">pd.NA])</span>
        <span class="s1">expected = DatetimeIndex([</span><span class="s3">&quot;2010-10-20&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s1">])</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_format_integer(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># GH 10178</span>
        <span class="s1">ser = Series([</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">2001</span><span class="s2">, </span><span class="s5">2002</span><span class="s1">])</span>
        <span class="s1">expected = Series([Timestamp(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">ser.apply(str)])</span>

        <span class="s1">result = to_datetime(ser</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%Y&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">ser = Series([</span><span class="s5">200001</span><span class="s2">, </span><span class="s5">200105</span><span class="s2">, </span><span class="s5">200206</span><span class="s1">])</span>
        <span class="s1">expected = Series([Timestamp(x[:</span><span class="s5">4</span><span class="s1">] + </span><span class="s3">&quot;-&quot; </span><span class="s1">+ x[</span><span class="s5">4</span><span class="s1">:]) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">ser.apply(str)])</span>

        <span class="s1">result = to_datetime(ser</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%Y%m&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;int_date, expected&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s4"># valid date, length == 8</span>
            <span class="s1">[</span><span class="s5">20121030</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2012</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">30</span><span class="s1">)]</span><span class="s2">,</span>
            <span class="s4"># short valid date, length == 6</span>
            <span class="s1">[</span><span class="s5">199934</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">1999</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)]</span><span class="s2">,</span>
            <span class="s4"># long integer date partially parsed to datetime(2012,1,1), length &gt; 8</span>
            <span class="s1">[</span><span class="s5">2012010101</span><span class="s2">, </span><span class="s5">2012010101</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s4"># invalid date partially parsed to datetime(2012,9,9), length == 8</span>
            <span class="s1">[</span><span class="s5">20129930</span><span class="s2">, </span><span class="s5">20129930</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s4"># short integer date partially parsed to datetime(2012,9,9), length &lt; 8</span>
            <span class="s1">[</span><span class="s5">2012993</span><span class="s2">, </span><span class="s5">2012993</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s4"># short invalid date, length == 4</span>
            <span class="s1">[</span><span class="s5">2121</span><span class="s2">, </span><span class="s5">2121</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_int_to_datetime_format_YYYYMMDD_typeerror(self</span><span class="s2">, </span><span class="s1">int_date</span><span class="s2">, </span><span class="s1">expected):</span>
        <span class="s4"># GH 26583</span>
        <span class="s1">result = to_datetime(int_date</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%Y%m%d&quot;</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;ignore&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_format_microsecond(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s1">month_abbr = calendar.month_abbr[</span><span class="s5">4</span><span class="s1">]</span>
        <span class="s1">val = </span><span class="s3">f&quot;01-</span><span class="s2">{</span><span class="s1">month_abbr</span><span class="s2">}</span><span class="s3">-2011 00:00:01.978&quot;</span>

        <span class="s1">format = </span><span class="s3">&quot;%d-%b-%Y %H:%M:%S.%f&quot;</span>
        <span class="s1">result = to_datetime(val</span><span class="s2">, </span><span class="s1">format=format</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">exp = datetime.strptime(val</span><span class="s2">, </span><span class="s1">format)</span>
        <span class="s2">assert </span><span class="s1">result == exp</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;value, format, dt&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s3">&quot;01/10/2010 15:20&quot;</span><span class="s2">, </span><span class="s3">&quot;%m/%d/%Y %H:%M&quot;</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;2010-01-10 15:20&quot;</span><span class="s1">)]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;01/10/2010 05:43&quot;</span><span class="s2">, </span><span class="s3">&quot;%m/%d/%Y %I:%M&quot;</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;2010-01-10 05:43&quot;</span><span class="s1">)]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s3">&quot;01/10/2010 13:56:01&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;%m/%d/%Y %H:%M:%S&quot;</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2010-01-10 13:56:01&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s4"># The 3 tests below are locale-dependent.</span>
            <span class="s4"># They pass, except when the machine locale is zh_CN or it_IT .</span>
            <span class="s1">pytest.param(</span>
                <span class="s3">&quot;01/10/2010 08:14 PM&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;%m/%d/%Y %I:%M %p&quot;</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2010-01-10 20:14&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">marks=pytest.mark.xfail(</span>
                    <span class="s1">locale.getlocale()[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;zh_CN&quot;</span><span class="s2">, </span><span class="s3">&quot;it_IT&quot;</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">reason=</span><span class="s3">&quot;fail on a CI build with LC_ALL=zh_CN.utf8/it_IT.utf8&quot;</span><span class="s2">,</span>
                    <span class="s1">strict=</span><span class="s2">False,</span>
                <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">pytest.param(</span>
                <span class="s3">&quot;01/10/2010 07:40 AM&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;%m/%d/%Y %I:%M %p&quot;</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2010-01-10 07:40&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">marks=pytest.mark.xfail(</span>
                    <span class="s1">locale.getlocale()[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;zh_CN&quot;</span><span class="s2">, </span><span class="s3">&quot;it_IT&quot;</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">reason=</span><span class="s3">&quot;fail on a CI build with LC_ALL=zh_CN.utf8/it_IT.utf8&quot;</span><span class="s2">,</span>
                    <span class="s1">strict=</span><span class="s2">False,</span>
                <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">pytest.param(</span>
                <span class="s3">&quot;01/10/2010 09:12:56 AM&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;%m/%d/%Y %I:%M:%S %p&quot;</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2010-01-10 09:12:56&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">marks=pytest.mark.xfail(</span>
                    <span class="s1">locale.getlocale()[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;zh_CN&quot;</span><span class="s2">, </span><span class="s3">&quot;it_IT&quot;</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">reason=</span><span class="s3">&quot;fail on a CI build with LC_ALL=zh_CN.utf8/it_IT.utf8&quot;</span><span class="s2">,</span>
                    <span class="s1">strict=</span><span class="s2">False,</span>
                <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_format_time(self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s1">dt):</span>
        <span class="s2">assert </span><span class="s1">to_datetime(value</span><span class="s2">, </span><span class="s1">format=format</span><span class="s2">, </span><span class="s1">cache=cache) == dt</span>

    <span class="s1">@td.skip_if_not_us_locale</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_with_non_exact(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># GH 10834</span>
        <span class="s4"># 8904</span>
        <span class="s4"># exact kw</span>
        <span class="s1">ser = Series(</span>
            <span class="s1">[</span><span class="s3">&quot;19MAY11&quot;</span><span class="s2">, </span><span class="s3">&quot;foobar19MAY11&quot;</span><span class="s2">, </span><span class="s3">&quot;19MAY11:00:00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;19MAY11 00:00:00Z&quot;</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">result = to_datetime(ser</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%d%b%y&quot;</span><span class="s2">, </span><span class="s1">exact=</span><span class="s2">False, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected = to_datetime(</span>
            <span class="s1">ser.str.extract(</span><span class="s3">r&quot;(\d+\w+\d+)&quot;</span><span class="s2">, </span><span class="s1">expand=</span><span class="s2">False</span><span class="s1">)</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%d%b%y&quot;</span><span class="s2">, </span><span class="s1">cache=cache</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;format, expected&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s3">&quot;%Y-%m-%d&quot;</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">3</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;%Y-%d-%m&quot;</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;%Y-%m-%d %H&quot;</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">12</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;%Y-%d-%m %H&quot;</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">12</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;%Y-%m-%d %H:%M&quot;</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">12</span><span class="s2">, </span><span class="s5">34</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;%Y-%d-%m %H:%M&quot;</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">12</span><span class="s2">, </span><span class="s5">34</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;%Y-%m-%d %H:%M:%S&quot;</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">12</span><span class="s2">, </span><span class="s5">34</span><span class="s2">, </span><span class="s5">56</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;%Y-%d-%m %H:%M:%S&quot;</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">12</span><span class="s2">, </span><span class="s5">34</span><span class="s2">, </span><span class="s5">56</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;%Y-%m-%d %H:%M:%S.%f&quot;</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">12</span><span class="s2">, </span><span class="s5">34</span><span class="s2">, </span><span class="s5">56</span><span class="s2">, </span><span class="s5">123456</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;%Y-%d-%m %H:%M:%S.%f&quot;</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">12</span><span class="s2">, </span><span class="s5">34</span><span class="s2">, </span><span class="s5">56</span><span class="s2">, </span><span class="s5">123456</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span>
                <span class="s3">&quot;%Y-%m-%d %H:%M:%S.%f%z&quot;</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">12</span><span class="s2">, </span><span class="s5">34</span><span class="s2">, </span><span class="s5">56</span><span class="s2">, </span><span class="s5">123456</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;UTC+01:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span>
                <span class="s3">&quot;%Y-%d-%m %H:%M:%S.%f%z&quot;</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">12</span><span class="s2">, </span><span class="s5">34</span><span class="s2">, </span><span class="s5">56</span><span class="s2">, </span><span class="s5">123456</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;UTC+01:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_non_exact_doesnt_parse_whole_string(self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s1">expected):</span>
        <span class="s4"># https://github.com/pandas-dev/pandas/issues/50412</span>
        <span class="s4"># the formats alternate between ISO8601 and non-ISO8601 to check both paths</span>
        <span class="s1">result = to_datetime(</span>
            <span class="s3">&quot;2000-01-03 12:34:56.123456+01:00&quot;</span><span class="s2">, </span><span class="s1">format=format</span><span class="s2">, </span><span class="s1">exact=</span><span class="s2">False</span>
        <span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;arg&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s3">&quot;2012-01-01 09:00:00.000000001&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;2012-01-01 09:00:00.000001&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;2012-01-01 09:00:00.001&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;2012-01-01 09:00:00.001000&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;2012-01-01 09:00:00.001000000&quot;</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_parse_nanoseconds_with_formula(self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">arg):</span>
        <span class="s4"># GH8989</span>
        <span class="s4"># truncating the nanoseconds when a format was provided</span>
        <span class="s1">expected = to_datetime(arg</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">result = to_datetime(arg</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%Y-%m-%d %H:%M:%S.%f&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;value,fmt,expected&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s3">&quot;2009324&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y%W%w&quot;</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;2009-08-13&quot;</span><span class="s1">)]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;2013020&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y%U%w&quot;</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;2013-01-13&quot;</span><span class="s1">)]</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_format_weeks(self</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">fmt</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s2">assert </span><span class="s1">to_datetime(value</span><span class="s2">, </span><span class="s1">format=fmt</span><span class="s2">, </span><span class="s1">cache=cache) == expected</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;fmt,dates,expected_dates&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">[</span>
                <span class="s3">&quot;%Y-%m-%d %H:%M:%S %Z&quot;</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s3">&quot;2010-01-01 12:00:00 UTC&quot;</span><span class="s1">] * </span><span class="s5">2</span><span class="s2">,</span>
                <span class="s1">[Timestamp(</span><span class="s3">&quot;2010-01-01 12:00:00&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;UTC&quot;</span><span class="s1">)] * </span><span class="s5">2</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s3">&quot;%Y-%m-%d %H:%M:%S%z&quot;</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s3">&quot;2010-01-01 12:00:00+0100&quot;</span><span class="s1">] * </span><span class="s5">2</span><span class="s2">,</span>
                <span class="s1">[</span>
                    <span class="s1">Timestamp(</span>
                        <span class="s3">&quot;2010-01-01 12:00:00&quot;</span><span class="s2">, </span><span class="s1">tzinfo=timezone(timedelta(minutes=</span><span class="s5">60</span><span class="s1">))</span>
                    <span class="s1">)</span>
                <span class="s1">]</span>
                <span class="s1">* </span><span class="s5">2</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s3">&quot;%Y-%m-%d %H:%M:%S %z&quot;</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s3">&quot;2010-01-01 12:00:00 +0100&quot;</span><span class="s1">] * </span><span class="s5">2</span><span class="s2">,</span>
                <span class="s1">[</span>
                    <span class="s1">Timestamp(</span>
                        <span class="s3">&quot;2010-01-01 12:00:00&quot;</span><span class="s2">, </span><span class="s1">tzinfo=timezone(timedelta(minutes=</span><span class="s5">60</span><span class="s1">))</span>
                    <span class="s1">)</span>
                <span class="s1">]</span>
                <span class="s1">* </span><span class="s5">2</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s3">&quot;%Y-%m-%d %H:%M:%S %z&quot;</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s3">&quot;2010-01-01 12:00:00 Z&quot;</span><span class="s2">, </span><span class="s3">&quot;2010-01-01 12:00:00 Z&quot;</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[</span>
                    <span class="s1">Timestamp(</span>
                        <span class="s3">&quot;2010-01-01 12:00:00&quot;</span><span class="s2">, </span><span class="s1">tzinfo=pytz.FixedOffset(</span><span class="s5">0</span><span class="s1">)</span>
                    <span class="s1">)</span><span class="s2">,  </span><span class="s4"># pytz coerces to UTC</span>
                    <span class="s1">Timestamp(</span><span class="s3">&quot;2010-01-01 12:00:00&quot;</span><span class="s2">, </span><span class="s1">tzinfo=pytz.FixedOffset(</span><span class="s5">0</span><span class="s1">))</span><span class="s2">,</span>
                <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_parse_tzname_or_tzoffset(self</span><span class="s2">, </span><span class="s1">fmt</span><span class="s2">, </span><span class="s1">dates</span><span class="s2">, </span><span class="s1">expected_dates):</span>
        <span class="s4"># GH 13486</span>
        <span class="s1">result = to_datetime(dates</span><span class="s2">, </span><span class="s1">format=fmt)</span>
        <span class="s1">expected = Index(expected_dates)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;fmt,dates,expected_dates&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">[</span>
                <span class="s3">&quot;%Y-%m-%d %H:%M:%S %Z&quot;</span><span class="s2">,</span>
                <span class="s1">[</span>
                    <span class="s3">&quot;2010-01-01 12:00:00 UTC&quot;</span><span class="s2">,</span>
                    <span class="s3">&quot;2010-01-01 12:00:00 GMT&quot;</span><span class="s2">,</span>
                    <span class="s3">&quot;2010-01-01 12:00:00 US/Pacific&quot;</span><span class="s2">,</span>
                <span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[</span>
                    <span class="s1">Timestamp(</span><span class="s3">&quot;2010-01-01 12:00:00&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;UTC&quot;</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">Timestamp(</span><span class="s3">&quot;2010-01-01 12:00:00&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;GMT&quot;</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">Timestamp(</span><span class="s3">&quot;2010-01-01 12:00:00&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;US/Pacific&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s3">&quot;%Y-%m-%d %H:%M:%S %z&quot;</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s3">&quot;2010-01-01 12:00:00 +0100&quot;</span><span class="s2">, </span><span class="s3">&quot;2010-01-01 12:00:00 -0100&quot;</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[</span>
                    <span class="s1">Timestamp(</span>
                        <span class="s3">&quot;2010-01-01 12:00:00&quot;</span><span class="s2">, </span><span class="s1">tzinfo=timezone(timedelta(minutes=</span><span class="s5">60</span><span class="s1">))</span>
                    <span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">Timestamp(</span>
                        <span class="s3">&quot;2010-01-01 12:00:00&quot;</span><span class="s2">, </span><span class="s1">tzinfo=timezone(timedelta(minutes=-</span><span class="s5">60</span><span class="s1">))</span>
                    <span class="s1">)</span><span class="s2">,</span>
                <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_parse_tzname_or_tzoffset_utc_false_deprecated(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">fmt</span><span class="s2">, </span><span class="s1">dates</span><span class="s2">, </span><span class="s1">expected_dates</span>
    <span class="s1">):</span>
        <span class="s4"># GH 13486, 50887</span>
        <span class="s1">msg = </span><span class="s3">&quot;parsing datetimes with mixed time zones will raise an error&quot;</span>
        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">result = to_datetime(dates</span><span class="s2">, </span><span class="s1">format=fmt)</span>
        <span class="s1">expected = Index(expected_dates)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_parse_tzname_or_tzoffset_different_tz_to_utc(self):</span>
        <span class="s4"># GH 32792</span>
        <span class="s1">dates = [</span>
            <span class="s3">&quot;2010-01-01 12:00:00 +0100&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;2010-01-01 12:00:00 -0100&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;2010-01-01 12:00:00 +0300&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;2010-01-01 12:00:00 +0400&quot;</span><span class="s2">,</span>
        <span class="s1">]</span>
        <span class="s1">expected_dates = [</span>
            <span class="s3">&quot;2010-01-01 11:00:00+00:00&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;2010-01-01 13:00:00+00:00&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;2010-01-01 09:00:00+00:00&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;2010-01-01 08:00:00+00:00&quot;</span><span class="s2">,</span>
        <span class="s1">]</span>
        <span class="s1">fmt = </span><span class="s3">&quot;%Y-%m-%d %H:%M:%S %z&quot;</span>

        <span class="s1">result = to_datetime(dates</span><span class="s2">, </span><span class="s1">format=fmt</span><span class="s2">, </span><span class="s1">utc=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">expected = DatetimeIndex(expected_dates)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;offset&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;+0&quot;</span><span class="s2">, </span><span class="s3">&quot;-1foo&quot;</span><span class="s2">, </span><span class="s3">&quot;UTCbar&quot;</span><span class="s2">, </span><span class="s3">&quot;:10&quot;</span><span class="s2">, </span><span class="s3">&quot;+01:000:01&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_parse_timezone_malformed(self</span><span class="s2">, </span><span class="s1">offset):</span>
        <span class="s1">fmt = </span><span class="s3">&quot;%Y-%m-%d %H:%M:%S %z&quot;</span>
        <span class="s1">date = </span><span class="s3">&quot;2010-01-01 12:00:00 &quot; </span><span class="s1">+ offset</span>

        <span class="s1">msg = </span><span class="s3">&quot;|&quot;</span><span class="s1">.join(</span>
            <span class="s1">[</span>
                <span class="s3">r'^time data &quot;.*&quot; doesn\'t match format &quot;.*&quot;, at position 0. '</span>
                <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">PARSING_ERR_MSG</span><span class="s2">}</span><span class="s3">$&quot;</span><span class="s2">,</span>
                <span class="s3">r'^unconverted data remains when parsing with format &quot;.*&quot;: &quot;.*&quot;, '</span>
                <span class="s3">f&quot;at position 0. </span><span class="s2">{</span><span class="s1">PARSING_ERR_MSG</span><span class="s2">}</span><span class="s3">$&quot;</span><span class="s2">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime([date]</span><span class="s2">, </span><span class="s1">format=fmt)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_parse_timezone_keeps_name(self):</span>
        <span class="s4"># GH 21697</span>
        <span class="s1">fmt = </span><span class="s3">&quot;%Y-%m-%d %H:%M:%S %z&quot;</span>
        <span class="s1">arg = Index([</span><span class="s3">&quot;2010-01-01 12:00:00 Z&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;foo&quot;</span><span class="s1">)</span>
        <span class="s1">result = to_datetime(arg</span><span class="s2">, </span><span class="s1">format=fmt)</span>
        <span class="s1">expected = DatetimeIndex([</span><span class="s3">&quot;2010-01-01 12:00:00&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;UTC&quot;</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;foo&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">class </span><span class="s1">TestToDatetime:</span>
    <span class="s1">@pytest.mark.filterwarnings(</span><span class="s3">&quot;ignore:Could not infer format&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_overflow(self):</span>
        <span class="s4"># we should get an OutOfBoundsDatetime, NOT OverflowError</span>
        <span class="s4"># TODO: Timestamp raises ValueError(&quot;could not convert string to Timestamp&quot;)</span>
        <span class="s4">#  can we make these more consistent?</span>
        <span class="s1">arg = </span><span class="s3">&quot;08335394550&quot;</span>
        <span class="s1">msg = </span><span class="s3">'Parsing &quot;08335394550&quot; to datetime overflows, at position 0'</span>
        <span class="s2">with </span><span class="s1">pytest.raises(OutOfBoundsDatetime</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(arg)</span>

        <span class="s2">with </span><span class="s1">pytest.raises(OutOfBoundsDatetime</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime([arg])</span>

        <span class="s1">res = to_datetime(arg</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">res </span><span class="s2">is </span><span class="s1">NaT</span>
        <span class="s1">res = to_datetime([arg]</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(res</span><span class="s2">, </span><span class="s1">Index([NaT]))</span>

        <span class="s1">res = to_datetime(arg</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;ignore&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">isinstance(res</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">and </span><span class="s1">res == arg</span>
        <span class="s1">res = to_datetime([arg]</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;ignore&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(res</span><span class="s2">, </span><span class="s1">Index([arg]</span><span class="s2">, </span><span class="s1">dtype=object))</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_mixed_datetime_and_string(self):</span>
        <span class="s4"># GH#47018 adapted old doctest with new behavior</span>
        <span class="s1">d1 = datetime(</span><span class="s5">2020</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">17</span><span class="s2">, </span><span class="s1">tzinfo=timezone(-timedelta(hours=</span><span class="s5">1</span><span class="s1">)))</span>
        <span class="s1">d2 = datetime(</span><span class="s5">2020</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">18</span><span class="s2">, </span><span class="s1">tzinfo=timezone(-timedelta(hours=</span><span class="s5">1</span><span class="s1">)))</span>
        <span class="s1">res = to_datetime([</span><span class="s3">&quot;2020-01-01 17:00 -0100&quot;</span><span class="s2">, </span><span class="s1">d2])</span>
        <span class="s1">expected = to_datetime([d1</span><span class="s2">, </span><span class="s1">d2]).tz_convert(timezone(timedelta(minutes=-</span><span class="s5">60</span><span class="s1">)))</span>
        <span class="s1">tm.assert_index_equal(res</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;format&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;%Y-%m-%d&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%d-%m&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">ids=[</span><span class="s3">&quot;ISO8601&quot;</span><span class="s2">, </span><span class="s3">&quot;non-ISO8601&quot;</span><span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_mixed_date_and_string(self</span><span class="s2">, </span><span class="s1">format):</span>
        <span class="s4"># https://github.com/pandas-dev/pandas/issues/50108</span>
        <span class="s1">d1 = date(</span><span class="s5">2020</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">res = to_datetime([</span><span class="s3">&quot;2020-01-01&quot;</span><span class="s2">, </span><span class="s1">d1]</span><span class="s2">, </span><span class="s1">format=format)</span>
        <span class="s1">expected = DatetimeIndex([</span><span class="s3">&quot;2020-01-01&quot;</span><span class="s2">, </span><span class="s3">&quot;2020-01-02&quot;</span><span class="s1">])</span>
        <span class="s1">tm.assert_index_equal(res</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;fmt&quot;</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;%Y-%d-%m %H:%M:%S%z&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%d %H:%M:%S%z&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">ids=[</span><span class="s3">&quot;non-ISO8601 format&quot;</span><span class="s2">, </span><span class="s3">&quot;ISO8601 format&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;utc, args, expected&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">pytest.param(</span>
                <span class="s2">True,</span>
                <span class="s1">[</span><span class="s3">&quot;2000-01-01 01:00:00-08:00&quot;</span><span class="s2">, </span><span class="s3">&quot;2000-01-01 02:00:00-08:00&quot;</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">DatetimeIndex(</span>
                    <span class="s1">[</span><span class="s3">&quot;2000-01-01 09:00:00+00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;2000-01-01 10:00:00+00:00&quot;</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s1">dtype=</span><span class="s3">&quot;datetime64[ns, UTC]&quot;</span><span class="s2">,</span>
                <span class="s1">)</span><span class="s2">,</span>
                <span class="s1">id=</span><span class="s3">&quot;all tz-aware, with utc&quot;</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">pytest.param(</span>
                <span class="s2">False,</span>
                <span class="s1">[</span><span class="s3">&quot;2000-01-01 01:00:00+00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;2000-01-01 02:00:00+00:00&quot;</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">DatetimeIndex(</span>
                    <span class="s1">[</span><span class="s3">&quot;2000-01-01 01:00:00+00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;2000-01-01 02:00:00+00:00&quot;</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">)</span><span class="s2">,</span>
                <span class="s1">id=</span><span class="s3">&quot;all tz-aware, without utc&quot;</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">pytest.param(</span>
                <span class="s2">True,</span>
                <span class="s1">[</span><span class="s3">&quot;2000-01-01 01:00:00-08:00&quot;</span><span class="s2">, </span><span class="s3">&quot;2000-01-01 02:00:00+00:00&quot;</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">DatetimeIndex(</span>
                    <span class="s1">[</span><span class="s3">&quot;2000-01-01 09:00:00+00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;2000-01-01 02:00:00+00:00&quot;</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s1">dtype=</span><span class="s3">&quot;datetime64[ns, UTC]&quot;</span><span class="s2">,</span>
                <span class="s1">)</span><span class="s2">,</span>
                <span class="s1">id=</span><span class="s3">&quot;all tz-aware, mixed offsets, with utc&quot;</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">pytest.param(</span>
                <span class="s2">True,</span>
                <span class="s1">[</span><span class="s3">&quot;2000-01-01 01:00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;2000-01-01 02:00:00+00:00&quot;</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">DatetimeIndex(</span>
                    <span class="s1">[</span><span class="s3">&quot;2000-01-01 01:00:00+00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;2000-01-01 02:00:00+00:00&quot;</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s1">dtype=</span><span class="s3">&quot;datetime64[ns, UTC]&quot;</span><span class="s2">,</span>
                <span class="s1">)</span><span class="s2">,</span>
                <span class="s1">id=</span><span class="s3">&quot;tz-aware string, naive pydatetime, with utc&quot;</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;constructor&quot;</span><span class="s2">,</span>
        <span class="s1">[Timestamp</span><span class="s2">, lambda </span><span class="s1">x: Timestamp(x).to_pydatetime()]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_mixed_datetime_and_string_with_format(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">fmt</span><span class="s2">, </span><span class="s1">utc</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">constructor</span>
    <span class="s1">):</span>
        <span class="s4"># https://github.com/pandas-dev/pandas/issues/49298</span>
        <span class="s4"># https://github.com/pandas-dev/pandas/issues/50254</span>
        <span class="s4"># note: ISO8601 formats go down a fastpath, so we need to check both</span>
        <span class="s4"># a ISO8601 format and a non-ISO8601 one</span>
        <span class="s1">ts1 = constructor(args[</span><span class="s5">0</span><span class="s1">])</span>
        <span class="s1">ts2 = args[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">result = to_datetime([ts1</span><span class="s2">, </span><span class="s1">ts2]</span><span class="s2">, </span><span class="s1">format=fmt</span><span class="s2">, </span><span class="s1">utc=utc)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;fmt&quot;</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;%Y-%d-%m %H:%M:%S%z&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%d %H:%M:%S%z&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">ids=[</span><span class="s3">&quot;non-ISO8601 format&quot;</span><span class="s2">, </span><span class="s3">&quot;ISO8601 format&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;constructor&quot;</span><span class="s2">,</span>
        <span class="s1">[Timestamp</span><span class="s2">, lambda </span><span class="s1">x: Timestamp(x).to_pydatetime()]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_mixed_datetime_and_string_with_format_mixed_offsets_utc_false(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">fmt</span><span class="s2">, </span><span class="s1">constructor</span>
    <span class="s1">):</span>
        <span class="s4"># https://github.com/pandas-dev/pandas/issues/49298</span>
        <span class="s4"># https://github.com/pandas-dev/pandas/issues/50254</span>
        <span class="s4"># note: ISO8601 formats go down a fastpath, so we need to check both</span>
        <span class="s4"># a ISO8601 format and a non-ISO8601 one</span>
        <span class="s1">args = [</span><span class="s3">&quot;2000-01-01 01:00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;2000-01-01 02:00:00+00:00&quot;</span><span class="s1">]</span>
        <span class="s1">ts1 = constructor(args[</span><span class="s5">0</span><span class="s1">])</span>
        <span class="s1">ts2 = args[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">msg = </span><span class="s3">&quot;parsing datetimes with mixed time zones will raise an error&quot;</span>

        <span class="s1">expected = Index(</span>
            <span class="s1">[</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2000-01-01 01:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2000-01-01 02:00:00+0000&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;UTC&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">result = to_datetime([ts1</span><span class="s2">, </span><span class="s1">ts2]</span><span class="s2">, </span><span class="s1">format=fmt</span><span class="s2">, </span><span class="s1">utc=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;fmt, expected&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">pytest.param(</span>
                <span class="s3">&quot;%Y-%m-%d %H:%M:%S%z&quot;</span><span class="s2">,</span>
                <span class="s1">Index(</span>
                    <span class="s1">[</span>
                        <span class="s1">Timestamp(</span><span class="s3">&quot;2000-01-01 09:00:00+0100&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;UTC+01:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">Timestamp(</span><span class="s3">&quot;2000-01-02 02:00:00+0200&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;UTC+02:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">NaT</span><span class="s2">,</span>
                    <span class="s1">]</span>
                <span class="s1">)</span><span class="s2">,</span>
                <span class="s1">id=</span><span class="s3">&quot;ISO8601, non-UTC&quot;</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">pytest.param(</span>
                <span class="s3">&quot;%Y-%d-%m %H:%M:%S%z&quot;</span><span class="s2">,</span>
                <span class="s1">Index(</span>
                    <span class="s1">[</span>
                        <span class="s1">Timestamp(</span><span class="s3">&quot;2000-01-01 09:00:00+0100&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;UTC+01:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">Timestamp(</span><span class="s3">&quot;2000-02-01 02:00:00+0200&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;UTC+02:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">NaT</span><span class="s2">,</span>
                    <span class="s1">]</span>
                <span class="s1">)</span><span class="s2">,</span>
                <span class="s1">id=</span><span class="s3">&quot;non-ISO8601, non-UTC&quot;</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_mixed_offsets_with_none_tz(self</span><span class="s2">, </span><span class="s1">fmt</span><span class="s2">, </span><span class="s1">expected):</span>
        <span class="s4"># https://github.com/pandas-dev/pandas/issues/50071</span>
        <span class="s1">msg = </span><span class="s3">&quot;parsing datetimes with mixed time zones will raise an error&quot;</span>

        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">result = to_datetime(</span>
                <span class="s1">[</span><span class="s3">&quot;2000-01-01 09:00:00+01:00&quot;</span><span class="s2">, </span><span class="s3">&quot;2000-01-02 02:00:00+02:00&quot;</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">format=fmt</span><span class="s2">,</span>
                <span class="s1">utc=</span><span class="s2">False,</span>
            <span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;fmt, expected&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">pytest.param(</span>
                <span class="s3">&quot;%Y-%m-%d %H:%M:%S%z&quot;</span><span class="s2">,</span>
                <span class="s1">DatetimeIndex(</span>
                    <span class="s1">[</span><span class="s3">&quot;2000-01-01 08:00:00+00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;2000-01-02 00:00:00+00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s1">dtype=</span><span class="s3">&quot;datetime64[ns, UTC]&quot;</span><span class="s2">,</span>
                <span class="s1">)</span><span class="s2">,</span>
                <span class="s1">id=</span><span class="s3">&quot;ISO8601, UTC&quot;</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">pytest.param(</span>
                <span class="s3">&quot;%Y-%d-%m %H:%M:%S%z&quot;</span><span class="s2">,</span>
                <span class="s1">DatetimeIndex(</span>
                    <span class="s1">[</span><span class="s3">&quot;2000-01-01 08:00:00+00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;2000-02-01 00:00:00+00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s1">dtype=</span><span class="s3">&quot;datetime64[ns, UTC]&quot;</span><span class="s2">,</span>
                <span class="s1">)</span><span class="s2">,</span>
                <span class="s1">id=</span><span class="s3">&quot;non-ISO8601, UTC&quot;</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_mixed_offsets_with_none(self</span><span class="s2">, </span><span class="s1">fmt</span><span class="s2">, </span><span class="s1">expected):</span>
        <span class="s4"># https://github.com/pandas-dev/pandas/issues/50071</span>
        <span class="s1">result = to_datetime(</span>
            <span class="s1">[</span><span class="s3">&quot;2000-01-01 09:00:00+01:00&quot;</span><span class="s2">, </span><span class="s3">&quot;2000-01-02 02:00:00+02:00&quot;</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">format=fmt</span><span class="s2">,</span>
            <span class="s1">utc=</span><span class="s2">True,</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;fmt&quot;</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;%Y-%d-%m %H:%M:%S%z&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%d %H:%M:%S%z&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">ids=[</span><span class="s3">&quot;non-ISO8601 format&quot;</span><span class="s2">, </span><span class="s3">&quot;ISO8601 format&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;args&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">pytest.param(</span>
                <span class="s1">[</span><span class="s3">&quot;2000-01-01 01:00:00-08:00&quot;</span><span class="s2">, </span><span class="s3">&quot;2000-01-01 02:00:00-07:00&quot;</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">id=</span><span class="s3">&quot;all tz-aware, mixed timezones, without utc&quot;</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;constructor&quot;</span><span class="s2">,</span>
        <span class="s1">[Timestamp</span><span class="s2">, lambda </span><span class="s1">x: Timestamp(x).to_pydatetime()]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_mixed_datetime_and_string_with_format_raises(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">fmt</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">constructor</span>
    <span class="s1">):</span>
        <span class="s4"># https://github.com/pandas-dev/pandas/issues/49298</span>
        <span class="s4"># note: ISO8601 formats go down a fastpath, so we need to check both</span>
        <span class="s4"># a ISO8601 format and a non-ISO8601 one</span>
        <span class="s1">ts1 = constructor(args[</span><span class="s5">0</span><span class="s1">])</span>
        <span class="s1">ts2 = constructor(args[</span><span class="s5">1</span><span class="s1">])</span>
        <span class="s2">with </span><span class="s1">pytest.raises(</span>
            <span class="s1">ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;cannot be converted to datetime64 unless utc=True&quot;</span>
        <span class="s1">):</span>
            <span class="s1">to_datetime([ts1</span><span class="s2">, </span><span class="s1">ts2]</span><span class="s2">, </span><span class="s1">format=fmt</span><span class="s2">, </span><span class="s1">utc=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_np_str(self):</span>
        <span class="s4"># GH#32264</span>
        <span class="s4"># GH#48969</span>
        <span class="s1">value = np.str_(</span><span class="s3">&quot;2019-02-04 10:18:46.297000+0000&quot;</span><span class="s1">)</span>

        <span class="s1">ser = Series([value])</span>

        <span class="s1">exp = Timestamp(</span><span class="s3">&quot;2019-02-04 10:18:46.297000&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;UTC&quot;</span><span class="s1">)</span>

        <span class="s2">assert </span><span class="s1">to_datetime(value) == exp</span>
        <span class="s2">assert </span><span class="s1">to_datetime(ser.iloc[</span><span class="s5">0</span><span class="s1">]) == exp</span>

        <span class="s1">res = to_datetime([value])</span>
        <span class="s1">expected = Index([exp])</span>
        <span class="s1">tm.assert_index_equal(res</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">res = to_datetime(ser)</span>
        <span class="s1">expected = Series(expected)</span>
        <span class="s1">tm.assert_series_equal(res</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;s, _format, dt&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s3">&quot;2015-1-1&quot;</span><span class="s2">, </span><span class="s3">&quot;%G-%V-%u&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2014</span><span class="s2">, </span><span class="s5">12</span><span class="s2">, </span><span class="s5">29</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;2015-1-4&quot;</span><span class="s2">, </span><span class="s3">&quot;%G-%V-%u&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2015</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;2015-1-7&quot;</span><span class="s2">, </span><span class="s3">&quot;%G-%V-%u&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2015</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)]</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_iso_week_year_format(self</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">_format</span><span class="s2">, </span><span class="s1">dt):</span>
        <span class="s4"># See GH#16607</span>
        <span class="s2">assert </span><span class="s1">to_datetime(s</span><span class="s2">, </span><span class="s1">format=_format) == dt</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;msg, s, _format&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">[</span>
                <span class="s3">&quot;ISO week directive '%V' is incompatible with the year directive &quot;</span>
                <span class="s3">&quot;'%Y'. Use the ISO year '%G' instead.&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;1999 50&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;%Y %V&quot;</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s3">&quot;ISO year directive '%G' must be used with the ISO week directive &quot;</span>
                <span class="s3">&quot;'%V' and a weekday directive '%A', '%a', '%w', or '%u'.&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;1999 51&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;%G %V&quot;</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s3">&quot;ISO year directive '%G' must be used with the ISO week directive &quot;</span>
                <span class="s3">&quot;'%V' and a weekday directive '%A', '%a', '%w', or '%u'.&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;1999 Monday&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;%G %A&quot;</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s3">&quot;ISO year directive '%G' must be used with the ISO week directive &quot;</span>
                <span class="s3">&quot;'%V' and a weekday directive '%A', '%a', '%w', or '%u'.&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;1999 Mon&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;%G %a&quot;</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s3">&quot;ISO year directive '%G' must be used with the ISO week directive &quot;</span>
                <span class="s3">&quot;'%V' and a weekday directive '%A', '%a', '%w', or '%u'.&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;1999 6&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;%G %w&quot;</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s3">&quot;ISO year directive '%G' must be used with the ISO week directive &quot;</span>
                <span class="s3">&quot;'%V' and a weekday directive '%A', '%a', '%w', or '%u'.&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;1999 6&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;%G %u&quot;</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s3">&quot;ISO year directive '%G' must be used with the ISO week directive &quot;</span>
                <span class="s3">&quot;'%V' and a weekday directive '%A', '%a', '%w', or '%u'.&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;2051&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;%G&quot;</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s3">&quot;Day of the year directive '%j' is not compatible with ISO year &quot;</span>
                <span class="s3">&quot;directive '%G'. Use '%Y' instead.&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;1999 51 6 256&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;%G %V %u %j&quot;</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s3">&quot;ISO week directive '%V' is incompatible with the year directive &quot;</span>
                <span class="s3">&quot;'%Y'. Use the ISO year '%G' instead.&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;1999 51 Sunday&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;%Y %V %A&quot;</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s3">&quot;ISO week directive '%V' is incompatible with the year directive &quot;</span>
                <span class="s3">&quot;'%Y'. Use the ISO year '%G' instead.&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;1999 51 Sun&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;%Y %V %a&quot;</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s3">&quot;ISO week directive '%V' is incompatible with the year directive &quot;</span>
                <span class="s3">&quot;'%Y'. Use the ISO year '%G' instead.&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;1999 51 1&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;%Y %V %w&quot;</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s3">&quot;ISO week directive '%V' is incompatible with the year directive &quot;</span>
                <span class="s3">&quot;'%Y'. Use the ISO year '%G' instead.&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;1999 51 1&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;%Y %V %u&quot;</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s3">&quot;ISO week directive '%V' must be used with the ISO year directive &quot;</span>
                <span class="s3">&quot;'%G' and a weekday directive '%A', '%a', '%w', or '%u'.&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;20&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;%V&quot;</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s3">&quot;ISO week directive '%V' must be used with the ISO year directive &quot;</span>
                <span class="s3">&quot;'%G' and a weekday directive '%A', '%a', '%w', or '%u'.&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;1999 51 Sunday&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;%V %A&quot;</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s3">&quot;ISO week directive '%V' must be used with the ISO year directive &quot;</span>
                <span class="s3">&quot;'%G' and a weekday directive '%A', '%a', '%w', or '%u'.&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;1999 51 Sun&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;%V %a&quot;</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s3">&quot;ISO week directive '%V' must be used with the ISO year directive &quot;</span>
                <span class="s3">&quot;'%G' and a weekday directive '%A', '%a', '%w', or '%u'.&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;1999 51 1&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;%V %w&quot;</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s3">&quot;ISO week directive '%V' must be used with the ISO year directive &quot;</span>
                <span class="s3">&quot;'%G' and a weekday directive '%A', '%a', '%w', or '%u'.&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;1999 51 1&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;%V %u&quot;</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s3">&quot;Day of the year directive '%j' is not compatible with ISO year &quot;</span>
                <span class="s3">&quot;directive '%G'. Use '%Y' instead.&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;1999 50&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;%G %j&quot;</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s3">&quot;ISO week directive '%V' must be used with the ISO year directive &quot;</span>
                <span class="s3">&quot;'%G' and a weekday directive '%A', '%a', '%w', or '%u'.&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;20 Monday&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;%V %A&quot;</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;errors&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;raise&quot;</span><span class="s2">, </span><span class="s3">&quot;coerce&quot;</span><span class="s2">, </span><span class="s3">&quot;ignore&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_error_iso_week_year(self</span><span class="s2">, </span><span class="s1">msg</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">_format</span><span class="s2">, </span><span class="s1">errors):</span>
        <span class="s4"># See GH#16607, GH#50308</span>
        <span class="s4"># This test checks for errors thrown when giving the wrong format</span>
        <span class="s4"># However, as discussed on PR#25541, overriding the locale</span>
        <span class="s4"># causes a different error to be thrown due to the format being</span>
        <span class="s4"># locale specific, but the test data is in english.</span>
        <span class="s4"># Therefore, the tests only run when locale is not overwritten,</span>
        <span class="s4"># as a sort of solution to this problem.</span>
        <span class="s2">if </span><span class="s1">locale.getlocale() != (</span><span class="s3">&quot;zh_CN&quot;</span><span class="s2">, </span><span class="s3">&quot;UTF-8&quot;</span><span class="s1">) </span><span class="s2">and </span><span class="s1">locale.getlocale() != (</span>
            <span class="s3">&quot;it_IT&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;UTF-8&quot;</span><span class="s2">,</span>
        <span class="s1">):</span>
            <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
                <span class="s1">to_datetime(s</span><span class="s2">, </span><span class="s1">format=_format</span><span class="s2">, </span><span class="s1">errors=errors)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;tz&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None, </span><span class="s3">&quot;US/Central&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_dtarr(self</span><span class="s2">, </span><span class="s1">tz):</span>
        <span class="s4"># DatetimeArray</span>
        <span class="s1">dti = date_range(</span><span class="s3">&quot;1965-04-03&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s5">19</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">&quot;2W&quot;</span><span class="s2">, </span><span class="s1">tz=tz)</span>
        <span class="s1">arr = DatetimeArray(dti)</span>

        <span class="s1">result = to_datetime(arr)</span>
        <span class="s2">assert </span><span class="s1">result </span><span class="s2">is </span><span class="s1">arr</span>

    <span class="s4"># Doesn't work on Windows since tzpath not set correctly</span>
    <span class="s1">@td.skip_if_windows</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;arg_class&quot;</span><span class="s2">, </span><span class="s1">[Series</span><span class="s2">, </span><span class="s1">Index])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;utc&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;tz&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None, </span><span class="s3">&quot;US/Central&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_arrow(self</span><span class="s2">, </span><span class="s1">tz</span><span class="s2">, </span><span class="s1">utc</span><span class="s2">, </span><span class="s1">arg_class):</span>
        <span class="s1">pa = pytest.importorskip(</span><span class="s3">&quot;pyarrow&quot;</span><span class="s1">)</span>

        <span class="s1">dti = date_range(</span><span class="s3">&quot;1965-04-03&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s5">19</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">&quot;2W&quot;</span><span class="s2">, </span><span class="s1">tz=tz)</span>
        <span class="s1">dti = arg_class(dti)</span>

        <span class="s1">dti_arrow = dti.astype(pd.ArrowDtype(pa.timestamp(unit=</span><span class="s3">&quot;ns&quot;</span><span class="s2">, </span><span class="s1">tz=tz)))</span>

        <span class="s1">result = to_datetime(dti_arrow</span><span class="s2">, </span><span class="s1">utc=utc)</span>
        <span class="s1">expected = to_datetime(dti</span><span class="s2">, </span><span class="s1">utc=utc).astype(</span>
            <span class="s1">pd.ArrowDtype(pa.timestamp(unit=</span><span class="s3">&quot;ns&quot;</span><span class="s2">, </span><span class="s1">tz=tz </span><span class="s2">if not </span><span class="s1">utc </span><span class="s2">else </span><span class="s3">&quot;UTC&quot;</span><span class="s1">))</span>
        <span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">utc </span><span class="s2">and </span><span class="s1">arg_class </span><span class="s2">is not </span><span class="s1">Series:</span>
            <span class="s4"># Doesn't hold for utc=True, since that will astype</span>
            <span class="s4"># to_datetime also returns a new object for series</span>
            <span class="s2">assert </span><span class="s1">result </span><span class="s2">is </span><span class="s1">dti_arrow</span>
        <span class="s2">if </span><span class="s1">arg_class </span><span class="s2">is </span><span class="s1">Series:</span>
            <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_pydatetime(self):</span>
        <span class="s1">actual = to_datetime(datetime(</span><span class="s5">2008</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">15</span><span class="s1">))</span>
        <span class="s2">assert </span><span class="s1">actual == datetime(</span><span class="s5">2008</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">15</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_YYYYMMDD(self):</span>
        <span class="s1">actual = to_datetime(</span><span class="s3">&quot;20080115&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">actual == datetime(</span><span class="s5">2008</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">15</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_unparsable_ignore(self):</span>
        <span class="s4"># unparsable</span>
        <span class="s1">ser = </span><span class="s3">&quot;Month 1, 1999&quot;</span>
        <span class="s2">assert </span><span class="s1">to_datetime(ser</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;ignore&quot;</span><span class="s1">) == ser</span>

    <span class="s1">@td.skip_if_windows  </span><span class="s4"># `tm.set_timezone` does not work in windows</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_now(self):</span>
        <span class="s4"># See GH#18666</span>
        <span class="s2">with </span><span class="s1">tm.set_timezone(</span><span class="s3">&quot;US/Eastern&quot;</span><span class="s1">):</span>
            <span class="s4"># GH#18705</span>
            <span class="s1">now = Timestamp(</span><span class="s3">&quot;now&quot;</span><span class="s1">)</span>
            <span class="s1">pdnow = to_datetime(</span><span class="s3">&quot;now&quot;</span><span class="s1">)</span>
            <span class="s1">pdnow2 = to_datetime([</span><span class="s3">&quot;now&quot;</span><span class="s1">])[</span><span class="s5">0</span><span class="s1">]</span>

            <span class="s4"># These should all be equal with infinite perf; this gives</span>
            <span class="s4"># a generous margin of 10 seconds</span>
            <span class="s2">assert </span><span class="s1">abs(pdnow._value - now._value) &lt; </span><span class="s5">1e10</span>
            <span class="s2">assert </span><span class="s1">abs(pdnow2._value - now._value) &lt; </span><span class="s5">1e10</span>

            <span class="s2">assert </span><span class="s1">pdnow.tzinfo </span><span class="s2">is None</span>
            <span class="s2">assert </span><span class="s1">pdnow2.tzinfo </span><span class="s2">is None</span>

    <span class="s1">@td.skip_if_windows  </span><span class="s4"># `tm.set_timezone` does not work in windows</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;tz&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;Pacific/Auckland&quot;</span><span class="s2">, </span><span class="s3">&quot;US/Samoa&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_today(self</span><span class="s2">, </span><span class="s1">tz):</span>
        <span class="s4"># See GH#18666</span>
        <span class="s4"># Test with one timezone far ahead of UTC and another far behind, so</span>
        <span class="s4"># one of these will _almost_ always be in a different day from UTC.</span>
        <span class="s4"># Unfortunately this test between 12 and 1 AM Samoa time</span>
        <span class="s4"># this both of these timezones _and_ UTC will all be in the same day,</span>
        <span class="s4"># so this test will not detect the regression introduced in #18666.</span>
        <span class="s2">with </span><span class="s1">tm.set_timezone(tz):</span>
            <span class="s1">nptoday = np.datetime64(</span><span class="s3">&quot;today&quot;</span><span class="s1">).astype(</span><span class="s3">&quot;datetime64[ns]&quot;</span><span class="s1">).astype(np.int64)</span>
            <span class="s1">pdtoday = to_datetime(</span><span class="s3">&quot;today&quot;</span><span class="s1">)</span>
            <span class="s1">pdtoday2 = to_datetime([</span><span class="s3">&quot;today&quot;</span><span class="s1">])[</span><span class="s5">0</span><span class="s1">]</span>

            <span class="s1">tstoday = Timestamp(</span><span class="s3">&quot;today&quot;</span><span class="s1">)</span>
            <span class="s1">tstoday2 = Timestamp.today().as_unit(</span><span class="s3">&quot;ns&quot;</span><span class="s1">)</span>

            <span class="s4"># These should all be equal with infinite perf; this gives</span>
            <span class="s4"># a generous margin of 10 seconds</span>
            <span class="s2">assert </span><span class="s1">abs(pdtoday.normalize()._value - nptoday) &lt; </span><span class="s5">1e10</span>
            <span class="s2">assert </span><span class="s1">abs(pdtoday2.normalize()._value - nptoday) &lt; </span><span class="s5">1e10</span>
            <span class="s2">assert </span><span class="s1">abs(pdtoday._value - tstoday._value) &lt; </span><span class="s5">1e10</span>
            <span class="s2">assert </span><span class="s1">abs(pdtoday._value - tstoday2._value) &lt; </span><span class="s5">1e10</span>

            <span class="s2">assert </span><span class="s1">pdtoday.tzinfo </span><span class="s2">is None</span>
            <span class="s2">assert </span><span class="s1">pdtoday2.tzinfo </span><span class="s2">is None</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;arg&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;now&quot;</span><span class="s2">, </span><span class="s3">&quot;today&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_today_now_unicode_bytes(self</span><span class="s2">, </span><span class="s1">arg):</span>
        <span class="s1">to_datetime([arg])</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;format, expected_ds&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s3">&quot;%Y-%m-%d %H:%M:%S%z&quot;</span><span class="s2">, </span><span class="s3">&quot;2020-01-03&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;%Y-%d-%m %H:%M:%S%z&quot;</span><span class="s2">, </span><span class="s3">&quot;2020-03-01&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s2">None, </span><span class="s3">&quot;2020-01-03&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;string, attribute&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s3">&quot;now&quot;</span><span class="s2">, </span><span class="s3">&quot;utcnow&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;today&quot;</span><span class="s2">, </span><span class="s3">&quot;today&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_now_with_format(self</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s1">expected_ds</span><span class="s2">, </span><span class="s1">string</span><span class="s2">, </span><span class="s1">attribute):</span>
        <span class="s4"># https://github.com/pandas-dev/pandas/issues/50359</span>
        <span class="s1">result = to_datetime([</span><span class="s3">&quot;2020-01-03 00:00:00Z&quot;</span><span class="s2">, </span><span class="s1">string]</span><span class="s2">, </span><span class="s1">format=format</span><span class="s2">, </span><span class="s1">utc=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">expected = DatetimeIndex(</span>
            <span class="s1">[expected_ds</span><span class="s2">, </span><span class="s1">getattr(Timestamp</span><span class="s2">, </span><span class="s1">attribute)()]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;datetime64[ns, UTC]&quot;</span>
        <span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">(expected - result).max().total_seconds() &lt; </span><span class="s5">1</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;dt&quot;</span><span class="s2">, </span><span class="s1">[np.datetime64(</span><span class="s3">&quot;2000-01-01&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.datetime64(</span><span class="s3">&quot;2000-01-02&quot;</span><span class="s1">)]</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_dt64s(self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">dt):</span>
        <span class="s2">assert </span><span class="s1">to_datetime(dt</span><span class="s2">, </span><span class="s1">cache=cache) == Timestamp(dt)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;arg, format&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s3">&quot;2001-01-01&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%d&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;01-01-2001&quot;</span><span class="s2">, </span><span class="s3">&quot;%d-%m-%Y&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_dt64s_and_str(self</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">, </span><span class="s1">format):</span>
        <span class="s4"># https://github.com/pandas-dev/pandas/issues/50036</span>
        <span class="s1">result = to_datetime([arg</span><span class="s2">, </span><span class="s1">np.datetime64(</span><span class="s3">&quot;2020-01-01&quot;</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">format=format)</span>
        <span class="s1">expected = DatetimeIndex([</span><span class="s3">&quot;2001-01-01&quot;</span><span class="s2">, </span><span class="s3">&quot;2020-01-01&quot;</span><span class="s1">])</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;dt&quot;</span><span class="s2">, </span><span class="s1">[np.datetime64(</span><span class="s3">&quot;1000-01-01&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.datetime64(</span><span class="s3">&quot;5000-01-02&quot;</span><span class="s1">)]</span>
    <span class="s1">)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;errors&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;raise&quot;</span><span class="s2">, </span><span class="s3">&quot;ignore&quot;</span><span class="s2">, </span><span class="s3">&quot;coerce&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_dt64s_out_of_ns_bounds(self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">dt</span><span class="s2">, </span><span class="s1">errors):</span>
        <span class="s4"># GH#50369 We cast to the nearest supported reso, i.e. &quot;s&quot;</span>
        <span class="s1">ts = to_datetime(dt</span><span class="s2">, </span><span class="s1">errors=errors</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s2">assert </span><span class="s1">isinstance(ts</span><span class="s2">, </span><span class="s1">Timestamp)</span>
        <span class="s2">assert </span><span class="s1">ts.unit == </span><span class="s3">&quot;s&quot;</span>
        <span class="s2">assert </span><span class="s1">ts.asm8 == dt</span>

        <span class="s1">ts = Timestamp(dt)</span>
        <span class="s2">assert </span><span class="s1">ts.unit == </span><span class="s3">&quot;s&quot;</span>
        <span class="s2">assert </span><span class="s1">ts.asm8 == dt</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_dt64d_out_of_bounds(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s1">dt64 = np.datetime64(np.iinfo(np.int64).max</span><span class="s2">, </span><span class="s3">&quot;D&quot;</span><span class="s1">)</span>

        <span class="s1">msg = </span><span class="s3">&quot;Out of bounds nanosecond timestamp&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(OutOfBoundsDatetime</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">Timestamp(dt64)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(OutOfBoundsDatetime</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(dt64</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;raise&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>

        <span class="s2">assert </span><span class="s1">to_datetime(dt64</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s2">, </span><span class="s1">cache=cache) </span><span class="s2">is </span><span class="s1">NaT</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;unit&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;s&quot;</span><span class="s2">, </span><span class="s3">&quot;D&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_array_of_dt64s(self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">unit):</span>
        <span class="s4"># https://github.com/pandas-dev/pandas/issues/31491</span>
        <span class="s4"># Need at least 50 to ensure cache is used.</span>
        <span class="s1">dts = [</span>
            <span class="s1">np.datetime64(</span><span class="s3">&quot;2000-01-01&quot;</span><span class="s2">, </span><span class="s1">unit)</span><span class="s2">,</span>
            <span class="s1">np.datetime64(</span><span class="s3">&quot;2000-01-02&quot;</span><span class="s2">, </span><span class="s1">unit)</span><span class="s2">,</span>
        <span class="s1">] * </span><span class="s5">30</span>
        <span class="s4"># Assuming all datetimes are in bounds, to_datetime() returns</span>
        <span class="s4"># an array that is equal to Timestamp() parsing</span>
        <span class="s1">result = to_datetime(dts</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s2">if </span><span class="s1">cache:</span>
            <span class="s4"># FIXME: behavior should not depend on cache</span>
            <span class="s1">expected = DatetimeIndex([Timestamp(x).asm8 </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">dts]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;M8[s]&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">expected = DatetimeIndex([Timestamp(x).asm8 </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">dts]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;M8[ns]&quot;</span><span class="s1">)</span>

        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s4"># A list of datetimes where the last one is out of bounds</span>
        <span class="s1">dts_with_oob = dts + [np.datetime64(</span><span class="s3">&quot;9999-01-01&quot;</span><span class="s1">)]</span>

        <span class="s4"># As of GH#51978 we do not raise in this case</span>
        <span class="s1">to_datetime(dts_with_oob</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;raise&quot;</span><span class="s1">)</span>

        <span class="s1">result = to_datetime(dts_with_oob</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s2">if not </span><span class="s1">cache:</span>
            <span class="s4"># FIXME: shouldn't depend on cache!</span>
            <span class="s1">expected = DatetimeIndex(</span>
                <span class="s1">[Timestamp(dts_with_oob[</span><span class="s5">0</span><span class="s1">]).asm8</span><span class="s2">, </span><span class="s1">Timestamp(dts_with_oob[</span><span class="s5">1</span><span class="s1">]).asm8] * </span><span class="s5">30</span>
                <span class="s1">+ [NaT]</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">expected = DatetimeIndex(np.array(dts_with_oob</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;M8[s]&quot;</span><span class="s1">))</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s4"># With errors='ignore', out of bounds datetime64s</span>
        <span class="s4"># are converted to their .item(), which depending on the version of</span>
        <span class="s4"># numpy is either a python datetime.datetime or datetime.date</span>
        <span class="s1">result = to_datetime(dts_with_oob</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s2">if not </span><span class="s1">cache:</span>
            <span class="s4"># FIXME: shouldn't depend on cache!</span>
            <span class="s1">expected = Index(dts_with_oob)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_out_of_bounds_errors_ignore(self):</span>
        <span class="s4"># https://github.com/pandas-dev/pandas/issues/50587</span>
        <span class="s1">result = to_datetime(np.datetime64(</span><span class="s3">&quot;9999-01-01&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;ignore&quot;</span><span class="s1">)</span>
        <span class="s1">expected = np.datetime64(</span><span class="s3">&quot;9999-01-01&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_tz(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># xref 8260</span>
        <span class="s4"># uniform returns a DatetimeIndex</span>
        <span class="s1">arr = [</span>
            <span class="s1">Timestamp(</span><span class="s3">&quot;2013-01-01 13:00:00-0800&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;US/Pacific&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">Timestamp(</span><span class="s3">&quot;2013-01-02 14:00:00-0800&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;US/Pacific&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span>
        <span class="s1">result = to_datetime(arr</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected = DatetimeIndex(</span>
            <span class="s1">[</span><span class="s3">&quot;2013-01-01 13:00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;2013-01-02 14:00:00&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;US/Pacific&quot;</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_tz_mixed(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># mixed tzs will raise if errors='raise'</span>
        <span class="s4"># https://github.com/pandas-dev/pandas/issues/50585</span>
        <span class="s1">arr = [</span>
            <span class="s1">Timestamp(</span><span class="s3">&quot;2013-01-01 13:00:00&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;US/Pacific&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">Timestamp(</span><span class="s3">&quot;2013-01-02 14:00:00&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;US/Eastern&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span>
        <span class="s1">msg = (</span>
            <span class="s3">&quot;Tz-aware datetime.datetime cannot be &quot;</span>
            <span class="s3">&quot;converted to datetime64 unless utc=True&quot;</span>
        <span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(arr</span><span class="s2">, </span><span class="s1">cache=cache)</span>

        <span class="s1">result = to_datetime(arr</span><span class="s2">, </span><span class="s1">cache=cache</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;ignore&quot;</span><span class="s1">)</span>
        <span class="s1">expected = Index(</span>
            <span class="s1">[</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2013-01-01 13:00:00-08:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2013-01-02 14:00:00-05:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">dtype=</span><span class="s3">&quot;object&quot;</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">result = to_datetime(arr</span><span class="s2">, </span><span class="s1">cache=cache</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s1">)</span>
        <span class="s1">expected = DatetimeIndex(</span>
            <span class="s1">[</span><span class="s3">&quot;2013-01-01 13:00:00-08:00&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;datetime64[ns, US/Pacific]&quot;</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_different_offsets(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># inspired by asv timeseries.ToDatetimeNONISO8601 benchmark</span>
        <span class="s4"># see GH-26097 for more</span>
        <span class="s1">ts_string_1 = </span><span class="s3">&quot;March 1, 2018 12:00:00+0400&quot;</span>
        <span class="s1">ts_string_2 = </span><span class="s3">&quot;March 1, 2018 12:00:00+0500&quot;</span>
        <span class="s1">arr = [ts_string_1] * </span><span class="s5">5 </span><span class="s1">+ [ts_string_2] * </span><span class="s5">5</span>
        <span class="s1">expected = Index([parse(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">arr])</span>
        <span class="s1">msg = </span><span class="s3">&quot;parsing datetimes with mixed time zones will raise an error&quot;</span>
        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">result = to_datetime(arr</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_tz_pytz(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># see gh-8260</span>
        <span class="s1">us_eastern = pytz.timezone(</span><span class="s3">&quot;US/Eastern&quot;</span><span class="s1">)</span>
        <span class="s1">arr = np.array(</span>
            <span class="s1">[</span>
                <span class="s1">us_eastern.localize(</span>
                    <span class="s1">datetime(year=</span><span class="s5">2000</span><span class="s2">, </span><span class="s1">month=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">day=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">hour=</span><span class="s5">3</span><span class="s2">, </span><span class="s1">minute=</span><span class="s5">0</span><span class="s1">)</span>
                <span class="s1">)</span><span class="s2">,</span>
                <span class="s1">us_eastern.localize(</span>
                    <span class="s1">datetime(year=</span><span class="s5">2000</span><span class="s2">, </span><span class="s1">month=</span><span class="s5">6</span><span class="s2">, </span><span class="s1">day=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">hour=</span><span class="s5">3</span><span class="s2">, </span><span class="s1">minute=</span><span class="s5">0</span><span class="s1">)</span>
                <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">dtype=object</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">result = to_datetime(arr</span><span class="s2">, </span><span class="s1">utc=</span><span class="s2">True, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected = DatetimeIndex(</span>
            <span class="s1">[</span><span class="s3">&quot;2000-01-01 08:00:00+00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;2000-06-01 07:00:00+00:00&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">dtype=</span><span class="s3">&quot;datetime64[ns, UTC]&quot;</span><span class="s2">,</span>
            <span class="s1">freq=</span><span class="s2">None,</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;init_constructor, end_constructor&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">(Index</span><span class="s2">, </span><span class="s1">DatetimeIndex)</span><span class="s2">,</span>
            <span class="s1">(list</span><span class="s2">, </span><span class="s1">DatetimeIndex)</span><span class="s2">,</span>
            <span class="s1">(np.array</span><span class="s2">, </span><span class="s1">DatetimeIndex)</span><span class="s2">,</span>
            <span class="s1">(Series</span><span class="s2">, </span><span class="s1">Series)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_utc_true(self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">init_constructor</span><span class="s2">, </span><span class="s1">end_constructor):</span>
        <span class="s4"># See gh-11934 &amp; gh-6415</span>
        <span class="s1">data = [</span><span class="s3">&quot;20100102 121314&quot;</span><span class="s2">, </span><span class="s3">&quot;20100102 121315&quot;</span><span class="s1">]</span>
        <span class="s1">expected_data = [</span>
            <span class="s1">Timestamp(</span><span class="s3">&quot;2010-01-02 12:13:14&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;utc&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">Timestamp(</span><span class="s3">&quot;2010-01-02 12:13:15&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;utc&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span>

        <span class="s1">result = to_datetime(</span>
            <span class="s1">init_constructor(data)</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%Y%m%d %H%M%S&quot;</span><span class="s2">, </span><span class="s1">utc=</span><span class="s2">True, </span><span class="s1">cache=cache</span>
        <span class="s1">)</span>
        <span class="s1">expected = end_constructor(expected_data)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;scalar, expected&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s3">&quot;20100102 121314&quot;</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;2010-01-02 12:13:14&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;utc&quot;</span><span class="s1">)]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;20100102 121315&quot;</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;2010-01-02 12:13:15&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;utc&quot;</span><span class="s1">)]</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_utc_true_scalar(self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">scalar</span><span class="s2">, </span><span class="s1">expected):</span>
        <span class="s4"># Test scalar case as well</span>
        <span class="s1">result = to_datetime(scalar</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%Y%m%d %H%M%S&quot;</span><span class="s2">, </span><span class="s1">utc=</span><span class="s2">True, </span><span class="s1">cache=cache)</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_utc_true_with_series_single_value(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># GH 15760 UTC=True with Series</span>
        <span class="s1">ts = </span><span class="s5">1.5e18</span>
        <span class="s1">result = to_datetime(Series([ts])</span><span class="s2">, </span><span class="s1">utc=</span><span class="s2">True, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected = Series([Timestamp(ts</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;utc&quot;</span><span class="s1">)])</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_utc_true_with_series_tzaware_string(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s1">ts = </span><span class="s3">&quot;2013-01-01 00:00:00-01:00&quot;</span>
        <span class="s1">expected_ts = </span><span class="s3">&quot;2013-01-01 01:00:00&quot;</span>
        <span class="s1">data = Series([ts] * </span><span class="s5">3</span><span class="s1">)</span>
        <span class="s1">result = to_datetime(data</span><span class="s2">, </span><span class="s1">utc=</span><span class="s2">True, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected = Series([Timestamp(expected_ts</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;utc&quot;</span><span class="s1">)] * </span><span class="s5">3</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;date, dtype&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s3">&quot;2013-01-01 01:00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;datetime64[ns]&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2013-01-01 01:00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;datetime64[ns, UTC]&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_utc_true_with_series_datetime_ns(self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">date</span><span class="s2">, </span><span class="s1">dtype):</span>
        <span class="s1">expected = Series([Timestamp(</span><span class="s3">&quot;2013-01-01 01:00:00&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;UTC&quot;</span><span class="s1">)])</span>
        <span class="s1">result = to_datetime(Series([date]</span><span class="s2">, </span><span class="s1">dtype=dtype)</span><span class="s2">, </span><span class="s1">utc=</span><span class="s2">True, </span><span class="s1">cache=cache)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_tz_psycopg2(self</span><span class="s2">, </span><span class="s1">request</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># xref 8260</span>
        <span class="s1">psycopg2_tz = pytest.importorskip(</span><span class="s3">&quot;psycopg2.tz&quot;</span><span class="s1">)</span>

        <span class="s4"># misc cases</span>
        <span class="s1">tz1 = psycopg2_tz.FixedOffsetTimezone(offset=-</span><span class="s5">300</span><span class="s2">, </span><span class="s1">name=</span><span class="s2">None</span><span class="s1">)</span>
        <span class="s1">tz2 = psycopg2_tz.FixedOffsetTimezone(offset=-</span><span class="s5">240</span><span class="s2">, </span><span class="s1">name=</span><span class="s2">None</span><span class="s1">)</span>
        <span class="s1">arr = np.array(</span>
            <span class="s1">[</span>
                <span class="s1">datetime(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">tzinfo=tz1)</span><span class="s2">,</span>
                <span class="s1">datetime(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">6</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">tzinfo=tz2)</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">dtype=object</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s1">result = to_datetime(arr</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s2">, </span><span class="s1">utc=</span><span class="s2">True, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected = DatetimeIndex(</span>
            <span class="s1">[</span><span class="s3">&quot;2000-01-01 08:00:00+00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;2000-06-01 07:00:00+00:00&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">dtype=</span><span class="s3">&quot;datetime64[ns, UTC]&quot;</span><span class="s2">,</span>
            <span class="s1">freq=</span><span class="s2">None,</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s4"># dtype coercion</span>
        <span class="s1">i = DatetimeIndex(</span>
            <span class="s1">[</span><span class="s3">&quot;2000-01-01 08:00:00&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">tz=psycopg2_tz.FixedOffsetTimezone(offset=-</span><span class="s5">300</span><span class="s2">, </span><span class="s1">name=</span><span class="s2">None</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">is_datetime64_ns_dtype(i)</span>

        <span class="s4"># tz coercion</span>
        <span class="s1">result = to_datetime(i</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">i)</span>

        <span class="s1">result = to_datetime(i</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s2">, </span><span class="s1">utc=</span><span class="s2">True, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected = DatetimeIndex([</span><span class="s3">&quot;2000-01-01 13:00:00&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;datetime64[ns, UTC]&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;arg&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_datetime_bool(self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">arg):</span>
        <span class="s4"># GH13176</span>
        <span class="s1">msg = </span><span class="s3">r&quot;dtype bool cannot be converted to datetime64\[ns\]&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(arg)</span>
        <span class="s2">assert </span><span class="s1">to_datetime(arg</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s2">, </span><span class="s1">cache=cache) </span><span class="s2">is </span><span class="s1">NaT</span>
        <span class="s2">assert </span><span class="s1">to_datetime(arg</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">cache=cache) </span><span class="s2">is </span><span class="s1">arg</span>

    <span class="s2">def </span><span class="s1">test_datetime_bool_arrays_mixed(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s1">msg = </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">type(cache)</span><span class="s2">} </span><span class="s3">is not convertible to datetime&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime([</span><span class="s2">False, </span><span class="s1">datetime.today()]</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(</span>
            <span class="s1">ValueError</span><span class="s2">,</span>
            <span class="s1">match=(</span>
                <span class="s3">r'^time data &quot;True&quot; doesn\'t match format &quot;%Y%m%d&quot;, '</span>
                <span class="s3">f&quot;at position 1. </span><span class="s2">{</span><span class="s1">PARSING_ERR_MSG</span><span class="s2">}</span><span class="s3">$&quot;</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">):</span>
            <span class="s1">to_datetime([</span><span class="s3">&quot;20130101&quot;</span><span class="s2">, True</span><span class="s1">]</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">tm.assert_index_equal(</span>
            <span class="s1">to_datetime([</span><span class="s5">0</span><span class="s2">, False, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s5">0.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span><span class="s2">,</span>
            <span class="s1">DatetimeIndex(</span>
                <span class="s1">[to_datetime(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">cache=cache)</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s1">to_datetime(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">cache=cache)]</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;arg&quot;</span><span class="s2">, </span><span class="s1">[bool</span><span class="s2">, </span><span class="s1">to_datetime])</span>
    <span class="s2">def </span><span class="s1">test_datetime_invalid_datatype(self</span><span class="s2">, </span><span class="s1">arg):</span>
        <span class="s4"># GH13176</span>
        <span class="s1">msg = </span><span class="s3">&quot;is not convertible to datetime&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(arg)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;errors&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;coerce&quot;</span><span class="s2">, </span><span class="s3">&quot;raise&quot;</span><span class="s2">, </span><span class="s3">&quot;ignore&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_invalid_format_raises(self</span><span class="s2">, </span><span class="s1">errors):</span>
        <span class="s4"># https://github.com/pandas-dev/pandas/issues/50255</span>
        <span class="s2">with </span><span class="s1">pytest.raises(</span>
            <span class="s1">ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;':' is a bad directive in format 'H%:M%:S%&quot;</span>
        <span class="s1">):</span>
            <span class="s1">to_datetime([</span><span class="s3">&quot;00:00:00&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;H%:M%:S%&quot;</span><span class="s2">, </span><span class="s1">errors=errors)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;value&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;00:01:99&quot;</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;format&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None, </span><span class="s3">&quot;%H:%M:%S&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_datetime_invalid_scalar(self</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">format):</span>
        <span class="s4"># GH24763</span>
        <span class="s1">res = to_datetime(value</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">format=format)</span>
        <span class="s2">assert </span><span class="s1">res == value</span>

        <span class="s1">res = to_datetime(value</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s2">, </span><span class="s1">format=format)</span>
        <span class="s2">assert </span><span class="s1">res </span><span class="s2">is </span><span class="s1">NaT</span>

        <span class="s1">msg = </span><span class="s3">&quot;|&quot;</span><span class="s1">.join(</span>
            <span class="s1">[</span>
                <span class="s3">r'^time data &quot;a&quot; doesn\'t match format &quot;%H:%M:%S&quot;, at position 0. '</span>
                <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">PARSING_ERR_MSG</span><span class="s2">}</span><span class="s3">$&quot;</span><span class="s2">,</span>
                <span class="s3">r'^Given date string &quot;a&quot; not likely a datetime, at position 0$'</span><span class="s2">,</span>
                <span class="s3">r'^unconverted data remains when parsing with format &quot;%H:%M:%S&quot;: &quot;9&quot;, '</span>
                <span class="s3">f&quot;at position 0. </span><span class="s2">{</span><span class="s1">PARSING_ERR_MSG</span><span class="s2">}</span><span class="s3">$&quot;</span><span class="s2">,</span>
                <span class="s3">r&quot;^second must be in 0..59: 00:01:99, at position 0$&quot;</span><span class="s2">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(value</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;raise&quot;</span><span class="s2">, </span><span class="s1">format=format)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;value&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;3000/12/11 00:00:00&quot;</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;format&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None, </span><span class="s3">&quot;%H:%M:%S&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_datetime_outofbounds_scalar(self</span><span class="s2">, </span><span class="s1">value</span><span class="s2">, </span><span class="s1">format):</span>
        <span class="s4"># GH24763</span>
        <span class="s1">res = to_datetime(value</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">format=format)</span>
        <span class="s2">assert </span><span class="s1">res == value</span>

        <span class="s1">res = to_datetime(value</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s2">, </span><span class="s1">format=format)</span>
        <span class="s2">assert </span><span class="s1">res </span><span class="s2">is </span><span class="s1">NaT</span>

        <span class="s2">if </span><span class="s1">format </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s3">r'^time data &quot;.*&quot; doesn\'t match format &quot;.*&quot;, at position 0.'</span>
            <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
                <span class="s1">to_datetime(value</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;raise&quot;</span><span class="s2">, </span><span class="s1">format=format)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s3">&quot;^Out of bounds .*, at position 0$&quot;</span>
            <span class="s2">with </span><span class="s1">pytest.raises(OutOfBoundsDatetime</span><span class="s2">, </span><span class="s1">match=msg):</span>
                <span class="s1">to_datetime(value</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;raise&quot;</span><span class="s2">, </span><span class="s1">format=format)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s1">(</span><span class="s3">&quot;values&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">[([</span><span class="s3">&quot;a&quot;</span><span class="s1">])</span><span class="s2">, </span><span class="s1">([</span><span class="s3">&quot;00:01:99&quot;</span><span class="s1">])</span><span class="s2">, </span><span class="s1">([</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;99:00:00&quot;</span><span class="s1">])]</span>
    <span class="s1">)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;format&quot;</span><span class="s2">, </span><span class="s1">[(</span><span class="s2">None</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;%H:%M:%S&quot;</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_datetime_invalid_index(self</span><span class="s2">, </span><span class="s1">values</span><span class="s2">, </span><span class="s1">format):</span>
        <span class="s4"># GH24763</span>
        <span class="s4"># Not great to have logic in tests, but this one's hard to</span>
        <span class="s4"># parametrise over</span>
        <span class="s2">if </span><span class="s1">format </span><span class="s2">is None and </span><span class="s1">len(values) &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">warn = UserWarning</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">warn = </span><span class="s2">None</span>
        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(warn</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;Could not infer format&quot;</span><span class="s1">):</span>
            <span class="s1">res = to_datetime(values</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">format=format)</span>
        <span class="s1">tm.assert_index_equal(res</span><span class="s2">, </span><span class="s1">Index(values))</span>

        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(warn</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;Could not infer format&quot;</span><span class="s1">):</span>
            <span class="s1">res = to_datetime(values</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s2">, </span><span class="s1">format=format)</span>
        <span class="s1">tm.assert_index_equal(res</span><span class="s2">, </span><span class="s1">DatetimeIndex([NaT] * len(values)))</span>

        <span class="s1">msg = </span><span class="s3">&quot;|&quot;</span><span class="s1">.join(</span>
            <span class="s1">[</span>
                <span class="s3">r'^Given date string &quot;a&quot; not likely a datetime, at position 0$'</span><span class="s2">,</span>
                <span class="s3">r'^time data &quot;a&quot; doesn\'t match format &quot;%H:%M:%S&quot;, at position 0. '</span>
                <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">PARSING_ERR_MSG</span><span class="s2">}</span><span class="s3">$&quot;</span><span class="s2">,</span>
                <span class="s3">r'^unconverted data remains when parsing with format &quot;%H:%M:%S&quot;: &quot;9&quot;, '</span>
                <span class="s3">f&quot;at position 0. </span><span class="s2">{</span><span class="s1">PARSING_ERR_MSG</span><span class="s2">}</span><span class="s3">$&quot;</span><span class="s2">,</span>
                <span class="s3">r&quot;^second must be in 0..59: 00:01:99, at position 0$&quot;</span><span class="s2">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s2">with </span><span class="s1">tm.assert_produces_warning(warn</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;Could not infer format&quot;</span><span class="s1">):</span>
                <span class="s1">to_datetime(values</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;raise&quot;</span><span class="s2">, </span><span class="s1">format=format)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;utc&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, None</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;format&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;%Y%m%d %H:%M:%S&quot;</span><span class="s2">, None</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;constructor&quot;</span><span class="s2">, </span><span class="s1">[list</span><span class="s2">, </span><span class="s1">tuple</span><span class="s2">, </span><span class="s1">np.array</span><span class="s2">, </span><span class="s1">Index</span><span class="s2">, </span><span class="s1">deque])</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_cache(self</span><span class="s2">, </span><span class="s1">utc</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s1">constructor):</span>
        <span class="s1">date = </span><span class="s3">&quot;20130101 00:00:00&quot;</span>
        <span class="s1">test_dates = [date] * </span><span class="s5">10</span><span class="s1">**</span><span class="s5">5</span>
        <span class="s1">data = constructor(test_dates)</span>

        <span class="s1">result = to_datetime(data</span><span class="s2">, </span><span class="s1">utc=utc</span><span class="s2">, </span><span class="s1">format=format</span><span class="s2">, </span><span class="s1">cache=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">expected = to_datetime(data</span><span class="s2">, </span><span class="s1">utc=utc</span><span class="s2">, </span><span class="s1">format=format</span><span class="s2">, </span><span class="s1">cache=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_from_deque(self):</span>
        <span class="s4"># GH 29403</span>
        <span class="s1">result = to_datetime(deque([Timestamp(</span><span class="s3">&quot;2010-06-02 09:30:00&quot;</span><span class="s1">)] * </span><span class="s5">51</span><span class="s1">))</span>
        <span class="s1">expected = to_datetime([Timestamp(</span><span class="s3">&quot;2010-06-02 09:30:00&quot;</span><span class="s1">)] * </span><span class="s5">51</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;utc&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, None</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;format&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;%Y%m%d %H:%M:%S&quot;</span><span class="s2">, None</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_cache_series(self</span><span class="s2">, </span><span class="s1">utc</span><span class="s2">, </span><span class="s1">format):</span>
        <span class="s1">date = </span><span class="s3">&quot;20130101 00:00:00&quot;</span>
        <span class="s1">test_dates = [date] * </span><span class="s5">10</span><span class="s1">**</span><span class="s5">5</span>
        <span class="s1">data = Series(test_dates)</span>
        <span class="s1">result = to_datetime(data</span><span class="s2">, </span><span class="s1">utc=utc</span><span class="s2">, </span><span class="s1">format=format</span><span class="s2">, </span><span class="s1">cache=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">expected = to_datetime(data</span><span class="s2">, </span><span class="s1">utc=utc</span><span class="s2">, </span><span class="s1">format=format</span><span class="s2">, </span><span class="s1">cache=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_cache_scalar(self):</span>
        <span class="s1">date = </span><span class="s3">&quot;20130101 00:00:00&quot;</span>
        <span class="s1">result = to_datetime(date</span><span class="s2">, </span><span class="s1">cache=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">expected = Timestamp(</span><span class="s3">&quot;20130101 00:00:00&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;datetimelikes,expected_values&quot;</span><span class="s2">,</span>
        <span class="s1">(</span>
            <span class="s1">(</span>
                <span class="s1">(</span><span class="s2">None, </span><span class="s1">np.nan) + (NaT</span><span class="s2">,</span><span class="s1">) * start_caching_at</span><span class="s2">,</span>
                <span class="s1">(NaT</span><span class="s2">,</span><span class="s1">) * (start_caching_at + </span><span class="s5">2</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span>
                <span class="s1">(</span><span class="s2">None, </span><span class="s1">Timestamp(</span><span class="s3">&quot;2012-07-26&quot;</span><span class="s1">)) + (NaT</span><span class="s2">,</span><span class="s1">) * start_caching_at</span><span class="s2">,</span>
                <span class="s1">(NaT</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;2012-07-26&quot;</span><span class="s1">)) + (NaT</span><span class="s2">,</span><span class="s1">) * start_caching_at</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span>
                <span class="s1">(</span><span class="s2">None,</span><span class="s1">)</span>
                <span class="s1">+ (NaT</span><span class="s2">,</span><span class="s1">) * start_caching_at</span>
                <span class="s1">+ (</span><span class="s3">&quot;2012 July 26&quot;</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;2012-07-26&quot;</span><span class="s1">))</span><span class="s2">,</span>
                <span class="s1">(NaT</span><span class="s2">,</span><span class="s1">) * (start_caching_at + </span><span class="s5">1</span><span class="s1">)</span>
                <span class="s1">+ (Timestamp(</span><span class="s3">&quot;2012-07-26&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;2012-07-26&quot;</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">)</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_convert_object_to_datetime_with_cache(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">datetimelikes</span><span class="s2">, </span><span class="s1">expected_values</span>
    <span class="s1">):</span>
        <span class="s4"># GH#39882</span>
        <span class="s1">ser = Series(</span>
            <span class="s1">datetimelikes</span><span class="s2">,</span>
            <span class="s1">dtype=</span><span class="s3">&quot;object&quot;</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">result_series = to_datetime(ser</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s1">)</span>
        <span class="s1">expected_series = Series(</span>
            <span class="s1">expected_values</span><span class="s2">,</span>
            <span class="s1">dtype=</span><span class="s3">&quot;datetime64[ns]&quot;</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result_series</span><span class="s2">, </span><span class="s1">expected_series)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;cache&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s1">(</span><span class="s3">&quot;input&quot;</span><span class="s2">, </span><span class="s3">&quot;expected&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span>
            <span class="s1">(</span>
                <span class="s1">Series([NaT] * </span><span class="s5">20 </span><span class="s1">+ [</span><span class="s2">None</span><span class="s1">] * </span><span class="s5">20</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;object&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">Series([NaT] * </span><span class="s5">40</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;datetime64[ns]&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span>
                <span class="s1">Series([NaT] * </span><span class="s5">60 </span><span class="s1">+ [</span><span class="s2">None</span><span class="s1">] * </span><span class="s5">60</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;object&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">Series([NaT] * </span><span class="s5">120</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;datetime64[ns]&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(Series([</span><span class="s2">None</span><span class="s1">] * </span><span class="s5">20</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Series([NaT] * </span><span class="s5">20</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;datetime64[ns]&quot;</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(Series([</span><span class="s2">None</span><span class="s1">] * </span><span class="s5">60</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Series([NaT] * </span><span class="s5">60</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;datetime64[ns]&quot;</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(Series([</span><span class="s3">&quot;&quot;</span><span class="s1">] * </span><span class="s5">20</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Series([NaT] * </span><span class="s5">20</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;datetime64[ns]&quot;</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(Series([</span><span class="s3">&quot;&quot;</span><span class="s1">] * </span><span class="s5">60</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Series([NaT] * </span><span class="s5">60</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;datetime64[ns]&quot;</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(Series([pd.NA] * </span><span class="s5">20</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Series([NaT] * </span><span class="s5">20</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;datetime64[ns]&quot;</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(Series([pd.NA] * </span><span class="s5">60</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Series([NaT] * </span><span class="s5">60</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;datetime64[ns]&quot;</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(Series([np.nan] * </span><span class="s5">20</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Series([NaT] * </span><span class="s5">20</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;datetime64[ns]&quot;</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(Series([np.nan] * </span><span class="s5">60</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Series([NaT] * </span><span class="s5">60</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;datetime64[ns]&quot;</span><span class="s1">))</span><span class="s2">,</span>
        <span class="s1">)</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_converts_null_like_to_nat(self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">input</span><span class="s2">, </span><span class="s1">expected):</span>
        <span class="s4"># GH35888</span>
        <span class="s1">result = to_datetime(input</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;date, format&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s3">&quot;2017-20&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%W&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;20 Sunday&quot;</span><span class="s2">, </span><span class="s3">&quot;%W %A&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;20 Sun&quot;</span><span class="s2">, </span><span class="s3">&quot;%W %a&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2017-21&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%U&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;20 Sunday&quot;</span><span class="s2">, </span><span class="s3">&quot;%U %A&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;20 Sun&quot;</span><span class="s2">, </span><span class="s3">&quot;%U %a&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_week_without_day_and_calendar_year(self</span><span class="s2">, </span><span class="s1">date</span><span class="s2">, </span><span class="s1">format):</span>
        <span class="s4"># GH16774</span>

        <span class="s1">msg = </span><span class="s3">&quot;Cannot use '%W' or '%U' without day and year&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(date</span><span class="s2">, </span><span class="s1">format=format)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_coerce(self):</span>
        <span class="s4"># GH 26122</span>
        <span class="s1">ts_strings = [</span>
            <span class="s3">&quot;March 1, 2018 12:00:00+0400&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;March 1, 2018 12:00:00+0500&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;20100240&quot;</span><span class="s2">,</span>
        <span class="s1">]</span>
        <span class="s1">msg = </span><span class="s3">&quot;parsing datetimes with mixed time zones will raise an error&quot;</span>
        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">result = to_datetime(ts_strings</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s1">)</span>
        <span class="s1">expected = Index(</span>
            <span class="s1">[</span>
                <span class="s1">datetime(</span><span class="s5">2018</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">12</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">tzinfo=tzoffset(</span><span class="s2">None, </span><span class="s5">14400</span><span class="s1">))</span><span class="s2">,</span>
                <span class="s1">datetime(</span><span class="s5">2018</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">12</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">tzinfo=tzoffset(</span><span class="s2">None, </span><span class="s5">18000</span><span class="s1">))</span><span class="s2">,</span>
                <span class="s1">NaT</span><span class="s2">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;string_arg, format&quot;</span><span class="s2">,</span>
        <span class="s1">[(</span><span class="s3">&quot;March 1, 2018&quot;</span><span class="s2">, </span><span class="s3">&quot;%B %d, %Y&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;2018-03-01&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%d&quot;</span><span class="s1">)]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;outofbounds&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">datetime(</span><span class="s5">9999</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">date(</span><span class="s5">9999</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">np.datetime64(</span><span class="s3">&quot;9999-01-01&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;January 1, 9999&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;9999-01-01&quot;</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_coerce_oob(self</span><span class="s2">, </span><span class="s1">string_arg</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s1">outofbounds):</span>
        <span class="s4"># https://github.com/pandas-dev/pandas/issues/50255</span>
        <span class="s1">ts_strings = [string_arg</span><span class="s2">, </span><span class="s1">outofbounds]</span>
        <span class="s1">result = to_datetime(ts_strings</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s2">, </span><span class="s1">format=format)</span>
        <span class="s1">expected = DatetimeIndex([datetime(</span><span class="s5">2018</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">NaT])</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;errors, expected&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s3">&quot;coerce&quot;</span><span class="s2">, </span><span class="s1">Index([NaT</span><span class="s2">, </span><span class="s1">NaT]))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">Index([</span><span class="s3">&quot;200622-12-31&quot;</span><span class="s2">, </span><span class="s3">&quot;111111-24-11&quot;</span><span class="s1">]))</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_malformed_no_raise(self</span><span class="s2">, </span><span class="s1">errors</span><span class="s2">, </span><span class="s1">expected):</span>
        <span class="s4"># GH 28299</span>
        <span class="s4"># GH 48633</span>
        <span class="s1">ts_strings = [</span><span class="s3">&quot;200622-12-31&quot;</span><span class="s2">, </span><span class="s3">&quot;111111-24-11&quot;</span><span class="s1">]</span>
        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(UserWarning</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;Could not infer format&quot;</span><span class="s1">):</span>
            <span class="s1">result = to_datetime(ts_strings</span><span class="s2">, </span><span class="s1">errors=errors)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_malformed_raise(self):</span>
        <span class="s4"># GH 48633</span>
        <span class="s1">ts_strings = [</span><span class="s3">&quot;200622-12-31&quot;</span><span class="s2">, </span><span class="s3">&quot;111111-24-11&quot;</span><span class="s1">]</span>
        <span class="s1">msg = (</span>
            <span class="s3">'Parsed string &quot;200622-12-31&quot; gives an invalid tzoffset, which must '</span>
            <span class="s3">r&quot;be between -timedelta\(hours=24\) and timedelta\(hours=24\), &quot;</span>
            <span class="s3">&quot;at position 0&quot;</span>
        <span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(</span>
            <span class="s1">ValueError</span><span class="s2">,</span>
            <span class="s1">match=msg</span><span class="s2">,</span>
        <span class="s1">):</span>
            <span class="s2">with </span><span class="s1">tm.assert_produces_warning(</span>
                <span class="s1">UserWarning</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;Could not infer format&quot;</span>
            <span class="s1">):</span>
                <span class="s1">to_datetime(</span>
                    <span class="s1">ts_strings</span><span class="s2">,</span>
                    <span class="s1">errors=</span><span class="s3">&quot;raise&quot;</span><span class="s2">,</span>
                <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_iso_8601_strings_with_same_offset(self):</span>
        <span class="s4"># GH 17697, 11736</span>
        <span class="s1">ts_str = </span><span class="s3">&quot;2015-11-18 15:30:00+05:30&quot;</span>
        <span class="s1">result = to_datetime(ts_str)</span>
        <span class="s1">expected = Timestamp(ts_str)</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

        <span class="s1">expected = DatetimeIndex([Timestamp(ts_str)] * </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">result = to_datetime([ts_str] * </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = DatetimeIndex([ts_str] * </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_iso_8601_strings_with_different_offsets(self):</span>
        <span class="s4"># GH 17697, 11736, 50887</span>
        <span class="s1">ts_strings = [</span><span class="s3">&quot;2015-11-18 15:30:00+05:30&quot;</span><span class="s2">, </span><span class="s3">&quot;2015-11-18 16:30:00+06:30&quot;</span><span class="s2">, </span><span class="s1">NaT]</span>
        <span class="s1">msg = </span><span class="s3">&quot;parsing datetimes with mixed time zones will raise an error&quot;</span>
        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">result = to_datetime(ts_strings)</span>
        <span class="s1">expected = np.array(</span>
            <span class="s1">[</span>
                <span class="s1">datetime(</span><span class="s5">2015</span><span class="s2">, </span><span class="s5">11</span><span class="s2">, </span><span class="s5">18</span><span class="s2">, </span><span class="s5">15</span><span class="s2">, </span><span class="s5">30</span><span class="s2">, </span><span class="s1">tzinfo=tzoffset(</span><span class="s2">None, </span><span class="s5">19800</span><span class="s1">))</span><span class="s2">,</span>
                <span class="s1">datetime(</span><span class="s5">2015</span><span class="s2">, </span><span class="s5">11</span><span class="s2">, </span><span class="s5">18</span><span class="s2">, </span><span class="s5">16</span><span class="s2">, </span><span class="s5">30</span><span class="s2">, </span><span class="s1">tzinfo=tzoffset(</span><span class="s2">None, </span><span class="s5">23400</span><span class="s1">))</span><span class="s2">,</span>
                <span class="s1">NaT</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">dtype=object</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s4"># GH 21864</span>
        <span class="s1">expected = Index(expected)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_iso_8601_strings_with_different_offsets_utc(self):</span>
        <span class="s1">ts_strings = [</span><span class="s3">&quot;2015-11-18 15:30:00+05:30&quot;</span><span class="s2">, </span><span class="s3">&quot;2015-11-18 16:30:00+06:30&quot;</span><span class="s2">, </span><span class="s1">NaT]</span>
        <span class="s1">result = to_datetime(ts_strings</span><span class="s2">, </span><span class="s1">utc=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">expected = DatetimeIndex(</span>
            <span class="s1">[Timestamp(</span><span class="s5">2015</span><span class="s2">, </span><span class="s5">11</span><span class="s2">, </span><span class="s5">18</span><span class="s2">, </span><span class="s5">10</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s5">2015</span><span class="s2">, </span><span class="s5">11</span><span class="s2">, </span><span class="s5">18</span><span class="s2">, </span><span class="s5">10</span><span class="s1">)</span><span class="s2">, </span><span class="s1">NaT]</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;UTC&quot;</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_mixed_offsets_with_native_datetime_raises(self):</span>
        <span class="s4"># GH 25978</span>

        <span class="s1">vals = [</span>
            <span class="s3">&quot;nan&quot;</span><span class="s2">,</span>
            <span class="s1">Timestamp(</span><span class="s3">&quot;1990-01-01&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;2015-03-14T16:15:14.123-08:00&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;2019-03-04T21:56:32.620-07:00&quot;</span><span class="s2">,</span>
            <span class="s2">None,</span>
            <span class="s3">&quot;today&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;now&quot;</span><span class="s2">,</span>
        <span class="s1">]</span>
        <span class="s1">ser = Series(vals)</span>
        <span class="s2">assert </span><span class="s1">all(ser[i] </span><span class="s2">is </span><span class="s1">vals[i] </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(vals)))  </span><span class="s4"># GH#40111</span>

        <span class="s1">now = Timestamp(</span><span class="s3">&quot;now&quot;</span><span class="s1">)</span>
        <span class="s1">today = Timestamp(</span><span class="s3">&quot;today&quot;</span><span class="s1">)</span>
        <span class="s1">msg = </span><span class="s3">&quot;parsing datetimes with mixed time zones will raise an error&quot;</span>
        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">mixed = to_datetime(ser)</span>
        <span class="s1">expected = Series(</span>
            <span class="s1">[</span>
                <span class="s3">&quot;NaT&quot;</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;1990-01-01&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2015-03-14T16:15:14.123-08:00&quot;</span><span class="s1">).to_pydatetime()</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2019-03-04T21:56:32.620-07:00&quot;</span><span class="s1">).to_pydatetime()</span><span class="s2">,</span>
                <span class="s2">None,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">dtype=object</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(mixed[:-</span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s4"># we'll check mixed[-1] and mixed[-2] match now and today to within</span>
        <span class="s4"># call-timing tolerances</span>
        <span class="s2">assert </span><span class="s1">(now - mixed.iloc[-</span><span class="s5">1</span><span class="s1">]).total_seconds() &lt;= </span><span class="s5">0.1</span>
        <span class="s2">assert </span><span class="s1">(today - mixed.iloc[-</span><span class="s5">2</span><span class="s1">]).total_seconds() &lt;= </span><span class="s5">0.1</span>

        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;Tz-aware datetime.datetime&quot;</span><span class="s1">):</span>
            <span class="s1">to_datetime(mixed)</span>

    <span class="s2">def </span><span class="s1">test_non_iso_strings_with_tz_offset(self):</span>
        <span class="s1">result = to_datetime([</span><span class="s3">&quot;March 1, 2018 12:00:00+0400&quot;</span><span class="s1">] * </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">expected = DatetimeIndex(</span>
            <span class="s1">[datetime(</span><span class="s5">2018</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">12</span><span class="s2">, </span><span class="s1">tzinfo=timezone(timedelta(minutes=</span><span class="s5">240</span><span class="s1">)))] * </span><span class="s5">2</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;ts, expected&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">(Timestamp(</span><span class="s3">&quot;2018-01-01&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;2018-01-01&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;UTC&quot;</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2018-01-01&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;US/Pacific&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2018-01-01 08:00&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;UTC&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_timestamp_utc_true(self</span><span class="s2">, </span><span class="s1">ts</span><span class="s2">, </span><span class="s1">expected):</span>
        <span class="s4"># GH 24415</span>
        <span class="s1">result = to_datetime(ts</span><span class="s2">, </span><span class="s1">utc=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dt_str&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;00010101&quot;</span><span class="s2">, </span><span class="s3">&quot;13000101&quot;</span><span class="s2">, </span><span class="s3">&quot;30000101&quot;</span><span class="s2">, </span><span class="s3">&quot;99990101&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_with_format_out_of_bounds(self</span><span class="s2">, </span><span class="s1">dt_str):</span>
        <span class="s4"># GH 9107</span>
        <span class="s1">msg = </span><span class="s3">&quot;Out of bounds nanosecond timestamp&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(OutOfBoundsDatetime</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(dt_str</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%Y%m%d&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_utc(self):</span>
        <span class="s1">arr = np.array([parse(</span><span class="s3">&quot;2012-06-13T01:39:00Z&quot;</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">dtype=object)</span>

        <span class="s1">result = to_datetime(arr</span><span class="s2">, </span><span class="s1">utc=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">result.tz </span><span class="s2">is </span><span class="s1">timezone.utc</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_fixed_offset(self):</span>
        <span class="s2">from </span><span class="s1">pandas.tests.indexes.datetimes.test_timezones </span><span class="s2">import </span><span class="s1">fixed_off</span>

        <span class="s1">dates = [</span>
            <span class="s1">datetime(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">tzinfo=fixed_off)</span><span class="s2">,</span>
            <span class="s1">datetime(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s1">tzinfo=fixed_off)</span><span class="s2">,</span>
            <span class="s1">datetime(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s1">tzinfo=fixed_off)</span><span class="s2">,</span>
        <span class="s1">]</span>
        <span class="s1">result = to_datetime(dates)</span>
        <span class="s2">assert </span><span class="s1">result.tz == fixed_off</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;date&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s3">&quot;2020-10-26 00:00:00+06:00&quot;</span><span class="s2">, </span><span class="s3">&quot;2020-10-26 00:00:00+01:00&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;2020-10-26 00:00:00+06:00&quot;</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;2018-01-01&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;US/Pacific&quot;</span><span class="s1">)]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s3">&quot;2020-10-26 00:00:00+06:00&quot;</span><span class="s2">,</span>
                <span class="s1">datetime(</span><span class="s5">2020</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">18</span><span class="s2">, </span><span class="s1">tzinfo=pytz.timezone(</span><span class="s3">&quot;Australia/Melbourne&quot;</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_mixed_offsets_with_utc_false_deprecated(self</span><span class="s2">, </span><span class="s1">date):</span>
        <span class="s4"># GH 50887</span>
        <span class="s1">msg = </span><span class="s3">&quot;parsing datetimes with mixed time zones will raise an error&quot;</span>
        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(date</span><span class="s2">, </span><span class="s1">utc=</span><span class="s2">False</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestToDatetimeUnit:</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;unit&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;Y&quot;</span><span class="s2">, </span><span class="s3">&quot;M&quot;</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;item&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s5">150</span><span class="s2">, </span><span class="s1">float(</span><span class="s5">150</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_month_or_year_unit_int(self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">unit</span><span class="s2">, </span><span class="s1">item</span><span class="s2">, </span><span class="s1">request):</span>
        <span class="s4"># GH#50870 Note we have separate tests that pd.Timestamp gets these right</span>
        <span class="s1">ts = Timestamp(item</span><span class="s2">, </span><span class="s1">unit=unit)</span>
        <span class="s1">expected = DatetimeIndex([ts])</span>

        <span class="s1">result = to_datetime([item]</span><span class="s2">, </span><span class="s1">unit=unit</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = to_datetime(np.array([item]</span><span class="s2">, </span><span class="s1">dtype=object)</span><span class="s2">, </span><span class="s1">unit=unit</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s4"># TODO: this should also work</span>
        <span class="s2">if </span><span class="s1">isinstance(item</span><span class="s2">, </span><span class="s1">float):</span>
            <span class="s1">request.node.add_marker(</span>
                <span class="s1">pytest.mark.xfail(</span>
                    <span class="s1">reason=</span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">type(item).__name__</span><span class="s2">} </span><span class="s3">in np.array should work&quot;</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s1">result = to_datetime(np.array([item])</span><span class="s2">, </span><span class="s1">unit=unit</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;unit&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;Y&quot;</span><span class="s2">, </span><span class="s3">&quot;M&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_month_or_year_unit_non_round_float(self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">unit):</span>
        <span class="s4"># GH#50301</span>
        <span class="s4"># Match Timestamp behavior in disallowing non-round floats with</span>
        <span class="s4">#  Y or M unit</span>
        <span class="s1">warn_msg = </span><span class="s3">&quot;strings will be parsed as datetime strings&quot;</span>
        <span class="s1">msg = </span><span class="s3">f&quot;Conversion of non-round float with unit=</span><span class="s2">{</span><span class="s1">unit</span><span class="s2">} </span><span class="s3">is ambiguous&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime([</span><span class="s5">1.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">unit=unit</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;raise&quot;</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s2">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s2">, </span><span class="s1">match=warn_msg):</span>
                <span class="s1">to_datetime([</span><span class="s3">&quot;1.5&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">unit=unit</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;raise&quot;</span><span class="s1">)</span>

        <span class="s4"># with errors=&quot;ignore&quot; we also end up raising within the Timestamp</span>
        <span class="s4">#  constructor; this may not be ideal</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime([</span><span class="s5">1.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">unit=unit</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;ignore&quot;</span><span class="s1">)</span>

        <span class="s1">res = to_datetime([</span><span class="s5">1.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">unit=unit</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s1">)</span>
        <span class="s1">expected = Index([NaT]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;M8[ns]&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(res</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s2">, </span><span class="s1">match=warn_msg):</span>
            <span class="s1">res = to_datetime([</span><span class="s3">&quot;1.5&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">unit=unit</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(res</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s4"># round floats are OK</span>
        <span class="s1">res = to_datetime([</span><span class="s5">1.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">unit=unit)</span>
        <span class="s1">expected = to_datetime([</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">unit=unit)</span>
        <span class="s1">tm.assert_index_equal(res</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_unit(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># GH 11758</span>
        <span class="s4"># test proper behavior with errors</span>
        <span class="s1">msg = </span><span class="s3">&quot;cannot specify both format and unit&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime([</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;D&quot;</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%Y%m%d&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>

    <span class="s2">def </span><span class="s1">test_unit_array_mixed_nans(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s1">values = [</span><span class="s5">11111111111111111</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1.0</span><span class="s2">, </span><span class="s1">iNaT</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">]</span>
        <span class="s1">result = to_datetime(values</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;D&quot;</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected = Index(</span>
            <span class="s1">[</span>
                <span class="s5">11111111111111111</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;1970-01-02&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;1970-01-02&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">NaT</span><span class="s2">,</span>
                <span class="s1">NaT</span><span class="s2">,</span>
                <span class="s1">NaT</span><span class="s2">,</span>
                <span class="s1">NaT</span><span class="s2">,</span>
                <span class="s1">NaT</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">dtype=object</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = to_datetime(values</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;D&quot;</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected = DatetimeIndex(</span>
            <span class="s1">[</span><span class="s3">&quot;NaT&quot;</span><span class="s2">, </span><span class="s3">&quot;1970-01-02&quot;</span><span class="s2">, </span><span class="s3">&quot;1970-01-02&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">msg = </span><span class="s3">&quot;cannot convert input 11111111111111111 with the unit 'D'&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(OutOfBoundsDatetime</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(values</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;D&quot;</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;raise&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>

    <span class="s2">def </span><span class="s1">test_unit_array_mixed_nans_large_int(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s1">values = [</span><span class="s5">1420043460000000000000000</span><span class="s2">, </span><span class="s1">iNaT</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s1">]</span>

        <span class="s1">result = to_datetime(values</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;s&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected = Index([</span><span class="s5">1420043460000000000000000</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s1">NaT]</span><span class="s2">, </span><span class="s1">dtype=object)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = to_datetime(values</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;s&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected = DatetimeIndex([</span><span class="s3">&quot;NaT&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s1">])</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">msg = </span><span class="s3">&quot;cannot convert input 1420043460000000000000000 with the unit 's'&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(OutOfBoundsDatetime</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(values</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;raise&quot;</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;s&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_invalid_str_not_out_of_bounds_valuerror(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># if we have a string, then we raise a ValueError</span>
        <span class="s4"># and NOT an OutOfBoundsDatetime</span>
        <span class="s1">msg = </span><span class="s3">&quot;non convertible value foo with the unit 's'&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(</span><span class="s3">&quot;foo&quot;</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;raise&quot;</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;s&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;error&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;raise&quot;</span><span class="s2">, </span><span class="s3">&quot;coerce&quot;</span><span class="s2">, </span><span class="s3">&quot;ignore&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_unit_consistency(self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">error):</span>
        <span class="s4"># consistency of conversions</span>
        <span class="s1">expected = Timestamp(</span><span class="s3">&quot;1970-05-09 14:25:11&quot;</span><span class="s1">)</span>
        <span class="s1">result = to_datetime(</span><span class="s5">11111111</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;s&quot;</span><span class="s2">, </span><span class="s1">errors=error</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>
        <span class="s2">assert </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">Timestamp)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;errors&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;ignore&quot;</span><span class="s2">, </span><span class="s3">&quot;raise&quot;</span><span class="s2">, </span><span class="s3">&quot;coerce&quot;</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dtype&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;float64&quot;</span><span class="s2">, </span><span class="s3">&quot;int64&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_unit_with_numeric(self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">errors</span><span class="s2">, </span><span class="s1">dtype):</span>
        <span class="s4"># GH 13180</span>
        <span class="s4"># coercions from floats/ints are ok</span>
        <span class="s1">expected = DatetimeIndex([</span><span class="s3">&quot;2015-06-19 05:33:20&quot;</span><span class="s2">, </span><span class="s3">&quot;2015-05-27 22:33:20&quot;</span><span class="s1">])</span>
        <span class="s1">arr = np.array([</span><span class="s5">1.434692e18</span><span class="s2">, </span><span class="s5">1.432766e18</span><span class="s1">]).astype(dtype)</span>
        <span class="s1">result = to_datetime(arr</span><span class="s2">, </span><span class="s1">errors=errors</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;exp, arr, warning&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">[</span>
                <span class="s1">[</span><span class="s3">&quot;NaT&quot;</span><span class="s2">, </span><span class="s3">&quot;2015-06-19 05:33:20&quot;</span><span class="s2">, </span><span class="s3">&quot;2015-05-27 22:33:20&quot;</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s3">&quot;foo&quot;</span><span class="s2">, </span><span class="s5">1.434692e18</span><span class="s2">, </span><span class="s5">1.432766e18</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">UserWarning</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s1">[</span><span class="s3">&quot;2015-06-19 05:33:20&quot;</span><span class="s2">, </span><span class="s3">&quot;2015-05-27 22:33:20&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s5">1.434692e18</span><span class="s2">, </span><span class="s5">1.432766e18</span><span class="s2">, </span><span class="s3">&quot;foo&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s2">None,</span>
            <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_unit_with_numeric_coerce(self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">exp</span><span class="s2">, </span><span class="s1">arr</span><span class="s2">, </span><span class="s1">warning):</span>
        <span class="s4"># but we want to make sure that we are coercing</span>
        <span class="s4"># if we have ints/strings</span>
        <span class="s1">expected = DatetimeIndex(exp)</span>
        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(warning</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;Could not infer format&quot;</span><span class="s1">):</span>
            <span class="s1">result = to_datetime(arr</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;arr&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">[Timestamp(</span><span class="s3">&quot;20130101&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s5">1.434692e18</span><span class="s2">, </span><span class="s5">1.432766e18</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s5">1.434692e18</span><span class="s2">, </span><span class="s5">1.432766e18</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;20130101&quot;</span><span class="s1">)]</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_unit_mixed(self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">arr):</span>
        <span class="s4"># GH#50453 pre-2.0 with mixed numeric/datetimes and errors=&quot;coerce&quot;</span>
        <span class="s4">#  the numeric entries would be coerced to NaT, was never clear exactly</span>
        <span class="s4">#  why.</span>
        <span class="s4"># mixed integers/datetimes</span>
        <span class="s1">expected = Index([Timestamp(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">arr]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;M8[ns]&quot;</span><span class="s1">)</span>
        <span class="s1">result = to_datetime(arr</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s4"># GH#49037 pre-2.0 this raised, but it always worked with Series,</span>
        <span class="s4">#  was never clear why it was disallowed</span>
        <span class="s1">result = to_datetime(arr</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;raise&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = DatetimeIndex(arr)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_unit_rounding(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># GH 14156 &amp; GH 20445: argument will incur floating point errors</span>
        <span class="s4"># but no premature rounding</span>
        <span class="s1">result = to_datetime(</span><span class="s5">1434743731.8770001</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;s&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected = Timestamp(</span><span class="s3">&quot;2015-06-19 19:55:31.877000192&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

    <span class="s2">def </span><span class="s1">test_unit_ignore_keeps_name(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># GH 21697</span>
        <span class="s1">expected = Index([</span><span class="s5">15e9</span><span class="s1">] * </span><span class="s5">2</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;name&quot;</span><span class="s1">)</span>
        <span class="s1">result = to_datetime(expected</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;s&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_errors_ignore_utc_true(self):</span>
        <span class="s4"># GH#23758</span>
        <span class="s1">result = to_datetime([</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;s&quot;</span><span class="s2">, </span><span class="s1">utc=</span><span class="s2">True, </span><span class="s1">errors=</span><span class="s3">&quot;ignore&quot;</span><span class="s1">)</span>
        <span class="s1">expected = DatetimeIndex([</span><span class="s3">&quot;1970-01-01 00:00:01&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">tz=</span><span class="s3">&quot;UTC&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s4"># TODO: this is moved from tests.series.test_timeseries, may be redundant</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;dtype&quot;</span><span class="s2">, </span><span class="s1">[int</span><span class="s2">, </span><span class="s1">float])</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_unit(self</span><span class="s2">, </span><span class="s1">dtype):</span>
        <span class="s1">epoch = </span><span class="s5">1370745748</span>
        <span class="s1">ser = Series([epoch + t </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">20</span><span class="s1">)]).astype(dtype)</span>
        <span class="s1">result = to_datetime(ser</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;s&quot;</span><span class="s1">)</span>
        <span class="s1">expected = Series(</span>
            <span class="s1">[Timestamp(</span><span class="s3">&quot;2013-06-09 02:42:28&quot;</span><span class="s1">) + timedelta(seconds=t) </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">20</span><span class="s1">)]</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;null&quot;</span><span class="s2">, </span><span class="s1">[iNaT</span><span class="s2">, </span><span class="s1">np.nan])</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_unit_with_nulls(self</span><span class="s2">, </span><span class="s1">null):</span>
        <span class="s1">epoch = </span><span class="s5">1370745748</span>
        <span class="s1">ser = Series([epoch + t </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">20</span><span class="s1">)] + [null])</span>
        <span class="s1">result = to_datetime(ser</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;s&quot;</span><span class="s1">)</span>
        <span class="s1">expected = Series(</span>
            <span class="s1">[Timestamp(</span><span class="s3">&quot;2013-06-09 02:42:28&quot;</span><span class="s1">) + timedelta(seconds=t) </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">20</span><span class="s1">)]</span>
            <span class="s1">+ [NaT]</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_unit_fractional_seconds(self):</span>
        <span class="s4"># GH13834</span>
        <span class="s1">epoch = </span><span class="s5">1370745748</span>
        <span class="s1">ser = Series([epoch + t </span><span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">np.arange(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">0.25</span><span class="s1">)] + [iNaT]).astype(float)</span>
        <span class="s1">result = to_datetime(ser</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;s&quot;</span><span class="s1">)</span>
        <span class="s1">expected = Series(</span>
            <span class="s1">[</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2013-06-09 02:42:28&quot;</span><span class="s1">) + timedelta(seconds=t)</span>
                <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">np.arange(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">0.25</span><span class="s1">)</span>
            <span class="s1">]</span>
            <span class="s1">+ [NaT]</span>
        <span class="s1">)</span>
        <span class="s4"># GH20455 argument will incur floating point errors but no premature rounding</span>
        <span class="s1">result = result.round(</span><span class="s3">&quot;ms&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_unit_na_values(self):</span>
        <span class="s1">result = to_datetime([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s1">np.nan]</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;D&quot;</span><span class="s1">)</span>
        <span class="s1">expected = DatetimeIndex(</span>
            <span class="s1">[Timestamp(</span><span class="s3">&quot;1970-01-02&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;1970-01-03&quot;</span><span class="s1">)] + [</span><span class="s3">&quot;NaT&quot;</span><span class="s1">] * </span><span class="s5">3</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;bad_val&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;foo&quot;</span><span class="s2">, </span><span class="s5">111111111</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_unit_invalid(self</span><span class="s2">, </span><span class="s1">bad_val):</span>
        <span class="s1">msg = </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">bad_val</span><span class="s2">} </span><span class="s3">with the unit 'D'&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s1">bad_val]</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;D&quot;</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;bad_val&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;foo&quot;</span><span class="s2">, </span><span class="s5">111111111</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_to_timestamp_unit_coerce(self</span><span class="s2">, </span><span class="s1">bad_val):</span>
        <span class="s4"># coerce we can process</span>
        <span class="s1">expected = DatetimeIndex(</span>
            <span class="s1">[Timestamp(</span><span class="s3">&quot;1970-01-02&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;1970-01-03&quot;</span><span class="s1">)] + [</span><span class="s3">&quot;NaT&quot;</span><span class="s1">] * </span><span class="s5">1</span>
        <span class="s1">)</span>
        <span class="s1">result = to_datetime([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s1">bad_val]</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;D&quot;</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_float_to_datetime_raise_near_bounds(self):</span>
        <span class="s4"># GH50183</span>
        <span class="s1">msg = </span><span class="s3">&quot;cannot convert input with unit 'D'&quot;</span>
        <span class="s1">oneday_in_ns = </span><span class="s5">1e9 </span><span class="s1">* </span><span class="s5">60 </span><span class="s1">* </span><span class="s5">60 </span><span class="s1">* </span><span class="s5">24</span>
        <span class="s1">tsmax_in_days = </span><span class="s5">2</span><span class="s1">**</span><span class="s5">63 </span><span class="s1">/ oneday_in_ns  </span><span class="s4"># 2**63 ns, in days</span>
        <span class="s4"># just in bounds</span>
        <span class="s1">should_succeed = Series(</span>
            <span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">tsmax_in_days - </span><span class="s5">0.005</span><span class="s2">, </span><span class="s1">-tsmax_in_days + </span><span class="s5">0.005</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=float</span>
        <span class="s1">)</span>
        <span class="s1">expected = (should_succeed * oneday_in_ns).astype(np.int64)</span>
        <span class="s2">for </span><span class="s1">error_mode </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;raise&quot;</span><span class="s2">, </span><span class="s3">&quot;coerce&quot;</span><span class="s2">, </span><span class="s3">&quot;ignore&quot;</span><span class="s1">]:</span>
            <span class="s1">result1 = to_datetime(should_succeed</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;D&quot;</span><span class="s2">, </span><span class="s1">errors=error_mode)</span>
            <span class="s1">tm.assert_almost_equal(result1.astype(np.int64)</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-10</span><span class="s1">)</span>
        <span class="s4"># just out of bounds</span>
        <span class="s1">should_fail1 = Series([</span><span class="s5">0</span><span class="s2">, </span><span class="s1">tsmax_in_days + </span><span class="s5">0.005</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=float)</span>
        <span class="s1">should_fail2 = Series([</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-tsmax_in_days - </span><span class="s5">0.005</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=float)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(OutOfBoundsDatetime</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(should_fail1</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;D&quot;</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;raise&quot;</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(OutOfBoundsDatetime</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(should_fail2</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;D&quot;</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;raise&quot;</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestToDatetimeDataFrame:</span>
    <span class="s1">@pytest.fixture</span>
    <span class="s2">def </span><span class="s1">df(self):</span>
        <span class="s2">return </span><span class="s1">DataFrame(</span>
            <span class="s1">{</span>
                <span class="s3">&quot;year&quot;</span><span class="s1">: [</span><span class="s5">2015</span><span class="s2">, </span><span class="s5">2016</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s3">&quot;month&quot;</span><span class="s1">: [</span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s3">&quot;day&quot;</span><span class="s1">: [</span><span class="s5">4</span><span class="s2">, </span><span class="s5">5</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s3">&quot;hour&quot;</span><span class="s1">: [</span><span class="s5">6</span><span class="s2">, </span><span class="s5">7</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s3">&quot;minute&quot;</span><span class="s1">: [</span><span class="s5">58</span><span class="s2">, </span><span class="s5">59</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s3">&quot;second&quot;</span><span class="s1">: [</span><span class="s5">10</span><span class="s2">, </span><span class="s5">11</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s3">&quot;ms&quot;</span><span class="s1">: [</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s3">&quot;us&quot;</span><span class="s1">: [</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s3">&quot;ns&quot;</span><span class="s1">: [</span><span class="s5">3</span><span class="s2">, </span><span class="s5">3</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">}</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_dataframe(self</span><span class="s2">, </span><span class="s1">df</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s1">result = to_datetime(</span>
            <span class="s1">{</span><span class="s3">&quot;year&quot;</span><span class="s1">: df[</span><span class="s3">&quot;year&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;month&quot;</span><span class="s1">: df[</span><span class="s3">&quot;month&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;day&quot;</span><span class="s1">: df[</span><span class="s3">&quot;day&quot;</span><span class="s1">]}</span><span class="s2">, </span><span class="s1">cache=cache</span>
        <span class="s1">)</span>
        <span class="s1">expected = Series(</span>
            <span class="s1">[Timestamp(</span><span class="s3">&quot;20150204 00:00:00&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;20160305 00:0:00&quot;</span><span class="s1">)]</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s4"># dict-like</span>
        <span class="s1">result = to_datetime(df[[</span><span class="s3">&quot;year&quot;</span><span class="s2">, </span><span class="s3">&quot;month&quot;</span><span class="s2">, </span><span class="s3">&quot;day&quot;</span><span class="s1">]].to_dict()</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_dataframe_dict_with_constructable(self</span><span class="s2">, </span><span class="s1">df</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># dict but with constructable</span>
        <span class="s1">df2 = df[[</span><span class="s3">&quot;year&quot;</span><span class="s2">, </span><span class="s3">&quot;month&quot;</span><span class="s2">, </span><span class="s3">&quot;day&quot;</span><span class="s1">]].to_dict()</span>
        <span class="s1">df2[</span><span class="s3">&quot;month&quot;</span><span class="s1">] = </span><span class="s5">2</span>
        <span class="s1">result = to_datetime(df2</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected2 = Series(</span>
            <span class="s1">[Timestamp(</span><span class="s3">&quot;20150204 00:00:00&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;20160205 00:0:00&quot;</span><span class="s1">)]</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected2)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;unit&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">{</span>
                <span class="s3">&quot;year&quot;</span><span class="s1">: </span><span class="s3">&quot;years&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;month&quot;</span><span class="s1">: </span><span class="s3">&quot;months&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;day&quot;</span><span class="s1">: </span><span class="s3">&quot;days&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;hour&quot;</span><span class="s1">: </span><span class="s3">&quot;hours&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;minute&quot;</span><span class="s1">: </span><span class="s3">&quot;minutes&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;second&quot;</span><span class="s1">: </span><span class="s3">&quot;seconds&quot;</span><span class="s2">,</span>
            <span class="s1">}</span><span class="s2">,</span>
            <span class="s1">{</span>
                <span class="s3">&quot;year&quot;</span><span class="s1">: </span><span class="s3">&quot;year&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;month&quot;</span><span class="s1">: </span><span class="s3">&quot;month&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;day&quot;</span><span class="s1">: </span><span class="s3">&quot;day&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;hour&quot;</span><span class="s1">: </span><span class="s3">&quot;hour&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;minute&quot;</span><span class="s1">: </span><span class="s3">&quot;minute&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;second&quot;</span><span class="s1">: </span><span class="s3">&quot;second&quot;</span><span class="s2">,</span>
            <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_dataframe_field_aliases_column_subset(self</span><span class="s2">, </span><span class="s1">df</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">unit):</span>
        <span class="s4"># unit mappings</span>
        <span class="s1">result = to_datetime(df[list(unit.keys())].rename(columns=unit)</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected = Series(</span>
            <span class="s1">[Timestamp(</span><span class="s3">&quot;20150204 06:58:10&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;20160305 07:59:11&quot;</span><span class="s1">)]</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_dataframe_field_aliases(self</span><span class="s2">, </span><span class="s1">df</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s1">d = {</span>
            <span class="s3">&quot;year&quot;</span><span class="s1">: </span><span class="s3">&quot;year&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;month&quot;</span><span class="s1">: </span><span class="s3">&quot;month&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;day&quot;</span><span class="s1">: </span><span class="s3">&quot;day&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;hour&quot;</span><span class="s1">: </span><span class="s3">&quot;hour&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;minute&quot;</span><span class="s1">: </span><span class="s3">&quot;minute&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;second&quot;</span><span class="s1">: </span><span class="s3">&quot;second&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;ms&quot;</span><span class="s1">: </span><span class="s3">&quot;ms&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;us&quot;</span><span class="s1">: </span><span class="s3">&quot;us&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;ns&quot;</span><span class="s1">: </span><span class="s3">&quot;ns&quot;</span><span class="s2">,</span>
        <span class="s1">}</span>

        <span class="s1">result = to_datetime(df.rename(columns=d)</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected = Series(</span>
            <span class="s1">[</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;20150204 06:58:10.001002003&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;20160305 07:59:11.001002003&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_dataframe_str_dtype(self</span><span class="s2">, </span><span class="s1">df</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># coerce back to int</span>
        <span class="s1">result = to_datetime(df.astype(str)</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected = Series(</span>
            <span class="s1">[</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;20150204 06:58:10.001002003&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;20160305 07:59:11.001002003&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_dataframe_coerce(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># passing coerce</span>
        <span class="s1">df2 = DataFrame({</span><span class="s3">&quot;year&quot;</span><span class="s1">: [</span><span class="s5">2015</span><span class="s2">, </span><span class="s5">2016</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;month&quot;</span><span class="s1">: [</span><span class="s5">2</span><span class="s2">, </span><span class="s5">20</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;day&quot;</span><span class="s1">: [</span><span class="s5">4</span><span class="s2">, </span><span class="s5">5</span><span class="s1">]})</span>

        <span class="s1">msg = (</span>
            <span class="s3">r'^cannot assemble the datetimes: time data &quot;.+&quot; doesn\'t '</span>
            <span class="s3">r'match format &quot;%Y%m%d&quot;, at position 1\.'</span>
        <span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(df2</span><span class="s2">, </span><span class="s1">cache=cache)</span>

        <span class="s1">result = to_datetime(df2</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected = Series([Timestamp(</span><span class="s3">&quot;20150204 00:00:00&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">NaT])</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_dataframe_extra_keys_raisesm(self</span><span class="s2">, </span><span class="s1">df</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># extra columns</span>
        <span class="s1">msg = </span><span class="s3">r&quot;extra keys have been passed to the datetime assemblage: \[foo\]&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">df2 = df.copy()</span>
            <span class="s1">df2[</span><span class="s3">&quot;foo&quot;</span><span class="s1">] = </span><span class="s5">1</span>
            <span class="s1">to_datetime(df2</span><span class="s2">, </span><span class="s1">cache=cache)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;cols&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s3">&quot;year&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;year&quot;</span><span class="s2">, </span><span class="s3">&quot;month&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;year&quot;</span><span class="s2">, </span><span class="s3">&quot;month&quot;</span><span class="s2">, </span><span class="s3">&quot;second&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;month&quot;</span><span class="s2">, </span><span class="s3">&quot;day&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;year&quot;</span><span class="s2">, </span><span class="s3">&quot;day&quot;</span><span class="s2">, </span><span class="s3">&quot;second&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_dataframe_missing_keys_raises(self</span><span class="s2">, </span><span class="s1">df</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">cols):</span>
        <span class="s4"># not enough</span>
        <span class="s1">msg = (</span>
            <span class="s3">r&quot;to assemble mappings requires at least that \[year, month, &quot;</span>
            <span class="s3">r&quot;day\] be specified: \[.+\] is missing&quot;</span>
        <span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(df[cols]</span><span class="s2">, </span><span class="s1">cache=cache)</span>

    <span class="s2">def </span><span class="s1">test_dataframe_duplicate_columns_raises(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># duplicates</span>
        <span class="s1">msg = </span><span class="s3">&quot;cannot assemble with duplicate keys&quot;</span>
        <span class="s1">df2 = DataFrame({</span><span class="s3">&quot;year&quot;</span><span class="s1">: [</span><span class="s5">2015</span><span class="s2">, </span><span class="s5">2016</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;month&quot;</span><span class="s1">: [</span><span class="s5">2</span><span class="s2">, </span><span class="s5">20</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;day&quot;</span><span class="s1">: [</span><span class="s5">4</span><span class="s2">, </span><span class="s5">5</span><span class="s1">]})</span>
        <span class="s1">df2.columns = [</span><span class="s3">&quot;year&quot;</span><span class="s2">, </span><span class="s3">&quot;year&quot;</span><span class="s2">, </span><span class="s3">&quot;day&quot;</span><span class="s1">]</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(df2</span><span class="s2">, </span><span class="s1">cache=cache)</span>

        <span class="s1">df2 = DataFrame(</span>
            <span class="s1">{</span><span class="s3">&quot;year&quot;</span><span class="s1">: [</span><span class="s5">2015</span><span class="s2">, </span><span class="s5">2016</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;month&quot;</span><span class="s1">: [</span><span class="s5">2</span><span class="s2">, </span><span class="s5">20</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;day&quot;</span><span class="s1">: [</span><span class="s5">4</span><span class="s2">, </span><span class="s5">5</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;hour&quot;</span><span class="s1">: [</span><span class="s5">4</span><span class="s2">, </span><span class="s5">5</span><span class="s1">]}</span>
        <span class="s1">)</span>
        <span class="s1">df2.columns = [</span><span class="s3">&quot;year&quot;</span><span class="s2">, </span><span class="s3">&quot;month&quot;</span><span class="s2">, </span><span class="s3">&quot;day&quot;</span><span class="s2">, </span><span class="s3">&quot;day&quot;</span><span class="s1">]</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(df2</span><span class="s2">, </span><span class="s1">cache=cache)</span>

    <span class="s2">def </span><span class="s1">test_dataframe_int16(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># GH#13451</span>
        <span class="s1">df = DataFrame({</span><span class="s3">&quot;year&quot;</span><span class="s1">: [</span><span class="s5">2015</span><span class="s2">, </span><span class="s5">2016</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;month&quot;</span><span class="s1">: [</span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;day&quot;</span><span class="s1">: [</span><span class="s5">4</span><span class="s2">, </span><span class="s5">5</span><span class="s1">]})</span>

        <span class="s4"># int16</span>
        <span class="s1">result = to_datetime(df.astype(</span><span class="s3">&quot;int16&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected = Series(</span>
            <span class="s1">[Timestamp(</span><span class="s3">&quot;20150204 00:00:00&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;20160305 00:00:00&quot;</span><span class="s1">)]</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_dataframe_mixed(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># mixed dtypes</span>
        <span class="s1">df = DataFrame({</span><span class="s3">&quot;year&quot;</span><span class="s1">: [</span><span class="s5">2015</span><span class="s2">, </span><span class="s5">2016</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;month&quot;</span><span class="s1">: [</span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;day&quot;</span><span class="s1">: [</span><span class="s5">4</span><span class="s2">, </span><span class="s5">5</span><span class="s1">]})</span>
        <span class="s1">df[</span><span class="s3">&quot;month&quot;</span><span class="s1">] = df[</span><span class="s3">&quot;month&quot;</span><span class="s1">].astype(</span><span class="s3">&quot;int8&quot;</span><span class="s1">)</span>
        <span class="s1">df[</span><span class="s3">&quot;day&quot;</span><span class="s1">] = df[</span><span class="s3">&quot;day&quot;</span><span class="s1">].astype(</span><span class="s3">&quot;int8&quot;</span><span class="s1">)</span>
        <span class="s1">result = to_datetime(df</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected = Series(</span>
            <span class="s1">[Timestamp(</span><span class="s3">&quot;20150204 00:00:00&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;20160305 00:00:00&quot;</span><span class="s1">)]</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_dataframe_float(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># float</span>
        <span class="s1">df = DataFrame({</span><span class="s3">&quot;year&quot;</span><span class="s1">: [</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">2001</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;month&quot;</span><span class="s1">: [</span><span class="s5">1.5</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;day&quot;</span><span class="s1">: [</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]})</span>
        <span class="s1">msg = (</span>
            <span class="s3">r&quot;^cannot assemble the datetimes: unconverted data remains when parsing &quot;</span>
            <span class="s3">r'with format &quot;.*&quot;: &quot;1&quot;, at position 0.'</span>
        <span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(df</span><span class="s2">, </span><span class="s1">cache=cache)</span>

    <span class="s2">def </span><span class="s1">test_dataframe_utc_true(self):</span>
        <span class="s4"># GH#23760</span>
        <span class="s1">df = DataFrame({</span><span class="s3">&quot;year&quot;</span><span class="s1">: [</span><span class="s5">2015</span><span class="s2">, </span><span class="s5">2016</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;month&quot;</span><span class="s1">: [</span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;day&quot;</span><span class="s1">: [</span><span class="s5">4</span><span class="s2">, </span><span class="s5">5</span><span class="s1">]})</span>
        <span class="s1">result = to_datetime(df</span><span class="s2">, </span><span class="s1">utc=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">expected = Series(</span>
            <span class="s1">np.array([</span><span class="s3">&quot;2015-02-04&quot;</span><span class="s2">, </span><span class="s3">&quot;2016-03-05&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;datetime64[ns]&quot;</span><span class="s1">)</span>
        <span class="s1">).dt.tz_localize(</span><span class="s3">&quot;UTC&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">class </span><span class="s1">TestToDatetimeMisc:</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_barely_out_of_bounds(self):</span>
        <span class="s4"># GH#19529</span>
        <span class="s4"># GH#19382 close enough to bounds that dropping nanos would result</span>
        <span class="s4"># in an in-bounds datetime</span>
        <span class="s1">arr = np.array([</span><span class="s3">&quot;2262-04-11 23:47:16.854775808&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=object)</span>

        <span class="s1">msg = </span><span class="s3">&quot;^Out of bounds nanosecond timestamp: .*, at position 0&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(OutOfBoundsDatetime</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(arr)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;arg, exp_str&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s3">&quot;2012-01-01 00:00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;2012-01-01 00:00:00&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;20121001&quot;</span><span class="s2">, </span><span class="s3">&quot;2012-10-01&quot;</span><span class="s1">]</span><span class="s2">,  </span><span class="s4"># bad iso 8601</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_iso8601(self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">, </span><span class="s1">exp_str):</span>
        <span class="s1">result = to_datetime([arg]</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">exp = Timestamp(exp_str)</span>
        <span class="s2">assert </span><span class="s1">result[</span><span class="s5">0</span><span class="s1">] == exp</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;input, format&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s3">&quot;2012&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2012-01&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%d&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2012-01-01&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%d %H&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2012-01-01 10&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%d %H:%M&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2012-01-01 10:00&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%d %H:%M:%S&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2012-01-01 10:00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%d %H:%M:%S.%f&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2012-01-01 10:00:00.123&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%d %H:%M:%S.%f%z&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s5">0</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%d&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;exact&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_iso8601_fails(self</span><span class="s2">, </span><span class="s1">input</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s1">exact):</span>
        <span class="s4"># https://github.com/pandas-dev/pandas/issues/12649</span>
        <span class="s4"># `format` is longer than the string, so this fails regardless of `exact`</span>
        <span class="s2">with </span><span class="s1">pytest.raises(</span>
            <span class="s1">ValueError</span><span class="s2">,</span>
            <span class="s1">match=(</span>
                <span class="s3">rf&quot;time data \&quot;</span><span class="s2">{</span><span class="s1">input</span><span class="s2">}</span><span class="s3">\&quot; doesn't match format &quot;</span>
                <span class="s3">rf&quot;\&quot;</span><span class="s2">{</span><span class="s1">format</span><span class="s2">}</span><span class="s3">\&quot;, at position 0&quot;</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">):</span>
            <span class="s1">to_datetime(input</span><span class="s2">, </span><span class="s1">format=format</span><span class="s2">, </span><span class="s1">exact=exact)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;input, format&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s3">&quot;2012-01-01&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2012-01-01 10&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%d&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2012-01-01 10:00&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%d %H&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2012-01-01 10:00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%d %H:%M&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s5">0</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%d&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_iso8601_exact_fails(self</span><span class="s2">, </span><span class="s1">input</span><span class="s2">, </span><span class="s1">format):</span>
        <span class="s4"># https://github.com/pandas-dev/pandas/issues/12649</span>
        <span class="s4"># `format` is shorter than the date string, so only fails with `exact=True`</span>
        <span class="s1">msg = </span><span class="s3">&quot;|&quot;</span><span class="s1">.join(</span>
            <span class="s1">[</span>
                <span class="s3">'^unconverted data remains when parsing with format &quot;.*&quot;: &quot;.*&quot;'</span>
                <span class="s3">f&quot;, at position 0. </span><span class="s2">{</span><span class="s1">PARSING_ERR_MSG</span><span class="s2">}</span><span class="s3">$&quot;</span><span class="s2">,</span>
                <span class="s3">f'^time data &quot;.*&quot; doesn</span><span class="s2">\'</span><span class="s3">t match format &quot;.*&quot;, at position 0. '</span>
                <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">PARSING_ERR_MSG</span><span class="s2">}</span><span class="s3">$&quot;</span><span class="s2">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(</span>
            <span class="s1">ValueError</span><span class="s2">,</span>
            <span class="s1">match=(msg)</span><span class="s2">,</span>
        <span class="s1">):</span>
            <span class="s1">to_datetime(input</span><span class="s2">, </span><span class="s1">format=format)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;input, format&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s3">&quot;2012-01-01&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2012-01-01 00&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%d&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2012-01-01 00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%d %H&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2012-01-01 00:00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%d %H:%M&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_iso8601_non_exact(self</span><span class="s2">, </span><span class="s1">input</span><span class="s2">, </span><span class="s1">format):</span>
        <span class="s4"># https://github.com/pandas-dev/pandas/issues/12649</span>
        <span class="s1">expected = Timestamp(</span><span class="s5">2012</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">result = to_datetime(input</span><span class="s2">, </span><span class="s1">format=format</span><span class="s2">, </span><span class="s1">exact=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;input, format&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s3">&quot;2020-01&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y/%m&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2020-01-01&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y/%m/%d&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2020-01-01 00&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y/%m/%dT%H&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2020-01-01T00&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y/%m/%d %H&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2020-01-01 00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y/%m/%dT%H:%M&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2020-01-01T00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y/%m/%d %H:%M&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2020-01-01 00:00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y/%m/%dT%H:%M:%S&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2020-01-01T00:00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y/%m/%d %H:%M:%S&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_iso8601_separator(self</span><span class="s2">, </span><span class="s1">input</span><span class="s2">, </span><span class="s1">format):</span>
        <span class="s4"># https://github.com/pandas-dev/pandas/issues/12649</span>
        <span class="s2">with </span><span class="s1">pytest.raises(</span>
            <span class="s1">ValueError</span><span class="s2">,</span>
            <span class="s1">match=(</span>
                <span class="s3">rf&quot;time data \&quot;</span><span class="s2">{</span><span class="s1">input</span><span class="s2">}</span><span class="s3">\&quot; doesn\'t match format &quot;</span>
                <span class="s3">rf&quot;\&quot;</span><span class="s2">{</span><span class="s1">format</span><span class="s2">}</span><span class="s3">\&quot;, at position 0&quot;</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">):</span>
            <span class="s1">to_datetime(input</span><span class="s2">, </span><span class="s1">format=format)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;input, format&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s3">&quot;2020-01&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2020-01-01&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%d&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2020-01-01 00&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%d %H&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2020-01-01T00&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%dT%H&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2020-01-01 00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%d %H:%M&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2020-01-01T00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%dT%H:%M&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2020-01-01 00:00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%d %H:%M:%S&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2020-01-01T00:00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%dT%H:%M:%S&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2020-01-01T00:00:00.000&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%dT%H:%M:%S.%f&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2020-01-01T00:00:00.000000&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%dT%H:%M:%S.%f&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2020-01-01T00:00:00.000000000&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%dT%H:%M:%S.%f&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_iso8601_valid(self</span><span class="s2">, </span><span class="s1">input</span><span class="s2">, </span><span class="s1">format):</span>
        <span class="s4"># https://github.com/pandas-dev/pandas/issues/12649</span>
        <span class="s1">expected = Timestamp(</span><span class="s5">2020</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">result = to_datetime(input</span><span class="s2">, </span><span class="s1">format=format)</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;input, format&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s3">&quot;2020-1&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2020-1-1&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%d&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2020-1-1 0&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%d %H&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2020-1-1T0&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%dT%H&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2020-1-1 0:0&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%d %H:%M&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2020-1-1T0:0&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%dT%H:%M&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2020-1-1 0:0:0&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%d %H:%M:%S&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2020-1-1T0:0:0&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%dT%H:%M:%S&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2020-1-1T0:0:0.000&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%dT%H:%M:%S.%f&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2020-1-1T0:0:0.000000&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%dT%H:%M:%S.%f&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2020-1-1T0:0:0.000000000&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%dT%H:%M:%S.%f&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_iso8601_non_padded(self</span><span class="s2">, </span><span class="s1">input</span><span class="s2">, </span><span class="s1">format):</span>
        <span class="s4"># https://github.com/pandas-dev/pandas/issues/21422</span>
        <span class="s1">expected = Timestamp(</span><span class="s5">2020</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">result = to_datetime(input</span><span class="s2">, </span><span class="s1">format=format)</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;input, format&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s3">&quot;2020-01-01T00:00:00.000000000+00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%dT%H:%M:%S.%f%z&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2020-01-01T00:00:00+00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%dT%H:%M:%S%z&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2020-01-01T00:00:00Z&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%dT%H:%M:%S%z&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_iso8601_with_timezone_valid(self</span><span class="s2">, </span><span class="s1">input</span><span class="s2">, </span><span class="s1">format):</span>
        <span class="s4"># https://github.com/pandas-dev/pandas/issues/12649</span>
        <span class="s1">expected = Timestamp(</span><span class="s5">2020</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">tzinfo=pytz.UTC)</span>
        <span class="s1">result = to_datetime(input</span><span class="s2">, </span><span class="s1">format=format)</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_default(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s1">rs = to_datetime(</span><span class="s3">&quot;2001&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">xp = datetime(</span><span class="s5">2001</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">rs == xp</span>

    <span class="s1">@pytest.mark.xfail(reason=</span><span class="s3">&quot;fails to enforce dayfirst=True, which would raise&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_respects_dayfirst(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># dayfirst is essentially broken</span>

        <span class="s4"># The msg here is not important since it isn't actually raised yet.</span>
        <span class="s1">msg = </span><span class="s3">&quot;Invalid date specified&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s4"># if dayfirst is respected, then this would parse as month=13, which</span>
            <span class="s4">#  would raise</span>
            <span class="s2">with </span><span class="s1">tm.assert_produces_warning(UserWarning</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;Provide format&quot;</span><span class="s1">):</span>
                <span class="s1">to_datetime(</span><span class="s3">&quot;01-13-2012&quot;</span><span class="s2">, </span><span class="s1">dayfirst=</span><span class="s2">True, </span><span class="s1">cache=cache)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_on_datetime64_series(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># #2699</span>
        <span class="s1">ser = Series(date_range(</span><span class="s3">&quot;1/1/2000&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s5">10</span><span class="s1">))</span>

        <span class="s1">result = to_datetime(ser</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s2">assert </span><span class="s1">result[</span><span class="s5">0</span><span class="s1">] == ser[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_with_space_in_series(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># GH 6428</span>
        <span class="s1">ser = Series([</span><span class="s3">&quot;10/18/2006&quot;</span><span class="s2">, </span><span class="s3">&quot;10/18/2008&quot;</span><span class="s2">, </span><span class="s3">&quot; &quot;</span><span class="s1">])</span>
        <span class="s1">msg = (</span>
            <span class="s3">r'^time data &quot; &quot; doesn\'t match format &quot;%m/%d/%Y&quot;, '</span>
            <span class="s3">rf&quot;at position 2. </span><span class="s2">{</span><span class="s1">PARSING_ERR_MSG</span><span class="s2">}</span><span class="s3">$&quot;</span>
        <span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(ser</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;raise&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">result_coerce = to_datetime(ser</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected_coerce = Series([datetime(</span><span class="s5">2006</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">18</span><span class="s1">)</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2008</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">18</span><span class="s1">)</span><span class="s2">, </span><span class="s1">NaT])</span>
        <span class="s1">tm.assert_series_equal(result_coerce</span><span class="s2">, </span><span class="s1">expected_coerce)</span>
        <span class="s1">result_ignore = to_datetime(ser</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">tm.assert_series_equal(result_ignore</span><span class="s2">, </span><span class="s1">ser)</span>

    <span class="s1">@td.skip_if_not_us_locale</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_with_apply(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># this is only locale tested with US/None locales</span>
        <span class="s4"># GH 5195</span>
        <span class="s4"># with a format and coerce a single item to_datetime fails</span>
        <span class="s1">td = Series([</span><span class="s3">&quot;May 04&quot;</span><span class="s2">, </span><span class="s3">&quot;Jun 02&quot;</span><span class="s2">, </span><span class="s3">&quot;Dec 11&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">index=[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s1">])</span>
        <span class="s1">expected = to_datetime(td</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%b %y&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">result = td.apply(to_datetime</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%b %y&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_timezone_name(self):</span>
        <span class="s4"># https://github.com/pandas-dev/pandas/issues/49748</span>
        <span class="s1">result = to_datetime(</span><span class="s3">&quot;2020-01-01 00:00:00UTC&quot;</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%Y-%m-%d %H:%M:%S%Z&quot;</span><span class="s1">)</span>
        <span class="s1">expected = Timestamp(</span><span class="s5">2020</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">).tz_localize(</span><span class="s3">&quot;UTC&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

    <span class="s1">@td.skip_if_not_us_locale</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;errors&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;raise&quot;</span><span class="s2">, </span><span class="s3">&quot;coerce&quot;</span><span class="s2">, </span><span class="s3">&quot;ignore&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_with_apply_with_empty_str(self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">errors):</span>
        <span class="s4"># this is only locale tested with US/None locales</span>
        <span class="s4"># GH 5195, GH50251</span>
        <span class="s4"># with a format and coerce a single item to_datetime fails</span>
        <span class="s1">td = Series([</span><span class="s3">&quot;May 04&quot;</span><span class="s2">, </span><span class="s3">&quot;Jun 02&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">index=[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s1">])</span>
        <span class="s1">expected = to_datetime(td</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%b %y&quot;</span><span class="s2">, </span><span class="s1">errors=errors</span><span class="s2">, </span><span class="s1">cache=cache)</span>

        <span class="s1">result = td.apply(</span>
            <span class="s2">lambda </span><span class="s1">x: to_datetime(x</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;%b %y&quot;</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_empty_stt(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># empty string</span>
        <span class="s1">result = to_datetime(</span><span class="s3">&quot;&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s2">assert </span><span class="s1">result </span><span class="s2">is </span><span class="s1">NaT</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_empty_str_list(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s1">result = to_datetime([</span><span class="s3">&quot;&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s2">assert </span><span class="s1">isna(result).all()</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_zero(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># ints</span>
        <span class="s1">result = Timestamp(</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">expected = to_datetime(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_strings(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># GH 3888 (strings)</span>
        <span class="s1">expected = to_datetime([</span><span class="s3">&quot;2012&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">cache=cache)[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">result = to_datetime(</span><span class="s3">&quot;2012&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_strings_variation(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s1">array = [</span><span class="s3">&quot;2012&quot;</span><span class="s2">, </span><span class="s3">&quot;20120101&quot;</span><span class="s2">, </span><span class="s3">&quot;20120101 12:01:01&quot;</span><span class="s1">]</span>
        <span class="s1">expected = [to_datetime(dt_str</span><span class="s2">, </span><span class="s1">cache=cache) </span><span class="s2">for </span><span class="s1">dt_str </span><span class="s2">in </span><span class="s1">array]</span>
        <span class="s1">result = [Timestamp(date_str) </span><span class="s2">for </span><span class="s1">date_str </span><span class="s2">in </span><span class="s1">array]</span>
        <span class="s1">tm.assert_almost_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;result&quot;</span><span class="s2">, </span><span class="s1">[Timestamp(</span><span class="s3">&quot;2012&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">to_datetime(</span><span class="s3">&quot;2012&quot;</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_strings_vs_constructor(self</span><span class="s2">, </span><span class="s1">result):</span>
        <span class="s1">expected = Timestamp(</span><span class="s5">2012</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_unprocessable_input(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># GH 4928</span>
        <span class="s4"># GH 21864</span>
        <span class="s1">result = to_datetime([</span><span class="s5">1</span><span class="s2">, </span><span class="s3">&quot;1&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>

        <span class="s1">expected = Index(np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s3">&quot;1&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;O&quot;</span><span class="s1">))</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">msg = </span><span class="s3">'^Given date string &quot;1&quot; not likely a datetime, at position 1$'</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime([</span><span class="s5">1</span><span class="s2">, </span><span class="s3">&quot;1&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;raise&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_unhashable_input(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s1">series = Series([[</span><span class="s3">&quot;a&quot;</span><span class="s1">]] * </span><span class="s5">100</span><span class="s1">)</span>
        <span class="s1">result = to_datetime(series</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">tm.assert_series_equal(series</span><span class="s2">, </span><span class="s1">result)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_other_datetime64_units(self):</span>
        <span class="s4"># 5/25/2012</span>
        <span class="s1">scalar = np.int64(</span><span class="s5">1337904000000000</span><span class="s1">).view(</span><span class="s3">&quot;M8[us]&quot;</span><span class="s1">)</span>
        <span class="s1">as_obj = scalar.astype(</span><span class="s3">&quot;O&quot;</span><span class="s1">)</span>

        <span class="s1">index = DatetimeIndex([scalar])</span>
        <span class="s2">assert </span><span class="s1">index[</span><span class="s5">0</span><span class="s1">] == scalar.astype(</span><span class="s3">&quot;O&quot;</span><span class="s1">)</span>

        <span class="s1">value = Timestamp(scalar)</span>
        <span class="s2">assert </span><span class="s1">value == as_obj</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_list_of_integers(self):</span>
        <span class="s1">rng = date_range(</span><span class="s3">&quot;1/1/2000&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s5">20</span><span class="s1">)</span>
        <span class="s1">rng = DatetimeIndex(rng.values)</span>

        <span class="s1">ints = list(rng.asi8)</span>

        <span class="s1">result = DatetimeIndex(ints)</span>

        <span class="s1">tm.assert_index_equal(rng</span><span class="s2">, </span><span class="s1">result)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_overflow(self):</span>
        <span class="s4"># gh-17637</span>
        <span class="s4"># we are overflowing Timedelta range here</span>
        <span class="s1">msg = </span><span class="s3">&quot;Cannot cast 139999 days 00:00:00 to unit='ns' without overflow&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(OutOfBoundsTimedelta</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">date_range(start=</span><span class="s3">&quot;1/1/1700&quot;</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">&quot;B&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s5">100000</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_string_invalid_operation(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s1">invalid = np.array([</span><span class="s3">&quot;87156549591102612381000001219H5&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=object)</span>
        <span class="s4"># GH #51084</span>

        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;Unknown datetime string format&quot;</span><span class="s1">):</span>
            <span class="s1">to_datetime(invalid</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;raise&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>

    <span class="s2">def </span><span class="s1">test_string_na_nat_conversion(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># GH #999, #858</span>

        <span class="s1">strings = np.array([</span><span class="s3">&quot;1/1/2000&quot;</span><span class="s2">, </span><span class="s3">&quot;1/2/2000&quot;</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s3">&quot;1/4/2000&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=object)</span>

        <span class="s1">expected = np.empty(</span><span class="s5">4</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;M8[ns]&quot;</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">val </span><span class="s2">in </span><span class="s1">enumerate(strings):</span>
            <span class="s2">if </span><span class="s1">isna(val):</span>
                <span class="s1">expected[i] = iNaT</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">expected[i] = parse(val)</span>

        <span class="s1">result = tslib.array_to_datetime(strings)[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">tm.assert_almost_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result2 = to_datetime(strings</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s2">assert </span><span class="s1">isinstance(result2</span><span class="s2">, </span><span class="s1">DatetimeIndex)</span>
        <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">result2.values)</span>

    <span class="s2">def </span><span class="s1">test_string_na_nat_conversion_malformed(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s1">malformed = np.array([</span><span class="s3">&quot;1/100/2000&quot;</span><span class="s2">, </span><span class="s1">np.nan]</span><span class="s2">, </span><span class="s1">dtype=object)</span>

        <span class="s4"># GH 10636, default is now 'raise'</span>
        <span class="s1">msg = </span><span class="s3">r&quot;Unknown datetime string format&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(malformed</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;raise&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>

        <span class="s1">result = to_datetime(malformed</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s4"># GH 21864</span>
        <span class="s1">expected = Index(malformed)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(malformed</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;raise&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>

    <span class="s2">def </span><span class="s1">test_string_na_nat_conversion_with_name(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s1">idx = [</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s2">, </span><span class="s3">&quot;d&quot;</span><span class="s2">, </span><span class="s3">&quot;e&quot;</span><span class="s1">]</span>
        <span class="s1">series = Series(</span>
            <span class="s1">[</span><span class="s3">&quot;1/1/2000&quot;</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s3">&quot;1/3/2000&quot;</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s3">&quot;1/5/2000&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">index=idx</span><span class="s2">, </span><span class="s1">name=</span><span class="s3">&quot;foo&quot;</span>
        <span class="s1">)</span>
        <span class="s1">dseries = Series(</span>
            <span class="s1">[</span>
                <span class="s1">to_datetime(</span><span class="s3">&quot;1/1/2000&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span><span class="s2">,</span>
                <span class="s1">np.nan</span><span class="s2">,</span>
                <span class="s1">to_datetime(</span><span class="s3">&quot;1/3/2000&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span><span class="s2">,</span>
                <span class="s1">np.nan</span><span class="s2">,</span>
                <span class="s1">to_datetime(</span><span class="s3">&quot;1/5/2000&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">index=idx</span><span class="s2">,</span>
            <span class="s1">name=</span><span class="s3">&quot;foo&quot;</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s1">result = to_datetime(series</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">dresult = to_datetime(dseries</span><span class="s2">, </span><span class="s1">cache=cache)</span>

        <span class="s1">expected = Series(np.empty(</span><span class="s5">5</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;M8[ns]&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">index=idx)</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">5</span><span class="s1">):</span>
            <span class="s1">x = series.iloc[i]</span>
            <span class="s2">if </span><span class="s1">isna(x):</span>
                <span class="s1">expected.iloc[i] = NaT</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">expected.iloc[i] = to_datetime(x</span><span class="s2">, </span><span class="s1">cache=cache)</span>

        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">check_names=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">result.name == </span><span class="s3">&quot;foo&quot;</span>

        <span class="s1">tm.assert_series_equal(dresult</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">check_names=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">dresult.name == </span><span class="s3">&quot;foo&quot;</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;unit&quot;</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">&quot;h&quot;</span><span class="s2">, </span><span class="s3">&quot;m&quot;</span><span class="s2">, </span><span class="s3">&quot;s&quot;</span><span class="s2">, </span><span class="s3">&quot;ms&quot;</span><span class="s2">, </span><span class="s3">&quot;us&quot;</span><span class="s2">, </span><span class="s3">&quot;ns&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_dti_constructor_numpy_timeunits(self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">unit):</span>
        <span class="s4"># GH 9114</span>
        <span class="s1">dtype = np.dtype(</span><span class="s3">f&quot;M8[</span><span class="s2">{</span><span class="s1">unit</span><span class="s2">}</span><span class="s3">]&quot;</span><span class="s1">)</span>
        <span class="s1">base = to_datetime([</span><span class="s3">&quot;2000-01-01T00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;2000-01-02T00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">cache=cache)</span>

        <span class="s1">values = base.values.astype(dtype)</span>

        <span class="s2">if </span><span class="s1">unit </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;h&quot;</span><span class="s2">, </span><span class="s3">&quot;m&quot;</span><span class="s1">]:</span>
            <span class="s4"># we cast to closest supported unit</span>
            <span class="s1">unit = </span><span class="s3">&quot;s&quot;</span>
        <span class="s1">exp_dtype = np.dtype(</span><span class="s3">f&quot;M8[</span><span class="s2">{</span><span class="s1">unit</span><span class="s2">}</span><span class="s3">]&quot;</span><span class="s1">)</span>
        <span class="s1">expected = DatetimeIndex(base.astype(exp_dtype))</span>
        <span class="s2">assert </span><span class="s1">expected.dtype == exp_dtype</span>

        <span class="s1">tm.assert_index_equal(DatetimeIndex(values)</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">tm.assert_index_equal(to_datetime(values</span><span class="s2">, </span><span class="s1">cache=cache)</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_dayfirst(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># GH 5917</span>
        <span class="s1">arr = [</span><span class="s3">&quot;10/02/2014&quot;</span><span class="s2">, </span><span class="s3">&quot;11/02/2014&quot;</span><span class="s2">, </span><span class="s3">&quot;12/02/2014&quot;</span><span class="s1">]</span>
        <span class="s1">expected = DatetimeIndex(</span>
            <span class="s1">[datetime(</span><span class="s5">2014</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">10</span><span class="s1">)</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2014</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">11</span><span class="s1">)</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2014</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">12</span><span class="s1">)]</span>
        <span class="s1">)</span>
        <span class="s1">idx1 = DatetimeIndex(arr</span><span class="s2">, </span><span class="s1">dayfirst=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">idx2 = DatetimeIndex(np.array(arr)</span><span class="s2">, </span><span class="s1">dayfirst=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">idx3 = to_datetime(arr</span><span class="s2">, </span><span class="s1">dayfirst=</span><span class="s2">True, </span><span class="s1">cache=cache)</span>
        <span class="s1">idx4 = to_datetime(np.array(arr)</span><span class="s2">, </span><span class="s1">dayfirst=</span><span class="s2">True, </span><span class="s1">cache=cache)</span>
        <span class="s1">idx5 = DatetimeIndex(Index(arr)</span><span class="s2">, </span><span class="s1">dayfirst=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">idx6 = DatetimeIndex(Series(arr)</span><span class="s2">, </span><span class="s1">dayfirst=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(expected</span><span class="s2">, </span><span class="s1">idx1)</span>
        <span class="s1">tm.assert_index_equal(expected</span><span class="s2">, </span><span class="s1">idx2)</span>
        <span class="s1">tm.assert_index_equal(expected</span><span class="s2">, </span><span class="s1">idx3)</span>
        <span class="s1">tm.assert_index_equal(expected</span><span class="s2">, </span><span class="s1">idx4)</span>
        <span class="s1">tm.assert_index_equal(expected</span><span class="s2">, </span><span class="s1">idx5)</span>
        <span class="s1">tm.assert_index_equal(expected</span><span class="s2">, </span><span class="s1">idx6)</span>

    <span class="s2">def </span><span class="s1">test_dayfirst_warnings_valid_input(self):</span>
        <span class="s4"># GH 12585</span>
        <span class="s1">warning_msg = (</span>
            <span class="s3">&quot;Parsing dates in .* format when dayfirst=.* was specified. &quot;</span>
            <span class="s3">&quot;Pass `dayfirst=.*` or specify a format to silence this warning.&quot;</span>
        <span class="s1">)</span>

        <span class="s4"># CASE 1: valid input</span>
        <span class="s1">arr = [</span><span class="s3">&quot;31/12/2014&quot;</span><span class="s2">, </span><span class="s3">&quot;10/03/2011&quot;</span><span class="s1">]</span>
        <span class="s1">expected = DatetimeIndex(</span>
            <span class="s1">[</span><span class="s3">&quot;2014-12-31&quot;</span><span class="s2">, </span><span class="s3">&quot;2011-03-10&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;datetime64[ns]&quot;</span><span class="s2">, </span><span class="s1">freq=</span><span class="s2">None</span>
        <span class="s1">)</span>

        <span class="s4"># A. dayfirst arg correct, no warning</span>
        <span class="s1">res1 = to_datetime(arr</span><span class="s2">, </span><span class="s1">dayfirst=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(expected</span><span class="s2">, </span><span class="s1">res1)</span>

        <span class="s4"># B. dayfirst arg incorrect, warning</span>
        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(UserWarning</span><span class="s2">, </span><span class="s1">match=warning_msg):</span>
            <span class="s1">res2 = to_datetime(arr</span><span class="s2">, </span><span class="s1">dayfirst=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(expected</span><span class="s2">, </span><span class="s1">res2)</span>

    <span class="s2">def </span><span class="s1">test_dayfirst_warnings_invalid_input(self):</span>
        <span class="s4"># CASE 2: invalid input</span>
        <span class="s4"># cannot consistently process with single format</span>
        <span class="s4"># ValueError *always* raised</span>

        <span class="s4"># first in DD/MM/YYYY, second in MM/DD/YYYY</span>
        <span class="s1">arr = [</span><span class="s3">&quot;31/12/2014&quot;</span><span class="s2">, </span><span class="s3">&quot;03/30/2011&quot;</span><span class="s1">]</span>

        <span class="s2">with </span><span class="s1">pytest.raises(</span>
            <span class="s1">ValueError</span><span class="s2">,</span>
            <span class="s1">match=(</span>
                <span class="s3">r'^time data &quot;03/30/2011&quot; doesn\'t match format '</span>
                <span class="s3">rf'&quot;%d/%m/%Y&quot;, at position 1. </span><span class="s2">{</span><span class="s1">PARSING_ERR_MSG</span><span class="s2">}</span><span class="s3">$'</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">):</span>
            <span class="s1">to_datetime(arr</span><span class="s2">, </span><span class="s1">dayfirst=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;klass&quot;</span><span class="s2">, </span><span class="s1">[DatetimeIndex</span><span class="s2">, </span><span class="s1">DatetimeArray])</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_dta_tz(self</span><span class="s2">, </span><span class="s1">klass):</span>
        <span class="s4"># GH#27733</span>
        <span class="s1">dti = date_range(</span><span class="s3">&quot;2015-04-05&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s5">3</span><span class="s1">).rename(</span><span class="s3">&quot;foo&quot;</span><span class="s1">)</span>
        <span class="s1">expected = dti.tz_localize(</span><span class="s3">&quot;UTC&quot;</span><span class="s1">)</span>

        <span class="s1">obj = klass(dti)</span>
        <span class="s1">expected = klass(expected)</span>

        <span class="s1">result = to_datetime(obj</span><span class="s2">, </span><span class="s1">utc=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">class </span><span class="s1">TestGuessDatetimeFormat:</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;test_list&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">[</span>
                <span class="s3">&quot;2011-12-30 00:00:00.000000&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;2011-12-30 00:00:00.000000&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;2011-12-30 00:00:00.000000&quot;</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s3">&quot;2011-12-30 00:00:00.000000&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;&quot;</span><span class="s2">, </span><span class="s3">&quot;2011-12-30 00:00:00.000000&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;NaT&quot;</span><span class="s2">, </span><span class="s3">&quot;2011-12-30 00:00:00.000000&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;2011-12-30 00:00:00.000000&quot;</span><span class="s2">, </span><span class="s3">&quot;random_string&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;now&quot;</span><span class="s2">, </span><span class="s3">&quot;2011-12-30 00:00:00.000000&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;today&quot;</span><span class="s2">, </span><span class="s3">&quot;2011-12-30 00:00:00.000000&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_guess_datetime_format_for_array(self</span><span class="s2">, </span><span class="s1">test_list):</span>
        <span class="s1">expected_format = </span><span class="s3">&quot;%Y-%m-%d %H:%M:%S.%f&quot;</span>
        <span class="s1">test_array = np.array(test_list</span><span class="s2">, </span><span class="s1">dtype=object)</span>
        <span class="s2">assert </span><span class="s1">tools._guess_datetime_format_for_array(test_array) == expected_format</span>

    <span class="s1">@td.skip_if_not_us_locale</span>
    <span class="s2">def </span><span class="s1">test_guess_datetime_format_for_array_all_nans(self):</span>
        <span class="s1">format_for_string_of_nans = tools._guess_datetime_format_for_array(</span>
            <span class="s1">np.array([np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;O&quot;</span><span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">format_for_string_of_nans </span><span class="s2">is None</span>


<span class="s2">class </span><span class="s1">TestToDatetimeInferFormat:</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;test_format&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;%m-%d-%Y&quot;</span><span class="s2">, </span><span class="s3">&quot;%m/%d/%Y %H:%M:%S.%f&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%dT%H:%M:%S.%f&quot;</span><span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_infer_datetime_format_consistent_format(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">test_format</span>
    <span class="s1">):</span>
        <span class="s1">ser = Series(date_range(</span><span class="s3">&quot;20000101&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s5">50</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">&quot;H&quot;</span><span class="s1">))</span>

        <span class="s1">s_as_dt_strings = ser.apply(</span><span class="s2">lambda </span><span class="s1">x: x.strftime(test_format))</span>

        <span class="s1">with_format = to_datetime(s_as_dt_strings</span><span class="s2">, </span><span class="s1">format=test_format</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">without_format = to_datetime(s_as_dt_strings</span><span class="s2">, </span><span class="s1">cache=cache)</span>

        <span class="s4"># Whether the format is explicitly passed, or</span>
        <span class="s4"># it is inferred, the results should all be the same</span>
        <span class="s1">tm.assert_series_equal(with_format</span><span class="s2">, </span><span class="s1">without_format)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_inconsistent_format(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s1">data = [</span><span class="s3">&quot;01/01/2011 00:00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;01-02-2011 00:00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;2011-01-03T00:00:00&quot;</span><span class="s1">]</span>
        <span class="s1">ser = Series(np.array(data))</span>
        <span class="s1">msg = (</span>
            <span class="s3">r'^time data &quot;01-02-2011 00:00:00&quot; doesn\'t match format '</span>
            <span class="s3">rf'&quot;%m/%d/%Y %H:%M:%S&quot;, at position 1. </span><span class="s2">{</span><span class="s1">PARSING_ERR_MSG</span><span class="s2">}</span><span class="s3">$'</span>
        <span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(ser</span><span class="s2">, </span><span class="s1">cache=cache)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_consistent_format(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s1">data = [</span><span class="s3">&quot;Jan/01/2011&quot;</span><span class="s2">, </span><span class="s3">&quot;Feb/01/2011&quot;</span><span class="s2">, </span><span class="s3">&quot;Mar/01/2011&quot;</span><span class="s1">]</span>
        <span class="s1">ser = Series(np.array(data))</span>
        <span class="s1">result = to_datetime(ser</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected = Series(</span>
            <span class="s1">[</span><span class="s3">&quot;2011-01-01&quot;</span><span class="s2">, </span><span class="s3">&quot;2011-02-01&quot;</span><span class="s2">, </span><span class="s3">&quot;2011-03-01&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;datetime64[ns]&quot;</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_series_with_nans(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s1">ser = Series(</span>
            <span class="s1">np.array(</span>
                <span class="s1">[</span><span class="s3">&quot;01/01/2011 00:00:00&quot;</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s3">&quot;01/03/2011 00:00:00&quot;</span><span class="s2">, </span><span class="s1">np.nan]</span><span class="s2">,</span>
                <span class="s1">dtype=object</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s1">result = to_datetime(ser</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected = Series(</span>
            <span class="s1">[</span><span class="s3">&quot;2011-01-01&quot;</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s3">&quot;2011-01-03&quot;</span><span class="s2">, </span><span class="s1">NaT]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;datetime64[ns]&quot;</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_to_datetime_series_start_with_nans(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s1">ser = Series(</span>
            <span class="s1">np.array(</span>
                <span class="s1">[</span>
                    <span class="s1">np.nan</span><span class="s2">,</span>
                    <span class="s1">np.nan</span><span class="s2">,</span>
                    <span class="s3">&quot;01/01/2011 00:00:00&quot;</span><span class="s2">,</span>
                    <span class="s3">&quot;01/02/2011 00:00:00&quot;</span><span class="s2">,</span>
                    <span class="s3">&quot;01/03/2011 00:00:00&quot;</span><span class="s2">,</span>
                <span class="s1">]</span><span class="s2">,</span>
                <span class="s1">dtype=object</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

        <span class="s1">result = to_datetime(ser</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">expected = Series(</span>
            <span class="s1">[NaT</span><span class="s2">, </span><span class="s1">NaT</span><span class="s2">, </span><span class="s3">&quot;2011-01-01&quot;</span><span class="s2">, </span><span class="s3">&quot;2011-01-02&quot;</span><span class="s2">, </span><span class="s3">&quot;2011-01-03&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;datetime64[ns]&quot;</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;tz_name, offset&quot;</span><span class="s2">,</span>
        <span class="s1">[(</span><span class="s3">&quot;UTC&quot;</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;UTC-3&quot;</span><span class="s2">, </span><span class="s5">180</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;UTC+3&quot;</span><span class="s2">, </span><span class="s1">-</span><span class="s5">180</span><span class="s1">)]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_infer_datetime_format_tz_name(self</span><span class="s2">, </span><span class="s1">tz_name</span><span class="s2">, </span><span class="s1">offset):</span>
        <span class="s4"># GH 33133</span>
        <span class="s1">ser = Series([</span><span class="s3">f&quot;2019-02-02 08:07:13 </span><span class="s2">{</span><span class="s1">tz_name</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">])</span>
        <span class="s1">result = to_datetime(ser)</span>
        <span class="s1">tz = timezone(timedelta(minutes=offset))</span>
        <span class="s1">expected = Series([Timestamp(</span><span class="s3">&quot;2019-02-02 08:07:13&quot;</span><span class="s1">).tz_localize(tz)])</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;ts,zero_tz&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s3">&quot;2019-02-02 08:07:13&quot;</span><span class="s2">, </span><span class="s3">&quot;Z&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2019-02-02 08:07:13&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2019-02-02 08:07:13.012345&quot;</span><span class="s2">, </span><span class="s3">&quot;Z&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2019-02-02 08:07:13.012345&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_infer_datetime_format_zero_tz(self</span><span class="s2">, </span><span class="s1">ts</span><span class="s2">, </span><span class="s1">zero_tz):</span>
        <span class="s4"># GH 41047</span>
        <span class="s1">ser = Series([ts + zero_tz])</span>
        <span class="s1">result = to_datetime(ser)</span>
        <span class="s1">tz = pytz.utc </span><span class="s2">if </span><span class="s1">zero_tz == </span><span class="s3">&quot;Z&quot; </span><span class="s2">else None</span>
        <span class="s1">expected = Series([Timestamp(ts</span><span class="s2">, </span><span class="s1">tz=tz)])</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;format&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">None, </span><span class="s3">&quot;%Y-%m-%d&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_iso8601_noleading_0s(self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">format):</span>
        <span class="s4"># GH 11871</span>
        <span class="s1">ser = Series([</span><span class="s3">&quot;2014-1-1&quot;</span><span class="s2">, </span><span class="s3">&quot;2014-2-2&quot;</span><span class="s2">, </span><span class="s3">&quot;2015-3-3&quot;</span><span class="s1">])</span>
        <span class="s1">expected = Series(</span>
            <span class="s1">[</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2014-01-01&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2014-02-02&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">Timestamp(</span><span class="s3">&quot;2015-03-03&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(to_datetime(ser</span><span class="s2">, </span><span class="s1">format=format</span><span class="s2">, </span><span class="s1">cache=cache)</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_parse_dates_infer_datetime_format_warning(self):</span>
        <span class="s4"># GH 49024</span>
        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(</span>
            <span class="s1">UserWarning</span><span class="s2">,</span>
            <span class="s1">match=</span><span class="s3">&quot;The argument 'infer_datetime_format' is deprecated&quot;</span><span class="s2">,</span>
        <span class="s1">):</span>
            <span class="s1">to_datetime([</span><span class="s3">&quot;10-10-2000&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">infer_datetime_format=</span><span class="s2">True</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestDaysInMonth:</span>
    <span class="s4"># tests for issue #10154</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;arg, format&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s3">&quot;2015-02-29&quot;</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;2015-02-29&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%d&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;2015-02-32&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%d&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;2015-04-31&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%d&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_day_not_in_month_coerce(self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">, </span><span class="s1">format):</span>
        <span class="s2">assert </span><span class="s1">isna(to_datetime(arg</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s2">, </span><span class="s1">format=format</span><span class="s2">, </span><span class="s1">cache=cache))</span>

    <span class="s2">def </span><span class="s1">test_day_not_in_month_raise(self</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s1">msg = </span><span class="s3">&quot;day is out of range for month: 2015-02-29, at position 0&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(</span><span class="s3">&quot;2015-02-29&quot;</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;raise&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;arg, format, msg&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span>
                <span class="s3">&quot;2015-02-29&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;%Y-%m-%d&quot;</span><span class="s2">,</span>
                <span class="s3">f&quot;^day is out of range for month, at position 0. </span><span class="s2">{</span><span class="s1">PARSING_ERR_MSG</span><span class="s2">}</span><span class="s3">$&quot;</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span>
                <span class="s3">&quot;2015-29-02&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;%Y-%d-%m&quot;</span><span class="s2">,</span>
                <span class="s3">f&quot;^day is out of range for month, at position 0. </span><span class="s2">{</span><span class="s1">PARSING_ERR_MSG</span><span class="s2">}</span><span class="s3">$&quot;</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span>
                <span class="s3">&quot;2015-02-32&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;%Y-%m-%d&quot;</span><span class="s2">,</span>
                <span class="s3">'^unconverted data remains when parsing with format &quot;%Y-%m-%d&quot;: &quot;2&quot;, '</span>
                <span class="s3">f&quot;at position 0. </span><span class="s2">{</span><span class="s1">PARSING_ERR_MSG</span><span class="s2">}</span><span class="s3">$&quot;</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span>
                <span class="s3">&quot;2015-32-02&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;%Y-%d-%m&quot;</span><span class="s2">,</span>
                <span class="s3">'^time data &quot;2015-32-02&quot; doesn</span><span class="s2">\'</span><span class="s3">t match format &quot;%Y-%d-%m&quot;, '</span>
                <span class="s3">f&quot;at position 0. </span><span class="s2">{</span><span class="s1">PARSING_ERR_MSG</span><span class="s2">}</span><span class="s3">$&quot;</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span>
                <span class="s3">&quot;2015-04-31&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;%Y-%m-%d&quot;</span><span class="s2">,</span>
                <span class="s3">f&quot;^day is out of range for month, at position 0. </span><span class="s2">{</span><span class="s1">PARSING_ERR_MSG</span><span class="s2">}</span><span class="s3">$&quot;</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span>
                <span class="s3">&quot;2015-31-04&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;%Y-%d-%m&quot;</span><span class="s2">,</span>
                <span class="s3">f&quot;^day is out of range for month, at position 0. </span><span class="s2">{</span><span class="s1">PARSING_ERR_MSG</span><span class="s2">}</span><span class="s3">$&quot;</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_day_not_in_month_raise_value(self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s1">msg):</span>
        <span class="s4"># https://github.com/pandas-dev/pandas/issues/50462</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(arg</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;raise&quot;</span><span class="s2">, </span><span class="s1">format=format</span><span class="s2">, </span><span class="s1">cache=cache)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;expected, format&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s3">&quot;2015-02-29&quot;</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;2015-02-29&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%d&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;2015-02-29&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%d&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;2015-04-31&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%d&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_day_not_in_month_ignore(self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">format):</span>
        <span class="s1">result = to_datetime(expected</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">format=format</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>


<span class="s2">class </span><span class="s1">TestDatetimeParsingWrappers:</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;date_str, expected&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s3">&quot;2011-01-01&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2011</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2Q2005&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2005</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2Q05&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2005</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2005Q1&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2005</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;05Q1&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2005</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2011Q3&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2011</span><span class="s2">, </span><span class="s5">7</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;11Q3&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2011</span><span class="s2">, </span><span class="s5">7</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;3Q2011&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2011</span><span class="s2">, </span><span class="s5">7</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;3Q11&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2011</span><span class="s2">, </span><span class="s5">7</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s4"># quarterly without space</span>
            <span class="s1">(</span><span class="s3">&quot;2000Q4&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;00Q4&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;4Q2000&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;4Q00&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2000q4&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2000-Q4&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;00-Q4&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;4Q-2000&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;4Q-00&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;00q4&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2005&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2005</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2005-11&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2005</span><span class="s2">, </span><span class="s5">11</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2005 11&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2005</span><span class="s2">, </span><span class="s5">11</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;11-2005&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2005</span><span class="s2">, </span><span class="s5">11</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;11 2005&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2005</span><span class="s2">, </span><span class="s5">11</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;200511&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2020</span><span class="s2">, </span><span class="s5">5</span><span class="s2">, </span><span class="s5">11</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;20051109&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2005</span><span class="s2">, </span><span class="s5">11</span><span class="s2">, </span><span class="s5">9</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;20051109 10:15&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2005</span><span class="s2">, </span><span class="s5">11</span><span class="s2">, </span><span class="s5">9</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">15</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;20051109 08H&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2005</span><span class="s2">, </span><span class="s5">11</span><span class="s2">, </span><span class="s5">9</span><span class="s2">, </span><span class="s5">8</span><span class="s2">, </span><span class="s5">0</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2005-11-09 10:15&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2005</span><span class="s2">, </span><span class="s5">11</span><span class="s2">, </span><span class="s5">9</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">15</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2005-11-09 08H&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2005</span><span class="s2">, </span><span class="s5">11</span><span class="s2">, </span><span class="s5">9</span><span class="s2">, </span><span class="s5">8</span><span class="s2">, </span><span class="s5">0</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2005/11/09 10:15&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2005</span><span class="s2">, </span><span class="s5">11</span><span class="s2">, </span><span class="s5">9</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">15</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2005/11/09 10:15:32&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2005</span><span class="s2">, </span><span class="s5">11</span><span class="s2">, </span><span class="s5">9</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">15</span><span class="s2">, </span><span class="s5">32</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2005/11/09 10:15:32 AM&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2005</span><span class="s2">, </span><span class="s5">11</span><span class="s2">, </span><span class="s5">9</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">15</span><span class="s2">, </span><span class="s5">32</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2005/11/09 10:15:32 PM&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2005</span><span class="s2">, </span><span class="s5">11</span><span class="s2">, </span><span class="s5">9</span><span class="s2">, </span><span class="s5">22</span><span class="s2">, </span><span class="s5">15</span><span class="s2">, </span><span class="s5">32</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2005/11/09 08H&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2005</span><span class="s2">, </span><span class="s5">11</span><span class="s2">, </span><span class="s5">9</span><span class="s2">, </span><span class="s5">8</span><span class="s2">, </span><span class="s5">0</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;Thu Sep 25 10:36:28 2003&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2003</span><span class="s2">, </span><span class="s5">9</span><span class="s2">, </span><span class="s5">25</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">36</span><span class="s2">, </span><span class="s5">28</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;Thu Sep 25 2003&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2003</span><span class="s2">, </span><span class="s5">9</span><span class="s2">, </span><span class="s5">25</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;Sep 25 2003&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2003</span><span class="s2">, </span><span class="s5">9</span><span class="s2">, </span><span class="s5">25</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;January 1 2014&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2014</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s4"># GHE10537</span>
            <span class="s1">(</span><span class="s3">&quot;2014-06&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2014</span><span class="s2">, </span><span class="s5">6</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;06-2014&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2014</span><span class="s2">, </span><span class="s5">6</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;2014-6&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2014</span><span class="s2">, </span><span class="s5">6</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;6-2014&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2014</span><span class="s2">, </span><span class="s5">6</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;20010101 12&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2001</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">12</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;20010101 1234&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2001</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">12</span><span class="s2">, </span><span class="s5">34</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;20010101 123456&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">2001</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">12</span><span class="s2">, </span><span class="s5">34</span><span class="s2">, </span><span class="s5">56</span><span class="s1">))</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_parsers(self</span><span class="s2">, </span><span class="s1">date_str</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">cache):</span>
        <span class="s4"># dateutil &gt;= 2.5.0 defaults to yearfirst=True</span>
        <span class="s4"># https://github.com/dateutil/dateutil/issues/217</span>
        <span class="s1">yearfirst = </span><span class="s2">True</span>

        <span class="s1">result1</span><span class="s2">, </span><span class="s1">_ = parsing.parse_datetime_string_with_reso(</span>
            <span class="s1">date_str</span><span class="s2">, </span><span class="s1">yearfirst=yearfirst</span>
        <span class="s1">)</span>
        <span class="s1">result2 = to_datetime(date_str</span><span class="s2">, </span><span class="s1">yearfirst=yearfirst)</span>
        <span class="s1">result3 = to_datetime([date_str]</span><span class="s2">, </span><span class="s1">yearfirst=yearfirst)</span>
        <span class="s4"># result5 is used below</span>
        <span class="s1">result4 = to_datetime(</span>
            <span class="s1">np.array([date_str]</span><span class="s2">, </span><span class="s1">dtype=object)</span><span class="s2">, </span><span class="s1">yearfirst=yearfirst</span><span class="s2">, </span><span class="s1">cache=cache</span>
        <span class="s1">)</span>
        <span class="s1">result6 = DatetimeIndex([date_str]</span><span class="s2">, </span><span class="s1">yearfirst=yearfirst)</span>
        <span class="s4"># result7 is used below</span>
        <span class="s1">result8 = DatetimeIndex(Index([date_str])</span><span class="s2">, </span><span class="s1">yearfirst=yearfirst)</span>
        <span class="s1">result9 = DatetimeIndex(Series([date_str])</span><span class="s2">, </span><span class="s1">yearfirst=yearfirst)</span>

        <span class="s2">for </span><span class="s1">res </span><span class="s2">in </span><span class="s1">[result1</span><span class="s2">, </span><span class="s1">result2]:</span>
            <span class="s2">assert </span><span class="s1">res == expected</span>
        <span class="s2">for </span><span class="s1">res </span><span class="s2">in </span><span class="s1">[result3</span><span class="s2">, </span><span class="s1">result4</span><span class="s2">, </span><span class="s1">result6</span><span class="s2">, </span><span class="s1">result8</span><span class="s2">, </span><span class="s1">result9]:</span>
            <span class="s1">exp = DatetimeIndex([Timestamp(expected)])</span>
            <span class="s1">tm.assert_index_equal(res</span><span class="s2">, </span><span class="s1">exp)</span>

        <span class="s4"># these really need to have yearfirst, but we don't support</span>
        <span class="s2">if not </span><span class="s1">yearfirst:</span>
            <span class="s1">result5 = Timestamp(date_str)</span>
            <span class="s2">assert </span><span class="s1">result5 == expected</span>
            <span class="s1">result7 = date_range(date_str</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">&quot;S&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">yearfirst=yearfirst)</span>
            <span class="s2">assert </span><span class="s1">result7 == expected</span>

    <span class="s2">def </span><span class="s1">test_na_values_with_cache(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">unique_nulls_fixture</span><span class="s2">, </span><span class="s1">unique_nulls_fixture2</span>
    <span class="s1">):</span>
        <span class="s4"># GH22305</span>
        <span class="s1">expected = Index([NaT</span><span class="s2">, </span><span class="s1">NaT]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;datetime64[ns]&quot;</span><span class="s1">)</span>
        <span class="s1">result = to_datetime([unique_nulls_fixture</span><span class="s2">, </span><span class="s1">unique_nulls_fixture2]</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_parsers_nat(self):</span>
        <span class="s4"># Test that each of several string-accepting methods return pd.NaT</span>
        <span class="s1">result1</span><span class="s2">, </span><span class="s1">_ = parsing.parse_datetime_string_with_reso(</span><span class="s3">&quot;NaT&quot;</span><span class="s1">)</span>
        <span class="s1">result2 = to_datetime(</span><span class="s3">&quot;NaT&quot;</span><span class="s1">)</span>
        <span class="s1">result3 = Timestamp(</span><span class="s3">&quot;NaT&quot;</span><span class="s1">)</span>
        <span class="s1">result4 = DatetimeIndex([</span><span class="s3">&quot;NaT&quot;</span><span class="s1">])[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s2">assert </span><span class="s1">result1 </span><span class="s2">is </span><span class="s1">NaT</span>
        <span class="s2">assert </span><span class="s1">result2 </span><span class="s2">is </span><span class="s1">NaT</span>
        <span class="s2">assert </span><span class="s1">result3 </span><span class="s2">is </span><span class="s1">NaT</span>
        <span class="s2">assert </span><span class="s1">result4 </span><span class="s2">is </span><span class="s1">NaT</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;date_str, dayfirst, yearfirst, expected&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s3">&quot;10-11-12&quot;</span><span class="s2">, False, False, </span><span class="s1">datetime(</span><span class="s5">2012</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">11</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;10-11-12&quot;</span><span class="s2">, True, False, </span><span class="s1">datetime(</span><span class="s5">2012</span><span class="s2">, </span><span class="s5">11</span><span class="s2">, </span><span class="s5">10</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;10-11-12&quot;</span><span class="s2">, False, True, </span><span class="s1">datetime(</span><span class="s5">2010</span><span class="s2">, </span><span class="s5">11</span><span class="s2">, </span><span class="s5">12</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;10-11-12&quot;</span><span class="s2">, True, True, </span><span class="s1">datetime(</span><span class="s5">2010</span><span class="s2">, </span><span class="s5">12</span><span class="s2">, </span><span class="s5">11</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;20/12/21&quot;</span><span class="s2">, False, False, </span><span class="s1">datetime(</span><span class="s5">2021</span><span class="s2">, </span><span class="s5">12</span><span class="s2">, </span><span class="s5">20</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;20/12/21&quot;</span><span class="s2">, True, False, </span><span class="s1">datetime(</span><span class="s5">2021</span><span class="s2">, </span><span class="s5">12</span><span class="s2">, </span><span class="s5">20</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;20/12/21&quot;</span><span class="s2">, False, True, </span><span class="s1">datetime(</span><span class="s5">2020</span><span class="s2">, </span><span class="s5">12</span><span class="s2">, </span><span class="s5">21</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;20/12/21&quot;</span><span class="s2">, True, True, </span><span class="s1">datetime(</span><span class="s5">2020</span><span class="s2">, </span><span class="s5">12</span><span class="s2">, </span><span class="s5">21</span><span class="s1">))</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_parsers_dayfirst_yearfirst(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">date_str</span><span class="s2">, </span><span class="s1">dayfirst</span><span class="s2">, </span><span class="s1">yearfirst</span><span class="s2">, </span><span class="s1">expected</span>
    <span class="s1">):</span>
        <span class="s4"># OK</span>
        <span class="s4"># 2.5.1 10-11-12   [dayfirst=0, yearfirst=0] -&gt; 2012-10-11 00:00:00</span>
        <span class="s4"># 2.5.2 10-11-12   [dayfirst=0, yearfirst=1] -&gt; 2012-10-11 00:00:00</span>
        <span class="s4"># 2.5.3 10-11-12   [dayfirst=0, yearfirst=0] -&gt; 2012-10-11 00:00:00</span>

        <span class="s4"># OK</span>
        <span class="s4"># 2.5.1 10-11-12   [dayfirst=0, yearfirst=1] -&gt; 2010-11-12 00:00:00</span>
        <span class="s4"># 2.5.2 10-11-12   [dayfirst=0, yearfirst=1] -&gt; 2010-11-12 00:00:00</span>
        <span class="s4"># 2.5.3 10-11-12   [dayfirst=0, yearfirst=1] -&gt; 2010-11-12 00:00:00</span>

        <span class="s4"># bug fix in 2.5.2</span>
        <span class="s4"># 2.5.1 10-11-12   [dayfirst=1, yearfirst=1] -&gt; 2010-11-12 00:00:00</span>
        <span class="s4"># 2.5.2 10-11-12   [dayfirst=1, yearfirst=1] -&gt; 2010-12-11 00:00:00</span>
        <span class="s4"># 2.5.3 10-11-12   [dayfirst=1, yearfirst=1] -&gt; 2010-12-11 00:00:00</span>

        <span class="s4"># OK</span>
        <span class="s4"># 2.5.1 10-11-12   [dayfirst=1, yearfirst=0] -&gt; 2012-11-10 00:00:00</span>
        <span class="s4"># 2.5.2 10-11-12   [dayfirst=1, yearfirst=0] -&gt; 2012-11-10 00:00:00</span>
        <span class="s4"># 2.5.3 10-11-12   [dayfirst=1, yearfirst=0] -&gt; 2012-11-10 00:00:00</span>

        <span class="s4"># OK</span>
        <span class="s4"># 2.5.1 20/12/21   [dayfirst=0, yearfirst=0] -&gt; 2021-12-20 00:00:00</span>
        <span class="s4"># 2.5.2 20/12/21   [dayfirst=0, yearfirst=0] -&gt; 2021-12-20 00:00:00</span>
        <span class="s4"># 2.5.3 20/12/21   [dayfirst=0, yearfirst=0] -&gt; 2021-12-20 00:00:00</span>

        <span class="s4"># OK</span>
        <span class="s4"># 2.5.1 20/12/21   [dayfirst=0, yearfirst=1] -&gt; 2020-12-21 00:00:00</span>
        <span class="s4"># 2.5.2 20/12/21   [dayfirst=0, yearfirst=1] -&gt; 2020-12-21 00:00:00</span>
        <span class="s4"># 2.5.3 20/12/21   [dayfirst=0, yearfirst=1] -&gt; 2020-12-21 00:00:00</span>

        <span class="s4"># revert of bug in 2.5.2</span>
        <span class="s4"># 2.5.1 20/12/21   [dayfirst=1, yearfirst=1] -&gt; 2020-12-21 00:00:00</span>
        <span class="s4"># 2.5.2 20/12/21   [dayfirst=1, yearfirst=1] -&gt; month must be in 1..12</span>
        <span class="s4"># 2.5.3 20/12/21   [dayfirst=1, yearfirst=1] -&gt; 2020-12-21 00:00:00</span>

        <span class="s4"># OK</span>
        <span class="s4"># 2.5.1 20/12/21   [dayfirst=1, yearfirst=0] -&gt; 2021-12-20 00:00:00</span>
        <span class="s4"># 2.5.2 20/12/21   [dayfirst=1, yearfirst=0] -&gt; 2021-12-20 00:00:00</span>
        <span class="s4"># 2.5.3 20/12/21   [dayfirst=1, yearfirst=0] -&gt; 2021-12-20 00:00:00</span>

        <span class="s4"># str : dayfirst, yearfirst, expected</span>

        <span class="s4"># compare with dateutil result</span>
        <span class="s1">dateutil_result = parse(date_str</span><span class="s2">, </span><span class="s1">dayfirst=dayfirst</span><span class="s2">, </span><span class="s1">yearfirst=yearfirst)</span>
        <span class="s2">assert </span><span class="s1">dateutil_result == expected</span>

        <span class="s1">result1</span><span class="s2">, </span><span class="s1">_ = parsing.parse_datetime_string_with_reso(</span>
            <span class="s1">date_str</span><span class="s2">, </span><span class="s1">dayfirst=dayfirst</span><span class="s2">, </span><span class="s1">yearfirst=yearfirst</span>
        <span class="s1">)</span>

        <span class="s4"># we don't support dayfirst/yearfirst here:</span>
        <span class="s2">if not </span><span class="s1">dayfirst </span><span class="s2">and not </span><span class="s1">yearfirst:</span>
            <span class="s1">result2 = Timestamp(date_str)</span>
            <span class="s2">assert </span><span class="s1">result2 == expected</span>

        <span class="s1">result3 = to_datetime(</span>
            <span class="s1">date_str</span><span class="s2">, </span><span class="s1">dayfirst=dayfirst</span><span class="s2">, </span><span class="s1">yearfirst=yearfirst</span><span class="s2">, </span><span class="s1">cache=cache</span>
        <span class="s1">)</span>

        <span class="s1">result4 = DatetimeIndex([date_str]</span><span class="s2">, </span><span class="s1">dayfirst=dayfirst</span><span class="s2">, </span><span class="s1">yearfirst=yearfirst)[</span><span class="s5">0</span><span class="s1">]</span>

        <span class="s2">assert </span><span class="s1">result1 == expected</span>
        <span class="s2">assert </span><span class="s1">result3 == expected</span>
        <span class="s2">assert </span><span class="s1">result4 == expected</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;date_str, exp_def&quot;</span><span class="s2">,</span>
        <span class="s1">[[</span><span class="s3">&quot;10:15&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">10</span><span class="s2">, </span><span class="s5">15</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;9:05&quot;</span><span class="s2">, </span><span class="s1">datetime(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">9</span><span class="s2">, </span><span class="s5">5</span><span class="s1">)]]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_parsers_timestring(self</span><span class="s2">, </span><span class="s1">date_str</span><span class="s2">, </span><span class="s1">exp_def):</span>
        <span class="s4"># must be the same as dateutil result</span>
        <span class="s1">exp_now = parse(date_str)</span>

        <span class="s1">result1</span><span class="s2">, </span><span class="s1">_ = parsing.parse_datetime_string_with_reso(date_str)</span>
        <span class="s1">result2 = to_datetime(date_str)</span>
        <span class="s1">result3 = to_datetime([date_str])</span>
        <span class="s1">result4 = Timestamp(date_str)</span>
        <span class="s1">result5 = DatetimeIndex([date_str])[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s4"># parse time string return time string based on default date</span>
        <span class="s4"># others are not, and can't be changed because it is used in</span>
        <span class="s4"># time series plot</span>
        <span class="s2">assert </span><span class="s1">result1 == exp_def</span>
        <span class="s2">assert </span><span class="s1">result2 == exp_now</span>
        <span class="s2">assert </span><span class="s1">result3 == exp_now</span>
        <span class="s2">assert </span><span class="s1">result4 == exp_now</span>
        <span class="s2">assert </span><span class="s1">result5 == exp_now</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;dt_string, tz, dt_string_repr&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span>
                <span class="s3">&quot;2013-01-01 05:45+0545&quot;</span><span class="s2">,</span>
                <span class="s1">timezone(timedelta(minutes=</span><span class="s5">345</span><span class="s1">))</span><span class="s2">,</span>
                <span class="s3">&quot;Timestamp('2013-01-01 05:45:00+0545', tz='UTC+05:45')&quot;</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span>
                <span class="s3">&quot;2013-01-01 05:30+0530&quot;</span><span class="s2">,</span>
                <span class="s1">timezone(timedelta(minutes=</span><span class="s5">330</span><span class="s1">))</span><span class="s2">,</span>
                <span class="s3">&quot;Timestamp('2013-01-01 05:30:00+0530', tz='UTC+05:30')&quot;</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_parsers_timezone_minute_offsets_roundtrip(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">cache</span><span class="s2">, </span><span class="s1">dt_string</span><span class="s2">, </span><span class="s1">tz</span><span class="s2">, </span><span class="s1">dt_string_repr</span>
    <span class="s1">):</span>
        <span class="s4"># GH11708</span>
        <span class="s1">base = to_datetime(</span><span class="s3">&quot;2013-01-01 00:00:00&quot;</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s1">base = base.tz_localize(</span><span class="s3">&quot;UTC&quot;</span><span class="s1">).tz_convert(tz)</span>
        <span class="s1">dt_time = to_datetime(dt_string</span><span class="s2">, </span><span class="s1">cache=cache)</span>
        <span class="s2">assert </span><span class="s1">base == dt_time</span>
        <span class="s2">assert </span><span class="s1">dt_string_repr == repr(dt_time)</span>


<span class="s1">@pytest.fixture(params=[</span><span class="s3">&quot;D&quot;</span><span class="s2">, </span><span class="s3">&quot;s&quot;</span><span class="s2">, </span><span class="s3">&quot;ms&quot;</span><span class="s2">, </span><span class="s3">&quot;us&quot;</span><span class="s2">, </span><span class="s3">&quot;ns&quot;</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">units(request):</span>
    <span class="s0">&quot;&quot;&quot;Day and some time units. 
 
    * D 
    * s 
    * ms 
    * us 
    * ns 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">request.param</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">epoch_1960():</span>
    <span class="s0">&quot;&quot;&quot;Timestamp at 1960-01-01.&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">Timestamp(</span><span class="s3">&quot;1960-01-01&quot;</span><span class="s1">)</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">units_from_epochs():</span>
    <span class="s2">return </span><span class="s1">list(range(</span><span class="s5">5</span><span class="s1">))</span>


<span class="s1">@pytest.fixture(params=[</span><span class="s3">&quot;timestamp&quot;</span><span class="s2">, </span><span class="s3">&quot;pydatetime&quot;</span><span class="s2">, </span><span class="s3">&quot;datetime64&quot;</span><span class="s2">, </span><span class="s3">&quot;str_1960&quot;</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">epochs(epoch_1960</span><span class="s2">, </span><span class="s1">request):</span>
    <span class="s0">&quot;&quot;&quot;Timestamp at 1960-01-01 in various forms. 
 
    * Timestamp 
    * datetime.datetime 
    * numpy.datetime64 
    * str 
    &quot;&quot;&quot;</span>
    <span class="s2">assert </span><span class="s1">request.param </span><span class="s2">in </span><span class="s1">{</span><span class="s3">&quot;timestamp&quot;</span><span class="s2">, </span><span class="s3">&quot;pydatetime&quot;</span><span class="s2">, </span><span class="s3">&quot;datetime64&quot;</span><span class="s2">, </span><span class="s3">&quot;str_1960&quot;</span><span class="s1">}</span>
    <span class="s2">if </span><span class="s1">request.param == </span><span class="s3">&quot;timestamp&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">epoch_1960</span>
    <span class="s2">elif </span><span class="s1">request.param == </span><span class="s3">&quot;pydatetime&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">epoch_1960.to_pydatetime()</span>
    <span class="s2">elif </span><span class="s1">request.param == </span><span class="s3">&quot;datetime64&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">epoch_1960.to_datetime64()</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">str(epoch_1960)</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">julian_dates():</span>
    <span class="s2">return </span><span class="s1">date_range(</span><span class="s3">&quot;2014-1-1&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s5">10</span><span class="s1">).to_julian_date().values</span>


<span class="s2">class </span><span class="s1">TestOrigin:</span>
    <span class="s2">def </span><span class="s1">test_origin_and_unit(self):</span>
        <span class="s4"># GH#42624</span>
        <span class="s1">ts = to_datetime(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;s&quot;</span><span class="s2">, </span><span class="s1">origin=</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">expected = Timestamp(</span><span class="s3">&quot;1970-01-01 00:00:02&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">ts == expected</span>

        <span class="s1">ts = to_datetime(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;s&quot;</span><span class="s2">, </span><span class="s1">origin=</span><span class="s5">1_000_000_000</span><span class="s1">)</span>
        <span class="s1">expected = Timestamp(</span><span class="s3">&quot;2001-09-09 01:46:41&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">ts == expected</span>

    <span class="s2">def </span><span class="s1">test_julian(self</span><span class="s2">, </span><span class="s1">julian_dates):</span>
        <span class="s4"># gh-11276, gh-11745</span>
        <span class="s4"># for origin as julian</span>

        <span class="s1">result = Series(to_datetime(julian_dates</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;D&quot;</span><span class="s2">, </span><span class="s1">origin=</span><span class="s3">&quot;julian&quot;</span><span class="s1">))</span>
        <span class="s1">expected = Series(</span>
            <span class="s1">to_datetime(julian_dates - Timestamp(</span><span class="s5">0</span><span class="s1">).to_julian_date()</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;D&quot;</span><span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_unix(self):</span>
        <span class="s1">result = Series(to_datetime([</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;D&quot;</span><span class="s2">, </span><span class="s1">origin=</span><span class="s3">&quot;unix&quot;</span><span class="s1">))</span>
        <span class="s1">expected = Series(</span>
            <span class="s1">[Timestamp(</span><span class="s3">&quot;1970-01-01&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;1970-01-02&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;1970-01-03&quot;</span><span class="s1">)]</span>
        <span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_julian_round_trip(self):</span>
        <span class="s1">result = to_datetime(</span><span class="s5">2456658</span><span class="s2">, </span><span class="s1">origin=</span><span class="s3">&quot;julian&quot;</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;D&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">result.to_julian_date() == </span><span class="s5">2456658</span>

        <span class="s4"># out-of-bounds</span>
        <span class="s1">msg = </span><span class="s3">&quot;1 is Out of Bounds for origin='julian'&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">origin=</span><span class="s3">&quot;julian&quot;</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;D&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_invalid_unit(self</span><span class="s2">, </span><span class="s1">units</span><span class="s2">, </span><span class="s1">julian_dates):</span>
        <span class="s4"># checking for invalid combination of origin='julian' and unit != D</span>
        <span class="s2">if </span><span class="s1">units != </span><span class="s3">&quot;D&quot;</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s3">&quot;unit must be 'D' for origin='julian'&quot;</span>
            <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
                <span class="s1">to_datetime(julian_dates</span><span class="s2">, </span><span class="s1">unit=units</span><span class="s2">, </span><span class="s1">origin=</span><span class="s3">&quot;julian&quot;</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;unit&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;ns&quot;</span><span class="s2">, </span><span class="s3">&quot;D&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_invalid_origin(self</span><span class="s2">, </span><span class="s1">unit):</span>
        <span class="s4"># need to have a numeric specified</span>
        <span class="s1">msg = </span><span class="s3">&quot;it must be numeric with a unit specified&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(</span><span class="s3">&quot;2005-01-01&quot;</span><span class="s2">, </span><span class="s1">origin=</span><span class="s3">&quot;1960-01-01&quot;</span><span class="s2">, </span><span class="s1">unit=unit)</span>

    <span class="s2">def </span><span class="s1">test_epoch(self</span><span class="s2">, </span><span class="s1">units</span><span class="s2">, </span><span class="s1">epochs</span><span class="s2">, </span><span class="s1">epoch_1960</span><span class="s2">, </span><span class="s1">units_from_epochs):</span>
        <span class="s1">expected = Series(</span>
            <span class="s1">[pd.Timedelta(x</span><span class="s2">, </span><span class="s1">unit=units) + epoch_1960 </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">units_from_epochs]</span>
        <span class="s1">)</span>

        <span class="s1">result = Series(to_datetime(units_from_epochs</span><span class="s2">, </span><span class="s1">unit=units</span><span class="s2">, </span><span class="s1">origin=epochs))</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;origin, exc&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s3">&quot;random_string&quot;</span><span class="s2">, </span><span class="s1">ValueError)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;epoch&quot;</span><span class="s2">, </span><span class="s1">ValueError)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;13-24-1990&quot;</span><span class="s2">, </span><span class="s1">ValueError)</span><span class="s2">,</span>
            <span class="s1">(datetime(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">OutOfBoundsDatetime)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_invalid_origins(self</span><span class="s2">, </span><span class="s1">origin</span><span class="s2">, </span><span class="s1">exc</span><span class="s2">, </span><span class="s1">units</span><span class="s2">, </span><span class="s1">units_from_epochs):</span>
        <span class="s1">msg = </span><span class="s3">&quot;|&quot;</span><span class="s1">.join(</span>
            <span class="s1">[</span>
                <span class="s3">f&quot;origin </span><span class="s2">{</span><span class="s1">origin</span><span class="s2">} </span><span class="s3">is Out of Bounds&quot;</span><span class="s2">,</span>
                <span class="s3">f&quot;origin </span><span class="s2">{</span><span class="s1">origin</span><span class="s2">} </span><span class="s3">cannot be converted to a Timestamp&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;Cannot cast .* to unit='ns' without overflow&quot;</span><span class="s2">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(exc</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(units_from_epochs</span><span class="s2">, </span><span class="s1">unit=units</span><span class="s2">, </span><span class="s1">origin=origin)</span>

    <span class="s2">def </span><span class="s1">test_invalid_origins_tzinfo(self):</span>
        <span class="s4"># GH16842</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;must be tz-naive&quot;</span><span class="s1">):</span>
            <span class="s1">to_datetime(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;D&quot;</span><span class="s2">, </span><span class="s1">origin=datetime(</span><span class="s5">2000</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">tzinfo=pytz.utc))</span>

    <span class="s2">def </span><span class="s1">test_incorrect_value_exception(self):</span>
        <span class="s4"># GH47495</span>
        <span class="s1">msg = (</span>
            <span class="s3">&quot;Unknown datetime string format, unable to parse: yesterday, at position 1&quot;</span>
        <span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime([</span><span class="s3">&quot;today&quot;</span><span class="s2">, </span><span class="s3">&quot;yesterday&quot;</span><span class="s1">])</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;format, warning&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s2">None, </span><span class="s1">UserWarning)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;%Y-%m-%d %H:%M:%S&quot;</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;%Y-%d-%m %H:%M:%S&quot;</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_to_datetime_out_of_bounds_with_format_arg(self</span><span class="s2">, </span><span class="s1">format</span><span class="s2">, </span><span class="s1">warning):</span>
        <span class="s4"># see gh-23830</span>
        <span class="s1">msg = </span><span class="s3">r&quot;^Out of bounds nanosecond timestamp: 2417-10-10 00:00:00, at position 0&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(OutOfBoundsDatetime</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">to_datetime(</span><span class="s3">&quot;2417-10-10 00:00:00&quot;</span><span class="s2">, </span><span class="s1">format=format)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;arg, origin, expected_str&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s5">200 </span><span class="s1">* </span><span class="s5">365</span><span class="s2">, </span><span class="s3">&quot;unix&quot;</span><span class="s2">, </span><span class="s3">&quot;2169-11-13 00:00:00&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s5">200 </span><span class="s1">* </span><span class="s5">365</span><span class="s2">, </span><span class="s3">&quot;1870-01-01&quot;</span><span class="s2">, </span><span class="s3">&quot;2069-11-13 00:00:00&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s5">300 </span><span class="s1">* </span><span class="s5">365</span><span class="s2">, </span><span class="s3">&quot;1870-01-01&quot;</span><span class="s2">, </span><span class="s3">&quot;2169-10-20 00:00:00&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_processing_order(self</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">, </span><span class="s1">origin</span><span class="s2">, </span><span class="s1">expected_str):</span>
        <span class="s4"># make sure we handle out-of-bounds *before*</span>
        <span class="s4"># constructing the dates</span>

        <span class="s1">result = to_datetime(arg</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;D&quot;</span><span class="s2">, </span><span class="s1">origin=origin)</span>
        <span class="s1">expected = Timestamp(expected_str)</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

        <span class="s1">result = to_datetime(</span><span class="s5">200 </span><span class="s1">* </span><span class="s5">365</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;D&quot;</span><span class="s2">, </span><span class="s1">origin=</span><span class="s3">&quot;1870-01-01&quot;</span><span class="s1">)</span>
        <span class="s1">expected = Timestamp(</span><span class="s3">&quot;2069-11-13 00:00:00&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

        <span class="s1">result = to_datetime(</span><span class="s5">300 </span><span class="s1">* </span><span class="s5">365</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;D&quot;</span><span class="s2">, </span><span class="s1">origin=</span><span class="s3">&quot;1870-01-01&quot;</span><span class="s1">)</span>
        <span class="s1">expected = Timestamp(</span><span class="s3">&quot;2169-10-20 00:00:00&quot;</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;offset,utc,exp&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s3">&quot;Z&quot;</span><span class="s2">, True, </span><span class="s3">&quot;2019-01-01T00:00:00.000Z&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;Z&quot;</span><span class="s2">, None, </span><span class="s3">&quot;2019-01-01T00:00:00.000Z&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;-01:00&quot;</span><span class="s2">, True, </span><span class="s3">&quot;2019-01-01T01:00:00.000Z&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;-01:00&quot;</span><span class="s2">, None, </span><span class="s3">&quot;2019-01-01T00:00:00.000-01:00&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_arg_tz_ns_unit(self</span><span class="s2">, </span><span class="s1">offset</span><span class="s2">, </span><span class="s1">utc</span><span class="s2">, </span><span class="s1">exp):</span>
        <span class="s4"># GH 25546</span>
        <span class="s1">arg = </span><span class="s3">&quot;2019-01-01T00:00:00.000&quot; </span><span class="s1">+ offset</span>
        <span class="s1">result = to_datetime([arg]</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;ns&quot;</span><span class="s2">, </span><span class="s1">utc=utc)</span>
        <span class="s1">expected = to_datetime([exp])</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">class </span><span class="s1">TestShouldCache:</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;listlike,do_caching&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s5">5</span><span class="s2">, </span><span class="s5">6</span><span class="s2">, </span><span class="s5">7</span><span class="s2">, </span><span class="s5">8</span><span class="s2">, </span><span class="s5">9</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, False</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s5">5</span><span class="s2">, </span><span class="s5">6</span><span class="s2">, </span><span class="s5">7</span><span class="s2">, </span><span class="s5">8</span><span class="s2">, </span><span class="s5">9</span><span class="s1">]</span><span class="s2">, True</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_should_cache(self</span><span class="s2">, </span><span class="s1">listlike</span><span class="s2">, </span><span class="s1">do_caching):</span>
        <span class="s2">assert </span><span class="s1">(</span>
            <span class="s1">tools.should_cache(listlike</span><span class="s2">, </span><span class="s1">check_count=len(listlike)</span><span class="s2">, </span><span class="s1">unique_share=</span><span class="s5">0.7</span><span class="s1">)</span>
            <span class="s1">== do_caching</span>
        <span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;unique_share,check_count, err_message&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">11</span><span class="s2">, </span><span class="s3">r&quot;check_count must be in next bounds: \[0; len\(arg\)\]&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s5">10</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s3">r&quot;unique_share must be in next bounds: \(0; 1\)&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_should_cache_errors(self</span><span class="s2">, </span><span class="s1">unique_share</span><span class="s2">, </span><span class="s1">check_count</span><span class="s2">, </span><span class="s1">err_message):</span>
        <span class="s1">arg = [</span><span class="s5">5</span><span class="s1">] * </span><span class="s5">10</span>

        <span class="s2">with </span><span class="s1">pytest.raises(AssertionError</span><span class="s2">, </span><span class="s1">match=err_message):</span>
            <span class="s1">tools.should_cache(arg</span><span class="s2">, </span><span class="s1">unique_share</span><span class="s2">, </span><span class="s1">check_count)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;listlike&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">(deque([Timestamp(</span><span class="s3">&quot;2010-06-02 09:30:00&quot;</span><span class="s1">)] * </span><span class="s5">51</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">([Timestamp(</span><span class="s3">&quot;2010-06-02 09:30:00&quot;</span><span class="s1">)] * </span><span class="s5">51</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(tuple([Timestamp(</span><span class="s3">&quot;2010-06-02 09:30:00&quot;</span><span class="s1">)] * </span><span class="s5">51</span><span class="s1">))</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_no_slicing_errors_in_should_cache(self</span><span class="s2">, </span><span class="s1">listlike):</span>
        <span class="s4"># GH#29403</span>
        <span class="s2">assert </span><span class="s1">tools.should_cache(listlike) </span><span class="s2">is True</span>


<span class="s2">def </span><span class="s1">test_nullable_integer_to_datetime():</span>
    <span class="s4"># Test for #30050</span>
    <span class="s1">ser = Series([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, None, </span><span class="s5">2</span><span class="s1">**</span><span class="s5">61</span><span class="s2">, None</span><span class="s1">])</span>
    <span class="s1">ser = ser.astype(</span><span class="s3">&quot;Int64&quot;</span><span class="s1">)</span>
    <span class="s1">ser_copy = ser.copy()</span>

    <span class="s1">res = to_datetime(ser</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;ns&quot;</span><span class="s1">)</span>

    <span class="s1">expected = Series(</span>
        <span class="s1">[</span>
            <span class="s1">np.datetime64(</span><span class="s3">&quot;1970-01-01 00:00:00.000000001&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">np.datetime64(</span><span class="s3">&quot;1970-01-01 00:00:00.000000002&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">np.datetime64(</span><span class="s3">&quot;NaT&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">np.datetime64(</span><span class="s3">&quot;2043-01-25 23:56:49.213693952&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">np.datetime64(</span><span class="s3">&quot;NaT&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(res</span><span class="s2">, </span><span class="s1">expected)</span>
    <span class="s4"># Check that ser isn't mutated</span>
    <span class="s1">tm.assert_series_equal(ser</span><span class="s2">, </span><span class="s1">ser_copy)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;klass&quot;</span><span class="s2">, </span><span class="s1">[np.array</span><span class="s2">, </span><span class="s1">list])</span>
<span class="s2">def </span><span class="s1">test_na_to_datetime(nulls_fixture</span><span class="s2">, </span><span class="s1">klass):</span>
    <span class="s2">if </span><span class="s1">isinstance(nulls_fixture</span><span class="s2">, </span><span class="s1">Decimal):</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;not convertible to datetime&quot;</span><span class="s1">):</span>
            <span class="s1">to_datetime(klass([nulls_fixture]))</span>

    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">result = to_datetime(klass([nulls_fixture]))</span>

        <span class="s2">assert </span><span class="s1">result[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">is </span><span class="s1">NaT</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;errors&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;raise&quot;</span><span class="s2">, </span><span class="s3">&quot;coerce&quot;</span><span class="s2">, </span><span class="s3">&quot;ignore&quot;</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;args, format&quot;</span><span class="s2">,</span>
    <span class="s1">[</span>
        <span class="s1">([</span><span class="s3">&quot;03/24/2016&quot;</span><span class="s2">, </span><span class="s3">&quot;03/25/2016&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;%m/%d/%Y&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">([</span><span class="s3">&quot;2016-03-24&quot;</span><span class="s2">, </span><span class="s3">&quot;2016-03-25&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;%Y-%m-%d&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">ids=[</span><span class="s3">&quot;non-ISO8601&quot;</span><span class="s2">, </span><span class="s3">&quot;ISO8601&quot;</span><span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_empty_string_datetime(errors</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">format):</span>
    <span class="s4"># GH13044, GH50251</span>
    <span class="s1">td = Series(args)</span>

    <span class="s4"># coerce empty string to pd.NaT</span>
    <span class="s1">result = to_datetime(td</span><span class="s2">, </span><span class="s1">format=format</span><span class="s2">, </span><span class="s1">errors=errors)</span>
    <span class="s1">expected = Series([</span><span class="s3">&quot;2016-03-24&quot;</span><span class="s2">, </span><span class="s3">&quot;2016-03-25&quot;</span><span class="s2">, </span><span class="s1">NaT]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;datetime64[ns]&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(expected</span><span class="s2">, </span><span class="s1">result)</span>


<span class="s2">def </span><span class="s1">test_empty_string_datetime_coerce__unit():</span>
    <span class="s4"># GH13044</span>
    <span class="s4"># coerce empty string to pd.NaT</span>
    <span class="s1">result = to_datetime([</span><span class="s5">1</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;s&quot;</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s1">)</span>
    <span class="s1">expected = DatetimeIndex([</span><span class="s3">&quot;1970-01-01 00:00:01&quot;</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;datetime64[ns]&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_index_equal(expected</span><span class="s2">, </span><span class="s1">result)</span>

    <span class="s4"># verify that no exception is raised even when errors='raise' is set</span>
    <span class="s1">result = to_datetime([</span><span class="s5">1</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">unit=</span><span class="s3">&quot;s&quot;</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;raise&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_index_equal(expected</span><span class="s2">, </span><span class="s1">result)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;cache&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_to_datetime_monotonic_increasing_index(cache):</span>
    <span class="s4"># GH28238</span>
    <span class="s1">cstart = start_caching_at</span>
    <span class="s1">times = date_range(Timestamp(</span><span class="s3">&quot;1980&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">periods=cstart</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">&quot;YS&quot;</span><span class="s1">)</span>
    <span class="s1">times = times.to_frame(index=</span><span class="s2">False, </span><span class="s1">name=</span><span class="s3">&quot;DT&quot;</span><span class="s1">).sample(n=cstart</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">times.index = times.index.to_series().astype(float) / </span><span class="s5">1000</span>
    <span class="s1">result = to_datetime(times.iloc[:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">cache=cache)</span>
    <span class="s1">expected = times.iloc[:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;series_length&quot;</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s5">40</span><span class="s2">, </span><span class="s1">start_caching_at</span><span class="s2">, </span><span class="s1">(start_caching_at + </span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(start_caching_at + </span><span class="s5">5</span><span class="s1">)]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_to_datetime_cache_coerce_50_lines_outofbounds(series_length):</span>
    <span class="s4"># GH#45319</span>
    <span class="s1">s = Series(</span>
        <span class="s1">[datetime.fromisoformat(</span><span class="s3">&quot;1446-04-12 00:00:00+00:00&quot;</span><span class="s1">)]</span>
        <span class="s1">+ ([datetime.fromisoformat(</span><span class="s3">&quot;1991-10-20 00:00:00+00:00&quot;</span><span class="s1">)] * series_length)</span>
    <span class="s1">)</span>
    <span class="s1">result1 = to_datetime(s</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;coerce&quot;</span><span class="s2">, </span><span class="s1">utc=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s1">expected1 = Series(</span>
        <span class="s1">[NaT] + ([Timestamp(</span><span class="s3">&quot;1991-10-20 00:00:00+00:00&quot;</span><span class="s1">)] * series_length)</span>
    <span class="s1">)</span>

    <span class="s1">tm.assert_series_equal(result1</span><span class="s2">, </span><span class="s1">expected1)</span>

    <span class="s1">result2 = to_datetime(s</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">utc=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s1">expected2 = Series(</span>
        <span class="s1">[datetime.fromisoformat(</span><span class="s3">&quot;1446-04-12 00:00:00+00:00&quot;</span><span class="s1">)]</span>
        <span class="s1">+ ([datetime.fromisoformat(</span><span class="s3">&quot;1991-10-20 00:00:00+00:00&quot;</span><span class="s1">)] * series_length)</span>
    <span class="s1">)</span>

    <span class="s1">tm.assert_series_equal(result2</span><span class="s2">, </span><span class="s1">expected2)</span>

    <span class="s2">with </span><span class="s1">pytest.raises(OutOfBoundsDatetime</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;Out of bounds nanosecond timestamp&quot;</span><span class="s1">):</span>
        <span class="s1">to_datetime(s</span><span class="s2">, </span><span class="s1">errors=</span><span class="s3">&quot;raise&quot;</span><span class="s2">, </span><span class="s1">utc=</span><span class="s2">True</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_to_datetime_format_f_parse_nanos():</span>
    <span class="s4"># GH 48767</span>
    <span class="s1">timestamp = </span><span class="s3">&quot;15/02/2020 02:03:04.123456789&quot;</span>
    <span class="s1">timestamp_format = </span><span class="s3">&quot;%d/%m/%Y %H:%M:%S.%f&quot;</span>
    <span class="s1">result = to_datetime(timestamp</span><span class="s2">, </span><span class="s1">format=timestamp_format)</span>
    <span class="s1">expected = Timestamp(</span>
        <span class="s1">year=</span><span class="s5">2020</span><span class="s2">,</span>
        <span class="s1">month=</span><span class="s5">2</span><span class="s2">,</span>
        <span class="s1">day=</span><span class="s5">15</span><span class="s2">,</span>
        <span class="s1">hour=</span><span class="s5">2</span><span class="s2">,</span>
        <span class="s1">minute=</span><span class="s5">3</span><span class="s2">,</span>
        <span class="s1">second=</span><span class="s5">4</span><span class="s2">,</span>
        <span class="s1">microsecond=</span><span class="s5">123456</span><span class="s2">,</span>
        <span class="s1">nanosecond=</span><span class="s5">789</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">result == expected</span>


<span class="s2">def </span><span class="s1">test_to_datetime_mixed_iso8601():</span>
    <span class="s4"># https://github.com/pandas-dev/pandas/issues/50411</span>
    <span class="s1">result = to_datetime([</span><span class="s3">&quot;2020-01-01&quot;</span><span class="s2">, </span><span class="s3">&quot;2020-01-01 05:00:00&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;ISO8601&quot;</span><span class="s1">)</span>
    <span class="s1">expected = DatetimeIndex([</span><span class="s3">&quot;2020-01-01 00:00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;2020-01-01 05:00:00&quot;</span><span class="s1">])</span>
    <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_to_datetime_mixed_other():</span>
    <span class="s4"># https://github.com/pandas-dev/pandas/issues/50411</span>
    <span class="s1">result = to_datetime([</span><span class="s3">&quot;01/11/2000&quot;</span><span class="s2">, </span><span class="s3">&quot;12 January 2000&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;mixed&quot;</span><span class="s1">)</span>
    <span class="s1">expected = DatetimeIndex([</span><span class="s3">&quot;2000-01-11&quot;</span><span class="s2">, </span><span class="s3">&quot;2000-01-12&quot;</span><span class="s1">])</span>
    <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;exact&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;format&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;ISO8601&quot;</span><span class="s2">, </span><span class="s3">&quot;mixed&quot;</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_to_datetime_mixed_or_iso_exact(exact</span><span class="s2">, </span><span class="s1">format):</span>
    <span class="s1">msg = </span><span class="s3">&quot;Cannot use 'exact' when 'format' is 'mixed' or 'ISO8601'&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">to_datetime([</span><span class="s3">&quot;2020-01-01&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">exact=exact</span><span class="s2">, </span><span class="s1">format=format)</span>


<span class="s2">def </span><span class="s1">test_to_datetime_mixed_not_necessarily_iso8601_raise():</span>
    <span class="s4"># https://github.com/pandas-dev/pandas/issues/50411</span>
    <span class="s2">with </span><span class="s1">pytest.raises(</span>
        <span class="s1">ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;Time data 01-01-2000 is not ISO8601 format, at position 1&quot;</span>
    <span class="s1">):</span>
        <span class="s1">to_datetime([</span><span class="s3">&quot;2020-01-01&quot;</span><span class="s2">, </span><span class="s3">&quot;01-01-2000&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;ISO8601&quot;</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s1">(</span><span class="s3">&quot;errors&quot;</span><span class="s2">, </span><span class="s3">&quot;expected&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span><span class="s3">&quot;coerce&quot;</span><span class="s2">, </span><span class="s1">DatetimeIndex([</span><span class="s3">&quot;2020-01-01 00:00:00&quot;</span><span class="s2">, </span><span class="s1">NaT]))</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">Index([</span><span class="s3">&quot;2020-01-01&quot;</span><span class="s2">, </span><span class="s3">&quot;01-01-2000&quot;</span><span class="s1">]))</span><span class="s2">,</span>
    <span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_to_datetime_mixed_not_necessarily_iso8601_coerce(errors</span><span class="s2">, </span><span class="s1">expected):</span>
    <span class="s4"># https://github.com/pandas-dev/pandas/issues/50411</span>
    <span class="s1">result = to_datetime([</span><span class="s3">&quot;2020-01-01&quot;</span><span class="s2">, </span><span class="s3">&quot;01-01-2000&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;ISO8601&quot;</span><span class="s2">, </span><span class="s1">errors=errors)</span>
    <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_ignoring_unknown_tz_deprecated():</span>
    <span class="s4"># GH#18702, GH#51476</span>
    <span class="s1">dtstr = </span><span class="s3">&quot;2014 Jan 9 05:15 FAKE&quot;</span>
    <span class="s1">msg = </span><span class="s3">'un-recognized timezone &quot;FAKE&quot;. Dropping unrecognized timezones is deprecated'</span>
    <span class="s2">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">res = Timestamp(dtstr)</span>
    <span class="s2">assert </span><span class="s1">res == Timestamp(dtstr[:-</span><span class="s5">5</span><span class="s1">])</span>

    <span class="s2">with </span><span class="s1">tm.assert_produces_warning(FutureWarning):</span>
        <span class="s1">res = to_datetime(dtstr)</span>
    <span class="s2">assert </span><span class="s1">res == to_datetime(dtstr[:-</span><span class="s5">5</span><span class="s1">])</span>
    <span class="s2">with </span><span class="s1">tm.assert_produces_warning(FutureWarning):</span>
        <span class="s1">res = to_datetime([dtstr])</span>
    <span class="s1">tm.assert_index_equal(res</span><span class="s2">, </span><span class="s1">to_datetime([dtstr[:-</span><span class="s5">5</span><span class="s1">]]))</span>


<span class="s2">def </span><span class="s1">test_from_numeric_arrow_dtype(any_numeric_ea_dtype):</span>
    <span class="s4"># GH 52425</span>
    <span class="s1">pytest.importorskip(</span><span class="s3">&quot;pyarrow&quot;</span><span class="s1">)</span>
    <span class="s1">ser = Series([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">any_numeric_ea_dtype.lower()</span><span class="s2">}</span><span class="s3">[pyarrow]&quot;</span><span class="s1">)</span>
    <span class="s1">result = to_datetime(ser)</span>
    <span class="s1">expected = Series([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">&quot;datetime64[ns]&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_to_datetime_with_empty_str_utc_false_format_mixed():</span>
    <span class="s4"># GH 50887</span>
    <span class="s1">result = to_datetime([</span><span class="s3">&quot;2020-01-01 00:00+00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;mixed&quot;</span><span class="s1">)</span>
    <span class="s1">expected = Index([Timestamp(</span><span class="s3">&quot;2020-01-01 00:00+00:00&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;NaT&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=object)</span>
    <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_to_datetime_with_empty_str_utc_false_offsets_and_format_mixed():</span>
    <span class="s4"># GH 50887</span>
    <span class="s1">msg = </span><span class="s3">&quot;parsing datetimes with mixed time zones will raise an error&quot;</span>

    <span class="s2">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">to_datetime(</span>
            <span class="s1">[</span><span class="s3">&quot;2020-01-01 00:00+00:00&quot;</span><span class="s2">, </span><span class="s3">&quot;2020-01-01 00:00+02:00&quot;</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">&quot;mixed&quot;</span>
        <span class="s1">)</span>
</pre>
</body>
</html>