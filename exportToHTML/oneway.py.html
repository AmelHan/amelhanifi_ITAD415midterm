<html>
<head>
<title>oneway.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
oneway.py</font>
</center></td></tr></table>
<pre><span class="s0"># -*- coding: utf-8 -*-</span>
<span class="s2">&quot;&quot;&quot; 
Created on Wed Mar 18 10:33:38 2020 
 
Author: Josef Perktold 
License: BSD-3 
 
&quot;&quot;&quot;</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">from </span><span class="s1">scipy </span><span class="s3">import </span><span class="s1">stats</span>
<span class="s3">from </span><span class="s1">scipy.special </span><span class="s3">import </span><span class="s1">ncfdtrinc</span>

<span class="s0"># functions that use scipy.special instead of boost based function in stats</span>
<span class="s3">from </span><span class="s1">statsmodels.stats.power </span><span class="s3">import </span><span class="s1">ncf_cdf</span><span class="s3">, </span><span class="s1">ncf_ppf</span>

<span class="s3">from </span><span class="s1">statsmodels.stats.robust_compare </span><span class="s3">import </span><span class="s1">TrimmedMean</span><span class="s3">, </span><span class="s1">scale_transform</span>
<span class="s3">from </span><span class="s1">statsmodels.tools.testing </span><span class="s3">import </span><span class="s1">Holder</span>
<span class="s3">from </span><span class="s1">statsmodels.stats.base </span><span class="s3">import </span><span class="s1">HolderTuple</span>


<span class="s3">def </span><span class="s1">effectsize_oneway(means</span><span class="s3">, </span><span class="s1">vars_</span><span class="s3">, </span><span class="s1">nobs</span><span class="s3">, </span><span class="s1">use_var=</span><span class="s4">&quot;unequal&quot;</span><span class="s3">, </span><span class="s1">ddof_between=</span><span class="s5">0</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Effect size corresponding to Cohen's f = nc / nobs for oneway anova 
 
    This contains adjustment for Welch and Brown-Forsythe Anova so that 
    effect size can be used with FTestAnovaPower. 
 
    Parameters 
    ---------- 
    means : array_like 
        Mean of samples to be compared 
    vars_ : float or array_like 
        Residual (within) variance of each sample or pooled 
        If ``vars_`` is scalar, then it is interpreted as pooled variance that 
        is the same for all samples, ``use_var`` will be ignored. 
        Otherwise, the variances are used depending on the ``use_var`` keyword. 
    nobs : int or array_like 
        Number of observations for the samples. 
        If nobs is scalar, then it is assumed that all samples have the same 
        number ``nobs`` of observation, i.e. a balanced sample case. 
        Otherwise, statistics will be weighted corresponding to nobs. 
        Only relative sizes are relevant, any proportional change to nobs does 
        not change the effect size. 
    use_var : {&quot;unequal&quot;, &quot;equal&quot;, &quot;bf&quot;} 
        If ``use_var`` is &quot;unequal&quot;, then the variances can differ across 
        samples and the effect size for Welch anova will be computed. 
    ddof_between : int 
        Degrees of freedom correction for the weighted between sum of squares. 
        The denominator is ``nobs_total - ddof_between`` 
        This can be used to match differences across reference literature. 
 
    Returns 
    ------- 
    f2 : float 
        Effect size corresponding to squared Cohen's f, which is also equal 
        to the noncentrality divided by total number of observations. 
 
    Notes 
    ----- 
    This currently handles the following cases for oneway anova 
 
    - balanced sample with homoscedastic variances 
    - samples with different number of observations and with homoscedastic 
      variances 
    - samples with different number of observations and with heteroskedastic 
      variances. This corresponds to Welch anova 
 
    In the case of &quot;unequal&quot; and &quot;bf&quot; methods for unequal variances, the 
    effect sizes do not directly correspond to the test statistic in Anova. 
    Both have correction terms dropped or added, so the effect sizes match up 
    with using FTestAnovaPower. 
    If all variances are equal, then all three methods result in the same 
    effect size. If variances are unequal, then the three methods produce 
    small differences in effect size. 
 
    Note, the effect size and power computation for BF Anova was not found in 
    the literature. The correction terms were added so that FTestAnovaPower 
    provides a good approximation to the power. 
 
    Status: experimental 
    We might add additional returns, if those are needed to support power 
    and sample size applications. 
 
    Examples 
    -------- 
    The following shows how to compute effect size and power for each of the 
    three anova methods. The null hypothesis is that the means are equal which 
    corresponds to a zero effect size. Under the alternative, means differ 
    with two sample means at a distance delta from the mean. We assume the 
    variance is the same under the null and alternative hypothesis. 
 
    ``nobs`` for the samples defines the fraction of observations in the 
    samples. ``nobs`` in the power method defines the total sample size. 
 
    In simulations, the computed power for standard anova, 
    i.e.``use_var=&quot;equal&quot;`` overestimates the simulated power by a few percent. 
    The equal variance assumption does not hold in this example. 
 
    &gt;&gt;&gt; from statsmodels.stats.oneway import effectsize_oneway 
    &gt;&gt;&gt; from statsmodels.stats.power import FTestAnovaPower 
    &gt;&gt;&gt; 
    &gt;&gt;&gt; nobs = np.array([10, 12, 13, 15]) 
    &gt;&gt;&gt; delta = 0.5 
    &gt;&gt;&gt; means_alt = np.array([-1, 0, 0, 1]) * delta 
    &gt;&gt;&gt; vars_ = np.arange(1, len(means_alt) + 1) 
    &gt;&gt;&gt; 
    &gt;&gt;&gt; f2_alt = effectsize_oneway(means_alt, vars_, nobs, use_var=&quot;equal&quot;) 
    &gt;&gt;&gt; f2_alt 
    0.04581300813008131 
    &gt;&gt;&gt; 
    &gt;&gt;&gt; kwds = {'effect_size': np.sqrt(f2_alt), 'nobs': 100, 'alpha': 0.05, 
    ...         'k_groups': 4} 
    &gt;&gt;&gt; power = FTestAnovaPower().power(**kwds) 
    &gt;&gt;&gt; power 
    0.39165892158983273 
    &gt;&gt;&gt; 
    &gt;&gt;&gt; f2_alt = effectsize_oneway(means_alt, vars_, nobs, use_var=&quot;unequal&quot;) 
    &gt;&gt;&gt; f2_alt 
    0.060640138408304504 
    &gt;&gt;&gt; 
    &gt;&gt;&gt; kwds['effect_size'] = np.sqrt(f2_alt) 
    &gt;&gt;&gt; power = FTestAnovaPower().power(**kwds) 
    &gt;&gt;&gt; power 
    0.5047366512800622 
    &gt;&gt;&gt; 
    &gt;&gt;&gt; f2_alt = effectsize_oneway(means_alt, vars_, nobs, use_var=&quot;bf&quot;) 
    &gt;&gt;&gt; f2_alt 
    0.04391324307956788 
    &gt;&gt;&gt; 
    &gt;&gt;&gt; kwds['effect_size'] = np.sqrt(f2_alt) 
    &gt;&gt;&gt; power = FTestAnovaPower().power(**kwds) 
    &gt;&gt;&gt; power 
    0.3765792117047725 
 
    &quot;&quot;&quot;</span>
    <span class="s0"># the code here is largely a copy of onway_generic with adjustments</span>

    <span class="s1">means = np.asarray(means)</span>
    <span class="s1">n_groups = means.shape[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s3">if </span><span class="s1">np.size(nobs) == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">nobs = np.ones(n_groups) * nobs</span>

    <span class="s1">nobs_t = nobs.sum()</span>

    <span class="s3">if </span><span class="s1">use_var == </span><span class="s4">&quot;equal&quot;</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">np.size(vars_) == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">var_resid = vars_</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">vars_ = np.asarray(vars_)</span>
            <span class="s1">var_resid = ((nobs - </span><span class="s5">1</span><span class="s1">) * vars_).sum() / (nobs_t - n_groups)</span>

        <span class="s1">vars_ = var_resid  </span><span class="s0"># scalar, if broadcasting works</span>

    <span class="s1">weights = nobs / vars_</span>

    <span class="s1">w_total = weights.sum()</span>
    <span class="s1">w_rel = weights / w_total</span>
    <span class="s0"># meanw_t = (weights * means).sum() / w_total</span>
    <span class="s1">meanw_t = w_rel @ means</span>

    <span class="s1">f2 = np.dot(weights</span><span class="s3">, </span><span class="s1">(means - meanw_t)**</span><span class="s5">2</span><span class="s1">) / (nobs_t - ddof_between)</span>

    <span class="s3">if </span><span class="s1">use_var.lower() == </span><span class="s4">&quot;bf&quot;</span><span class="s1">:</span>
        <span class="s1">weights = nobs</span>
        <span class="s1">w_total = weights.sum()</span>
        <span class="s1">w_rel = weights / w_total</span>
        <span class="s1">meanw_t = w_rel @ means</span>
        <span class="s0"># TODO: reuse general case with weights</span>
        <span class="s1">tmp = ((</span><span class="s5">1. </span><span class="s1">- nobs / nobs_t) * vars_).sum()</span>
        <span class="s1">statistic = </span><span class="s5">1. </span><span class="s1">* (nobs * (means - meanw_t)**</span><span class="s5">2</span><span class="s1">).sum()</span>
        <span class="s1">statistic /= tmp</span>
        <span class="s1">f2 = statistic * (</span><span class="s5">1. </span><span class="s1">- nobs / nobs_t).sum() / nobs_t</span>
        <span class="s0"># correction factor for df_num in BFM</span>
        <span class="s1">df_num2 = n_groups - </span><span class="s5">1</span>
        <span class="s1">df_num = tmp**</span><span class="s5">2 </span><span class="s1">/ ((vars_**</span><span class="s5">2</span><span class="s1">).sum() +</span>
                           <span class="s1">(nobs / nobs_t * vars_).sum()**</span><span class="s5">2 </span><span class="s1">-</span>
                           <span class="s5">2 </span><span class="s1">* (nobs / nobs_t * vars_**</span><span class="s5">2</span><span class="s1">).sum())</span>
        <span class="s1">f2 *= df_num / df_num2</span>

    <span class="s3">return </span><span class="s1">f2</span>


<span class="s3">def </span><span class="s1">convert_effectsize_fsqu(f2=</span><span class="s3">None, </span><span class="s1">eta2=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Convert squared effect sizes in f family 
 
    f2 is signal to noise ratio, var_explained / var_residual 
 
    eta2 is proportion of explained variance, var_explained / var_total 
 
    uses the relationship: 
    f2 = eta2 / (1 - eta2) 
 
    Parameters 
    ---------- 
    f2 : None or float 
       Squared Cohen's F effect size. If f2 is not None, then eta2 will be 
       computed. 
    eta2 : None or float 
       Squared eta effect size. If f2 is None and eta2 is not None, then f2 is 
       computed. 
 
    Returns 
    ------- 
    res : Holder instance 
        An instance of the Holder class with f2 and eta2 as attributes. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">f2 </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">eta2 = </span><span class="s5">1 </span><span class="s1">/ (</span><span class="s5">1 </span><span class="s1">+ </span><span class="s5">1 </span><span class="s1">/ f2)</span>

    <span class="s3">elif </span><span class="s1">eta2 </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">f2 = eta2 / (</span><span class="s5">1 </span><span class="s1">- eta2)</span>

    <span class="s1">res = Holder(f2=f2</span><span class="s3">, </span><span class="s1">eta2=eta2)</span>
    <span class="s3">return </span><span class="s1">res</span>


<span class="s3">def </span><span class="s1">_fstat2effectsize(f_stat</span><span class="s3">, </span><span class="s1">df):</span>
    <span class="s2">&quot;&quot;&quot;Compute anova effect size from F-statistic 
 
    This might be combined with convert_effectsize_fsqu 
 
    Parameters 
    ---------- 
    f_stat : array_like 
        Test statistic of an F-test 
    df : tuple 
        degrees of freedom ``df = (df1, df2)`` where 
         - df1 : numerator degrees of freedom, number of constraints 
         - df2 : denominator degrees of freedom, df_resid 
 
    Returns 
    ------- 
    res : Holder instance 
        This instance contains effect size measures f2, eta2, omega2 and eps2 
        as attributes. 
 
    Notes 
    ----- 
    This uses the following definitions: 
 
    - f2 = f_stat * df1 / df2 
    - eta2 = f2 / (f2 + 1) 
    - omega2 = (f2 - df1 / df2) / (f2 + 2) 
    - eps2 = (f2 - df1 / df2) / (f2 + 1) 
 
    This differs from effect size measures in other function which define 
    ``f2 = f_stat * df1 / nobs`` 
    or an equivalent expression for power computation. The noncentrality 
    index for the hypothesis test is in those cases given by 
    ``nc = f_stat * df1``. 
 
    Currently omega2 and eps2 are computed in two different ways. Those 
    values agree for regular cases but can show different behavior in corner 
    cases (e.g. zero division). 
 
    &quot;&quot;&quot;</span>
    <span class="s1">df1</span><span class="s3">, </span><span class="s1">df2 = df</span>
    <span class="s1">f2 = f_stat * df1 / df2</span>
    <span class="s1">eta2 = f2 / (f2 + </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">omega2_ = (f_stat - </span><span class="s5">1</span><span class="s1">) / (f_stat + (df2 + </span><span class="s5">1</span><span class="s1">) / df1)</span>
    <span class="s1">omega2 = (f2 - df1 / df2) / (f2 + </span><span class="s5">1 </span><span class="s1">+ </span><span class="s5">1 </span><span class="s1">/ df2)  </span><span class="s0"># rewrite</span>
    <span class="s1">eps2_ = (f_stat - </span><span class="s5">1</span><span class="s1">) / (f_stat + df2 / df1)</span>
    <span class="s1">eps2 = (f2 - df1 / df2) / (f2 + </span><span class="s5">1</span><span class="s1">)  </span><span class="s0"># rewrite</span>
    <span class="s3">return </span><span class="s1">Holder(f2=f2</span><span class="s3">, </span><span class="s1">eta2=eta2</span><span class="s3">, </span><span class="s1">omega2=omega2</span><span class="s3">, </span><span class="s1">eps2=eps2</span><span class="s3">, </span><span class="s1">eps2_=eps2_</span><span class="s3">,</span>
                  <span class="s1">omega2_=omega2_)</span>


<span class="s0"># conversion functions for Wellek's equivalence effect size</span>
<span class="s0"># these are mainly to compare with literature</span>

<span class="s3">def </span><span class="s1">wellek_to_f2(eps</span><span class="s3">, </span><span class="s1">n_groups):</span>
    <span class="s2">&quot;&quot;&quot;Convert Wellek's effect size (sqrt) to Cohen's f-squared 
 
    This computes the following effect size : 
 
       f2 = 1 / n_groups * eps**2 
 
    Parameters 
    ---------- 
    eps : float or ndarray 
        Wellek's effect size used in anova equivalence test 
    n_groups : int 
        Number of groups in oneway comparison 
 
    Returns 
    ------- 
    f2 : effect size Cohen's f-squared 
 
    &quot;&quot;&quot;</span>
    <span class="s1">f2 = </span><span class="s5">1 </span><span class="s1">/ n_groups * eps**</span><span class="s5">2</span>
    <span class="s3">return </span><span class="s1">f2</span>


<span class="s3">def </span><span class="s1">f2_to_wellek(f2</span><span class="s3">, </span><span class="s1">n_groups):</span>
    <span class="s2">&quot;&quot;&quot;Convert Cohen's f-squared to Wellek's effect size (sqrt) 
 
    This computes the following effect size : 
 
       eps = sqrt(n_groups * f2) 
 
    Parameters 
    ---------- 
    f2 : float or ndarray 
        Effect size Cohen's f-squared 
    n_groups : int 
        Number of groups in oneway comparison 
 
    Returns 
    ------- 
    eps : float or ndarray 
        Wellek's effect size used in anova equivalence test 
    &quot;&quot;&quot;</span>
    <span class="s1">eps = np.sqrt(n_groups * f2)</span>
    <span class="s3">return </span><span class="s1">eps</span>


<span class="s3">def </span><span class="s1">fstat_to_wellek(f_stat</span><span class="s3">, </span><span class="s1">n_groups</span><span class="s3">, </span><span class="s1">nobs_mean):</span>
    <span class="s2">&quot;&quot;&quot;Convert F statistic to wellek's effect size eps squared 
 
    This computes the following effect size : 
 
       es = f_stat * (n_groups - 1) / nobs_mean 
 
    Parameters 
    ---------- 
    f_stat : float or ndarray 
        Test statistic of an F-test. 
    n_groups : int 
        Number of groups in oneway comparison 
    nobs_mean : float or ndarray 
        Average number of observations across groups. 
 
    Returns 
    ------- 
    eps : float or ndarray 
        Wellek's effect size used in anova equivalence test 
 
    &quot;&quot;&quot;</span>
    <span class="s1">es = f_stat * (n_groups - </span><span class="s5">1</span><span class="s1">) / nobs_mean</span>
    <span class="s3">return </span><span class="s1">es</span>


<span class="s3">def </span><span class="s1">confint_noncentrality(f_stat</span><span class="s3">, </span><span class="s1">df</span><span class="s3">, </span><span class="s1">alpha=</span><span class="s5">0.05</span><span class="s3">,</span>
                          <span class="s1">alternative=</span><span class="s4">&quot;two-sided&quot;</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Confidence interval for noncentrality parameter in F-test 
 
    This does not yet handle non-negativity constraint on nc. 
    Currently only two-sided alternative is supported. 
 
    Parameters 
    ---------- 
    f_stat : float 
    df : tuple 
        degrees of freedom ``df = (df1, df2)`` where 
 
        - df1 : numerator degrees of freedom, number of constraints 
        - df2 : denominator degrees of freedom, df_resid 
 
    alpha : float, default 0.05 
    alternative : {&quot;two-sided&quot;} 
        Other alternatives have not been implements. 
 
    Returns 
    ------- 
    float 
        The end point of the confidence interval. 
 
    Notes 
    ----- 
    The algorithm inverts the cdf of the noncentral F distribution with 
    respect to the noncentrality parameters. 
    See Steiger 2004 and references cited in it. 
 
    References 
    ---------- 
    .. [1] Steiger, James H. 2004. “Beyond the F Test: Effect Size Confidence 
       Intervals and Tests of Close Fit in the Analysis of Variance and 
       Contrast Analysis.” Psychological Methods 9 (2): 164–82. 
       https://doi.org/10.1037/1082-989X.9.2.164. 
 
    See Also 
    -------- 
    confint_effectsize_oneway 
    &quot;&quot;&quot;</span>

    <span class="s1">df1</span><span class="s3">, </span><span class="s1">df2 = df</span>
    <span class="s3">if </span><span class="s1">alternative </span><span class="s3">in </span><span class="s1">[</span><span class="s4">&quot;two-sided&quot;</span><span class="s3">, </span><span class="s4">&quot;2s&quot;</span><span class="s3">, </span><span class="s4">&quot;ts&quot;</span><span class="s1">]:</span>
        <span class="s1">alpha1s = alpha / </span><span class="s5">2</span>
        <span class="s1">ci = ncfdtrinc(df1</span><span class="s3">, </span><span class="s1">df2</span><span class="s3">, </span><span class="s1">[</span><span class="s5">1 </span><span class="s1">- alpha1s</span><span class="s3">, </span><span class="s1">alpha1s]</span><span class="s3">, </span><span class="s1">f_stat)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span>

    <span class="s3">return </span><span class="s1">ci</span>


<span class="s3">def </span><span class="s1">confint_effectsize_oneway(f_stat</span><span class="s3">, </span><span class="s1">df</span><span class="s3">, </span><span class="s1">alpha=</span><span class="s5">0.05</span><span class="s3">, </span><span class="s1">nobs=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Confidence interval for effect size in oneway anova for F distribution 
 
    This does not yet handle non-negativity constraint on nc. 
    Currently only two-sided alternative is supported. 
 
    Parameters 
    ---------- 
    f_stat : float 
    df : tuple 
        degrees of freedom ``df = (df1, df2)`` where 
 
        - df1 : numerator degrees of freedom, number of constraints 
        - df2 : denominator degrees of freedom, df_resid 
 
    alpha : float, default 0.05 
    nobs : int, default None 
 
    Returns 
    ------- 
    Holder 
        Class with effect size and confidence attributes 
 
    Notes 
    ----- 
    The confidence interval for the noncentrality parameter is obtained by 
    inverting the cdf of the noncentral F distribution. Confidence intervals 
    for other effect sizes are computed by endpoint transformation. 
 
 
    R package ``effectsize`` does not compute the confidence intervals in the 
    same way. Their confidence intervals can be replicated with 
 
    &gt;&gt;&gt; ci_nc = confint_noncentrality(f_stat, df1, df2, alpha=0.1) 
    &gt;&gt;&gt; ci_es = smo._fstat2effectsize(ci_nc / df1, df1, df2) 
 
    See Also 
    -------- 
    confint_noncentrality 
    &quot;&quot;&quot;</span>

    <span class="s1">df1</span><span class="s3">, </span><span class="s1">df2 = df</span>
    <span class="s3">if </span><span class="s1">nobs </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">nobs = df1 + df2 + </span><span class="s5">1</span>
    <span class="s1">ci_nc = confint_noncentrality(f_stat</span><span class="s3">, </span><span class="s1">df</span><span class="s3">, </span><span class="s1">alpha=alpha)</span>

    <span class="s1">ci_f2 = ci_nc / nobs</span>
    <span class="s1">ci_res = convert_effectsize_fsqu(f2=ci_f2)</span>
    <span class="s1">ci_res.ci_omega2 = (ci_f2 - df1 / df2) / (ci_f2 + </span><span class="s5">1 </span><span class="s1">+ </span><span class="s5">1 </span><span class="s1">/ df2)</span>
    <span class="s1">ci_res.ci_nc = ci_nc</span>
    <span class="s1">ci_res.ci_f = np.sqrt(ci_res.f2)</span>
    <span class="s1">ci_res.ci_eta = np.sqrt(ci_res.eta2)</span>
    <span class="s1">ci_res.ci_f_corrected = np.sqrt(ci_res.f2 * (df1 + </span><span class="s5">1</span><span class="s1">) / df1)</span>

    <span class="s3">return </span><span class="s1">ci_res</span>


<span class="s3">def </span><span class="s1">anova_generic(means</span><span class="s3">, </span><span class="s1">variances</span><span class="s3">, </span><span class="s1">nobs</span><span class="s3">, </span><span class="s1">use_var=</span><span class="s4">&quot;unequal&quot;</span><span class="s3">,</span>
                  <span class="s1">welch_correction=</span><span class="s3">True, </span><span class="s1">info=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Oneway Anova based on summary statistics 
 
    Parameters 
    ---------- 
    means : array_like 
        Mean of samples to be compared 
    variances : float or array_like 
        Residual (within) variance of each sample or pooled. 
        If ``variances`` is scalar, then it is interpreted as pooled variance 
        that is the same for all samples, ``use_var`` will be ignored. 
        Otherwise, the variances are used depending on the ``use_var`` keyword. 
    nobs : int or array_like 
        Number of observations for the samples. 
        If nobs is scalar, then it is assumed that all samples have the same 
        number ``nobs`` of observation, i.e. a balanced sample case. 
        Otherwise, statistics will be weighted corresponding to nobs. 
        Only relative sizes are relevant, any proportional change to nobs does 
        not change the effect size. 
    use_var : {&quot;unequal&quot;, &quot;equal&quot;, &quot;bf&quot;} 
        If ``use_var`` is &quot;unequal&quot;, then the variances can differ across 
        samples and the effect size for Welch anova will be computed. 
    welch_correction : bool 
        If this is false, then the Welch correction to the test statistic is 
        not included. This allows the computation of an effect size measure 
        that corresponds more closely to Cohen's f. 
    info : not used yet 
 
    Returns 
    ------- 
    res : results instance 
        This includes `statistic` and `pvalue`. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">options = {</span><span class="s4">&quot;use_var&quot;</span><span class="s1">: use_var</span><span class="s3">,</span>
               <span class="s4">&quot;welch_correction&quot;</span><span class="s1">: welch_correction</span>
               <span class="s1">}</span>
    <span class="s3">if </span><span class="s1">means.ndim != </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'data (means, ...) has to be one-dimensional'</span><span class="s1">)</span>
    <span class="s1">nobs_t = nobs.sum()</span>
    <span class="s1">n_groups = len(means)</span>
    <span class="s0"># mean_t = (nobs * means).sum() / nobs_t</span>
    <span class="s3">if </span><span class="s1">use_var == </span><span class="s4">&quot;unequal&quot;</span><span class="s1">:</span>
        <span class="s1">weights = nobs / variances</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">weights = nobs</span>

    <span class="s1">w_total = weights.sum()</span>
    <span class="s1">w_rel = weights / w_total</span>
    <span class="s0"># meanw_t = (weights * means).sum() / w_total</span>
    <span class="s1">meanw_t = w_rel @ means</span>

    <span class="s1">statistic = np.dot(weights</span><span class="s3">, </span><span class="s1">(means - meanw_t)**</span><span class="s5">2</span><span class="s1">) / (n_groups - </span><span class="s5">1.</span><span class="s1">)</span>
    <span class="s1">df_num = n_groups - </span><span class="s5">1.</span>

    <span class="s3">if </span><span class="s1">use_var == </span><span class="s4">&quot;unequal&quot;</span><span class="s1">:</span>
        <span class="s1">tmp = ((</span><span class="s5">1 </span><span class="s1">- w_rel)**</span><span class="s5">2 </span><span class="s1">/ (nobs - </span><span class="s5">1</span><span class="s1">)).sum() / (n_groups**</span><span class="s5">2 </span><span class="s1">- </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">welch_correction:</span>
            <span class="s1">statistic /= </span><span class="s5">1 </span><span class="s1">+ </span><span class="s5">2 </span><span class="s1">* (n_groups - </span><span class="s5">2</span><span class="s1">) * tmp</span>
        <span class="s1">df_denom = </span><span class="s5">1. </span><span class="s1">/ (</span><span class="s5">3. </span><span class="s1">* tmp)</span>

    <span class="s3">elif </span><span class="s1">use_var == </span><span class="s4">&quot;equal&quot;</span><span class="s1">:</span>
        <span class="s0"># variance of group demeaned total sample, pooled var_resid</span>
        <span class="s1">tmp = ((nobs - </span><span class="s5">1</span><span class="s1">) * variances).sum() / (nobs_t - n_groups)</span>
        <span class="s1">statistic /= tmp</span>
        <span class="s1">df_denom = nobs_t - n_groups</span>

    <span class="s3">elif </span><span class="s1">use_var == </span><span class="s4">&quot;bf&quot;</span><span class="s1">:</span>
        <span class="s1">tmp = ((</span><span class="s5">1. </span><span class="s1">- nobs / nobs_t) * variances).sum()</span>
        <span class="s1">statistic = </span><span class="s5">1. </span><span class="s1">* (nobs * (means - meanw_t)**</span><span class="s5">2</span><span class="s1">).sum()</span>
        <span class="s1">statistic /= tmp</span>

        <span class="s1">df_num2 = n_groups - </span><span class="s5">1</span>
        <span class="s1">df_denom = tmp**</span><span class="s5">2 </span><span class="s1">/ ((</span><span class="s5">1. </span><span class="s1">- nobs / nobs_t) ** </span><span class="s5">2 </span><span class="s1">*</span>
                             <span class="s1">variances ** </span><span class="s5">2 </span><span class="s1">/ (nobs - </span><span class="s5">1</span><span class="s1">)).sum()</span>
        <span class="s1">df_num = tmp**</span><span class="s5">2 </span><span class="s1">/ ((variances ** </span><span class="s5">2</span><span class="s1">).sum() +</span>
                           <span class="s1">(nobs / nobs_t * variances).sum() ** </span><span class="s5">2 </span><span class="s1">-</span>
                           <span class="s5">2 </span><span class="s1">* (nobs / nobs_t * variances ** </span><span class="s5">2</span><span class="s1">).sum())</span>
        <span class="s1">pval2 = stats.f.sf(statistic</span><span class="s3">, </span><span class="s1">df_num2</span><span class="s3">, </span><span class="s1">df_denom)</span>
        <span class="s1">options[</span><span class="s4">&quot;df2&quot;</span><span class="s1">] = (df_num2</span><span class="s3">, </span><span class="s1">df_denom)</span>
        <span class="s1">options[</span><span class="s4">&quot;df_num2&quot;</span><span class="s1">] = df_num2</span>
        <span class="s1">options[</span><span class="s4">&quot;pvalue2&quot;</span><span class="s1">] = pval2</span>

    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'use_var is to be one of &quot;unequal&quot;, &quot;equal&quot; or &quot;bf&quot;'</span><span class="s1">)</span>

    <span class="s1">pval = stats.f.sf(statistic</span><span class="s3">, </span><span class="s1">df_num</span><span class="s3">, </span><span class="s1">df_denom)</span>
    <span class="s1">res = HolderTuple(statistic=statistic</span><span class="s3">,</span>
                      <span class="s1">pvalue=pval</span><span class="s3">,</span>
                      <span class="s1">df=(df_num</span><span class="s3">, </span><span class="s1">df_denom)</span><span class="s3">,</span>
                      <span class="s1">df_num=df_num</span><span class="s3">,</span>
                      <span class="s1">df_denom=df_denom</span><span class="s3">,</span>
                      <span class="s1">nobs_t=nobs_t</span><span class="s3">,</span>
                      <span class="s1">n_groups=n_groups</span><span class="s3">,</span>
                      <span class="s1">means=means</span><span class="s3">,</span>
                      <span class="s1">nobs=nobs</span><span class="s3">,</span>
                      <span class="s1">vars_=variances</span><span class="s3">,</span>
                      <span class="s1">**options</span>
                      <span class="s1">)</span>
    <span class="s3">return </span><span class="s1">res</span>


<span class="s3">def </span><span class="s1">anova_oneway(data</span><span class="s3">, </span><span class="s1">groups=</span><span class="s3">None, </span><span class="s1">use_var=</span><span class="s4">&quot;unequal&quot;</span><span class="s3">, </span><span class="s1">welch_correction=</span><span class="s3">True,</span>
                 <span class="s1">trim_frac=</span><span class="s5">0</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Oneway Anova 
 
    This implements standard anova, Welch and Brown-Forsythe, and trimmed 
    (Yuen) variants of those. 
 
    Parameters 
    ---------- 
    data : tuple of array_like or DataFrame or Series 
        Data for k independent samples, with k &gt;= 2. 
        The data can be provided as a tuple or list of arrays or in long 
        format with outcome observations in ``data`` and group membership in 
        ``groups``. 
    groups : ndarray or Series 
        If data is in long format, then groups is needed as indicator to which 
        group or sample and observations belongs. 
    use_var : {&quot;unequal&quot;, &quot;equal&quot; or &quot;bf&quot;} 
        `use_var` specified how to treat heteroscedasticity, unequal variance, 
        across samples. Three approaches are available 
 
        &quot;unequal&quot; : Variances are not assumed to be equal across samples. 
            Heteroscedasticity is taken into account with Welch Anova and 
            Satterthwaite-Welch degrees of freedom. 
            This is the default. 
        &quot;equal&quot; : Variances are assumed to be equal across samples. 
            This is the standard Anova. 
        &quot;bf: Variances are not assumed to be equal across samples. 
            The method is Browne-Forsythe (1971) for testing equality of means 
            with the corrected degrees of freedom by Merothra. The original BF 
            degrees of freedom are available as additional attributes in the 
            results instance, ``df_denom2`` and ``p_value2``. 
 
    welch_correction : bool 
        If this is false, then the Welch correction to the test statistic is 
        not included. This allows the computation of an effect size measure 
        that corresponds more closely to Cohen's f. 
    trim_frac : float in [0, 0.5) 
        Optional trimming for Anova with trimmed mean and winsorized variances. 
        With the default trim_frac equal to zero, the oneway Anova statistics 
        are computed without trimming. If `trim_frac` is larger than zero, 
        then the largest and smallest observations in each sample are trimmed. 
        The number of trimmed observations is the fraction of number of 
        observations in the sample truncated to the next lower integer. 
        `trim_frac` has to be smaller than 0.5, however, if the fraction is 
        so large that there are not enough observations left over, then `nan` 
        will be returned. 
 
    Returns 
    ------- 
    res : results instance 
        The returned HolderTuple instance has the following main attributes 
        and some additional information in other attributes. 
 
        statistic : float 
            Test statistic for k-sample mean comparison which is approximately 
            F-distributed. 
        pvalue : float 
            If ``use_var=&quot;bf&quot;``, then the p-value is based on corrected 
            degrees of freedom following Mehrotra 1997. 
        pvalue2 : float 
            This is the p-value based on degrees of freedom as in 
            Brown-Forsythe 1974 and is only available if ``use_var=&quot;bf&quot;``. 
        df = (df_denom, df_num) : tuple of floats 
            Degreeds of freedom for the F-distribution depend on ``use_var``. 
            If ``use_var=&quot;bf&quot;``, then `df_denom` is for Mehrotra p-values 
            `df_denom2` is available for Brown-Forsythe 1974 p-values. 
            `df_num` is the same numerator degrees of freedom for both 
            p-values. 
 
    Notes 
    ----- 
    Welch's anova is correctly sized (not liberal or conservative) in smaller 
    samples if the distribution of the samples is not very far away from the 
    normal distribution. The test can become liberal if the data is strongly 
    skewed. Welch's Anova can also be correctly sized for discrete 
    distributions with finite support, like Lickert scale data. 
    The trimmed version is robust to many non-normal distributions, it stays 
    correctly sized in many cases, and is more powerful in some cases with 
    skewness or heavy tails. 
 
    Trimming is currently based on the integer part of ``nobs * trim_frac``. 
    The default might change to including fractional observations as in the 
    original articles by Yuen. 
 
 
    See Also 
    -------- 
    anova_generic 
 
    References 
    ---------- 
    Brown, Morton B., and Alan B. Forsythe. 1974. “The Small Sample Behavior 
    of Some Statistics Which Test the Equality of Several Means.” 
    Technometrics 16 (1) (February 1): 129–132. doi:10.2307/1267501. 
 
    Mehrotra, Devan V. 1997. “Improving the Brown-Forsythe Solution to the 
    Generalized Behrens-Fisher Problem.” Communications in Statistics - 
    Simulation and Computation 26 (3): 1139–1145. 
    doi:10.1080/03610919708813431. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">groups </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">uniques = np.unique(groups)</span>
        <span class="s1">data = [data[groups == uni] </span><span class="s3">for </span><span class="s1">uni </span><span class="s3">in </span><span class="s1">uniques]</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s0"># uniques = None  # not used yet, add to info?</span>
        <span class="s3">pass</span>
    <span class="s1">args = list(map(np.asarray</span><span class="s3">, </span><span class="s1">data))</span>
    <span class="s3">if </span><span class="s1">any([x.ndim != </span><span class="s5">1 </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">args]):</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'data arrays have to be one-dimensional'</span><span class="s1">)</span>

    <span class="s1">nobs = np.array([len(x) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">args]</span><span class="s3">, </span><span class="s1">float)</span>
    <span class="s0"># n_groups = len(args)  # not used</span>
    <span class="s0"># means = np.array([np.mean(x, axis=0) for x in args], float)</span>
    <span class="s0"># vars_ = np.array([np.var(x, ddof=1, axis=0) for x in args], float)</span>

    <span class="s3">if </span><span class="s1">trim_frac == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">means = np.array([x.mean() </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">args])</span>
        <span class="s1">vars_ = np.array([x.var(ddof=</span><span class="s5">1</span><span class="s1">) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">args])</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">tms = [TrimmedMean(x</span><span class="s3">, </span><span class="s1">trim_frac) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">args]</span>
        <span class="s1">means = np.array([tm.mean_trimmed </span><span class="s3">for </span><span class="s1">tm </span><span class="s3">in </span><span class="s1">tms])</span>
        <span class="s0"># R doesn't use uncorrected var_winsorized</span>
        <span class="s0"># vars_ = np.array([tm.var_winsorized for tm in tms])</span>
        <span class="s1">vars_ = np.array([tm.var_winsorized * (tm.nobs - </span><span class="s5">1</span><span class="s1">) /</span>
                          <span class="s1">(tm.nobs_reduced - </span><span class="s5">1</span><span class="s1">) </span><span class="s3">for </span><span class="s1">tm </span><span class="s3">in </span><span class="s1">tms])</span>
        <span class="s0"># nobs_original = nobs  # store just in case</span>
        <span class="s1">nobs = np.array([tm.nobs_reduced </span><span class="s3">for </span><span class="s1">tm </span><span class="s3">in </span><span class="s1">tms])</span>

    <span class="s1">res = anova_generic(means</span><span class="s3">, </span><span class="s1">vars_</span><span class="s3">, </span><span class="s1">nobs</span><span class="s3">, </span><span class="s1">use_var=use_var</span><span class="s3">,</span>
                        <span class="s1">welch_correction=welch_correction)</span>

    <span class="s3">return </span><span class="s1">res</span>


<span class="s3">def </span><span class="s1">equivalence_oneway_generic(f_stat</span><span class="s3">, </span><span class="s1">n_groups</span><span class="s3">, </span><span class="s1">nobs</span><span class="s3">, </span><span class="s1">equiv_margin</span><span class="s3">, </span><span class="s1">df</span><span class="s3">,</span>
                               <span class="s1">alpha=</span><span class="s5">0.05</span><span class="s3">, </span><span class="s1">margin_type=</span><span class="s4">&quot;f2&quot;</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Equivalence test for oneway anova (Wellek and extensions) 
 
    This is an helper function when summary statistics are available. 
    Use `equivalence_oneway` instead. 
 
    The null hypothesis is that the means differ by more than `equiv_margin` 
    in the anova distance measure. 
    If the Null is rejected, then the data supports that means are equivalent, 
    i.e. within a given distance. 
 
    Parameters 
    ---------- 
    f_stat : float 
        F-statistic 
    n_groups : int 
        Number of groups in oneway comparison. 
    nobs : ndarray 
        Array of number of observations in groups. 
    equiv_margin : float 
        Equivalence margin in terms of effect size. Effect size can be chosen 
        with `margin_type`. default is squared Cohen's f. 
    df : tuple 
        degrees of freedom ``df = (df1, df2)`` where 
 
        - df1 : numerator degrees of freedom, number of constraints 
        - df2 : denominator degrees of freedom, df_resid 
 
    alpha : float in (0, 1) 
        Significance level for the hypothesis test. 
    margin_type : &quot;f2&quot; or &quot;wellek&quot; 
        Type of effect size used for equivalence margin. 
 
    Returns 
    ------- 
    results : instance of HolderTuple class 
        The two main attributes are test statistic `statistic` and p-value 
        `pvalue`. 
 
    Notes 
    ----- 
    Equivalence in this function is defined in terms of a squared distance 
    measure similar to Mahalanobis distance. 
    Alternative definitions for the oneway case are based on maximum difference 
    between pairs of means or similar pairwise distances. 
 
    The equivalence margin is used for the noncentrality parameter in the 
    noncentral F distribution for the test statistic. In samples with unequal 
    variances estimated using Welch or Brown-Forsythe Anova, the f-statistic 
    depends on the unequal variances and corrections to the test statistic. 
    This means that the equivalence margins are not fully comparable across 
    methods for treating unequal variances. 
 
    References 
    ---------- 
    Wellek, Stefan. 2010. Testing Statistical Hypotheses of Equivalence and 
    Noninferiority. 2nd ed. Boca Raton: CRC Press. 
 
    Cribbie, Robert A., Chantal A. Arpin-Cribbie, and Jamie A. Gruman. 2009. 
    “Tests of Equivalence for One-Way Independent Groups Designs.” The Journal 
    of Experimental Education 78 (1): 1–13. 
    https://doi.org/10.1080/00220970903224552. 
 
    Jan, Show-Li, and Gwowen Shieh. 2019. “On the Extended Welch Test for 
    Assessing Equivalence of Standardized Means.” Statistics in 
    Biopharmaceutical Research 0 (0): 1–8. 
    https://doi.org/10.1080/19466315.2019.1654915. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">nobs_t = nobs.sum()</span>
    <span class="s1">nobs_mean = nobs_t / n_groups</span>

    <span class="s3">if </span><span class="s1">margin_type == </span><span class="s4">&quot;wellek&quot;</span><span class="s1">:</span>
        <span class="s1">nc_null = nobs_mean * equiv_margin**</span><span class="s5">2</span>
        <span class="s1">es = f_stat * (n_groups - </span><span class="s5">1</span><span class="s1">) / nobs_mean</span>
        <span class="s1">type_effectsize = </span><span class="s4">&quot;Wellek's psi_squared&quot;</span>
    <span class="s3">elif </span><span class="s1">margin_type </span><span class="s3">in </span><span class="s1">[</span><span class="s4">&quot;f2&quot;</span><span class="s3">, </span><span class="s4">&quot;fsqu&quot;</span><span class="s3">, </span><span class="s4">&quot;fsquared&quot;</span><span class="s1">]:</span>
        <span class="s1">nc_null = nobs_t * equiv_margin</span>
        <span class="s1">es = f_stat / nobs_t</span>
        <span class="s1">type_effectsize = </span><span class="s4">&quot;Cohen's f_squared&quot;</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'`margin_type` should be &quot;f2&quot; or &quot;wellek&quot;'</span><span class="s1">)</span>
    <span class="s1">crit_f = ncf_ppf(alpha</span><span class="s3">, </span><span class="s1">df[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">df[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">nc_null)</span>

    <span class="s3">if </span><span class="s1">margin_type == </span><span class="s4">&quot;wellek&quot;</span><span class="s1">:</span>
        <span class="s0"># TODO: do we need a sqrt</span>
        <span class="s1">crit_es = crit_f * (n_groups - </span><span class="s5">1</span><span class="s1">) / nobs_mean</span>
    <span class="s3">elif </span><span class="s1">margin_type </span><span class="s3">in </span><span class="s1">[</span><span class="s4">&quot;f2&quot;</span><span class="s3">, </span><span class="s4">&quot;fsqu&quot;</span><span class="s3">, </span><span class="s4">&quot;fsquared&quot;</span><span class="s1">]:</span>
        <span class="s1">crit_es = crit_f / nobs_t</span>

    <span class="s1">reject = (es &lt; crit_es)</span>

    <span class="s1">pv = ncf_cdf(f_stat</span><span class="s3">, </span><span class="s1">df[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">df[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">nc_null)</span>
    <span class="s1">pwr = ncf_cdf(crit_f</span><span class="s3">, </span><span class="s1">df[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">df[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s5">1e-13</span><span class="s1">)  </span><span class="s0"># scipy, cannot be 0</span>
    <span class="s1">res = HolderTuple(statistic=f_stat</span><span class="s3">,</span>
                      <span class="s1">pvalue=pv</span><span class="s3">,</span>
                      <span class="s1">effectsize=es</span><span class="s3">,  </span><span class="s0"># match es type to margin_type</span>
                      <span class="s1">crit_f=crit_f</span><span class="s3">,</span>
                      <span class="s1">crit_es=crit_es</span><span class="s3">,</span>
                      <span class="s1">reject=reject</span><span class="s3">,</span>
                      <span class="s1">power_zero=pwr</span><span class="s3">,</span>
                      <span class="s1">df=df</span><span class="s3">,</span>
                      <span class="s1">f_stat=f_stat</span><span class="s3">,</span>
                      <span class="s1">type_effectsize=type_effectsize</span>
                      <span class="s1">)</span>
    <span class="s3">return </span><span class="s1">res</span>


<span class="s3">def </span><span class="s1">equivalence_oneway(data</span><span class="s3">, </span><span class="s1">equiv_margin</span><span class="s3">, </span><span class="s1">groups=</span><span class="s3">None, </span><span class="s1">use_var=</span><span class="s4">&quot;unequal&quot;</span><span class="s3">,</span>
                       <span class="s1">welch_correction=</span><span class="s3">True, </span><span class="s1">trim_frac=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">margin_type=</span><span class="s4">&quot;f2&quot;</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;equivalence test for oneway anova (Wellek's Anova) 
 
    The null hypothesis is that the means differ by more than `equiv_margin` 
    in the anova distance measure. 
    If the Null is rejected, then the data supports that means are equivalent, 
    i.e. within a given distance. 
 
    Parameters 
    ---------- 
    data : tuple of array_like or DataFrame or Series 
        Data for k independent samples, with k &gt;= 2. 
        The data can be provided as a tuple or list of arrays or in long 
        format with outcome observations in ``data`` and group membership in 
        ``groups``. 
    equiv_margin : float 
        Equivalence margin in terms of effect size. Effect size can be chosen 
        with `margin_type`. default is squared Cohen's f. 
    groups : ndarray or Series 
        If data is in long format, then groups is needed as indicator to which 
        group or sample and observations belongs. 
    use_var : {&quot;unequal&quot;, &quot;equal&quot; or &quot;bf&quot;} 
        `use_var` specified how to treat heteroscedasticity, unequal variance, 
        across samples. Three approaches are available 
 
        &quot;unequal&quot; : Variances are not assumed to be equal across samples. 
            Heteroscedasticity is taken into account with Welch Anova and 
            Satterthwaite-Welch degrees of freedom. 
            This is the default. 
        &quot;equal&quot; : Variances are assumed to be equal across samples. 
            This is the standard Anova. 
        &quot;bf: Variances are not assumed to be equal across samples. 
            The method is Browne-Forsythe (1971) for testing equality of means 
            with the corrected degrees of freedom by Merothra. The original BF 
            degrees of freedom are available as additional attributes in the 
            results instance, ``df_denom2`` and ``p_value2``. 
 
    welch_correction : bool 
        If this is false, then the Welch correction to the test statistic is 
        not included. This allows the computation of an effect size measure 
        that corresponds more closely to Cohen's f. 
    trim_frac : float in [0, 0.5) 
        Optional trimming for Anova with trimmed mean and winsorized variances. 
        With the default trim_frac equal to zero, the oneway Anova statistics 
        are computed without trimming. If `trim_frac` is larger than zero, 
        then the largest and smallest observations in each sample are trimmed. 
        The number of trimmed observations is the fraction of number of 
        observations in the sample truncated to the next lower integer. 
        `trim_frac` has to be smaller than 0.5, however, if the fraction is 
        so large that there are not enough observations left over, then `nan` 
        will be returned. 
    margin_type : &quot;f2&quot; or &quot;wellek&quot; 
        Type of effect size used for equivalence margin, either squared 
        Cohen's f or Wellek's psi. Default is &quot;f2&quot;. 
 
    Returns 
    ------- 
    results : instance of HolderTuple class 
        The two main attributes are test statistic `statistic` and p-value 
        `pvalue`. 
 
    See Also 
    -------- 
    anova_oneway 
    equivalence_scale_oneway 
    &quot;&quot;&quot;</span>

    <span class="s0"># use anova to compute summary statistics and f-statistic</span>
    <span class="s1">res0 = anova_oneway(data</span><span class="s3">, </span><span class="s1">groups=groups</span><span class="s3">, </span><span class="s1">use_var=use_var</span><span class="s3">,</span>
                        <span class="s1">welch_correction=welch_correction</span><span class="s3">,</span>
                        <span class="s1">trim_frac=trim_frac)</span>
    <span class="s1">f_stat = res0.statistic</span>
    <span class="s1">res = equivalence_oneway_generic(f_stat</span><span class="s3">, </span><span class="s1">res0.n_groups</span><span class="s3">, </span><span class="s1">res0.nobs_t</span><span class="s3">,</span>
                                     <span class="s1">equiv_margin</span><span class="s3">, </span><span class="s1">res0.df</span><span class="s3">, </span><span class="s1">alpha=</span><span class="s5">0.05</span><span class="s3">,</span>
                                     <span class="s1">margin_type=margin_type)</span>

    <span class="s3">return </span><span class="s1">res</span>


<span class="s3">def </span><span class="s1">_power_equivalence_oneway_emp(f_stat</span><span class="s3">, </span><span class="s1">n_groups</span><span class="s3">, </span><span class="s1">nobs</span><span class="s3">, </span><span class="s1">eps</span><span class="s3">, </span><span class="s1">df</span><span class="s3">, </span><span class="s1">alpha=</span><span class="s5">0.05</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Empirical power of oneway equivalence test 
 
    This only returns post-hoc, empirical power. 
 
    Warning: eps is currently effect size margin as defined as in Wellek, and 
    not the signal to noise ratio (Cohen's f family). 
 
    Parameters 
    ---------- 
    f_stat : float 
        F-statistic from oneway anova, used to compute empirical effect size 
    n_groups : int 
        Number of groups in oneway comparison. 
    nobs : ndarray 
        Array of number of observations in groups. 
    eps : float 
        Equivalence margin in terms of effect size given by Wellek's psi. 
    df : tuple 
        Degrees of freedom for F distribution. 
    alpha : float in (0, 1) 
        Significance level for the hypothesis test. 
 
    Returns 
    ------- 
    pow : float 
        Ex-post, post-hoc or empirical power at f-statistic of the equivalence 
        test. 
    &quot;&quot;&quot;</span>

    <span class="s1">res = equivalence_oneway_generic(f_stat</span><span class="s3">, </span><span class="s1">n_groups</span><span class="s3">, </span><span class="s1">nobs</span><span class="s3">, </span><span class="s1">eps</span><span class="s3">, </span><span class="s1">df</span><span class="s3">,</span>
                                     <span class="s1">alpha=alpha</span><span class="s3">, </span><span class="s1">margin_type=</span><span class="s4">&quot;wellek&quot;</span><span class="s1">)</span>

    <span class="s1">nobs_mean = nobs.sum() / n_groups</span>
    <span class="s1">fn = f_stat  </span><span class="s0"># post-hoc power, empirical power at estimate</span>
    <span class="s1">esn = fn * (n_groups - </span><span class="s5">1</span><span class="s1">) / nobs_mean  </span><span class="s0"># Wellek psi</span>
    <span class="s1">pow_ = ncf_cdf(res.crit_f</span><span class="s3">, </span><span class="s1">df[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">df[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">nobs_mean * esn)</span>

    <span class="s3">return </span><span class="s1">pow_</span>


<span class="s3">def </span><span class="s1">power_equivalence_oneway(f2_alt</span><span class="s3">, </span><span class="s1">equiv_margin</span><span class="s3">, </span><span class="s1">nobs_t</span><span class="s3">, </span><span class="s1">n_groups=</span><span class="s3">None,</span>
                             <span class="s1">df=</span><span class="s3">None, </span><span class="s1">alpha=</span><span class="s5">0.05</span><span class="s3">, </span><span class="s1">margin_type=</span><span class="s4">&quot;f2&quot;</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Power of  oneway equivalence test 
 
    Parameters 
    ---------- 
    f2_alt : float 
        Effect size, squared Cohen's f, under the alternative. 
    equiv_margin : float 
        Equivalence margin in terms of effect size. Effect size can be chosen 
        with `margin_type`. default is squared Cohen's f. 
    nobs_t : ndarray 
        Total number of observations summed over all groups. 
    n_groups : int 
        Number of groups in oneway comparison. If margin_type is &quot;wellek&quot;, 
        then either ``n_groups`` or ``df`` has to be given. 
    df : tuple 
        Degrees of freedom for F distribution, 
        ``df = (n_groups - 1, nobs_t - n_groups)`` 
    alpha : float in (0, 1) 
        Significance level for the hypothesis test. 
    margin_type : &quot;f2&quot; or &quot;wellek&quot; 
        Type of effect size used for equivalence margin, either squared 
        Cohen's f or Wellek's psi. Default is &quot;f2&quot;. 
 
    Returns 
    ------- 
    pow_alt : float 
        Power of the equivalence test at given equivalence effect size under 
        the alternative. 
    &quot;&quot;&quot;</span>

    <span class="s0"># one of n_groups or df has to be specified</span>
    <span class="s3">if </span><span class="s1">df </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">n_groups </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;either df or n_groups has to be provided&quot;</span><span class="s1">)</span>
        <span class="s1">df = (n_groups - </span><span class="s5">1</span><span class="s3">, </span><span class="s1">nobs_t - n_groups)</span>

    <span class="s0"># esn = fn * (n_groups - 1) / nobs_mean  # Wellek psi</span>

    <span class="s0"># fix for scipy, ncf does not allow nc == 0, fixed in scipy master</span>
    <span class="s3">if </span><span class="s1">f2_alt == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">f2_alt = </span><span class="s5">1e-13</span>
    <span class="s0"># effect size, critical value at margin</span>
    <span class="s0"># f2_null = equiv_margin</span>
    <span class="s3">if </span><span class="s1">margin_type </span><span class="s3">in </span><span class="s1">[</span><span class="s4">&quot;f2&quot;</span><span class="s3">, </span><span class="s4">&quot;fsqu&quot;</span><span class="s3">, </span><span class="s4">&quot;fsquared&quot;</span><span class="s1">]:</span>
        <span class="s1">f2_null = equiv_margin</span>
    <span class="s3">elif </span><span class="s1">margin_type == </span><span class="s4">&quot;wellek&quot;</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">n_groups </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;If margin_type is wellek, then n_groups has &quot;</span>
                             <span class="s4">&quot;to be provided&quot;</span><span class="s1">)</span>
        <span class="s0">#  f2_null = (n_groups - 1) * n_groups / nobs_t * equiv_margin**2</span>
        <span class="s1">nobs_mean = nobs_t / n_groups</span>
        <span class="s1">f2_null = nobs_mean * equiv_margin**</span><span class="s5">2 </span><span class="s1">/ nobs_t</span>
        <span class="s1">f2_alt = nobs_mean * f2_alt**</span><span class="s5">2 </span><span class="s1">/ nobs_t</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'`margin_type` should be &quot;f2&quot; or &quot;wellek&quot;'</span><span class="s1">)</span>

    <span class="s1">crit_f_margin = ncf_ppf(alpha</span><span class="s3">, </span><span class="s1">df[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">df[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">nobs_t * f2_null)</span>
    <span class="s1">pwr_alt = ncf_cdf(crit_f_margin</span><span class="s3">, </span><span class="s1">df[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">df[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">nobs_t * f2_alt)</span>
    <span class="s3">return </span><span class="s1">pwr_alt</span>


<span class="s3">def </span><span class="s1">simulate_power_equivalence_oneway(means</span><span class="s3">, </span><span class="s1">nobs</span><span class="s3">, </span><span class="s1">equiv_margin</span><span class="s3">, </span><span class="s1">vars_=</span><span class="s3">None,</span>
                                      <span class="s1">k_mc=</span><span class="s5">1000</span><span class="s3">, </span><span class="s1">trim_frac=</span><span class="s5">0</span><span class="s3">,</span>
                                      <span class="s1">options_var=</span><span class="s3">None, </span><span class="s1">margin_type=</span><span class="s4">&quot;f2&quot;</span>
                                      <span class="s1">):  </span><span class="s0"># , anova_options=None):  #TODO</span>
    <span class="s2">&quot;&quot;&quot;Simulate Power for oneway equivalence test (Wellek's Anova) 
 
    This function is experimental and written to evaluate asymptotic power 
    function. This function will change without backwards compatibility 
    constraints. The only part that is stable is `pvalue` attribute in results. 
 
    Effect size for equivalence margin 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">options_var </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">options_var = [</span><span class="s4">&quot;unequal&quot;</span><span class="s3">, </span><span class="s4">&quot;equal&quot;</span><span class="s3">, </span><span class="s4">&quot;bf&quot;</span><span class="s1">]</span>
    <span class="s3">if </span><span class="s1">vars_ </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">stds = np.sqrt(vars_)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">stds = np.ones(len(means))</span>

    <span class="s1">nobs_mean = nobs.mean()</span>
    <span class="s1">n_groups = len(nobs)</span>
    <span class="s1">res_mc = []</span>
    <span class="s1">f_mc = []</span>
    <span class="s1">reject_mc = []</span>
    <span class="s1">other_mc = []</span>
    <span class="s3">for </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">range(k_mc):</span>
        <span class="s1">y0</span><span class="s3">, </span><span class="s1">y1</span><span class="s3">, </span><span class="s1">y2</span><span class="s3">, </span><span class="s1">y3 = [m + std * np.random.randn(n)</span>
                          <span class="s3">for </span><span class="s1">(n</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">std) </span><span class="s3">in </span><span class="s1">zip(nobs</span><span class="s3">, </span><span class="s1">means</span><span class="s3">, </span><span class="s1">stds)]</span>

        <span class="s1">res_i = []</span>
        <span class="s1">f_i = []</span>
        <span class="s1">reject_i = []</span>
        <span class="s1">other_i = []</span>
        <span class="s3">for </span><span class="s1">uv </span><span class="s3">in </span><span class="s1">options_var:</span>
            <span class="s0"># for welch in options_welch:</span>
            <span class="s0"># res1 = sma.anova_generic(means, vars_, nobs, use_var=uv,</span>
            <span class="s0">#                          welch_correction=welch)</span>
            <span class="s1">res0 = anova_oneway([y0</span><span class="s3">, </span><span class="s1">y1</span><span class="s3">, </span><span class="s1">y2</span><span class="s3">, </span><span class="s1">y3]</span><span class="s3">, </span><span class="s1">use_var=uv</span><span class="s3">,</span>
                                <span class="s1">trim_frac=trim_frac)</span>
            <span class="s1">f_stat = res0.statistic</span>
            <span class="s1">res1 = equivalence_oneway_generic(f_stat</span><span class="s3">, </span><span class="s1">n_groups</span><span class="s3">, </span><span class="s1">nobs.sum()</span><span class="s3">,</span>
                                              <span class="s1">equiv_margin</span><span class="s3">, </span><span class="s1">res0.df</span><span class="s3">,</span>
                                              <span class="s1">alpha=</span><span class="s5">0.05</span><span class="s3">,</span>
                                              <span class="s1">margin_type=margin_type)</span>
            <span class="s1">res_i.append(res1.pvalue)</span>
            <span class="s1">es_wellek = f_stat * (n_groups - </span><span class="s5">1</span><span class="s1">) / nobs_mean</span>
            <span class="s1">f_i.append(es_wellek)</span>
            <span class="s1">reject_i.append(res1.reject)</span>
            <span class="s1">other_i.extend([res1.crit_f</span><span class="s3">, </span><span class="s1">res1.crit_es</span><span class="s3">, </span><span class="s1">res1.power_zero])</span>
        <span class="s1">res_mc.append(res_i)</span>
        <span class="s1">f_mc.append(f_i)</span>
        <span class="s1">reject_mc.append(reject_i)</span>
        <span class="s1">other_mc.append(other_i)</span>

    <span class="s1">f_mc = np.asarray(f_mc)</span>
    <span class="s1">other_mc = np.asarray(other_mc)</span>
    <span class="s1">res_mc = np.asarray(res_mc)</span>
    <span class="s1">reject_mc = np.asarray(reject_mc)</span>
    <span class="s1">res = Holder(f_stat=f_mc</span><span class="s3">,</span>
                 <span class="s1">other=other_mc</span><span class="s3">,</span>
                 <span class="s1">pvalue=res_mc</span><span class="s3">,</span>
                 <span class="s1">reject=reject_mc</span>
                 <span class="s1">)</span>
    <span class="s3">return </span><span class="s1">res</span>


<span class="s3">def </span><span class="s1">test_scale_oneway(data</span><span class="s3">, </span><span class="s1">method=</span><span class="s4">&quot;bf&quot;</span><span class="s3">, </span><span class="s1">center=</span><span class="s4">&quot;median&quot;</span><span class="s3">, </span><span class="s1">transform=</span><span class="s4">&quot;abs&quot;</span><span class="s3">,</span>
                      <span class="s1">trim_frac_mean=</span><span class="s5">0.1</span><span class="s3">, </span><span class="s1">trim_frac_anova=</span><span class="s5">0.0</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Oneway Anova test for equal scale, variance or dispersion 
 
    This hypothesis test performs a oneway anova test on transformed data and 
    includes Levene and Brown-Forsythe tests for equal variances as special 
    cases. 
 
    Parameters 
    ---------- 
    data : tuple of array_like or DataFrame or Series 
        Data for k independent samples, with k &gt;= 2. The data can be provided 
        as a tuple or list of arrays or in long format with outcome 
        observations in ``data`` and group membership in ``groups``. 
    method : {&quot;unequal&quot;, &quot;equal&quot; or &quot;bf&quot;} 
        How to treat heteroscedasticity across samples. This is used as 
        `use_var` option in `anova_oneway` and refers to the variance of the 
        transformed data, i.e. assumption is on 4th moment if squares are used 
        as transform. 
        Three approaches are available: 
 
        &quot;unequal&quot; : Variances are not assumed to be equal across samples. 
            Heteroscedasticity is taken into account with Welch Anova and 
            Satterthwaite-Welch degrees of freedom. 
            This is the default. 
        &quot;equal&quot; : Variances are assumed to be equal across samples. 
            This is the standard Anova. 
        &quot;bf&quot; : Variances are not assumed to be equal across samples. 
            The method is Browne-Forsythe (1971) for testing equality of means 
            with the corrected degrees of freedom by Merothra. The original BF 
            degrees of freedom are available as additional attributes in the 
            results instance, ``df_denom2`` and ``p_value2``. 
 
    center : &quot;median&quot;, &quot;mean&quot;, &quot;trimmed&quot; or float 
        Statistic used for centering observations. If a float, then this 
        value is used to center. Default is median. 
    transform : &quot;abs&quot;, &quot;square&quot; or callable 
        Transformation for the centered observations. If a callable, then this 
        function is called on the centered data. 
        Default is absolute value. 
    trim_frac_mean=0.1 : float in [0, 0.5) 
        Trim fraction for the trimmed mean when `center` is &quot;trimmed&quot; 
    trim_frac_anova : float in [0, 0.5) 
        Optional trimming for Anova with trimmed mean and Winsorized variances. 
        With the default trim_frac equal to zero, the oneway Anova statistics 
        are computed without trimming. If `trim_frac` is larger than zero, 
        then the largest and smallest observations in each sample are trimmed. 
        see ``trim_frac`` option in `anova_oneway` 
 
    Returns 
    ------- 
    res : results instance 
        The returned HolderTuple instance has the following main attributes 
        and some additional information in other attributes. 
 
        statistic : float 
            Test statistic for k-sample mean comparison which is approximately 
            F-distributed. 
        pvalue : float 
            If ``method=&quot;bf&quot;``, then the p-value is based on corrected 
            degrees of freedom following Mehrotra 1997. 
        pvalue2 : float 
            This is the p-value based on degrees of freedom as in 
            Brown-Forsythe 1974 and is only available if ``method=&quot;bf&quot;``. 
        df : (df_denom, df_num) 
            Tuple containing degrees of freedom for the F-distribution depend 
            on ``method``. If ``method=&quot;bf&quot;``, then `df_denom` is for Mehrotra 
            p-values `df_denom2` is available for Brown-Forsythe 1974 p-values. 
            `df_num` is the same numerator degrees of freedom for both 
            p-values. 
 
    See Also 
    -------- 
    anova_oneway 
    scale_transform 
    &quot;&quot;&quot;</span>

    <span class="s1">data = map(np.asarray</span><span class="s3">, </span><span class="s1">data)</span>
    <span class="s1">xxd = [scale_transform(x</span><span class="s3">, </span><span class="s1">center=center</span><span class="s3">, </span><span class="s1">transform=transform</span><span class="s3">,</span>
                           <span class="s1">trim_frac=trim_frac_mean) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">data]</span>

    <span class="s1">res = anova_oneway(xxd</span><span class="s3">, </span><span class="s1">groups=</span><span class="s3">None, </span><span class="s1">use_var=method</span><span class="s3">,</span>
                       <span class="s1">welch_correction=</span><span class="s3">True, </span><span class="s1">trim_frac=trim_frac_anova)</span>
    <span class="s1">res.data_transformed = xxd</span>
    <span class="s3">return </span><span class="s1">res</span>


<span class="s3">def </span><span class="s1">equivalence_scale_oneway(data</span><span class="s3">, </span><span class="s1">equiv_margin</span><span class="s3">, </span><span class="s1">method=</span><span class="s4">'bf'</span><span class="s3">, </span><span class="s1">center=</span><span class="s4">'median'</span><span class="s3">,</span>
                             <span class="s1">transform=</span><span class="s4">'abs'</span><span class="s3">, </span><span class="s1">trim_frac_mean=</span><span class="s5">0.</span><span class="s3">,</span>
                             <span class="s1">trim_frac_anova=</span><span class="s5">0.</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot;Oneway Anova test for equivalence of scale, variance or dispersion 
 
    This hypothesis test performs a oneway equivalence anova test on 
    transformed data. 
 
    Note, the interpretation of the equivalence margin `equiv_margin` will 
    depend on the transformation of the data. Transformations like 
    absolute deviation are not scaled to correspond to the variance under 
    normal distribution. 
 
    Parameters 
    ---------- 
    data : tuple of array_like or DataFrame or Series 
        Data for k independent samples, with k &gt;= 2. The data can be provided 
        as a tuple or list of arrays or in long format with outcome 
        observations in ``data`` and group membership in ``groups``. 
    equiv_margin : float 
        Equivalence margin in terms of effect size. Effect size can be chosen 
        with `margin_type`. default is squared Cohen's f. 
    method : {&quot;unequal&quot;, &quot;equal&quot; or &quot;bf&quot;} 
        How to treat heteroscedasticity across samples. This is used as 
        `use_var` option in `anova_oneway` and refers to the variance of the 
        transformed data, i.e. assumption is on 4th moment if squares are used 
        as transform. 
        Three approaches are available: 
 
        &quot;unequal&quot; : Variances are not assumed to be equal across samples. 
            Heteroscedasticity is taken into account with Welch Anova and 
            Satterthwaite-Welch degrees of freedom. 
            This is the default. 
        &quot;equal&quot; : Variances are assumed to be equal across samples. 
            This is the standard Anova. 
        &quot;bf&quot; : Variances are not assumed to be equal across samples. 
            The method is Browne-Forsythe (1971) for testing equality of means 
            with the corrected degrees of freedom by Merothra. The original BF 
            degrees of freedom are available as additional attributes in the 
            results instance, ``df_denom2`` and ``p_value2``. 
    center : &quot;median&quot;, &quot;mean&quot;, &quot;trimmed&quot; or float 
        Statistic used for centering observations. If a float, then this 
        value is used to center. Default is median. 
    transform : &quot;abs&quot;, &quot;square&quot; or callable 
        Transformation for the centered observations. If a callable, then this 
        function is called on the centered data. 
        Default is absolute value. 
    trim_frac_mean : float in [0, 0.5) 
        Trim fraction for the trimmed mean when `center` is &quot;trimmed&quot; 
    trim_frac_anova : float in [0, 0.5) 
        Optional trimming for Anova with trimmed mean and Winsorized variances. 
        With the default trim_frac equal to zero, the oneway Anova statistics 
        are computed without trimming. If `trim_frac` is larger than zero, 
        then the largest and smallest observations in each sample are trimmed. 
        see ``trim_frac`` option in `anova_oneway` 
 
    Returns 
    ------- 
    results : instance of HolderTuple class 
        The two main attributes are test statistic `statistic` and p-value 
        `pvalue`. 
 
    See Also 
    -------- 
    anova_oneway 
    scale_transform 
    equivalence_oneway 
    &quot;&quot;&quot;</span>
    <span class="s1">data = map(np.asarray</span><span class="s3">, </span><span class="s1">data)</span>
    <span class="s1">xxd = [scale_transform(x</span><span class="s3">, </span><span class="s1">center=center</span><span class="s3">, </span><span class="s1">transform=transform</span><span class="s3">,</span>
                           <span class="s1">trim_frac=trim_frac_mean) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">data]</span>

    <span class="s1">res = equivalence_oneway(xxd</span><span class="s3">, </span><span class="s1">equiv_margin</span><span class="s3">, </span><span class="s1">use_var=method</span><span class="s3">,</span>
                             <span class="s1">welch_correction=</span><span class="s3">True, </span><span class="s1">trim_frac=trim_frac_anova)</span>
    <span class="s1">res.x_transformed = xxd</span>
    <span class="s3">return </span><span class="s1">res</span>
</pre>
</body>
</html>