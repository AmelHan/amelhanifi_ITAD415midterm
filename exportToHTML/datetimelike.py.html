<html>
<head>
<title>datetimelike.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
datetimelike.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Base and utility classes for tseries type pandas objects. 
&quot;&quot;&quot;</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">from </span><span class="s1">abc </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">ABC</span><span class="s2">,</span>
    <span class="s1">abstractmethod</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">TYPE_CHECKING</span><span class="s2">,</span>
    <span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">Callable</span><span class="s2">,</span>
    <span class="s1">cast</span><span class="s2">,</span>
    <span class="s1">final</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">from </span><span class="s1">pandas._config </span><span class="s2">import </span><span class="s1">using_copy_on_write</span>

<span class="s2">from </span><span class="s1">pandas._libs </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">NaT</span><span class="s2">,</span>
    <span class="s1">Timedelta</span><span class="s2">,</span>
    <span class="s1">lib</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas._libs.tslibs </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">BaseOffset</span><span class="s2">,</span>
    <span class="s1">Resolution</span><span class="s2">,</span>
    <span class="s1">Tick</span><span class="s2">,</span>
    <span class="s1">parsing</span><span class="s2">,</span>
    <span class="s1">to_offset</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.compat.numpy </span><span class="s2">import </span><span class="s1">function </span><span class="s2">as </span><span class="s1">nv</span>
<span class="s2">from </span><span class="s1">pandas.errors </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">InvalidIndexError</span><span class="s2">,</span>
    <span class="s1">NullFrequencyError</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.util._decorators </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">Appender</span><span class="s2">,</span>
    <span class="s1">cache_readonly</span><span class="s2">,</span>
    <span class="s1">doc</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">from </span><span class="s1">pandas.core.dtypes.common </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">is_integer</span><span class="s2">,</span>
    <span class="s1">is_list_like</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.dtypes.concat </span><span class="s2">import </span><span class="s1">concat_compat</span>
<span class="s2">from </span><span class="s1">pandas.core.dtypes.dtypes </span><span class="s2">import </span><span class="s1">CategoricalDtype</span>

<span class="s2">from </span><span class="s1">pandas.core.arrays </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">DatetimeArray</span><span class="s2">,</span>
    <span class="s1">ExtensionArray</span><span class="s2">,</span>
    <span class="s1">PeriodArray</span><span class="s2">,</span>
    <span class="s1">TimedeltaArray</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.arrays.datetimelike </span><span class="s2">import </span><span class="s1">DatetimeLikeArrayMixin</span>
<span class="s2">import </span><span class="s1">pandas.core.common </span><span class="s2">as </span><span class="s1">com</span>
<span class="s2">import </span><span class="s1">pandas.core.indexes.base </span><span class="s2">as </span><span class="s1">ibase</span>
<span class="s2">from </span><span class="s1">pandas.core.indexes.base </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">Index</span><span class="s2">,</span>
    <span class="s1">_index_shared_docs</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.indexes.extension </span><span class="s2">import </span><span class="s1">NDArrayBackedExtensionIndex</span>
<span class="s2">from </span><span class="s1">pandas.core.indexes.range </span><span class="s2">import </span><span class="s1">RangeIndex</span>
<span class="s2">from </span><span class="s1">pandas.core.tools.timedeltas </span><span class="s2">import </span><span class="s1">to_timedelta</span>

<span class="s2">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s2">from </span><span class="s1">collections.abc </span><span class="s2">import </span><span class="s1">Sequence</span>
    <span class="s2">from </span><span class="s1">datetime </span><span class="s2">import </span><span class="s1">datetime</span>

    <span class="s2">from </span><span class="s1">pandas._typing </span><span class="s2">import </span><span class="s1">(</span>
        <span class="s1">Axis</span><span class="s2">,</span>
        <span class="s1">Self</span><span class="s2">,</span>
        <span class="s1">npt</span><span class="s2">,</span>
    <span class="s1">)</span>

    <span class="s2">from </span><span class="s1">pandas </span><span class="s2">import </span><span class="s1">CategoricalIndex</span>

<span class="s1">_index_doc_kwargs = dict(ibase._index_doc_kwargs)</span>


<span class="s2">class </span><span class="s1">DatetimeIndexOpsMixin(NDArrayBackedExtensionIndex</span><span class="s2">, </span><span class="s1">ABC):</span>
    <span class="s0">&quot;&quot;&quot; 
    Common ops mixin to support a unified interface datetimelike Index. 
    &quot;&quot;&quot;</span>

    <span class="s1">_can_hold_strings = </span><span class="s2">False</span>
    <span class="s1">_data: DatetimeArray | TimedeltaArray | PeriodArray</span>

    <span class="s1">@doc(DatetimeLikeArrayMixin.mean)</span>
    <span class="s2">def </span><span class="s1">mean(self</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">skipna: bool = </span><span class="s2">True, </span><span class="s1">axis: int | </span><span class="s2">None </span><span class="s1">= </span><span class="s3">0</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s1">self._data.mean(skipna=skipna</span><span class="s2">, </span><span class="s1">axis=axis)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">freq(self) -&gt; BaseOffset | </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">self._data.freq</span>

    <span class="s1">@freq.setter</span>
    <span class="s2">def </span><span class="s1">freq(self</span><span class="s2">, </span><span class="s1">value) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s4"># error: Property &quot;freq&quot; defined in &quot;PeriodArray&quot; is read-only  [misc]</span>
        <span class="s1">self._data.freq = value  </span><span class="s4"># type: ignore[misc]</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">asi8(self) -&gt; npt.NDArray[np.int64]:</span>
        <span class="s2">return </span><span class="s1">self._data.asi8</span>

    <span class="s1">@property</span>
    <span class="s1">@doc(DatetimeLikeArrayMixin.freqstr)</span>
    <span class="s2">def </span><span class="s1">freqstr(self) -&gt; str | </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">self._data.freqstr</span>

    <span class="s1">@cache_readonly</span>
    <span class="s1">@abstractmethod</span>
    <span class="s2">def </span><span class="s1">_resolution_obj(self) -&gt; Resolution:</span>
        <span class="s1">...</span>

    <span class="s1">@cache_readonly</span>
    <span class="s1">@doc(DatetimeLikeArrayMixin.resolution)</span>
    <span class="s2">def </span><span class="s1">resolution(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s1">self._data.resolution</span>

    <span class="s4"># ------------------------------------------------------------------------</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">hasnans(self) -&gt; bool:</span>
        <span class="s2">return </span><span class="s1">self._data._hasna</span>

    <span class="s2">def </span><span class="s1">equals(self</span><span class="s2">, </span><span class="s1">other: Any) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot; 
        Determines if two Index objects contain the same elements. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.is_(other):</span>
            <span class="s2">return True</span>

        <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">Index):</span>
            <span class="s2">return False</span>
        <span class="s2">elif </span><span class="s1">other.dtype.kind </span><span class="s2">in </span><span class="s5">&quot;iufc&quot;</span><span class="s1">:</span>
            <span class="s2">return False</span>
        <span class="s2">elif not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">type(self)):</span>
            <span class="s1">should_try = </span><span class="s2">False</span>
            <span class="s1">inferable = self._data._infer_matches</span>
            <span class="s2">if </span><span class="s1">other.dtype == object:</span>
                <span class="s1">should_try = other.inferred_type </span><span class="s2">in </span><span class="s1">inferable</span>
            <span class="s2">elif </span><span class="s1">isinstance(other.dtype</span><span class="s2">, </span><span class="s1">CategoricalDtype):</span>
                <span class="s1">other = cast(</span><span class="s5">&quot;CategoricalIndex&quot;</span><span class="s2">, </span><span class="s1">other)</span>
                <span class="s1">should_try = other.categories.inferred_type </span><span class="s2">in </span><span class="s1">inferable</span>

            <span class="s2">if </span><span class="s1">should_try:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">other = type(self)(other)</span>
                <span class="s2">except </span><span class="s1">(ValueError</span><span class="s2">, </span><span class="s1">TypeError</span><span class="s2">, </span><span class="s1">OverflowError):</span>
                    <span class="s4"># e.g.</span>
                    <span class="s4">#  ValueError -&gt; cannot parse str entry, or OutOfBoundsDatetime</span>
                    <span class="s4">#  TypeError  -&gt; trying to convert IntervalIndex to DatetimeIndex</span>
                    <span class="s4">#  OverflowError -&gt; Index([very_large_timedeltas])</span>
                    <span class="s2">return False</span>

        <span class="s2">if </span><span class="s1">self.dtype != other.dtype:</span>
            <span class="s4"># have different timezone</span>
            <span class="s2">return False</span>

        <span class="s2">return </span><span class="s1">np.array_equal(self.asi8</span><span class="s2">, </span><span class="s1">other.asi8)</span>

    <span class="s1">@Appender(Index.__contains__.__doc__)</span>
    <span class="s2">def </span><span class="s1">__contains__(self</span><span class="s2">, </span><span class="s1">key: Any) -&gt; bool:</span>
        <span class="s1">hash(key)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">self.get_loc(key)</span>
        <span class="s2">except </span><span class="s1">(KeyError</span><span class="s2">, </span><span class="s1">TypeError</span><span class="s2">, </span><span class="s1">ValueError</span><span class="s2">, </span><span class="s1">InvalidIndexError):</span>
            <span class="s2">return False</span>
        <span class="s2">return True</span>

    <span class="s2">def </span><span class="s1">_convert_tolerance(self</span><span class="s2">, </span><span class="s1">tolerance</span><span class="s2">, </span><span class="s1">target):</span>
        <span class="s1">tolerance = np.asarray(to_timedelta(tolerance).to_numpy())</span>
        <span class="s2">return </span><span class="s1">super()._convert_tolerance(tolerance</span><span class="s2">, </span><span class="s1">target)</span>

    <span class="s4"># --------------------------------------------------------------------</span>
    <span class="s4"># Rendering Methods</span>

    <span class="s2">def </span><span class="s1">format(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">name: bool = </span><span class="s2">False,</span>
        <span class="s1">formatter: Callable | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">na_rep: str = </span><span class="s5">&quot;NaT&quot;</span><span class="s2">,</span>
        <span class="s1">date_format: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">) -&gt; list[str]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Render a string representation of the Index. 
        &quot;&quot;&quot;</span>
        <span class="s1">header = []</span>
        <span class="s2">if </span><span class="s1">name:</span>
            <span class="s1">header.append(</span>
                <span class="s1">ibase.pprint_thing(self.name</span><span class="s2">, </span><span class="s1">escape_chars=(</span><span class="s5">&quot;</span><span class="s2">\t</span><span class="s5">&quot;</span><span class="s2">, </span><span class="s5">&quot;</span><span class="s2">\r</span><span class="s5">&quot;</span><span class="s2">, </span><span class="s5">&quot;</span><span class="s2">\n</span><span class="s5">&quot;</span><span class="s1">))</span>
                <span class="s2">if </span><span class="s1">self.name </span><span class="s2">is not None</span>
                <span class="s2">else </span><span class="s5">&quot;&quot;</span>
            <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">formatter </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">header + list(self.map(formatter))</span>

        <span class="s2">return </span><span class="s1">self._format_with_header(header</span><span class="s2">, </span><span class="s1">na_rep=na_rep</span><span class="s2">, </span><span class="s1">date_format=date_format)</span>

    <span class="s2">def </span><span class="s1">_format_with_header(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">header: list[str]</span><span class="s2">, </span><span class="s1">na_rep: str = </span><span class="s5">&quot;NaT&quot;</span><span class="s2">, </span><span class="s1">date_format: str | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None</span>
    <span class="s1">) -&gt; list[str]:</span>
        <span class="s4"># matches base class except for whitespace padding and date_format</span>
        <span class="s2">return </span><span class="s1">header + list(</span>
            <span class="s1">self._format_native_types(na_rep=na_rep</span><span class="s2">, </span><span class="s1">date_format=date_format)</span>
        <span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_formatter_func(self):</span>
        <span class="s2">return </span><span class="s1">self._data._formatter()</span>

    <span class="s2">def </span><span class="s1">_format_attrs(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a list of tuples of the (attr,formatted_value). 
        &quot;&quot;&quot;</span>
        <span class="s1">attrs = super()._format_attrs()</span>
        <span class="s2">for </span><span class="s1">attrib </span><span class="s2">in </span><span class="s1">self._attributes:</span>
            <span class="s4"># iterating over _attributes prevents us from doing this for PeriodIndex</span>
            <span class="s2">if </span><span class="s1">attrib == </span><span class="s5">&quot;freq&quot;</span><span class="s1">:</span>
                <span class="s1">freq = self.freqstr</span>
                <span class="s2">if </span><span class="s1">freq </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">freq = repr(freq)  </span><span class="s4"># e.g. D -&gt; 'D'</span>
                <span class="s1">attrs.append((</span><span class="s5">&quot;freq&quot;</span><span class="s2">, </span><span class="s1">freq))</span>
        <span class="s2">return </span><span class="s1">attrs</span>

    <span class="s1">@Appender(Index._summary.__doc__)</span>
    <span class="s2">def </span><span class="s1">_summary(self</span><span class="s2">, </span><span class="s1">name=</span><span class="s2">None</span><span class="s1">) -&gt; str:</span>
        <span class="s1">result = super()._summary(name=name)</span>
        <span class="s2">if </span><span class="s1">self.freq:</span>
            <span class="s1">result += </span><span class="s5">f&quot;</span><span class="s2">\n</span><span class="s5">Freq: </span><span class="s2">{</span><span class="s1">self.freqstr</span><span class="s2">}</span><span class="s5">&quot;</span>

        <span class="s2">return </span><span class="s1">result</span>

    <span class="s4"># --------------------------------------------------------------------</span>
    <span class="s4"># Indexing Methods</span>

    <span class="s1">@final</span>
    <span class="s2">def </span><span class="s1">_can_partial_date_slice(self</span><span class="s2">, </span><span class="s1">reso: Resolution) -&gt; bool:</span>
        <span class="s4"># e.g. test_getitem_setitem_periodindex</span>
        <span class="s4"># History of conversation GH#3452, GH#3931, GH#2369, GH#14826</span>
        <span class="s2">return </span><span class="s1">reso &gt; self._resolution_obj</span>
        <span class="s4"># NB: for DTI/PI, not TDI</span>

    <span class="s2">def </span><span class="s1">_parsed_string_to_bounds(self</span><span class="s2">, </span><span class="s1">reso: Resolution</span><span class="s2">, </span><span class="s1">parsed):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s2">def </span><span class="s1">_parse_with_reso(self</span><span class="s2">, </span><span class="s1">label: str):</span>
        <span class="s4"># overridden by TimedeltaIndex</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.freq </span><span class="s2">is None or </span><span class="s1">hasattr(self.freq</span><span class="s2">, </span><span class="s5">&quot;rule_code&quot;</span><span class="s1">):</span>
                <span class="s1">freq = self.freq</span>
        <span class="s2">except </span><span class="s1">NotImplementedError:</span>
            <span class="s1">freq = getattr(self</span><span class="s2">, </span><span class="s5">&quot;freqstr&quot;</span><span class="s2">, </span><span class="s1">getattr(self</span><span class="s2">, </span><span class="s5">&quot;inferred_freq&quot;</span><span class="s2">, None</span><span class="s1">))</span>

        <span class="s1">freqstr: str | </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">freq </span><span class="s2">is not None and not </span><span class="s1">isinstance(freq</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">freqstr = freq.rule_code</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">freqstr = freq</span>

        <span class="s2">if </span><span class="s1">isinstance(label</span><span class="s2">, </span><span class="s1">np.str_):</span>
            <span class="s4"># GH#45580</span>
            <span class="s1">label = str(label)</span>

        <span class="s1">parsed</span><span class="s2">, </span><span class="s1">reso_str = parsing.parse_datetime_string_with_reso(label</span><span class="s2">, </span><span class="s1">freqstr)</span>
        <span class="s1">reso = Resolution.from_attrname(reso_str)</span>
        <span class="s2">return </span><span class="s1">parsed</span><span class="s2">, </span><span class="s1">reso</span>

    <span class="s2">def </span><span class="s1">_get_string_slice(self</span><span class="s2">, </span><span class="s1">key: str):</span>
        <span class="s4"># overridden by TimedeltaIndex</span>
        <span class="s1">parsed</span><span class="s2">, </span><span class="s1">reso = self._parse_with_reso(key)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._partial_date_slice(reso</span><span class="s2">, </span><span class="s1">parsed)</span>
        <span class="s2">except </span><span class="s1">KeyError </span><span class="s2">as </span><span class="s1">err:</span>
            <span class="s2">raise </span><span class="s1">KeyError(key) </span><span class="s2">from </span><span class="s1">err</span>

    <span class="s1">@final</span>
    <span class="s2">def </span><span class="s1">_partial_date_slice(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">reso: Resolution</span><span class="s2">,</span>
        <span class="s1">parsed: datetime</span><span class="s2">,</span>
    <span class="s1">) -&gt; slice | npt.NDArray[np.intp]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        reso : Resolution 
        parsed : datetime 
 
        Returns 
        ------- 
        slice or ndarray[intp] 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">self._can_partial_date_slice(reso):</span>
            <span class="s2">raise </span><span class="s1">ValueError</span>

        <span class="s1">t1</span><span class="s2">, </span><span class="s1">t2 = self._parsed_string_to_bounds(reso</span><span class="s2">, </span><span class="s1">parsed)</span>
        <span class="s1">vals = self._data._ndarray</span>
        <span class="s1">unbox = self._data._unbox</span>

        <span class="s2">if </span><span class="s1">self.is_monotonic_increasing:</span>
            <span class="s2">if </span><span class="s1">len(self) </span><span class="s2">and </span><span class="s1">(</span>
                <span class="s1">(t1 &lt; self[</span><span class="s3">0</span><span class="s1">] </span><span class="s2">and </span><span class="s1">t2 &lt; self[</span><span class="s3">0</span><span class="s1">]) </span><span class="s2">or </span><span class="s1">(t1 &gt; self[-</span><span class="s3">1</span><span class="s1">] </span><span class="s2">and </span><span class="s1">t2 &gt; self[-</span><span class="s3">1</span><span class="s1">])</span>
            <span class="s1">):</span>
                <span class="s4"># we are out of range</span>
                <span class="s2">raise </span><span class="s1">KeyError</span>

            <span class="s4"># TODO: does this depend on being monotonic _increasing_?</span>

            <span class="s4"># a monotonic (sorted) series can be sliced</span>
            <span class="s1">left = vals.searchsorted(unbox(t1)</span><span class="s2">, </span><span class="s1">side=</span><span class="s5">&quot;left&quot;</span><span class="s1">)</span>
            <span class="s1">right = vals.searchsorted(unbox(t2)</span><span class="s2">, </span><span class="s1">side=</span><span class="s5">&quot;right&quot;</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">slice(left</span><span class="s2">, </span><span class="s1">right)</span>

        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">lhs_mask = vals &gt;= unbox(t1)</span>
            <span class="s1">rhs_mask = vals &lt;= unbox(t2)</span>

            <span class="s4"># try to find the dates</span>
            <span class="s2">return </span><span class="s1">(lhs_mask &amp; rhs_mask).nonzero()[</span><span class="s3">0</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">_maybe_cast_slice_bound(self</span><span class="s2">, </span><span class="s1">label</span><span class="s2">, </span><span class="s1">side: str):</span>
        <span class="s0">&quot;&quot;&quot; 
        If label is a string, cast it to scalar type according to resolution. 
 
        Parameters 
        ---------- 
        label : object 
        side : {'left', 'right'} 
 
        Returns 
        ------- 
        label : object 
 
        Notes 
        ----- 
        Value of `side` parameter should be validated in caller. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(label</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">parsed</span><span class="s2">, </span><span class="s1">reso = self._parse_with_reso(label)</span>
            <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">err:</span>
                <span class="s4"># DTI -&gt; parsing.DateParseError</span>
                <span class="s4"># TDI -&gt; 'unit abbreviation w/o a number'</span>
                <span class="s4"># PI -&gt; string cannot be parsed as datetime-like</span>
                <span class="s1">self._raise_invalid_indexer(</span><span class="s5">&quot;slice&quot;</span><span class="s2">, </span><span class="s1">label</span><span class="s2">, </span><span class="s1">err)</span>

            <span class="s1">lower</span><span class="s2">, </span><span class="s1">upper = self._parsed_string_to_bounds(reso</span><span class="s2">, </span><span class="s1">parsed)</span>
            <span class="s2">return </span><span class="s1">lower </span><span class="s2">if </span><span class="s1">side == </span><span class="s5">&quot;left&quot; </span><span class="s2">else </span><span class="s1">upper</span>
        <span class="s2">elif not </span><span class="s1">isinstance(label</span><span class="s2">, </span><span class="s1">self._data._recognized_scalars):</span>
            <span class="s1">self._raise_invalid_indexer(</span><span class="s5">&quot;slice&quot;</span><span class="s2">, </span><span class="s1">label)</span>

        <span class="s2">return </span><span class="s1">label</span>

    <span class="s4"># --------------------------------------------------------------------</span>
    <span class="s4"># Arithmetic Methods</span>

    <span class="s2">def </span><span class="s1">shift(self</span><span class="s2">, </span><span class="s1">periods: int = </span><span class="s3">1</span><span class="s2">, </span><span class="s1">freq=</span><span class="s2">None</span><span class="s1">) -&gt; Self:</span>
        <span class="s0">&quot;&quot;&quot; 
        Shift index by desired number of time frequency increments. 
 
        This method is for shifting the values of datetime-like indexes 
        by a specified time increment a given number of times. 
 
        Parameters 
        ---------- 
        periods : int, default 1 
            Number of periods (or increments) to shift by, 
            can be positive or negative. 
        freq : pandas.DateOffset, pandas.Timedelta or string, optional 
            Frequency increment to shift by. 
            If None, the index is shifted by its own `freq` attribute. 
            Offset aliases are valid strings, e.g., 'D', 'W', 'M' etc. 
 
        Returns 
        ------- 
        pandas.DatetimeIndex 
            Shifted index. 
 
        See Also 
        -------- 
        Index.shift : Shift values of Index. 
        PeriodIndex.shift : Shift values of PeriodIndex. 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s4"># --------------------------------------------------------------------</span>

    <span class="s1">@doc(Index._maybe_cast_listlike_indexer)</span>
    <span class="s2">def </span><span class="s1">_maybe_cast_listlike_indexer(self</span><span class="s2">, </span><span class="s1">keyarr):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">res = self._data._validate_listlike(keyarr</span><span class="s2">, </span><span class="s1">allow_object=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">except </span><span class="s1">(ValueError</span><span class="s2">, </span><span class="s1">TypeError):</span>
            <span class="s2">if not </span><span class="s1">isinstance(keyarr</span><span class="s2">, </span><span class="s1">ExtensionArray):</span>
                <span class="s4"># e.g. we don't want to cast DTA to ndarray[object]</span>
                <span class="s1">res = com.asarray_tuplesafe(keyarr)</span>
                <span class="s4"># TODO: com.asarray_tuplesafe shouldn't cast e.g. DatetimeArray</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">res = keyarr</span>
        <span class="s2">return </span><span class="s1">Index(res</span><span class="s2">, </span><span class="s1">dtype=res.dtype)</span>


<span class="s2">class </span><span class="s1">DatetimeTimedeltaMixin(DatetimeIndexOpsMixin</span><span class="s2">, </span><span class="s1">ABC):</span>
    <span class="s0">&quot;&quot;&quot; 
    Mixin class for methods shared by DatetimeIndex and TimedeltaIndex, 
    but not PeriodIndex 
    &quot;&quot;&quot;</span>

    <span class="s1">_data: DatetimeArray | TimedeltaArray</span>
    <span class="s1">_comparables = [</span><span class="s5">&quot;name&quot;</span><span class="s2">, </span><span class="s5">&quot;freq&quot;</span><span class="s1">]</span>
    <span class="s1">_attributes = [</span><span class="s5">&quot;name&quot;</span><span class="s2">, </span><span class="s5">&quot;freq&quot;</span><span class="s1">]</span>

    <span class="s4"># Compat for frequency inference, see GH#23789</span>
    <span class="s1">_is_monotonic_increasing = Index.is_monotonic_increasing</span>
    <span class="s1">_is_monotonic_decreasing = Index.is_monotonic_decreasing</span>
    <span class="s1">_is_unique = Index.is_unique</span>

    <span class="s1">_join_precedence = </span><span class="s3">10</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">unit(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s1">self._data.unit</span>

    <span class="s2">def </span><span class="s1">as_unit(self</span><span class="s2">, </span><span class="s1">unit: str) -&gt; Self:</span>
        <span class="s0">&quot;&quot;&quot; 
        Convert to a dtype with the given unit resolution. 
 
        Parameters 
        ---------- 
        unit : {'s', 'ms', 'us', 'ns'} 
 
        Returns 
        ------- 
        same type as self 
 
        Examples 
        -------- 
        For :class:`pandas.DatetimeIndex`: 
 
        &gt;&gt;&gt; idx = pd.DatetimeIndex(['2020-01-02 01:02:03.004005006']) 
        &gt;&gt;&gt; idx 
        DatetimeIndex(['2020-01-02 01:02:03.004005006'], 
                      dtype='datetime64[ns]', freq=None) 
        &gt;&gt;&gt; idx.as_unit('s') 
        DatetimeIndex(['2020-01-02 01:02:03'], dtype='datetime64[s]', freq=None) 
 
        For :class:`pandas.TimedeltaIndex`: 
 
        &gt;&gt;&gt; tdelta_idx = pd.to_timedelta(['1 day 3 min 2 us 42 ns']) 
        &gt;&gt;&gt; tdelta_idx 
        TimedeltaIndex(['1 days 00:03:00.000002042'], 
                        dtype='timedelta64[ns]', freq=None) 
        &gt;&gt;&gt; tdelta_idx.as_unit('s') 
        TimedeltaIndex(['1 days 00:03:00'], dtype='timedelta64[s]', freq=None) 
        &quot;&quot;&quot;</span>
        <span class="s1">arr = self._data.as_unit(unit)</span>
        <span class="s2">return </span><span class="s1">type(self)._simple_new(arr</span><span class="s2">, </span><span class="s1">name=self.name)</span>

    <span class="s2">def </span><span class="s1">_with_freq(self</span><span class="s2">, </span><span class="s1">freq):</span>
        <span class="s1">arr = self._data._with_freq(freq)</span>
        <span class="s2">return </span><span class="s1">type(self)._simple_new(arr</span><span class="s2">, </span><span class="s1">name=self._name)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">values(self) -&gt; np.ndarray:</span>
        <span class="s4"># NB: For Datetime64TZ this is lossy</span>
        <span class="s1">data = self._data._ndarray</span>
        <span class="s2">if </span><span class="s1">using_copy_on_write():</span>
            <span class="s1">data = data.view()</span>
            <span class="s1">data.flags.writeable = </span><span class="s2">False</span>
        <span class="s2">return </span><span class="s1">data</span>

    <span class="s1">@doc(DatetimeIndexOpsMixin.shift)</span>
    <span class="s2">def </span><span class="s1">shift(self</span><span class="s2">, </span><span class="s1">periods: int = </span><span class="s3">1</span><span class="s2">, </span><span class="s1">freq=</span><span class="s2">None</span><span class="s1">) -&gt; Self:</span>
        <span class="s2">if </span><span class="s1">freq </span><span class="s2">is not None and </span><span class="s1">freq != self.freq:</span>
            <span class="s2">if </span><span class="s1">isinstance(freq</span><span class="s2">, </span><span class="s1">str):</span>
                <span class="s1">freq = to_offset(freq)</span>
            <span class="s1">offset = periods * freq</span>
            <span class="s2">return </span><span class="s1">self + offset</span>

        <span class="s2">if </span><span class="s1">periods == </span><span class="s3">0 </span><span class="s2">or </span><span class="s1">len(self) == </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s4"># GH#14811 empty case</span>
            <span class="s2">return </span><span class="s1">self.copy()</span>

        <span class="s2">if </span><span class="s1">self.freq </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">NullFrequencyError(</span><span class="s5">&quot;Cannot shift with no freq&quot;</span><span class="s1">)</span>

        <span class="s1">start = self[</span><span class="s3">0</span><span class="s1">] + periods * self.freq</span>
        <span class="s1">end = self[-</span><span class="s3">1</span><span class="s1">] + periods * self.freq</span>

        <span class="s4"># Note: in the DatetimeTZ case, _generate_range will infer the</span>
        <span class="s4">#  appropriate timezone from `start` and `end`, so tz does not need</span>
        <span class="s4">#  to be passed explicitly.</span>
        <span class="s1">result = self._data._generate_range(</span>
            <span class="s1">start=start</span><span class="s2">, </span><span class="s1">end=end</span><span class="s2">, </span><span class="s1">periods=</span><span class="s2">None, </span><span class="s1">freq=self.freq</span>
        <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">type(self)._simple_new(result</span><span class="s2">, </span><span class="s1">name=self.name)</span>

    <span class="s1">@cache_readonly</span>
    <span class="s1">@doc(DatetimeLikeArrayMixin.inferred_freq)</span>
    <span class="s2">def </span><span class="s1">inferred_freq(self) -&gt; str | </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">self._data.inferred_freq</span>

    <span class="s4"># --------------------------------------------------------------------</span>
    <span class="s4"># Set Operation Methods</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">_as_range_index(self) -&gt; RangeIndex:</span>
        <span class="s4"># Convert our i8 representations to RangeIndex</span>
        <span class="s4"># Caller is responsible for checking isinstance(self.freq, Tick)</span>
        <span class="s1">freq = cast(Tick</span><span class="s2">, </span><span class="s1">self.freq)</span>
        <span class="s1">tick = freq.delta._value</span>
        <span class="s1">rng = range(self[</span><span class="s3">0</span><span class="s1">]._value</span><span class="s2">, </span><span class="s1">self[-</span><span class="s3">1</span><span class="s1">]._value + tick</span><span class="s2">, </span><span class="s1">tick)</span>
        <span class="s2">return </span><span class="s1">RangeIndex(rng)</span>

    <span class="s2">def </span><span class="s1">_can_range_setop(self</span><span class="s2">, </span><span class="s1">other) -&gt; bool:</span>
        <span class="s2">return </span><span class="s1">isinstance(self.freq</span><span class="s2">, </span><span class="s1">Tick) </span><span class="s2">and </span><span class="s1">isinstance(other.freq</span><span class="s2">, </span><span class="s1">Tick)</span>

    <span class="s2">def </span><span class="s1">_wrap_range_setop(self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">res_i8) -&gt; Self:</span>
        <span class="s1">new_freq = </span><span class="s2">None</span>
        <span class="s2">if not </span><span class="s1">len(res_i8):</span>
            <span class="s4"># RangeIndex defaults to step=1, which we don't want.</span>
            <span class="s1">new_freq = self.freq</span>
        <span class="s2">elif </span><span class="s1">isinstance(res_i8</span><span class="s2">, </span><span class="s1">RangeIndex):</span>
            <span class="s1">new_freq = to_offset(Timedelta(res_i8.step))</span>

        <span class="s4"># TODO(GH#41493): we cannot just do</span>
        <span class="s4">#  type(self._data)(res_i8.values, dtype=self.dtype, freq=new_freq)</span>
        <span class="s4"># because test_setops_preserve_freq fails with _validate_frequency raising.</span>
        <span class="s4"># This raising is incorrect, as 'on_freq' is incorrect. This will</span>
        <span class="s4"># be fixed by GH#41493</span>
        <span class="s1">res_values = res_i8.values.view(self._data._ndarray.dtype)</span>
        <span class="s1">result = type(self._data)._simple_new(</span>
            <span class="s4"># error: Argument &quot;dtype&quot; to &quot;_simple_new&quot; of &quot;DatetimeArray&quot; has</span>
            <span class="s4"># incompatible type &quot;Union[dtype[Any], ExtensionDtype]&quot;; expected</span>
            <span class="s4"># &quot;Union[dtype[datetime64], DatetimeTZDtype]&quot;</span>
            <span class="s1">res_values</span><span class="s2">,</span>
            <span class="s1">dtype=self.dtype</span><span class="s2">,  </span><span class="s4"># type: ignore[arg-type]</span>
            <span class="s1">freq=new_freq</span><span class="s2">,  </span><span class="s4"># type: ignore[arg-type]</span>
        <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">cast(</span><span class="s5">&quot;Self&quot;</span><span class="s2">, </span><span class="s1">self._wrap_setop_result(other</span><span class="s2">, </span><span class="s1">result))</span>

    <span class="s2">def </span><span class="s1">_range_intersect(self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">sort) -&gt; Self:</span>
        <span class="s4"># Dispatch to RangeIndex intersection logic.</span>
        <span class="s1">left = self._as_range_index</span>
        <span class="s1">right = other._as_range_index</span>
        <span class="s1">res_i8 = left.intersection(right</span><span class="s2">, </span><span class="s1">sort=sort)</span>
        <span class="s2">return </span><span class="s1">self._wrap_range_setop(other</span><span class="s2">, </span><span class="s1">res_i8)</span>

    <span class="s2">def </span><span class="s1">_range_union(self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">sort) -&gt; Self:</span>
        <span class="s4"># Dispatch to RangeIndex union logic.</span>
        <span class="s1">left = self._as_range_index</span>
        <span class="s1">right = other._as_range_index</span>
        <span class="s1">res_i8 = left.union(right</span><span class="s2">, </span><span class="s1">sort=sort)</span>
        <span class="s2">return </span><span class="s1">self._wrap_range_setop(other</span><span class="s2">, </span><span class="s1">res_i8)</span>

    <span class="s2">def </span><span class="s1">_intersection(self</span><span class="s2">, </span><span class="s1">other: Index</span><span class="s2">, </span><span class="s1">sort: bool = </span><span class="s2">False</span><span class="s1">) -&gt; Index:</span>
        <span class="s0">&quot;&quot;&quot; 
        intersection specialized to the case with matching dtypes and both non-empty. 
        &quot;&quot;&quot;</span>
        <span class="s1">other = cast(</span><span class="s5">&quot;DatetimeTimedeltaMixin&quot;</span><span class="s2">, </span><span class="s1">other)</span>

        <span class="s2">if </span><span class="s1">self._can_range_setop(other):</span>
            <span class="s2">return </span><span class="s1">self._range_intersect(other</span><span class="s2">, </span><span class="s1">sort=sort)</span>

        <span class="s2">if not </span><span class="s1">self._can_fast_intersect(other):</span>
            <span class="s1">result = Index._intersection(self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">sort=sort)</span>
            <span class="s4"># We need to invalidate the freq because Index._intersection</span>
            <span class="s4">#  uses _shallow_copy on a view of self._data, which will preserve</span>
            <span class="s4">#  self.freq if we're not careful.</span>
            <span class="s4"># At this point we should have result.dtype == self.dtype</span>
            <span class="s4">#  and type(result) is type(self._data)</span>
            <span class="s1">result = self._wrap_setop_result(other</span><span class="s2">, </span><span class="s1">result)</span>
            <span class="s2">return </span><span class="s1">result._with_freq(</span><span class="s2">None</span><span class="s1">)._with_freq(</span><span class="s5">&quot;infer&quot;</span><span class="s1">)</span>

        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._fast_intersect(other</span><span class="s2">, </span><span class="s1">sort)</span>

    <span class="s2">def </span><span class="s1">_fast_intersect(self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">sort):</span>
        <span class="s4"># to make our life easier, &quot;sort&quot; the two ranges</span>
        <span class="s2">if </span><span class="s1">self[</span><span class="s3">0</span><span class="s1">] &lt;= other[</span><span class="s3">0</span><span class="s1">]:</span>
            <span class="s1">left</span><span class="s2">, </span><span class="s1">right = self</span><span class="s2">, </span><span class="s1">other</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">left</span><span class="s2">, </span><span class="s1">right = other</span><span class="s2">, </span><span class="s1">self</span>

        <span class="s4"># after sorting, the intersection always starts with the right index</span>
        <span class="s4"># and ends with the index of which the last elements is smallest</span>
        <span class="s1">end = min(left[-</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">right[-</span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">start = right[</span><span class="s3">0</span><span class="s1">]</span>

        <span class="s2">if </span><span class="s1">end &lt; start:</span>
            <span class="s1">result = self[:</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">lslice = slice(*left.slice_locs(start</span><span class="s2">, </span><span class="s1">end))</span>
            <span class="s1">result = left._values[lslice]</span>

        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">_can_fast_intersect(self</span><span class="s2">, </span><span class="s1">other: Self) -&gt; bool:</span>
        <span class="s4"># Note: we only get here with len(self) &gt; 0 and len(other) &gt; 0</span>
        <span class="s2">if </span><span class="s1">self.freq </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return False</span>

        <span class="s2">elif </span><span class="s1">other.freq != self.freq:</span>
            <span class="s2">return False</span>

        <span class="s2">elif not </span><span class="s1">self.is_monotonic_increasing:</span>
            <span class="s4"># Because freq is not None, we must then be monotonic decreasing</span>
            <span class="s2">return False</span>

        <span class="s4"># this along with matching freqs ensure that we &quot;line up&quot;,</span>
        <span class="s4">#  so intersection will preserve freq</span>
        <span class="s4"># Note we are assuming away Ticks, as those go through _range_intersect</span>
        <span class="s4"># GH#42104</span>
        <span class="s2">return </span><span class="s1">self.freq.n == </span><span class="s3">1</span>

    <span class="s2">def </span><span class="s1">_can_fast_union(self</span><span class="s2">, </span><span class="s1">other: Self) -&gt; bool:</span>
        <span class="s4"># Assumes that type(self) == type(other), as per the annotation</span>
        <span class="s4"># The ability to fast_union also implies that `freq` should be</span>
        <span class="s4">#  retained on union.</span>
        <span class="s1">freq = self.freq</span>

        <span class="s2">if </span><span class="s1">freq </span><span class="s2">is None or </span><span class="s1">freq != other.freq:</span>
            <span class="s2">return False</span>

        <span class="s2">if not </span><span class="s1">self.is_monotonic_increasing:</span>
            <span class="s4"># Because freq is not None, we must then be monotonic decreasing</span>
            <span class="s4"># TODO: do union on the reversed indexes?</span>
            <span class="s2">return False</span>

        <span class="s2">if </span><span class="s1">len(self) == </span><span class="s3">0 </span><span class="s2">or </span><span class="s1">len(other) == </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s4"># only reached via union_many</span>
            <span class="s2">return True</span>

        <span class="s4"># to make our life easier, &quot;sort&quot; the two ranges</span>
        <span class="s2">if </span><span class="s1">self[</span><span class="s3">0</span><span class="s1">] &lt;= other[</span><span class="s3">0</span><span class="s1">]:</span>
            <span class="s1">left</span><span class="s2">, </span><span class="s1">right = self</span><span class="s2">, </span><span class="s1">other</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">left</span><span class="s2">, </span><span class="s1">right = other</span><span class="s2">, </span><span class="s1">self</span>

        <span class="s1">right_start = right[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">left_end = left[-</span><span class="s3">1</span><span class="s1">]</span>

        <span class="s4"># Only need to &quot;adjoin&quot;, not overlap</span>
        <span class="s2">return </span><span class="s1">(right_start == left_end + freq) </span><span class="s2">or </span><span class="s1">right_start </span><span class="s2">in </span><span class="s1">left</span>

    <span class="s2">def </span><span class="s1">_fast_union(self</span><span class="s2">, </span><span class="s1">other: Self</span><span class="s2">, </span><span class="s1">sort=</span><span class="s2">None</span><span class="s1">) -&gt; Self:</span>
        <span class="s4"># Caller is responsible for ensuring self and other are non-empty</span>

        <span class="s4"># to make our life easier, &quot;sort&quot; the two ranges</span>
        <span class="s2">if </span><span class="s1">self[</span><span class="s3">0</span><span class="s1">] &lt;= other[</span><span class="s3">0</span><span class="s1">]:</span>
            <span class="s1">left</span><span class="s2">, </span><span class="s1">right = self</span><span class="s2">, </span><span class="s1">other</span>
        <span class="s2">elif </span><span class="s1">sort </span><span class="s2">is False</span><span class="s1">:</span>
            <span class="s4"># TDIs are not in the &quot;correct&quot; order and we don't want</span>
            <span class="s4">#  to sort but want to remove overlaps</span>
            <span class="s1">left</span><span class="s2">, </span><span class="s1">right = self</span><span class="s2">, </span><span class="s1">other</span>
            <span class="s1">left_start = left[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s1">loc = right.searchsorted(left_start</span><span class="s2">, </span><span class="s1">side=</span><span class="s5">&quot;left&quot;</span><span class="s1">)</span>
            <span class="s1">right_chunk = right._values[:loc]</span>
            <span class="s1">dates = concat_compat((left._values</span><span class="s2">, </span><span class="s1">right_chunk))</span>
            <span class="s1">result = type(self)._simple_new(dates</span><span class="s2">, </span><span class="s1">name=self.name)</span>
            <span class="s2">return </span><span class="s1">result</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">left</span><span class="s2">, </span><span class="s1">right = other</span><span class="s2">, </span><span class="s1">self</span>

        <span class="s1">left_end = left[-</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s1">right_end = right[-</span><span class="s3">1</span><span class="s1">]</span>

        <span class="s4"># concatenate</span>
        <span class="s2">if </span><span class="s1">left_end &lt; right_end:</span>
            <span class="s1">loc = right.searchsorted(left_end</span><span class="s2">, </span><span class="s1">side=</span><span class="s5">&quot;right&quot;</span><span class="s1">)</span>
            <span class="s1">right_chunk = right._values[loc:]</span>
            <span class="s1">dates = concat_compat([left._values</span><span class="s2">, </span><span class="s1">right_chunk])</span>
            <span class="s4"># The can_fast_union check ensures that the result.freq</span>
            <span class="s4">#  should match self.freq</span>
            <span class="s1">dates = type(self._data)(dates</span><span class="s2">, </span><span class="s1">freq=self.freq)</span>
            <span class="s1">result = type(self)._simple_new(dates)</span>
            <span class="s2">return </span><span class="s1">result</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">left</span>

    <span class="s2">def </span><span class="s1">_union(self</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">sort):</span>
        <span class="s4"># We are called by `union`, which is responsible for this validation</span>
        <span class="s2">assert </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">type(self))</span>
        <span class="s2">assert </span><span class="s1">self.dtype == other.dtype</span>

        <span class="s2">if </span><span class="s1">self._can_range_setop(other):</span>
            <span class="s2">return </span><span class="s1">self._range_union(other</span><span class="s2">, </span><span class="s1">sort=sort)</span>

        <span class="s2">if </span><span class="s1">self._can_fast_union(other):</span>
            <span class="s1">result = self._fast_union(other</span><span class="s2">, </span><span class="s1">sort=sort)</span>
            <span class="s4"># in the case with sort=None, the _can_fast_union check ensures</span>
            <span class="s4">#  that result.freq == self.freq</span>
            <span class="s2">return </span><span class="s1">result</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">super()._union(other</span><span class="s2">, </span><span class="s1">sort)._with_freq(</span><span class="s5">&quot;infer&quot;</span><span class="s1">)</span>

    <span class="s4"># --------------------------------------------------------------------</span>
    <span class="s4"># Join Methods</span>

    <span class="s2">def </span><span class="s1">_get_join_freq(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s0">&quot;&quot;&quot; 
        Get the freq to attach to the result of a join operation. 
        &quot;&quot;&quot;</span>
        <span class="s1">freq = </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">self._can_fast_union(other):</span>
            <span class="s1">freq = self.freq</span>
        <span class="s2">return </span><span class="s1">freq</span>

    <span class="s2">def </span><span class="s1">_wrap_joined_index(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">joined</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">lidx: npt.NDArray[np.intp]</span><span class="s2">, </span><span class="s1">ridx: npt.NDArray[np.intp]</span>
    <span class="s1">):</span>
        <span class="s2">assert </span><span class="s1">other.dtype == self.dtype</span><span class="s2">, </span><span class="s1">(other.dtype</span><span class="s2">, </span><span class="s1">self.dtype)</span>
        <span class="s1">result = super()._wrap_joined_index(joined</span><span class="s2">, </span><span class="s1">other</span><span class="s2">, </span><span class="s1">lidx</span><span class="s2">, </span><span class="s1">ridx)</span>
        <span class="s1">result._data._freq = self._get_join_freq(other)</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">_get_engine_target(self) -&gt; np.ndarray:</span>
        <span class="s4"># engine methods and libjoin methods need dt64/td64 values cast to i8</span>
        <span class="s2">return </span><span class="s1">self._data._ndarray.view(</span><span class="s5">&quot;i8&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_from_join_target(self</span><span class="s2">, </span><span class="s1">result: np.ndarray):</span>
        <span class="s4"># view e.g. i8 back to M8[ns]</span>
        <span class="s1">result = result.view(self._data._ndarray.dtype)</span>
        <span class="s2">return </span><span class="s1">self._data._from_backing_data(result)</span>

    <span class="s4"># --------------------------------------------------------------------</span>
    <span class="s4"># List-like Methods</span>

    <span class="s2">def </span><span class="s1">_get_delete_freq(self</span><span class="s2">, </span><span class="s1">loc: int | slice | Sequence[int]):</span>
        <span class="s0">&quot;&quot;&quot; 
        Find the `freq` for self.delete(loc). 
        &quot;&quot;&quot;</span>
        <span class="s1">freq = </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">self.freq </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">is_integer(loc):</span>
                <span class="s2">if </span><span class="s1">loc </span><span class="s2">in </span><span class="s1">(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">-len(self)</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s2">, </span><span class="s1">len(self) - </span><span class="s3">1</span><span class="s1">):</span>
                    <span class="s1">freq = self.freq</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">is_list_like(loc):</span>
                    <span class="s4"># error: Incompatible types in assignment (expression has</span>
                    <span class="s4"># type &quot;Union[slice, ndarray]&quot;, variable has type</span>
                    <span class="s4"># &quot;Union[int, slice, Sequence[int]]&quot;)</span>
                    <span class="s1">loc = lib.maybe_indices_to_slice(  </span><span class="s4"># type: ignore[assignment]</span>
                        <span class="s1">np.asarray(loc</span><span class="s2">, </span><span class="s1">dtype=np.intp)</span><span class="s2">, </span><span class="s1">len(self)</span>
                    <span class="s1">)</span>
                <span class="s2">if </span><span class="s1">isinstance(loc</span><span class="s2">, </span><span class="s1">slice) </span><span class="s2">and </span><span class="s1">loc.step </span><span class="s2">in </span><span class="s1">(</span><span class="s3">1</span><span class="s2">, None</span><span class="s1">):</span>
                    <span class="s2">if </span><span class="s1">loc.start </span><span class="s2">in </span><span class="s1">(</span><span class="s3">0</span><span class="s2">, None</span><span class="s1">) </span><span class="s2">or </span><span class="s1">loc.stop </span><span class="s2">in </span><span class="s1">(len(self)</span><span class="s2">, None</span><span class="s1">):</span>
                        <span class="s1">freq = self.freq</span>
        <span class="s2">return </span><span class="s1">freq</span>

    <span class="s2">def </span><span class="s1">_get_insert_freq(self</span><span class="s2">, </span><span class="s1">loc: int</span><span class="s2">, </span><span class="s1">item):</span>
        <span class="s0">&quot;&quot;&quot; 
        Find the `freq` for self.insert(loc, item). 
        &quot;&quot;&quot;</span>
        <span class="s1">value = self._data._validate_scalar(item)</span>
        <span class="s1">item = self._data._box_func(value)</span>

        <span class="s1">freq = </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">self.freq </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s4"># freq can be preserved on edge cases</span>
            <span class="s2">if </span><span class="s1">self.size:</span>
                <span class="s2">if </span><span class="s1">item </span><span class="s2">is </span><span class="s1">NaT:</span>
                    <span class="s2">pass</span>
                <span class="s2">elif </span><span class="s1">loc </span><span class="s2">in </span><span class="s1">(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">-len(self)) </span><span class="s2">and </span><span class="s1">item + self.freq == self[</span><span class="s3">0</span><span class="s1">]:</span>
                    <span class="s1">freq = self.freq</span>
                <span class="s2">elif </span><span class="s1">(loc == len(self)) </span><span class="s2">and </span><span class="s1">item - self.freq == self[-</span><span class="s3">1</span><span class="s1">]:</span>
                    <span class="s1">freq = self.freq</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s4"># Adding a single item to an empty index may preserve freq</span>
                <span class="s2">if </span><span class="s1">isinstance(self.freq</span><span class="s2">, </span><span class="s1">Tick):</span>
                    <span class="s4"># all TimedeltaIndex cases go through here; is_on_offset</span>
                    <span class="s4">#  would raise TypeError</span>
                    <span class="s1">freq = self.freq</span>
                <span class="s2">elif </span><span class="s1">self.freq.is_on_offset(item):</span>
                    <span class="s1">freq = self.freq</span>
        <span class="s2">return </span><span class="s1">freq</span>

    <span class="s1">@doc(NDArrayBackedExtensionIndex.delete)</span>
    <span class="s2">def </span><span class="s1">delete(self</span><span class="s2">, </span><span class="s1">loc) -&gt; Self:</span>
        <span class="s1">result = super().delete(loc)</span>
        <span class="s1">result._data._freq = self._get_delete_freq(loc)</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s1">@doc(NDArrayBackedExtensionIndex.insert)</span>
    <span class="s2">def </span><span class="s1">insert(self</span><span class="s2">, </span><span class="s1">loc: int</span><span class="s2">, </span><span class="s1">item):</span>
        <span class="s1">result = super().insert(loc</span><span class="s2">, </span><span class="s1">item)</span>
        <span class="s2">if </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">type(self)):</span>
            <span class="s4"># i.e. parent class method did not cast</span>
            <span class="s1">result._data._freq = self._get_insert_freq(loc</span><span class="s2">, </span><span class="s1">item)</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s4"># --------------------------------------------------------------------</span>
    <span class="s4"># NDArray-Like Methods</span>

    <span class="s1">@Appender(_index_shared_docs[</span><span class="s5">&quot;take&quot;</span><span class="s1">] % _index_doc_kwargs)</span>
    <span class="s2">def </span><span class="s1">take(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">indices</span><span class="s2">,</span>
        <span class="s1">axis: Axis = </span><span class="s3">0</span><span class="s2">,</span>
        <span class="s1">allow_fill: bool = </span><span class="s2">True,</span>
        <span class="s1">fill_value=</span><span class="s2">None,</span>
        <span class="s1">**kwargs</span><span class="s2">,</span>
    <span class="s1">) -&gt; Self:</span>
        <span class="s1">nv.validate_take(()</span><span class="s2">, </span><span class="s1">kwargs)</span>
        <span class="s1">indices = np.asarray(indices</span><span class="s2">, </span><span class="s1">dtype=np.intp)</span>

        <span class="s1">result = NDArrayBackedExtensionIndex.take(</span>
            <span class="s1">self</span><span class="s2">, </span><span class="s1">indices</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">allow_fill</span><span class="s2">, </span><span class="s1">fill_value</span><span class="s2">, </span><span class="s1">**kwargs</span>
        <span class="s1">)</span>

        <span class="s1">maybe_slice = lib.maybe_indices_to_slice(indices</span><span class="s2">, </span><span class="s1">len(self))</span>
        <span class="s2">if </span><span class="s1">isinstance(maybe_slice</span><span class="s2">, </span><span class="s1">slice):</span>
            <span class="s1">freq = self._data._get_getitem_freq(maybe_slice)</span>
            <span class="s1">result._data._freq = freq</span>
        <span class="s2">return </span><span class="s1">result</span>
</pre>
</body>
</html>