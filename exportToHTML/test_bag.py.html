<html>
<head>
<title>test_bag.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
.s5 { color: #629755; font-style: italic;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_bag.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">import </span><span class="s1">gc</span>
<span class="s0">import </span><span class="s1">math</span>
<span class="s0">import </span><span class="s1">os</span>
<span class="s0">import </span><span class="s1">random</span>
<span class="s0">import </span><span class="s1">warnings</span>
<span class="s0">import </span><span class="s1">weakref</span>
<span class="s0">from </span><span class="s1">bz2 </span><span class="s0">import </span><span class="s1">BZ2File</span>
<span class="s0">from </span><span class="s1">collections.abc </span><span class="s0">import </span><span class="s1">Iterator</span>
<span class="s0">from </span><span class="s1">concurrent.futures </span><span class="s0">import </span><span class="s1">ProcessPoolExecutor</span>
<span class="s0">from </span><span class="s1">gzip </span><span class="s0">import </span><span class="s1">GzipFile</span>
<span class="s0">from </span><span class="s1">itertools </span><span class="s0">import </span><span class="s1">repeat</span>

<span class="s0">import </span><span class="s1">partd</span>
<span class="s0">import </span><span class="s1">pytest</span>
<span class="s0">from </span><span class="s1">tlz </span><span class="s0">import </span><span class="s1">groupby</span><span class="s0">, </span><span class="s1">identity</span><span class="s0">, </span><span class="s1">join</span><span class="s0">, </span><span class="s1">merge</span><span class="s0">, </span><span class="s1">pluck</span><span class="s0">, </span><span class="s1">unique</span><span class="s0">, </span><span class="s1">valmap</span>

<span class="s0">import </span><span class="s1">dask</span>
<span class="s0">import </span><span class="s1">dask.bag </span><span class="s0">as </span><span class="s1">db</span>
<span class="s0">from </span><span class="s1">dask.bag.core </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">Bag</span><span class="s0">,</span>
    <span class="s1">collect</span><span class="s0">,</span>
    <span class="s1">from_delayed</span><span class="s0">,</span>
    <span class="s1">inline_singleton_lists</span><span class="s0">,</span>
    <span class="s1">lazify</span><span class="s0">,</span>
    <span class="s1">lazify_task</span><span class="s0">,</span>
    <span class="s1">optimize</span><span class="s0">,</span>
    <span class="s1">partition</span><span class="s0">,</span>
    <span class="s1">reduceby</span><span class="s0">,</span>
    <span class="s1">reify</span><span class="s0">,</span>
    <span class="s1">total_mem_usage</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">dask.bag.utils </span><span class="s0">import </span><span class="s1">assert_eq</span>
<span class="s0">from </span><span class="s1">dask.blockwise </span><span class="s0">import </span><span class="s1">Blockwise</span>
<span class="s0">from </span><span class="s1">dask.delayed </span><span class="s0">import </span><span class="s1">Delayed</span>
<span class="s0">from </span><span class="s1">dask.typing </span><span class="s0">import </span><span class="s1">Graph</span>
<span class="s0">from </span><span class="s1">dask.utils </span><span class="s0">import </span><span class="s1">filetexts</span><span class="s0">, </span><span class="s1">tmpdir</span><span class="s0">, </span><span class="s1">tmpfile</span>
<span class="s0">from </span><span class="s1">dask.utils_test </span><span class="s0">import </span><span class="s1">add</span><span class="s0">, </span><span class="s1">hlg_layer</span><span class="s0">, </span><span class="s1">hlg_layer_topological</span><span class="s0">, </span><span class="s1">inc</span>

<span class="s1">dsk: Graph = {(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s3">0</span><span class="s1">): (range</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s1">): (range</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s3">2</span><span class="s1">): (range</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)}</span>

<span class="s1">L = list(range(</span><span class="s3">5</span><span class="s1">)) * </span><span class="s3">3</span>

<span class="s1">b = Bag(dsk</span><span class="s0">, </span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">iseven(x):</span>
    <span class="s0">return </span><span class="s1">x % </span><span class="s3">2 </span><span class="s1">== </span><span class="s3">0</span>


<span class="s0">def </span><span class="s1">isodd(x):</span>
    <span class="s0">return </span><span class="s1">x % </span><span class="s3">2 </span><span class="s1">== </span><span class="s3">1</span>


<span class="s0">def </span><span class="s1">test_Bag():</span>
    <span class="s0">assert </span><span class="s1">b.name == </span><span class="s2">&quot;x&quot;</span>
    <span class="s0">assert </span><span class="s1">b.npartitions == </span><span class="s3">3</span>


<span class="s0">def </span><span class="s1">test_keys():</span>
    <span class="s0">assert </span><span class="s1">b.__dask_keys__() == sorted(dsk.keys())</span>


<span class="s0">def </span><span class="s1">test_bag_groupby_pure_hash():</span>
    <span class="s4"># https://github.com/dask/dask/issues/6640</span>
    <span class="s1">result = b.groupby(iseven).compute()</span>
    <span class="s0">assert </span><span class="s1">result == [(</span><span class="s0">False, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s1">] * </span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s0">True, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">4</span><span class="s1">] * </span><span class="s3">3</span><span class="s1">)]</span>


<span class="s0">def </span><span class="s1">test_bag_groupby_normal_hash():</span>
    <span class="s4"># https://github.com/dask/dask/issues/6640</span>
    <span class="s1">result = b.groupby(</span><span class="s0">lambda </span><span class="s1">x: </span><span class="s2">&quot;even&quot; </span><span class="s0">if </span><span class="s1">iseven(x) </span><span class="s0">else </span><span class="s2">&quot;odd&quot;</span><span class="s1">).compute()</span>
    <span class="s0">assert </span><span class="s1">len(result) == </span><span class="s3">2</span>
    <span class="s0">assert </span><span class="s1">(</span><span class="s2">&quot;odd&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s1">] * </span><span class="s3">3</span><span class="s1">) </span><span class="s0">in </span><span class="s1">result</span>
    <span class="s0">assert </span><span class="s1">(</span><span class="s2">&quot;even&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">4</span><span class="s1">] * </span><span class="s3">3</span><span class="s1">) </span><span class="s0">in </span><span class="s1">result</span>


<span class="s0">def </span><span class="s1">test_bag_map():</span>
    <span class="s1">b = db.from_sequence(range(</span><span class="s3">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">10</span><span class="s1">)</span>
    <span class="s1">b2 = db.from_sequence(range(</span><span class="s3">100</span><span class="s0">, </span><span class="s3">200</span><span class="s1">)</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">10</span><span class="s1">)</span>
    <span class="s1">x = b.compute()</span>
    <span class="s1">x2 = b2.compute()</span>

    <span class="s0">def </span><span class="s1">myadd(a=</span><span class="s3">1</span><span class="s0">, </span><span class="s1">b=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">c=</span><span class="s3">3</span><span class="s1">):</span>
        <span class="s0">return </span><span class="s1">a + b + c</span>

    <span class="s1">assert_eq(db.map(myadd</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, </span><span class="s1">list(map(myadd</span><span class="s0">, </span><span class="s1">x)))</span>
    <span class="s1">assert_eq(db.map(myadd</span><span class="s0">, </span><span class="s1">a=b)</span><span class="s0">, </span><span class="s1">list(map(myadd</span><span class="s0">, </span><span class="s1">x)))</span>
    <span class="s1">assert_eq(db.map(myadd</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">b2)</span><span class="s0">, </span><span class="s1">list(map(myadd</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">x2)))</span>
    <span class="s1">assert_eq(db.map(myadd</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[myadd(i</span><span class="s0">, </span><span class="s3">10</span><span class="s1">) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">x])</span>
    <span class="s1">assert_eq(db.map(myadd</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s1">b=b)</span><span class="s0">, </span><span class="s1">[myadd(</span><span class="s3">10</span><span class="s0">, </span><span class="s1">b=i) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">x])</span>

    <span class="s1">sol = [myadd(i</span><span class="s0">, </span><span class="s1">b=j</span><span class="s0">, </span><span class="s1">c=</span><span class="s3">100</span><span class="s1">) </span><span class="s0">for </span><span class="s1">(i</span><span class="s0">, </span><span class="s1">j) </span><span class="s0">in </span><span class="s1">zip(x</span><span class="s0">, </span><span class="s1">x2)]</span>
    <span class="s1">assert_eq(db.map(myadd</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">b=b2</span><span class="s0">, </span><span class="s1">c=</span><span class="s3">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">sol)</span>

    <span class="s1">sol = [myadd(i</span><span class="s0">, </span><span class="s1">c=</span><span class="s3">100</span><span class="s1">) </span><span class="s0">for </span><span class="s1">(i</span><span class="s0">, </span><span class="s1">j) </span><span class="s0">in </span><span class="s1">zip(x</span><span class="s0">, </span><span class="s1">x2)]</span>
    <span class="s1">assert_eq(db.map(myadd</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">c=</span><span class="s3">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">sol)</span>

    <span class="s1">x_sum = sum(x)</span>
    <span class="s1">sol = [myadd(x_sum</span><span class="s0">, </span><span class="s1">b=i</span><span class="s0">, </span><span class="s1">c=</span><span class="s3">100</span><span class="s1">) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">x2]</span>
    <span class="s1">assert_eq(db.map(myadd</span><span class="s0">, </span><span class="s1">b.sum()</span><span class="s0">, </span><span class="s1">b=b2</span><span class="s0">, </span><span class="s1">c=</span><span class="s3">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">sol)</span>

    <span class="s1">sol = [myadd(i</span><span class="s0">, </span><span class="s1">b=x_sum</span><span class="s0">, </span><span class="s1">c=</span><span class="s3">100</span><span class="s1">) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">x2]</span>
    <span class="s1">assert_eq(db.map(myadd</span><span class="s0">, </span><span class="s1">b2</span><span class="s0">, </span><span class="s1">b.sum()</span><span class="s0">, </span><span class="s1">c=</span><span class="s3">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">sol)</span>

    <span class="s1">sol = [myadd(a=</span><span class="s3">100</span><span class="s0">, </span><span class="s1">b=x_sum</span><span class="s0">, </span><span class="s1">c=i) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">x2]</span>
    <span class="s1">assert_eq(db.map(myadd</span><span class="s0">, </span><span class="s1">a=</span><span class="s3">100</span><span class="s0">, </span><span class="s1">b=b.sum()</span><span class="s0">, </span><span class="s1">c=b2)</span><span class="s0">, </span><span class="s1">sol)</span>

    <span class="s1">a = dask.delayed(</span><span class="s3">10</span><span class="s1">)</span>
    <span class="s1">assert_eq(db.map(myadd</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">a)</span><span class="s0">, </span><span class="s1">[myadd(i</span><span class="s0">, </span><span class="s3">10</span><span class="s1">) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">x])</span>
    <span class="s1">assert_eq(db.map(myadd</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">b=a)</span><span class="s0">, </span><span class="s1">[myadd(i</span><span class="s0">, </span><span class="s1">b=</span><span class="s3">10</span><span class="s1">) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">x])</span>

    <span class="s4"># Mispatched npartitions</span>
    <span class="s1">fewer_parts = db.from_sequence(range(</span><span class="s3">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">5</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">db.map(myadd</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">fewer_parts)</span>

    <span class="s4"># No bags</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">db.map(myadd</span><span class="s0">, </span><span class="s1">b.sum()</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>

    <span class="s4"># Unequal partitioning</span>
    <span class="s1">unequal = db.from_sequence(range(</span><span class="s3">110</span><span class="s1">)</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">10</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">db.map(myadd</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">unequal</span><span class="s0">, </span><span class="s1">c=b2).compute()</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">db.map(myadd</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">b=unequal</span><span class="s0">, </span><span class="s1">c=b2).compute()</span>


<span class="s0">def </span><span class="s1">test_map_method():</span>
    <span class="s1">b = db.from_sequence(range(</span><span class="s3">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">10</span><span class="s1">)</span>
    <span class="s1">b2 = db.from_sequence(range(</span><span class="s3">100</span><span class="s0">, </span><span class="s3">200</span><span class="s1">)</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">10</span><span class="s1">)</span>
    <span class="s1">x = b.compute()</span>
    <span class="s1">x2 = b2.compute()</span>

    <span class="s0">def </span><span class="s1">myadd(a</span><span class="s0">, </span><span class="s1">b=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">c=</span><span class="s3">3</span><span class="s1">):</span>
        <span class="s0">return </span><span class="s1">a + b + c</span>

    <span class="s0">assert </span><span class="s1">b.map(myadd).compute() == list(map(myadd</span><span class="s0">, </span><span class="s1">x))</span>
    <span class="s0">assert </span><span class="s1">b.map(myadd</span><span class="s0">, </span><span class="s1">b2).compute() == list(map(myadd</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">x2))</span>
    <span class="s0">assert </span><span class="s1">b.map(myadd</span><span class="s0">, </span><span class="s3">10</span><span class="s1">).compute() == [myadd(i</span><span class="s0">, </span><span class="s3">10</span><span class="s1">) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">x]</span>
    <span class="s0">assert </span><span class="s1">b.map(myadd</span><span class="s0">, </span><span class="s1">b=</span><span class="s3">10</span><span class="s1">).compute() == [myadd(i</span><span class="s0">, </span><span class="s1">b=</span><span class="s3">10</span><span class="s1">) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">x]</span>
    <span class="s0">assert </span><span class="s1">b.map(myadd</span><span class="s0">, </span><span class="s1">b2</span><span class="s0">, </span><span class="s1">c=</span><span class="s3">10</span><span class="s1">).compute() == [</span>
        <span class="s1">myadd(i</span><span class="s0">, </span><span class="s1">j</span><span class="s0">, </span><span class="s3">10</span><span class="s1">) </span><span class="s0">for </span><span class="s1">(i</span><span class="s0">, </span><span class="s1">j) </span><span class="s0">in </span><span class="s1">zip(x</span><span class="s0">, </span><span class="s1">x2)</span>
    <span class="s1">]</span>
    <span class="s1">x_sum = sum(x)</span>
    <span class="s0">assert </span><span class="s1">b.map(myadd</span><span class="s0">, </span><span class="s1">b.sum()</span><span class="s0">, </span><span class="s1">c=</span><span class="s3">10</span><span class="s1">).compute() == [myadd(i</span><span class="s0">, </span><span class="s1">x_sum</span><span class="s0">, </span><span class="s3">10</span><span class="s1">) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">x]</span>


<span class="s0">def </span><span class="s1">test_starmap():</span>
    <span class="s1">data = [(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">7</span><span class="s0">, </span><span class="s3">8</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">9</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)]</span>
    <span class="s1">b = db.from_sequence(data</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">2</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">myadd(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">c=</span><span class="s3">0</span><span class="s1">):</span>
        <span class="s0">return </span><span class="s1">a + b + c</span>

    <span class="s0">assert </span><span class="s1">b.starmap(myadd).compute() == [myadd(*a) </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">data]</span>
    <span class="s0">assert </span><span class="s1">b.starmap(myadd</span><span class="s0">, </span><span class="s1">c=</span><span class="s3">10</span><span class="s1">).compute() == [myadd(*a</span><span class="s0">, </span><span class="s1">c=</span><span class="s3">10</span><span class="s1">) </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">data]</span>
    <span class="s1">max_second = b.pluck(</span><span class="s3">1</span><span class="s1">).max()</span>
    <span class="s0">assert </span><span class="s1">b.starmap(myadd</span><span class="s0">, </span><span class="s1">c=max_second).compute() == [</span>
        <span class="s1">myadd(*a</span><span class="s0">, </span><span class="s1">c=max_second.compute()) </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">data</span>
    <span class="s1">]</span>
    <span class="s1">c = dask.delayed(</span><span class="s3">10</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">b.starmap(myadd</span><span class="s0">, </span><span class="s1">c=c).compute() == [myadd(*a</span><span class="s0">, </span><span class="s1">c=</span><span class="s3">10</span><span class="s1">) </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">data]</span>


<span class="s0">def </span><span class="s1">test_filter():</span>
    <span class="s1">c = b.filter(iseven)</span>
    <span class="s1">expected = merge(</span>
        <span class="s1">dsk</span><span class="s0">,</span>
        <span class="s1">{</span>
            <span class="s1">(c.name</span><span class="s0">, </span><span class="s1">i): (reify</span><span class="s0">, </span><span class="s1">(filter</span><span class="s0">, </span><span class="s1">iseven</span><span class="s0">, </span><span class="s1">(b.name</span><span class="s0">, </span><span class="s1">i)))</span>
            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(b.npartitions)</span>
        <span class="s1">}</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">c.dask == expected</span>
    <span class="s0">assert </span><span class="s1">c.name == b.filter(iseven).name</span>


<span class="s0">def </span><span class="s1">test_remove():</span>
    <span class="s1">f = </span><span class="s0">lambda </span><span class="s1">x: x % </span><span class="s3">2 </span><span class="s1">== </span><span class="s3">0</span>
    <span class="s1">c = b.remove(f)</span>
    <span class="s0">assert </span><span class="s1">list(c) == [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s1">] * </span><span class="s3">3</span>
    <span class="s0">assert </span><span class="s1">c.name == b.remove(f).name</span>


<span class="s0">def </span><span class="s1">test_iter():</span>
    <span class="s0">assert </span><span class="s1">sorted(list(b)) == sorted(L)</span>
    <span class="s0">assert </span><span class="s1">sorted(list(b.map(inc))) == sorted(list(range(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">6</span><span class="s1">)) * </span><span class="s3">3</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;func&quot;</span><span class="s0">, </span><span class="s1">[str</span><span class="s0">, </span><span class="s1">repr])</span>
<span class="s0">def </span><span class="s1">test_repr(func):</span>
    <span class="s0">assert </span><span class="s1">str(b.npartitions) </span><span class="s0">in </span><span class="s1">func(b)</span>
    <span class="s0">assert </span><span class="s1">b.name[:</span><span class="s3">5</span><span class="s1">] </span><span class="s0">in </span><span class="s1">func(b)</span>

    <span class="s0">assert </span><span class="s2">&quot;from_sequence&quot; </span><span class="s0">in </span><span class="s1">func(db.from_sequence(range(</span><span class="s3">5</span><span class="s1">)))</span>


<span class="s0">def </span><span class="s1">test_pluck():</span>
    <span class="s1">d = {(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s3">0</span><span class="s1">): [(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">20</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s1">): [(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">30</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">4</span><span class="s0">, </span><span class="s3">40</span><span class="s1">)]}</span>
    <span class="s1">b = Bag(d</span><span class="s0">, </span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">set(b.pluck(</span><span class="s3">0</span><span class="s1">)) == {</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">}</span>
    <span class="s0">assert </span><span class="s1">set(b.pluck(</span><span class="s3">1</span><span class="s1">)) == {</span><span class="s3">10</span><span class="s0">, </span><span class="s3">20</span><span class="s0">, </span><span class="s3">30</span><span class="s0">, </span><span class="s3">40</span><span class="s1">}</span>
    <span class="s0">assert </span><span class="s1">set(b.pluck([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">])) == {(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">20</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">30</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">40</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)}</span>
    <span class="s0">assert </span><span class="s1">b.pluck([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]).name == b.pluck([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]).name</span>


<span class="s0">def </span><span class="s1">test_pluck_with_default():</span>
    <span class="s1">b = db.from_sequence([</span><span class="s2">&quot;Hello&quot;</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s2">&quot;World&quot;</span><span class="s1">])</span>
    <span class="s1">pytest.raises(IndexError</span><span class="s0">, lambda</span><span class="s1">: list(b.pluck(</span><span class="s3">0</span><span class="s1">)))</span>
    <span class="s0">assert </span><span class="s1">list(b.pluck(</span><span class="s3">0</span><span class="s0">, None</span><span class="s1">)) == [</span><span class="s2">&quot;H&quot;</span><span class="s0">, None, </span><span class="s2">&quot;W&quot;</span><span class="s1">]</span>
    <span class="s0">assert </span><span class="s1">b.pluck(</span><span class="s3">0</span><span class="s0">, None</span><span class="s1">).name == b.pluck(</span><span class="s3">0</span><span class="s0">, None</span><span class="s1">).name</span>
    <span class="s0">assert </span><span class="s1">b.pluck(</span><span class="s3">0</span><span class="s1">).name != b.pluck(</span><span class="s3">0</span><span class="s0">, None</span><span class="s1">).name</span>


<span class="s0">def </span><span class="s1">test_unzip():</span>
    <span class="s1">b = db.from_sequence(range(</span><span class="s3">100</span><span class="s1">)).map(</span><span class="s0">lambda </span><span class="s1">x: (x</span><span class="s0">, </span><span class="s1">x + </span><span class="s3">1</span><span class="s0">, </span><span class="s1">x + </span><span class="s3">2</span><span class="s1">))</span>
    <span class="s1">one</span><span class="s0">, </span><span class="s1">two</span><span class="s0">, </span><span class="s1">three = b.unzip(</span><span class="s3">3</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">list(one) == list(range(</span><span class="s3">100</span><span class="s1">))</span>
    <span class="s0">assert </span><span class="s1">list(three) == [i + </span><span class="s3">2 </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">100</span><span class="s1">)]</span>
    <span class="s0">assert </span><span class="s1">one.name == b.unzip(</span><span class="s3">3</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">].name</span>
    <span class="s0">assert </span><span class="s1">one.name != two.name</span>


<span class="s0">def </span><span class="s1">test_fold():</span>
    <span class="s1">c = b.fold(add)</span>
    <span class="s0">assert </span><span class="s1">c.compute() == sum(L)</span>
    <span class="s0">assert </span><span class="s1">c.key == b.fold(add).key</span>

    <span class="s1">c2 = b.fold(add</span><span class="s0">, </span><span class="s1">initial=</span><span class="s3">10</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">c2.key != c.key</span>
    <span class="s0">assert </span><span class="s1">c2.compute() == sum(L) + </span><span class="s3">10 </span><span class="s1">* b.npartitions</span>
    <span class="s0">assert </span><span class="s1">c2.key == b.fold(add</span><span class="s0">, </span><span class="s1">initial=</span><span class="s3">10</span><span class="s1">).key</span>

    <span class="s1">c = db.from_sequence(range(</span><span class="s3">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">3</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">binop(acc</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s1">acc = acc.copy()</span>
        <span class="s1">acc.add(x)</span>
        <span class="s0">return </span><span class="s1">acc</span>

    <span class="s1">d = c.fold(binop</span><span class="s0">, </span><span class="s1">set.union</span><span class="s0">, </span><span class="s1">initial=set())</span>
    <span class="s0">assert </span><span class="s1">d.compute() == set(c)</span>
    <span class="s0">assert </span><span class="s1">d.key == c.fold(binop</span><span class="s0">, </span><span class="s1">set.union</span><span class="s0">, </span><span class="s1">initial=set()).key</span>

    <span class="s1">d = db.from_sequence(</span><span class="s2">&quot;hello&quot;</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">set(d.fold(</span><span class="s0">lambda </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b: </span><span class="s2">&quot;&quot;</span><span class="s1">.join([a</span><span class="s0">, </span><span class="s1">b])</span><span class="s0">, </span><span class="s1">initial=</span><span class="s2">&quot;&quot;</span><span class="s1">).compute()) == set(</span>
        <span class="s2">&quot;hello&quot;</span>
    <span class="s1">)</span>

    <span class="s1">e = db.from_sequence([[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">3</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">set(e.fold(add</span><span class="s0">, </span><span class="s1">initial=[]).compute(scheduler=</span><span class="s2">&quot;sync&quot;</span><span class="s1">)) == {</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">}</span>


<span class="s0">def </span><span class="s1">test_fold_bag():</span>
    <span class="s0">def </span><span class="s1">binop(tot</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s1">tot.add(x)</span>
        <span class="s0">return </span><span class="s1">tot</span>

    <span class="s1">c = b.fold(binop</span><span class="s0">, </span><span class="s1">combine=set.union</span><span class="s0">, </span><span class="s1">initial=set()</span><span class="s0">, </span><span class="s1">out_type=Bag)</span>
    <span class="s0">assert </span><span class="s1">isinstance(c</span><span class="s0">, </span><span class="s1">Bag)</span>
    <span class="s1">assert_eq(c</span><span class="s0">, </span><span class="s1">list(set(range(</span><span class="s3">5</span><span class="s1">))))</span>


<span class="s0">def </span><span class="s1">test_distinct():</span>
    <span class="s0">assert </span><span class="s1">sorted(b.distinct()) == [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">]</span>
    <span class="s0">assert </span><span class="s1">b.distinct().name == b.distinct().name</span>
    <span class="s0">assert </span><span class="s2">&quot;distinct&quot; </span><span class="s0">in </span><span class="s1">b.distinct().name</span>
    <span class="s0">assert </span><span class="s1">b.distinct().count().compute() == </span><span class="s3">5</span>
    <span class="s1">bag = db.from_sequence([</span><span class="s3">0</span><span class="s1">] * </span><span class="s3">50</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">50</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">bag.filter(</span><span class="s0">None</span><span class="s1">).distinct().compute() == []</span>


<span class="s0">def </span><span class="s1">test_distinct_with_key():</span>
    <span class="s1">seq = [{</span><span class="s2">&quot;a&quot;</span><span class="s1">: i} </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]]</span>
    <span class="s1">bag = db.from_sequence(seq</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">expected = list(unique(seq</span><span class="s0">, </span><span class="s1">key=</span><span class="s0">lambda </span><span class="s1">x: x[</span><span class="s2">&quot;a&quot;</span><span class="s1">]))</span>
    <span class="s1">assert_eq(bag.distinct(key=</span><span class="s2">&quot;a&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">expected)</span>
    <span class="s1">assert_eq(bag.distinct(key=</span><span class="s0">lambda </span><span class="s1">x: x[</span><span class="s2">&quot;a&quot;</span><span class="s1">])</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_frequencies():</span>
    <span class="s1">c = b.frequencies()</span>
    <span class="s0">assert </span><span class="s1">dict(c) == {</span><span class="s3">0</span><span class="s1">: </span><span class="s3">3</span><span class="s0">, </span><span class="s3">1</span><span class="s1">: </span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s1">: </span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s1">: </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">: </span><span class="s3">3</span><span class="s1">}</span>
    <span class="s1">c2 = b.frequencies(split_every=</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">dict(c2) == {</span><span class="s3">0</span><span class="s1">: </span><span class="s3">3</span><span class="s0">, </span><span class="s3">1</span><span class="s1">: </span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s1">: </span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s1">: </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">: </span><span class="s3">3</span><span class="s1">}</span>
    <span class="s0">assert </span><span class="s1">c.name == b.frequencies().name</span>
    <span class="s0">assert </span><span class="s1">c.name != c2.name</span>
    <span class="s0">assert </span><span class="s1">c2.name == b.frequencies(split_every=</span><span class="s3">2</span><span class="s1">).name</span>
    <span class="s4"># test bag with empty partitions</span>
    <span class="s1">b2 = db.from_sequence(range(</span><span class="s3">20</span><span class="s1">)</span><span class="s0">, </span><span class="s1">partition_size=</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">b2 = b2.filter(</span><span class="s0">lambda </span><span class="s1">x: x &lt; </span><span class="s3">10</span><span class="s1">)</span>
    <span class="s1">d = b2.frequencies()</span>
    <span class="s0">assert </span><span class="s1">dict(d) == dict(zip(range(</span><span class="s3">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s1">] * </span><span class="s3">10</span><span class="s1">))</span>
    <span class="s1">bag = db.from_sequence([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">bag2 = bag.filter(</span><span class="s0">None</span><span class="s1">).frequencies(split_every=</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">assert_eq(bag2</span><span class="s0">, </span><span class="s1">[])</span>


<span class="s0">def </span><span class="s1">test_frequencies_sorted():</span>
    <span class="s1">b = db.from_sequence([</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">])</span>
    <span class="s0">assert </span><span class="s1">list(b.frequencies(sort=</span><span class="s0">True</span><span class="s1">).compute()) == [(</span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)]</span>


<span class="s0">def </span><span class="s1">test_topk():</span>
    <span class="s0">assert </span><span class="s1">list(b.topk(</span><span class="s3">4</span><span class="s1">)) == [</span><span class="s3">4</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span>
    <span class="s1">c = b.topk(</span><span class="s3">4</span><span class="s0">, </span><span class="s1">key=</span><span class="s0">lambda </span><span class="s1">x: -x)</span>
    <span class="s0">assert </span><span class="s1">list(c) == [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span>
    <span class="s1">c2 = b.topk(</span><span class="s3">4</span><span class="s0">, </span><span class="s1">key=</span><span class="s0">lambda </span><span class="s1">x: -x</span><span class="s0">, </span><span class="s1">split_every=</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">list(c2) == [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span>
    <span class="s0">assert </span><span class="s1">c.name != c2.name</span>
    <span class="s0">assert </span><span class="s1">b.topk(</span><span class="s3">4</span><span class="s1">).name == b.topk(</span><span class="s3">4</span><span class="s1">).name</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;npartitions&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_topk_with_non_callable_key(npartitions):</span>
    <span class="s1">b = db.from_sequence([(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">9</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">8</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">npartitions=npartitions)</span>
    <span class="s0">assert </span><span class="s1">list(b.topk(</span><span class="s3">2</span><span class="s0">, </span><span class="s1">key=</span><span class="s3">1</span><span class="s1">)) == [(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">9</span><span class="s1">)]</span>
    <span class="s0">assert </span><span class="s1">list(b.topk(</span><span class="s3">2</span><span class="s0">, </span><span class="s1">key=</span><span class="s3">0</span><span class="s1">)) == [(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">8</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">9</span><span class="s1">)]</span>
    <span class="s0">assert </span><span class="s1">b.topk(</span><span class="s3">2</span><span class="s0">, </span><span class="s1">key=</span><span class="s3">1</span><span class="s1">).name == b.topk(</span><span class="s3">2</span><span class="s0">, </span><span class="s1">key=</span><span class="s3">1</span><span class="s1">).name</span>


<span class="s0">def </span><span class="s1">test_topk_with_multiarg_lambda():</span>
    <span class="s1">b = db.from_sequence([(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">9</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">8</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">list(b.topk(</span><span class="s3">2</span><span class="s0">, </span><span class="s1">key=</span><span class="s0">lambda </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b: b)) == [(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">9</span><span class="s1">)]</span>


<span class="s0">def </span><span class="s1">test_lambdas():</span>
    <span class="s0">assert </span><span class="s1">list(b.map(</span><span class="s0">lambda </span><span class="s1">x: x + </span><span class="s3">1</span><span class="s1">)) == list(b.map(inc))</span>


<span class="s0">def </span><span class="s1">test_reductions():</span>
    <span class="s0">assert </span><span class="s1">int(b.count()) == </span><span class="s3">15</span>
    <span class="s0">assert </span><span class="s1">int(b.sum()) == </span><span class="s3">30</span>
    <span class="s0">assert </span><span class="s1">int(b.max()) == </span><span class="s3">4</span>
    <span class="s0">assert </span><span class="s1">int(b.min()) == </span><span class="s3">0</span>
    <span class="s0">assert </span><span class="s1">b.any().compute() </span><span class="s0">is True</span>
    <span class="s0">assert </span><span class="s1">b.all().compute() </span><span class="s0">is False</span>
    <span class="s0">assert </span><span class="s1">b.all().key == b.all().key</span>
    <span class="s0">assert </span><span class="s1">b.all().key != b.any().key</span>


<span class="s0">def </span><span class="s1">test_reduction_names():</span>
    <span class="s0">assert </span><span class="s1">b.sum().name.startswith(</span><span class="s2">&quot;sum&quot;</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">b.reduction(sum</span><span class="s0">, </span><span class="s1">sum).name.startswith(</span><span class="s2">&quot;sum&quot;</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">any(</span>
        <span class="s1">isinstance(k</span><span class="s0">, </span><span class="s1">str) </span><span class="s0">and </span><span class="s1">k.startswith(</span><span class="s2">&quot;max&quot;</span><span class="s1">) </span><span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">b.reduction(sum</span><span class="s0">, </span><span class="s1">max).dask</span>
    <span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">b.reduction(sum</span><span class="s0">, </span><span class="s1">sum</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;foo&quot;</span><span class="s1">).name.startswith(</span><span class="s2">&quot;foo&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_tree_reductions():</span>
    <span class="s1">b = db.from_sequence(range(</span><span class="s3">12</span><span class="s1">))</span>
    <span class="s1">c = b.reduction(sum</span><span class="s0">, </span><span class="s1">sum</span><span class="s0">, </span><span class="s1">split_every=</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">d = b.reduction(sum</span><span class="s0">, </span><span class="s1">sum</span><span class="s0">, </span><span class="s1">split_every=</span><span class="s3">6</span><span class="s1">)</span>
    <span class="s1">e = b.reduction(sum</span><span class="s0">, </span><span class="s1">sum</span><span class="s0">, </span><span class="s1">split_every=</span><span class="s3">5</span><span class="s1">)</span>

    <span class="s0">assert </span><span class="s1">c.compute() == d.compute() == e.compute()</span>

    <span class="s0">assert </span><span class="s1">len(c.dask) &gt; len(d.dask)</span>

    <span class="s1">c = b.sum(split_every=</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">d = b.sum(split_every=</span><span class="s3">5</span><span class="s1">)</span>

    <span class="s0">assert </span><span class="s1">c.compute() == d.compute()</span>
    <span class="s0">assert </span><span class="s1">len(c.dask) &gt; len(d.dask)</span>

    <span class="s0">assert </span><span class="s1">c.key != d.key</span>
    <span class="s0">assert </span><span class="s1">c.key == b.sum(split_every=</span><span class="s3">2</span><span class="s1">).key</span>
    <span class="s0">assert </span><span class="s1">c.key != b.sum().key</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;npartitions&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_aggregation(npartitions):</span>
    <span class="s1">L = list(range(</span><span class="s3">15</span><span class="s1">))</span>
    <span class="s1">b = db.range(</span><span class="s3">15</span><span class="s0">, </span><span class="s1">npartitions=npartitions)</span>
    <span class="s1">assert_eq(b.mean()</span><span class="s0">, </span><span class="s1">sum(L) / len(L))</span>
    <span class="s1">assert_eq(b.sum()</span><span class="s0">, </span><span class="s1">sum(L))</span>
    <span class="s1">assert_eq(b.count()</span><span class="s0">, </span><span class="s1">len(L))</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;npartitions&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">10</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_non_splittable_reductions(npartitions):</span>
    <span class="s1">np = pytest.importorskip(</span><span class="s2">&quot;numpy&quot;</span><span class="s1">)</span>
    <span class="s1">data = list(range(</span><span class="s3">100</span><span class="s1">))</span>
    <span class="s1">c = db.from_sequence(data</span><span class="s0">, </span><span class="s1">npartitions=npartitions)</span>

    <span class="s1">assert_eq(c.mean()</span><span class="s0">, </span><span class="s1">np.mean(data))</span>
    <span class="s1">assert_eq(c.std()</span><span class="s0">, </span><span class="s1">np.std(data))</span>


<span class="s0">def </span><span class="s1">test_std():</span>
    <span class="s1">assert_eq(b.std()</span><span class="s0">, </span><span class="s1">math.sqrt(</span><span class="s3">2.0</span><span class="s1">))</span>
    <span class="s0">assert </span><span class="s1">float(b.std()) == math.sqrt(</span><span class="s3">2.0</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_var():</span>
    <span class="s1">assert_eq(b.var()</span><span class="s0">, </span><span class="s3">2.0</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">float(b.var()) == </span><span class="s3">2.0</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;transform&quot;</span><span class="s0">, </span><span class="s1">[identity</span><span class="s0">, </span><span class="s1">dask.delayed</span><span class="s0">, lambda </span><span class="s1">x: db.from_sequence(x</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">1</span><span class="s1">)]</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_join(transform):</span>
    <span class="s1">other = transform([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">])</span>
    <span class="s1">c = b.join(other</span><span class="s0">, </span><span class="s1">on_self=isodd</span><span class="s0">, </span><span class="s1">on_other=iseven)</span>
    <span class="s1">assert_eq(c</span><span class="s0">, </span><span class="s1">list(join(iseven</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">isodd</span><span class="s0">, </span><span class="s1">list(b))))</span>
    <span class="s1">assert_eq(b.join(other</span><span class="s0">, </span><span class="s1">isodd)</span><span class="s0">, </span><span class="s1">list(join(isodd</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">isodd</span><span class="s0">, </span><span class="s1">list(b))))</span>
    <span class="s0">assert </span><span class="s1">c.name == b.join(other</span><span class="s0">, </span><span class="s1">on_self=isodd</span><span class="s0">, </span><span class="s1">on_other=iseven).name</span>


<span class="s0">def </span><span class="s1">test_foldby():</span>
    <span class="s1">c = b.foldby(iseven</span><span class="s0">, </span><span class="s1">add</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">add</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">(reduceby</span><span class="s0">, </span><span class="s1">iseven</span><span class="s0">, </span><span class="s1">add</span><span class="s0">, </span><span class="s1">(b.name</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s3">0</span><span class="s1">) </span><span class="s0">in </span><span class="s1">list(c.dask.values())</span>
    <span class="s0">assert </span><span class="s1">set(c) == set(reduceby(iseven</span><span class="s0">, lambda </span><span class="s1">acc</span><span class="s0">, </span><span class="s1">x: acc + x</span><span class="s0">, </span><span class="s1">L</span><span class="s0">, </span><span class="s3">0</span><span class="s1">).items())</span>
    <span class="s0">assert </span><span class="s1">c.name == b.foldby(iseven</span><span class="s0">, </span><span class="s1">add</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">add</span><span class="s0">, </span><span class="s3">0</span><span class="s1">).name</span>

    <span class="s1">c = b.foldby(iseven</span><span class="s0">, lambda </span><span class="s1">acc</span><span class="s0">, </span><span class="s1">x: acc + x)</span>
    <span class="s0">assert </span><span class="s1">set(c) == set(reduceby(iseven</span><span class="s0">, lambda </span><span class="s1">acc</span><span class="s0">, </span><span class="s1">x: acc + x</span><span class="s0">, </span><span class="s1">L</span><span class="s0">, </span><span class="s3">0</span><span class="s1">).items())</span>


<span class="s0">def </span><span class="s1">test_foldby_tree_reduction():</span>
    <span class="s1">dsk = list()</span>
    <span class="s0">for </span><span class="s1">n </span><span class="s0">in </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s3">32</span><span class="s1">]:</span>
        <span class="s1">b = db.from_sequence(range(</span><span class="s3">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">npartitions=n)</span>
        <span class="s1">c = b.foldby(iseven</span><span class="s0">, </span><span class="s1">add)</span>
        <span class="s1">dsk.extend([c])</span>
        <span class="s0">for </span><span class="s1">m </span><span class="s0">in </span><span class="s1">[</span><span class="s0">False, None, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]:</span>
            <span class="s1">d = b.foldby(iseven</span><span class="s0">, </span><span class="s1">add</span><span class="s0">, </span><span class="s1">split_every=m)</span>
            <span class="s1">e = b.foldby(iseven</span><span class="s0">, </span><span class="s1">add</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">split_every=m)</span>
            <span class="s1">f = b.foldby(iseven</span><span class="s0">, </span><span class="s1">add</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">add</span><span class="s0">, </span><span class="s1">split_every=m)</span>
            <span class="s1">g = b.foldby(iseven</span><span class="s0">, </span><span class="s1">add</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">add</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">split_every=m)</span>
            <span class="s1">dsk.extend([d</span><span class="s0">, </span><span class="s1">e</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">g])</span>
    <span class="s1">results = dask.compute(dsk)</span>
    <span class="s1">first = results[</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s0">assert </span><span class="s1">all([r == first </span><span class="s0">for </span><span class="s1">r </span><span class="s0">in </span><span class="s1">results])</span>


<span class="s0">def </span><span class="s1">test_map_partitions():</span>
    <span class="s0">assert </span><span class="s1">list(b.map_partitions(len)) == [</span><span class="s3">5</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]</span>
    <span class="s0">assert </span><span class="s1">b.map_partitions(len).name == b.map_partitions(len).name</span>
    <span class="s0">assert </span><span class="s1">b.map_partitions(</span><span class="s0">lambda </span><span class="s1">a: len(a) + </span><span class="s3">1</span><span class="s1">).name != b.map_partitions(len).name</span>


<span class="s0">def </span><span class="s1">test_map_partitions_args_kwargs():</span>
    <span class="s1">x = [random.randint(-</span><span class="s3">100</span><span class="s0">, </span><span class="s3">100</span><span class="s1">) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">100</span><span class="s1">)]</span>
    <span class="s1">y = [random.randint(-</span><span class="s3">100</span><span class="s0">, </span><span class="s3">100</span><span class="s1">) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">100</span><span class="s1">)]</span>

    <span class="s1">dx = db.from_sequence(x</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">10</span><span class="s1">)</span>
    <span class="s1">dy = db.from_sequence(y</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">10</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">maximum(x</span><span class="s0">, </span><span class="s1">y=</span><span class="s3">0</span><span class="s1">):</span>
        <span class="s1">y = repeat(y) </span><span class="s0">if </span><span class="s1">isinstance(y</span><span class="s0">, </span><span class="s1">int) </span><span class="s0">else </span><span class="s1">y</span>
        <span class="s0">return </span><span class="s1">[max(a</span><span class="s0">, </span><span class="s1">b) </span><span class="s0">for </span><span class="s1">(a</span><span class="s0">, </span><span class="s1">b) </span><span class="s0">in </span><span class="s1">zip(x</span><span class="s0">, </span><span class="s1">y)]</span>

    <span class="s1">sol = maximum(x</span><span class="s0">, </span><span class="s1">y=</span><span class="s3">10</span><span class="s1">)</span>
    <span class="s1">assert_eq(db.map_partitions(maximum</span><span class="s0">, </span><span class="s1">dx</span><span class="s0">, </span><span class="s1">y=</span><span class="s3">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">sol)</span>
    <span class="s1">assert_eq(dx.map_partitions(maximum</span><span class="s0">, </span><span class="s1">y=</span><span class="s3">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">sol)</span>
    <span class="s1">assert_eq(dx.map_partitions(maximum</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">sol)</span>

    <span class="s1">sol = maximum(x</span><span class="s0">, </span><span class="s1">y)</span>
    <span class="s1">assert_eq(db.map_partitions(maximum</span><span class="s0">, </span><span class="s1">dx</span><span class="s0">, </span><span class="s1">dy)</span><span class="s0">, </span><span class="s1">sol)</span>
    <span class="s1">assert_eq(dx.map_partitions(maximum</span><span class="s0">, </span><span class="s1">y=dy)</span><span class="s0">, </span><span class="s1">sol)</span>
    <span class="s1">assert_eq(dx.map_partitions(maximum</span><span class="s0">, </span><span class="s1">dy)</span><span class="s0">, </span><span class="s1">sol)</span>

    <span class="s1">dy_mean = dy.mean().apply(int)</span>
    <span class="s1">sol = maximum(x</span><span class="s0">, </span><span class="s1">int(sum(y) / len(y)))</span>
    <span class="s1">assert_eq(dx.map_partitions(maximum</span><span class="s0">, </span><span class="s1">y=dy_mean)</span><span class="s0">, </span><span class="s1">sol)</span>
    <span class="s1">assert_eq(dx.map_partitions(maximum</span><span class="s0">, </span><span class="s1">dy_mean)</span><span class="s0">, </span><span class="s1">sol)</span>

    <span class="s1">dy_mean = dask.delayed(dy_mean)</span>
    <span class="s1">assert_eq(dx.map_partitions(maximum</span><span class="s0">, </span><span class="s1">y=dy_mean)</span><span class="s0">, </span><span class="s1">sol)</span>
    <span class="s1">assert_eq(dx.map_partitions(maximum</span><span class="s0">, </span><span class="s1">dy_mean)</span><span class="s0">, </span><span class="s1">sol)</span>


<span class="s0">def </span><span class="s1">test_map_partitions_blockwise():</span>
    <span class="s4"># Check that the `token` argument works,</span>
    <span class="s4"># and that `map_partitions`` is using `Blockwise`.</span>
    <span class="s1">layer = hlg_layer(</span>
        <span class="s1">b.map_partitions(</span><span class="s0">lambda </span><span class="s1">x: x</span><span class="s0">, </span><span class="s1">token=</span><span class="s2">&quot;test-string&quot;</span><span class="s1">).dask</span><span class="s0">, </span><span class="s2">&quot;test-string&quot;</span>
    <span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">layer</span>
    <span class="s0">assert </span><span class="s1">isinstance(layer</span><span class="s0">, </span><span class="s1">Blockwise)</span>


<span class="s0">def </span><span class="s1">test_random_sample_size():</span>
    <span class="s5">&quot;&quot;&quot; 
    Number of randomly sampled elements are in the expected range. 
    &quot;&quot;&quot;</span>
    <span class="s1">a = db.from_sequence(range(</span><span class="s3">1000</span><span class="s1">)</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">5</span><span class="s1">)</span>
    <span class="s4"># we expect a size of approx. 100, but leave large margins to avoid</span>
    <span class="s4"># random failures</span>
    <span class="s0">assert </span><span class="s3">10 </span><span class="s1">&lt; len(list(a.random_sample(</span><span class="s3">0.1</span><span class="s0">, </span><span class="s3">42</span><span class="s1">))) &lt; </span><span class="s3">300</span>


<span class="s0">def </span><span class="s1">test_random_sample_prob_range():</span>
    <span class="s5">&quot;&quot;&quot; 
    Specifying probabilities outside the range [0, 1] raises ValueError. 
    &quot;&quot;&quot;</span>
    <span class="s1">a = db.from_sequence(range(</span><span class="s3">50</span><span class="s1">)</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">5</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">a.random_sample(-</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">a.random_sample(</span><span class="s3">1.1</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_random_sample_repeated_computation():</span>
    <span class="s5">&quot;&quot;&quot; 
    Repeated computation of a defined random sampling operation 
    generates identical results. 
    &quot;&quot;&quot;</span>
    <span class="s1">a = db.from_sequence(range(</span><span class="s3">50</span><span class="s1">)</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">5</span><span class="s1">)</span>
    <span class="s1">b = a.random_sample(</span><span class="s3">0.2</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">list(b) == list(b)  </span><span class="s4"># computation happens here</span>


<span class="s0">def </span><span class="s1">test_random_sample_different_definitions():</span>
    <span class="s5">&quot;&quot;&quot; 
    Repeatedly defining a random sampling operation yields different results 
    upon computation if no random seed is specified. 
    &quot;&quot;&quot;</span>
    <span class="s1">a = db.from_sequence(range(</span><span class="s3">50</span><span class="s1">)</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">5</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">list(a.random_sample(</span><span class="s3">0.5</span><span class="s1">)) != list(a.random_sample(</span><span class="s3">0.5</span><span class="s1">))</span>
    <span class="s0">assert </span><span class="s1">a.random_sample(</span><span class="s3">0.5</span><span class="s1">).name != a.random_sample(</span><span class="s3">0.5</span><span class="s1">).name</span>


<span class="s0">def </span><span class="s1">test_random_sample_random_state():</span>
    <span class="s5">&quot;&quot;&quot; 
    Sampling with fixed random seed generates identical results. 
    &quot;&quot;&quot;</span>
    <span class="s1">a = db.from_sequence(range(</span><span class="s3">50</span><span class="s1">)</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">5</span><span class="s1">)</span>
    <span class="s1">b = a.random_sample(</span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">1234</span><span class="s1">)</span>
    <span class="s1">c = a.random_sample(</span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">1234</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">list(b) == list(c)</span>


<span class="s0">def </span><span class="s1">test_lazify_task():</span>
    <span class="s1">task = (sum</span><span class="s0">, </span><span class="s1">(reify</span><span class="s0">, </span><span class="s1">(map</span><span class="s0">, </span><span class="s1">inc</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">])))</span>
    <span class="s0">assert </span><span class="s1">lazify_task(task) == (sum</span><span class="s0">, </span><span class="s1">(map</span><span class="s0">, </span><span class="s1">inc</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]))</span>

    <span class="s1">task = (reify</span><span class="s0">, </span><span class="s1">(map</span><span class="s0">, </span><span class="s1">inc</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]))</span>
    <span class="s0">assert </span><span class="s1">lazify_task(task) == task</span>

    <span class="s1">a = (reify</span><span class="s0">, </span><span class="s1">(map</span><span class="s0">, </span><span class="s1">inc</span><span class="s0">, </span><span class="s1">(reify</span><span class="s0">, </span><span class="s1">(filter</span><span class="s0">, </span><span class="s1">iseven</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">))))</span>
    <span class="s1">b = (reify</span><span class="s0">, </span><span class="s1">(map</span><span class="s0">, </span><span class="s1">inc</span><span class="s0">, </span><span class="s1">(filter</span><span class="s0">, </span><span class="s1">iseven</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">)))</span>
    <span class="s0">assert </span><span class="s1">lazify_task(a) == b</span>


<span class="s1">f = </span><span class="s0">lambda </span><span class="s1">x: x</span>


<span class="s0">def </span><span class="s1">test_lazify():</span>
    <span class="s1">a = {</span>
        <span class="s2">&quot;x&quot;</span><span class="s1">: (reify</span><span class="s0">, </span><span class="s1">(map</span><span class="s0">, </span><span class="s1">inc</span><span class="s0">, </span><span class="s1">(reify</span><span class="s0">, </span><span class="s1">(filter</span><span class="s0">, </span><span class="s1">iseven</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">))))</span><span class="s0">,</span>
        <span class="s2">&quot;a&quot;</span><span class="s1">: (f</span><span class="s0">, </span><span class="s2">&quot;x&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s2">&quot;b&quot;</span><span class="s1">: (f</span><span class="s0">, </span><span class="s2">&quot;x&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">}</span>
    <span class="s1">b = {</span><span class="s2">&quot;x&quot;</span><span class="s1">: (reify</span><span class="s0">, </span><span class="s1">(map</span><span class="s0">, </span><span class="s1">inc</span><span class="s0">, </span><span class="s1">(filter</span><span class="s0">, </span><span class="s1">iseven</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">)))</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s1">: (f</span><span class="s0">, </span><span class="s2">&quot;x&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: (f</span><span class="s0">, </span><span class="s2">&quot;x&quot;</span><span class="s1">)}</span>
    <span class="s0">assert </span><span class="s1">lazify(a) == b</span>


<span class="s0">def </span><span class="s1">test_inline_singleton_lists():</span>
    <span class="s1">inp = {</span><span class="s2">&quot;b&quot;</span><span class="s1">: (list</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">: (f</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)}</span>
    <span class="s1">out = {</span><span class="s2">&quot;c&quot;</span><span class="s1">: (f</span><span class="s0">, </span><span class="s1">(list</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)}</span>
    <span class="s0">assert </span><span class="s1">inline_singleton_lists(inp</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;c&quot;</span><span class="s1">]) == out</span>

    <span class="s1">out = {</span><span class="s2">&quot;c&quot;</span><span class="s1">: (f</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)}</span>
    <span class="s0">assert </span><span class="s1">optimize(inp</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;c&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">rename_fused_keys=</span><span class="s0">False</span><span class="s1">) == out</span>

    <span class="s4"># If list is an output key, don't fuse it</span>
    <span class="s0">assert </span><span class="s1">inline_singleton_lists(inp</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">]) == inp</span>
    <span class="s0">assert </span><span class="s1">optimize(inp</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">rename_fused_keys=</span><span class="s0">False</span><span class="s1">) == inp</span>

    <span class="s1">inp = {</span><span class="s2">&quot;b&quot;</span><span class="s1">: (list</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">: (f</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s1">: (f</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)}</span>
    <span class="s0">assert </span><span class="s1">inline_singleton_lists(inp</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s1">]) == inp</span>

    <span class="s4"># Doesn't inline constants</span>
    <span class="s1">inp = {</span><span class="s2">&quot;b&quot;</span><span class="s1">: (</span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">: (f</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">)}</span>
    <span class="s0">assert </span><span class="s1">inline_singleton_lists(inp</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;c&quot;</span><span class="s1">]) == inp</span>


<span class="s0">def </span><span class="s1">test_rename_fused_keys_bag():</span>
    <span class="s1">inp = {</span><span class="s2">&quot;b&quot;</span><span class="s1">: (list</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">: (f</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)}</span>

    <span class="s1">outp = optimize(inp</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;c&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">rename_fused_keys=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">outp.keys() == {</span><span class="s2">&quot;c&quot;</span><span class="s1">}</span>
    <span class="s0">assert </span><span class="s1">outp[</span><span class="s2">&quot;c&quot;</span><span class="s1">][</span><span class="s3">1</span><span class="s1">:] == (</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>

    <span class="s0">with </span><span class="s1">dask.config.set({</span><span class="s2">&quot;optimization.fuse.rename-keys&quot;</span><span class="s1">: </span><span class="s0">False</span><span class="s1">}):</span>
        <span class="s0">assert </span><span class="s1">optimize(inp</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;c&quot;</span><span class="s1">]) == outp</span>

    <span class="s4"># By default, fused keys are renamed</span>
    <span class="s0">assert </span><span class="s1">optimize(inp</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;c&quot;</span><span class="s1">]) != outp</span>


<span class="s0">def </span><span class="s1">test_take():</span>
    <span class="s0">assert </span><span class="s1">list(b.take(</span><span class="s3">2</span><span class="s1">)) == [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span>
    <span class="s0">assert </span><span class="s1">b.take(</span><span class="s3">2</span><span class="s1">) == (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">isinstance(b.take(</span><span class="s3">2</span><span class="s0">, </span><span class="s1">compute=</span><span class="s0">False</span><span class="s1">)</span><span class="s0">, </span><span class="s1">Bag)</span>


<span class="s0">def </span><span class="s1">test_take_npartitions():</span>
    <span class="s0">assert </span><span class="s1">list(b.take(</span><span class="s3">6</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">2</span><span class="s1">)) == [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span>
    <span class="s0">assert </span><span class="s1">b.take(</span><span class="s3">6</span><span class="s0">, </span><span class="s1">npartitions=-</span><span class="s3">1</span><span class="s1">) == (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">b.take(</span><span class="s3">3</span><span class="s0">, </span><span class="s1">npartitions=-</span><span class="s3">1</span><span class="s1">) == (</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">b.take(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">5</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_take_npartitions_warn():</span>
    <span class="s4"># Use single-threaded scheduler so warnings are properly captured in the</span>
    <span class="s4"># same process</span>
    <span class="s0">with </span><span class="s1">dask.config.set(scheduler=</span><span class="s2">&quot;sync&quot;</span><span class="s1">):</span>
        <span class="s0">with </span><span class="s1">pytest.warns(UserWarning):</span>
            <span class="s1">b.take(</span><span class="s3">100</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">pytest.warns(UserWarning):</span>
            <span class="s1">b.take(</span><span class="s3">7</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s0">True</span><span class="s1">) </span><span class="s0">as </span><span class="s1">record:</span>
            <span class="s1">b.take(</span><span class="s3">7</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">2</span><span class="s1">)</span>
            <span class="s1">b.take(</span><span class="s3">7</span><span class="s0">, </span><span class="s1">warn=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s0">assert not </span><span class="s1">record</span>


<span class="s0">def </span><span class="s1">test_map_is_lazy():</span>
    <span class="s0">assert </span><span class="s1">isinstance(map(</span><span class="s0">lambda </span><span class="s1">x: x</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">])</span><span class="s0">, </span><span class="s1">Iterator)</span>


<span class="s0">def </span><span class="s1">test_can_use_dict_to_make_concrete():</span>
    <span class="s0">assert </span><span class="s1">isinstance(dict(b.frequencies())</span><span class="s0">, </span><span class="s1">dict)</span>


<span class="s1">@pytest.mark.slow</span>
<span class="s1">@pytest.mark.network</span>
<span class="s1">@pytest.mark.skip(reason=</span><span class="s2">&quot;Hangs&quot;</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_from_url():</span>
    <span class="s1">a = db.from_url([</span><span class="s2">&quot;http://google.com&quot;</span><span class="s0">, </span><span class="s2">&quot;http://github.com&quot;</span><span class="s1">])</span>
    <span class="s0">assert </span><span class="s1">a.npartitions == </span><span class="s3">2</span>

    <span class="s1">b = db.from_url(</span><span class="s2">&quot;http://raw.githubusercontent.com/dask/dask/main/README.rst&quot;</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">b.npartitions == </span><span class="s3">1</span>
    <span class="s0">assert </span><span class="s6">b&quot;Dask</span><span class="s0">\n</span><span class="s6">&quot; </span><span class="s0">in </span><span class="s1">b.take(</span><span class="s3">10</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_read_text():</span>
    <span class="s0">with </span><span class="s1">filetexts({</span><span class="s2">&quot;a1.log&quot;</span><span class="s1">: </span><span class="s2">&quot;A</span><span class="s0">\n</span><span class="s2">B&quot;</span><span class="s0">, </span><span class="s2">&quot;a2.log&quot;</span><span class="s1">: </span><span class="s2">&quot;C</span><span class="s0">\n</span><span class="s2">D&quot;</span><span class="s1">}) </span><span class="s0">as </span><span class="s1">fns:</span>
        <span class="s0">assert </span><span class="s1">{line.strip() </span><span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">db.read_text(fns)} == set(</span><span class="s2">&quot;ABCD&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">{line.strip() </span><span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">db.read_text(</span><span class="s2">&quot;a*.log&quot;</span><span class="s1">)} == set(</span><span class="s2">&quot;ABCD&quot;</span><span class="s1">)</span>

    <span class="s1">pytest.raises(ValueError</span><span class="s0">, lambda</span><span class="s1">: db.read_text(</span><span class="s2">&quot;non-existent-*-path&quot;</span><span class="s1">))</span>


<span class="s0">def </span><span class="s1">test_read_text_large():</span>
    <span class="s0">with </span><span class="s1">tmpfile() </span><span class="s0">as </span><span class="s1">fn:</span>
        <span class="s0">with </span><span class="s1">open(fn</span><span class="s0">, </span><span class="s2">&quot;wb&quot;</span><span class="s1">) </span><span class="s0">as </span><span class="s1">f:</span>
            <span class="s1">f.write((</span><span class="s2">&quot;Hello, world!&quot; </span><span class="s1">+ os.linesep).encode() * </span><span class="s3">100</span><span class="s1">)</span>
        <span class="s1">b = db.read_text(fn</span><span class="s0">, </span><span class="s1">blocksize=</span><span class="s3">100</span><span class="s1">)</span>
        <span class="s1">c = db.read_text(fn)</span>
        <span class="s0">assert </span><span class="s1">len(b.dask) &gt; </span><span class="s3">5</span>
        <span class="s0">assert </span><span class="s1">list(map(str</span><span class="s0">, </span><span class="s1">b.str.strip())) == list(map(str</span><span class="s0">, </span><span class="s1">c.str.strip()))</span>

        <span class="s1">d = db.read_text([fn]</span><span class="s0">, </span><span class="s1">blocksize=</span><span class="s3">100</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">list(b) == list(d)</span>


<span class="s0">def </span><span class="s1">test_read_text_encoding():</span>
    <span class="s0">with </span><span class="s1">tmpfile() </span><span class="s0">as </span><span class="s1">fn:</span>
        <span class="s0">with </span><span class="s1">open(fn</span><span class="s0">, </span><span class="s2">&quot;wb&quot;</span><span class="s1">) </span><span class="s0">as </span><span class="s1">f:</span>
            <span class="s1">f.write((</span><span class="s2">&quot;&quot; </span><span class="s1">+ os.linesep).encode(</span><span class="s2">&quot;gb18030&quot;</span><span class="s1">) * </span><span class="s3">100</span><span class="s1">)</span>
        <span class="s1">b = db.read_text(fn</span><span class="s0">, </span><span class="s1">blocksize=</span><span class="s3">100</span><span class="s0">, </span><span class="s1">encoding=</span><span class="s2">&quot;gb18030&quot;</span><span class="s1">)</span>
        <span class="s1">c = db.read_text(fn</span><span class="s0">, </span><span class="s1">encoding=</span><span class="s2">&quot;gb18030&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">len(b.dask) &gt; </span><span class="s3">5</span>
        <span class="s1">b_enc = b.str.strip().map(</span><span class="s0">lambda </span><span class="s1">x: x.encode(</span><span class="s2">&quot;utf-8&quot;</span><span class="s1">))</span>
        <span class="s1">c_enc = c.str.strip().map(</span><span class="s0">lambda </span><span class="s1">x: x.encode(</span><span class="s2">&quot;utf-8&quot;</span><span class="s1">))</span>
        <span class="s0">assert </span><span class="s1">list(b_enc) == list(c_enc)</span>

        <span class="s1">d = db.read_text([fn]</span><span class="s0">, </span><span class="s1">blocksize=</span><span class="s3">100</span><span class="s0">, </span><span class="s1">encoding=</span><span class="s2">&quot;gb18030&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">list(b) == list(d)</span>


<span class="s0">def </span><span class="s1">test_read_text_large_gzip():</span>
    <span class="s0">with </span><span class="s1">tmpfile(</span><span class="s2">&quot;gz&quot;</span><span class="s1">) </span><span class="s0">as </span><span class="s1">fn:</span>
        <span class="s1">data = </span><span class="s6">b&quot;Hello, world!</span><span class="s0">\n</span><span class="s6">&quot; </span><span class="s1">* </span><span class="s3">100</span>
        <span class="s1">f = GzipFile(fn</span><span class="s0">, </span><span class="s2">&quot;wb&quot;</span><span class="s1">)</span>
        <span class="s1">f.write(data)</span>
        <span class="s1">f.close()</span>

        <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s4"># not allowed blocks when compressed</span>
            <span class="s1">db.read_text(fn</span><span class="s0">, </span><span class="s1">blocksize=</span><span class="s3">50</span><span class="s0">, </span><span class="s1">linedelimiter=</span><span class="s2">&quot;</span><span class="s0">\n</span><span class="s2">&quot;</span><span class="s1">)</span>

        <span class="s1">c = db.read_text(fn</span><span class="s0">, </span><span class="s1">blocksize=</span><span class="s0">None</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">c.npartitions == </span><span class="s3">1</span>
        <span class="s0">assert </span><span class="s2">&quot;&quot;</span><span class="s1">.join(c.compute()) == data.decode()</span>


<span class="s1">@pytest.mark.xfail(reason=</span><span class="s2">&quot;https://github.com/dask/dask/issues/6914&quot;</span><span class="s1">)</span>
<span class="s1">@pytest.mark.slow</span>
<span class="s1">@pytest.mark.network</span>
<span class="s0">def </span><span class="s1">test_from_s3():</span>
    <span class="s4"># note we don't test connection modes with aws_access_key and</span>
    <span class="s4"># aws_secret_key because these are not on travis-ci</span>
    <span class="s1">pytest.importorskip(</span><span class="s2">&quot;s3fs&quot;</span><span class="s1">)</span>

    <span class="s1">five_tips = (</span>
        <span class="s2">&quot;total_bill,tip,sex,smoker,day,time,size</span><span class="s0">\n</span><span class="s2">&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;16.99,1.01,Female,No,Sun,Dinner,2</span><span class="s0">\n</span><span class="s2">&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;10.34,1.66,Male,No,Sun,Dinner,3</span><span class="s0">\n</span><span class="s2">&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;21.01,3.5,Male,No,Sun,Dinner,3</span><span class="s0">\n</span><span class="s2">&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;23.68,3.31,Male,No,Sun,Dinner,2</span><span class="s0">\n</span><span class="s2">&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s4"># test compressed data</span>
    <span class="s1">e = db.read_text(</span><span class="s2">&quot;s3://tip-data/t*.gz&quot;</span><span class="s0">, </span><span class="s1">storage_options=dict(anon=</span><span class="s0">True</span><span class="s1">))</span>
    <span class="s0">assert </span><span class="s1">e.take(</span><span class="s3">5</span><span class="s1">) == five_tips</span>

    <span class="s4"># test multiple keys in bucket</span>
    <span class="s1">c = db.read_text(</span>
        <span class="s1">[</span><span class="s2">&quot;s3://tip-data/tips.gz&quot;</span><span class="s0">, </span><span class="s2">&quot;s3://tip-data/tips.json&quot;</span><span class="s0">, </span><span class="s2">&quot;s3://tip-data/tips.csv&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">storage_options=dict(anon=</span><span class="s0">True</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">c.npartitions == </span><span class="s3">3</span>


<span class="s0">def </span><span class="s1">test_from_sequence():</span>
    <span class="s1">b = db.from_sequence([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">3</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">len(b.dask) == </span><span class="s3">3</span>
    <span class="s0">assert </span><span class="s1">set(b) == {</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">}</span>


<span class="s0">def </span><span class="s1">test_from_long_sequence():</span>
    <span class="s1">L = list(range(</span><span class="s3">1001</span><span class="s1">))</span>
    <span class="s1">b = db.from_sequence(L)</span>
    <span class="s0">assert </span><span class="s1">set(b) == set(L)</span>


<span class="s0">def </span><span class="s1">test_from_empty_sequence():</span>
    <span class="s1">pytest.importorskip(</span><span class="s2">&quot;dask.dataframe&quot;</span><span class="s1">)</span>
    <span class="s1">b = db.from_sequence([])</span>
    <span class="s0">assert </span><span class="s1">b.npartitions == </span><span class="s3">1</span>
    <span class="s1">df = b.to_dataframe(meta={</span><span class="s2">&quot;a&quot;</span><span class="s1">: </span><span class="s2">&quot;int&quot;</span><span class="s1">}).compute()</span>
    <span class="s0">assert </span><span class="s1">df.empty</span><span class="s0">, </span><span class="s2">&quot;DataFrame is not empty&quot;</span>


<span class="s0">def </span><span class="s1">test_product():</span>
    <span class="s1">b2 = b.product(b)</span>
    <span class="s0">assert </span><span class="s1">b2.npartitions == b.npartitions**</span><span class="s3">2</span>
    <span class="s0">assert </span><span class="s1">set(b2) == {(i</span><span class="s0">, </span><span class="s1">j) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">L </span><span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">L}</span>

    <span class="s1">x = db.from_sequence([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">])</span>
    <span class="s1">y = db.from_sequence([</span><span class="s3">10</span><span class="s0">, </span><span class="s3">20</span><span class="s0">, </span><span class="s3">30</span><span class="s1">])</span>
    <span class="s1">z = x.product(y)</span>
    <span class="s0">assert </span><span class="s1">set(z) == {(i</span><span class="s0">, </span><span class="s1">j) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">] </span><span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">[</span><span class="s3">10</span><span class="s0">, </span><span class="s3">20</span><span class="s0">, </span><span class="s3">30</span><span class="s1">]}</span>

    <span class="s0">assert </span><span class="s1">z.name != b2.name</span>
    <span class="s0">assert </span><span class="s1">z.name == x.product(y).name</span>


<span class="s0">def </span><span class="s1">test_partition_collect():</span>
    <span class="s0">with </span><span class="s1">partd.Pickle() </span><span class="s0">as </span><span class="s1">p:</span>
        <span class="s1">partition(identity</span><span class="s0">, </span><span class="s1">range(</span><span class="s3">6</span><span class="s1">)</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s1">p)</span>
        <span class="s0">assert </span><span class="s1">set(p.get(</span><span class="s3">0</span><span class="s1">)) == {</span><span class="s3">0</span><span class="s0">, </span><span class="s3">3</span><span class="s1">}</span>
        <span class="s0">assert </span><span class="s1">set(p.get(</span><span class="s3">1</span><span class="s1">)) == {</span><span class="s3">1</span><span class="s0">, </span><span class="s3">4</span><span class="s1">}</span>
        <span class="s0">assert </span><span class="s1">set(p.get(</span><span class="s3">2</span><span class="s1">)) == {</span><span class="s3">2</span><span class="s0">, </span><span class="s3">5</span><span class="s1">}</span>

        <span class="s0">assert </span><span class="s1">sorted(collect(identity</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s1">)) == [(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s1">])</span><span class="s0">, </span><span class="s1">(</span><span class="s3">3</span><span class="s0">, </span><span class="s1">[</span><span class="s3">3</span><span class="s1">])]</span>


<span class="s0">def </span><span class="s1">test_groupby():</span>
    <span class="s1">c = b.groupby(identity)</span>
    <span class="s1">result = dict(c)</span>
    <span class="s0">assert </span><span class="s1">result == {</span>
        <span class="s3">0</span><span class="s1">: [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s3">1</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s3">2</span><span class="s1">: [</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s3">3</span><span class="s1">: [</span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s3">4</span><span class="s1">: [</span><span class="s3">4</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">4</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">}</span>
    <span class="s0">assert </span><span class="s1">c.npartitions == b.npartitions</span>
    <span class="s0">assert </span><span class="s1">c.name == b.groupby(identity).name</span>
    <span class="s0">assert </span><span class="s1">c.name != b.groupby(</span><span class="s0">lambda </span><span class="s1">x: x + </span><span class="s3">1</span><span class="s1">).name</span>


<span class="s0">def </span><span class="s1">test_groupby_with_indexer():</span>
    <span class="s1">b = db.from_sequence([[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">9</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">]])</span>
    <span class="s1">result = dict(b.groupby(</span><span class="s3">0</span><span class="s1">))</span>
    <span class="s0">assert </span><span class="s1">valmap(sorted</span><span class="s0">, </span><span class="s1">result) == {</span><span class="s3">1</span><span class="s1">: [[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">9</span><span class="s1">]]</span><span class="s0">, </span><span class="s3">2</span><span class="s1">: [[</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">]]}</span>


<span class="s0">def </span><span class="s1">test_groupby_with_npartitions_changed():</span>
    <span class="s1">result = b.groupby(</span><span class="s0">lambda </span><span class="s1">x: x</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">result2 = dict(result)</span>
    <span class="s0">assert </span><span class="s1">result2 == {</span>
        <span class="s3">0</span><span class="s1">: [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s3">1</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s3">2</span><span class="s1">: [</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s3">3</span><span class="s1">: [</span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s3">4</span><span class="s1">: [</span><span class="s3">4</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">4</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">}</span>

    <span class="s0">assert </span><span class="s1">result.npartitions == </span><span class="s3">1</span>


<span class="s0">def </span><span class="s1">test_groupby_with_scheduler_func():</span>
    <span class="s0">from </span><span class="s1">dask.threaded </span><span class="s0">import </span><span class="s1">get</span>

    <span class="s0">with </span><span class="s1">dask.config.set(scheduler=get):</span>
        <span class="s1">b.groupby(</span><span class="s0">lambda </span><span class="s1">x: x</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">1</span><span class="s1">).compute()</span>


<span class="s0">def </span><span class="s1">test_concat():</span>
    <span class="s1">a = db.from_sequence([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">])</span>
    <span class="s1">b = db.from_sequence([</span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s1">])</span>
    <span class="s1">c = db.concat([a</span><span class="s0">, </span><span class="s1">b])</span>
    <span class="s0">assert </span><span class="s1">list(c) == [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s1">]</span>
    <span class="s0">assert </span><span class="s1">c.name == db.concat([a</span><span class="s0">, </span><span class="s1">b]).name</span>


<span class="s0">def </span><span class="s1">test_flatten():</span>
    <span class="s1">b = db.from_sequence([[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]])</span>
    <span class="s0">assert </span><span class="s1">list(b.flatten()) == [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span>
    <span class="s0">assert </span><span class="s1">b.flatten().name == b.flatten().name</span>


<span class="s0">def </span><span class="s1">test_concat_after_map():</span>
    <span class="s1">a = db.from_sequence([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">])</span>
    <span class="s1">b = db.from_sequence([</span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">])</span>
    <span class="s1">result = db.concat([a.map(inc)</span><span class="s0">, </span><span class="s1">b])</span>
    <span class="s0">assert </span><span class="s1">list(result) == [</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]</span>


<span class="s0">def </span><span class="s1">test_args():</span>
    <span class="s1">c = b.map(</span><span class="s0">lambda </span><span class="s1">x: x + </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">d = Bag(*c._args)</span>

    <span class="s0">assert </span><span class="s1">list(c) == list(d)</span>
    <span class="s0">assert </span><span class="s1">c.npartitions == d.npartitions</span>


<span class="s0">def </span><span class="s1">test_to_dataframe():</span>
    <span class="s1">dd = pytest.importorskip(</span><span class="s2">&quot;dask.dataframe&quot;</span><span class="s1">)</span>
    <span class="s1">pd = pytest.importorskip(</span><span class="s2">&quot;pandas&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">check_parts(df</span><span class="s0">, </span><span class="s1">sol):</span>
        <span class="s0">assert </span><span class="s1">all(</span>
            <span class="s1">(p.dtypes == sol.dtypes).all() </span><span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">dask.compute(*df.to_delayed())</span>
        <span class="s1">)</span>

    <span class="s1">dsk = {(</span><span class="s2">&quot;test&quot;</span><span class="s0">, </span><span class="s3">0</span><span class="s1">): [(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;test&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s1">): []</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;test&quot;</span><span class="s0">, </span><span class="s3">2</span><span class="s1">): [(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">20</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">100</span><span class="s0">, </span><span class="s3">200</span><span class="s1">)]}</span>
    <span class="s1">b = Bag(dsk</span><span class="s0">, </span><span class="s2">&quot;test&quot;</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">sol = pd.DataFrame(b.compute()</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">])</span>

    <span class="s4"># Elements are tuples</span>
    <span class="s1">df = b.to_dataframe()</span>
    <span class="s1">dd.utils.assert_eq(df</span><span class="s0">, </span><span class="s1">sol.rename(columns={</span><span class="s2">&quot;a&quot;</span><span class="s1">: </span><span class="s3">0</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: </span><span class="s3">1</span><span class="s1">})</span><span class="s0">, </span><span class="s1">check_index=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">df = b.to_dataframe(columns=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">])</span>
    <span class="s1">dd.utils.assert_eq(df</span><span class="s0">, </span><span class="s1">sol</span><span class="s0">, </span><span class="s1">check_index=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">check_parts(df</span><span class="s0">, </span><span class="s1">sol)</span>
    <span class="s1">df = b.to_dataframe(meta=[(</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;i8&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;i8&quot;</span><span class="s1">)])</span>
    <span class="s1">dd.utils.assert_eq(df</span><span class="s0">, </span><span class="s1">sol</span><span class="s0">, </span><span class="s1">check_index=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">check_parts(df</span><span class="s0">, </span><span class="s1">sol)</span>

    <span class="s4"># Elements are dictionaries</span>
    <span class="s1">b = b.map(</span><span class="s0">lambda </span><span class="s1">x: dict(zip([</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x)))</span>
    <span class="s1">df = b.to_dataframe()</span>
    <span class="s1">dd.utils.assert_eq(df</span><span class="s0">, </span><span class="s1">sol</span><span class="s0">, </span><span class="s1">check_index=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">check_parts(df</span><span class="s0">, </span><span class="s1">sol)</span>
    <span class="s0">assert </span><span class="s1">df._name == b.to_dataframe()._name</span>

    <span class="s4"># With metadata specified</span>
    <span class="s0">for </span><span class="s1">meta </span><span class="s0">in </span><span class="s1">[sol</span><span class="s0">, </span><span class="s1">[(</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;i8&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;i8&quot;</span><span class="s1">)]]:</span>
        <span class="s1">df = b.to_dataframe(meta=meta)</span>
        <span class="s1">dd.utils.assert_eq(df</span><span class="s0">, </span><span class="s1">sol</span><span class="s0">, </span><span class="s1">check_index=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">check_parts(df</span><span class="s0">, </span><span class="s1">sol)</span>

    <span class="s4"># Error to specify both columns and meta</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">b.to_dataframe(columns=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">meta=sol)</span>

    <span class="s4"># Inference fails if empty first partition</span>
    <span class="s1">b2 = b.filter(</span><span class="s0">lambda </span><span class="s1">x: x[</span><span class="s2">&quot;a&quot;</span><span class="s1">] &gt; </span><span class="s3">200</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">b2.to_dataframe()</span>

    <span class="s4"># Single column</span>
    <span class="s1">b = b.pluck(</span><span class="s2">&quot;a&quot;</span><span class="s1">)</span>
    <span class="s1">sol = sol[[</span><span class="s2">&quot;a&quot;</span><span class="s1">]]</span>
    <span class="s1">df = b.to_dataframe(meta=sol)</span>
    <span class="s1">dd.utils.assert_eq(df</span><span class="s0">, </span><span class="s1">sol</span><span class="s0">, </span><span class="s1">check_index=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">check_parts(df</span><span class="s0">, </span><span class="s1">sol)</span>

    <span class="s4"># Works with iterators and tuples</span>
    <span class="s1">sol = pd.DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: range(</span><span class="s3">100</span><span class="s1">)})</span>
    <span class="s1">b = db.from_sequence(range(</span><span class="s3">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">5</span><span class="s1">)</span>
    <span class="s0">for </span><span class="s1">f </span><span class="s0">in </span><span class="s1">[iter</span><span class="s0">, </span><span class="s1">tuple]:</span>
        <span class="s1">df = b.map_partitions(f).to_dataframe(meta=sol)</span>
        <span class="s1">dd.utils.assert_eq(df</span><span class="s0">, </span><span class="s1">sol</span><span class="s0">, </span><span class="s1">check_index=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">check_parts(df</span><span class="s0">, </span><span class="s1">sol)</span>


<span class="s1">ext_open = [(</span><span class="s2">&quot;gz&quot;</span><span class="s0">, </span><span class="s1">GzipFile)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;bz2&quot;</span><span class="s0">, </span><span class="s1">BZ2File)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s1">open)]</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;ext,myopen&quot;</span><span class="s0">, </span><span class="s1">ext_open)</span>
<span class="s0">def </span><span class="s1">test_to_textfiles(ext</span><span class="s0">, </span><span class="s1">myopen):</span>
    <span class="s1">b = db.from_sequence([</span><span class="s2">&quot;abc&quot;</span><span class="s0">, </span><span class="s2">&quot;123&quot;</span><span class="s0">, </span><span class="s2">&quot;xyz&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">tmpdir() </span><span class="s0">as </span><span class="s1">dir:</span>
        <span class="s1">c = b.to_textfiles(os.path.join(dir</span><span class="s0">, </span><span class="s2">&quot;*.&quot; </span><span class="s1">+ ext)</span><span class="s0">, </span><span class="s1">compute=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">dask.compute(*c</span><span class="s0">, </span><span class="s1">scheduler=</span><span class="s2">&quot;sync&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">os.path.exists(os.path.join(dir</span><span class="s0">, </span><span class="s2">&quot;1.&quot; </span><span class="s1">+ ext))</span>

        <span class="s1">f = myopen(os.path.join(dir</span><span class="s0">, </span><span class="s2">&quot;1.&quot; </span><span class="s1">+ ext)</span><span class="s0">, </span><span class="s2">&quot;rb&quot;</span><span class="s1">)</span>
        <span class="s1">text = f.read()</span>
        <span class="s0">if </span><span class="s1">hasattr(text</span><span class="s0">, </span><span class="s2">&quot;decode&quot;</span><span class="s1">):</span>
            <span class="s1">text = text.decode()</span>
        <span class="s0">assert </span><span class="s2">&quot;xyz&quot; </span><span class="s0">in </span><span class="s1">text</span>
        <span class="s1">f.close()</span>


<span class="s0">def </span><span class="s1">test_to_textfiles_name_function_preserves_order():</span>
    <span class="s1">seq = [</span>
        <span class="s2">&quot;a&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;b&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;c&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;d&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;e&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;f&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;g&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;h&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;i&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;j&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;k&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;l&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;m&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;n&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;o&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;p&quot;</span><span class="s0">,</span>
    <span class="s1">]</span>
    <span class="s1">b = db.from_sequence(seq</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">16</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">tmpdir() </span><span class="s0">as </span><span class="s1">dn:</span>
        <span class="s1">b.to_textfiles(dn)</span>

        <span class="s1">out = (</span>
            <span class="s1">db.read_text(os.path.join(dn</span><span class="s0">, </span><span class="s2">&quot;*&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">encoding=</span><span class="s2">&quot;ascii&quot;</span><span class="s1">)</span>
            <span class="s1">.map(str)</span>
            <span class="s1">.map(str.strip)</span>
            <span class="s1">.compute()</span>
        <span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">seq == out</span>


<span class="s0">def </span><span class="s1">test_to_textfiles_name_function_warn():</span>
    <span class="s1">seq = [</span>
        <span class="s2">&quot;a&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;b&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;c&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;d&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;e&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;f&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;g&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;h&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;i&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;j&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;k&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;l&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;m&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;n&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;o&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;p&quot;</span><span class="s0">,</span>
    <span class="s1">]</span>
    <span class="s1">a = db.from_sequence(seq</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">16</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">tmpdir() </span><span class="s0">as </span><span class="s1">dn:</span>
        <span class="s1">a.to_textfiles(dn</span><span class="s0">, </span><span class="s1">name_function=str)</span>


<span class="s0">def </span><span class="s1">test_to_textfiles_encoding():</span>
    <span class="s1">b = db.from_sequence([</span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s0">for </span><span class="s1">ext</span><span class="s0">, </span><span class="s1">myopen </span><span class="s0">in </span><span class="s1">ext_open:</span>
        <span class="s0">with </span><span class="s1">tmpdir() </span><span class="s0">as </span><span class="s1">dir:</span>
            <span class="s1">c = b.to_textfiles(</span>
                <span class="s1">os.path.join(dir</span><span class="s0">, </span><span class="s2">&quot;*.&quot; </span><span class="s1">+ ext)</span><span class="s0">, </span><span class="s1">encoding=</span><span class="s2">&quot;gb18030&quot;</span><span class="s0">, </span><span class="s1">compute=</span><span class="s0">False</span>
            <span class="s1">)</span>
            <span class="s1">dask.compute(*c)</span>
            <span class="s0">assert </span><span class="s1">os.path.exists(os.path.join(dir</span><span class="s0">, </span><span class="s2">&quot;1.&quot; </span><span class="s1">+ ext))</span>

            <span class="s1">f = myopen(os.path.join(dir</span><span class="s0">, </span><span class="s2">&quot;1.&quot; </span><span class="s1">+ ext)</span><span class="s0">, </span><span class="s2">&quot;rb&quot;</span><span class="s1">)</span>
            <span class="s1">text = f.read()</span>
            <span class="s0">if </span><span class="s1">hasattr(text</span><span class="s0">, </span><span class="s2">&quot;decode&quot;</span><span class="s1">):</span>
                <span class="s1">text = text.decode(</span><span class="s2">&quot;gb18030&quot;</span><span class="s1">)</span>
            <span class="s0">assert </span><span class="s2">&quot;&quot; </span><span class="s0">in </span><span class="s1">text</span>
            <span class="s1">f.close()</span>


<span class="s0">def </span><span class="s1">test_to_textfiles_inputs():</span>
    <span class="s1">B = db.from_sequence([</span><span class="s2">&quot;abc&quot;</span><span class="s0">, </span><span class="s2">&quot;123&quot;</span><span class="s0">, </span><span class="s2">&quot;xyz&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">tmpfile() </span><span class="s0">as </span><span class="s1">a:</span>
        <span class="s0">with </span><span class="s1">tmpfile() </span><span class="s0">as </span><span class="s1">b:</span>
            <span class="s1">B.to_textfiles([a</span><span class="s0">, </span><span class="s1">b])</span>
            <span class="s0">assert </span><span class="s1">os.path.exists(a)</span>
            <span class="s0">assert </span><span class="s1">os.path.exists(b)</span>

    <span class="s0">with </span><span class="s1">tmpdir() </span><span class="s0">as </span><span class="s1">dirname:</span>
        <span class="s1">B.to_textfiles(dirname)</span>
        <span class="s0">assert </span><span class="s1">os.path.exists(dirname)</span>
        <span class="s0">assert </span><span class="s1">os.path.exists(os.path.join(dirname</span><span class="s0">, </span><span class="s2">&quot;0.part&quot;</span><span class="s1">))</span>

    <span class="s0">with </span><span class="s1">pytest.raises(TypeError):</span>
        <span class="s1">B.to_textfiles(</span><span class="s3">5</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_to_textfiles_endlines():</span>
    <span class="s1">b = db.from_sequence([</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">tmpfile() </span><span class="s0">as </span><span class="s1">fn:</span>
        <span class="s0">for </span><span class="s1">last_endline </span><span class="s0">in False, True</span><span class="s1">:</span>
            <span class="s1">b.to_textfiles([fn]</span><span class="s0">, </span><span class="s1">last_endline=last_endline)</span>
            <span class="s0">with </span><span class="s1">open(fn) </span><span class="s0">as </span><span class="s1">f:</span>
                <span class="s1">result = f.readlines()</span>
            <span class="s0">assert </span><span class="s1">result == [</span><span class="s2">&quot;a</span><span class="s0">\n</span><span class="s2">&quot;</span><span class="s0">, </span><span class="s2">&quot;b</span><span class="s0">\n</span><span class="s2">&quot;</span><span class="s0">, </span><span class="s2">&quot;c</span><span class="s0">\n</span><span class="s2">&quot; </span><span class="s0">if </span><span class="s1">last_endline </span><span class="s0">else </span><span class="s2">&quot;c&quot;</span><span class="s1">]</span>


<span class="s0">def </span><span class="s1">test_string_namespace():</span>
    <span class="s1">b = db.from_sequence([</span><span class="s2">&quot;Alice Smith&quot;</span><span class="s0">, </span><span class="s2">&quot;Bob Jones&quot;</span><span class="s0">, </span><span class="s2">&quot;Charlie Smith&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">2</span><span class="s1">)</span>

    <span class="s0">assert </span><span class="s2">&quot;split&quot; </span><span class="s0">in </span><span class="s1">dir(b.str)</span>
    <span class="s0">assert </span><span class="s2">&quot;match&quot; </span><span class="s0">in </span><span class="s1">dir(b.str)</span>

    <span class="s0">assert </span><span class="s1">list(b.str.lower()) == [</span><span class="s2">&quot;alice smith&quot;</span><span class="s0">, </span><span class="s2">&quot;bob jones&quot;</span><span class="s0">, </span><span class="s2">&quot;charlie smith&quot;</span><span class="s1">]</span>
    <span class="s0">assert </span><span class="s1">list(b.str.split(</span><span class="s2">&quot; &quot;</span><span class="s1">)) == [</span>
        <span class="s1">[</span><span class="s2">&quot;Alice&quot;</span><span class="s0">, </span><span class="s2">&quot;Smith&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">&quot;Bob&quot;</span><span class="s0">, </span><span class="s2">&quot;Jones&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">&quot;Charlie&quot;</span><span class="s0">, </span><span class="s2">&quot;Smith&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">]</span>
    <span class="s0">assert </span><span class="s1">list(b.str.match(</span><span class="s2">&quot;*Smith&quot;</span><span class="s1">)) == [</span><span class="s2">&quot;Alice Smith&quot;</span><span class="s0">, </span><span class="s2">&quot;Charlie Smith&quot;</span><span class="s1">]</span>

    <span class="s1">pytest.raises(AttributeError</span><span class="s0">, lambda</span><span class="s1">: b.str.sfohsofhf)</span>
    <span class="s0">assert </span><span class="s1">b.str.match(</span><span class="s2">&quot;*Smith&quot;</span><span class="s1">).name == b.str.match(</span><span class="s2">&quot;*Smith&quot;</span><span class="s1">).name</span>
    <span class="s0">assert </span><span class="s1">b.str.match(</span><span class="s2">&quot;*Smith&quot;</span><span class="s1">).name != b.str.match(</span><span class="s2">&quot;*John&quot;</span><span class="s1">).name</span>


<span class="s0">def </span><span class="s1">test_string_namespace_with_unicode():</span>
    <span class="s1">b = db.from_sequence([</span><span class="s2">&quot;Alice Smith&quot;</span><span class="s0">, </span><span class="s2">&quot;Bob Jones&quot;</span><span class="s0">, </span><span class="s2">&quot;Charlie Smith&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">list(b.str.lower()) == [</span><span class="s2">&quot;alice smith&quot;</span><span class="s0">, </span><span class="s2">&quot;bob jones&quot;</span><span class="s0">, </span><span class="s2">&quot;charlie smith&quot;</span><span class="s1">]</span>


<span class="s0">def </span><span class="s1">test_str_empty_split():</span>
    <span class="s1">b = db.from_sequence([</span><span class="s2">&quot;Alice Smith&quot;</span><span class="s0">, </span><span class="s2">&quot;Bob Jones&quot;</span><span class="s0">, </span><span class="s2">&quot;Charlie Smith&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">list(b.str.split()) == [</span>
        <span class="s1">[</span><span class="s2">&quot;Alice&quot;</span><span class="s0">, </span><span class="s2">&quot;Smith&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">&quot;Bob&quot;</span><span class="s0">, </span><span class="s2">&quot;Jones&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">&quot;Charlie&quot;</span><span class="s0">, </span><span class="s2">&quot;Smith&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">]</span>


<span class="s0">def </span><span class="s1">test_map_with_iterator_function():</span>
    <span class="s1">b = db.from_sequence([[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">2</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">f(L):</span>
        <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">L:</span>
            <span class="s0">yield </span><span class="s1">x + </span><span class="s3">1</span>

    <span class="s1">c = b.map(f)</span>

    <span class="s0">assert </span><span class="s1">list(c) == [[</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">7</span><span class="s1">]]</span>


<span class="s0">def </span><span class="s1">test_ensure_compute_output_is_concrete():</span>
    <span class="s1">b = db.from_sequence([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">])</span>
    <span class="s1">result = b.map(</span><span class="s0">lambda </span><span class="s1">x: x + </span><span class="s3">1</span><span class="s1">).compute()</span>
    <span class="s0">assert not </span><span class="s1">isinstance(result</span><span class="s0">, </span><span class="s1">Iterator)</span>


<span class="s0">class </span><span class="s1">BagOfDicts(db.Bag):</span>
    <span class="s0">def </span><span class="s1">get(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">default=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s0">return </span><span class="s1">self.map(</span><span class="s0">lambda </span><span class="s1">d: d.get(key</span><span class="s0">, </span><span class="s1">default))</span>

    <span class="s0">def </span><span class="s1">set(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s0">def </span><span class="s1">setter(d):</span>
            <span class="s1">d[key] = value</span>
            <span class="s0">return </span><span class="s1">d</span>

        <span class="s0">return </span><span class="s1">self.map(setter)</span>


<span class="s0">def </span><span class="s1">test_bag_class_extend():</span>
    <span class="s1">dictbag = BagOfDicts(*db.from_sequence([{</span><span class="s2">&quot;a&quot;</span><span class="s1">: {</span><span class="s2">&quot;b&quot;</span><span class="s1">: </span><span class="s2">&quot;c&quot;</span><span class="s1">}}])._args)</span>
    <span class="s0">assert </span><span class="s1">dictbag.get(</span><span class="s2">&quot;a&quot;</span><span class="s1">).get(</span><span class="s2">&quot;b&quot;</span><span class="s1">).compute()[</span><span class="s3">0</span><span class="s1">] == </span><span class="s2">&quot;c&quot;</span>
    <span class="s0">assert </span><span class="s1">dictbag.get(</span><span class="s2">&quot;a&quot;</span><span class="s1">).set(</span><span class="s2">&quot;d&quot;</span><span class="s0">, </span><span class="s2">&quot;EXTENSIBILITY!!!&quot;</span><span class="s1">).compute()[</span><span class="s3">0</span><span class="s1">] == {</span>
        <span class="s2">&quot;b&quot;</span><span class="s1">: </span><span class="s2">&quot;c&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;d&quot;</span><span class="s1">: </span><span class="s2">&quot;EXTENSIBILITY!!!&quot;</span><span class="s0">,</span>
    <span class="s1">}</span>
    <span class="s0">assert </span><span class="s1">isinstance(dictbag.get(</span><span class="s2">&quot;a&quot;</span><span class="s1">).get(</span><span class="s2">&quot;b&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">BagOfDicts)</span>


<span class="s0">def </span><span class="s1">test_gh715():</span>
    <span class="s1">bin_data = </span><span class="s2">&quot;</span><span class="s0">\u20ac</span><span class="s2">&quot;</span><span class="s1">.encode()</span>
    <span class="s0">with </span><span class="s1">tmpfile() </span><span class="s0">as </span><span class="s1">fn:</span>
        <span class="s0">with </span><span class="s1">open(fn</span><span class="s0">, </span><span class="s2">&quot;wb&quot;</span><span class="s1">) </span><span class="s0">as </span><span class="s1">f:</span>
            <span class="s1">f.write(bin_data)</span>
        <span class="s1">a = db.read_text(fn)</span>
        <span class="s0">assert </span><span class="s1">a.compute()[</span><span class="s3">0</span><span class="s1">] == bin_data.decode(</span><span class="s2">&quot;utf-8&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_bag_compute_forward_kwargs():</span>
    <span class="s1">x = db.from_sequence([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]).map(</span><span class="s0">lambda </span><span class="s1">a: a + </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">x.compute(bogus_keyword=</span><span class="s3">10</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_to_delayed():</span>
    <span class="s1">b = db.from_sequence([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s1">]</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">c = b.map(inc).to_delayed()</span>
    <span class="s0">assert </span><span class="s1">all(isinstance(x</span><span class="s0">, </span><span class="s1">Delayed) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">[a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">c])</span>
    <span class="s0">assert </span><span class="s1">b.compute() == [</span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]</span>

    <span class="s1">b = db.from_sequence([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s1">]</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">t = b.sum().to_delayed()</span>
    <span class="s0">assert </span><span class="s1">isinstance(t</span><span class="s0">, </span><span class="s1">Delayed)</span>
    <span class="s0">assert </span><span class="s1">t.compute() == </span><span class="s3">21</span>


<span class="s0">def </span><span class="s1">test_to_delayed_optimize_graph(tmpdir):</span>
    <span class="s1">b = db.from_sequence([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s1">]</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">b2 = b.map(inc).map(inc).map(inc)</span>

    <span class="s1">[d] = b2.to_delayed()</span>
    <span class="s1">text = str(dict(d.dask))</span>
    <span class="s0">assert </span><span class="s1">text.count(</span><span class="s2">&quot;reify&quot;</span><span class="s1">) == </span><span class="s3">1</span>
    <span class="s0">assert </span><span class="s1">d.__dask_layers__() != b2.__dask_layers__()</span>
    <span class="s1">[d2] = b2.to_delayed(optimize_graph=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">dict(d2.dask) == dict(b2.dask)</span>
    <span class="s0">assert </span><span class="s1">d2.__dask_layers__() == b2.__dask_layers__()</span>
    <span class="s0">assert </span><span class="s1">d.compute() == d2.compute()</span>

    <span class="s1">x = b2.sum()</span>
    <span class="s1">d = x.to_delayed()</span>
    <span class="s1">text = str(dict(d.dask))</span>
    <span class="s0">assert </span><span class="s1">d.__dask_layers__() == x.__dask_layers__()</span>
    <span class="s0">assert </span><span class="s1">text.count(</span><span class="s2">&quot;reify&quot;</span><span class="s1">) == </span><span class="s3">0</span>
    <span class="s1">d2 = x.to_delayed(optimize_graph=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">dict(d2.dask) == dict(x.dask)</span>
    <span class="s0">assert </span><span class="s1">d2.__dask_layers__() == x.__dask_layers__()</span>
    <span class="s0">assert </span><span class="s1">d.compute() == d2.compute()</span>

    <span class="s1">[d] = b2.to_textfiles(str(tmpdir)</span><span class="s0">, </span><span class="s1">compute=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">text = str(dict(d.dask))</span>
    <span class="s0">assert </span><span class="s1">text.count(</span><span class="s2">&quot;reify&quot;</span><span class="s1">) &lt;= </span><span class="s3">0</span>


<span class="s0">def </span><span class="s1">test_from_delayed():</span>
    <span class="s0">from </span><span class="s1">dask.delayed </span><span class="s0">import </span><span class="s1">delayed</span>

    <span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">c = delayed([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">])</span><span class="s0">, </span><span class="s1">delayed([</span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s1">])</span><span class="s0">, </span><span class="s1">delayed([</span><span class="s3">7</span><span class="s0">, </span><span class="s3">8</span><span class="s0">, </span><span class="s3">9</span><span class="s1">])</span>
    <span class="s1">bb = from_delayed([a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">c])</span>
    <span class="s0">assert </span><span class="s1">bb.name == from_delayed([a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">c]).name</span>

    <span class="s0">assert </span><span class="s1">isinstance(bb</span><span class="s0">, </span><span class="s1">Bag)</span>
    <span class="s0">assert </span><span class="s1">list(bb) == [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s3">8</span><span class="s0">, </span><span class="s3">9</span><span class="s1">]</span>

    <span class="s1">asum_value = delayed(sum)(a)</span>
    <span class="s1">asum_item = db.Item.from_delayed(asum_value)</span>
    <span class="s0">assert </span><span class="s1">asum_value.compute() == asum_item.compute() == </span><span class="s3">6</span>


<span class="s0">def </span><span class="s1">test_from_delayed_iterator():</span>
    <span class="s0">from </span><span class="s1">dask.delayed </span><span class="s0">import </span><span class="s1">delayed</span>

    <span class="s0">def </span><span class="s1">lazy_records(n):</span>
        <span class="s0">return </span><span class="s1">({</span><span class="s2">&quot;operations&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]} </span><span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(n))</span>

    <span class="s1">delayed_records = delayed(lazy_records</span><span class="s0">, </span><span class="s1">pure=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">bag = db.from_delayed([delayed_records(</span><span class="s3">5</span><span class="s1">) </span><span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">5</span><span class="s1">)])</span>
    <span class="s0">assert </span><span class="s1">db.compute(</span>
        <span class="s1">bag.count()</span><span class="s0">,</span>
        <span class="s1">bag.pluck(</span><span class="s2">&quot;operations&quot;</span><span class="s1">).count()</span><span class="s0">,</span>
        <span class="s1">bag.pluck(</span><span class="s2">&quot;operations&quot;</span><span class="s1">).flatten().count()</span><span class="s0">,</span>
        <span class="s1">scheduler=</span><span class="s2">&quot;sync&quot;</span><span class="s0">,</span>
    <span class="s1">) == (</span><span class="s3">25</span><span class="s0">, </span><span class="s3">25</span><span class="s0">, </span><span class="s3">50</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_range():</span>
    <span class="s0">for </span><span class="s1">npartitions </span><span class="s0">in </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s3">28</span><span class="s1">]:</span>
        <span class="s1">b = db.range(</span><span class="s3">100</span><span class="s0">, </span><span class="s1">npartitions=npartitions)</span>
        <span class="s0">assert </span><span class="s1">len(b.dask) == npartitions</span>
        <span class="s0">assert </span><span class="s1">b.npartitions == npartitions</span>
        <span class="s0">assert </span><span class="s1">list(b) == list(range(</span><span class="s3">100</span><span class="s1">))</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;npartitions&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s3">28</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_zip(npartitions</span><span class="s0">, </span><span class="s1">hi=</span><span class="s3">1000</span><span class="s1">):</span>
    <span class="s1">evens = db.from_sequence(range(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">hi</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">npartitions=npartitions)</span>
    <span class="s1">odds = db.from_sequence(range(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">hi</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">npartitions=npartitions)</span>
    <span class="s1">pairs = db.zip(evens</span><span class="s0">, </span><span class="s1">odds)</span>
    <span class="s0">assert </span><span class="s1">pairs.npartitions == evens.npartitions</span>
    <span class="s0">assert </span><span class="s1">pairs.npartitions == odds.npartitions</span>
    <span class="s0">assert </span><span class="s1">list(pairs) == list(zip(range(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">hi</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">range(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">hi</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)))</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;nin&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s3">11</span><span class="s0">, </span><span class="s3">23</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;nout&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">12</span><span class="s0">, </span><span class="s3">23</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_repartition_npartitions(nin</span><span class="s0">, </span><span class="s1">nout):</span>
    <span class="s1">b = db.from_sequence(range(</span><span class="s3">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">npartitions=nin)</span>
    <span class="s1">c = b.repartition(npartitions=nout)</span>
    <span class="s0">assert </span><span class="s1">c.npartitions == nout</span>
    <span class="s1">assert_eq(b</span><span class="s0">, </span><span class="s1">c)</span>
    <span class="s1">results = dask.get(c.dask</span><span class="s0">, </span><span class="s1">c.__dask_keys__())</span>
    <span class="s0">assert </span><span class="s1">all(results)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;nin, nout&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_repartition_partition_size(nin</span><span class="s0">, </span><span class="s1">nout):</span>
    <span class="s1">b = db.from_sequence(range(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">npartitions=nin)</span>
    <span class="s1">total_mem = sum(b.map_partitions(total_mem_usage).compute())</span>
    <span class="s1">c = b.repartition(partition_size=(total_mem // nout))</span>
    <span class="s0">assert </span><span class="s1">c.npartitions &gt;= nout</span>
    <span class="s1">assert_eq(b</span><span class="s0">, </span><span class="s1">c)</span>


<span class="s0">def </span><span class="s1">test_multiple_repartition_partition_size():</span>
    <span class="s1">b = db.from_sequence(range(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">total_mem = sum(b.map_partitions(total_mem_usage).compute())</span>

    <span class="s1">c = b.repartition(partition_size=(total_mem // </span><span class="s3">2</span><span class="s1">))</span>
    <span class="s0">assert </span><span class="s1">c.npartitions &gt;= </span><span class="s3">2</span>
    <span class="s1">assert_eq(b</span><span class="s0">, </span><span class="s1">c)</span>

    <span class="s1">d = c.repartition(partition_size=(total_mem // </span><span class="s3">5</span><span class="s1">))</span>
    <span class="s0">assert </span><span class="s1">d.npartitions &gt;= </span><span class="s3">5</span>
    <span class="s1">assert_eq(c</span><span class="s0">, </span><span class="s1">d)</span>


<span class="s0">def </span><span class="s1">test_repartition_partition_size_complex_dtypes():</span>
    <span class="s1">np = pytest.importorskip(</span><span class="s2">&quot;numpy&quot;</span><span class="s1">)</span>

    <span class="s1">b = db.from_sequence([np.array(range(</span><span class="s3">100</span><span class="s1">)) </span><span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">4</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">total_mem = sum(b.map_partitions(total_mem_usage).compute())</span>

    <span class="s1">new_partition_size = total_mem // </span><span class="s3">4</span>
    <span class="s1">c = b.repartition(partition_size=new_partition_size)</span>
    <span class="s0">assert </span><span class="s1">c.npartitions &gt;= </span><span class="s3">4</span>
    <span class="s1">assert_eq(b</span><span class="s0">, </span><span class="s1">c)</span>


<span class="s0">def </span><span class="s1">test_repartition_names():</span>
    <span class="s1">b = db.from_sequence(range(</span><span class="s3">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">5</span><span class="s1">)</span>
    <span class="s1">c = b.repartition(</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">b.name != c.name</span>

    <span class="s1">d = b.repartition(</span><span class="s3">20</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">b.name != c.name</span>
    <span class="s0">assert </span><span class="s1">c.name != d.name</span>

    <span class="s1">c = b.repartition(</span><span class="s3">5</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">b </span><span class="s0">is </span><span class="s1">c</span>


<span class="s0">def </span><span class="s1">test_repartition_input_errors():</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">bag = db.from_sequence(range(</span><span class="s3">10</span><span class="s1">))</span>
        <span class="s1">bag.repartition(npartitions=</span><span class="s3">5</span><span class="s0">, </span><span class="s1">partition_size=</span><span class="s2">&quot;5MiB&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_accumulate():</span>
    <span class="s1">parts = [[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">6</span><span class="s0">, </span><span class="s3">7</span><span class="s1">]]</span>
    <span class="s1">dsk = {(</span><span class="s2">&quot;test&quot;</span><span class="s0">, </span><span class="s1">i): p </span><span class="s0">for </span><span class="s1">(i</span><span class="s0">, </span><span class="s1">p) </span><span class="s0">in </span><span class="s1">enumerate(parts)}</span>
    <span class="s1">b = db.Bag(dsk</span><span class="s0">, </span><span class="s2">&quot;test&quot;</span><span class="s0">, </span><span class="s1">len(parts))</span>
    <span class="s1">r = b.accumulate(add)</span>
    <span class="s0">assert </span><span class="s1">r.name == b.accumulate(add).name</span>
    <span class="s0">assert </span><span class="s1">r.name != b.accumulate(add</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">).name</span>
    <span class="s0">assert </span><span class="s1">r.compute() == [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">6</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s3">15</span><span class="s0">, </span><span class="s3">21</span><span class="s0">, </span><span class="s3">28</span><span class="s1">]</span>
    <span class="s0">assert </span><span class="s1">b.accumulate(add</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">).compute() == [-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">9</span><span class="s0">, </span><span class="s3">14</span><span class="s0">, </span><span class="s3">20</span><span class="s0">, </span><span class="s3">27</span><span class="s1">]</span>
    <span class="s0">assert </span><span class="s1">b.accumulate(add).map(inc).compute() == [</span><span class="s3">2</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s3">11</span><span class="s0">, </span><span class="s3">16</span><span class="s0">, </span><span class="s3">22</span><span class="s0">, </span><span class="s3">29</span><span class="s1">]</span>

    <span class="s1">b = db.from_sequence([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">b.accumulate(add).compute() == [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">6</span><span class="s1">]</span>


<span class="s0">def </span><span class="s1">test_groupby_tasks():</span>
    <span class="s1">b = db.from_sequence(range(</span><span class="s3">160</span><span class="s1">)</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">out = b.groupby(</span><span class="s0">lambda </span><span class="s1">x: x % </span><span class="s3">10</span><span class="s0">, </span><span class="s1">max_branch=</span><span class="s3">4</span><span class="s0">, </span><span class="s1">shuffle=</span><span class="s2">&quot;tasks&quot;</span><span class="s1">)</span>
    <span class="s1">partitions = dask.get(out.dask</span><span class="s0">, </span><span class="s1">out.__dask_keys__())</span>

    <span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">partitions:</span>
        <span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">partitions:</span>
            <span class="s0">if </span><span class="s1">a </span><span class="s0">is not </span><span class="s1">b:</span>
                <span class="s0">assert not </span><span class="s1">set(pluck(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">a)) &amp; set(pluck(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">b))</span>

    <span class="s1">b = db.from_sequence(range(</span><span class="s3">1000</span><span class="s1">)</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">100</span><span class="s1">)</span>
    <span class="s1">out = b.groupby(</span><span class="s0">lambda </span><span class="s1">x: x % </span><span class="s3">123</span><span class="s0">, </span><span class="s1">shuffle=</span><span class="s2">&quot;tasks&quot;</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">len(out.dask) &lt; </span><span class="s3">100</span><span class="s1">**</span><span class="s3">2</span>
    <span class="s1">partitions = dask.get(out.dask</span><span class="s0">, </span><span class="s1">out.__dask_keys__())</span>

    <span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">partitions:</span>
        <span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">partitions:</span>
            <span class="s0">if </span><span class="s1">a </span><span class="s0">is not </span><span class="s1">b:</span>
                <span class="s0">assert not </span><span class="s1">set(pluck(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">a)) &amp; set(pluck(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">b))</span>

    <span class="s1">b = db.from_sequence(range(</span><span class="s3">10000</span><span class="s1">)</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">345</span><span class="s1">)</span>
    <span class="s1">out = b.groupby(</span><span class="s0">lambda </span><span class="s1">x: x % </span><span class="s3">2834</span><span class="s0">, </span><span class="s1">max_branch=</span><span class="s3">24</span><span class="s0">, </span><span class="s1">shuffle=</span><span class="s2">&quot;tasks&quot;</span><span class="s1">)</span>
    <span class="s1">partitions = dask.get(out.dask</span><span class="s0">, </span><span class="s1">out.__dask_keys__())</span>

    <span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">partitions:</span>
        <span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">partitions:</span>
            <span class="s0">if </span><span class="s1">a </span><span class="s0">is not </span><span class="s1">b:</span>
                <span class="s0">assert not </span><span class="s1">set(pluck(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">a)) &amp; set(pluck(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">b))</span>


<span class="s0">def </span><span class="s1">test_groupby_tasks_names():</span>
    <span class="s1">b = db.from_sequence(range(</span><span class="s3">160</span><span class="s1">)</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">func = </span><span class="s0">lambda </span><span class="s1">x: x % </span><span class="s3">10</span>
    <span class="s1">func2 = </span><span class="s0">lambda </span><span class="s1">x: x % </span><span class="s3">20</span>
    <span class="s0">assert </span><span class="s1">set(b.groupby(func</span><span class="s0">, </span><span class="s1">max_branch=</span><span class="s3">4</span><span class="s0">, </span><span class="s1">shuffle=</span><span class="s2">&quot;tasks&quot;</span><span class="s1">).dask) == set(</span>
        <span class="s1">b.groupby(func</span><span class="s0">, </span><span class="s1">max_branch=</span><span class="s3">4</span><span class="s0">, </span><span class="s1">shuffle=</span><span class="s2">&quot;tasks&quot;</span><span class="s1">).dask</span>
    <span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">set(b.groupby(func</span><span class="s0">, </span><span class="s1">max_branch=</span><span class="s3">4</span><span class="s0">, </span><span class="s1">shuffle=</span><span class="s2">&quot;tasks&quot;</span><span class="s1">).dask) != set(</span>
        <span class="s1">b.groupby(func</span><span class="s0">, </span><span class="s1">max_branch=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">shuffle=</span><span class="s2">&quot;tasks&quot;</span><span class="s1">).dask</span>
    <span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">set(b.groupby(func</span><span class="s0">, </span><span class="s1">max_branch=</span><span class="s3">4</span><span class="s0">, </span><span class="s1">shuffle=</span><span class="s2">&quot;tasks&quot;</span><span class="s1">).dask) != set(</span>
        <span class="s1">b.groupby(func2</span><span class="s0">, </span><span class="s1">max_branch=</span><span class="s3">4</span><span class="s0">, </span><span class="s1">shuffle=</span><span class="s2">&quot;tasks&quot;</span><span class="s1">).dask</span>
    <span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;size,npartitions,groups&quot;</span><span class="s0">, </span><span class="s1">[(</span><span class="s3">1000</span><span class="s0">, </span><span class="s3">20</span><span class="s0">, </span><span class="s3">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">12345</span><span class="s0">, </span><span class="s3">234</span><span class="s0">, </span><span class="s3">1042</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">100</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">50</span><span class="s1">)]</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_groupby_tasks_2(size</span><span class="s0">, </span><span class="s1">npartitions</span><span class="s0">, </span><span class="s1">groups):</span>
    <span class="s1">func = </span><span class="s0">lambda </span><span class="s1">x: x % groups</span>
    <span class="s1">b = db.range(size</span><span class="s0">, </span><span class="s1">npartitions=npartitions).groupby(func</span><span class="s0">, </span><span class="s1">shuffle=</span><span class="s2">&quot;tasks&quot;</span><span class="s1">)</span>
    <span class="s1">result = b.compute(scheduler=</span><span class="s2">&quot;sync&quot;</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">dict(result) == groupby(func</span><span class="s0">, </span><span class="s1">range(size))</span>


<span class="s0">def </span><span class="s1">test_groupby_tasks_3():</span>
    <span class="s1">func = </span><span class="s0">lambda </span><span class="s1">x: x % </span><span class="s3">10</span>
    <span class="s1">b = db.range(</span><span class="s3">20</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">5</span><span class="s1">).groupby(func</span><span class="s0">, </span><span class="s1">shuffle=</span><span class="s2">&quot;tasks&quot;</span><span class="s0">, </span><span class="s1">max_branch=</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">result = b.compute(scheduler=</span><span class="s2">&quot;sync&quot;</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">dict(result) == groupby(func</span><span class="s0">, </span><span class="s1">range(</span><span class="s3">20</span><span class="s1">))</span>
    <span class="s4"># assert b.npartitions == 5</span>


<span class="s0">def </span><span class="s1">test_to_textfiles_empty_partitions():</span>
    <span class="s0">with </span><span class="s1">tmpdir() </span><span class="s0">as </span><span class="s1">d:</span>
        <span class="s1">b = db.range(</span><span class="s3">5</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">5</span><span class="s1">).filter(</span><span class="s0">lambda </span><span class="s1">x: x == </span><span class="s3">1</span><span class="s1">).map(str)</span>
        <span class="s1">b.to_textfiles(os.path.join(d</span><span class="s0">, </span><span class="s2">&quot;*.txt&quot;</span><span class="s1">))</span>
        <span class="s0">assert </span><span class="s1">len(os.listdir(d)) == </span><span class="s3">5</span>


<span class="s0">def </span><span class="s1">test_reduction_empty():</span>
    <span class="s1">b = db.from_sequence(range(</span><span class="s3">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">100</span><span class="s1">)</span>
    <span class="s1">assert_eq(b.filter(</span><span class="s0">lambda </span><span class="s1">x: x % </span><span class="s3">2 </span><span class="s1">== </span><span class="s3">0</span><span class="s1">).max()</span><span class="s0">, </span><span class="s3">8</span><span class="s1">)</span>
    <span class="s1">assert_eq(b.filter(</span><span class="s0">lambda </span><span class="s1">x: x % </span><span class="s3">2 </span><span class="s1">== </span><span class="s3">0</span><span class="s1">).min()</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;npartitions&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">4</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_reduction_empty_aggregate(npartitions):</span>
    <span class="s1">b = db.from_sequence([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">npartitions=npartitions).filter(</span><span class="s0">None</span><span class="s1">)</span>
    <span class="s1">assert_eq(b.min(split_every=</span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">vals = db.compute(b.min(split_every=</span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">b.max(split_every=</span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">scheduler=</span><span class="s2">&quot;sync&quot;</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">vals == (</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">b = db.from_sequence([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">npartitions=npartitions)</span>
        <span class="s1">b.filter(</span><span class="s0">None</span><span class="s1">).min(split_every=</span><span class="s3">2</span><span class="s1">).compute(scheduler=</span><span class="s2">&quot;sync&quot;</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">StrictReal(int):</span>
    <span class="s0">def </span><span class="s1">__eq__(self</span><span class="s0">, </span><span class="s1">other):</span>
        <span class="s0">assert </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">StrictReal)</span>
        <span class="s0">return </span><span class="s1">self.real == other.real</span>

    <span class="s0">def </span><span class="s1">__ne__(self</span><span class="s0">, </span><span class="s1">other):</span>
        <span class="s0">assert </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">StrictReal)</span>
        <span class="s0">return </span><span class="s1">self.real != other.real</span>


<span class="s0">def </span><span class="s1">test_reduction_with_non_comparable_objects():</span>
    <span class="s1">b = db.from_sequence([StrictReal(x) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">10</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">partition_size=</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">assert_eq(b.fold(max</span><span class="s0">, </span><span class="s1">max)</span><span class="s0">, </span><span class="s1">StrictReal(</span><span class="s3">9</span><span class="s1">))</span>


<span class="s0">def </span><span class="s1">test_reduction_with_sparse_matrices():</span>
    <span class="s1">sp = pytest.importorskip(</span><span class="s2">&quot;scipy.sparse&quot;</span><span class="s1">)</span>
    <span class="s1">b = db.from_sequence([sp.csr_matrix([</span><span class="s3">0</span><span class="s1">]) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">4</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">partition_size=</span><span class="s3">2</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">sp_reduce(a</span><span class="s0">, </span><span class="s1">b):</span>
        <span class="s0">return </span><span class="s1">sp.vstack([a</span><span class="s0">, </span><span class="s1">b])</span>

    <span class="s0">assert </span><span class="s1">b.fold(sp_reduce</span><span class="s0">, </span><span class="s1">sp_reduce).compute(scheduler=</span><span class="s2">&quot;sync&quot;</span><span class="s1">).shape == (</span><span class="s3">4</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_empty():</span>
    <span class="s0">assert </span><span class="s1">list(db.from_sequence([])) == []</span>


<span class="s0">def </span><span class="s1">test_bag_picklable():</span>
    <span class="s0">from </span><span class="s1">pickle </span><span class="s0">import </span><span class="s1">dumps</span><span class="s0">, </span><span class="s1">loads</span>

    <span class="s1">b = db.from_sequence(range(</span><span class="s3">100</span><span class="s1">))</span>
    <span class="s1">b2 = loads(dumps(b))</span>
    <span class="s0">assert </span><span class="s1">b.compute() == b2.compute()</span>

    <span class="s1">s = b.sum()</span>
    <span class="s1">s2 = loads(dumps(s))</span>
    <span class="s0">assert </span><span class="s1">s.compute() == s2.compute()</span>


<span class="s0">def </span><span class="s1">test_msgpack_unicode():</span>
    <span class="s1">b = db.from_sequence([{</span><span class="s2">&quot;a&quot;</span><span class="s1">: </span><span class="s3">1</span><span class="s1">}]).groupby(</span><span class="s2">&quot;a&quot;</span><span class="s1">)</span>
    <span class="s1">result = b.compute(scheduler=</span><span class="s2">&quot;sync&quot;</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">dict(result) == {</span><span class="s3">1</span><span class="s1">: [{</span><span class="s2">&quot;a&quot;</span><span class="s1">: </span><span class="s3">1</span><span class="s1">}]}</span>


<span class="s0">def </span><span class="s1">test_bag_with_single_callable():</span>
    <span class="s1">f = </span><span class="s0">lambda</span><span class="s1">: </span><span class="s0">None</span>
    <span class="s1">b = db.from_sequence([f])</span>
    <span class="s1">assert_eq(b</span><span class="s0">, </span><span class="s1">[f])</span>


<span class="s0">def </span><span class="s1">test_optimize_fuse_keys():</span>
    <span class="s1">x = db.range(</span><span class="s3">10</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">y = x.map(inc)</span>
    <span class="s1">z = y.map(inc)</span>

    <span class="s1">dsk = z.__dask_optimize__(z.dask</span><span class="s0">, </span><span class="s1">z.__dask_keys__())</span>
    <span class="s0">assert not </span><span class="s1">y.dask.keys() &amp; dsk.keys()</span>

    <span class="s1">dsk = z.__dask_optimize__(z.dask</span><span class="s0">, </span><span class="s1">z.__dask_keys__()</span><span class="s0">, </span><span class="s1">fuse_keys=y.__dask_keys__())</span>
    <span class="s0">assert </span><span class="s1">all(k </span><span class="s0">in </span><span class="s1">dsk </span><span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">y.__dask_keys__())</span>


<span class="s0">def </span><span class="s1">test_reductions_are_lazy():</span>
    <span class="s1">current = [</span><span class="s0">None</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">part():</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">10</span><span class="s1">):</span>
            <span class="s1">current[</span><span class="s3">0</span><span class="s1">] = i</span>
            <span class="s0">yield </span><span class="s1">i</span>

    <span class="s0">def </span><span class="s1">func(part):</span>
        <span class="s0">assert </span><span class="s1">current[</span><span class="s3">0</span><span class="s1">] == </span><span class="s3">0</span>
        <span class="s0">return </span><span class="s1">sum(part)</span>

    <span class="s1">b = Bag({(</span><span class="s2">&quot;foo&quot;</span><span class="s0">, </span><span class="s3">0</span><span class="s1">): part()}</span><span class="s0">, </span><span class="s2">&quot;foo&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>

    <span class="s1">res = b.reduction(func</span><span class="s0">, </span><span class="s1">sum)</span>

    <span class="s1">assert_eq(res</span><span class="s0">, </span><span class="s1">sum(range(</span><span class="s3">10</span><span class="s1">)))</span>


<span class="s0">def </span><span class="s1">test_repeated_groupby():</span>
    <span class="s1">b = db.range(</span><span class="s3">10</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">c = b.groupby(</span><span class="s0">lambda </span><span class="s1">x: x % </span><span class="s3">3</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">valmap(len</span><span class="s0">, </span><span class="s1">dict(c)) == valmap(len</span><span class="s0">, </span><span class="s1">dict(c))</span>


<span class="s0">def </span><span class="s1">test_temporary_directory(tmpdir):</span>
    <span class="s1">b = db.range(</span><span class="s3">10</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">4</span><span class="s1">)</span>

    <span class="s4"># We use a pool to avoid a race condition between the pool close</span>
    <span class="s4"># cleaning up files, and the assert below.</span>
    <span class="s0">with </span><span class="s1">ProcessPoolExecutor(</span><span class="s3">4</span><span class="s1">) </span><span class="s0">as </span><span class="s1">pool:</span>
        <span class="s0">with </span><span class="s1">dask.config.set(temporary_directory=str(tmpdir)</span><span class="s0">, </span><span class="s1">pool=pool):</span>
            <span class="s1">b2 = b.groupby(</span><span class="s0">lambda </span><span class="s1">x: x % </span><span class="s3">2</span><span class="s1">)</span>
            <span class="s1">b2.compute()</span>
            <span class="s0">assert </span><span class="s1">any(fn.endswith(</span><span class="s2">&quot;.partd&quot;</span><span class="s1">) </span><span class="s0">for </span><span class="s1">fn </span><span class="s0">in </span><span class="s1">os.listdir(str(tmpdir)))</span>


<span class="s0">def </span><span class="s1">test_empty_bag():</span>
    <span class="s1">b = db.from_sequence([])</span>
    <span class="s1">assert_eq(b.map(inc).all()</span><span class="s0">, True</span><span class="s1">)</span>
    <span class="s1">assert_eq(b.map(inc).any()</span><span class="s0">, False</span><span class="s1">)</span>
    <span class="s1">assert_eq(b.map(inc).sum()</span><span class="s0">, False</span><span class="s1">)</span>
    <span class="s1">assert_eq(b.map(inc).count()</span><span class="s0">, False</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_bag_paths():</span>
    <span class="s1">b = db.from_sequence([</span><span class="s2">&quot;abc&quot;</span><span class="s0">, </span><span class="s2">&quot;123&quot;</span><span class="s0">, </span><span class="s2">&quot;xyz&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">paths = b.to_textfiles(</span><span class="s2">&quot;foo*&quot;</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">paths[</span><span class="s3">0</span><span class="s1">].endswith(</span><span class="s2">&quot;foo0&quot;</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">paths[</span><span class="s3">1</span><span class="s1">].endswith(</span><span class="s2">&quot;foo1&quot;</span><span class="s1">)</span>

    <span class="s1">os.remove(</span><span class="s2">&quot;foo0&quot;</span><span class="s1">)</span>
    <span class="s1">os.remove(</span><span class="s2">&quot;foo1&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_map_partitions_arg():</span>
    <span class="s0">def </span><span class="s1">append_str(partition</span><span class="s0">, </span><span class="s1">s):</span>
        <span class="s0">return </span><span class="s1">[x + s </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">partition]</span>

    <span class="s1">mybag = db.from_sequence([</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">])</span>

    <span class="s1">assert_eq(mybag.map_partitions(append_str</span><span class="s0">, </span><span class="s2">&quot;foo&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;afoo&quot;</span><span class="s0">, </span><span class="s2">&quot;bfoo&quot;</span><span class="s0">, </span><span class="s2">&quot;cfoo&quot;</span><span class="s1">])</span>
    <span class="s1">assert_eq(</span>
        <span class="s1">mybag.map_partitions(append_str</span><span class="s0">, </span><span class="s1">dask.delayed(</span><span class="s2">&quot;foo&quot;</span><span class="s1">))</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;afoo&quot;</span><span class="s0">, </span><span class="s2">&quot;bfoo&quot;</span><span class="s0">, </span><span class="s2">&quot;cfoo&quot;</span><span class="s1">]</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_map_keynames():</span>
    <span class="s1">b = db.from_sequence([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">])</span>
    <span class="s1">d = dict(b.map(inc).__dask_graph__())</span>
    <span class="s0">assert </span><span class="s2">&quot;inc&quot; </span><span class="s0">in </span><span class="s1">map(dask.utils.key_split</span><span class="s0">, </span><span class="s1">d)</span>

    <span class="s0">assert </span><span class="s1">set(b.map(inc).__dask_graph__()) != set(</span>
        <span class="s1">b.map_partitions(inc).__dask_graph__()</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_map_releases_element_references_as_soon_as_possible():</span>
    <span class="s4"># Ensure that Bag.map doesn't keep *element* references longer than</span>
    <span class="s4"># necessary. Previous map implementations used ``yield``, which would keep</span>
    <span class="s4"># a reference to the yielded element until the yielded method resumed (this</span>
    <span class="s4"># is just how generator functions work in CPython).</span>
    <span class="s4">#</span>
    <span class="s4"># See https://github.com/dask/dask/issues/5189</span>
    <span class="s4">#</span>
    <span class="s4"># We test 2 variant of potential extra references here:</span>
    <span class="s4"># 1. Within an element of a partition:</span>
    <span class="s4">#    At the time of the second `f_create` for each element, the `C` from</span>
    <span class="s4">#    the first `f_create` should be dropped.</span>
    <span class="s4"># 2. Within a partition:</span>
    <span class="s4">#    When the second item within a partition is processed, `C` from the</span>
    <span class="s4">#    first item should already be dropped.</span>
    <span class="s0">class </span><span class="s1">C:</span>
        <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">i):</span>
            <span class="s1">self.i = i</span>

    <span class="s4"># keep a weakref to all existing instances of `C`</span>
    <span class="s1">in_memory = weakref.WeakSet()</span>

    <span class="s0">def </span><span class="s1">f_create(i):</span>
        <span class="s4"># check that there are no instances of `C` left</span>
        <span class="s0">assert </span><span class="s1">len(in_memory) == </span><span class="s3">0</span>

        <span class="s4"># create new instance</span>
        <span class="s1">o = C(i)</span>
        <span class="s1">in_memory.add(o)</span>

        <span class="s0">return </span><span class="s1">o</span>

    <span class="s0">def </span><span class="s1">f_drop(o):</span>
        <span class="s4"># o reference dropped on return, should collect</span>
        <span class="s0">return </span><span class="s1">o.i + </span><span class="s3">100</span>

    <span class="s1">b = (</span>
        <span class="s1">db.from_sequence(range(</span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">.map(f_create)</span>
        <span class="s1">.map(f_drop)</span>
        <span class="s1">.map(f_create)</span>
        <span class="s1">.map(f_drop)</span>
        <span class="s1">.sum()</span>
    <span class="s1">)</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s4"># Disable gc to ensure refcycles don't matter here</span>
        <span class="s1">gc.disable()</span>
        <span class="s1">b.compute(scheduler=</span><span class="s2">&quot;sync&quot;</span><span class="s1">)</span>
    <span class="s0">finally</span><span class="s1">:</span>
        <span class="s1">gc.enable()</span>


<span class="s0">def </span><span class="s1">test_bagged_array_delayed():</span>
    <span class="s1">da = pytest.importorskip(</span><span class="s2">&quot;dask.array&quot;</span><span class="s1">)</span>

    <span class="s1">obj = da.ones(</span><span class="s3">10</span><span class="s0">, </span><span class="s1">chunks=</span><span class="s3">5</span><span class="s1">).to_delayed()[</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s1">bag = db.from_delayed(obj)</span>
    <span class="s1">b = bag.compute()</span>
    <span class="s1">assert_eq(b</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">])</span>


<span class="s0">def </span><span class="s1">test_dask_layers():</span>
    <span class="s1">a = db.from_sequence([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">a.__dask_layers__() == (a.name</span><span class="s0">,</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">a.dask.layers.keys() == {a.name}</span>
    <span class="s0">assert </span><span class="s1">a.dask.dependencies == {a.name: set()}</span>
    <span class="s1">i = a.min()</span>
    <span class="s0">assert </span><span class="s1">i.__dask_layers__() == (i.key</span><span class="s0">,</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">i.dask.layers.keys() == {a.name</span><span class="s0">, </span><span class="s1">i.key}</span>
    <span class="s0">assert </span><span class="s1">i.dask.dependencies == {a.name: set()</span><span class="s0">, </span><span class="s1">i.key: {a.name}}</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;optimize&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">False, True</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_dask_layers_to_delayed(optimize):</span>
    <span class="s4"># `da.Array.to_delayed` causes the layer name to not match the key.</span>
    <span class="s4"># Ensure the layer name is propagated between `Delayed` and `Item`.</span>
    <span class="s1">da = pytest.importorskip(</span><span class="s2">&quot;dask.array&quot;</span><span class="s1">)</span>
    <span class="s1">i = db.Item.from_delayed(da.ones(</span><span class="s3">1</span><span class="s1">).to_delayed()[</span><span class="s3">0</span><span class="s1">])</span>
    <span class="s1">name = i.key[</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s0">assert </span><span class="s1">i.key[</span><span class="s3">1</span><span class="s1">:] == (</span><span class="s3">0</span><span class="s0">,</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">i.dask.layers.keys() == {</span><span class="s2">&quot;delayed-&quot; </span><span class="s1">+ name}</span>
    <span class="s0">assert </span><span class="s1">i.dask.dependencies == {</span><span class="s2">&quot;delayed-&quot; </span><span class="s1">+ name: set()}</span>
    <span class="s0">assert </span><span class="s1">i.__dask_layers__() == (</span><span class="s2">&quot;delayed-&quot; </span><span class="s1">+ name</span><span class="s0">,</span><span class="s1">)</span>

    <span class="s1">arr = da.ones(</span><span class="s3">1</span><span class="s1">) + </span><span class="s3">1</span>
    <span class="s1">delayed = arr.to_delayed(optimize_graph=optimize)[</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s1">i = db.Item.from_delayed(delayed)</span>
    <span class="s0">assert </span><span class="s1">i.key == delayed.key</span>
    <span class="s0">assert </span><span class="s1">i.dask </span><span class="s0">is </span><span class="s1">delayed.dask</span>
    <span class="s0">assert </span><span class="s1">i.__dask_layers__() == delayed.__dask_layers__()</span>

    <span class="s1">back = i.to_delayed(optimize_graph=optimize)</span>
    <span class="s0">assert </span><span class="s1">back.__dask_layers__() == i.__dask_layers__()</span>

    <span class="s0">if not </span><span class="s1">optimize:</span>
        <span class="s0">assert </span><span class="s1">back.dask </span><span class="s0">is </span><span class="s1">arr.dask</span>
        <span class="s4"># When not optimized, the key is not a layer in the graph, so using it should fail</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;not in&quot;</span><span class="s1">):</span>
            <span class="s1">db.Item(back.dask</span><span class="s0">, </span><span class="s1">back.key)</span>

    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;not in&quot;</span><span class="s1">):</span>
        <span class="s1">db.Item(arr.dask</span><span class="s0">, </span><span class="s1">(arr.name</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">layer=</span><span class="s2">&quot;foo&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_to_dataframe_optimize_graph():</span>
    <span class="s1">pytest.importorskip(</span><span class="s2">&quot;dask.dataframe&quot;</span><span class="s1">)</span>
    <span class="s0">from </span><span class="s1">dask.dataframe.utils </span><span class="s0">import </span><span class="s1">assert_eq </span><span class="s0">as </span><span class="s1">assert_eq_df</span>
    <span class="s0">from </span><span class="s1">dask.dataframe.utils </span><span class="s0">import </span><span class="s1">pyarrow_strings_enabled</span>

    <span class="s1">x = db.from_sequence(</span>
        <span class="s1">[{</span><span class="s2">&quot;name&quot;</span><span class="s1">: </span><span class="s2">&quot;test1&quot;</span><span class="s0">, </span><span class="s2">&quot;v1&quot;</span><span class="s1">: </span><span class="s3">1</span><span class="s1">}</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;name&quot;</span><span class="s1">: </span><span class="s2">&quot;test2&quot;</span><span class="s0">, </span><span class="s2">&quot;v1&quot;</span><span class="s1">: </span><span class="s3">2</span><span class="s1">}]</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">2</span>
    <span class="s1">)</span>

    <span class="s4"># linear `map` tasks will be fused by graph optimization</span>
    <span class="s0">with </span><span class="s1">dask.annotate(foo=</span><span class="s0">True</span><span class="s1">):</span>
        <span class="s1">y = x.map(</span><span class="s0">lambda </span><span class="s1">a: dict(**a</span><span class="s0">, </span><span class="s1">v2=a[</span><span class="s2">&quot;v1&quot;</span><span class="s1">] + </span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">y = y.map(</span><span class="s0">lambda </span><span class="s1">a: dict(**a</span><span class="s0">, </span><span class="s1">v3=a[</span><span class="s2">&quot;v2&quot;</span><span class="s1">] + </span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">y = y.map(</span><span class="s0">lambda </span><span class="s1">a: dict(**a</span><span class="s0">, </span><span class="s1">v4=a[</span><span class="s2">&quot;v3&quot;</span><span class="s1">] + </span><span class="s3">1</span><span class="s1">))</span>

    <span class="s4"># verifying the maps are not fused yet</span>
    <span class="s0">assert </span><span class="s1">len(y.dask) == y.npartitions * </span><span class="s3">4</span>

    <span class="s4"># with optimizations</span>
    <span class="s1">d = y.to_dataframe()</span>

    <span class="s4"># All the `map` tasks have been fused</span>
    <span class="s0">assert </span><span class="s1">len(d.dask) &lt; len(y.dask) + d.npartitions * int(pyarrow_strings_enabled())</span>

    <span class="s4"># no optimizations</span>
    <span class="s1">d2 = y.to_dataframe(optimize_graph=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s4"># Graph hasn't been fused. It contains all the original tasks,</span>
    <span class="s4"># plus one extra layer converting to DataFrame</span>
    <span class="s0">assert </span><span class="s1">len(d2.dask.keys() - y.dask.keys()) == d.npartitions * (</span>
        <span class="s3">1 </span><span class="s1">+ int(pyarrow_strings_enabled())</span>
    <span class="s1">)</span>

    <span class="s4"># Annotations are still there</span>
    <span class="s0">assert </span><span class="s1">hlg_layer_topological(d2.dask</span><span class="s0">, </span><span class="s3">1</span><span class="s1">).annotations == {</span><span class="s2">&quot;foo&quot;</span><span class="s1">: </span><span class="s0">True</span><span class="s1">}</span>

    <span class="s1">assert_eq_df(d</span><span class="s0">, </span><span class="s1">d2)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;nworkers&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">100</span><span class="s0">, </span><span class="s3">250</span><span class="s0">, </span><span class="s3">500</span><span class="s0">, </span><span class="s3">1000</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_default_partitioning_worker_saturation(nworkers):</span>
    <span class="s4"># Ensure that Dask Bag can saturate any number of workers with concurrent tasks.</span>
    <span class="s4"># The default partitioning scheme partitions items to keep the task to item ratio sensible</span>
    <span class="s4"># but it should always be possible to saturate any number of workers given enough items in the bag.</span>
    <span class="s1">ntasks = </span><span class="s3">0</span>
    <span class="s1">nitems = </span><span class="s3">1</span>
    <span class="s0">while </span><span class="s1">ntasks &lt; nworkers:</span>
        <span class="s1">ntasks = len(db.from_sequence(range(nitems)).dask)</span>
        <span class="s1">nitems += math.floor(max(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">nworkers / </span><span class="s3">10</span><span class="s1">))</span>
        <span class="s0">assert </span><span class="s1">nitems &lt; </span><span class="s3">20_000</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;nworkers&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">100</span><span class="s0">, </span><span class="s3">250</span><span class="s0">, </span><span class="s3">500</span><span class="s0">, </span><span class="s3">1000</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_npartitions_saturation(nworkers):</span>
    <span class="s4"># If npartitions is set the bag should always contain at least that number of tasks</span>
    <span class="s0">for </span><span class="s1">nitems </span><span class="s0">in </span><span class="s1">range(nworkers</span><span class="s0">, </span><span class="s3">10 </span><span class="s1">* nworkers</span><span class="s0">, </span><span class="s1">max(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">math.floor(nworkers / </span><span class="s3">10</span><span class="s1">))):</span>
        <span class="s0">assert </span><span class="s1">(</span>
            <span class="s1">len(db.from_sequence(range(nitems)</span><span class="s0">, </span><span class="s1">npartitions=nworkers).dask) &gt;= nworkers</span>
        <span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_map_total_mem_usage():</span>
    <span class="s5">&quot;&quot;&quot;https://github.com/dask/dask/issues/10338&quot;&quot;&quot;</span>
    <span class="s1">b = db.from_sequence(range(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">total_mem_b = sum(b.map_partitions(total_mem_usage).compute())</span>
    <span class="s1">c = b.map(</span><span class="s0">lambda </span><span class="s1">x: x)</span>
    <span class="s1">total_mem_c = sum(c.map_partitions(total_mem_usage).compute())</span>
    <span class="s0">assert </span><span class="s1">total_mem_b == total_mem_c</span>
</pre>
</body>
</html>