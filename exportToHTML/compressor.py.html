<html>
<head>
<title>compressor.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #a5c261;}
.s6 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
compressor.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Classes and functions for managing compressors.&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">io</span>
<span class="s2">import </span><span class="s1">zlib</span>
<span class="s2">from </span><span class="s1">joblib.backports </span><span class="s2">import </span><span class="s1">LooseVersion</span>

<span class="s2">try</span><span class="s1">:</span>
    <span class="s2">from </span><span class="s1">threading </span><span class="s2">import </span><span class="s1">RLock</span>
<span class="s2">except </span><span class="s1">ImportError:</span>
    <span class="s2">from </span><span class="s1">dummy_threading </span><span class="s2">import </span><span class="s1">RLock</span>

<span class="s2">try</span><span class="s1">:</span>
    <span class="s2">import </span><span class="s1">bz2</span>
<span class="s2">except </span><span class="s1">ImportError:</span>
    <span class="s1">bz2 = </span><span class="s2">None</span>

<span class="s2">try</span><span class="s1">:</span>
    <span class="s2">import </span><span class="s1">lz4</span>
    <span class="s2">from </span><span class="s1">lz4.frame </span><span class="s2">import </span><span class="s1">LZ4FrameFile</span>
<span class="s2">except </span><span class="s1">ImportError:</span>
    <span class="s1">lz4 = </span><span class="s2">None</span>

<span class="s2">try</span><span class="s1">:</span>
    <span class="s2">import </span><span class="s1">lzma</span>
<span class="s2">except </span><span class="s1">ImportError:</span>
    <span class="s1">lzma = </span><span class="s2">None</span>


<span class="s1">LZ4_NOT_INSTALLED_ERROR = (</span><span class="s3">'LZ4 is not installed. Install it with pip: '</span>
                           <span class="s3">'https://python-lz4.readthedocs.io/'</span><span class="s1">)</span>

<span class="s4"># Registered compressors</span>
<span class="s1">_COMPRESSORS = {}</span>

<span class="s4"># Magic numbers of supported compression file formats.</span>
<span class="s1">_ZFILE_PREFIX = </span><span class="s5">b'ZF'  </span><span class="s4"># used with pickle files created before 0.9.3.</span>
<span class="s1">_ZLIB_PREFIX = </span><span class="s5">b'</span><span class="s2">\x78</span><span class="s5">'</span>
<span class="s1">_GZIP_PREFIX = </span><span class="s5">b'</span><span class="s2">\x1f\x8b</span><span class="s5">'</span>
<span class="s1">_BZ2_PREFIX = </span><span class="s5">b'BZ'</span>
<span class="s1">_XZ_PREFIX = </span><span class="s5">b'</span><span class="s2">\xfd\x37\x7a\x58\x5a</span><span class="s5">'</span>
<span class="s1">_LZMA_PREFIX = </span><span class="s5">b'</span><span class="s2">\x5d\x00</span><span class="s5">'</span>
<span class="s1">_LZ4_PREFIX = </span><span class="s5">b'</span><span class="s2">\x04\x22\x4D\x18</span><span class="s5">'</span>


<span class="s2">def </span><span class="s1">register_compressor(compressor_name</span><span class="s2">, </span><span class="s1">compressor</span><span class="s2">,</span>
                        <span class="s1">force=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Register a new compressor. 
 
    Parameters 
    ---------- 
    compressor_name: str. 
        The name of the compressor. 
    compressor: CompressorWrapper 
        An instance of a 'CompressorWrapper'. 
    &quot;&quot;&quot;</span>
    <span class="s2">global </span><span class="s1">_COMPRESSORS</span>
    <span class="s2">if not </span><span class="s1">isinstance(compressor_name</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Compressor name should be a string, &quot;</span>
                         <span class="s3">&quot;'{}' given.&quot;</span><span class="s1">.format(compressor_name))</span>

    <span class="s2">if not </span><span class="s1">isinstance(compressor</span><span class="s2">, </span><span class="s1">CompressorWrapper):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Compressor should implement the CompressorWrapper &quot;</span>
                         <span class="s3">&quot;interface, '{}' given.&quot;</span><span class="s1">.format(compressor))</span>

    <span class="s2">if </span><span class="s1">(compressor.fileobj_factory </span><span class="s2">is not None and</span>
            <span class="s1">(</span><span class="s2">not </span><span class="s1">hasattr(compressor.fileobj_factory</span><span class="s2">, </span><span class="s3">'read'</span><span class="s1">) </span><span class="s2">or</span>
             <span class="s2">not </span><span class="s1">hasattr(compressor.fileobj_factory</span><span class="s2">, </span><span class="s3">'write'</span><span class="s1">) </span><span class="s2">or</span>
             <span class="s2">not </span><span class="s1">hasattr(compressor.fileobj_factory</span><span class="s2">, </span><span class="s3">'seek'</span><span class="s1">) </span><span class="s2">or</span>
             <span class="s2">not </span><span class="s1">hasattr(compressor.fileobj_factory</span><span class="s2">, </span><span class="s3">'tell'</span><span class="s1">))):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Compressor 'fileobj_factory' attribute should &quot;</span>
                         <span class="s3">&quot;implement the file object interface, '{}' given.&quot;</span>
                         <span class="s1">.format(compressor.fileobj_factory))</span>

    <span class="s2">if </span><span class="s1">compressor_name </span><span class="s2">in </span><span class="s1">_COMPRESSORS </span><span class="s2">and not </span><span class="s1">force:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Compressor '{}' already registered.&quot;</span>
                         <span class="s1">.format(compressor_name))</span>

    <span class="s1">_COMPRESSORS[compressor_name] = compressor</span>


<span class="s2">class </span><span class="s1">CompressorWrapper():</span>
    <span class="s0">&quot;&quot;&quot;A wrapper around a compressor file object. 
 
    Attributes 
    ---------- 
    obj: a file-like object 
        The object must implement the buffer interface and will be used 
        internally to compress/decompress the data. 
    prefix: bytestring 
        A bytestring corresponding to the magic number that identifies the 
        file format associated to the compressor. 
    extension: str 
        The file extension used to automatically select this compressor during 
        a dump to a file. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">, </span><span class="s1">prefix=</span><span class="s5">b''</span><span class="s2">, </span><span class="s1">extension=</span><span class="s3">''</span><span class="s1">):</span>
        <span class="s1">self.fileobj_factory = obj</span>
        <span class="s1">self.prefix = prefix</span>
        <span class="s1">self.extension = extension</span>

    <span class="s2">def </span><span class="s1">compressor_file(self</span><span class="s2">, </span><span class="s1">fileobj</span><span class="s2">, </span><span class="s1">compresslevel=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Returns an instance of a compressor file object.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">compresslevel </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.fileobj_factory(fileobj</span><span class="s2">, </span><span class="s3">'wb'</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.fileobj_factory(fileobj</span><span class="s2">, </span><span class="s3">'wb'</span><span class="s2">,</span>
                                        <span class="s1">compresslevel=compresslevel)</span>

    <span class="s2">def </span><span class="s1">decompressor_file(self</span><span class="s2">, </span><span class="s1">fileobj):</span>
        <span class="s0">&quot;&quot;&quot;Returns an instance of a decompressor file object.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.fileobj_factory(fileobj</span><span class="s2">, </span><span class="s3">'rb'</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">BZ2CompressorWrapper(CompressorWrapper):</span>

    <span class="s1">prefix = _BZ2_PREFIX</span>
    <span class="s1">extension = </span><span class="s3">'.bz2'</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s2">if </span><span class="s1">bz2 </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.fileobj_factory = bz2.BZ2File</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.fileobj_factory = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">_check_versions(self):</span>
        <span class="s2">if </span><span class="s1">bz2 </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'bz2 module is not compiled on your python '</span>
                             <span class="s3">'standard library.'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">compressor_file(self</span><span class="s2">, </span><span class="s1">fileobj</span><span class="s2">, </span><span class="s1">compresslevel=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Returns an instance of a compressor file object.&quot;&quot;&quot;</span>
        <span class="s1">self._check_versions()</span>
        <span class="s2">if </span><span class="s1">compresslevel </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.fileobj_factory(fileobj</span><span class="s2">, </span><span class="s3">'wb'</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.fileobj_factory(fileobj</span><span class="s2">, </span><span class="s3">'wb'</span><span class="s2">,</span>
                                        <span class="s1">compresslevel=compresslevel)</span>

    <span class="s2">def </span><span class="s1">decompressor_file(self</span><span class="s2">, </span><span class="s1">fileobj):</span>
        <span class="s0">&quot;&quot;&quot;Returns an instance of a decompressor file object.&quot;&quot;&quot;</span>
        <span class="s1">self._check_versions()</span>
        <span class="s1">fileobj = self.fileobj_factory(fileobj</span><span class="s2">, </span><span class="s3">'rb'</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">fileobj</span>


<span class="s2">class </span><span class="s1">LZMACompressorWrapper(CompressorWrapper):</span>

    <span class="s1">prefix = _LZMA_PREFIX</span>
    <span class="s1">extension = </span><span class="s3">'.lzma'</span>
    <span class="s1">_lzma_format_name = </span><span class="s3">'FORMAT_ALONE'</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s2">if </span><span class="s1">lzma </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.fileobj_factory = lzma.LZMAFile</span>
            <span class="s1">self._lzma_format = getattr(lzma</span><span class="s2">, </span><span class="s1">self._lzma_format_name)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.fileobj_factory = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">_check_versions(self):</span>
        <span class="s2">if </span><span class="s1">lzma </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">'lzma module is not compiled on your python '</span>
                             <span class="s3">'standard library.'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">compressor_file(self</span><span class="s2">, </span><span class="s1">fileobj</span><span class="s2">, </span><span class="s1">compresslevel=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Returns an instance of a compressor file object.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">compresslevel </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.fileobj_factory(fileobj</span><span class="s2">, </span><span class="s3">'wb'</span><span class="s2">,</span>
                                        <span class="s1">format=self._lzma_format)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.fileobj_factory(fileobj</span><span class="s2">, </span><span class="s3">'wb'</span><span class="s2">,</span>
                                        <span class="s1">format=self._lzma_format</span><span class="s2">,</span>
                                        <span class="s1">preset=compresslevel)</span>

    <span class="s2">def </span><span class="s1">decompressor_file(self</span><span class="s2">, </span><span class="s1">fileobj):</span>
        <span class="s0">&quot;&quot;&quot;Returns an instance of a decompressor file object.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">lzma.LZMAFile(fileobj</span><span class="s2">, </span><span class="s3">'rb'</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">XZCompressorWrapper(LZMACompressorWrapper):</span>

    <span class="s1">prefix = _XZ_PREFIX</span>
    <span class="s1">extension = </span><span class="s3">'.xz'</span>
    <span class="s1">_lzma_format_name = </span><span class="s3">'FORMAT_XZ'</span>


<span class="s2">class </span><span class="s1">LZ4CompressorWrapper(CompressorWrapper):</span>

    <span class="s1">prefix = _LZ4_PREFIX</span>
    <span class="s1">extension = </span><span class="s3">'.lz4'</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s2">if </span><span class="s1">lz4 </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.fileobj_factory = LZ4FrameFile</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.fileobj_factory = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">_check_versions(self):</span>
        <span class="s2">if </span><span class="s1">lz4 </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(LZ4_NOT_INSTALLED_ERROR)</span>
        <span class="s1">lz4_version = lz4.__version__</span>
        <span class="s2">if </span><span class="s1">lz4_version.startswith(</span><span class="s3">&quot;v&quot;</span><span class="s1">):</span>
            <span class="s1">lz4_version = lz4_version[</span><span class="s6">1</span><span class="s1">:]</span>
        <span class="s2">if </span><span class="s1">LooseVersion(lz4_version) &lt; LooseVersion(</span><span class="s3">'0.19'</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValueError(LZ4_NOT_INSTALLED_ERROR)</span>

    <span class="s2">def </span><span class="s1">compressor_file(self</span><span class="s2">, </span><span class="s1">fileobj</span><span class="s2">, </span><span class="s1">compresslevel=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Returns an instance of a compressor file object.&quot;&quot;&quot;</span>
        <span class="s1">self._check_versions()</span>
        <span class="s2">if </span><span class="s1">compresslevel </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.fileobj_factory(fileobj</span><span class="s2">, </span><span class="s3">'wb'</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.fileobj_factory(fileobj</span><span class="s2">, </span><span class="s3">'wb'</span><span class="s2">,</span>
                                        <span class="s1">compression_level=compresslevel)</span>

    <span class="s2">def </span><span class="s1">decompressor_file(self</span><span class="s2">, </span><span class="s1">fileobj):</span>
        <span class="s0">&quot;&quot;&quot;Returns an instance of a decompressor file object.&quot;&quot;&quot;</span>
        <span class="s1">self._check_versions()</span>
        <span class="s2">return </span><span class="s1">self.fileobj_factory(fileobj</span><span class="s2">, </span><span class="s3">'rb'</span><span class="s1">)</span>


<span class="s4">###############################################################################</span>
<span class="s4">#  base file compression/decompression object definition</span>
<span class="s1">_MODE_CLOSED = </span><span class="s6">0</span>
<span class="s1">_MODE_READ = </span><span class="s6">1</span>
<span class="s1">_MODE_READ_EOF = </span><span class="s6">2</span>
<span class="s1">_MODE_WRITE = </span><span class="s6">3</span>
<span class="s1">_BUFFER_SIZE = </span><span class="s6">8192</span>


<span class="s2">class </span><span class="s1">BinaryZlibFile(io.BufferedIOBase):</span>
    <span class="s0">&quot;&quot;&quot;A file object providing transparent zlib (de)compression. 
 
    TODO python2_drop: is it still needed since we dropped Python 2 support A 
    BinaryZlibFile can act as a wrapper for an existing file object, or refer 
    directly to a named file on disk. 
 
    Note that BinaryZlibFile provides only a *binary* file interface: data read 
    is returned as bytes, and data to be written should be given as bytes. 
 
    This object is an adaptation of the BZ2File object and is compatible with 
    versions of python &gt;= 2.7. 
 
    If filename is a str or bytes object, it gives the name 
    of the file to be opened. Otherwise, it should be a file object, 
    which will be used to read or write the compressed data. 
 
    mode can be 'rb' for reading (default) or 'wb' for (over)writing 
 
    If mode is 'wb', compresslevel can be a number between 1 
    and 9 specifying the level of compression: 1 produces the least 
    compression, and 9 produces the most compression. 3 is the default. 
    &quot;&quot;&quot;</span>

    <span class="s1">wbits = zlib.MAX_WBITS</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">filename</span><span class="s2">, </span><span class="s1">mode=</span><span class="s3">&quot;rb&quot;</span><span class="s2">, </span><span class="s1">compresslevel=</span><span class="s6">3</span><span class="s1">):</span>
        <span class="s4"># This lock must be recursive, so that BufferedIOBase's</span>
        <span class="s4"># readline(), readlines() and writelines() don't deadlock.</span>
        <span class="s1">self._lock = RLock()</span>
        <span class="s1">self._fp = </span><span class="s2">None</span>
        <span class="s1">self._closefp = </span><span class="s2">False</span>
        <span class="s1">self._mode = _MODE_CLOSED</span>
        <span class="s1">self._pos = </span><span class="s6">0</span>
        <span class="s1">self._size = -</span><span class="s6">1</span>
        <span class="s1">self.compresslevel = compresslevel</span>

        <span class="s2">if not </span><span class="s1">isinstance(compresslevel</span><span class="s2">, </span><span class="s1">int) </span><span class="s2">or not </span><span class="s1">(</span><span class="s6">1 </span><span class="s1">&lt;= compresslevel &lt;= </span><span class="s6">9</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;'compresslevel' must be an integer &quot;</span>
                             <span class="s3">&quot;between 1 and 9. You provided 'compresslevel={}'&quot;</span>
                             <span class="s1">.format(compresslevel))</span>

        <span class="s2">if </span><span class="s1">mode == </span><span class="s3">&quot;rb&quot;</span><span class="s1">:</span>
            <span class="s1">self._mode = _MODE_READ</span>
            <span class="s1">self._decompressor = zlib.decompressobj(self.wbits)</span>
            <span class="s1">self._buffer = </span><span class="s5">b&quot;&quot;</span>
            <span class="s1">self._buffer_offset = </span><span class="s6">0</span>
        <span class="s2">elif </span><span class="s1">mode == </span><span class="s3">&quot;wb&quot;</span><span class="s1">:</span>
            <span class="s1">self._mode = _MODE_WRITE</span>
            <span class="s1">self._compressor = zlib.compressobj(self.compresslevel</span><span class="s2">,</span>
                                                <span class="s1">zlib.DEFLATED</span><span class="s2">, </span><span class="s1">self.wbits</span><span class="s2">,</span>
                                                <span class="s1">zlib.DEF_MEM_LEVEL</span><span class="s2">, </span><span class="s6">0</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Invalid mode: %r&quot; </span><span class="s1">% (mode</span><span class="s2">,</span><span class="s1">))</span>

        <span class="s2">if </span><span class="s1">isinstance(filename</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">self._fp = io.open(filename</span><span class="s2">, </span><span class="s1">mode)</span>
            <span class="s1">self._closefp = </span><span class="s2">True</span>
        <span class="s2">elif </span><span class="s1">hasattr(filename</span><span class="s2">, </span><span class="s3">&quot;read&quot;</span><span class="s1">) </span><span class="s2">or </span><span class="s1">hasattr(filename</span><span class="s2">, </span><span class="s3">&quot;write&quot;</span><span class="s1">):</span>
            <span class="s1">self._fp = filename</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;filename must be a str or bytes object, &quot;</span>
                            <span class="s3">&quot;or a file&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">close(self):</span>
        <span class="s0">&quot;&quot;&quot;Flush and close the file. 
 
        May be called more than once without error. Once the file is 
        closed, any other operation on it will raise a ValueError. 
        &quot;&quot;&quot;</span>
        <span class="s2">with </span><span class="s1">self._lock:</span>
            <span class="s2">if </span><span class="s1">self._mode == _MODE_CLOSED:</span>
                <span class="s2">return</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">self._mode </span><span class="s2">in </span><span class="s1">(_MODE_READ</span><span class="s2">, </span><span class="s1">_MODE_READ_EOF):</span>
                    <span class="s1">self._decompressor = </span><span class="s2">None</span>
                <span class="s2">elif </span><span class="s1">self._mode == _MODE_WRITE:</span>
                    <span class="s1">self._fp.write(self._compressor.flush())</span>
                    <span class="s1">self._compressor = </span><span class="s2">None</span>
            <span class="s2">finally</span><span class="s1">:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s2">if </span><span class="s1">self._closefp:</span>
                        <span class="s1">self._fp.close()</span>
                <span class="s2">finally</span><span class="s1">:</span>
                    <span class="s1">self._fp = </span><span class="s2">None</span>
                    <span class="s1">self._closefp = </span><span class="s2">False</span>
                    <span class="s1">self._mode = _MODE_CLOSED</span>
                    <span class="s1">self._buffer = </span><span class="s5">b&quot;&quot;</span>
                    <span class="s1">self._buffer_offset = </span><span class="s6">0</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">closed(self):</span>
        <span class="s0">&quot;&quot;&quot;True if this file is closed.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._mode == _MODE_CLOSED</span>

    <span class="s2">def </span><span class="s1">fileno(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the file descriptor for the underlying file.&quot;&quot;&quot;</span>
        <span class="s1">self._check_not_closed()</span>
        <span class="s2">return </span><span class="s1">self._fp.fileno()</span>

    <span class="s2">def </span><span class="s1">seekable(self):</span>
        <span class="s0">&quot;&quot;&quot;Return whether the file supports seeking.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.readable() </span><span class="s2">and </span><span class="s1">self._fp.seekable()</span>

    <span class="s2">def </span><span class="s1">readable(self):</span>
        <span class="s0">&quot;&quot;&quot;Return whether the file was opened for reading.&quot;&quot;&quot;</span>
        <span class="s1">self._check_not_closed()</span>
        <span class="s2">return </span><span class="s1">self._mode </span><span class="s2">in </span><span class="s1">(_MODE_READ</span><span class="s2">, </span><span class="s1">_MODE_READ_EOF)</span>

    <span class="s2">def </span><span class="s1">writable(self):</span>
        <span class="s0">&quot;&quot;&quot;Return whether the file was opened for writing.&quot;&quot;&quot;</span>
        <span class="s1">self._check_not_closed()</span>
        <span class="s2">return </span><span class="s1">self._mode == _MODE_WRITE</span>

    <span class="s4"># Mode-checking helper functions.</span>

    <span class="s2">def </span><span class="s1">_check_not_closed(self):</span>
        <span class="s2">if </span><span class="s1">self.closed:</span>
            <span class="s1">fname = getattr(self._fp</span><span class="s2">, </span><span class="s3">'name'</span><span class="s2">, None</span><span class="s1">)</span>
            <span class="s1">msg = </span><span class="s3">&quot;I/O operation on closed file&quot;</span>
            <span class="s2">if </span><span class="s1">fname </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">msg += </span><span class="s3">&quot; {}&quot;</span><span class="s1">.format(fname)</span>
            <span class="s1">msg += </span><span class="s3">&quot;.&quot;</span>
            <span class="s2">raise </span><span class="s1">ValueError(msg)</span>

    <span class="s2">def </span><span class="s1">_check_can_read(self):</span>
        <span class="s2">if </span><span class="s1">self._mode </span><span class="s2">not in </span><span class="s1">(_MODE_READ</span><span class="s2">, </span><span class="s1">_MODE_READ_EOF):</span>
            <span class="s1">self._check_not_closed()</span>
            <span class="s2">raise </span><span class="s1">io.UnsupportedOperation(</span><span class="s3">&quot;File not open for reading&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_check_can_write(self):</span>
        <span class="s2">if </span><span class="s1">self._mode != _MODE_WRITE:</span>
            <span class="s1">self._check_not_closed()</span>
            <span class="s2">raise </span><span class="s1">io.UnsupportedOperation(</span><span class="s3">&quot;File not open for writing&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_check_can_seek(self):</span>
        <span class="s2">if </span><span class="s1">self._mode </span><span class="s2">not in </span><span class="s1">(_MODE_READ</span><span class="s2">, </span><span class="s1">_MODE_READ_EOF):</span>
            <span class="s1">self._check_not_closed()</span>
            <span class="s2">raise </span><span class="s1">io.UnsupportedOperation(</span><span class="s3">&quot;Seeking is only supported &quot;</span>
                                          <span class="s3">&quot;on files open for reading&quot;</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">self._fp.seekable():</span>
            <span class="s2">raise </span><span class="s1">io.UnsupportedOperation(</span><span class="s3">&quot;The underlying file object &quot;</span>
                                          <span class="s3">&quot;does not support seeking&quot;</span><span class="s1">)</span>

    <span class="s4"># Fill the readahead buffer if it is empty. Returns False on EOF.</span>
    <span class="s2">def </span><span class="s1">_fill_buffer(self):</span>
        <span class="s2">if </span><span class="s1">self._mode == _MODE_READ_EOF:</span>
            <span class="s2">return False</span>
        <span class="s4"># Depending on the input data, our call to the decompressor may not</span>
        <span class="s4"># return any data. In this case, try again after reading another block.</span>
        <span class="s2">while </span><span class="s1">self._buffer_offset == len(self._buffer):</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">rawblock = (self._decompressor.unused_data </span><span class="s2">or</span>
                            <span class="s1">self._fp.read(_BUFFER_SIZE))</span>
                <span class="s2">if not </span><span class="s1">rawblock:</span>
                    <span class="s2">raise </span><span class="s1">EOFError</span>
            <span class="s2">except </span><span class="s1">EOFError:</span>
                <span class="s4"># End-of-stream marker and end of file. We're good.</span>
                <span class="s1">self._mode = _MODE_READ_EOF</span>
                <span class="s1">self._size = self._pos</span>
                <span class="s2">return False</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self._buffer = self._decompressor.decompress(rawblock)</span>
            <span class="s1">self._buffer_offset = </span><span class="s6">0</span>
        <span class="s2">return True</span>

    <span class="s4"># Read data until EOF.</span>
    <span class="s4"># If return_data is false, consume the data without returning it.</span>
    <span class="s2">def </span><span class="s1">_read_all(self</span><span class="s2">, </span><span class="s1">return_data=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s4"># The loop assumes that _buffer_offset is 0. Ensure that this is true.</span>
        <span class="s1">self._buffer = self._buffer[self._buffer_offset:]</span>
        <span class="s1">self._buffer_offset = </span><span class="s6">0</span>

        <span class="s1">blocks = []</span>
        <span class="s2">while </span><span class="s1">self._fill_buffer():</span>
            <span class="s2">if </span><span class="s1">return_data:</span>
                <span class="s1">blocks.append(self._buffer)</span>
            <span class="s1">self._pos += len(self._buffer)</span>
            <span class="s1">self._buffer = </span><span class="s5">b&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">return_data:</span>
            <span class="s2">return </span><span class="s5">b&quot;&quot;</span><span class="s1">.join(blocks)</span>

    <span class="s4"># Read a block of up to n bytes.</span>
    <span class="s4"># If return_data is false, consume the data without returning it.</span>
    <span class="s2">def </span><span class="s1">_read_block(self</span><span class="s2">, </span><span class="s1">n_bytes</span><span class="s2">, </span><span class="s1">return_data=</span><span class="s2">True</span><span class="s1">):</span>
        <span class="s4"># If we have enough data buffered, return immediately.</span>
        <span class="s1">end = self._buffer_offset + n_bytes</span>
        <span class="s2">if </span><span class="s1">end &lt;= len(self._buffer):</span>
            <span class="s1">data = self._buffer[self._buffer_offset: end]</span>
            <span class="s1">self._buffer_offset = end</span>
            <span class="s1">self._pos += len(data)</span>
            <span class="s2">return </span><span class="s1">data </span><span class="s2">if </span><span class="s1">return_data </span><span class="s2">else None</span>

        <span class="s4"># The loop assumes that _buffer_offset is 0. Ensure that this is true.</span>
        <span class="s1">self._buffer = self._buffer[self._buffer_offset:]</span>
        <span class="s1">self._buffer_offset = </span><span class="s6">0</span>

        <span class="s1">blocks = []</span>
        <span class="s2">while </span><span class="s1">n_bytes &gt; </span><span class="s6">0 </span><span class="s2">and </span><span class="s1">self._fill_buffer():</span>
            <span class="s2">if </span><span class="s1">n_bytes &lt; len(self._buffer):</span>
                <span class="s1">data = self._buffer[:n_bytes]</span>
                <span class="s1">self._buffer_offset = n_bytes</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">data = self._buffer</span>
                <span class="s1">self._buffer = </span><span class="s5">b&quot;&quot;</span>
            <span class="s2">if </span><span class="s1">return_data:</span>
                <span class="s1">blocks.append(data)</span>
            <span class="s1">self._pos += len(data)</span>
            <span class="s1">n_bytes -= len(data)</span>
        <span class="s2">if </span><span class="s1">return_data:</span>
            <span class="s2">return </span><span class="s5">b&quot;&quot;</span><span class="s1">.join(blocks)</span>

    <span class="s2">def </span><span class="s1">read(self</span><span class="s2">, </span><span class="s1">size=-</span><span class="s6">1</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Read up to size uncompressed bytes from the file. 
 
        If size is negative or omitted, read until EOF is reached. 
        Returns b'' if the file is already at EOF. 
        &quot;&quot;&quot;</span>
        <span class="s2">with </span><span class="s1">self._lock:</span>
            <span class="s1">self._check_can_read()</span>
            <span class="s2">if </span><span class="s1">size == </span><span class="s6">0</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s5">b&quot;&quot;</span>
            <span class="s2">elif </span><span class="s1">size &lt; </span><span class="s6">0</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">self._read_all()</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">self._read_block(size)</span>

    <span class="s2">def </span><span class="s1">readinto(self</span><span class="s2">, </span><span class="s1">b):</span>
        <span class="s0">&quot;&quot;&quot;Read up to len(b) bytes into b. 
 
        Returns the number of bytes read (0 for EOF). 
        &quot;&quot;&quot;</span>
        <span class="s2">with </span><span class="s1">self._lock:</span>
            <span class="s2">return </span><span class="s1">io.BufferedIOBase.readinto(self</span><span class="s2">, </span><span class="s1">b)</span>

    <span class="s2">def </span><span class="s1">write(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s0">&quot;&quot;&quot;Write a byte string to the file. 
 
        Returns the number of uncompressed bytes written, which is 
        always len(data). Note that due to buffering, the file on disk 
        may not reflect the data written until close() is called. 
        &quot;&quot;&quot;</span>
        <span class="s2">with </span><span class="s1">self._lock:</span>
            <span class="s1">self._check_can_write()</span>
            <span class="s4"># Convert data type if called by io.BufferedWriter.</span>
            <span class="s2">if </span><span class="s1">isinstance(data</span><span class="s2">, </span><span class="s1">memoryview):</span>
                <span class="s1">data = data.tobytes()</span>

            <span class="s1">compressed = self._compressor.compress(data)</span>
            <span class="s1">self._fp.write(compressed)</span>
            <span class="s1">self._pos += len(data)</span>
            <span class="s2">return </span><span class="s1">len(data)</span>

    <span class="s4"># Rewind the file to the beginning of the data stream.</span>
    <span class="s2">def </span><span class="s1">_rewind(self):</span>
        <span class="s1">self._fp.seek(</span><span class="s6">0</span><span class="s2">, </span><span class="s6">0</span><span class="s1">)</span>
        <span class="s1">self._mode = _MODE_READ</span>
        <span class="s1">self._pos = </span><span class="s6">0</span>
        <span class="s1">self._decompressor = zlib.decompressobj(self.wbits)</span>
        <span class="s1">self._buffer = </span><span class="s5">b&quot;&quot;</span>
        <span class="s1">self._buffer_offset = </span><span class="s6">0</span>

    <span class="s2">def </span><span class="s1">seek(self</span><span class="s2">, </span><span class="s1">offset</span><span class="s2">, </span><span class="s1">whence=</span><span class="s6">0</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Change the file position. 
 
        The new position is specified by offset, relative to the 
        position indicated by whence. Values for whence are: 
 
            0: start of stream (default); offset must not be negative 
            1: current stream position 
            2: end of stream; offset must not be positive 
 
        Returns the new file position. 
 
        Note that seeking is emulated, so depending on the parameters, 
        this operation may be extremely slow. 
        &quot;&quot;&quot;</span>
        <span class="s2">with </span><span class="s1">self._lock:</span>
            <span class="s1">self._check_can_seek()</span>

            <span class="s4"># Recalculate offset as an absolute file position.</span>
            <span class="s2">if </span><span class="s1">whence == </span><span class="s6">0</span><span class="s1">:</span>
                <span class="s2">pass</span>
            <span class="s2">elif </span><span class="s1">whence == </span><span class="s6">1</span><span class="s1">:</span>
                <span class="s1">offset = self._pos + offset</span>
            <span class="s2">elif </span><span class="s1">whence == </span><span class="s6">2</span><span class="s1">:</span>
                <span class="s4"># Seeking relative to EOF - we need to know the file's size.</span>
                <span class="s2">if </span><span class="s1">self._size &lt; </span><span class="s6">0</span><span class="s1">:</span>
                    <span class="s1">self._read_all(return_data=</span><span class="s2">False</span><span class="s1">)</span>
                <span class="s1">offset = self._size + offset</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Invalid value for whence: %s&quot; </span><span class="s1">% (whence</span><span class="s2">,</span><span class="s1">))</span>

            <span class="s4"># Make it so that offset is the number of bytes to skip forward.</span>
            <span class="s2">if </span><span class="s1">offset &lt; self._pos:</span>
                <span class="s1">self._rewind()</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">offset -= self._pos</span>

            <span class="s4"># Read and discard data until we reach the desired position.</span>
            <span class="s1">self._read_block(offset</span><span class="s2">, </span><span class="s1">return_data=</span><span class="s2">False</span><span class="s1">)</span>

            <span class="s2">return </span><span class="s1">self._pos</span>

    <span class="s2">def </span><span class="s1">tell(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the current file position.&quot;&quot;&quot;</span>
        <span class="s2">with </span><span class="s1">self._lock:</span>
            <span class="s1">self._check_not_closed()</span>
            <span class="s2">return </span><span class="s1">self._pos</span>


<span class="s2">class </span><span class="s1">ZlibCompressorWrapper(CompressorWrapper):</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">CompressorWrapper.__init__(self</span><span class="s2">, </span><span class="s1">obj=BinaryZlibFile</span><span class="s2">,</span>
                                   <span class="s1">prefix=_ZLIB_PREFIX</span><span class="s2">, </span><span class="s1">extension=</span><span class="s3">'.z'</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">BinaryGzipFile(BinaryZlibFile):</span>
    <span class="s0">&quot;&quot;&quot;A file object providing transparent gzip (de)compression. 
 
    If filename is a str or bytes object, it gives the name 
    of the file to be opened. Otherwise, it should be a file object, 
    which will be used to read or write the compressed data. 
 
    mode can be 'rb' for reading (default) or 'wb' for (over)writing 
 
    If mode is 'wb', compresslevel can be a number between 1 
    and 9 specifying the level of compression: 1 produces the least 
    compression, and 9 produces the most compression. 3 is the default. 
    &quot;&quot;&quot;</span>

    <span class="s1">wbits = </span><span class="s6">31  </span><span class="s4"># zlib compressor/decompressor wbits value for gzip format.</span>


<span class="s2">class </span><span class="s1">GzipCompressorWrapper(CompressorWrapper):</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">CompressorWrapper.__init__(self</span><span class="s2">, </span><span class="s1">obj=BinaryGzipFile</span><span class="s2">,</span>
                                   <span class="s1">prefix=_GZIP_PREFIX</span><span class="s2">, </span><span class="s1">extension=</span><span class="s3">'.gz'</span><span class="s1">)</span>
</pre>
</body>
</html>