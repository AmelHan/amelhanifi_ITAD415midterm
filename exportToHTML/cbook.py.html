<html>
<head>
<title>cbook.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
cbook.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
A collection of utility functions and classes.  Originally, many 
(but not all) were from the Python Cookbook -- hence the name cbook. 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">collections</span>
<span class="s2">import </span><span class="s1">collections.abc</span>
<span class="s2">import </span><span class="s1">contextlib</span>
<span class="s2">import </span><span class="s1">functools</span>
<span class="s2">import </span><span class="s1">gzip</span>
<span class="s2">import </span><span class="s1">itertools</span>
<span class="s2">import </span><span class="s1">math</span>
<span class="s2">import </span><span class="s1">operator</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">from </span><span class="s1">pathlib </span><span class="s2">import </span><span class="s1">Path</span>
<span class="s2">import </span><span class="s1">shlex</span>
<span class="s2">import </span><span class="s1">subprocess</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">time</span>
<span class="s2">import </span><span class="s1">traceback</span>
<span class="s2">import </span><span class="s1">types</span>
<span class="s2">import </span><span class="s1">weakref</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">try</span><span class="s1">:</span>
    <span class="s2">from </span><span class="s1">numpy.exceptions </span><span class="s2">import </span><span class="s1">VisibleDeprecationWarning  </span><span class="s3"># numpy &gt;= 1.25</span>
<span class="s2">except </span><span class="s1">ImportError:</span>
    <span class="s2">from </span><span class="s1">numpy </span><span class="s2">import </span><span class="s1">VisibleDeprecationWarning</span>

<span class="s2">import </span><span class="s1">matplotlib</span>
<span class="s2">from </span><span class="s1">matplotlib </span><span class="s2">import </span><span class="s1">_api</span><span class="s2">, </span><span class="s1">_c_internal_utils</span>


<span class="s2">def </span><span class="s1">_get_running_interactive_framework():</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the interactive framework whose event loop is currently running, if 
    any, or &quot;headless&quot; if no event loop can be started, or None. 
 
    Returns 
    ------- 
    Optional[str] 
        One of the following values: &quot;qt&quot;, &quot;gtk3&quot;, &quot;gtk4&quot;, &quot;wx&quot;, &quot;tk&quot;, 
        &quot;macosx&quot;, &quot;headless&quot;, ``None``. 
    &quot;&quot;&quot;</span>
    <span class="s3"># Use ``sys.modules.get(name)`` rather than ``name in sys.modules`` as</span>
    <span class="s3"># entries can also have been explicitly set to None.</span>
    <span class="s1">QtWidgets = (</span>
        <span class="s1">sys.modules.get(</span><span class="s4">&quot;PyQt6.QtWidgets&quot;</span><span class="s1">)</span>
        <span class="s2">or </span><span class="s1">sys.modules.get(</span><span class="s4">&quot;PySide6.QtWidgets&quot;</span><span class="s1">)</span>
        <span class="s2">or </span><span class="s1">sys.modules.get(</span><span class="s4">&quot;PyQt5.QtWidgets&quot;</span><span class="s1">)</span>
        <span class="s2">or </span><span class="s1">sys.modules.get(</span><span class="s4">&quot;PySide2.QtWidgets&quot;</span><span class="s1">)</span>
    <span class="s1">)</span>
    <span class="s2">if </span><span class="s1">QtWidgets </span><span class="s2">and </span><span class="s1">QtWidgets.QApplication.instance():</span>
        <span class="s2">return </span><span class="s4">&quot;qt&quot;</span>
    <span class="s1">Gtk = sys.modules.get(</span><span class="s4">&quot;gi.repository.Gtk&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">Gtk:</span>
        <span class="s2">if </span><span class="s1">Gtk.MAJOR_VERSION == </span><span class="s5">4</span><span class="s1">:</span>
            <span class="s2">from </span><span class="s1">gi.repository </span><span class="s2">import </span><span class="s1">GLib</span>
            <span class="s2">if </span><span class="s1">GLib.main_depth():</span>
                <span class="s2">return </span><span class="s4">&quot;gtk4&quot;</span>
        <span class="s2">if </span><span class="s1">Gtk.MAJOR_VERSION == </span><span class="s5">3 </span><span class="s2">and </span><span class="s1">Gtk.main_level():</span>
            <span class="s2">return </span><span class="s4">&quot;gtk3&quot;</span>
    <span class="s1">wx = sys.modules.get(</span><span class="s4">&quot;wx&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">wx </span><span class="s2">and </span><span class="s1">wx.GetApp():</span>
        <span class="s2">return </span><span class="s4">&quot;wx&quot;</span>
    <span class="s1">tkinter = sys.modules.get(</span><span class="s4">&quot;tkinter&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">tkinter:</span>
        <span class="s1">codes = {tkinter.mainloop.__code__</span><span class="s2">, </span><span class="s1">tkinter.Misc.mainloop.__code__}</span>
        <span class="s2">for </span><span class="s1">frame </span><span class="s2">in </span><span class="s1">sys._current_frames().values():</span>
            <span class="s2">while </span><span class="s1">frame:</span>
                <span class="s2">if </span><span class="s1">frame.f_code </span><span class="s2">in </span><span class="s1">codes:</span>
                    <span class="s2">return </span><span class="s4">&quot;tk&quot;</span>
                <span class="s1">frame = frame.f_back</span>
        <span class="s3"># premetively break reference cycle between locals and the frame</span>
        <span class="s2">del </span><span class="s1">frame</span>
    <span class="s1">macosx = sys.modules.get(</span><span class="s4">&quot;matplotlib.backends._macosx&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">macosx </span><span class="s2">and </span><span class="s1">macosx.event_loop_is_running():</span>
        <span class="s2">return </span><span class="s4">&quot;macosx&quot;</span>
    <span class="s2">if not </span><span class="s1">_c_internal_utils.display_is_valid():</span>
        <span class="s2">return </span><span class="s4">&quot;headless&quot;</span>
    <span class="s2">return None</span>


<span class="s2">def </span><span class="s1">_exception_printer(exc):</span>
    <span class="s2">if </span><span class="s1">_get_running_interactive_framework() </span><span class="s2">in </span><span class="s1">[</span><span class="s4">&quot;headless&quot;</span><span class="s2">, None</span><span class="s1">]:</span>
        <span class="s2">raise </span><span class="s1">exc</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">traceback.print_exc()</span>


<span class="s2">class </span><span class="s1">_StrongRef:</span>
    <span class="s0">&quot;&quot;&quot; 
    Wrapper similar to a weakref, but keeping a strong reference to the object. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">obj):</span>
        <span class="s1">self._obj = obj</span>

    <span class="s2">def </span><span class="s1">__call__(self):</span>
        <span class="s2">return </span><span class="s1">self._obj</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other):</span>
        <span class="s2">return </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">_StrongRef) </span><span class="s2">and </span><span class="s1">self._obj == other._obj</span>

    <span class="s2">def </span><span class="s1">__hash__(self):</span>
        <span class="s2">return </span><span class="s1">hash(self._obj)</span>


<span class="s2">def </span><span class="s1">_weak_or_strong_ref(func</span><span class="s2">, </span><span class="s1">callback):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return a `WeakMethod` wrapping *func* if possible, else a `_StrongRef`. 
    &quot;&quot;&quot;</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">weakref.WeakMethod(func</span><span class="s2">, </span><span class="s1">callback)</span>
    <span class="s2">except </span><span class="s1">TypeError:</span>
        <span class="s2">return </span><span class="s1">_StrongRef(func)</span>


<span class="s2">class </span><span class="s1">CallbackRegistry:</span>
    <span class="s0">&quot;&quot;&quot; 
    Handle registering, processing, blocking, and disconnecting 
    for a set of signals and callbacks: 
 
        &gt;&gt;&gt; def oneat(x): 
        ...     print('eat', x) 
        &gt;&gt;&gt; def ondrink(x): 
        ...     print('drink', x) 
 
        &gt;&gt;&gt; from matplotlib.cbook import CallbackRegistry 
        &gt;&gt;&gt; callbacks = CallbackRegistry() 
 
        &gt;&gt;&gt; id_eat = callbacks.connect('eat', oneat) 
        &gt;&gt;&gt; id_drink = callbacks.connect('drink', ondrink) 
 
        &gt;&gt;&gt; callbacks.process('drink', 123) 
        drink 123 
        &gt;&gt;&gt; callbacks.process('eat', 456) 
        eat 456 
        &gt;&gt;&gt; callbacks.process('be merry', 456)   # nothing will be called 
 
        &gt;&gt;&gt; callbacks.disconnect(id_eat) 
        &gt;&gt;&gt; callbacks.process('eat', 456)        # nothing will be called 
 
        &gt;&gt;&gt; with callbacks.blocked(signal='drink'): 
        ...     callbacks.process('drink', 123)  # nothing will be called 
        &gt;&gt;&gt; callbacks.process('drink', 123) 
        drink 123 
 
    In practice, one should always disconnect all callbacks when they are 
    no longer needed to avoid dangling references (and thus memory leaks). 
    However, real code in Matplotlib rarely does so, and due to its design, 
    it is rather difficult to place this kind of code.  To get around this, 
    and prevent this class of memory leaks, we instead store weak references 
    to bound methods only, so when the destination object needs to die, the 
    CallbackRegistry won't keep it alive. 
 
    Parameters 
    ---------- 
    exception_handler : callable, optional 
       If not None, *exception_handler* must be a function that takes an 
       `Exception` as single parameter.  It gets called with any `Exception` 
       raised by the callbacks during `CallbackRegistry.process`, and may 
       either re-raise the exception or handle it in another manner. 
 
       The default handler prints the exception (with `traceback.print_exc`) if 
       an interactive event loop is running; it re-raises the exception if no 
       interactive event loop is running. 
 
    signals : list, optional 
        If not None, *signals* is a list of signals that this registry handles: 
        attempting to `process` or to `connect` to a signal not in the list 
        throws a `ValueError`.  The default, None, does not restrict the 
        handled signals. 
    &quot;&quot;&quot;</span>

    <span class="s3"># We maintain two mappings:</span>
    <span class="s3">#   callbacks: signal -&gt; {cid -&gt; weakref-to-callback}</span>
    <span class="s3">#   _func_cid_map: signal -&gt; {weakref-to-callback -&gt; cid}</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">exception_handler=_exception_printer</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">signals=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">self._signals = </span><span class="s2">None if </span><span class="s1">signals </span><span class="s2">is None else </span><span class="s1">list(signals)  </span><span class="s3"># Copy it.</span>
        <span class="s1">self.exception_handler = exception_handler</span>
        <span class="s1">self.callbacks = {}</span>
        <span class="s1">self._cid_gen = itertools.count()</span>
        <span class="s1">self._func_cid_map = {}</span>
        <span class="s3"># A hidden variable that marks cids that need to be pickled.</span>
        <span class="s1">self._pickled_cids = set()</span>

    <span class="s2">def </span><span class="s1">__getstate__(self):</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">**vars(self)</span><span class="s2">,</span>
            <span class="s3"># In general, callbacks may not be pickled, so we just drop them,</span>
            <span class="s3"># unless directed otherwise by self._pickled_cids.</span>
            <span class="s4">&quot;callbacks&quot;</span><span class="s1">: {s: {cid: proxy() </span><span class="s2">for </span><span class="s1">cid</span><span class="s2">, </span><span class="s1">proxy </span><span class="s2">in </span><span class="s1">d.items()</span>
                              <span class="s2">if </span><span class="s1">cid </span><span class="s2">in </span><span class="s1">self._pickled_cids}</span>
                          <span class="s2">for </span><span class="s1">s</span><span class="s2">, </span><span class="s1">d </span><span class="s2">in </span><span class="s1">self.callbacks.items()}</span><span class="s2">,</span>
            <span class="s3"># It is simpler to reconstruct this from callbacks in __setstate__.</span>
            <span class="s4">&quot;_func_cid_map&quot;</span><span class="s1">: </span><span class="s2">None,</span>
            <span class="s4">&quot;_cid_gen&quot;</span><span class="s1">: next(self._cid_gen)</span>
        <span class="s1">}</span>

    <span class="s2">def </span><span class="s1">__setstate__(self</span><span class="s2">, </span><span class="s1">state):</span>
        <span class="s1">cid_count = state.pop(</span><span class="s4">'_cid_gen'</span><span class="s1">)</span>
        <span class="s1">vars(self).update(state)</span>
        <span class="s1">self.callbacks = {</span>
            <span class="s1">s: {cid: _weak_or_strong_ref(func</span><span class="s2">, </span><span class="s1">self._remove_proxy)</span>
                <span class="s2">for </span><span class="s1">cid</span><span class="s2">, </span><span class="s1">func </span><span class="s2">in </span><span class="s1">d.items()}</span>
            <span class="s2">for </span><span class="s1">s</span><span class="s2">, </span><span class="s1">d </span><span class="s2">in </span><span class="s1">self.callbacks.items()}</span>
        <span class="s1">self._func_cid_map = {</span>
            <span class="s1">s: {proxy: cid </span><span class="s2">for </span><span class="s1">cid</span><span class="s2">, </span><span class="s1">proxy </span><span class="s2">in </span><span class="s1">d.items()}</span>
            <span class="s2">for </span><span class="s1">s</span><span class="s2">, </span><span class="s1">d </span><span class="s2">in </span><span class="s1">self.callbacks.items()}</span>
        <span class="s1">self._cid_gen = itertools.count(cid_count)</span>

    <span class="s2">def </span><span class="s1">connect(self</span><span class="s2">, </span><span class="s1">signal</span><span class="s2">, </span><span class="s1">func):</span>
        <span class="s0">&quot;&quot;&quot;Register *func* to be called when signal *signal* is generated.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._signals </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">_api.check_in_list(self._signals</span><span class="s2">, </span><span class="s1">signal=signal)</span>
        <span class="s1">self._func_cid_map.setdefault(signal</span><span class="s2">, </span><span class="s1">{})</span>
        <span class="s1">proxy = _weak_or_strong_ref(func</span><span class="s2">, </span><span class="s1">self._remove_proxy)</span>
        <span class="s2">if </span><span class="s1">proxy </span><span class="s2">in </span><span class="s1">self._func_cid_map[signal]:</span>
            <span class="s2">return </span><span class="s1">self._func_cid_map[signal][proxy]</span>
        <span class="s1">cid = next(self._cid_gen)</span>
        <span class="s1">self._func_cid_map[signal][proxy] = cid</span>
        <span class="s1">self.callbacks.setdefault(signal</span><span class="s2">, </span><span class="s1">{})</span>
        <span class="s1">self.callbacks[signal][cid] = proxy</span>
        <span class="s2">return </span><span class="s1">cid</span>

    <span class="s2">def </span><span class="s1">_connect_picklable(self</span><span class="s2">, </span><span class="s1">signal</span><span class="s2">, </span><span class="s1">func):</span>
        <span class="s0">&quot;&quot;&quot; 
        Like `.connect`, but the callback is kept when pickling/unpickling. 
 
        Currently internal-use only. 
        &quot;&quot;&quot;</span>
        <span class="s1">cid = self.connect(signal</span><span class="s2">, </span><span class="s1">func)</span>
        <span class="s1">self._pickled_cids.add(cid)</span>
        <span class="s2">return </span><span class="s1">cid</span>

    <span class="s3"># Keep a reference to sys.is_finalizing, as sys may have been cleared out</span>
    <span class="s3"># at that point.</span>
    <span class="s2">def </span><span class="s1">_remove_proxy(self</span><span class="s2">, </span><span class="s1">proxy</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">_is_finalizing=sys.is_finalizing):</span>
        <span class="s2">if </span><span class="s1">_is_finalizing():</span>
            <span class="s3"># Weakrefs can't be properly torn down at that point anymore.</span>
            <span class="s2">return</span>
        <span class="s2">for </span><span class="s1">signal</span><span class="s2">, </span><span class="s1">proxy_to_cid </span><span class="s2">in </span><span class="s1">list(self._func_cid_map.items()):</span>
            <span class="s1">cid = proxy_to_cid.pop(proxy</span><span class="s2">, None</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">cid </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">del </span><span class="s1">self.callbacks[signal][cid]</span>
                <span class="s1">self._pickled_cids.discard(cid)</span>
                <span class="s2">break</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s3"># Not found</span>
            <span class="s2">return</span>
        <span class="s3"># Clean up empty dicts</span>
        <span class="s2">if </span><span class="s1">len(self.callbacks[signal]) == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2">del </span><span class="s1">self.callbacks[signal]</span>
            <span class="s2">del </span><span class="s1">self._func_cid_map[signal]</span>

    <span class="s2">def </span><span class="s1">disconnect(self</span><span class="s2">, </span><span class="s1">cid):</span>
        <span class="s0">&quot;&quot;&quot; 
        Disconnect the callback registered with callback id *cid*. 
 
        No error is raised if such a callback does not exist. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._pickled_cids.discard(cid)</span>
        <span class="s3"># Clean up callbacks</span>
        <span class="s2">for </span><span class="s1">signal</span><span class="s2">, </span><span class="s1">cid_to_proxy </span><span class="s2">in </span><span class="s1">list(self.callbacks.items()):</span>
            <span class="s1">proxy = cid_to_proxy.pop(cid</span><span class="s2">, None</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">proxy </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">break</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s3"># Not found</span>
            <span class="s2">return</span>

        <span class="s1">proxy_to_cid = self._func_cid_map[signal]</span>
        <span class="s2">for </span><span class="s1">current_proxy</span><span class="s2">, </span><span class="s1">current_cid </span><span class="s2">in </span><span class="s1">list(proxy_to_cid.items()):</span>
            <span class="s2">if </span><span class="s1">current_cid == cid:</span>
                <span class="s2">assert </span><span class="s1">proxy </span><span class="s2">is </span><span class="s1">current_proxy</span>
                <span class="s2">del </span><span class="s1">proxy_to_cid[current_proxy]</span>
        <span class="s3"># Clean up empty dicts</span>
        <span class="s2">if </span><span class="s1">len(self.callbacks[signal]) == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2">del </span><span class="s1">self.callbacks[signal]</span>
            <span class="s2">del </span><span class="s1">self._func_cid_map[signal]</span>

    <span class="s2">def </span><span class="s1">process(self</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Process signal *s*. 
 
        All of the functions registered to receive callbacks on *s* will be 
        called with ``*args`` and ``**kwargs``. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._signals </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">_api.check_in_list(self._signals</span><span class="s2">, </span><span class="s1">signal=s)</span>
        <span class="s2">for </span><span class="s1">ref </span><span class="s2">in </span><span class="s1">list(self.callbacks.get(s</span><span class="s2">, </span><span class="s1">{}).values()):</span>
            <span class="s1">func = ref()</span>
            <span class="s2">if </span><span class="s1">func </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">func(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
                <span class="s3"># this does not capture KeyboardInterrupt, SystemExit,</span>
                <span class="s3"># and GeneratorExit</span>
                <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">exc:</span>
                    <span class="s2">if </span><span class="s1">self.exception_handler </span><span class="s2">is not None</span><span class="s1">:</span>
                        <span class="s1">self.exception_handler(exc)</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s2">raise</span>

    <span class="s1">@contextlib.contextmanager</span>
    <span class="s2">def </span><span class="s1">blocked(self</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">signal=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Block callback signals from being processed. 
 
        A context manager to temporarily block/disable callback signals 
        from being processed by the registered listeners. 
 
        Parameters 
        ---------- 
        signal : str, optional 
            The callback signal to block. The default is to block all signals. 
        &quot;&quot;&quot;</span>
        <span class="s1">orig = self.callbacks</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">signal </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s3"># Empty out the callbacks</span>
                <span class="s1">self.callbacks = {}</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s3"># Only remove the specific signal</span>
                <span class="s1">self.callbacks = {k: orig[k] </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">orig </span><span class="s2">if </span><span class="s1">k != signal}</span>
            <span class="s2">yield</span>
        <span class="s2">finally</span><span class="s1">:</span>
            <span class="s1">self.callbacks = orig</span>


<span class="s2">class </span><span class="s1">silent_list(list):</span>
    <span class="s0">&quot;&quot;&quot; 
    A list with a short ``repr()``. 
 
    This is meant to be used for a homogeneous list of artists, so that they 
    don't cause long, meaningless output. 
 
    Instead of :: 
 
        [&lt;matplotlib.lines.Line2D object at 0x7f5749fed3c8&gt;, 
         &lt;matplotlib.lines.Line2D object at 0x7f5749fed4e0&gt;, 
         &lt;matplotlib.lines.Line2D object at 0x7f5758016550&gt;] 
 
    one will get :: 
 
        &lt;a list of 3 Line2D objects&gt; 
 
    If ``self.type`` is None, the type name is obtained from the first item in 
    the list (if any). 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">type</span><span class="s2">, </span><span class="s1">seq=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">self.type = type</span>
        <span class="s2">if </span><span class="s1">seq </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.extend(seq)</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s2">if </span><span class="s1">self.type </span><span class="s2">is not None or </span><span class="s1">len(self) != </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">tp = self.type </span><span class="s2">if </span><span class="s1">self.type </span><span class="s2">is not None else </span><span class="s1">type(self[</span><span class="s5">0</span><span class="s1">]).__name__</span>
            <span class="s2">return </span><span class="s4">f&quot;&lt;a list of </span><span class="s2">{</span><span class="s1">len(self)</span><span class="s2">} {</span><span class="s1">tp</span><span class="s2">} </span><span class="s4">objects&gt;&quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s4">&quot;&lt;an empty list&gt;&quot;</span>


<span class="s2">def </span><span class="s1">_local_over_kwdict(</span>
        <span class="s1">local_var</span><span class="s2">, </span><span class="s1">kwargs</span><span class="s2">, </span><span class="s1">*keys</span><span class="s2">,</span>
        <span class="s1">warning_cls=_api.MatplotlibDeprecationWarning):</span>
    <span class="s1">out = local_var</span>
    <span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">keys:</span>
        <span class="s1">kwarg_val = kwargs.pop(key</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">kwarg_val </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">out </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">out = kwarg_val</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">_api.warn_external(</span><span class="s4">f'&quot;</span><span class="s2">{</span><span class="s1">key</span><span class="s2">}</span><span class="s4">&quot; keyword argument will be ignored'</span><span class="s2">,</span>
                                   <span class="s1">warning_cls)</span>
    <span class="s2">return </span><span class="s1">out</span>


<span class="s2">def </span><span class="s1">strip_math(s):</span>
    <span class="s0">&quot;&quot;&quot; 
    Remove latex formatting from mathtext. 
 
    Only handles fully math and fully non-math strings. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">len(s) &gt;= </span><span class="s5">2 </span><span class="s2">and </span><span class="s1">s[</span><span class="s5">0</span><span class="s1">] == s[-</span><span class="s5">1</span><span class="s1">] == </span><span class="s4">&quot;$&quot;</span><span class="s1">:</span>
        <span class="s1">s = s[</span><span class="s5">1</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s2">for </span><span class="s1">tex</span><span class="s2">, </span><span class="s1">plain </span><span class="s2">in </span><span class="s1">[</span>
                <span class="s1">(</span><span class="s4">r&quot;\times&quot;</span><span class="s2">, </span><span class="s4">&quot;x&quot;</span><span class="s1">)</span><span class="s2">,  </span><span class="s3"># Specifically for Formatter support.</span>
                <span class="s1">(</span><span class="s4">r&quot;\mathdefault&quot;</span><span class="s2">, </span><span class="s4">&quot;&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">(</span><span class="s4">r&quot;\rm&quot;</span><span class="s2">, </span><span class="s4">&quot;&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">(</span><span class="s4">r&quot;\cal&quot;</span><span class="s2">, </span><span class="s4">&quot;&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">(</span><span class="s4">r&quot;\tt&quot;</span><span class="s2">, </span><span class="s4">&quot;&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">(</span><span class="s4">r&quot;\it&quot;</span><span class="s2">, </span><span class="s4">&quot;&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">(</span><span class="s4">&quot;</span><span class="s2">\\</span><span class="s4">&quot;</span><span class="s2">, </span><span class="s4">&quot;&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">(</span><span class="s4">&quot;{&quot;</span><span class="s2">, </span><span class="s4">&quot;&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">(</span><span class="s4">&quot;}&quot;</span><span class="s2">, </span><span class="s4">&quot;&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]:</span>
            <span class="s1">s = s.replace(tex</span><span class="s2">, </span><span class="s1">plain)</span>
    <span class="s2">return </span><span class="s1">s</span>


<span class="s2">def </span><span class="s1">_strip_comment(s):</span>
    <span class="s0">&quot;&quot;&quot;Strip everything from the first unquoted #.&quot;&quot;&quot;</span>
    <span class="s1">pos = </span><span class="s5">0</span>
    <span class="s2">while True</span><span class="s1">:</span>
        <span class="s1">quote_pos = s.find(</span><span class="s4">'&quot;'</span><span class="s2">, </span><span class="s1">pos)</span>
        <span class="s1">hash_pos = s.find(</span><span class="s4">'#'</span><span class="s2">, </span><span class="s1">pos)</span>
        <span class="s2">if </span><span class="s1">quote_pos &lt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">without_comment = s </span><span class="s2">if </span><span class="s1">hash_pos &lt; </span><span class="s5">0 </span><span class="s2">else </span><span class="s1">s[:hash_pos]</span>
            <span class="s2">return </span><span class="s1">without_comment.strip()</span>
        <span class="s2">elif </span><span class="s5">0 </span><span class="s1">&lt;= hash_pos &lt; quote_pos:</span>
            <span class="s2">return </span><span class="s1">s[:hash_pos].strip()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">closing_quote_pos = s.find(</span><span class="s4">'&quot;'</span><span class="s2">, </span><span class="s1">quote_pos + </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">closing_quote_pos &lt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">f&quot;Missing closing quote in: </span><span class="s2">{</span><span class="s1">s</span><span class="s2">!r}</span><span class="s4">. If you need a double-&quot;</span>
                    <span class="s4">'quote inside a string, use escaping: e.g. &quot;the </span><span class="s2">\&quot; </span><span class="s4">char&quot;'</span><span class="s1">)</span>
            <span class="s1">pos = closing_quote_pos + </span><span class="s5">1  </span><span class="s3"># behind closing quote</span>


<span class="s2">def </span><span class="s1">is_writable_file_like(obj):</span>
    <span class="s0">&quot;&quot;&quot;Return whether *obj* looks like a file object with a *write* method.&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">callable(getattr(obj</span><span class="s2">, </span><span class="s4">'write'</span><span class="s2">, None</span><span class="s1">))</span>


<span class="s2">def </span><span class="s1">file_requires_unicode(x):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return whether the given writable file-like object requires Unicode to be 
    written to it. 
    &quot;&quot;&quot;</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">x.write(</span><span class="s6">b''</span><span class="s1">)</span>
    <span class="s2">except </span><span class="s1">TypeError:</span>
        <span class="s2">return True</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return False</span>


<span class="s2">def </span><span class="s1">to_filehandle(fname</span><span class="s2">, </span><span class="s1">flag=</span><span class="s4">'r'</span><span class="s2">, </span><span class="s1">return_opened=</span><span class="s2">False, </span><span class="s1">encoding=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert a path to an open file handle or pass-through a file-like object. 
 
    Consider using `open_file_cm` instead, as it allows one to properly close 
    newly created file objects more easily. 
 
    Parameters 
    ---------- 
    fname : str or path-like or file-like 
        If `str` or `os.PathLike`, the file is opened using the flags specified 
        by *flag* and *encoding*.  If a file-like object, it is passed through. 
    flag : str, default: 'r' 
        Passed as the *mode* argument to `open` when *fname* is `str` or 
        `os.PathLike`; ignored if *fname* is file-like. 
    return_opened : bool, default: False 
        If True, return both the file object and a boolean indicating whether 
        this was a new file (that the caller needs to close).  If False, return 
        only the new file. 
    encoding : str or None, default: None 
        Passed as the *mode* argument to `open` when *fname* is `str` or 
        `os.PathLike`; ignored if *fname* is file-like. 
 
    Returns 
    ------- 
    fh : file-like 
    opened : bool 
        *opened* is only returned if *return_opened* is True. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance(fname</span><span class="s2">, </span><span class="s1">os.PathLike):</span>
        <span class="s1">fname = os.fspath(fname)</span>
    <span class="s2">if </span><span class="s1">isinstance(fname</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s2">if </span><span class="s1">fname.endswith(</span><span class="s4">'.gz'</span><span class="s1">):</span>
            <span class="s1">fh = gzip.open(fname</span><span class="s2">, </span><span class="s1">flag)</span>
        <span class="s2">elif </span><span class="s1">fname.endswith(</span><span class="s4">'.bz2'</span><span class="s1">):</span>
            <span class="s3"># python may not be compiled with bz2 support,</span>
            <span class="s3"># bury import until we need it</span>
            <span class="s2">import </span><span class="s1">bz2</span>
            <span class="s1">fh = bz2.BZ2File(fname</span><span class="s2">, </span><span class="s1">flag)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">fh = open(fname</span><span class="s2">, </span><span class="s1">flag</span><span class="s2">, </span><span class="s1">encoding=encoding)</span>
        <span class="s1">opened = </span><span class="s2">True</span>
    <span class="s2">elif </span><span class="s1">hasattr(fname</span><span class="s2">, </span><span class="s4">'seek'</span><span class="s1">):</span>
        <span class="s1">fh = fname</span>
        <span class="s1">opened = </span><span class="s2">False</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'fname must be a PathLike or file handle'</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">return_opened:</span>
        <span class="s2">return </span><span class="s1">fh</span><span class="s2">, </span><span class="s1">opened</span>
    <span class="s2">return </span><span class="s1">fh</span>


<span class="s2">def </span><span class="s1">open_file_cm(path_or_file</span><span class="s2">, </span><span class="s1">mode=</span><span class="s4">&quot;r&quot;</span><span class="s2">, </span><span class="s1">encoding=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">r&quot;&quot;&quot;Pass through file objects and context-manage path-likes.&quot;&quot;&quot;</span>
    <span class="s1">fh</span><span class="s2">, </span><span class="s1">opened = to_filehandle(path_or_file</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">, True, </span><span class="s1">encoding)</span>
    <span class="s2">return </span><span class="s1">fh </span><span class="s2">if </span><span class="s1">opened </span><span class="s2">else </span><span class="s1">contextlib.nullcontext(fh)</span>


<span class="s2">def </span><span class="s1">is_scalar_or_string(val):</span>
    <span class="s0">&quot;&quot;&quot;Return whether the given object is a scalar or string like.&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">isinstance(val</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">or not </span><span class="s1">np.iterable(val)</span>


<span class="s1">@_api.delete_parameter(</span>
    <span class="s4">&quot;3.8&quot;</span><span class="s2">, </span><span class="s4">&quot;np_load&quot;</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s4">&quot;open(get_sample_data(..., asfileobj=False))&quot;</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">get_sample_data(fname</span><span class="s2">, </span><span class="s1">asfileobj=</span><span class="s2">True, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">np_load=</span><span class="s2">True</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return a sample data file.  *fname* is a path relative to the 
    :file:`mpl-data/sample_data` directory.  If *asfileobj* is `True` 
    return a file object, otherwise just a file path. 
 
    Sample data files are stored in the 'mpl-data/sample_data' directory within 
    the Matplotlib package. 
 
    If the filename ends in .gz, the file is implicitly ungzipped.  If the 
    filename ends with .npy or .npz, and *asfileobj* is `True`, the file is 
    loaded with `numpy.load`. 
    &quot;&quot;&quot;</span>
    <span class="s1">path = _get_data_path(</span><span class="s4">'sample_data'</span><span class="s2">, </span><span class="s1">fname)</span>
    <span class="s2">if </span><span class="s1">asfileobj:</span>
        <span class="s1">suffix = path.suffix.lower()</span>
        <span class="s2">if </span><span class="s1">suffix == </span><span class="s4">'.gz'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">gzip.open(path)</span>
        <span class="s2">elif </span><span class="s1">suffix </span><span class="s2">in </span><span class="s1">[</span><span class="s4">'.npy'</span><span class="s2">, </span><span class="s4">'.npz'</span><span class="s1">]:</span>
            <span class="s2">if </span><span class="s1">np_load:</span>
                <span class="s2">return </span><span class="s1">np.load(path)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">path.open(</span><span class="s4">'rb'</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">suffix </span><span class="s2">in </span><span class="s1">[</span><span class="s4">'.csv'</span><span class="s2">, </span><span class="s4">'.xrc'</span><span class="s2">, </span><span class="s4">'.txt'</span><span class="s1">]:</span>
            <span class="s2">return </span><span class="s1">path.open(</span><span class="s4">'r'</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">path.open(</span><span class="s4">'rb'</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">str(path)</span>


<span class="s2">def </span><span class="s1">_get_data_path(*args):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the `pathlib.Path` to a resource file provided by Matplotlib. 
 
    ``*args`` specify a path relative to the base data path. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">Path(matplotlib.get_data_path()</span><span class="s2">, </span><span class="s1">*args)</span>


<span class="s2">def </span><span class="s1">flatten(seq</span><span class="s2">, </span><span class="s1">scalarp=is_scalar_or_string):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return a generator of flattened nested containers. 
 
    For example: 
 
        &gt;&gt;&gt; from matplotlib.cbook import flatten 
        &gt;&gt;&gt; l = (('John', ['Hunter']), (1, 23), [[([42, (5, 23)], )]]) 
        &gt;&gt;&gt; print(list(flatten(l))) 
        ['John', 'Hunter', 1, 23, 42, 5, 23] 
 
    By: Composite of Holger Krekel and Luther Blissett 
    From: https://code.activestate.com/recipes/121294/ 
    and Recipe 1.12 in cookbook 
    &quot;&quot;&quot;</span>
    <span class="s2">for </span><span class="s1">item </span><span class="s2">in </span><span class="s1">seq:</span>
        <span class="s2">if </span><span class="s1">scalarp(item) </span><span class="s2">or </span><span class="s1">item </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">yield </span><span class="s1">item</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">yield from </span><span class="s1">flatten(item</span><span class="s2">, </span><span class="s1">scalarp)</span>


<span class="s1">@_api.deprecated(</span><span class="s4">&quot;3.8&quot;</span><span class="s1">)</span>
<span class="s2">class </span><span class="s1">Stack:</span>
    <span class="s0">&quot;&quot;&quot; 
    Stack of elements with a movable cursor. 
 
    Mimics home/back/forward in a web browser. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">default=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">self.clear()</span>
        <span class="s1">self._default = default</span>

    <span class="s2">def </span><span class="s1">__call__(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the current element, or None.&quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">self._elements:</span>
            <span class="s2">return </span><span class="s1">self._default</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self._elements[self._pos]</span>

    <span class="s2">def </span><span class="s1">__len__(self):</span>
        <span class="s2">return </span><span class="s1">len(self._elements)</span>

    <span class="s2">def </span><span class="s1">__getitem__(self</span><span class="s2">, </span><span class="s1">ind):</span>
        <span class="s2">return </span><span class="s1">self._elements[ind]</span>

    <span class="s2">def </span><span class="s1">forward(self):</span>
        <span class="s0">&quot;&quot;&quot;Move the position forward and return the current element.&quot;&quot;&quot;</span>
        <span class="s1">self._pos = min(self._pos + </span><span class="s5">1</span><span class="s2">, </span><span class="s1">len(self._elements) - </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self()</span>

    <span class="s2">def </span><span class="s1">back(self):</span>
        <span class="s0">&quot;&quot;&quot;Move the position back and return the current element.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._pos &gt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">self._pos -= </span><span class="s5">1</span>
        <span class="s2">return </span><span class="s1">self()</span>

    <span class="s2">def </span><span class="s1">push(self</span><span class="s2">, </span><span class="s1">o):</span>
        <span class="s0">&quot;&quot;&quot; 
        Push *o* to the stack at current position.  Discard all later elements. 
 
        *o* is returned. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._elements = self._elements[:self._pos + </span><span class="s5">1</span><span class="s1">] + [o]</span>
        <span class="s1">self._pos = len(self._elements) - </span><span class="s5">1</span>
        <span class="s2">return </span><span class="s1">self()</span>

    <span class="s2">def </span><span class="s1">home(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Push the first element onto the top of the stack. 
 
        The first element is returned. 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">self._elements:</span>
            <span class="s2">return</span>
        <span class="s1">self.push(self._elements[</span><span class="s5">0</span><span class="s1">])</span>
        <span class="s2">return </span><span class="s1">self()</span>

    <span class="s2">def </span><span class="s1">empty(self):</span>
        <span class="s0">&quot;&quot;&quot;Return whether the stack is empty.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">len(self._elements) == </span><span class="s5">0</span>

    <span class="s2">def </span><span class="s1">clear(self):</span>
        <span class="s0">&quot;&quot;&quot;Empty the stack.&quot;&quot;&quot;</span>
        <span class="s1">self._pos = -</span><span class="s5">1</span>
        <span class="s1">self._elements = []</span>

    <span class="s2">def </span><span class="s1">bubble(self</span><span class="s2">, </span><span class="s1">o):</span>
        <span class="s0">&quot;&quot;&quot; 
        Raise all references of *o* to the top of the stack, and return it. 
 
        Raises 
        ------ 
        ValueError 
            If *o* is not in the stack. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">o </span><span class="s2">not in </span><span class="s1">self._elements:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'Given element not contained in the stack'</span><span class="s1">)</span>
        <span class="s1">old_elements = self._elements.copy()</span>
        <span class="s1">self.clear()</span>
        <span class="s1">top_elements = []</span>
        <span class="s2">for </span><span class="s1">elem </span><span class="s2">in </span><span class="s1">old_elements:</span>
            <span class="s2">if </span><span class="s1">elem == o:</span>
                <span class="s1">top_elements.append(elem)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.push(elem)</span>
        <span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">top_elements:</span>
            <span class="s1">self.push(o)</span>
        <span class="s2">return </span><span class="s1">o</span>

    <span class="s2">def </span><span class="s1">remove(self</span><span class="s2">, </span><span class="s1">o):</span>
        <span class="s0">&quot;&quot;&quot; 
        Remove *o* from the stack. 
 
        Raises 
        ------ 
        ValueError 
            If *o* is not in the stack. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">o </span><span class="s2">not in </span><span class="s1">self._elements:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'Given element not contained in the stack'</span><span class="s1">)</span>
        <span class="s1">old_elements = self._elements.copy()</span>
        <span class="s1">self.clear()</span>
        <span class="s2">for </span><span class="s1">elem </span><span class="s2">in </span><span class="s1">old_elements:</span>
            <span class="s2">if </span><span class="s1">elem != o:</span>
                <span class="s1">self.push(elem)</span>


<span class="s2">class </span><span class="s1">_Stack:</span>
    <span class="s0">&quot;&quot;&quot; 
    Stack of elements with a movable cursor. 
 
    Mimics home/back/forward in a web browser. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">self._pos = -</span><span class="s5">1</span>
        <span class="s1">self._elements = []</span>

    <span class="s2">def </span><span class="s1">clear(self):</span>
        <span class="s0">&quot;&quot;&quot;Empty the stack.&quot;&quot;&quot;</span>
        <span class="s1">self._pos = -</span><span class="s5">1</span>
        <span class="s1">self._elements = []</span>

    <span class="s2">def </span><span class="s1">__call__(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the current element, or None.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._elements[self._pos] </span><span class="s2">if </span><span class="s1">self._elements </span><span class="s2">else None</span>

    <span class="s2">def </span><span class="s1">__len__(self):</span>
        <span class="s2">return </span><span class="s1">len(self._elements)</span>

    <span class="s2">def </span><span class="s1">__getitem__(self</span><span class="s2">, </span><span class="s1">ind):</span>
        <span class="s2">return </span><span class="s1">self._elements[ind]</span>

    <span class="s2">def </span><span class="s1">forward(self):</span>
        <span class="s0">&quot;&quot;&quot;Move the position forward and return the current element.&quot;&quot;&quot;</span>
        <span class="s1">self._pos = min(self._pos + </span><span class="s5">1</span><span class="s2">, </span><span class="s1">len(self._elements) - </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self()</span>

    <span class="s2">def </span><span class="s1">back(self):</span>
        <span class="s0">&quot;&quot;&quot;Move the position back and return the current element.&quot;&quot;&quot;</span>
        <span class="s1">self._pos = max(self._pos - </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self()</span>

    <span class="s2">def </span><span class="s1">push(self</span><span class="s2">, </span><span class="s1">o):</span>
        <span class="s0">&quot;&quot;&quot; 
        Push *o* to the stack after the current position, and return *o*. 
 
        Discard all later elements. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._elements[self._pos + </span><span class="s5">1</span><span class="s1">:] = [o]</span>
        <span class="s1">self._pos = len(self._elements) - </span><span class="s5">1</span>
        <span class="s2">return </span><span class="s1">o</span>

    <span class="s2">def </span><span class="s1">home(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Push the first element onto the top of the stack. 
 
        The first element is returned. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.push(self._elements[</span><span class="s5">0</span><span class="s1">]) </span><span class="s2">if </span><span class="s1">self._elements </span><span class="s2">else None</span>


<span class="s2">def </span><span class="s1">safe_masked_invalid(x</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s1">x = np.array(x</span><span class="s2">, </span><span class="s1">subok=</span><span class="s2">True, </span><span class="s1">copy=copy)</span>
    <span class="s2">if not </span><span class="s1">x.dtype.isnative:</span>
        <span class="s3"># If we have already made a copy, do the byteswap in place, else make a</span>
        <span class="s3"># copy with the byte order swapped.</span>
        <span class="s3"># Swap to native order.</span>
        <span class="s1">x = x.byteswap(inplace=copy).view(x.dtype.newbyteorder(</span><span class="s4">'N'</span><span class="s1">))</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">xm = np.ma.masked_where(~(np.isfinite(x))</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s2">except </span><span class="s1">TypeError:</span>
        <span class="s2">return </span><span class="s1">x</span>
    <span class="s2">return </span><span class="s1">xm</span>


<span class="s2">def </span><span class="s1">print_cycles(objects</span><span class="s2">, </span><span class="s1">outstream=sys.stdout</span><span class="s2">, </span><span class="s1">show_progress=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Print loops of cyclic references in the given *objects*. 
 
    It is often useful to pass in ``gc.garbage`` to find the cycles that are 
    preventing some objects from being garbage collected. 
 
    Parameters 
    ---------- 
    objects 
        A list of objects to find cycles in. 
    outstream 
        The stream for output. 
    show_progress : bool 
        If True, print the number of objects reached as they are found. 
    &quot;&quot;&quot;</span>
    <span class="s2">import </span><span class="s1">gc</span>

    <span class="s2">def </span><span class="s1">print_path(path):</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">step </span><span class="s2">in </span><span class="s1">enumerate(path):</span>
            <span class="s3"># next &quot;wraps around&quot;</span>
            <span class="s1">next = path[(i + </span><span class="s5">1</span><span class="s1">) % len(path)]</span>

            <span class="s1">outstream.write(</span><span class="s4">&quot;   %s -- &quot; </span><span class="s1">% type(step))</span>
            <span class="s2">if </span><span class="s1">isinstance(step</span><span class="s2">, </span><span class="s1">dict):</span>
                <span class="s2">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">val </span><span class="s2">in </span><span class="s1">step.items():</span>
                    <span class="s2">if </span><span class="s1">val </span><span class="s2">is </span><span class="s1">next:</span>
                        <span class="s1">outstream.write(</span><span class="s4">f&quot;[</span><span class="s2">{</span><span class="s1">key</span><span class="s2">!r}</span><span class="s4">]&quot;</span><span class="s1">)</span>
                        <span class="s2">break</span>
                    <span class="s2">if </span><span class="s1">key </span><span class="s2">is </span><span class="s1">next:</span>
                        <span class="s1">outstream.write(</span><span class="s4">f&quot;[key] = </span><span class="s2">{</span><span class="s1">val</span><span class="s2">!r}</span><span class="s4">&quot;</span><span class="s1">)</span>
                        <span class="s2">break</span>
            <span class="s2">elif </span><span class="s1">isinstance(step</span><span class="s2">, </span><span class="s1">list):</span>
                <span class="s1">outstream.write(</span><span class="s4">&quot;[%d]&quot; </span><span class="s1">% step.index(next))</span>
            <span class="s2">elif </span><span class="s1">isinstance(step</span><span class="s2">, </span><span class="s1">tuple):</span>
                <span class="s1">outstream.write(</span><span class="s4">&quot;( tuple )&quot;</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">outstream.write(repr(step))</span>
            <span class="s1">outstream.write(</span><span class="s4">&quot; -&gt;</span><span class="s2">\n</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s1">outstream.write(</span><span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">recurse(obj</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">all</span><span class="s2">, </span><span class="s1">current_path):</span>
        <span class="s2">if </span><span class="s1">show_progress:</span>
            <span class="s1">outstream.write(</span><span class="s4">&quot;%d</span><span class="s2">\r</span><span class="s4">&quot; </span><span class="s1">% len(all))</span>

        <span class="s1">all[id(obj)] = </span><span class="s2">None</span>

        <span class="s1">referents = gc.get_referents(obj)</span>
        <span class="s2">for </span><span class="s1">referent </span><span class="s2">in </span><span class="s1">referents:</span>
            <span class="s3"># If we've found our way back to the start, this is</span>
            <span class="s3"># a cycle, so print it out</span>
            <span class="s2">if </span><span class="s1">referent </span><span class="s2">is </span><span class="s1">start:</span>
                <span class="s1">print_path(current_path)</span>

            <span class="s3"># Don't go back through the original list of objects, or</span>
            <span class="s3"># through temporary references to the object, since those</span>
            <span class="s3"># are just an artifact of the cycle detector itself.</span>
            <span class="s2">elif </span><span class="s1">referent </span><span class="s2">is </span><span class="s1">objects </span><span class="s2">or </span><span class="s1">isinstance(referent</span><span class="s2">, </span><span class="s1">types.FrameType):</span>
                <span class="s2">continue</span>

            <span class="s3"># We haven't seen this object before, so recurse</span>
            <span class="s2">elif </span><span class="s1">id(referent) </span><span class="s2">not in </span><span class="s1">all:</span>
                <span class="s1">recurse(referent</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">all</span><span class="s2">, </span><span class="s1">current_path + [obj])</span>

    <span class="s2">for </span><span class="s1">obj </span><span class="s2">in </span><span class="s1">objects:</span>
        <span class="s1">outstream.write(</span><span class="s4">f&quot;Examining: </span><span class="s2">{</span><span class="s1">obj</span><span class="s2">!r}\n</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s1">recurse(obj</span><span class="s2">, </span><span class="s1">obj</span><span class="s2">, </span><span class="s1">{}</span><span class="s2">, </span><span class="s1">[])</span>


<span class="s2">class </span><span class="s1">Grouper:</span>
    <span class="s0">&quot;&quot;&quot; 
    A disjoint-set data structure. 
 
    Objects can be joined using :meth:`join`, tested for connectedness 
    using :meth:`joined`, and all disjoint sets can be retrieved by 
    using the object as an iterator. 
 
    The objects being joined must be hashable and weak-referenceable. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from matplotlib.cbook import Grouper 
    &gt;&gt;&gt; class Foo: 
    ...     def __init__(self, s): 
    ...         self.s = s 
    ...     def __repr__(self): 
    ...         return self.s 
    ... 
    &gt;&gt;&gt; a, b, c, d, e, f = [Foo(x) for x in 'abcdef'] 
    &gt;&gt;&gt; grp = Grouper() 
    &gt;&gt;&gt; grp.join(a, b) 
    &gt;&gt;&gt; grp.join(b, c) 
    &gt;&gt;&gt; grp.join(d, e) 
    &gt;&gt;&gt; list(grp) 
    [[a, b, c], [d, e]] 
    &gt;&gt;&gt; grp.joined(a, b) 
    True 
    &gt;&gt;&gt; grp.joined(a, c) 
    True 
    &gt;&gt;&gt; grp.joined(a, d) 
    False 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">init=()):</span>
        <span class="s1">self._mapping = weakref.WeakKeyDictionary(</span>
            <span class="s1">{x: weakref.WeakSet([x]) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">init})</span>

    <span class="s2">def </span><span class="s1">__getstate__(self):</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s1">**vars(self)</span><span class="s2">,</span>
            <span class="s3"># Convert weak refs to strong ones.</span>
            <span class="s4">&quot;_mapping&quot;</span><span class="s1">: {k: set(v) </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">self._mapping.items()}</span><span class="s2">,</span>
        <span class="s1">}</span>

    <span class="s2">def </span><span class="s1">__setstate__(self</span><span class="s2">, </span><span class="s1">state):</span>
        <span class="s1">vars(self).update(state)</span>
        <span class="s3"># Convert strong refs to weak ones.</span>
        <span class="s1">self._mapping = weakref.WeakKeyDictionary(</span>
            <span class="s1">{k: weakref.WeakSet(v) </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">self._mapping.items()})</span>

    <span class="s2">def </span><span class="s1">__contains__(self</span><span class="s2">, </span><span class="s1">item):</span>
        <span class="s2">return </span><span class="s1">item </span><span class="s2">in </span><span class="s1">self._mapping</span>

    <span class="s1">@_api.deprecated(</span><span class="s4">&quot;3.8&quot;</span><span class="s2">, </span><span class="s1">alternative=</span><span class="s4">&quot;none, you no longer need to clean a Grouper&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">clean(self):</span>
        <span class="s0">&quot;&quot;&quot;Clean dead weak references from the dictionary.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">join(self</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s0">&quot;&quot;&quot; 
        Join given arguments into the same set.  Accepts one or more arguments. 
        &quot;&quot;&quot;</span>
        <span class="s1">mapping = self._mapping</span>
        <span class="s1">set_a = mapping.setdefault(a</span><span class="s2">, </span><span class="s1">weakref.WeakSet([a]))</span>

        <span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">args:</span>
            <span class="s1">set_b = mapping.get(arg</span><span class="s2">, </span><span class="s1">weakref.WeakSet([arg]))</span>
            <span class="s2">if </span><span class="s1">set_b </span><span class="s2">is not </span><span class="s1">set_a:</span>
                <span class="s2">if </span><span class="s1">len(set_b) &gt; len(set_a):</span>
                    <span class="s1">set_a</span><span class="s2">, </span><span class="s1">set_b = set_b</span><span class="s2">, </span><span class="s1">set_a</span>
                <span class="s1">set_a.update(set_b)</span>
                <span class="s2">for </span><span class="s1">elem </span><span class="s2">in </span><span class="s1">set_b:</span>
                    <span class="s1">mapping[elem] = set_a</span>

    <span class="s2">def </span><span class="s1">joined(self</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b):</span>
        <span class="s0">&quot;&quot;&quot;Return whether *a* and *b* are members of the same set.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">(self._mapping.get(a</span><span class="s2">, </span><span class="s1">object()) </span><span class="s2">is </span><span class="s1">self._mapping.get(b))</span>

    <span class="s2">def </span><span class="s1">remove(self</span><span class="s2">, </span><span class="s1">a):</span>
        <span class="s0">&quot;&quot;&quot;Remove *a* from the grouper, doing nothing if it is not there.&quot;&quot;&quot;</span>
        <span class="s1">set_a = self._mapping.pop(a</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">set_a:</span>
            <span class="s1">set_a.remove(a)</span>

    <span class="s2">def </span><span class="s1">__iter__(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Iterate over each of the disjoint sets as a list. 
 
        The iterator is invalid if interleaved with calls to join(). 
        &quot;&quot;&quot;</span>
        <span class="s1">unique_groups = {id(group): group </span><span class="s2">for </span><span class="s1">group </span><span class="s2">in </span><span class="s1">self._mapping.values()}</span>
        <span class="s2">for </span><span class="s1">group </span><span class="s2">in </span><span class="s1">unique_groups.values():</span>
            <span class="s2">yield </span><span class="s1">[x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">group]</span>

    <span class="s2">def </span><span class="s1">get_siblings(self</span><span class="s2">, </span><span class="s1">a):</span>
        <span class="s0">&quot;&quot;&quot;Return all of the items joined with *a*, including itself.&quot;&quot;&quot;</span>
        <span class="s1">siblings = self._mapping.get(a</span><span class="s2">, </span><span class="s1">[a])</span>
        <span class="s2">return </span><span class="s1">[x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">siblings]</span>


<span class="s2">class </span><span class="s1">GrouperView:</span>
    <span class="s0">&quot;&quot;&quot;Immutable view over a `.Grouper`.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">grouper): self._grouper = grouper</span>
    <span class="s2">def </span><span class="s1">__contains__(self</span><span class="s2">, </span><span class="s1">item): </span><span class="s2">return </span><span class="s1">item </span><span class="s2">in </span><span class="s1">self._grouper</span>
    <span class="s2">def </span><span class="s1">__iter__(self): </span><span class="s2">return </span><span class="s1">iter(self._grouper)</span>
    <span class="s2">def </span><span class="s1">joined(self</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b): </span><span class="s2">return </span><span class="s1">self._grouper.joined(a</span><span class="s2">, </span><span class="s1">b)</span>
    <span class="s2">def </span><span class="s1">get_siblings(self</span><span class="s2">, </span><span class="s1">a): </span><span class="s2">return </span><span class="s1">self._grouper.get_siblings(a)</span>


<span class="s2">def </span><span class="s1">simple_linear_interpolation(a</span><span class="s2">, </span><span class="s1">steps):</span>
    <span class="s0">&quot;&quot;&quot; 
    Resample an array with ``steps - 1`` points between original point pairs. 
 
    Along each column of *a*, ``(steps - 1)`` points are introduced between 
    each original values; the values are linearly interpolated. 
 
    Parameters 
    ---------- 
    a : array, shape (n, ...) 
    steps : int 
 
    Returns 
    ------- 
    array 
        shape ``((n - 1) * steps + 1, ...)`` 
    &quot;&quot;&quot;</span>
    <span class="s1">fps = a.reshape((len(a)</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">))</span>
    <span class="s1">xp = np.arange(len(a)) * steps</span>
    <span class="s1">x = np.arange((len(a) - </span><span class="s5">1</span><span class="s1">) * steps + </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">(np.column_stack([np.interp(x</span><span class="s2">, </span><span class="s1">xp</span><span class="s2">, </span><span class="s1">fp) </span><span class="s2">for </span><span class="s1">fp </span><span class="s2">in </span><span class="s1">fps.T])</span>
            <span class="s1">.reshape((len(x)</span><span class="s2">,</span><span class="s1">) + a.shape[</span><span class="s5">1</span><span class="s1">:]))</span>


<span class="s2">def </span><span class="s1">delete_masked_points(*args):</span>
    <span class="s0">&quot;&quot;&quot; 
    Find all masked and/or non-finite points in a set of arguments, 
    and return the arguments with only the unmasked points remaining. 
 
    Arguments can be in any of 5 categories: 
 
    1) 1-D masked arrays 
    2) 1-D ndarrays 
    3) ndarrays with more than one dimension 
    4) other non-string iterables 
    5) anything else 
 
    The first argument must be in one of the first four categories; 
    any argument with a length differing from that of the first 
    argument (and hence anything in category 5) then will be 
    passed through unchanged. 
 
    Masks are obtained from all arguments of the correct length 
    in categories 1, 2, and 4; a point is bad if masked in a masked 
    array or if it is a nan or inf.  No attempt is made to 
    extract a mask from categories 2, 3, and 4 if `numpy.isfinite` 
    does not yield a Boolean array. 
 
    All input arguments that are not passed unchanged are returned 
    as ndarrays after removing the points or rows corresponding to 
    masks in any of the arguments. 
 
    A vastly simpler version of this function was originally 
    written as a helper for Axes.scatter(). 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">len(args):</span>
        <span class="s2">return </span><span class="s1">()</span>
    <span class="s2">if </span><span class="s1">is_scalar_or_string(args[</span><span class="s5">0</span><span class="s1">]):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;First argument must be a sequence&quot;</span><span class="s1">)</span>
    <span class="s1">nrecs = len(args[</span><span class="s5">0</span><span class="s1">])</span>
    <span class="s1">margs = []</span>
    <span class="s1">seqlist = [</span><span class="s2">False</span><span class="s1">] * len(args)</span>
    <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">x </span><span class="s2">in </span><span class="s1">enumerate(args):</span>
        <span class="s2">if not </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">and </span><span class="s1">np.iterable(x) </span><span class="s2">and </span><span class="s1">len(x) == nrecs:</span>
            <span class="s1">seqlist[i] = </span><span class="s2">True</span>
            <span class="s2">if </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">np.ma.MaskedArray):</span>
                <span class="s2">if </span><span class="s1">x.ndim &gt; </span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Masked arrays must be 1-D&quot;</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">x = np.asarray(x)</span>
        <span class="s1">margs.append(x)</span>
    <span class="s1">masks = []  </span><span class="s3"># List of masks that are True where good.</span>
    <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">x </span><span class="s2">in </span><span class="s1">enumerate(margs):</span>
        <span class="s2">if </span><span class="s1">seqlist[i]:</span>
            <span class="s2">if </span><span class="s1">x.ndim &gt; </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s2">continue  </span><span class="s3"># Don't try to get nan locations unless 1-D.</span>
            <span class="s2">if </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">np.ma.MaskedArray):</span>
                <span class="s1">masks.append(~np.ma.getmaskarray(x))  </span><span class="s3"># invert the mask</span>
                <span class="s1">xd = x.data</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">xd = x</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">mask = np.isfinite(xd)</span>
                <span class="s2">if </span><span class="s1">isinstance(mask</span><span class="s2">, </span><span class="s1">np.ndarray):</span>
                    <span class="s1">masks.append(mask)</span>
            <span class="s2">except </span><span class="s1">Exception:  </span><span class="s3"># Fixme: put in tuple of possible exceptions?</span>
                <span class="s2">pass</span>
    <span class="s2">if </span><span class="s1">len(masks):</span>
        <span class="s1">mask = np.logical_and.reduce(masks)</span>
        <span class="s1">igood = mask.nonzero()[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">len(igood) &lt; nrecs:</span>
            <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">x </span><span class="s2">in </span><span class="s1">enumerate(margs):</span>
                <span class="s2">if </span><span class="s1">seqlist[i]:</span>
                    <span class="s1">margs[i] = x[igood]</span>
    <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">x </span><span class="s2">in </span><span class="s1">enumerate(margs):</span>
        <span class="s2">if </span><span class="s1">seqlist[i] </span><span class="s2">and </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">np.ma.MaskedArray):</span>
            <span class="s1">margs[i] = x.filled()</span>
    <span class="s2">return </span><span class="s1">margs</span>


<span class="s2">def </span><span class="s1">_combine_masks(*args):</span>
    <span class="s0">&quot;&quot;&quot; 
    Find all masked and/or non-finite points in a set of arguments, 
    and return the arguments as masked arrays with a common mask. 
 
    Arguments can be in any of 5 categories: 
 
    1) 1-D masked arrays 
    2) 1-D ndarrays 
    3) ndarrays with more than one dimension 
    4) other non-string iterables 
    5) anything else 
 
    The first argument must be in one of the first four categories; 
    any argument with a length differing from that of the first 
    argument (and hence anything in category 5) then will be 
    passed through unchanged. 
 
    Masks are obtained from all arguments of the correct length 
    in categories 1, 2, and 4; a point is bad if masked in a masked 
    array or if it is a nan or inf.  No attempt is made to 
    extract a mask from categories 2 and 4 if `numpy.isfinite` 
    does not yield a Boolean array.  Category 3 is included to 
    support RGB or RGBA ndarrays, which are assumed to have only 
    valid values and which are passed through unchanged. 
 
    All input arguments that are not passed unchanged are returned 
    as masked arrays if any masked points are found, otherwise as 
    ndarrays. 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if not </span><span class="s1">len(args):</span>
        <span class="s2">return </span><span class="s1">()</span>
    <span class="s2">if </span><span class="s1">is_scalar_or_string(args[</span><span class="s5">0</span><span class="s1">]):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;First argument must be a sequence&quot;</span><span class="s1">)</span>
    <span class="s1">nrecs = len(args[</span><span class="s5">0</span><span class="s1">])</span>
    <span class="s1">margs = []  </span><span class="s3"># Output args; some may be modified.</span>
    <span class="s1">seqlist = [</span><span class="s2">False</span><span class="s1">] * len(args)  </span><span class="s3"># Flags: True if output will be masked.</span>
    <span class="s1">masks = []    </span><span class="s3"># List of masks.</span>
    <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">x </span><span class="s2">in </span><span class="s1">enumerate(args):</span>
        <span class="s2">if </span><span class="s1">is_scalar_or_string(x) </span><span class="s2">or </span><span class="s1">len(x) != nrecs:</span>
            <span class="s1">margs.append(x)  </span><span class="s3"># Leave it unmodified.</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">np.ma.MaskedArray) </span><span class="s2">and </span><span class="s1">x.ndim &gt; </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Masked arrays must be 1-D&quot;</span><span class="s1">)</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">x = np.asanyarray(x)</span>
            <span class="s2">except </span><span class="s1">(VisibleDeprecationWarning</span><span class="s2">, </span><span class="s1">ValueError):</span>
                <span class="s3"># NumPy 1.19 raises a warning about ragged arrays, but we want</span>
                <span class="s3"># to accept basically anything here.</span>
                <span class="s1">x = np.asanyarray(x</span><span class="s2">, </span><span class="s1">dtype=object)</span>
            <span class="s2">if </span><span class="s1">x.ndim == </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">x = safe_masked_invalid(x)</span>
                <span class="s1">seqlist[i] = </span><span class="s2">True</span>
                <span class="s2">if </span><span class="s1">np.ma.is_masked(x):</span>
                    <span class="s1">masks.append(np.ma.getmaskarray(x))</span>
            <span class="s1">margs.append(x)  </span><span class="s3"># Possibly modified.</span>
    <span class="s2">if </span><span class="s1">len(masks):</span>
        <span class="s1">mask = np.logical_or.reduce(masks)</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">x </span><span class="s2">in </span><span class="s1">enumerate(margs):</span>
            <span class="s2">if </span><span class="s1">seqlist[i]:</span>
                <span class="s1">margs[i] = np.ma.array(x</span><span class="s2">, </span><span class="s1">mask=mask)</span>
    <span class="s2">return </span><span class="s1">margs</span>


<span class="s2">def </span><span class="s1">boxplot_stats(X</span><span class="s2">, </span><span class="s1">whis=</span><span class="s5">1.5</span><span class="s2">, </span><span class="s1">bootstrap=</span><span class="s2">None, </span><span class="s1">labels=</span><span class="s2">None,</span>
                  <span class="s1">autorange=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Return a list of dictionaries of statistics used to draw a series of box 
    and whisker plots using `~.Axes.bxp`. 
 
    Parameters 
    ---------- 
    X : array-like 
        Data that will be represented in the boxplots. Should have 2 or 
        fewer dimensions. 
 
    whis : float or (float, float), default: 1.5 
        The position of the whiskers. 
 
        If a float, the lower whisker is at the lowest datum above 
        ``Q1 - whis*(Q3-Q1)``, and the upper whisker at the highest datum below 
        ``Q3 + whis*(Q3-Q1)``, where Q1 and Q3 are the first and third 
        quartiles.  The default value of ``whis = 1.5`` corresponds to Tukey's 
        original definition of boxplots. 
 
        If a pair of floats, they indicate the percentiles at which to draw the 
        whiskers (e.g., (5, 95)).  In particular, setting this to (0, 100) 
        results in whiskers covering the whole range of the data. 
 
        In the edge case where ``Q1 == Q3``, *whis* is automatically set to 
        (0, 100) (cover the whole range of the data) if *autorange* is True. 
 
        Beyond the whiskers, data are considered outliers and are plotted as 
        individual points. 
 
    bootstrap : int, optional 
        Number of times the confidence intervals around the median 
        should be bootstrapped (percentile method). 
 
    labels : array-like, optional 
        Labels for each dataset. Length must be compatible with 
        dimensions of *X*. 
 
    autorange : bool, optional (False) 
        When `True` and the data are distributed such that the 25th and 75th 
        percentiles are equal, ``whis`` is set to (0, 100) such that the 
        whisker ends are at the minimum and maximum of the data. 
 
    Returns 
    ------- 
    list of dict 
        A list of dictionaries containing the results for each column 
        of data. Keys of each dictionary are the following: 
 
        ========   =================================== 
        Key        Value Description 
        ========   =================================== 
        label      tick label for the boxplot 
        mean       arithmetic mean value 
        med        50th percentile 
        q1         first quartile (25th percentile) 
        q3         third quartile (75th percentile) 
        iqr        interquartile range 
        cilo       lower notch around the median 
        cihi       upper notch around the median 
        whislo     end of the lower whisker 
        whishi     end of the upper whisker 
        fliers     outliers 
        ========   =================================== 
 
    Notes 
    ----- 
    Non-bootstrapping approach to confidence interval uses Gaussian-based 
    asymptotic approximation: 
 
    .. math:: 
 
        \mathrm{med} \pm 1.57 \times \frac{\mathrm{iqr}}{\sqrt{N}} 
 
    General approach from: 
    McGill, R., Tukey, J.W., and Larsen, W.A. (1978) &quot;Variations of 
    Boxplots&quot;, The American Statistician, 32:12-16. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">_bootstrap_median(data</span><span class="s2">, </span><span class="s1">N=</span><span class="s5">5000</span><span class="s1">):</span>
        <span class="s3"># determine 95% confidence intervals of the median</span>
        <span class="s1">M = len(data)</span>
        <span class="s1">percentiles = [</span><span class="s5">2.5</span><span class="s2">, </span><span class="s5">97.5</span><span class="s1">]</span>

        <span class="s1">bs_index = np.random.randint(M</span><span class="s2">, </span><span class="s1">size=(N</span><span class="s2">, </span><span class="s1">M))</span>
        <span class="s1">bsData = data[bs_index]</span>
        <span class="s1">estimate = np.median(bsData</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">overwrite_input=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s1">CI = np.percentile(estimate</span><span class="s2">, </span><span class="s1">percentiles)</span>
        <span class="s2">return </span><span class="s1">CI</span>

    <span class="s2">def </span><span class="s1">_compute_conf_interval(data</span><span class="s2">, </span><span class="s1">med</span><span class="s2">, </span><span class="s1">iqr</span><span class="s2">, </span><span class="s1">bootstrap):</span>
        <span class="s2">if </span><span class="s1">bootstrap </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s3"># Do a bootstrap estimate of notch locations.</span>
            <span class="s3"># get conf. intervals around median</span>
            <span class="s1">CI = _bootstrap_median(data</span><span class="s2">, </span><span class="s1">N=bootstrap)</span>
            <span class="s1">notch_min = CI[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">notch_max = CI[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>

            <span class="s1">N = len(data)</span>
            <span class="s1">notch_min = med - </span><span class="s5">1.57 </span><span class="s1">* iqr / np.sqrt(N)</span>
            <span class="s1">notch_max = med + </span><span class="s5">1.57 </span><span class="s1">* iqr / np.sqrt(N)</span>

        <span class="s2">return </span><span class="s1">notch_min</span><span class="s2">, </span><span class="s1">notch_max</span>

    <span class="s3"># output is a list of dicts</span>
    <span class="s1">bxpstats = []</span>

    <span class="s3"># convert X to a list of lists</span>
    <span class="s1">X = _reshape_2D(X</span><span class="s2">, </span><span class="s4">&quot;X&quot;</span><span class="s1">)</span>

    <span class="s1">ncols = len(X)</span>
    <span class="s2">if </span><span class="s1">labels </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">labels = itertools.repeat(</span><span class="s2">None</span><span class="s1">)</span>
    <span class="s2">elif </span><span class="s1">len(labels) != ncols:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Dimensions of labels and X must be compatible&quot;</span><span class="s1">)</span>

    <span class="s1">input_whis = whis</span>
    <span class="s2">for </span><span class="s1">ii</span><span class="s2">, </span><span class="s1">(x</span><span class="s2">, </span><span class="s1">label) </span><span class="s2">in </span><span class="s1">enumerate(zip(X</span><span class="s2">, </span><span class="s1">labels)):</span>

        <span class="s3"># empty dict</span>
        <span class="s1">stats = {}</span>
        <span class="s2">if </span><span class="s1">label </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">stats[</span><span class="s4">'label'</span><span class="s1">] = label</span>

        <span class="s3"># restore whis to the input values in case it got changed in the loop</span>
        <span class="s1">whis = input_whis</span>

        <span class="s3"># note tricksiness, append up here and then mutate below</span>
        <span class="s1">bxpstats.append(stats)</span>

        <span class="s3"># if empty, bail</span>
        <span class="s2">if </span><span class="s1">len(x) == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">stats[</span><span class="s4">'fliers'</span><span class="s1">] = np.array([])</span>
            <span class="s1">stats[</span><span class="s4">'mean'</span><span class="s1">] = np.nan</span>
            <span class="s1">stats[</span><span class="s4">'med'</span><span class="s1">] = np.nan</span>
            <span class="s1">stats[</span><span class="s4">'q1'</span><span class="s1">] = np.nan</span>
            <span class="s1">stats[</span><span class="s4">'q3'</span><span class="s1">] = np.nan</span>
            <span class="s1">stats[</span><span class="s4">'iqr'</span><span class="s1">] = np.nan</span>
            <span class="s1">stats[</span><span class="s4">'cilo'</span><span class="s1">] = np.nan</span>
            <span class="s1">stats[</span><span class="s4">'cihi'</span><span class="s1">] = np.nan</span>
            <span class="s1">stats[</span><span class="s4">'whislo'</span><span class="s1">] = np.nan</span>
            <span class="s1">stats[</span><span class="s4">'whishi'</span><span class="s1">] = np.nan</span>
            <span class="s2">continue</span>

        <span class="s3"># up-convert to an array, just to be safe</span>
        <span class="s1">x = np.asarray(x)</span>

        <span class="s3"># arithmetic mean</span>
        <span class="s1">stats[</span><span class="s4">'mean'</span><span class="s1">] = np.mean(x)</span>

        <span class="s3"># medians and quartiles</span>
        <span class="s1">q1</span><span class="s2">, </span><span class="s1">med</span><span class="s2">, </span><span class="s1">q3 = np.percentile(x</span><span class="s2">, </span><span class="s1">[</span><span class="s5">25</span><span class="s2">, </span><span class="s5">50</span><span class="s2">, </span><span class="s5">75</span><span class="s1">])</span>

        <span class="s3"># interquartile range</span>
        <span class="s1">stats[</span><span class="s4">'iqr'</span><span class="s1">] = q3 - q1</span>
        <span class="s2">if </span><span class="s1">stats[</span><span class="s4">'iqr'</span><span class="s1">] == </span><span class="s5">0 </span><span class="s2">and </span><span class="s1">autorange:</span>
            <span class="s1">whis = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">100</span><span class="s1">)</span>

        <span class="s3"># conf. interval around median</span>
        <span class="s1">stats[</span><span class="s4">'cilo'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">stats[</span><span class="s4">'cihi'</span><span class="s1">] = _compute_conf_interval(</span>
            <span class="s1">x</span><span class="s2">, </span><span class="s1">med</span><span class="s2">, </span><span class="s1">stats[</span><span class="s4">'iqr'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">bootstrap</span>
        <span class="s1">)</span>

        <span class="s3"># lowest/highest non-outliers</span>
        <span class="s2">if </span><span class="s1">np.iterable(whis) </span><span class="s2">and not </span><span class="s1">isinstance(whis</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">loval</span><span class="s2">, </span><span class="s1">hival = np.percentile(x</span><span class="s2">, </span><span class="s1">whis)</span>
        <span class="s2">elif </span><span class="s1">np.isreal(whis):</span>
            <span class="s1">loval = q1 - whis * stats[</span><span class="s4">'iqr'</span><span class="s1">]</span>
            <span class="s1">hival = q3 + whis * stats[</span><span class="s4">'iqr'</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'whis must be a float or list of percentiles'</span><span class="s1">)</span>

        <span class="s3"># get high extreme</span>
        <span class="s1">wiskhi = x[x &lt;= hival]</span>
        <span class="s2">if </span><span class="s1">len(wiskhi) == </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">np.max(wiskhi) &lt; q3:</span>
            <span class="s1">stats[</span><span class="s4">'whishi'</span><span class="s1">] = q3</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">stats[</span><span class="s4">'whishi'</span><span class="s1">] = np.max(wiskhi)</span>

        <span class="s3"># get low extreme</span>
        <span class="s1">wisklo = x[x &gt;= loval]</span>
        <span class="s2">if </span><span class="s1">len(wisklo) == </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">np.min(wisklo) &gt; q1:</span>
            <span class="s1">stats[</span><span class="s4">'whislo'</span><span class="s1">] = q1</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">stats[</span><span class="s4">'whislo'</span><span class="s1">] = np.min(wisklo)</span>

        <span class="s3"># compute a single array of outliers</span>
        <span class="s1">stats[</span><span class="s4">'fliers'</span><span class="s1">] = np.concatenate([</span>
            <span class="s1">x[x &lt; stats[</span><span class="s4">'whislo'</span><span class="s1">]]</span><span class="s2">,</span>
            <span class="s1">x[x &gt; stats[</span><span class="s4">'whishi'</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">])</span>

        <span class="s3"># add in the remaining stats</span>
        <span class="s1">stats[</span><span class="s4">'q1'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">stats[</span><span class="s4">'med'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">stats[</span><span class="s4">'q3'</span><span class="s1">] = q1</span><span class="s2">, </span><span class="s1">med</span><span class="s2">, </span><span class="s1">q3</span>

    <span class="s2">return </span><span class="s1">bxpstats</span>


<span class="s3">#: Maps short codes for line style to their full name used by backends.</span>
<span class="s1">ls_mapper = {</span><span class="s4">'-'</span><span class="s1">: </span><span class="s4">'solid'</span><span class="s2">, </span><span class="s4">'--'</span><span class="s1">: </span><span class="s4">'dashed'</span><span class="s2">, </span><span class="s4">'-.'</span><span class="s1">: </span><span class="s4">'dashdot'</span><span class="s2">, </span><span class="s4">':'</span><span class="s1">: </span><span class="s4">'dotted'</span><span class="s1">}</span>
<span class="s3">#: Maps full names for line styles used by backends to their short codes.</span>
<span class="s1">ls_mapper_r = {v: k </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">ls_mapper.items()}</span>


<span class="s2">def </span><span class="s1">contiguous_regions(mask):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return a list of (ind0, ind1) such that ``mask[ind0:ind1].all()`` is 
    True and we cover all such regions. 
    &quot;&quot;&quot;</span>
    <span class="s1">mask = np.asarray(mask</span><span class="s2">, </span><span class="s1">dtype=bool)</span>

    <span class="s2">if not </span><span class="s1">mask.size:</span>
        <span class="s2">return </span><span class="s1">[]</span>

    <span class="s3"># Find the indices of region changes, and correct offset</span>
    <span class="s1">idx</span><span class="s2">, </span><span class="s1">= np.nonzero(mask[:-</span><span class="s5">1</span><span class="s1">] != mask[</span><span class="s5">1</span><span class="s1">:])</span>
    <span class="s1">idx += </span><span class="s5">1</span>

    <span class="s3"># List operations are faster for moderately sized arrays</span>
    <span class="s1">idx = idx.tolist()</span>

    <span class="s3"># Add first and/or last index if needed</span>
    <span class="s2">if </span><span class="s1">mask[</span><span class="s5">0</span><span class="s1">]:</span>
        <span class="s1">idx = [</span><span class="s5">0</span><span class="s1">] + idx</span>
    <span class="s2">if </span><span class="s1">mask[-</span><span class="s5">1</span><span class="s1">]:</span>
        <span class="s1">idx.append(len(mask))</span>

    <span class="s2">return </span><span class="s1">list(zip(idx[::</span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">idx[</span><span class="s5">1</span><span class="s1">::</span><span class="s5">2</span><span class="s1">]))</span>


<span class="s2">def </span><span class="s1">is_math_text(s):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return whether the string *s* contains math expressions. 
 
    This is done by checking whether *s* contains an even number of 
    non-escaped dollar signs. 
    &quot;&quot;&quot;</span>
    <span class="s1">s = str(s)</span>
    <span class="s1">dollar_count = s.count(</span><span class="s4">r'$'</span><span class="s1">) - s.count(</span><span class="s4">r'\$'</span><span class="s1">)</span>
    <span class="s1">even_dollars = (dollar_count &gt; </span><span class="s5">0 </span><span class="s2">and </span><span class="s1">dollar_count % </span><span class="s5">2 </span><span class="s1">== </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">even_dollars</span>


<span class="s2">def </span><span class="s1">_to_unmasked_float_array(x):</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert a sequence to a float array; if input was a masked array, masked 
    values are converted to nans. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">hasattr(x</span><span class="s2">, </span><span class="s4">'mask'</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s1">np.ma.asarray(x</span><span class="s2">, </span><span class="s1">float).filled(np.nan)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">np.asarray(x</span><span class="s2">, </span><span class="s1">float)</span>


<span class="s2">def </span><span class="s1">_check_1d(x):</span>
    <span class="s0">&quot;&quot;&quot;Convert scalars to 1D arrays; pass-through arrays as is.&quot;&quot;&quot;</span>
    <span class="s3"># Unpack in case of e.g. Pandas or xarray object</span>
    <span class="s1">x = _unpack_to_numpy(x)</span>
    <span class="s3"># plot requires `shape` and `ndim`.  If passed an</span>
    <span class="s3"># object that doesn't provide them, then force to numpy array.</span>
    <span class="s3"># Note this will strip unit information.</span>
    <span class="s2">if </span><span class="s1">(</span><span class="s2">not </span><span class="s1">hasattr(x</span><span class="s2">, </span><span class="s4">'shape'</span><span class="s1">) </span><span class="s2">or</span>
            <span class="s2">not </span><span class="s1">hasattr(x</span><span class="s2">, </span><span class="s4">'ndim'</span><span class="s1">) </span><span class="s2">or</span>
            <span class="s1">len(x.shape) &lt; </span><span class="s5">1</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s1">np.atleast_1d(x)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">x</span>


<span class="s2">def </span><span class="s1">_reshape_2D(X</span><span class="s2">, </span><span class="s1">name):</span>
    <span class="s0">&quot;&quot;&quot; 
    Use Fortran ordering to convert ndarrays and lists of iterables to lists of 
    1D arrays. 
 
    Lists of iterables are converted by applying `numpy.asanyarray` to each of 
    their elements.  1D ndarrays are returned in a singleton list containing 
    them.  2D ndarrays are converted to the list of their *columns*. 
 
    *name* is used to generate the error message for invalid inputs. 
    &quot;&quot;&quot;</span>

    <span class="s3"># Unpack in case of e.g. Pandas or xarray object</span>
    <span class="s1">X = _unpack_to_numpy(X)</span>

    <span class="s3"># Iterate over columns for ndarrays.</span>
    <span class="s2">if </span><span class="s1">isinstance(X</span><span class="s2">, </span><span class="s1">np.ndarray):</span>
        <span class="s1">X = X.T</span>

        <span class="s2">if </span><span class="s1">len(X) == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">[[]]</span>
        <span class="s2">elif </span><span class="s1">X.ndim == </span><span class="s5">1 </span><span class="s2">and </span><span class="s1">np.ndim(X[</span><span class="s5">0</span><span class="s1">]) == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s3"># 1D array of scalars: directly return it.</span>
            <span class="s2">return </span><span class="s1">[X]</span>
        <span class="s2">elif </span><span class="s1">X.ndim </span><span class="s2">in </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">]:</span>
            <span class="s3"># 2D array, or 1D array of iterables: flatten them first.</span>
            <span class="s2">return </span><span class="s1">[np.reshape(x</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">X]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">f'</span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s4">must have 2 or fewer dimensions'</span><span class="s1">)</span>

    <span class="s3"># Iterate over list of iterables.</span>
    <span class="s2">if </span><span class="s1">len(X) == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">[[]]</span>

    <span class="s1">result = []</span>
    <span class="s1">is_1d = </span><span class="s2">True</span>
    <span class="s2">for </span><span class="s1">xi </span><span class="s2">in </span><span class="s1">X:</span>
        <span class="s3"># check if this is iterable, except for strings which we</span>
        <span class="s3"># treat as singletons.</span>
        <span class="s2">if not </span><span class="s1">isinstance(xi</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">iter(xi)</span>
            <span class="s2">except </span><span class="s1">TypeError:</span>
                <span class="s2">pass</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">is_1d = </span><span class="s2">False</span>
        <span class="s1">xi = np.asanyarray(xi)</span>
        <span class="s1">nd = np.ndim(xi)</span>
        <span class="s2">if </span><span class="s1">nd &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">f'</span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s4">must have 2 or fewer dimensions'</span><span class="s1">)</span>
        <span class="s1">result.append(xi.reshape(-</span><span class="s5">1</span><span class="s1">))</span>

    <span class="s2">if </span><span class="s1">is_1d:</span>
        <span class="s3"># 1D array of scalars: directly return it.</span>
        <span class="s2">return </span><span class="s1">[np.reshape(result</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s3"># 2D array, or 1D array of iterables: use flattened version.</span>
        <span class="s2">return </span><span class="s1">result</span>


<span class="s2">def </span><span class="s1">violin_stats(X</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">points=</span><span class="s5">100</span><span class="s2">, </span><span class="s1">quantiles=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return a list of dictionaries of data which can be used to draw a series 
    of violin plots. 
 
    See the ``Returns`` section below to view the required keys of the 
    dictionary. 
 
    Users can skip this function and pass a user-defined set of dictionaries 
    with the same keys to `~.axes.Axes.violinplot` instead of using Matplotlib 
    to do the calculations. See the *Returns* section below for the keys 
    that must be present in the dictionaries. 
 
    Parameters 
    ---------- 
    X : array-like 
        Sample data that will be used to produce the gaussian kernel density 
        estimates. Must have 2 or fewer dimensions. 
 
    method : callable 
        The method used to calculate the kernel density estimate for each 
        column of data. When called via ``method(v, coords)``, it should 
        return a vector of the values of the KDE evaluated at the values 
        specified in coords. 
 
    points : int, default: 100 
        Defines the number of points to evaluate each of the gaussian kernel 
        density estimates at. 
 
    quantiles : array-like, default: None 
        Defines (if not None) a list of floats in interval [0, 1] for each 
        column of data, which represents the quantiles that will be rendered 
        for that column of data. Must have 2 or fewer dimensions. 1D array will 
        be treated as a singleton list containing them. 
 
    Returns 
    ------- 
    list of dict 
        A list of dictionaries containing the results for each column of data. 
        The dictionaries contain at least the following: 
 
        - coords: A list of scalars containing the coordinates this particular 
          kernel density estimate was evaluated at. 
        - vals: A list of scalars containing the values of the kernel density 
          estimate at each of the coordinates given in *coords*. 
        - mean: The mean value for this column of data. 
        - median: The median value for this column of data. 
        - min: The minimum value for this column of data. 
        - max: The maximum value for this column of data. 
        - quantiles: The quantile values for this column of data. 
    &quot;&quot;&quot;</span>

    <span class="s3"># List of dictionaries describing each of the violins.</span>
    <span class="s1">vpstats = []</span>

    <span class="s3"># Want X to be a list of data sequences</span>
    <span class="s1">X = _reshape_2D(X</span><span class="s2">, </span><span class="s4">&quot;X&quot;</span><span class="s1">)</span>

    <span class="s3"># Want quantiles to be as the same shape as data sequences</span>
    <span class="s2">if </span><span class="s1">quantiles </span><span class="s2">is not None and </span><span class="s1">len(quantiles) != </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">quantiles = _reshape_2D(quantiles</span><span class="s2">, </span><span class="s4">&quot;quantiles&quot;</span><span class="s1">)</span>
    <span class="s3"># Else, mock quantiles if it's none or empty</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">quantiles = [[]] * len(X)</span>

    <span class="s3"># quantiles should have the same size as dataset</span>
    <span class="s2">if </span><span class="s1">len(X) != len(quantiles):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;List of violinplot statistics and quantiles values&quot;</span>
                         <span class="s4">&quot; must have the same length&quot;</span><span class="s1">)</span>

    <span class="s3"># Zip x and quantiles</span>
    <span class="s2">for </span><span class="s1">(x</span><span class="s2">, </span><span class="s1">q) </span><span class="s2">in </span><span class="s1">zip(X</span><span class="s2">, </span><span class="s1">quantiles):</span>
        <span class="s3"># Dictionary of results for this distribution</span>
        <span class="s1">stats = {}</span>

        <span class="s3"># Calculate basic stats for the distribution</span>
        <span class="s1">min_val = np.min(x)</span>
        <span class="s1">max_val = np.max(x)</span>
        <span class="s1">quantile_val = np.percentile(x</span><span class="s2">, </span><span class="s5">100 </span><span class="s1">* q)</span>

        <span class="s3"># Evaluate the kernel density estimate</span>
        <span class="s1">coords = np.linspace(min_val</span><span class="s2">, </span><span class="s1">max_val</span><span class="s2">, </span><span class="s1">points)</span>
        <span class="s1">stats[</span><span class="s4">'vals'</span><span class="s1">] = method(x</span><span class="s2">, </span><span class="s1">coords)</span>
        <span class="s1">stats[</span><span class="s4">'coords'</span><span class="s1">] = coords</span>

        <span class="s3"># Store additional statistics for this distribution</span>
        <span class="s1">stats[</span><span class="s4">'mean'</span><span class="s1">] = np.mean(x)</span>
        <span class="s1">stats[</span><span class="s4">'median'</span><span class="s1">] = np.median(x)</span>
        <span class="s1">stats[</span><span class="s4">'min'</span><span class="s1">] = min_val</span>
        <span class="s1">stats[</span><span class="s4">'max'</span><span class="s1">] = max_val</span>
        <span class="s1">stats[</span><span class="s4">'quantiles'</span><span class="s1">] = np.atleast_1d(quantile_val)</span>

        <span class="s3"># Append to output</span>
        <span class="s1">vpstats.append(stats)</span>

    <span class="s2">return </span><span class="s1">vpstats</span>


<span class="s2">def </span><span class="s1">pts_to_prestep(x</span><span class="s2">, </span><span class="s1">*args):</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert continuous line to pre-steps. 
 
    Given a set of ``N`` points, convert to ``2N - 1`` points, which when 
    connected linearly give a step function which changes values at the 
    beginning of the intervals. 
 
    Parameters 
    ---------- 
    x : array 
        The x location of the steps. May be empty. 
 
    y1, ..., yp : array 
        y arrays to be turned into steps; all must be the same length as ``x``. 
 
    Returns 
    ------- 
    array 
        The x and y values converted to steps in the same order as the input; 
        can be unpacked as ``x_out, y1_out, ..., yp_out``.  If the input is 
        length ``N``, each of these arrays will be length ``2N + 1``. For 
        ``N=0``, the length will be 0. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; x_s, y1_s, y2_s = pts_to_prestep(x, y1, y2) 
    &quot;&quot;&quot;</span>
    <span class="s1">steps = np.zeros((</span><span class="s5">1 </span><span class="s1">+ len(args)</span><span class="s2">, </span><span class="s1">max(</span><span class="s5">2 </span><span class="s1">* len(x) - </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)))</span>
    <span class="s3"># In all `pts_to_*step` functions, only assign once using *x* and *args*,</span>
    <span class="s3"># as converting to an array may be expensive.</span>
    <span class="s1">steps[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">::</span><span class="s5">2</span><span class="s1">] = x</span>
    <span class="s1">steps[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">::</span><span class="s5">2</span><span class="s1">] = steps[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">:-</span><span class="s5">2</span><span class="s1">:</span><span class="s5">2</span><span class="s1">]</span>
    <span class="s1">steps[</span><span class="s5">1</span><span class="s1">:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">::</span><span class="s5">2</span><span class="s1">] = args</span>
    <span class="s1">steps[</span><span class="s5">1</span><span class="s1">:</span><span class="s2">, </span><span class="s5">1</span><span class="s1">::</span><span class="s5">2</span><span class="s1">] = steps[</span><span class="s5">1</span><span class="s1">:</span><span class="s2">, </span><span class="s5">2</span><span class="s1">::</span><span class="s5">2</span><span class="s1">]</span>
    <span class="s2">return </span><span class="s1">steps</span>


<span class="s2">def </span><span class="s1">pts_to_poststep(x</span><span class="s2">, </span><span class="s1">*args):</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert continuous line to post-steps. 
 
    Given a set of ``N`` points convert to ``2N + 1`` points, which when 
    connected linearly give a step function which changes values at the end of 
    the intervals. 
 
    Parameters 
    ---------- 
    x : array 
        The x location of the steps. May be empty. 
 
    y1, ..., yp : array 
        y arrays to be turned into steps; all must be the same length as ``x``. 
 
    Returns 
    ------- 
    array 
        The x and y values converted to steps in the same order as the input; 
        can be unpacked as ``x_out, y1_out, ..., yp_out``.  If the input is 
        length ``N``, each of these arrays will be length ``2N + 1``. For 
        ``N=0``, the length will be 0. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; x_s, y1_s, y2_s = pts_to_poststep(x, y1, y2) 
    &quot;&quot;&quot;</span>
    <span class="s1">steps = np.zeros((</span><span class="s5">1 </span><span class="s1">+ len(args)</span><span class="s2">, </span><span class="s1">max(</span><span class="s5">2 </span><span class="s1">* len(x) - </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)))</span>
    <span class="s1">steps[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">::</span><span class="s5">2</span><span class="s1">] = x</span>
    <span class="s1">steps[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">::</span><span class="s5">2</span><span class="s1">] = steps[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s1">::</span><span class="s5">2</span><span class="s1">]</span>
    <span class="s1">steps[</span><span class="s5">1</span><span class="s1">:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">::</span><span class="s5">2</span><span class="s1">] = args</span>
    <span class="s1">steps[</span><span class="s5">1</span><span class="s1">:</span><span class="s2">, </span><span class="s5">1</span><span class="s1">::</span><span class="s5">2</span><span class="s1">] = steps[</span><span class="s5">1</span><span class="s1">:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">:-</span><span class="s5">2</span><span class="s1">:</span><span class="s5">2</span><span class="s1">]</span>
    <span class="s2">return </span><span class="s1">steps</span>


<span class="s2">def </span><span class="s1">pts_to_midstep(x</span><span class="s2">, </span><span class="s1">*args):</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert continuous line to mid-steps. 
 
    Given a set of ``N`` points convert to ``2N`` points which when connected 
    linearly give a step function which changes values at the middle of the 
    intervals. 
 
    Parameters 
    ---------- 
    x : array 
        The x location of the steps. May be empty. 
 
    y1, ..., yp : array 
        y arrays to be turned into steps; all must be the same length as 
        ``x``. 
 
    Returns 
    ------- 
    array 
        The x and y values converted to steps in the same order as the input; 
        can be unpacked as ``x_out, y1_out, ..., yp_out``.  If the input is 
        length ``N``, each of these arrays will be length ``2N``. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; x_s, y1_s, y2_s = pts_to_midstep(x, y1, y2) 
    &quot;&quot;&quot;</span>
    <span class="s1">steps = np.zeros((</span><span class="s5">1 </span><span class="s1">+ len(args)</span><span class="s2">, </span><span class="s5">2 </span><span class="s1">* len(x)))</span>
    <span class="s1">x = np.asanyarray(x)</span>
    <span class="s1">steps[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">:</span><span class="s5">2</span><span class="s1">] = steps[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s1">::</span><span class="s5">2</span><span class="s1">] = (x[:-</span><span class="s5">1</span><span class="s1">] + x[</span><span class="s5">1</span><span class="s1">:]) / </span><span class="s5">2</span>
    <span class="s1">steps[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">:</span><span class="s5">1</span><span class="s1">] = x[:</span><span class="s5">1</span><span class="s1">]  </span><span class="s3"># Also works for zero-sized input.</span>
    <span class="s1">steps[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">:] = x[-</span><span class="s5">1</span><span class="s1">:]</span>
    <span class="s1">steps[</span><span class="s5">1</span><span class="s1">:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">::</span><span class="s5">2</span><span class="s1">] = args</span>
    <span class="s1">steps[</span><span class="s5">1</span><span class="s1">:</span><span class="s2">, </span><span class="s5">1</span><span class="s1">::</span><span class="s5">2</span><span class="s1">] = steps[</span><span class="s5">1</span><span class="s1">:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">::</span><span class="s5">2</span><span class="s1">]</span>
    <span class="s2">return </span><span class="s1">steps</span>


<span class="s1">STEP_LOOKUP_MAP = {</span><span class="s4">'default'</span><span class="s1">: </span><span class="s2">lambda </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y: (x</span><span class="s2">, </span><span class="s1">y)</span><span class="s2">,</span>
                   <span class="s4">'steps'</span><span class="s1">: pts_to_prestep</span><span class="s2">,</span>
                   <span class="s4">'steps-pre'</span><span class="s1">: pts_to_prestep</span><span class="s2">,</span>
                   <span class="s4">'steps-post'</span><span class="s1">: pts_to_poststep</span><span class="s2">,</span>
                   <span class="s4">'steps-mid'</span><span class="s1">: pts_to_midstep}</span>


<span class="s2">def </span><span class="s1">index_of(y):</span>
    <span class="s0">&quot;&quot;&quot; 
    A helper function to create reasonable x values for the given *y*. 
 
    This is used for plotting (x, y) if x values are not explicitly given. 
 
    First try ``y.index`` (assuming *y* is a `pandas.Series`), if that 
    fails, use ``range(len(y))``. 
 
    This will be extended in the future to deal with more types of 
    labeled data. 
 
    Parameters 
    ---------- 
    y : float or array-like 
 
    Returns 
    ------- 
    x, y : ndarray 
       The x and y values to plot. 
    &quot;&quot;&quot;</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">y.index.to_numpy()</span><span class="s2">, </span><span class="s1">y.to_numpy()</span>
    <span class="s2">except </span><span class="s1">AttributeError:</span>
        <span class="s2">pass</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">y = _check_1d(y)</span>
    <span class="s2">except </span><span class="s1">(VisibleDeprecationWarning</span><span class="s2">, </span><span class="s1">ValueError):</span>
        <span class="s3"># NumPy 1.19 will warn on ragged input, and we can't actually use it.</span>
        <span class="s2">pass</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">np.arange(y.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=float)</span><span class="s2">, </span><span class="s1">y</span>
    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'Input could not be cast to an at-least-1D NumPy array'</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">safe_first_element(obj):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the first element in *obj*. 
 
    This is a type-independent way of obtaining the first element, 
    supporting both index access and the iterator protocol. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_safe_first_finite(obj</span><span class="s2">, </span><span class="s1">skip_nonfinite=</span><span class="s2">False</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_safe_first_finite(obj</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">skip_nonfinite=</span><span class="s2">True</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the first finite element in *obj* if one is available and skip_nonfinite is 
    True. Otherwise, return the first element. 
 
    This is a method for internal use. 
 
    This is a type-independent way of obtaining the first finite element, supporting 
    both index access and the iterator protocol. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">safe_isfinite(val):</span>
        <span class="s2">if </span><span class="s1">val </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return False</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">math.isfinite(val)</span>
        <span class="s2">except </span><span class="s1">(TypeError</span><span class="s2">, </span><span class="s1">ValueError):</span>
            <span class="s2">pass</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">np.isfinite(val) </span><span class="s2">if </span><span class="s1">np.isscalar(val) </span><span class="s2">else True</span>
        <span class="s2">except </span><span class="s1">TypeError:</span>
            <span class="s3"># This is something that NumPy cannot make heads or tails of,</span>
            <span class="s3"># assume &quot;finite&quot;</span>
            <span class="s2">return True</span>
    <span class="s2">if </span><span class="s1">skip_nonfinite </span><span class="s2">is False</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">isinstance(obj</span><span class="s2">, </span><span class="s1">collections.abc.Iterator):</span>
            <span class="s3"># needed to accept `array.flat` as input.</span>
            <span class="s3"># np.flatiter reports as an instance of collections.Iterator</span>
            <span class="s3"># but can still be indexed via [].</span>
            <span class="s3"># This has the side effect of re-setting the iterator, but</span>
            <span class="s3"># that is acceptable.</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">obj[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s2">except </span><span class="s1">TypeError:</span>
                <span class="s2">pass</span>
            <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s4">&quot;matplotlib does not support generators &quot;</span>
                               <span class="s4">&quot;as input&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">next(iter(obj))</span>
    <span class="s2">elif </span><span class="s1">isinstance(obj</span><span class="s2">, </span><span class="s1">np.flatiter):</span>
        <span class="s3"># TODO do the finite filtering on this</span>
        <span class="s2">return </span><span class="s1">obj[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s2">elif </span><span class="s1">isinstance(obj</span><span class="s2">, </span><span class="s1">collections.abc.Iterator):</span>
        <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s4">&quot;matplotlib does not &quot;</span>
                           <span class="s4">&quot;support generators as input&quot;</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">for </span><span class="s1">val </span><span class="s2">in </span><span class="s1">obj:</span>
            <span class="s2">if </span><span class="s1">safe_isfinite(val):</span>
                <span class="s2">return </span><span class="s1">val</span>
        <span class="s2">return </span><span class="s1">safe_first_element(obj)</span>


<span class="s2">def </span><span class="s1">sanitize_sequence(data):</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert dictview objects to list. Other inputs are returned unchanged. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">(list(data) </span><span class="s2">if </span><span class="s1">isinstance(data</span><span class="s2">, </span><span class="s1">collections.abc.MappingView)</span>
            <span class="s2">else </span><span class="s1">data)</span>


<span class="s2">def </span><span class="s1">normalize_kwargs(kw</span><span class="s2">, </span><span class="s1">alias_mapping=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Helper function to normalize kwarg inputs. 
 
    Parameters 
    ---------- 
    kw : dict or None 
        A dict of keyword arguments.  None is explicitly supported and treated 
        as an empty dict, to support functions with an optional parameter of 
        the form ``props=None``. 
 
    alias_mapping : dict or Artist subclass or Artist instance, optional 
        A mapping between a canonical name to a list of aliases, in order of 
        precedence from lowest to highest. 
 
        If the canonical value is not in the list it is assumed to have the 
        highest priority. 
 
        If an Artist subclass or instance is passed, use its properties alias 
        mapping. 
 
    Raises 
    ------ 
    TypeError 
        To match what Python raises if invalid arguments/keyword arguments are 
        passed to a callable. 
    &quot;&quot;&quot;</span>
    <span class="s2">from </span><span class="s1">matplotlib.artist </span><span class="s2">import </span><span class="s1">Artist</span>

    <span class="s2">if </span><span class="s1">kw </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">{}</span>

    <span class="s3"># deal with default value of alias_mapping</span>
    <span class="s2">if </span><span class="s1">alias_mapping </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">alias_mapping = {}</span>
    <span class="s2">elif </span><span class="s1">(isinstance(alias_mapping</span><span class="s2">, </span><span class="s1">type) </span><span class="s2">and </span><span class="s1">issubclass(alias_mapping</span><span class="s2">, </span><span class="s1">Artist)</span>
          <span class="s2">or </span><span class="s1">isinstance(alias_mapping</span><span class="s2">, </span><span class="s1">Artist)):</span>
        <span class="s1">alias_mapping = getattr(alias_mapping</span><span class="s2">, </span><span class="s4">&quot;_alias_map&quot;</span><span class="s2">, </span><span class="s1">{})</span>

    <span class="s1">to_canonical = {alias: canonical</span>
                    <span class="s2">for </span><span class="s1">canonical</span><span class="s2">, </span><span class="s1">alias_list </span><span class="s2">in </span><span class="s1">alias_mapping.items()</span>
                    <span class="s2">for </span><span class="s1">alias </span><span class="s2">in </span><span class="s1">alias_list}</span>
    <span class="s1">canonical_to_seen = {}</span>
    <span class="s1">ret = {}  </span><span class="s3"># output dictionary</span>

    <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">kw.items():</span>
        <span class="s1">canonical = to_canonical.get(k</span><span class="s2">, </span><span class="s1">k)</span>
        <span class="s2">if </span><span class="s1">canonical </span><span class="s2">in </span><span class="s1">canonical_to_seen:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s4">f&quot;Got both </span><span class="s2">{</span><span class="s1">canonical_to_seen[canonical]</span><span class="s2">!r} </span><span class="s4">and &quot;</span>
                            <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">k</span><span class="s2">!r}</span><span class="s4">, which are aliases of one another&quot;</span><span class="s1">)</span>
        <span class="s1">canonical_to_seen[canonical] = k</span>
        <span class="s1">ret[canonical] = v</span>

    <span class="s2">return </span><span class="s1">ret</span>


<span class="s1">@contextlib.contextmanager</span>
<span class="s2">def </span><span class="s1">_lock_path(path):</span>
    <span class="s0">&quot;&quot;&quot; 
    Context manager for locking a path. 
 
    Usage:: 
 
        with _lock_path(path): 
            ... 
 
    Another thread or process that attempts to lock the same path will wait 
    until this context manager is exited. 
 
    The lock is implemented by creating a temporary file in the parent 
    directory, so that directory must exist and be writable. 
    &quot;&quot;&quot;</span>
    <span class="s1">path = Path(path)</span>
    <span class="s1">lock_path = path.with_name(path.name + </span><span class="s4">&quot;.matplotlib-lock&quot;</span><span class="s1">)</span>
    <span class="s1">retries = </span><span class="s5">50</span>
    <span class="s1">sleeptime = </span><span class="s5">0.1</span>
    <span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range(retries):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">with </span><span class="s1">lock_path.open(</span><span class="s4">&quot;xb&quot;</span><span class="s1">):</span>
                <span class="s2">break</span>
        <span class="s2">except </span><span class="s1">FileExistsError:</span>
            <span class="s1">time.sleep(sleeptime)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">TimeoutError(</span><span class="s4">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s4">Lock error: Matplotlib failed to acquire the following lock file: 
    {} 
This maybe due to another process holding this lock file.  If you are sure no 
other Matplotlib process is running, remove this file and try again.&quot;&quot;&quot;</span><span class="s1">.format(</span>
            <span class="s1">lock_path))</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">yield</span>
    <span class="s2">finally</span><span class="s1">:</span>
        <span class="s1">lock_path.unlink()</span>


<span class="s2">def </span><span class="s1">_topmost_artist(</span>
        <span class="s1">artists</span><span class="s2">,</span>
        <span class="s1">_cached_max=functools.partial(max</span><span class="s2">, </span><span class="s1">key=operator.attrgetter(</span><span class="s4">&quot;zorder&quot;</span><span class="s1">))):</span>
    <span class="s0">&quot;&quot;&quot; 
    Get the topmost artist of a list. 
 
    In case of a tie, return the *last* of the tied artists, as it will be 
    drawn on top of the others. `max` returns the first maximum in case of 
    ties, so we need to iterate over the list in reverse order. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">_cached_max(reversed(artists))</span>


<span class="s2">def </span><span class="s1">_str_equal(obj</span><span class="s2">, </span><span class="s1">s):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return whether *obj* is a string equal to string *s*. 
 
    This helper solely exists to handle the case where *obj* is a numpy array, 
    because in such cases, a naive ``obj == s`` would yield an array, which 
    cannot be used in a boolean context. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">isinstance(obj</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">and </span><span class="s1">obj == s</span>


<span class="s2">def </span><span class="s1">_str_lower_equal(obj</span><span class="s2">, </span><span class="s1">s):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return whether *obj* is a string equal, when lowercased, to string *s*. 
 
    This helper solely exists to handle the case where *obj* is a numpy array, 
    because in such cases, a naive ``obj == s`` would yield an array, which 
    cannot be used in a boolean context. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">isinstance(obj</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">and </span><span class="s1">obj.lower() == s</span>


<span class="s2">def </span><span class="s1">_array_perimeter(arr):</span>
    <span class="s0">&quot;&quot;&quot; 
    Get the elements on the perimeter of *arr*. 
 
    Parameters 
    ---------- 
    arr : ndarray, shape (M, N) 
        The input array. 
 
    Returns 
    ------- 
    ndarray, shape (2*(M - 1) + 2*(N - 1),) 
        The elements on the perimeter of the array:: 
 
           [arr[0, 0], ..., arr[0, -1], ..., arr[-1, -1], ..., arr[-1, 0], ...] 
 
    Examples 
    -------- 
    &gt;&gt;&gt; i, j = np.ogrid[:3, :4] 
    &gt;&gt;&gt; a = i*10 + j 
    &gt;&gt;&gt; a 
    array([[ 0,  1,  2,  3], 
           [10, 11, 12, 13], 
           [20, 21, 22, 23]]) 
    &gt;&gt;&gt; _array_perimeter(a) 
    array([ 0,  1,  2,  3, 13, 23, 22, 21, 20, 10]) 
    &quot;&quot;&quot;</span>
    <span class="s3"># note we use Python's half-open ranges to avoid repeating</span>
    <span class="s3"># the corners</span>
    <span class="s1">forward = np.s_[</span><span class="s5">0</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">]      </span><span class="s3"># [0 ... -1)</span>
    <span class="s1">backward = np.s_[-</span><span class="s5">1</span><span class="s1">:</span><span class="s5">0</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">]  </span><span class="s3"># [-1 ... 0)</span>
    <span class="s2">return </span><span class="s1">np.concatenate((</span>
        <span class="s1">arr[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">forward]</span><span class="s2">,</span>
        <span class="s1">arr[forward</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">arr[-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">backward]</span><span class="s2">,</span>
        <span class="s1">arr[backward</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">))</span>


<span class="s2">def </span><span class="s1">_unfold(arr</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">size</span><span class="s2">, </span><span class="s1">step):</span>
    <span class="s0">&quot;&quot;&quot; 
    Append an extra dimension containing sliding windows along *axis*. 
 
    All windows are of size *size* and begin with every *step* elements. 
 
    Parameters 
    ---------- 
    arr : ndarray, shape (N_1, ..., N_k) 
        The input array 
    axis : int 
        Axis along which the windows are extracted 
    size : int 
        Size of the windows 
    step : int 
        Stride between first elements of subsequent windows. 
 
    Returns 
    ------- 
    ndarray, shape (N_1, ..., 1 + (N_axis-size)/step, ..., N_k, size) 
 
    Examples 
    -------- 
    &gt;&gt;&gt; i, j = np.ogrid[:3, :7] 
    &gt;&gt;&gt; a = i*10 + j 
    &gt;&gt;&gt; a 
    array([[ 0,  1,  2,  3,  4,  5,  6], 
           [10, 11, 12, 13, 14, 15, 16], 
           [20, 21, 22, 23, 24, 25, 26]]) 
    &gt;&gt;&gt; _unfold(a, axis=1, size=3, step=2) 
    array([[[ 0,  1,  2], 
            [ 2,  3,  4], 
            [ 4,  5,  6]], 
           [[10, 11, 12], 
            [12, 13, 14], 
            [14, 15, 16]], 
           [[20, 21, 22], 
            [22, 23, 24], 
            [24, 25, 26]]]) 
    &quot;&quot;&quot;</span>
    <span class="s1">new_shape = [*arr.shape</span><span class="s2">, </span><span class="s1">size]</span>
    <span class="s1">new_strides = [*arr.strides</span><span class="s2">, </span><span class="s1">arr.strides[axis]]</span>
    <span class="s1">new_shape[axis] = (new_shape[axis] - size) // step + </span><span class="s5">1</span>
    <span class="s1">new_strides[axis] = new_strides[axis] * step</span>
    <span class="s2">return </span><span class="s1">np.lib.stride_tricks.as_strided(arr</span><span class="s2">,</span>
                                           <span class="s1">shape=new_shape</span><span class="s2">,</span>
                                           <span class="s1">strides=new_strides</span><span class="s2">,</span>
                                           <span class="s1">writeable=</span><span class="s2">False</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_array_patch_perimeters(x</span><span class="s2">, </span><span class="s1">rstride</span><span class="s2">, </span><span class="s1">cstride):</span>
    <span class="s0">&quot;&quot;&quot; 
    Extract perimeters of patches from *arr*. 
 
    Extracted patches are of size (*rstride* + 1) x (*cstride* + 1) and 
    share perimeters with their neighbors. The ordering of the vertices matches 
    that returned by ``_array_perimeter``. 
 
    Parameters 
    ---------- 
    x : ndarray, shape (N, M) 
        Input array 
    rstride : int 
        Vertical (row) stride between corresponding elements of each patch 
    cstride : int 
        Horizontal (column) stride between corresponding elements of each patch 
 
    Returns 
    ------- 
    ndarray, shape (N/rstride * M/cstride, 2 * (rstride + cstride)) 
    &quot;&quot;&quot;</span>
    <span class="s2">assert </span><span class="s1">rstride &gt; </span><span class="s5">0 </span><span class="s2">and </span><span class="s1">cstride &gt; </span><span class="s5">0</span>
    <span class="s2">assert </span><span class="s1">(x.shape[</span><span class="s5">0</span><span class="s1">] - </span><span class="s5">1</span><span class="s1">) % rstride == </span><span class="s5">0</span>
    <span class="s2">assert </span><span class="s1">(x.shape[</span><span class="s5">1</span><span class="s1">] - </span><span class="s5">1</span><span class="s1">) % cstride == </span><span class="s5">0</span>
    <span class="s3"># We build up each perimeter from four half-open intervals. Here is an</span>
    <span class="s3"># illustrated explanation for rstride == cstride == 3</span>
    <span class="s3">#</span>
    <span class="s3">#       T T T R</span>
    <span class="s3">#       L     R</span>
    <span class="s3">#       L     R</span>
    <span class="s3">#       L B B B</span>
    <span class="s3">#</span>
    <span class="s3"># where T means that this element will be in the top array, R for right,</span>
    <span class="s3"># B for bottom and L for left. Each of the arrays below has a shape of:</span>
    <span class="s3">#</span>
    <span class="s3">#    (number of perimeters that can be extracted vertically,</span>
    <span class="s3">#     number of perimeters that can be extracted horizontally,</span>
    <span class="s3">#     cstride for top and bottom and rstride for left and right)</span>
    <span class="s3">#</span>
    <span class="s3"># Note that _unfold doesn't incur any memory copies, so the only costly</span>
    <span class="s3"># operation here is the np.concatenate.</span>
    <span class="s1">top = _unfold(x[:-</span><span class="s5">1</span><span class="s1">:rstride</span><span class="s2">, </span><span class="s1">:-</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">cstride</span><span class="s2">, </span><span class="s1">cstride)</span>
    <span class="s1">bottom = _unfold(x[rstride::rstride</span><span class="s2">, </span><span class="s5">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">cstride</span><span class="s2">, </span><span class="s1">cstride)[...</span><span class="s2">, </span><span class="s1">::-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">right = _unfold(x[:-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">cstride::cstride]</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">rstride</span><span class="s2">, </span><span class="s1">rstride)</span>
    <span class="s1">left = _unfold(x[</span><span class="s5">1</span><span class="s1">:</span><span class="s2">, </span><span class="s1">:-</span><span class="s5">1</span><span class="s1">:cstride]</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">rstride</span><span class="s2">, </span><span class="s1">rstride)[...</span><span class="s2">, </span><span class="s1">::-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s2">return </span><span class="s1">(np.concatenate((top</span><span class="s2">, </span><span class="s1">right</span><span class="s2">, </span><span class="s1">bottom</span><span class="s2">, </span><span class="s1">left)</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">2</span><span class="s1">)</span>
              <span class="s1">.reshape(-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2 </span><span class="s1">* (rstride + cstride)))</span>


<span class="s1">@contextlib.contextmanager</span>
<span class="s2">def </span><span class="s1">_setattr_cm(obj</span><span class="s2">, </span><span class="s1">**kwargs):</span>
    <span class="s0">&quot;&quot;&quot; 
    Temporarily set some attributes; restore original state at context exit. 
    &quot;&quot;&quot;</span>
    <span class="s1">sentinel = object()</span>
    <span class="s1">origs = {}</span>
    <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">kwargs:</span>
        <span class="s1">orig = getattr(obj</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">, </span><span class="s1">sentinel)</span>
        <span class="s2">if </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">obj.__dict__ </span><span class="s2">or </span><span class="s1">orig </span><span class="s2">is </span><span class="s1">sentinel:</span>
            <span class="s3"># if we are pulling from the instance dict or the object</span>
            <span class="s3"># does not have this attribute we can trust the above</span>
            <span class="s1">origs[attr] = orig</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s3"># if the attribute is not in the instance dict it must be</span>
            <span class="s3"># from the class level</span>
            <span class="s1">cls_orig = getattr(type(obj)</span><span class="s2">, </span><span class="s1">attr)</span>
            <span class="s3"># if we are dealing with a property (but not a general descriptor)</span>
            <span class="s3"># we want to set the original value back.</span>
            <span class="s2">if </span><span class="s1">isinstance(cls_orig</span><span class="s2">, </span><span class="s1">property):</span>
                <span class="s1">origs[attr] = orig</span>
            <span class="s3"># otherwise this is _something_ we are going to shadow at</span>
            <span class="s3"># the instance dict level from higher up in the MRO.  We</span>
            <span class="s3"># are going to assume we can delattr(obj, attr) to clean</span>
            <span class="s3"># up after ourselves.  It is possible that this code will</span>
            <span class="s3"># fail if used with a non-property custom descriptor which</span>
            <span class="s3"># implements __set__ (and __delete__ does not act like a</span>
            <span class="s3"># stack).  However, this is an internal tool and we do not</span>
            <span class="s3"># currently have any custom descriptors.</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">origs[attr] = sentinel</span>

    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">for </span><span class="s1">attr</span><span class="s2">, </span><span class="s1">val </span><span class="s2">in </span><span class="s1">kwargs.items():</span>
            <span class="s1">setattr(obj</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">, </span><span class="s1">val)</span>
        <span class="s2">yield</span>
    <span class="s2">finally</span><span class="s1">:</span>
        <span class="s2">for </span><span class="s1">attr</span><span class="s2">, </span><span class="s1">orig </span><span class="s2">in </span><span class="s1">origs.items():</span>
            <span class="s2">if </span><span class="s1">orig </span><span class="s2">is </span><span class="s1">sentinel:</span>
                <span class="s1">delattr(obj</span><span class="s2">, </span><span class="s1">attr)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">setattr(obj</span><span class="s2">, </span><span class="s1">attr</span><span class="s2">, </span><span class="s1">orig)</span>


<span class="s2">class </span><span class="s1">_OrderedSet(collections.abc.MutableSet):</span>
    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">self._od = collections.OrderedDict()</span>

    <span class="s2">def </span><span class="s1">__contains__(self</span><span class="s2">, </span><span class="s1">key):</span>
        <span class="s2">return </span><span class="s1">key </span><span class="s2">in </span><span class="s1">self._od</span>

    <span class="s2">def </span><span class="s1">__iter__(self):</span>
        <span class="s2">return </span><span class="s1">iter(self._od)</span>

    <span class="s2">def </span><span class="s1">__len__(self):</span>
        <span class="s2">return </span><span class="s1">len(self._od)</span>

    <span class="s2">def </span><span class="s1">add(self</span><span class="s2">, </span><span class="s1">key):</span>
        <span class="s1">self._od.pop(key</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s1">self._od[key] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">discard(self</span><span class="s2">, </span><span class="s1">key):</span>
        <span class="s1">self._od.pop(key</span><span class="s2">, None</span><span class="s1">)</span>


<span class="s3"># Agg's buffers are unmultiplied RGBA8888, which neither PyQt&lt;=5.1 nor cairo</span>
<span class="s3"># support; however, both do support premultiplied ARGB32.</span>


<span class="s2">def </span><span class="s1">_premultiplied_argb32_to_unmultiplied_rgba8888(buf):</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert a premultiplied ARGB32 buffer to an unmultiplied RGBA8888 buffer. 
    &quot;&quot;&quot;</span>
    <span class="s1">rgba = np.take(  </span><span class="s3"># .take() ensures C-contiguity of the result.</span>
        <span class="s1">buf</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s5">2</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">3</span><span class="s1">] </span><span class="s2">if </span><span class="s1">sys.byteorder == </span><span class="s4">&quot;little&quot; </span><span class="s2">else </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">2</span><span class="s1">)</span>
    <span class="s1">rgb = rgba[...</span><span class="s2">, </span><span class="s1">:-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">alpha = rgba[...</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s3"># Un-premultiply alpha.  The formula is the same as in cairo-png.c.</span>
    <span class="s1">mask = alpha != </span><span class="s5">0</span>
    <span class="s2">for </span><span class="s1">channel </span><span class="s2">in </span><span class="s1">np.rollaxis(rgb</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">):</span>
        <span class="s1">channel[mask] = (</span>
            <span class="s1">(channel[mask].astype(int) * </span><span class="s5">255 </span><span class="s1">+ alpha[mask] // </span><span class="s5">2</span><span class="s1">)</span>
            <span class="s1">// alpha[mask])</span>
    <span class="s2">return </span><span class="s1">rgba</span>


<span class="s2">def </span><span class="s1">_unmultiplied_rgba8888_to_premultiplied_argb32(rgba8888):</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert an unmultiplied RGBA8888 buffer to a premultiplied ARGB32 buffer. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">sys.byteorder == </span><span class="s4">&quot;little&quot;</span><span class="s1">:</span>
        <span class="s1">argb32 = np.take(rgba8888</span><span class="s2">, </span><span class="s1">[</span><span class="s5">2</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">rgb24 = argb32[...</span><span class="s2">, </span><span class="s1">:-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">alpha8 = argb32[...</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">:]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">argb32 = np.take(rgba8888</span><span class="s2">, </span><span class="s1">[</span><span class="s5">3</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">alpha8 = argb32[...</span><span class="s2">, </span><span class="s1">:</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">rgb24 = argb32[...</span><span class="s2">, </span><span class="s5">1</span><span class="s1">:]</span>
    <span class="s3"># Only bother premultiplying when the alpha channel is not fully opaque,</span>
    <span class="s3"># as the cost is not negligible.  The unsafe cast is needed to do the</span>
    <span class="s3"># multiplication in-place in an integer buffer.</span>
    <span class="s2">if </span><span class="s1">alpha8.min() != </span><span class="s5">0xff</span><span class="s1">:</span>
        <span class="s1">np.multiply(rgb24</span><span class="s2">, </span><span class="s1">alpha8 / </span><span class="s5">0xff</span><span class="s2">, </span><span class="s1">out=rgb24</span><span class="s2">, </span><span class="s1">casting=</span><span class="s4">&quot;unsafe&quot;</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">argb32</span>


<span class="s2">def </span><span class="s1">_get_nonzero_slices(buf):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the bounds of the nonzero region of a 2D array as a pair of slices. 
 
    ``buf[_get_nonzero_slices(buf)]`` is the smallest sub-rectangle in *buf* 
    that encloses all non-zero entries in *buf*.  If *buf* is fully zero, then 
    ``(slice(0, 0), slice(0, 0))`` is returned. 
    &quot;&quot;&quot;</span>
    <span class="s1">x_nz</span><span class="s2">, </span><span class="s1">= buf.any(axis=</span><span class="s5">0</span><span class="s1">).nonzero()</span>
    <span class="s1">y_nz</span><span class="s2">, </span><span class="s1">= buf.any(axis=</span><span class="s5">1</span><span class="s1">).nonzero()</span>
    <span class="s2">if </span><span class="s1">len(x_nz) </span><span class="s2">and </span><span class="s1">len(y_nz):</span>
        <span class="s1">l</span><span class="s2">, </span><span class="s1">r = x_nz[[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]]</span>
        <span class="s1">b</span><span class="s2">, </span><span class="s1">t = y_nz[[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]]</span>
        <span class="s2">return </span><span class="s1">slice(b</span><span class="s2">, </span><span class="s1">t + </span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">slice(l</span><span class="s2">, </span><span class="s1">r + </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">slice(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">slice(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_pformat_subprocess(command):</span>
    <span class="s0">&quot;&quot;&quot;Pretty-format a subprocess command for printing/logging purposes.&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">(command </span><span class="s2">if </span><span class="s1">isinstance(command</span><span class="s2">, </span><span class="s1">str)</span>
            <span class="s2">else </span><span class="s4">&quot; &quot;</span><span class="s1">.join(shlex.quote(os.fspath(arg)) </span><span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">command))</span>


<span class="s2">def </span><span class="s1">_check_and_log_subprocess(command</span><span class="s2">, </span><span class="s1">logger</span><span class="s2">, </span><span class="s1">**kwargs):</span>
    <span class="s0">&quot;&quot;&quot; 
    Run *command*, returning its stdout output if it succeeds. 
 
    If it fails (exits with nonzero return code), raise an exception whose text 
    includes the failed command and captured stdout and stderr output. 
 
    Regardless of the return code, the command is logged at DEBUG level on 
    *logger*.  In case of success, the output is likewise logged. 
    &quot;&quot;&quot;</span>
    <span class="s1">logger.debug(</span><span class="s4">'%s'</span><span class="s2">, </span><span class="s1">_pformat_subprocess(command))</span>
    <span class="s1">proc = subprocess.run(command</span><span class="s2">, </span><span class="s1">capture_output=</span><span class="s2">True, </span><span class="s1">**kwargs)</span>
    <span class="s2">if </span><span class="s1">proc.returncode:</span>
        <span class="s1">stdout = proc.stdout</span>
        <span class="s2">if </span><span class="s1">isinstance(stdout</span><span class="s2">, </span><span class="s1">bytes):</span>
            <span class="s1">stdout = stdout.decode()</span>
        <span class="s1">stderr = proc.stderr</span>
        <span class="s2">if </span><span class="s1">isinstance(stderr</span><span class="s2">, </span><span class="s1">bytes):</span>
            <span class="s1">stderr = stderr.decode()</span>
        <span class="s2">raise </span><span class="s1">RuntimeError(</span>
            <span class="s4">f&quot;The command</span><span class="s2">\n</span><span class="s4">&quot;</span>
            <span class="s4">f&quot;    </span><span class="s2">{</span><span class="s1">_pformat_subprocess(command)</span><span class="s2">}\n</span><span class="s4">&quot;</span>
            <span class="s4">f&quot;failed and generated the following output:</span><span class="s2">\n</span><span class="s4">&quot;</span>
            <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">stdout</span><span class="s2">}\n</span><span class="s4">&quot;</span>
            <span class="s4">f&quot;and the following error:</span><span class="s2">\n</span><span class="s4">&quot;</span>
            <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">stderr</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">proc.stdout:</span>
        <span class="s1">logger.debug(</span><span class="s4">&quot;stdout:</span><span class="s2">\n</span><span class="s4">%s&quot;</span><span class="s2">, </span><span class="s1">proc.stdout)</span>
    <span class="s2">if </span><span class="s1">proc.stderr:</span>
        <span class="s1">logger.debug(</span><span class="s4">&quot;stderr:</span><span class="s2">\n</span><span class="s4">%s&quot;</span><span class="s2">, </span><span class="s1">proc.stderr)</span>
    <span class="s2">return </span><span class="s1">proc.stdout</span>


<span class="s2">def </span><span class="s1">_backend_module_name(name):</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert a backend name (either a standard backend -- &quot;Agg&quot;, &quot;TkAgg&quot;, ... -- 
    or a custom backend -- &quot;module://...&quot;) to the corresponding module name). 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">(name[</span><span class="s5">9</span><span class="s1">:] </span><span class="s2">if </span><span class="s1">name.startswith(</span><span class="s4">&quot;module://&quot;</span><span class="s1">)</span>
            <span class="s2">else </span><span class="s4">f&quot;matplotlib.backends.backend_</span><span class="s2">{</span><span class="s1">name.lower()</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_setup_new_guiapp():</span>
    <span class="s0">&quot;&quot;&quot; 
    Perform OS-dependent setup when Matplotlib creates a new GUI application. 
    &quot;&quot;&quot;</span>
    <span class="s3"># Windows: If not explicit app user model id has been set yet (so we're not</span>
    <span class="s3"># already embedded), then set it to &quot;matplotlib&quot;, so that taskbar icons are</span>
    <span class="s3"># correct.</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">_c_internal_utils.Win32_GetCurrentProcessExplicitAppUserModelID()</span>
    <span class="s2">except </span><span class="s1">OSError:</span>
        <span class="s1">_c_internal_utils.Win32_SetCurrentProcessExplicitAppUserModelID(</span>
            <span class="s4">&quot;matplotlib&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_format_approx(number</span><span class="s2">, </span><span class="s1">precision):</span>
    <span class="s0">&quot;&quot;&quot; 
    Format the number with at most the number of decimals given as precision. 
    Remove trailing zeros and possibly the decimal point. 
    &quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s4">f'</span><span class="s2">{</span><span class="s1">number</span><span class="s2">:</span><span class="s4">.</span><span class="s2">{</span><span class="s1">precision</span><span class="s2">}</span><span class="s4">f</span><span class="s2">}</span><span class="s4">'</span><span class="s1">.rstrip(</span><span class="s4">'0'</span><span class="s1">).rstrip(</span><span class="s4">'.'</span><span class="s1">) </span><span class="s2">or </span><span class="s4">'0'</span>


<span class="s2">def </span><span class="s1">_g_sig_digits(value</span><span class="s2">, </span><span class="s1">delta):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return the number of significant digits to %g-format *value*, assuming that 
    it is known with an error of *delta*. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">delta == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3"># delta = 0 may occur when trying to format values over a tiny range;</span>
        <span class="s3"># in that case, replace it by the distance to the closest float.</span>
        <span class="s1">delta = abs(np.spacing(value))</span>
    <span class="s3"># If e.g. value = 45.67 and delta = 0.02, then we want to round to 2 digits</span>
    <span class="s3"># after the decimal point (floor(log10(0.02)) = -2); 45.67 contributes 2</span>
    <span class="s3"># digits before the decimal point (floor(log10(45.67)) + 1 = 2): the total</span>
    <span class="s3"># is 4 significant digits.  A value of 0 contributes 1 &quot;digit&quot; before the</span>
    <span class="s3"># decimal point.</span>
    <span class="s3"># For inf or nan, the precision doesn't matter.</span>
    <span class="s2">return </span><span class="s1">max(</span>
        <span class="s5">0</span><span class="s2">,</span>
        <span class="s1">(math.floor(math.log10(abs(value))) + </span><span class="s5">1 </span><span class="s2">if </span><span class="s1">value </span><span class="s2">else </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">- math.floor(math.log10(delta))) </span><span class="s2">if </span><span class="s1">math.isfinite(value) </span><span class="s2">else </span><span class="s5">0</span>


<span class="s2">def </span><span class="s1">_unikey_or_keysym_to_mplkey(unikey</span><span class="s2">, </span><span class="s1">keysym):</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert a Unicode key or X keysym to a Matplotlib key name. 
 
    The Unicode key is checked first; this avoids having to list most printable 
    keysyms such as ``EuroSign``. 
    &quot;&quot;&quot;</span>
    <span class="s3"># For non-printable characters, gtk3 passes &quot;\0&quot; whereas tk passes an &quot;&quot;.</span>
    <span class="s2">if </span><span class="s1">unikey </span><span class="s2">and </span><span class="s1">unikey.isprintable():</span>
        <span class="s2">return </span><span class="s1">unikey</span>
    <span class="s1">key = keysym.lower()</span>
    <span class="s2">if </span><span class="s1">key.startswith(</span><span class="s4">&quot;kp_&quot;</span><span class="s1">):  </span><span class="s3"># keypad_x (including kp_enter).</span>
        <span class="s1">key = key[</span><span class="s5">3</span><span class="s1">:]</span>
    <span class="s2">if </span><span class="s1">key.startswith(</span><span class="s4">&quot;page_&quot;</span><span class="s1">):  </span><span class="s3"># page_{up,down}</span>
        <span class="s1">key = key.replace(</span><span class="s4">&quot;page_&quot;</span><span class="s2">, </span><span class="s4">&quot;page&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">key.endswith((</span><span class="s4">&quot;_l&quot;</span><span class="s2">, </span><span class="s4">&quot;_r&quot;</span><span class="s1">)):  </span><span class="s3"># alt_l, ctrl_l, shift_l.</span>
        <span class="s1">key = key[:-</span><span class="s5">2</span><span class="s1">]</span>
    <span class="s2">if </span><span class="s1">sys.platform == </span><span class="s4">&quot;darwin&quot; </span><span class="s2">and </span><span class="s1">key == </span><span class="s4">&quot;meta&quot;</span><span class="s1">:</span>
        <span class="s3"># meta should be reported as command on mac</span>
        <span class="s1">key = </span><span class="s4">&quot;cmd&quot;</span>
    <span class="s1">key = {</span>
        <span class="s4">&quot;return&quot;</span><span class="s1">: </span><span class="s4">&quot;enter&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;prior&quot;</span><span class="s1">: </span><span class="s4">&quot;pageup&quot;</span><span class="s2">,  </span><span class="s3"># Used by tk.</span>
        <span class="s4">&quot;next&quot;</span><span class="s1">: </span><span class="s4">&quot;pagedown&quot;</span><span class="s2">,  </span><span class="s3"># Used by tk.</span>
    <span class="s1">}.get(key</span><span class="s2">, </span><span class="s1">key)</span>
    <span class="s2">return </span><span class="s1">key</span>


<span class="s1">@functools.cache</span>
<span class="s2">def </span><span class="s1">_make_class_factory(mixin_class</span><span class="s2">, </span><span class="s1">fmt</span><span class="s2">, </span><span class="s1">attr_name=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Return a function that creates picklable classes inheriting from a mixin. 
 
    After :: 
 
        factory = _make_class_factory(FooMixin, fmt, attr_name) 
        FooAxes = factory(Axes) 
 
    ``Foo`` is a class that inherits from ``FooMixin`` and ``Axes`` and **is 
    picklable** (picklability is what differentiates this from a plain call to 
    `type`).  Its ``__name__`` is set to ``fmt.format(Axes.__name__)`` and the 
    base class is stored in the ``attr_name`` attribute, if not None. 
 
    Moreover, the return value of ``factory`` is memoized: calls with the same 
    ``Axes`` class always return the same subclass. 
    &quot;&quot;&quot;</span>

    <span class="s1">@functools.cache</span>
    <span class="s2">def </span><span class="s1">class_factory(axes_class):</span>
        <span class="s3"># if we have already wrapped this class, declare victory!</span>
        <span class="s2">if </span><span class="s1">issubclass(axes_class</span><span class="s2">, </span><span class="s1">mixin_class):</span>
            <span class="s2">return </span><span class="s1">axes_class</span>

        <span class="s3"># The parameter is named &quot;axes_class&quot; for backcompat but is really just</span>
        <span class="s3"># a base class; no axes semantics are used.</span>
        <span class="s1">base_class = axes_class</span>

        <span class="s2">class </span><span class="s1">subcls(mixin_class</span><span class="s2">, </span><span class="s1">base_class):</span>
            <span class="s3"># Better approximation than __module__ = &quot;matplotlib.cbook&quot;.</span>
            <span class="s1">__module__ = mixin_class.__module__</span>

            <span class="s2">def </span><span class="s1">__reduce__(self):</span>
                <span class="s2">return </span><span class="s1">(_picklable_class_constructor</span><span class="s2">,</span>
                        <span class="s1">(mixin_class</span><span class="s2">, </span><span class="s1">fmt</span><span class="s2">, </span><span class="s1">attr_name</span><span class="s2">, </span><span class="s1">base_class)</span><span class="s2">,</span>
                        <span class="s1">self.__getstate__())</span>

        <span class="s1">subcls.__name__ = subcls.__qualname__ = fmt.format(base_class.__name__)</span>
        <span class="s2">if </span><span class="s1">attr_name </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">setattr(subcls</span><span class="s2">, </span><span class="s1">attr_name</span><span class="s2">, </span><span class="s1">base_class)</span>
        <span class="s2">return </span><span class="s1">subcls</span>

    <span class="s1">class_factory.__module__ = mixin_class.__module__</span>
    <span class="s2">return </span><span class="s1">class_factory</span>


<span class="s2">def </span><span class="s1">_picklable_class_constructor(mixin_class</span><span class="s2">, </span><span class="s1">fmt</span><span class="s2">, </span><span class="s1">attr_name</span><span class="s2">, </span><span class="s1">base_class):</span>
    <span class="s0">&quot;&quot;&quot;Internal helper for _make_class_factory.&quot;&quot;&quot;</span>
    <span class="s1">factory = _make_class_factory(mixin_class</span><span class="s2">, </span><span class="s1">fmt</span><span class="s2">, </span><span class="s1">attr_name)</span>
    <span class="s1">cls = factory(base_class)</span>
    <span class="s2">return </span><span class="s1">cls.__new__(cls)</span>


<span class="s2">def </span><span class="s1">_unpack_to_numpy(x):</span>
    <span class="s0">&quot;&quot;&quot;Internal helper to extract data from e.g. pandas and xarray objects.&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">np.ndarray):</span>
        <span class="s3"># If numpy, return directly</span>
        <span class="s2">return </span><span class="s1">x</span>
    <span class="s2">if </span><span class="s1">hasattr(x</span><span class="s2">, </span><span class="s4">'to_numpy'</span><span class="s1">):</span>
        <span class="s3"># Assume that any to_numpy() method actually returns a numpy array</span>
        <span class="s2">return </span><span class="s1">x.to_numpy()</span>
    <span class="s2">if </span><span class="s1">hasattr(x</span><span class="s2">, </span><span class="s4">'values'</span><span class="s1">):</span>
        <span class="s1">xtmp = x.values</span>
        <span class="s3"># For example a dict has a 'values' attribute, but it is not a property</span>
        <span class="s3"># so in this case we do not want to return a function</span>
        <span class="s2">if </span><span class="s1">isinstance(xtmp</span><span class="s2">, </span><span class="s1">np.ndarray):</span>
            <span class="s2">return </span><span class="s1">xtmp</span>
    <span class="s2">return </span><span class="s1">x</span>


<span class="s2">def </span><span class="s1">_auto_format_str(fmt</span><span class="s2">, </span><span class="s1">value):</span>
    <span class="s0">&quot;&quot;&quot; 
    Apply *value* to the format string *fmt*. 
 
    This works both with unnamed %-style formatting and 
    unnamed {}-style formatting. %-style formatting has priority. 
    If *fmt* is %-style formattable that will be used. Otherwise, 
    {}-formatting is applied. Strings without formatting placeholders 
    are passed through as is. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; _auto_format_str('%.2f m', 0.2) 
    '0.20 m' 
    &gt;&gt;&gt; _auto_format_str('{} m', 0.2) 
    '0.2 m' 
    &gt;&gt;&gt; _auto_format_str('const', 0.2) 
    'const' 
    &gt;&gt;&gt; _auto_format_str('%d or {}', 0.2) 
    '0 or {}' 
    &quot;&quot;&quot;</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">fmt % (value</span><span class="s2">,</span><span class="s1">)</span>
    <span class="s2">except </span><span class="s1">(TypeError</span><span class="s2">, </span><span class="s1">ValueError):</span>
        <span class="s2">return </span><span class="s1">fmt.format(value)</span>
</pre>
</body>
</html>