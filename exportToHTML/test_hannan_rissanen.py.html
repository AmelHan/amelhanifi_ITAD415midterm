<html>
<head>
<title>test_hannan_rissanen.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_hannan_rissanen.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">import </span><span class="s1">pytest</span>
<span class="s0">from </span><span class="s1">numpy.testing </span><span class="s0">import </span><span class="s1">assert_allclose</span>

<span class="s0">from </span><span class="s1">statsmodels.tsa.innovations.arma_innovations </span><span class="s0">import </span><span class="s1">arma_innovations</span>
<span class="s0">from </span><span class="s1">statsmodels.tsa.arima.datasets.brockwell_davis_2002 </span><span class="s0">import </span><span class="s1">lake</span>
<span class="s0">from </span><span class="s1">statsmodels.tsa.arima.estimators.hannan_rissanen </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">hannan_rissanen</span><span class="s0">, </span><span class="s1">_validate_fixed_params</span><span class="s0">,</span>
    <span class="s1">_package_fixed_and_free_params_info</span><span class="s0">,</span>
    <span class="s1">_stitch_fixed_and_free_params</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">statsmodels.tsa.arima.specification </span><span class="s0">import </span><span class="s1">SARIMAXSpecification</span>
<span class="s0">from </span><span class="s1">statsmodels.tools.tools </span><span class="s0">import </span><span class="s1">Bunch</span>


<span class="s1">@pytest.mark.low_precision(</span><span class="s2">'Test against Example 5.1.7 in Brockwell and Davis'</span>
                           <span class="s2">' (2016)'</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_brockwell_davis_example_517():</span>
    <span class="s3"># Get the lake data</span>
    <span class="s1">endog = lake.copy()</span>

    <span class="s3"># BD do not implement the &quot;bias correction&quot; third step that they describe,</span>
    <span class="s3"># so we can't use their results to test that. Thus here `unbiased=False`.</span>
    <span class="s3"># Note: it's not clear why BD use initial_order=22 (and they don't mention</span>
    <span class="s3"># that they do this), but it is the value that allows the test to pass.</span>
    <span class="s1">hr</span><span class="s0">, </span><span class="s1">_ = hannan_rissanen(endog</span><span class="s0">, </span><span class="s1">ar_order=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">ma_order=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">demean=</span><span class="s0">True,</span>
                            <span class="s1">initial_ar_order=</span><span class="s4">22</span><span class="s0">, </span><span class="s1">unbiased=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">assert_allclose(hr.ar_params</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0.6961</span><span class="s1">]</span><span class="s0">, </span><span class="s1">atol=</span><span class="s4">1e-4</span><span class="s1">)</span>
    <span class="s1">assert_allclose(hr.ma_params</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0.3788</span><span class="s1">]</span><span class="s0">, </span><span class="s1">atol=</span><span class="s4">1e-4</span><span class="s1">)</span>

    <span class="s3"># Because our fast implementation of the innovations algorithm does not</span>
    <span class="s3"># allow for non-stationary processes, the estimate of the variance returned</span>
    <span class="s3"># by `hannan_rissanen` is based on the residuals from the least-squares</span>
    <span class="s3"># regression, rather than (as reported by BD) based on the innovations</span>
    <span class="s3"># algorithm output. Since the estimates here do correspond to a stationary</span>
    <span class="s3"># series, we can compute the innovations variance manually to check</span>
    <span class="s3"># against BD.</span>
    <span class="s1">u</span><span class="s0">, </span><span class="s1">v = arma_innovations(endog - endog.mean()</span><span class="s0">, </span><span class="s1">hr.ar_params</span><span class="s0">, </span><span class="s1">hr.ma_params</span><span class="s0">,</span>
                            <span class="s1">sigma2=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">tmp = u / v**</span><span class="s4">0.5</span>
    <span class="s1">assert_allclose(np.inner(tmp</span><span class="s0">, </span><span class="s1">tmp) / len(u)</span><span class="s0">, </span><span class="s4">0.4774</span><span class="s0">, </span><span class="s1">atol=</span><span class="s4">1e-4</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_itsmr():</span>
    <span class="s3"># This is essentially a high precision version of</span>
    <span class="s3"># test_brockwell_davis_example_517, where the desired values were computed</span>
    <span class="s3"># from R itsmr::hannan; see results/results_hr.R</span>
    <span class="s1">endog = lake.copy()</span>
    <span class="s1">hr</span><span class="s0">, </span><span class="s1">_ = hannan_rissanen(endog</span><span class="s0">, </span><span class="s1">ar_order=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">ma_order=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">demean=</span><span class="s0">True,</span>
                            <span class="s1">initial_ar_order=</span><span class="s4">22</span><span class="s0">, </span><span class="s1">unbiased=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s1">assert_allclose(hr.ar_params</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0.69607715</span><span class="s1">]</span><span class="s0">, </span><span class="s1">atol=</span><span class="s4">1e-4</span><span class="s1">)</span>
    <span class="s1">assert_allclose(hr.ma_params</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0.3787969217</span><span class="s1">]</span><span class="s0">, </span><span class="s1">atol=</span><span class="s4">1e-4</span><span class="s1">)</span>

    <span class="s3"># Because our fast implementation of the innovations algorithm does not</span>
    <span class="s3"># allow for non-stationary processes, the estimate of the variance returned</span>
    <span class="s3"># by `hannan_rissanen` is based on the residuals from the least-squares</span>
    <span class="s3"># regression, rather than (as reported by BD) based on the innovations</span>
    <span class="s3"># algorithm output. Since the estimates here do correspond to a stationary</span>
    <span class="s3"># series, we can compute the innovations variance manually to check</span>
    <span class="s3"># against BD.</span>
    <span class="s1">u</span><span class="s0">, </span><span class="s1">v = arma_innovations(endog - endog.mean()</span><span class="s0">, </span><span class="s1">hr.ar_params</span><span class="s0">, </span><span class="s1">hr.ma_params</span><span class="s0">,</span>
                            <span class="s1">sigma2=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">tmp = u / v**</span><span class="s4">0.5</span>
    <span class="s1">assert_allclose(np.inner(tmp</span><span class="s0">, </span><span class="s1">tmp) / len(u)</span><span class="s0">, </span><span class="s4">0.4773580109</span><span class="s0">, </span><span class="s1">atol=</span><span class="s4">1e-4</span><span class="s1">)</span>


<span class="s1">@pytest.mark.xfail(reason=</span><span class="s2">'TODO: improve checks on valid order parameters.'</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_initial_order():</span>
    <span class="s1">endog = np.arange(</span><span class="s4">20</span><span class="s1">) * </span><span class="s4">1.0</span>
    <span class="s3"># TODO: shouldn't allow initial_ar_order &lt;= ar_order</span>
    <span class="s1">hannan_rissanen(endog</span><span class="s0">, </span><span class="s1">ar_order=</span><span class="s4">2</span><span class="s0">, </span><span class="s1">ma_order=</span><span class="s4">0</span><span class="s0">, </span><span class="s1">initial_ar_order=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s3"># TODO: shouldn't allow initial_ar_order &lt;= ma_order</span>
    <span class="s1">hannan_rissanen(endog</span><span class="s0">, </span><span class="s1">ar_order=</span><span class="s4">0</span><span class="s0">, </span><span class="s1">ma_order=</span><span class="s4">2</span><span class="s0">, </span><span class="s1">initial_ar_order=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s3"># TODO: shouldn't allow initial_ar_order &gt;= dataset</span>
    <span class="s1">hannan_rissanen(endog</span><span class="s0">, </span><span class="s1">ar_order=</span><span class="s4">0</span><span class="s0">, </span><span class="s1">ma_order=</span><span class="s4">2</span><span class="s0">, </span><span class="s1">initial_ar_order=</span><span class="s4">20</span><span class="s1">)</span>


<span class="s1">@pytest.mark.xfail(reason=</span><span class="s2">'TODO: improve checks on valid order parameters.'</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_invalid_orders():</span>
    <span class="s1">endog = np.arange(</span><span class="s4">2</span><span class="s1">) * </span><span class="s4">1.0</span>
    <span class="s3"># TODO: shouldn't allow ar_order &gt;= dataset</span>
    <span class="s1">hannan_rissanen(endog</span><span class="s0">, </span><span class="s1">ar_order=</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s3"># TODO: shouldn't allow ma_order &gt;= dataset</span>
    <span class="s1">hannan_rissanen(endog</span><span class="s0">, </span><span class="s1">ma_order=</span><span class="s4">2</span><span class="s1">)</span>


<span class="s1">@pytest.mark.todo(</span><span class="s2">'Improve checks on valid order parameters.'</span><span class="s1">)</span>
<span class="s1">@pytest.mark.smoke</span>
<span class="s0">def </span><span class="s1">test_nonconsecutive_lags():</span>
    <span class="s1">endog = np.arange(</span><span class="s4">20</span><span class="s1">) * </span><span class="s4">1.0</span>
    <span class="s1">hannan_rissanen(endog</span><span class="s0">, </span><span class="s1">ar_order=[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">4</span><span class="s1">])</span>
    <span class="s1">hannan_rissanen(endog</span><span class="s0">, </span><span class="s1">ma_order=[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s1">])</span>
    <span class="s1">hannan_rissanen(endog</span><span class="s0">, </span><span class="s1">ar_order=[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">ma_order=[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s1">])</span>
    <span class="s1">hannan_rissanen(endog</span><span class="s0">, </span><span class="s1">ar_order=[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">hannan_rissanen(endog</span><span class="s0">, </span><span class="s1">ma_order=[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">hannan_rissanen(endog</span><span class="s0">, </span><span class="s1">ar_order=[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">ma_order=[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">])</span>

    <span class="s1">hannan_rissanen(endog</span><span class="s0">, </span><span class="s1">ar_order=</span><span class="s4">0</span><span class="s0">, </span><span class="s1">ma_order=</span><span class="s4">0</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_unbiased_error():</span>
    <span class="s3"># Test that we get the appropriate error when we specify unbiased=True</span>
    <span class="s3"># but the second-stage yields non-stationary parameters.</span>
    <span class="s1">endog = (np.arange(</span><span class="s4">1000</span><span class="s1">) * </span><span class="s4">1.0</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">'Cannot perform third step'</span><span class="s1">):</span>
        <span class="s1">hannan_rissanen(endog</span><span class="s0">, </span><span class="s1">ar_order=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">ma_order=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">unbiased=</span><span class="s0">True</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_set_default_unbiased():</span>
    <span class="s3"># setting unbiased=None with stationary and invertible parameters should</span>
    <span class="s3"># yield the exact same results as setting unbiased=True</span>
    <span class="s1">endog = lake.copy()</span>
    <span class="s1">p_1</span><span class="s0">, </span><span class="s1">other_results_2 = hannan_rissanen(</span>
        <span class="s1">endog</span><span class="s0">, </span><span class="s1">ar_order=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">ma_order=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">unbiased=</span><span class="s0">None</span>
    <span class="s1">)</span>

    <span class="s3"># unbiased=True</span>
    <span class="s1">p_2</span><span class="s0">, </span><span class="s1">other_results_1 = hannan_rissanen(</span>
        <span class="s1">endog</span><span class="s0">, </span><span class="s1">ar_order=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">ma_order=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">unbiased=</span><span class="s0">True</span>
    <span class="s1">)</span>

    <span class="s1">np.testing.assert_array_equal(p_1.ar_params</span><span class="s0">, </span><span class="s1">p_2.ar_params)</span>
    <span class="s1">np.testing.assert_array_equal(p_1.ma_params</span><span class="s0">, </span><span class="s1">p_2.ma_params)</span>
    <span class="s0">assert </span><span class="s1">p_1.sigma2 == p_2.sigma2</span>
    <span class="s1">np.testing.assert_array_equal(other_results_1.resid</span><span class="s0">, </span><span class="s1">other_results_2.resid)</span>

    <span class="s3"># unbiased=False</span>
    <span class="s1">p_3</span><span class="s0">, </span><span class="s1">_ = hannan_rissanen(</span>
        <span class="s1">endog</span><span class="s0">, </span><span class="s1">ar_order=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">ma_order=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">unbiased=</span><span class="s0">False</span>
    <span class="s1">)</span>
    <span class="s0">assert not </span><span class="s1">np.array_equal(p_1.ar_params</span><span class="s0">, </span><span class="s1">p_3.ar_params)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;ar_order, ma_order, fixed_params, invalid_fixed_params&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s3"># no fixed param</span>
        <span class="s1">(</span><span class="s4">2</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, None, None</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">([</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">{}</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s3"># invalid fixed params</span>
        <span class="s1">(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;ar.L2&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s0">, </span><span class="s2">&quot;ma.L2&quot;</span><span class="s1">: </span><span class="s4">0</span><span class="s1">}</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;ar.L2&quot;</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">([</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;ma.L1&quot;</span><span class="s1">: </span><span class="s4">0</span><span class="s0">, </span><span class="s2">&quot;sigma2&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s1">}</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;ma.L2&quot;</span><span class="s0">, </span><span class="s2">&quot;sigma2&quot;</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;ma.L1&quot;</span><span class="s1">: </span><span class="s4">0</span><span class="s0">, </span><span class="s2">&quot;ar.L1&quot;</span><span class="s1">: </span><span class="s4">0</span><span class="s1">}</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;ar.L1&quot;</span><span class="s0">, </span><span class="s2">&quot;ma.L1&quot;</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s4">5</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;random_param&quot;</span><span class="s1">: </span><span class="s4">0</span><span class="s0">, </span><span class="s2">&quot;ar.L1&quot;</span><span class="s1">: </span><span class="s4">0</span><span class="s1">}</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;random_param&quot;</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s3"># valid fixed params</span>
        <span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;ma.L1&quot;</span><span class="s1">: -</span><span class="s4">1</span><span class="s0">, </span><span class="s2">&quot;ma.L2&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s1">}</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;ar.L1&quot;</span><span class="s1">: </span><span class="s4">0</span><span class="s1">}</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;ma.L2&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s0">, </span><span class="s2">&quot;ar.L3&quot;</span><span class="s1">: -</span><span class="s4">1</span><span class="s1">}</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s3"># all fixed</span>
        <span class="s1">(</span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;ma.L1&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s0">, </span><span class="s2">&quot;ma.L2&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s0">, </span><span class="s2">&quot;ar.L1&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s0">, </span><span class="s2">&quot;ar.L2&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s1">}</span><span class="s0">, None</span><span class="s1">)</span>
    <span class="s1">]</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_validate_fixed_params(ar_order</span><span class="s0">, </span><span class="s1">ma_order</span><span class="s0">, </span><span class="s1">fixed_params</span><span class="s0">,</span>
                               <span class="s1">invalid_fixed_params):</span>
    <span class="s3"># test validation with both _validate_fixed_params and directly with</span>
    <span class="s3"># hannan_rissanen</span>

    <span class="s1">endog = np.random.normal(size=</span><span class="s4">100</span><span class="s1">)</span>
    <span class="s1">spec = SARIMAXSpecification(endog</span><span class="s0">, </span><span class="s1">ar_order=ar_order</span><span class="s0">, </span><span class="s1">ma_order=ma_order)</span>

    <span class="s0">if </span><span class="s1">invalid_fixed_params </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">_validate_fixed_params(fixed_params</span><span class="s0">, </span><span class="s1">spec.param_names)</span>
        <span class="s1">hannan_rissanen(</span>
            <span class="s1">endog</span><span class="s0">, </span><span class="s1">ar_order=ar_order</span><span class="s0">, </span><span class="s1">ma_order=ma_order</span><span class="s0">,</span>
            <span class="s1">fixed_params=fixed_params</span><span class="s0">, </span><span class="s1">unbiased=</span><span class="s0">False</span>
        <span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">valid_params = sorted(list(set(spec.param_names) - {</span><span class="s2">'sigma2'</span><span class="s1">}))</span>
        <span class="s1">msg = (</span>
            <span class="s2">f&quot;Invalid fixed parameter(s): </span><span class="s0">{</span><span class="s1">invalid_fixed_params</span><span class="s0">}</span><span class="s2">. &quot;</span>
            <span class="s2">f&quot;Please select among </span><span class="s0">{</span><span class="s1">valid_params</span><span class="s0">}</span><span class="s2">.&quot;</span>
        <span class="s1">)</span>
        <span class="s3"># using direct `assert` to test error message instead of `match` since</span>
        <span class="s3"># the error message contains regex characters</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError) </span><span class="s0">as </span><span class="s1">e:</span>
            <span class="s1">_validate_fixed_params(fixed_params</span><span class="s0">, </span><span class="s1">spec.param_names)</span>
            <span class="s0">assert </span><span class="s1">e.msg == msg</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError) </span><span class="s0">as </span><span class="s1">e:</span>
            <span class="s1">hannan_rissanen(</span>
                <span class="s1">endog</span><span class="s0">, </span><span class="s1">ar_order=ar_order</span><span class="s0">, </span><span class="s1">ma_order=ma_order</span><span class="s0">,</span>
                <span class="s1">fixed_params=fixed_params</span><span class="s0">, </span><span class="s1">unbiased=</span><span class="s0">False</span>
            <span class="s1">)</span>
            <span class="s0">assert </span><span class="s1">e.msg == msg</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;fixed_params, spec_ar_lags, spec_ma_lags, expected_bunch&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">({}</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[]</span><span class="s0">, </span><span class="s1">Bunch(</span>
            <span class="s3"># lags</span>
            <span class="s1">fixed_ar_lags=[]</span><span class="s0">, </span><span class="s1">fixed_ma_lags=[]</span><span class="s0">,</span>
            <span class="s1">free_ar_lags=[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">free_ma_lags=[]</span><span class="s0">,</span>
            <span class="s3"># ixs</span>
            <span class="s1">fixed_ar_ix=np.array([]</span><span class="s0">, </span><span class="s1">dtype=int)</span><span class="s0">,</span>
            <span class="s1">fixed_ma_ix=np.array([]</span><span class="s0">, </span><span class="s1">dtype=int)</span><span class="s0">,</span>
            <span class="s1">free_ar_ix=np.array([</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=int)</span><span class="s0">,</span>
            <span class="s1">free_ma_ix=np.array([]</span><span class="s0">, </span><span class="s1">dtype=int)</span><span class="s0">,</span>
            <span class="s3"># fixed params</span>
            <span class="s1">fixed_ar_params=np.array([])</span><span class="s0">, </span><span class="s1">fixed_ma_params=np.array([])</span><span class="s0">,</span>
        <span class="s1">))</span><span class="s0">,</span>
        <span class="s1">({</span><span class="s2">&quot;ar.L2&quot;</span><span class="s1">: </span><span class="s4">0.1</span><span class="s0">, </span><span class="s2">&quot;ma.L1&quot;</span><span class="s1">: </span><span class="s4">0.2</span><span class="s1">}</span><span class="s0">, </span><span class="s1">[</span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">Bunch(</span>
            <span class="s3"># lags</span>
            <span class="s1">fixed_ar_lags=[</span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">fixed_ma_lags=[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">free_ar_lags=[]</span><span class="s0">, </span><span class="s1">free_ma_lags=[</span><span class="s4">3</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s3"># ixs</span>
            <span class="s1">fixed_ar_ix=np.array([</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=int)</span><span class="s0">,</span>
            <span class="s1">fixed_ma_ix=np.array([</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=int)</span><span class="s0">,</span>
            <span class="s1">free_ar_ix=np.array([]</span><span class="s0">, </span><span class="s1">dtype=int)</span><span class="s0">,</span>
            <span class="s1">free_ma_ix=np.array([</span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=int)</span><span class="s0">,</span>
            <span class="s3"># fixed params</span>
            <span class="s1">fixed_ar_params=np.array([</span><span class="s4">0.1</span><span class="s1">])</span><span class="s0">, </span><span class="s1">fixed_ma_params=np.array([</span><span class="s4">0.2</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">))</span><span class="s0">,</span>
        <span class="s1">({</span><span class="s2">&quot;ma.L5&quot;</span><span class="s1">: </span><span class="s4">0.1</span><span class="s0">, </span><span class="s2">&quot;ma.L10&quot;</span><span class="s1">: </span><span class="s4">0.2</span><span class="s1">}</span><span class="s0">, </span><span class="s1">[]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">5</span><span class="s0">, </span><span class="s4">10</span><span class="s1">]</span><span class="s0">, </span><span class="s1">Bunch(</span>
            <span class="s3"># lags</span>
            <span class="s1">fixed_ar_lags=[]</span><span class="s0">, </span><span class="s1">fixed_ma_lags=[</span><span class="s4">5</span><span class="s0">, </span><span class="s4">10</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">free_ar_lags=[]</span><span class="s0">, </span><span class="s1">free_ma_lags=[]</span><span class="s0">,</span>
            <span class="s3"># ixs</span>
            <span class="s1">fixed_ar_ix=np.array([]</span><span class="s0">, </span><span class="s1">dtype=int)</span><span class="s0">,</span>
            <span class="s1">fixed_ma_ix=np.array([</span><span class="s4">4</span><span class="s0">, </span><span class="s4">9</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=int)</span><span class="s0">,</span>
            <span class="s1">free_ar_ix=np.array([]</span><span class="s0">, </span><span class="s1">dtype=int)</span><span class="s0">,</span>
            <span class="s1">free_ma_ix=np.array([]</span><span class="s0">, </span><span class="s1">dtype=int)</span><span class="s0">,</span>
            <span class="s3"># fixed params</span>
            <span class="s1">fixed_ar_params=np.array([])</span><span class="s0">, </span><span class="s1">fixed_ma_params=np.array([</span><span class="s4">0.1</span><span class="s0">, </span><span class="s4">0.2</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">))</span><span class="s0">,</span>
    <span class="s1">]</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_package_fixed_and_free_params_info(fixed_params</span><span class="s0">, </span><span class="s1">spec_ar_lags</span><span class="s0">,</span>
                                            <span class="s1">spec_ma_lags</span><span class="s0">, </span><span class="s1">expected_bunch):</span>
    <span class="s1">actual_bunch = _package_fixed_and_free_params_info(</span>
        <span class="s1">fixed_params</span><span class="s0">, </span><span class="s1">spec_ar_lags</span><span class="s0">, </span><span class="s1">spec_ma_lags</span>
    <span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">isinstance(actual_bunch</span><span class="s0">, </span><span class="s1">Bunch)</span>
    <span class="s0">assert </span><span class="s1">len(actual_bunch) == len(expected_bunch)</span>
    <span class="s0">assert </span><span class="s1">actual_bunch.keys() == expected_bunch.keys()</span>

    <span class="s3"># check lags</span>
    <span class="s1">lags = [</span><span class="s2">'fixed_ar_lags'</span><span class="s0">, </span><span class="s2">'fixed_ma_lags'</span><span class="s0">, </span><span class="s2">'free_ar_lags'</span><span class="s0">, </span><span class="s2">'free_ma_lags'</span><span class="s1">]</span>
    <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">lags:</span>
        <span class="s0">assert </span><span class="s1">isinstance(actual_bunch[k]</span><span class="s0">, </span><span class="s1">list)</span>
        <span class="s0">assert </span><span class="s1">actual_bunch[k] == expected_bunch[k]</span>

    <span class="s3"># check lags</span>
    <span class="s1">ixs = [</span><span class="s2">'fixed_ar_ix'</span><span class="s0">, </span><span class="s2">'fixed_ma_ix'</span><span class="s0">, </span><span class="s2">'free_ar_ix'</span><span class="s0">, </span><span class="s2">'free_ma_ix'</span><span class="s1">]</span>
    <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">ixs:</span>
        <span class="s0">assert </span><span class="s1">isinstance(actual_bunch[k]</span><span class="s0">, </span><span class="s1">np.ndarray)</span>
        <span class="s0">assert </span><span class="s1">actual_bunch[k].dtype </span><span class="s0">in </span><span class="s1">[np.int64</span><span class="s0">, </span><span class="s1">np.int32]</span>
        <span class="s1">np.testing.assert_array_equal(actual_bunch[k]</span><span class="s0">, </span><span class="s1">expected_bunch[k])</span>

    <span class="s1">params = [</span><span class="s2">'fixed_ar_params'</span><span class="s0">, </span><span class="s2">'fixed_ma_params'</span><span class="s1">]</span>
    <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">params:</span>
        <span class="s0">assert </span><span class="s1">isinstance(actual_bunch[k]</span><span class="s0">, </span><span class="s1">np.ndarray)</span>
        <span class="s1">np.testing.assert_array_equal(actual_bunch[k]</span><span class="s0">, </span><span class="s1">expected_bunch[k])</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;fixed_lags, free_lags, fixed_params, free_params, &quot;</span>
    <span class="s2">&quot;spec_lags, expected_all_params&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">([]</span><span class="s0">, </span><span class="s1">[]</span><span class="s0">, </span><span class="s1">[]</span><span class="s0">, </span><span class="s1">[]</span><span class="s0">, </span><span class="s1">[]</span><span class="s0">, </span><span class="s1">[])</span><span class="s0">,</span>
        <span class="s1">([</span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0.2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0.2</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">([]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0.2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0.2</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">([</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0.2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s4">0.2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">,  </span><span class="s1">[</span><span class="s4">0.2</span><span class="s0">, </span><span class="s1">-</span><span class="s4">0.2</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">([</span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0.2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0.3</span><span class="s0">, </span><span class="s1">-</span><span class="s4">0.2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0.3</span><span class="s0">, </span><span class="s1">-</span><span class="s4">0.2</span><span class="s0">, </span><span class="s4">0.2</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">([</span><span class="s4">3</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">2</span><span class="s0">, </span><span class="s4">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0.3</span><span class="s0">, </span><span class="s4">0.1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0.5</span><span class="s0">, </span><span class="s4">0.</span><span class="s1">]</span><span class="s0">,</span>
         <span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0.1</span><span class="s0">, </span><span class="s4">0.5</span><span class="s0">, </span><span class="s4">0.3</span><span class="s0">, </span><span class="s4">0.</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">([</span><span class="s4">3</span><span class="s0">, </span><span class="s4">10</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0.2</span><span class="s0">, </span><span class="s4">0.5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0.3</span><span class="s0">, </span><span class="s1">-</span><span class="s4">0.2</span><span class="s1">]</span><span class="s0">,</span>
         <span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">10</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0.3</span><span class="s0">, </span><span class="s1">-</span><span class="s4">0.2</span><span class="s0">, </span><span class="s4">0.2</span><span class="s0">, </span><span class="s4">0.5</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s3"># edge case where 'spec_lags' is somehow not sorted</span>
        <span class="s1">([</span><span class="s4">3</span><span class="s0">, </span><span class="s4">10</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0.2</span><span class="s0">, </span><span class="s4">0.5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0.3</span><span class="s0">, </span><span class="s1">-</span><span class="s4">0.2</span><span class="s1">]</span><span class="s0">,</span>
         <span class="s1">[</span><span class="s4">3</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">10</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0.2</span><span class="s0">, </span><span class="s4">0.3</span><span class="s0">, </span><span class="s4">0.5</span><span class="s0">, </span><span class="s1">-</span><span class="s4">0.2</span><span class="s1">])</span><span class="s0">,</span>
    <span class="s1">]</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_stitch_fixed_and_free_params(fixed_lags</span><span class="s0">, </span><span class="s1">free_lags</span><span class="s0">, </span><span class="s1">fixed_params</span><span class="s0">,</span>
                                      <span class="s1">free_params</span><span class="s0">, </span><span class="s1">spec_lags</span><span class="s0">,</span>
                                      <span class="s1">expected_all_params):</span>
    <span class="s1">actual_all_params = _stitch_fixed_and_free_params(</span>
        <span class="s1">fixed_lags</span><span class="s0">, </span><span class="s1">fixed_params</span><span class="s0">, </span><span class="s1">free_lags</span><span class="s0">, </span><span class="s1">free_params</span><span class="s0">, </span><span class="s1">spec_lags</span>
    <span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">actual_all_params == expected_all_params</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;fixed_params&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">{</span><span class="s2">&quot;ar.L1&quot;</span><span class="s1">: </span><span class="s4">0.69607715</span><span class="s1">}</span><span class="s0">,  </span><span class="s3"># fix ar</span>
        <span class="s1">{</span><span class="s2">&quot;ma.L1&quot;</span><span class="s1">: </span><span class="s4">0.37879692</span><span class="s1">}</span><span class="s0">,  </span><span class="s3"># fix ma</span>
        <span class="s1">{</span><span class="s2">&quot;ar.L1&quot;</span><span class="s1">: </span><span class="s4">0.69607715</span><span class="s0">, </span><span class="s2">&quot;ma.L1&quot;</span><span class="s1">: </span><span class="s4">0.37879692</span><span class="s1">}</span><span class="s0">,  </span><span class="s3"># no free params</span>
    <span class="s1">]</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_itsmr_with_fixed_params(fixed_params):</span>
    <span class="s3"># This test is a variation of test_itsmr where we fix 1 or more parameters</span>
    <span class="s3"># for Example 5.1.7 in Brockwell and Davis (2016) and check that free</span>
    <span class="s3"># parameters are still correct'.</span>

    <span class="s1">endog = lake.copy()</span>
    <span class="s1">hr</span><span class="s0">, </span><span class="s1">_ = hannan_rissanen(</span>
        <span class="s1">endog</span><span class="s0">, </span><span class="s1">ar_order=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">ma_order=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">demean=</span><span class="s0">True,</span>
        <span class="s1">initial_ar_order=</span><span class="s4">22</span><span class="s0">, </span><span class="s1">unbiased=</span><span class="s0">False,</span>
        <span class="s1">fixed_params=fixed_params</span>
    <span class="s1">)</span>

    <span class="s1">assert_allclose(hr.ar_params</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0.69607715</span><span class="s1">]</span><span class="s0">, </span><span class="s1">atol=</span><span class="s4">1e-4</span><span class="s1">)</span>
    <span class="s1">assert_allclose(hr.ma_params</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0.3787969217</span><span class="s1">]</span><span class="s0">, </span><span class="s1">atol=</span><span class="s4">1e-4</span><span class="s1">)</span>

    <span class="s3"># Because our fast implementation of the innovations algorithm does not</span>
    <span class="s3"># allow for non-stationary processes, the estimate of the variance returned</span>
    <span class="s3"># by `hannan_rissanen` is based on the residuals from the least-squares</span>
    <span class="s3"># regression, rather than (as reported by BD) based on the innovations</span>
    <span class="s3"># algorithm output. Since the estimates here do correspond to a stationary</span>
    <span class="s3"># series, we can compute the innovations variance manually to check</span>
    <span class="s3"># against BD.</span>
    <span class="s1">u</span><span class="s0">, </span><span class="s1">v = arma_innovations(endog - endog.mean()</span><span class="s0">, </span><span class="s1">hr.ar_params</span><span class="s0">, </span><span class="s1">hr.ma_params</span><span class="s0">,</span>
                            <span class="s1">sigma2=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">tmp = u / v**</span><span class="s4">0.5</span>
    <span class="s1">assert_allclose(np.inner(tmp</span><span class="s0">, </span><span class="s1">tmp) / len(u)</span><span class="s0">, </span><span class="s4">0.4773580109</span><span class="s0">, </span><span class="s1">atol=</span><span class="s4">1e-4</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_unbiased_error_with_fixed_params():</span>
    <span class="s3"># unbiased=True with fixed params should throw NotImplementedError for now</span>
    <span class="s1">endog = np.random.normal(size=</span><span class="s4">1000</span><span class="s1">)</span>
    <span class="s1">msg = (</span>
        <span class="s2">&quot;Third step of Hannan-Rissanen estimation to remove parameter bias&quot;</span>
        <span class="s2">&quot; is not yet implemented for the case with fixed parameters.&quot;</span>
    <span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">hannan_rissanen(endog</span><span class="s0">, </span><span class="s1">ar_order=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">ma_order=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">unbiased=</span><span class="s0">True,</span>
                        <span class="s1">fixed_params={</span><span class="s2">&quot;ar.L1&quot;</span><span class="s1">: </span><span class="s4">0</span><span class="s1">})</span>


<span class="s0">def </span><span class="s1">test_set_default_unbiased_with_fixed_params():</span>
    <span class="s3"># setting unbiased=None with fixed params should yield the exact same</span>
    <span class="s3"># results as setting unbiased=False</span>
    <span class="s1">endog = np.random.normal(size=</span><span class="s4">1000</span><span class="s1">)</span>
    <span class="s3"># unbiased=None</span>
    <span class="s1">p_1</span><span class="s0">, </span><span class="s1">other_results_2 = hannan_rissanen(</span>
        <span class="s1">endog</span><span class="s0">, </span><span class="s1">ar_order=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">ma_order=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">unbiased=</span><span class="s0">None,</span>
        <span class="s1">fixed_params={</span><span class="s2">&quot;ar.L1&quot;</span><span class="s1">: </span><span class="s4">0.69607715</span><span class="s1">}</span>
    <span class="s1">)</span>
    <span class="s3"># unbiased=False</span>
    <span class="s1">p_2</span><span class="s0">, </span><span class="s1">other_results_1 = hannan_rissanen(</span>
        <span class="s1">endog</span><span class="s0">, </span><span class="s1">ar_order=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">ma_order=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">unbiased=</span><span class="s0">False,</span>
        <span class="s1">fixed_params={</span><span class="s2">&quot;ar.L1&quot;</span><span class="s1">: </span><span class="s4">0.69607715</span><span class="s1">}</span>
    <span class="s1">)</span>

    <span class="s1">np.testing.assert_array_equal(p_1.ar_params</span><span class="s0">, </span><span class="s1">p_2.ar_params)</span>
    <span class="s1">np.testing.assert_array_equal(p_1.ma_params</span><span class="s0">, </span><span class="s1">p_2.ma_params)</span>
    <span class="s0">assert </span><span class="s1">p_1.sigma2 == p_2.sigma2</span>
    <span class="s1">np.testing.assert_array_equal(other_results_1.resid</span><span class="s0">, </span><span class="s1">other_results_2.resid)</span>
</pre>
</body>
</html>