<html>
<head>
<title>test_gmm.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_gmm.py</font>
</center></td></tr></table>
<pre><span class="s0"># -*- coding: utf-8 -*-</span>
<span class="s2">&quot;&quot;&quot; 
 
Created on Fri Oct 04 13:19:01 2013 
 
Author: Josef Perktold 
&quot;&quot;&quot;</span>
<span class="s3">from </span><span class="s1">statsmodels.compat.python </span><span class="s3">import </span><span class="s1">lrange</span><span class="s3">, </span><span class="s1">lmap</span>

<span class="s3">import </span><span class="s1">os</span>
<span class="s3">import </span><span class="s1">copy</span>

<span class="s3">import </span><span class="s1">pytest</span>
<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">from </span><span class="s1">numpy.testing </span><span class="s3">import </span><span class="s1">assert_allclose</span><span class="s3">, </span><span class="s1">assert_equal</span>
<span class="s3">import </span><span class="s1">pandas </span><span class="s3">as </span><span class="s1">pd</span>

<span class="s3">from </span><span class="s1">statsmodels.tools.tools </span><span class="s3">import </span><span class="s1">add_constant</span>
<span class="s3">from </span><span class="s1">statsmodels.regression.linear_model </span><span class="s3">import </span><span class="s1">OLS</span>
<span class="s3">import </span><span class="s1">statsmodels.sandbox.regression.gmm </span><span class="s3">as </span><span class="s1">gmm</span>


<span class="s3">def </span><span class="s1">get_griliches76_data():</span>
    <span class="s1">curdir = os.path.split(__file__)[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">path = os.path.join(curdir</span><span class="s3">, </span><span class="s5">'griliches76.dta'</span><span class="s1">)</span>
    <span class="s1">griliches76_data = pd.read_stata(path)</span>

    <span class="s0"># create year dummies</span>
    <span class="s1">years = griliches76_data[</span><span class="s5">'year'</span><span class="s1">].unique()</span>
    <span class="s1">N = griliches76_data.shape[</span><span class="s4">0</span><span class="s1">]</span>

    <span class="s3">for </span><span class="s1">yr </span><span class="s3">in </span><span class="s1">years:</span>
        <span class="s1">griliches76_data[</span><span class="s5">'D_%i' </span><span class="s1">% yr] = np.zeros(N)</span>
        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(N):</span>
            <span class="s3">if </span><span class="s1">griliches76_data.loc[griliches76_data.index[i]</span><span class="s3">, </span><span class="s5">'year'</span><span class="s1">] == yr:</span>
                <span class="s1">griliches76_data.loc[griliches76_data.index[i]</span><span class="s3">, </span><span class="s5">'D_%i' </span><span class="s1">% yr] = </span><span class="s4">1</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">pass</span>

    <span class="s1">griliches76_data[</span><span class="s5">'const'</span><span class="s1">] = </span><span class="s4">1</span>

    <span class="s1">X = add_constant(griliches76_data[[</span><span class="s5">'s'</span><span class="s3">, </span><span class="s5">'iq'</span><span class="s3">, </span><span class="s5">'expr'</span><span class="s3">, </span><span class="s5">'tenure'</span><span class="s3">, </span><span class="s5">'rns'</span><span class="s3">,</span>
                                       <span class="s5">'smsa'</span><span class="s3">, </span><span class="s5">'D_67'</span><span class="s3">, </span><span class="s5">'D_68'</span><span class="s3">, </span><span class="s5">'D_69'</span><span class="s3">, </span><span class="s5">'D_70'</span><span class="s3">,</span>
                                       <span class="s5">'D_71'</span><span class="s3">, </span><span class="s5">'D_73'</span><span class="s1">]]</span><span class="s3">,</span>
                                       <span class="s0">#prepend=False)  # for Stata comparison</span>
                                       <span class="s1">prepend=</span><span class="s3">True</span><span class="s1">)  </span><span class="s0"># for R comparison</span>

    <span class="s1">Z = add_constant(griliches76_data[[</span><span class="s5">'expr'</span><span class="s3">, </span><span class="s5">'tenure'</span><span class="s3">, </span><span class="s5">'rns'</span><span class="s3">, </span><span class="s5">'smsa'</span><span class="s3">, </span><span class="s1">\</span>
                                       <span class="s5">'D_67'</span><span class="s3">, </span><span class="s5">'D_68'</span><span class="s3">, </span><span class="s5">'D_69'</span><span class="s3">, </span><span class="s5">'D_70'</span><span class="s3">, </span><span class="s5">'D_71'</span><span class="s3">,</span>
                                       <span class="s5">'D_73'</span><span class="s3">, </span><span class="s5">'med'</span><span class="s3">, </span><span class="s5">'kww'</span><span class="s3">, </span><span class="s5">'age'</span><span class="s3">, </span><span class="s5">'mrt'</span><span class="s1">]])</span>
    <span class="s1">Y = griliches76_data[</span><span class="s5">'lw'</span><span class="s1">]</span>

    <span class="s3">return </span><span class="s1">Y</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">Z</span>

<span class="s0"># use module global to load only once</span>
<span class="s1">yg_df</span><span class="s3">, </span><span class="s1">xg_df</span><span class="s3">, </span><span class="s1">zg_df = get_griliches76_data()</span>

<span class="s1">endog = np.asarray(yg_df</span><span class="s3">, </span><span class="s1">dtype=float)  </span><span class="s0"># TODO: why is yg_df float32</span>
<span class="s1">exog</span><span class="s3">, </span><span class="s1">instrument = lmap(np.asarray</span><span class="s3">, </span><span class="s1">[xg_df</span><span class="s3">, </span><span class="s1">zg_df])</span>

<span class="s3">assert </span><span class="s1">exog.dtype == np.float64</span>
<span class="s3">assert </span><span class="s1">instrument.dtype == np.float64</span>


<span class="s0"># from R</span>
<span class="s0">#-----------------</span>
<span class="s1">varnames = np.array([</span><span class="s5">&quot;(Intercept)&quot;</span><span class="s3">, </span><span class="s5">&quot;s&quot;</span><span class="s3">, </span><span class="s5">&quot;iq&quot;</span><span class="s3">, </span><span class="s5">&quot;expr&quot;</span><span class="s3">, </span><span class="s5">&quot;tenure&quot;</span><span class="s3">, </span><span class="s5">&quot;rns&quot;</span><span class="s3">, </span><span class="s5">&quot;smsa&quot;</span><span class="s3">, </span><span class="s5">&quot;D_67&quot;</span><span class="s3">, </span><span class="s5">&quot;D_68&quot;</span><span class="s3">, </span><span class="s5">&quot;D_69&quot;</span><span class="s3">, </span><span class="s5">&quot;D_70&quot;</span><span class="s3">,</span>
       <span class="s5">&quot;D_71&quot;</span><span class="s3">, </span><span class="s5">&quot;D_73&quot;</span><span class="s1">])</span>
<span class="s1">params = np.array([ </span><span class="s4">4.03350989</span><span class="s3">,  </span><span class="s4">0.17242531</span><span class="s3">, </span><span class="s1">-</span><span class="s4">0.00909883</span><span class="s3">,  </span><span class="s4">0.04928949</span><span class="s3">,  </span><span class="s4">0.04221709</span><span class="s3">,</span>
       <span class="s1">-</span><span class="s4">0.10179345</span><span class="s3">,  </span><span class="s4">0.12611095</span><span class="s3">, </span><span class="s1">-</span><span class="s4">0.05961711</span><span class="s3">,  </span><span class="s4">0.04867956</span><span class="s3">,  </span><span class="s4">0.15281763</span><span class="s3">,</span>
        <span class="s4">0.17443605</span><span class="s3">,  </span><span class="s4">0.09166597</span><span class="s3">,  </span><span class="s4">0.09323977</span><span class="s1">])</span>
<span class="s1">bse = np.array([ </span><span class="s4">0.31816162</span><span class="s3">,  </span><span class="s4">0.02091823</span><span class="s3">,  </span><span class="s4">0.00474527</span><span class="s3">,  </span><span class="s4">0.00822543</span><span class="s3">,  </span><span class="s4">0.00891969</span><span class="s3">,</span>
        <span class="s4">0.03447337</span><span class="s3">,  </span><span class="s4">0.03119615</span><span class="s3">,  </span><span class="s4">0.05577582</span><span class="s3">,  </span><span class="s4">0.05246796</span><span class="s3">,  </span><span class="s4">0.05201092</span><span class="s3">,</span>
        <span class="s4">0.06027671</span><span class="s3">,  </span><span class="s4">0.05461436</span><span class="s3">,  </span><span class="s4">0.05767865</span><span class="s1">])</span>
<span class="s1">tvalues = np.array([ </span><span class="s4">12.6775501</span><span class="s3">,   </span><span class="s4">8.2428242</span><span class="s3">,  </span><span class="s1">-</span><span class="s4">1.9174531</span><span class="s3">,   </span><span class="s4">5.9923305</span><span class="s3">,   </span><span class="s4">4.7330205</span><span class="s3">,</span>
        <span class="s1">-</span><span class="s4">2.9528144</span><span class="s3">,   </span><span class="s4">4.0425165</span><span class="s3">,  </span><span class="s1">-</span><span class="s4">1.0688701</span><span class="s3">,   </span><span class="s4">0.9277959</span><span class="s3">,   </span><span class="s4">2.9381834</span><span class="s3">,</span>
         <span class="s4">2.8939212</span><span class="s3">,   </span><span class="s4">1.6784225</span><span class="s3">,   </span><span class="s4">1.6165385</span><span class="s1">])</span>
<span class="s1">pvalues = np.array([  </span><span class="s4">1.72360000e-33</span><span class="s3">,   </span><span class="s4">7.57025400e-16</span><span class="s3">,   </span><span class="s4">5.55625000e-02</span><span class="s3">,</span>
         <span class="s4">3.21996700e-09</span><span class="s3">,   </span><span class="s4">2.64739100e-06</span><span class="s3">,   </span><span class="s4">3.24794100e-03</span><span class="s3">,</span>
         <span class="s4">5.83809900e-05</span><span class="s3">,   </span><span class="s4">2.85474400e-01</span><span class="s3">,   </span><span class="s4">3.53813900e-01</span><span class="s3">,</span>
         <span class="s4">3.40336100e-03</span><span class="s3">,   </span><span class="s4">3.91575100e-03</span><span class="s3">,   </span><span class="s4">9.36840200e-02</span><span class="s3">,</span>
         <span class="s4">1.06401300e-01</span><span class="s1">])</span>
    <span class="s0">#-----------------</span>

<span class="s3">def </span><span class="s1">test_iv2sls_r():</span>

    <span class="s1">mod = gmm.IV2SLS(endog</span><span class="s3">, </span><span class="s1">exog</span><span class="s3">, </span><span class="s1">instrument)</span>
    <span class="s1">res = mod.fit()</span>

    <span class="s0"># print(res.params)</span>
    <span class="s0"># print(res.params - params)</span>

    <span class="s1">n</span><span class="s3">, </span><span class="s1">k = exog.shape</span>

    <span class="s1">assert_allclose(res.params</span><span class="s3">, </span><span class="s1">params</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">1e-7</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">1e-9</span><span class="s1">)</span>
    <span class="s0"># TODO: check df correction</span>
    <span class="s0">#assert_allclose(res.bse * np.sqrt((n - k) / (n - k - 1.)), bse,</span>
    <span class="s1">assert_allclose(res.bse</span><span class="s3">, </span><span class="s1">bse</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">3e-7</span><span class="s1">)</span>

    <span class="s0"># GH 3849</span>
    <span class="s3">assert not </span><span class="s1">hasattr(mod</span><span class="s3">, </span><span class="s5">'_results'</span><span class="s1">)</span>



<span class="s3">def </span><span class="s1">test_ivgmm0_r():</span>
    <span class="s1">n</span><span class="s3">, </span><span class="s1">k = exog.shape</span>
    <span class="s1">nobs</span><span class="s3">, </span><span class="s1">k_instr = instrument.shape</span>

    <span class="s1">w0inv = np.dot(instrument.T</span><span class="s3">, </span><span class="s1">instrument) / nobs</span>
    <span class="s1">w0 = np.linalg.inv(w0inv)</span>

    <span class="s1">mod = gmm.IVGMM(endog</span><span class="s3">, </span><span class="s1">exog</span><span class="s3">, </span><span class="s1">instrument)</span>
    <span class="s1">res = mod.fit(np.ones(exog.shape[</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">float)</span><span class="s3">, </span><span class="s1">maxiter=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">inv_weights=w0inv</span><span class="s3">,</span>
                  <span class="s1">optim_method=</span><span class="s5">'bfgs'</span><span class="s3">,</span>
                  <span class="s1">optim_args={</span><span class="s5">'gtol'</span><span class="s1">:</span><span class="s4">1e-8</span><span class="s3">, </span><span class="s5">'disp'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">})</span>


    <span class="s1">assert_allclose(res.params</span><span class="s3">, </span><span class="s1">params</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">1e-4</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">1e-4</span><span class="s1">)</span>
    <span class="s0"># TODO : res.bse and bse are not the same, rtol=0.09 is large in this case</span>
    <span class="s0">#res.bse is still robust?, bse is not a sandwich ?</span>
    <span class="s1">assert_allclose(res.bse</span><span class="s3">, </span><span class="s1">bse</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">0.09</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">0</span><span class="s1">)</span>

    <span class="s1">score = res.model.score(res.params</span><span class="s3">, </span><span class="s1">w0)</span>
    <span class="s1">assert_allclose(score</span><span class="s3">, </span><span class="s1">np.zeros(score.shape)</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">5e-6</span><span class="s1">) </span><span class="s0"># atol=1e-8) ??</span>


<span class="s3">def </span><span class="s1">test_ivgmm1_stata():</span>

    <span class="s0"># copied constant to the beginning</span>
    <span class="s1">params_stata = np.array(</span>
          <span class="s1">[ </span><span class="s4">4.0335099 </span><span class="s3">,  </span><span class="s4">0.17242531</span><span class="s3">, </span><span class="s1">-</span><span class="s4">0.00909883</span><span class="s3">,  </span><span class="s4">0.04928949</span><span class="s3">,  </span><span class="s4">0.04221709</span><span class="s3">,</span>
           <span class="s1">-</span><span class="s4">0.10179345</span><span class="s3">,  </span><span class="s4">0.12611095</span><span class="s3">, </span><span class="s1">-</span><span class="s4">0.05961711</span><span class="s3">,  </span><span class="s4">0.04867956</span><span class="s3">,  </span><span class="s4">0.15281763</span><span class="s3">,</span>
            <span class="s4">0.17443605</span><span class="s3">,  </span><span class="s4">0.09166597</span><span class="s3">,  </span><span class="s4">0.09323976</span><span class="s1">])</span>

    <span class="s0"># robust bse with gmm onestep</span>
    <span class="s1">bse_stata = np.array(</span>
          <span class="s1">[ </span><span class="s4">0.33503289</span><span class="s3">,  </span><span class="s4">0.02073947</span><span class="s3">,  </span><span class="s4">0.00488624</span><span class="s3">,  </span><span class="s4">0.0080498 </span><span class="s3">,  </span><span class="s4">0.00946363</span><span class="s3">,</span>
            <span class="s4">0.03371053</span><span class="s3">,  </span><span class="s4">0.03081138</span><span class="s3">,  </span><span class="s4">0.05171372</span><span class="s3">,  </span><span class="s4">0.04981322</span><span class="s3">,  </span><span class="s4">0.0479285 </span><span class="s3">,</span>
            <span class="s4">0.06112515</span><span class="s3">,  </span><span class="s4">0.0554618 </span><span class="s3">,  </span><span class="s4">0.06084901</span><span class="s1">])</span>

    <span class="s1">n</span><span class="s3">, </span><span class="s1">k = exog.shape</span>
    <span class="s1">nobs</span><span class="s3">, </span><span class="s1">k_instr = instrument.shape</span>

    <span class="s1">w0inv = np.dot(instrument.T</span><span class="s3">, </span><span class="s1">instrument) / nobs</span>
    <span class="s1">w0 = np.linalg.inv(w0inv)</span>
    <span class="s1">start = OLS(endog</span><span class="s3">, </span><span class="s1">exog).fit().params</span>

    <span class="s1">mod = gmm.IVGMM(endog</span><span class="s3">, </span><span class="s1">exog</span><span class="s3">, </span><span class="s1">instrument)</span>
    <span class="s1">res = mod.fit(start</span><span class="s3">, </span><span class="s1">maxiter=</span><span class="s4">1</span><span class="s3">, </span><span class="s1">inv_weights=w0inv</span><span class="s3">, </span><span class="s1">optim_method=</span><span class="s5">'bfgs'</span><span class="s3">, </span><span class="s1">optim_args={</span><span class="s5">'gtol'</span><span class="s1">:</span><span class="s4">1e-6</span><span class="s3">, </span><span class="s5">'disp'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">})</span>


<span class="s0"># move constant to end for Stata</span>
<span class="s1">idx = lrange(len(params))</span>
<span class="s1">idx = idx[</span><span class="s4">1</span><span class="s1">:] + idx[:</span><span class="s4">1</span><span class="s1">]</span>
<span class="s1">exog_st = exog[:</span><span class="s3">, </span><span class="s1">idx]</span>


<span class="s3">class </span><span class="s1">TestGMMOLS:</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">exog = exog_st  </span><span class="s0"># with const at end</span>
        <span class="s1">res_ols = OLS(endog</span><span class="s3">, </span><span class="s1">exog).fit()</span>

        <span class="s0">#  use exog as instrument</span>
        <span class="s1">nobs</span><span class="s3">, </span><span class="s1">k_instr = exog.shape</span>
        <span class="s1">w0inv = np.dot(exog.T</span><span class="s3">, </span><span class="s1">exog) / nobs</span>
        <span class="s0">#w0 = np.linalg.inv(w0inv)</span>

        <span class="s1">mod = gmm.IVGMM(endog</span><span class="s3">, </span><span class="s1">exog</span><span class="s3">, </span><span class="s1">exog)</span>
        <span class="s1">res = mod.fit(np.ones(exog.shape[</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">float)</span><span class="s3">, </span><span class="s1">maxiter=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">inv_weights=w0inv</span><span class="s3">,</span>
                        <span class="s1">optim_method=</span><span class="s5">'bfgs'</span><span class="s3">, </span><span class="s1">optim_args={</span><span class="s5">'gtol'</span><span class="s1">:</span><span class="s4">1e-6</span><span class="s3">, </span><span class="s5">'disp'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">})</span>

        <span class="s1">cls.res1 = res</span>
        <span class="s1">cls.res2 = res_ols</span>


    <span class="s3">def </span><span class="s1">test_basic(self):</span>
        <span class="s1">res1</span><span class="s3">, </span><span class="s1">res2 = self.res1</span><span class="s3">, </span><span class="s1">self.res2</span>
        <span class="s0"># test both absolute and relative difference</span>
        <span class="s1">assert_allclose(res1.params</span><span class="s3">, </span><span class="s1">res2.params</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">5e-4</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res1.params</span><span class="s3">, </span><span class="s1">res2.params</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">1e-5</span><span class="s1">)</span>

        <span class="s1">n = res1.model.exog.shape[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">dffac = </span><span class="s4">1</span><span class="s0">#np.sqrt((n - 1.) / n)   # currently different df in cov calculation</span>
        <span class="s1">assert_allclose(res1.bse * dffac</span><span class="s3">, </span><span class="s1">res2.HC0_se</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">5e-6</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res1.bse * dffac</span><span class="s3">, </span><span class="s1">res2.HC0_se</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">1e-7</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.xfail(reason=</span><span class="s5">&quot;Not asserting anything meaningful&quot;</span><span class="s3">,</span>
                       <span class="s1">raises=NotImplementedError</span><span class="s3">, </span><span class="s1">strict=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s3">def </span><span class="s1">test_other(self):</span>
        <span class="s1">res1</span><span class="s3">, </span><span class="s1">res2 = self.res1</span><span class="s3">, </span><span class="s1">self.res2</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span>



<span class="s3">class </span><span class="s1">CheckGMM:</span>

    <span class="s1">params_tol = [</span><span class="s4">5e-6</span><span class="s3">, </span><span class="s4">5e-6</span><span class="s1">]</span>
    <span class="s1">bse_tol = [</span><span class="s4">5e-7</span><span class="s3">, </span><span class="s4">5e-7</span><span class="s1">]</span>

    <span class="s3">def </span><span class="s1">test_basic(self):</span>
        <span class="s1">res1</span><span class="s3">, </span><span class="s1">res2 = self.res1</span><span class="s3">, </span><span class="s1">self.res2</span>
        <span class="s0"># test both absolute and relative difference</span>
        <span class="s1">rtol</span><span class="s3">,  </span><span class="s1">atol = self.params_tol</span>
        <span class="s1">assert_allclose(res1.params</span><span class="s3">, </span><span class="s1">res2.params</span><span class="s3">, </span><span class="s1">rtol=rtol</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res1.params</span><span class="s3">, </span><span class="s1">res2.params</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">atol=atol)</span>

        <span class="s1">n = res1.model.exog.shape[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">dffac = </span><span class="s4">1 </span><span class="s0">#np.sqrt((n - 1.) / n)   # currently different df in cov calculation</span>
        <span class="s1">rtol</span><span class="s3">,  </span><span class="s1">atol = self.bse_tol</span>
        <span class="s1">assert_allclose(res1.bse * dffac</span><span class="s3">, </span><span class="s1">res2.bse</span><span class="s3">, </span><span class="s1">rtol=rtol</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res1.bse * dffac</span><span class="s3">, </span><span class="s1">res2.bse</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">atol=atol)</span>

    <span class="s3">def </span><span class="s1">test_other(self):</span>
        <span class="s0"># TODO: separate Q and J tests</span>
        <span class="s1">res1</span><span class="s3">, </span><span class="s1">res2 = self.res1</span><span class="s3">, </span><span class="s1">self.res2</span>
        <span class="s1">assert_allclose(res1.q</span><span class="s3">, </span><span class="s1">res2.Q</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">5e-6</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res1.jval</span><span class="s3">, </span><span class="s1">res2.J</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">5e-5</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">0</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_hypothesis(self):</span>
        <span class="s1">res1</span><span class="s3">, </span><span class="s1">res2 = self.res1</span><span class="s3">, </span><span class="s1">self.res2</span>
        <span class="s1">restriction = np.eye(len(res1.params))</span>
        <span class="s1">res_t = res1.t_test(restriction)</span>
        <span class="s1">assert_allclose(res_t.tvalue</span><span class="s3">, </span><span class="s1">res1.tvalues</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">1e-12</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res_t.pvalue</span><span class="s3">, </span><span class="s1">res1.pvalues</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">1e-12</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">rtol</span><span class="s3">,  </span><span class="s1">atol = self.bse_tol</span>
        <span class="s1">assert_allclose(res_t.tvalue</span><span class="s3">, </span><span class="s1">res2.tvalues</span><span class="s3">, </span><span class="s1">rtol=rtol*</span><span class="s4">10</span><span class="s3">, </span><span class="s1">atol=atol)</span>
        <span class="s1">assert_allclose(res_t.pvalue</span><span class="s3">, </span><span class="s1">res2.pvalues</span><span class="s3">, </span><span class="s1">rtol=rtol*</span><span class="s4">10</span><span class="s3">, </span><span class="s1">atol=atol)</span>

        <span class="s1">res_f = res1.f_test(restriction[:-</span><span class="s4">1</span><span class="s1">]) </span><span class="s0"># without constant</span>
        <span class="s0"># comparison with fvalue is not possible, those are not defined</span>
        <span class="s0"># assert_allclose(res_f.fvalue, res1.fvalue, rtol=1e-12, atol=0)</span>
        <span class="s0"># assert_allclose(res_f.pvalue, res1.f_pvalue, rtol=1e-12, atol=0)</span>
        <span class="s0"># assert_allclose(res_f.fvalue, res2.F, rtol=1e-10, atol=0)</span>
        <span class="s0"># assert_allclose(res_f.pvalue, res2.Fp, rtol=1e-08, atol=0)</span>

        <span class="s0"># Smoke test for Wald</span>
        <span class="s1">res_wald = res1.wald_test(restriction[:-</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">scalar=</span><span class="s3">True</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.smoke</span>
    <span class="s3">def </span><span class="s1">test_summary(self):</span>
        <span class="s1">res1 = self.res1</span>
        <span class="s1">summ = res1.summary()</span>
        <span class="s0"># len + 1 is for header line</span>
        <span class="s1">assert_equal(len(summ.tables[</span><span class="s4">1</span><span class="s1">])</span><span class="s3">, </span><span class="s1">len(res1.params) + </span><span class="s4">1</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_use_t(self):</span>
        <span class="s0"># Copy to avoid cache</span>
        <span class="s1">res1 = copy.deepcopy(self.res1)</span>
        <span class="s1">res1.use_t = </span><span class="s3">True</span>
        <span class="s1">summ = res1.summary()</span>
        <span class="s3">assert </span><span class="s5">'P&gt;|t|' </span><span class="s3">in </span><span class="s1">str(summ)</span>
        <span class="s3">assert </span><span class="s5">'P&gt;|z|' </span><span class="s3">not in </span><span class="s1">str(summ)</span>


<span class="s3">class </span><span class="s1">TestGMMSt1(CheckGMM):</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">setup_class(cls):</span>
        <span class="s0">#cls.bse_tol = [5e-7, 5e-7]</span>
        <span class="s0"># compare to Stata default options, iterative GMM</span>
        <span class="s1">exog = exog_st  </span><span class="s0"># with const at end</span>
        <span class="s1">start = OLS(endog</span><span class="s3">, </span><span class="s1">exog).fit().params</span>
        <span class="s1">nobs</span><span class="s3">, </span><span class="s1">k_instr = instrument.shape</span>
        <span class="s1">w0inv = np.dot(instrument.T</span><span class="s3">, </span><span class="s1">instrument) / nobs</span>
        <span class="s0">#w0 = np.linalg.inv(w0inv)</span>

        <span class="s1">mod = gmm.IVGMM(endog</span><span class="s3">, </span><span class="s1">exog</span><span class="s3">, </span><span class="s1">instrument)</span>
        <span class="s1">res10 = mod.fit(start</span><span class="s3">, </span><span class="s1">maxiter=</span><span class="s4">10</span><span class="s3">, </span><span class="s1">inv_weights=w0inv</span><span class="s3">,</span>
                        <span class="s1">optim_method=</span><span class="s5">'bfgs'</span><span class="s3">, </span><span class="s1">optim_args={</span><span class="s5">'gtol'</span><span class="s1">:</span><span class="s4">1e-6</span><span class="s3">, </span><span class="s5">'disp'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">}</span><span class="s3">,</span>
                        <span class="s1">wargs={</span><span class="s5">'centered'</span><span class="s1">:</span><span class="s3">False</span><span class="s1">})</span>
        <span class="s1">cls.res1 = res10</span>

        <span class="s3">from </span><span class="s1">.results_gmm_griliches_iter </span><span class="s3">import </span><span class="s1">results</span>
        <span class="s1">cls.res2 = results</span>

<span class="s3">class </span><span class="s1">TestGMMStTwostep(CheckGMM):</span>
    <span class="s0">#compares has_optimal_weights=True with Stata's has_optimal_weights=False</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">setup_class(cls):</span>
        <span class="s0"># compare to Stata default options, twostep GMM</span>
        <span class="s1">cls.params_tol = [</span><span class="s4">5e-5</span><span class="s3">, </span><span class="s4">5e-6</span><span class="s1">]</span>
        <span class="s1">cls.bse_tol = [</span><span class="s4">5e-6</span><span class="s3">, </span><span class="s4">5e-7</span><span class="s1">]</span>
        <span class="s1">exog = exog_st  </span><span class="s0"># with const at end</span>
        <span class="s1">start = OLS(endog</span><span class="s3">, </span><span class="s1">exog).fit().params</span>
        <span class="s1">nobs</span><span class="s3">, </span><span class="s1">k_instr = instrument.shape</span>
        <span class="s1">w0inv = np.dot(instrument.T</span><span class="s3">, </span><span class="s1">instrument) / nobs</span>
        <span class="s0">#w0 = np.linalg.inv(w0inv)</span>

        <span class="s1">mod = gmm.IVGMM(endog</span><span class="s3">, </span><span class="s1">exog</span><span class="s3">, </span><span class="s1">instrument)</span>
        <span class="s1">res10 = mod.fit(start</span><span class="s3">, </span><span class="s1">maxiter=</span><span class="s4">2</span><span class="s3">, </span><span class="s1">inv_weights=w0inv</span><span class="s3">,</span>
                        <span class="s1">optim_method=</span><span class="s5">'bfgs'</span><span class="s3">, </span><span class="s1">optim_args={</span><span class="s5">'gtol'</span><span class="s1">:</span><span class="s4">1e-6</span><span class="s3">, </span><span class="s5">'disp'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">}</span><span class="s3">,</span>
                        <span class="s1">wargs={</span><span class="s5">'centered'</span><span class="s1">:</span><span class="s3">False</span><span class="s1">})</span>
        <span class="s1">cls.res1 = res10</span>

        <span class="s3">from </span><span class="s1">.results_gmm_griliches </span><span class="s3">import </span><span class="s1">results_twostep </span><span class="s3">as </span><span class="s1">results</span>
        <span class="s1">cls.res2 = results</span>


<span class="s3">class </span><span class="s1">TestGMMStTwostepNO(CheckGMM):</span>
    <span class="s0">#with Stata default `has_optimal_weights=False`</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">setup_class(cls):</span>
        <span class="s0"># compare to Stata default options, twostep GMM</span>
        <span class="s1">cls.params_tol = [</span><span class="s4">5e-5</span><span class="s3">, </span><span class="s4">5e-6</span><span class="s1">]</span>
        <span class="s1">cls.bse_tol = [</span><span class="s4">1e-6</span><span class="s3">, </span><span class="s4">5e-5</span><span class="s1">]</span>
        <span class="s1">exog = exog_st  </span><span class="s0"># with const at end</span>
        <span class="s1">start = OLS(endog</span><span class="s3">, </span><span class="s1">exog).fit().params</span>
        <span class="s1">nobs</span><span class="s3">, </span><span class="s1">k_instr = instrument.shape</span>
        <span class="s1">w0inv = np.dot(instrument.T</span><span class="s3">, </span><span class="s1">instrument) / nobs</span>
        <span class="s0">#w0 = np.linalg.inv(w0inv)</span>

        <span class="s1">mod = gmm.IVGMM(endog</span><span class="s3">, </span><span class="s1">exog</span><span class="s3">, </span><span class="s1">instrument)</span>
        <span class="s1">res10 = mod.fit(start</span><span class="s3">, </span><span class="s1">maxiter=</span><span class="s4">2</span><span class="s3">, </span><span class="s1">inv_weights=w0inv</span><span class="s3">,</span>
                        <span class="s1">optim_method=</span><span class="s5">'bfgs'</span><span class="s3">, </span><span class="s1">optim_args={</span><span class="s5">'gtol'</span><span class="s1">:</span><span class="s4">1e-6</span><span class="s3">, </span><span class="s5">'disp'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">}</span><span class="s3">,</span>
                        <span class="s1">wargs={</span><span class="s5">'centered'</span><span class="s1">:</span><span class="s3">False</span><span class="s1">}</span><span class="s3">, </span><span class="s1">has_optimal_weights=</span><span class="s3">False</span><span class="s1">)</span>
        <span class="s1">cls.res1 = res10</span>

        <span class="s3">from </span><span class="s1">.results_gmm_griliches </span><span class="s3">import </span><span class="s1">results_twostep </span><span class="s3">as </span><span class="s1">results</span>
        <span class="s1">cls.res2 = results</span>


<span class="s3">class </span><span class="s1">TestGMMStOnestep(CheckGMM):</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">setup_class(cls):</span>
        <span class="s0"># compare to Stata default options, onestep GMM</span>
        <span class="s1">cls.params_tol = [</span><span class="s4">5e-4</span><span class="s3">, </span><span class="s4">5e-5</span><span class="s1">]</span>
        <span class="s1">cls.bse_tol = [</span><span class="s4">7e-3</span><span class="s3">, </span><span class="s4">5e-4</span><span class="s1">]</span>
        <span class="s1">exog = exog_st  </span><span class="s0"># with const at end</span>
        <span class="s1">start = OLS(endog</span><span class="s3">, </span><span class="s1">exog).fit().params</span>
        <span class="s1">nobs</span><span class="s3">, </span><span class="s1">k_instr = instrument.shape</span>
        <span class="s1">w0inv = np.dot(instrument.T</span><span class="s3">, </span><span class="s1">instrument) / nobs</span>
        <span class="s0">#w0 = np.linalg.inv(w0inv)</span>

        <span class="s1">mod = gmm.IVGMM(endog</span><span class="s3">, </span><span class="s1">exog</span><span class="s3">, </span><span class="s1">instrument)</span>
        <span class="s1">res = mod.fit(start</span><span class="s3">, </span><span class="s1">maxiter=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">inv_weights=w0inv</span><span class="s3">,</span>
                        <span class="s1">optim_method=</span><span class="s5">'bfgs'</span><span class="s3">,</span>
                        <span class="s1">optim_args={</span><span class="s5">'gtol'</span><span class="s1">:</span><span class="s4">1e-6</span><span class="s3">, </span><span class="s5">'disp'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">})</span>
        <span class="s1">cls.res1 = res</span>

        <span class="s3">from </span><span class="s1">.results_gmm_griliches </span><span class="s3">import </span><span class="s1">results_onestep </span><span class="s3">as </span><span class="s1">results</span>
        <span class="s1">cls.res2 = results</span>

    <span class="s3">def </span><span class="s1">test_bse_other(self):</span>
        <span class="s1">res1</span><span class="s3">, </span><span class="s1">res2 = self.res1</span><span class="s3">, </span><span class="s1">self.res2</span>
        <span class="s0"># try other versions for bse,</span>
        <span class="s0"># TODO: next two produce the same as before (looks like)</span>
        <span class="s1">bse = np.sqrt(np.diag((res1._cov_params(has_optimal_weights=</span><span class="s3">False</span><span class="s1">))))</span>
                                            <span class="s0">#weights=res1.weights))))</span>
        <span class="s0"># TODO: does not look different</span>
        <span class="s0">#assert_allclose(res1.bse, res2.bse, rtol=5e-06, atol=0)</span>
        <span class="s0">#nobs = instrument.shape[0]</span>
        <span class="s0">#w0inv = np.dot(instrument.T, instrument) / nobs</span>
        <span class="s1">q = self.res1.model.gmmobjective(self.res1.params</span><span class="s3">, </span><span class="s1">np.linalg.inv(self.res1.weights))</span>
        <span class="s0">#assert_allclose(q, res2.Q, rtol=5e-6, atol=0)</span>

    <span class="s1">@pytest.mark.xfail(reason=</span><span class="s5">&quot;q vs Q comparison fails&quot;</span><span class="s3">,</span>
                       <span class="s1">raises=AssertionError</span><span class="s3">, </span><span class="s1">strict=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s3">def </span><span class="s1">test_other(self):</span>
        <span class="s1">super(TestGMMStOnestep</span><span class="s3">, </span><span class="s1">self).test_other()</span>


<span class="s3">class </span><span class="s1">TestGMMStOnestepNO(CheckGMM):</span>
    <span class="s0"># matches Stats's defaults wargs={'centered':False}, has_optimal_weights=False</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">setup_class(cls):</span>
        <span class="s0"># compare to Stata default options, onestep GMM</span>
        <span class="s1">cls.params_tol = [</span><span class="s4">1e-5</span><span class="s3">, </span><span class="s4">1e-6</span><span class="s1">]</span>
        <span class="s1">cls.bse_tol = [</span><span class="s4">5e-6</span><span class="s3">, </span><span class="s4">5e-7</span><span class="s1">]</span>
        <span class="s1">exog = exog_st  </span><span class="s0"># with const at end</span>
        <span class="s1">start = OLS(endog</span><span class="s3">, </span><span class="s1">exog).fit().params</span>
        <span class="s1">nobs</span><span class="s3">, </span><span class="s1">k_instr = instrument.shape</span>
        <span class="s1">w0inv = np.dot(instrument.T</span><span class="s3">, </span><span class="s1">instrument) / nobs</span>
        <span class="s0">#w0 = np.linalg.inv(w0inv)</span>

        <span class="s1">mod = gmm.IVGMM(endog</span><span class="s3">, </span><span class="s1">exog</span><span class="s3">, </span><span class="s1">instrument)</span>
        <span class="s1">res = mod.fit(start</span><span class="s3">, </span><span class="s1">maxiter=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">inv_weights=w0inv</span><span class="s3">,</span>
                        <span class="s1">optim_method=</span><span class="s5">'bfgs'</span><span class="s3">, </span><span class="s1">optim_args={</span><span class="s5">'gtol'</span><span class="s1">:</span><span class="s4">1e-6</span><span class="s3">, </span><span class="s5">'disp'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">}</span><span class="s3">,</span>
                        <span class="s1">wargs={</span><span class="s5">'centered'</span><span class="s1">:</span><span class="s3">False</span><span class="s1">}</span><span class="s3">, </span><span class="s1">has_optimal_weights=</span><span class="s3">False</span><span class="s1">)</span>
        <span class="s1">cls.res1 = res</span>

        <span class="s3">from </span><span class="s1">.results_gmm_griliches </span><span class="s3">import </span><span class="s1">results_onestep </span><span class="s3">as </span><span class="s1">results</span>
        <span class="s1">cls.res2 = results</span>

    <span class="s1">@pytest.mark.xfail(reason=</span><span class="s5">&quot;q vs Q comparison fails&quot;</span><span class="s3">,</span>
                       <span class="s1">raises=AssertionError</span><span class="s3">, </span><span class="s1">strict=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s3">def </span><span class="s1">test_other(self):</span>
        <span class="s1">super(TestGMMStOnestepNO</span><span class="s3">, </span><span class="s1">self).test_other()</span>


<span class="s3">class </span><span class="s1">TestGMMStOneiter(CheckGMM):</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">setup_class(cls):</span>
        <span class="s0"># compare to Stata default options, onestep GMM</span>
        <span class="s0"># this uses maxiter=1, one iteration in loop</span>
        <span class="s1">cls.params_tol = [</span><span class="s4">5e-4</span><span class="s3">, </span><span class="s4">5e-5</span><span class="s1">]</span>
        <span class="s1">cls.bse_tol = [</span><span class="s4">7e-3</span><span class="s3">, </span><span class="s4">5e-4</span><span class="s1">]</span>
        <span class="s1">exog = exog_st  </span><span class="s0"># with const at end</span>
        <span class="s1">start = OLS(endog</span><span class="s3">, </span><span class="s1">exog).fit().params</span>
        <span class="s1">nobs</span><span class="s3">, </span><span class="s1">k_instr = instrument.shape</span>
        <span class="s1">w0inv = np.dot(instrument.T</span><span class="s3">, </span><span class="s1">instrument) / nobs</span>
        <span class="s0">#w0 = np.linalg.inv(w0inv)</span>

        <span class="s1">mod = gmm.IVGMM(endog</span><span class="s3">, </span><span class="s1">exog</span><span class="s3">, </span><span class="s1">instrument)</span>
        <span class="s1">res = mod.fit(start</span><span class="s3">, </span><span class="s1">maxiter=</span><span class="s4">1</span><span class="s3">, </span><span class="s1">inv_weights=w0inv</span><span class="s3">,</span>
                        <span class="s1">optim_method=</span><span class="s5">'bfgs'</span><span class="s3">, </span><span class="s1">optim_args={</span><span class="s5">'gtol'</span><span class="s1">:</span><span class="s4">1e-6</span><span class="s3">, </span><span class="s5">'disp'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">})</span>
        <span class="s1">cls.res1 = res</span>

        <span class="s3">from </span><span class="s1">.results_gmm_griliches </span><span class="s3">import </span><span class="s1">results_onestep </span><span class="s3">as </span><span class="s1">results</span>
        <span class="s1">cls.res2 = results</span>

    <span class="s1">@pytest.mark.xfail(reason=</span><span class="s5">&quot;q vs Q comparison fails&quot;</span><span class="s3">,</span>
                       <span class="s1">raises=AssertionError</span><span class="s3">, </span><span class="s1">strict=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s3">def </span><span class="s1">test_other(self):</span>
        <span class="s1">super(TestGMMStOneiter</span><span class="s3">, </span><span class="s1">self).test_other()</span>

    <span class="s3">def </span><span class="s1">test_bse_other(self):</span>
        <span class="s1">res1</span><span class="s3">, </span><span class="s1">res2 = self.res1</span><span class="s3">, </span><span class="s1">self.res2</span>

        <span class="s1">moms = res1.model.momcond(res1.params)</span>
        <span class="s1">w = res1.model.calc_weightmatrix(moms)</span>
        <span class="s0"># try other versions for bse,</span>
        <span class="s0"># TODO: next two produce the same as before (looks like)</span>
        <span class="s1">bse = np.sqrt(np.diag((res1._cov_params(has_optimal_weights=</span><span class="s3">False,</span>
                                            <span class="s1">weights=res1.weights))))</span>
        <span class="s0"># TODO: does not look different</span>
        <span class="s0">#assert_allclose(res1.bse, res2.bse, rtol=5e-06, atol=0)</span>
        <span class="s1">bse = np.sqrt(np.diag((res1._cov_params(has_optimal_weights=</span><span class="s3">False</span><span class="s1">))))</span>
                                                <span class="s0">#use_weights=True #weights=w</span>
        <span class="s0">#assert_allclose(res1.bse, res2.bse, rtol=5e-06, atol=0)</span>

        <span class="s0">#This does not replicate Stata oneway either</span>
        <span class="s1">nobs = instrument.shape[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">w0inv = np.dot(instrument.T</span><span class="s3">, </span><span class="s1">instrument) / nobs</span>
        <span class="s1">q = self.res1.model.gmmobjective(self.res1.params</span><span class="s3">, </span><span class="s1">w)</span><span class="s0">#self.res1.weights)</span>
        <span class="s0">#assert_allclose(q, res2.Q, rtol=5e-6, atol=0)</span>


<span class="s3">class </span><span class="s1">TestGMMStOneiterNO(CheckGMM):</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">setup_class(cls):</span>
        <span class="s0"># compare to Stata default options, onestep GMM</span>
        <span class="s0"># this uses maxiter=1, one iteration in loop</span>
        <span class="s1">cls.params_tol = [</span><span class="s4">1e-5</span><span class="s3">, </span><span class="s4">1e-6</span><span class="s1">]</span>
        <span class="s1">cls.bse_tol = [</span><span class="s4">5e-6</span><span class="s3">, </span><span class="s4">5e-7</span><span class="s1">]</span>
        <span class="s1">exog = exog_st  </span><span class="s0"># with const at end</span>
        <span class="s1">start = OLS(endog</span><span class="s3">, </span><span class="s1">exog).fit().params</span>
        <span class="s1">nobs</span><span class="s3">, </span><span class="s1">k_instr = instrument.shape</span>
        <span class="s1">w0inv = np.dot(instrument.T</span><span class="s3">, </span><span class="s1">instrument) / nobs</span>
        <span class="s0">#w0 = np.linalg.inv(w0inv)</span>

        <span class="s1">mod = gmm.IVGMM(endog</span><span class="s3">, </span><span class="s1">exog</span><span class="s3">, </span><span class="s1">instrument)</span>
        <span class="s1">res = mod.fit(start</span><span class="s3">, </span><span class="s1">maxiter=</span><span class="s4">1</span><span class="s3">, </span><span class="s1">inv_weights=w0inv</span><span class="s3">,</span>
                        <span class="s1">optim_method=</span><span class="s5">'bfgs'</span><span class="s3">, </span><span class="s1">optim_args={</span><span class="s5">'gtol'</span><span class="s1">:</span><span class="s4">1e-6</span><span class="s3">, </span><span class="s5">'disp'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">}</span><span class="s3">,</span>
                        <span class="s1">wargs={</span><span class="s5">'centered'</span><span class="s1">:</span><span class="s3">False</span><span class="s1">}</span><span class="s3">, </span><span class="s1">has_optimal_weights=</span><span class="s3">False</span><span class="s1">)</span>
        <span class="s1">cls.res1 = res</span>

        <span class="s3">from </span><span class="s1">.results_gmm_griliches </span><span class="s3">import </span><span class="s1">results_onestep </span><span class="s3">as </span><span class="s1">results</span>
        <span class="s1">cls.res2 = results</span>

    <span class="s1">@pytest.mark.xfail(reason=</span><span class="s5">&quot;q vs Q comparison fails&quot;</span><span class="s3">,</span>
                       <span class="s1">raises=AssertionError</span><span class="s3">, </span><span class="s1">strict=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s3">def </span><span class="s1">test_other(self):</span>
        <span class="s1">super(TestGMMStOneiterNO</span><span class="s3">, </span><span class="s1">self).test_other()</span>


<span class="s0">#------------ Crosscheck subclasses</span>

<span class="s3">class </span><span class="s1">TestGMMStOneiterNO_Linear(CheckGMM):</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">setup_class(cls):</span>
        <span class="s0"># compare to Stata default options, onestep GMM</span>
        <span class="s0"># this uses maxiter=1, one iteration in loop</span>
        <span class="s1">cls.params_tol = [</span><span class="s4">5e-9</span><span class="s3">, </span><span class="s4">1e-9</span><span class="s1">]</span>
        <span class="s1">cls.bse_tol = [</span><span class="s4">5e-10</span><span class="s3">, </span><span class="s4">1e-10</span><span class="s1">]</span>
        <span class="s1">exog = exog_st  </span><span class="s0"># with const at end</span>
        <span class="s1">start = OLS(endog</span><span class="s3">, </span><span class="s1">exog).fit().params</span>
        <span class="s1">nobs</span><span class="s3">, </span><span class="s1">k_instr = instrument.shape</span>
        <span class="s1">w0inv = np.dot(instrument.T</span><span class="s3">, </span><span class="s1">instrument) / nobs</span>
        <span class="s0">#w0 = np.linalg.inv(w0inv)</span>

        <span class="s1">mod = gmm.LinearIVGMM(endog</span><span class="s3">, </span><span class="s1">exog</span><span class="s3">, </span><span class="s1">instrument)</span>
        <span class="s1">res = mod.fit(start</span><span class="s3">, </span><span class="s1">maxiter=</span><span class="s4">1</span><span class="s3">, </span><span class="s1">inv_weights=w0inv</span><span class="s3">,</span>
                        <span class="s1">optim_method=</span><span class="s5">'bfgs'</span><span class="s3">, </span><span class="s1">optim_args={</span><span class="s5">'gtol'</span><span class="s1">:</span><span class="s4">1e-8</span><span class="s3">, </span><span class="s5">'disp'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">}</span><span class="s3">,</span>
                        <span class="s1">wargs={</span><span class="s5">'centered'</span><span class="s1">:</span><span class="s3">False</span><span class="s1">}</span><span class="s3">, </span><span class="s1">has_optimal_weights=</span><span class="s3">False</span><span class="s1">)</span>
        <span class="s1">cls.res1 = res</span>

        <span class="s1">mod = gmm.IVGMM(endog</span><span class="s3">, </span><span class="s1">exog</span><span class="s3">, </span><span class="s1">instrument)</span>
        <span class="s1">res = mod.fit(start</span><span class="s3">, </span><span class="s1">maxiter=</span><span class="s4">1</span><span class="s3">, </span><span class="s1">inv_weights=w0inv</span><span class="s3">,</span>
                        <span class="s1">optim_method=</span><span class="s5">'bfgs'</span><span class="s3">, </span><span class="s1">optim_args={</span><span class="s5">'gtol'</span><span class="s1">:</span><span class="s4">1e-6</span><span class="s3">, </span><span class="s5">'disp'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">}</span><span class="s3">,</span>
                        <span class="s1">wargs={</span><span class="s5">'centered'</span><span class="s1">:</span><span class="s3">False</span><span class="s1">}</span><span class="s3">, </span><span class="s1">has_optimal_weights=</span><span class="s3">False</span><span class="s1">)</span>
        <span class="s1">cls.res3 = res</span>

        <span class="s3">from </span><span class="s1">.results_gmm_griliches </span><span class="s3">import </span><span class="s1">results_onestep </span><span class="s3">as </span><span class="s1">results</span>
        <span class="s1">cls.res2 = results</span>

    <span class="s1">@pytest.mark.xfail(reason=</span><span class="s5">&quot;q vs Q comparison fails&quot;</span><span class="s3">,</span>
                       <span class="s1">raises=AssertionError</span><span class="s3">, </span><span class="s1">strict=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s3">def </span><span class="s1">test_other(self):</span>
        <span class="s1">super(TestGMMStOneiterNO_Linear</span><span class="s3">, </span><span class="s1">self).test_other()</span>


<span class="s3">class </span><span class="s1">TestGMMStOneiterNO_Nonlinear(CheckGMM):</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">setup_class(cls):</span>
        <span class="s0"># compare to Stata default options, onestep GMM</span>
        <span class="s0"># this uses maxiter=1, one iteration in loop</span>
        <span class="s1">cls.params_tol = [</span><span class="s4">5e-5</span><span class="s3">, </span><span class="s4">5e-6</span><span class="s1">]</span>
        <span class="s1">cls.bse_tol = [</span><span class="s4">5e-6</span><span class="s3">, </span><span class="s4">1e-1</span><span class="s1">]</span>
        <span class="s1">exog = exog_st  </span><span class="s0"># with const at end</span>
        <span class="s1">start = OLS(endog</span><span class="s3">, </span><span class="s1">exog).fit().params</span>
        <span class="s1">nobs</span><span class="s3">, </span><span class="s1">k_instr = instrument.shape</span>
        <span class="s1">w0inv = np.dot(instrument.T</span><span class="s3">, </span><span class="s1">instrument) / nobs</span>
        <span class="s0">#w0 = np.linalg.inv(w0inv)</span>

        <span class="s3">def </span><span class="s1">func(params</span><span class="s3">, </span><span class="s1">exog):</span>
            <span class="s3">return </span><span class="s1">np.dot(exog</span><span class="s3">, </span><span class="s1">params)</span>

        <span class="s1">mod = gmm.NonlinearIVGMM(endog</span><span class="s3">, </span><span class="s1">exog</span><span class="s3">, </span><span class="s1">instrument</span><span class="s3">, </span><span class="s1">func)</span>
        <span class="s1">res = mod.fit(start</span><span class="s3">, </span><span class="s1">maxiter=</span><span class="s4">1</span><span class="s3">, </span><span class="s1">inv_weights=w0inv</span><span class="s3">,</span>
                        <span class="s1">optim_method=</span><span class="s5">'bfgs'</span><span class="s3">, </span><span class="s1">optim_args={</span><span class="s5">'gtol'</span><span class="s1">:</span><span class="s4">1e-8</span><span class="s3">, </span><span class="s5">'disp'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">}</span><span class="s3">,</span>
                        <span class="s1">wargs={</span><span class="s5">'centered'</span><span class="s1">:</span><span class="s3">False</span><span class="s1">}</span><span class="s3">, </span><span class="s1">has_optimal_weights=</span><span class="s3">False</span><span class="s1">)</span>
        <span class="s1">cls.res1 = res</span>

        <span class="s1">mod = gmm.IVGMM(endog</span><span class="s3">, </span><span class="s1">exog</span><span class="s3">, </span><span class="s1">instrument)</span>
        <span class="s1">res = mod.fit(start</span><span class="s3">, </span><span class="s1">maxiter=</span><span class="s4">1</span><span class="s3">, </span><span class="s1">inv_weights=w0inv</span><span class="s3">,</span>
                        <span class="s1">optim_method=</span><span class="s5">'bfgs'</span><span class="s3">, </span><span class="s1">optim_args={</span><span class="s5">'gtol'</span><span class="s1">:</span><span class="s4">1e-6</span><span class="s3">, </span><span class="s5">'disp'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">}</span><span class="s3">,</span>
                        <span class="s1">wargs={</span><span class="s5">'centered'</span><span class="s1">:</span><span class="s3">False</span><span class="s1">}</span><span class="s3">, </span><span class="s1">has_optimal_weights=</span><span class="s3">False</span><span class="s1">)</span>
        <span class="s1">cls.res3 = res</span>

        <span class="s3">from </span><span class="s1">.results_gmm_griliches </span><span class="s3">import </span><span class="s1">results_onestep </span><span class="s3">as </span><span class="s1">results</span>
        <span class="s1">cls.res2 = results</span>

    <span class="s1">@pytest.mark.xfail(reason=</span><span class="s5">&quot;q vs Q comparison fails&quot;</span><span class="s3">,</span>
                       <span class="s1">raises=AssertionError</span><span class="s3">, </span><span class="s1">strict=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s3">def </span><span class="s1">test_other(self):</span>
        <span class="s1">super(TestGMMStOneiterNO_Nonlinear</span><span class="s3">, </span><span class="s1">self).test_other()</span>

    <span class="s3">def </span><span class="s1">test_score(self):</span>
        <span class="s1">params = self.res1.params * </span><span class="s4">1.1</span>
        <span class="s1">weights = self.res1.weights</span>
        <span class="s1">sc1 = self.res1.model.score(params</span><span class="s3">, </span><span class="s1">weights)</span>
        <span class="s1">sc2 = super(self.res1.model.__class__</span><span class="s3">, </span><span class="s1">self.res1.model).score(params</span><span class="s3">,</span>
                                                                      <span class="s1">weights)</span>
        <span class="s1">assert_allclose(sc1</span><span class="s3">, </span><span class="s1">sc2</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">1e-6</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(sc1</span><span class="s3">, </span><span class="s1">sc2</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">1e-7</span><span class="s1">)</span>

        <span class="s0"># score at optimum</span>
        <span class="s1">sc1 = self.res1.model.score(self.res1.params</span><span class="s3">, </span><span class="s1">weights)</span>
        <span class="s1">assert_allclose(sc1</span><span class="s3">, </span><span class="s1">np.zeros(len(params))</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">1e-8</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">TestGMMStOneiterOLS_Linear(CheckGMM):</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">setup_class(cls):</span>
        <span class="s0"># replicating OLS by GMM - high agreement</span>
        <span class="s1">cls.params_tol = [</span><span class="s4">1e-11</span><span class="s3">, </span><span class="s4">1e-12</span><span class="s1">]</span>
        <span class="s1">cls.bse_tol = [</span><span class="s4">1e-12</span><span class="s3">, </span><span class="s4">1e-12</span><span class="s1">]</span>
        <span class="s1">exog = exog_st  </span><span class="s0"># with const at end</span>
        <span class="s1">res_ols = OLS(endog</span><span class="s3">, </span><span class="s1">exog).fit()</span>
        <span class="s0">#Note: start is irrelevant but required</span>
        <span class="s1">start = np.ones(len(res_ols.params))</span>
        <span class="s1">nobs</span><span class="s3">, </span><span class="s1">k_instr = instrument.shape</span>
        <span class="s1">w0inv = np.dot(exog.T</span><span class="s3">, </span><span class="s1">exog) / nobs</span>
        <span class="s0">#w0 = np.linalg.inv(w0inv)</span>

        <span class="s1">mod = gmm.LinearIVGMM(endog</span><span class="s3">, </span><span class="s1">exog</span><span class="s3">, </span><span class="s1">exog)</span>
        <span class="s1">res = mod.fit(start</span><span class="s3">, </span><span class="s1">maxiter=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">inv_weights=w0inv</span><span class="s3">,</span>
                        <span class="s0">#optim_method='bfgs', optim_args={'gtol':1e-6, 'disp': 0},</span>
                        <span class="s1">optim_args={</span><span class="s5">'disp'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">}</span><span class="s3">,</span>
                        <span class="s1">weights_method=</span><span class="s5">'iid'</span><span class="s3">,</span>
                        <span class="s1">wargs={</span><span class="s5">'centered'</span><span class="s1">:</span><span class="s3">False, </span><span class="s5">'ddof'</span><span class="s1">:</span><span class="s5">'k_params'</span><span class="s1">}</span><span class="s3">,</span>
                        <span class="s1">has_optimal_weights=</span><span class="s3">True</span><span class="s1">)</span>

        <span class="s0"># fix use of t distribution see #2495 comment</span>
        <span class="s1">res.use_t = </span><span class="s3">True</span>
        <span class="s1">res.df_resid = res.nobs - len(res.params)</span>
        <span class="s1">cls.res1 = res</span>

        <span class="s0">#from .results_gmm_griliches import results_onestep as results</span>
        <span class="s0">#cls.res2 = results</span>
        <span class="s1">cls.res2 = res_ols</span>

    <span class="s1">@pytest.mark.xfail(reason=</span><span class="s5">&quot;RegressionResults has no `Q` attribute&quot;</span><span class="s3">,</span>
                       <span class="s1">raises=AttributeError</span><span class="s3">, </span><span class="s1">strict=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s3">def </span><span class="s1">test_other(self):</span>
        <span class="s1">super(TestGMMStOneiterOLS_Linear</span><span class="s3">, </span><span class="s1">self).test_other()</span>


<span class="s0"># ------------------</span>

<span class="s3">class </span><span class="s1">TestGMMSt2:</span>
    <span class="s0"># this looks like an old version, trying out different comparisons</span>
    <span class="s0"># of options with Stats</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">setup_class(cls):</span>
        <span class="s0"># compare to Stata default options, iterative GMM</span>
        <span class="s1">exog = exog_st  </span><span class="s0"># with const at end</span>
        <span class="s1">start = OLS(endog</span><span class="s3">, </span><span class="s1">exog).fit().params</span>
        <span class="s1">nobs</span><span class="s3">, </span><span class="s1">k_instr = instrument.shape</span>
        <span class="s1">w0inv = np.dot(instrument.T</span><span class="s3">, </span><span class="s1">instrument) / nobs</span>
        <span class="s0">#w0 = np.linalg.inv(w0inv)</span>

        <span class="s1">mod = gmm.IVGMM(endog</span><span class="s3">, </span><span class="s1">exog</span><span class="s3">, </span><span class="s1">instrument)</span>
        <span class="s1">res = mod.fit(start</span><span class="s3">, </span><span class="s1">maxiter=</span><span class="s4">2</span><span class="s3">, </span><span class="s1">inv_weights=w0inv</span><span class="s3">,</span>
                      <span class="s1">wargs={</span><span class="s5">'ddof'</span><span class="s1">:</span><span class="s4">0</span><span class="s3">, </span><span class="s5">'centered'</span><span class="s1">:</span><span class="s3">False</span><span class="s1">}</span><span class="s3">,</span>
                      <span class="s1">optim_method=</span><span class="s5">'bfgs'</span><span class="s3">, </span><span class="s1">optim_args={</span><span class="s5">'gtol'</span><span class="s1">:</span><span class="s4">1e-6</span><span class="s3">, </span><span class="s5">'disp'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">})</span>
        <span class="s1">cls.res1 = res</span>

        <span class="s3">from </span><span class="s1">.results_ivreg2_griliches </span><span class="s3">import </span><span class="s1">results_gmm2s_robust </span><span class="s3">as </span><span class="s1">results</span>
        <span class="s1">cls.res2 = results</span>

        <span class="s0"># TODO: remove after testing, compare bse from 1 iteration</span>
        <span class="s0"># see test_basic</span>
        <span class="s1">mod = gmm.IVGMM(endog</span><span class="s3">, </span><span class="s1">exog</span><span class="s3">, </span><span class="s1">instrument)</span>
        <span class="s1">res = mod.fit(start</span><span class="s3">, </span><span class="s1">maxiter=</span><span class="s4">1</span><span class="s3">, </span><span class="s1">inv_weights=w0inv</span><span class="s3">,</span>
                      <span class="s1">wargs={</span><span class="s5">'ddof'</span><span class="s1">:</span><span class="s4">0</span><span class="s3">, </span><span class="s5">'centered'</span><span class="s1">:</span><span class="s3">False</span><span class="s1">}</span><span class="s3">,</span>
                      <span class="s1">optim_method=</span><span class="s5">'bfgs'</span><span class="s3">, </span><span class="s1">optim_args={</span><span class="s5">'gtol'</span><span class="s1">:</span><span class="s4">1e-6</span><span class="s3">, </span><span class="s5">'disp'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">})</span>
        <span class="s1">cls.res3 = res</span>


    <span class="s3">def </span><span class="s1">test_basic(self):</span>
        <span class="s1">res1</span><span class="s3">, </span><span class="s1">res2 = self.res1</span><span class="s3">, </span><span class="s1">self.res2</span>
        <span class="s0"># test both absolute and relative difference</span>
        <span class="s1">assert_allclose(res1.params</span><span class="s3">, </span><span class="s1">res2.params</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">5e-05</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res1.params</span><span class="s3">, </span><span class="s1">res2.params</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">5e-06</span><span class="s1">)</span>

        <span class="s1">n = res1.model.exog.shape[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s0"># TODO: check df correction np.sqrt(745./758 )*res1.bse matches better</span>
        <span class="s1">dffact = np.sqrt(</span><span class="s4">745. </span><span class="s1">/ </span><span class="s4">758 </span><span class="s1">)</span>
        <span class="s1">assert_allclose(res1.bse * dffact</span><span class="s3">, </span><span class="s1">res2.bse</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">5e-03</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res1.bse * dffact</span><span class="s3">, </span><span class="s1">res2.bse</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">5e-03</span><span class="s1">)</span>

        <span class="s0"># try other versions for bse,</span>
        <span class="s0"># TODO: next two produce the same as before (looks like)</span>
        <span class="s1">bse = np.sqrt(np.diag((res1._cov_params(has_optimal_weights=</span><span class="s3">True,</span>
                                            <span class="s1">weights=res1.weights))))</span>
        <span class="s1">assert_allclose(res1.bse</span><span class="s3">, </span><span class="s1">res2.bse</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">5e-01</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">bse = np.sqrt(np.diag((res1._cov_params(has_optimal_weights=</span><span class="s3">True,</span>
                                               <span class="s1">weights=res1.weights</span><span class="s3">,</span>
                                               <span class="s1">use_weights=</span><span class="s3">True</span><span class="s1">))))</span>
        <span class="s1">assert_allclose(res1.bse</span><span class="s3">, </span><span class="s1">res2.bse</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">5e-02</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s0"># TODO: resolve this</span>
        <span class="s0"># try bse from previous step, is closer to Stata</span>
        <span class="s0"># guess: Stata ivreg2 does not calc for bse update after final iteration</span>
        <span class="s0"># need better test case, bse difference is close to numerical optimization precision</span>
        <span class="s1">assert_allclose(self.res3.bse</span><span class="s3">, </span><span class="s1">res2.bse</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">5e-05</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(self.res3.bse</span><span class="s3">, </span><span class="s1">res2.bse</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">5e-06</span><span class="s1">)</span>



        <span class="s0"># TODO; tvalues are not available yet, no inheritance</span>
        <span class="s0">#assert_allclose(res1.tvalues, res2.tvalues, rtol=5e-10, atol=0)</span>




<span class="s3">class </span><span class="s1">CheckIV2SLS:</span>

    <span class="s3">def </span><span class="s1">test_basic(self):</span>
        <span class="s1">res1</span><span class="s3">, </span><span class="s1">res2 = self.res1</span><span class="s3">, </span><span class="s1">self.res2</span>
        <span class="s0"># test both absolute and relative difference</span>
        <span class="s1">assert_allclose(res1.params</span><span class="s3">, </span><span class="s1">res2.params</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">1e-9</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res1.params</span><span class="s3">, </span><span class="s1">res2.params</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">1e-10</span><span class="s1">)</span>

        <span class="s1">n = res1.model.exog.shape[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">assert_allclose(res1.bse</span><span class="s3">, </span><span class="s1">res2.bse</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">1e-10</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res1.bse</span><span class="s3">, </span><span class="s1">res2.bse</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">1e-11</span><span class="s1">)</span>

        <span class="s1">assert_allclose(res1.tvalues</span><span class="s3">, </span><span class="s1">res2.tvalues</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">5e-10</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">0</span><span class="s1">)</span>


    <span class="s3">def </span><span class="s1">test_other(self):</span>
        <span class="s1">res1</span><span class="s3">, </span><span class="s1">res2 = self.res1</span><span class="s3">, </span><span class="s1">self.res2</span>
        <span class="s1">assert_allclose(res1.rsquared</span><span class="s3">, </span><span class="s1">res2.r2</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">1e-7</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res1.rsquared_adj</span><span class="s3">, </span><span class="s1">res2.r2_a</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">1e-7</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s0"># TODO: why is fvalue different, IV2SLS uses inherited linear</span>
        <span class="s1">assert_allclose(res1.fvalue</span><span class="s3">, </span><span class="s1">res2.F</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">1e-10</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res1.f_pvalue</span><span class="s3">, </span><span class="s1">res2.Fp</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">1e-8</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(np.sqrt(res1.mse_resid)</span><span class="s3">, </span><span class="s1">res2.rmse</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">1e-10</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res1.ssr</span><span class="s3">, </span><span class="s1">res2.rss</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">1e-10</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res1.uncentered_tss</span><span class="s3">, </span><span class="s1">res2.yy</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">1e-10</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res1.centered_tss</span><span class="s3">, </span><span class="s1">res2.yyc</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">1e-10</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res1.ess</span><span class="s3">, </span><span class="s1">res2.mss</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">1e-9</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">assert_equal(res1.df_model</span><span class="s3">, </span><span class="s1">res2.df_m)</span>
        <span class="s1">assert_equal(res1.df_resid</span><span class="s3">, </span><span class="s1">res2.df_r)</span>

        <span class="s0"># TODO: llf raise NotImplementedError</span>
        <span class="s0">#assert_allclose(res1.llf, res2.ll, rtol=1e-10, atol=0)</span>


    <span class="s3">def </span><span class="s1">test_hypothesis(self):</span>
        <span class="s1">res1</span><span class="s3">, </span><span class="s1">res2 = self.res1</span><span class="s3">, </span><span class="s1">self.res2</span>
        <span class="s1">restriction = np.eye(len(res1.params))</span>
        <span class="s1">res_t = res1.t_test(restriction)</span>
        <span class="s1">assert_allclose(res_t.tvalue</span><span class="s3">, </span><span class="s1">res1.tvalues</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">1e-12</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res_t.pvalue</span><span class="s3">, </span><span class="s1">res1.pvalues</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">1e-12</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">res_f = res1.f_test(restriction[:-</span><span class="s4">1</span><span class="s1">]) </span><span class="s0"># without constant</span>
        <span class="s0"># TODO res1.fvalue problem, see issue #1104</span>
        <span class="s1">assert_allclose(res_f.fvalue</span><span class="s3">, </span><span class="s1">res1.fvalue</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">1e-12</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res_f.pvalue</span><span class="s3">, </span><span class="s1">res1.f_pvalue</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">1e-10</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res_f.fvalue</span><span class="s3">, </span><span class="s1">res2.F</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">1e-10</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res_f.pvalue</span><span class="s3">, </span><span class="s1">res2.Fp</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">1e-08</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">0</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_hausman(self):</span>
        <span class="s1">res1</span><span class="s3">, </span><span class="s1">res2 = self.res1</span><span class="s3">, </span><span class="s1">self.res2</span>
        <span class="s1">hausm = res1.spec_hausman()</span>
        <span class="s0"># hausman uses se2 = ssr / nobs, no df correction</span>
        <span class="s1">assert_allclose(hausm[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">res2.hausman[</span><span class="s5">'DWH'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">1e-11</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(hausm[</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">res2.hausman[</span><span class="s5">'DWHp'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s4">1e-10</span><span class="s3">, </span><span class="s1">atol=</span><span class="s4">1e-25</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.smoke</span>
    <span class="s3">def </span><span class="s1">test_summary(self):</span>
        <span class="s1">res1 = self.res1</span>
        <span class="s1">summ = res1.summary()</span>
        <span class="s1">assert_equal(len(summ.tables[</span><span class="s4">1</span><span class="s1">])</span><span class="s3">, </span><span class="s1">len(res1.params) + </span><span class="s4">1</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">TestIV2SLSSt1(CheckIV2SLS):</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">exog = exog_st  </span><span class="s0"># with const at end</span>
        <span class="s1">start = OLS(endog</span><span class="s3">, </span><span class="s1">exog).fit().params</span>
        <span class="s1">nobs</span><span class="s3">, </span><span class="s1">k_instr = instrument.shape</span>

        <span class="s1">mod = gmm.IV2SLS(endog</span><span class="s3">, </span><span class="s1">exog</span><span class="s3">, </span><span class="s1">instrument)</span>
        <span class="s1">res = mod.fit()</span>
        <span class="s1">cls.res1 = res</span>

        <span class="s3">from </span><span class="s1">.results_ivreg2_griliches </span><span class="s3">import </span><span class="s1">results_small </span><span class="s3">as </span><span class="s1">results</span>
        <span class="s1">cls.res2 = results</span>


    <span class="s0"># See GH #2720</span>
    <span class="s3">def </span><span class="s1">test_input_dimensions(self):</span>
        <span class="s1">rs = np.random.RandomState(</span><span class="s4">1234</span><span class="s1">)</span>
        <span class="s1">x = rs.randn(</span><span class="s4">200</span><span class="s3">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">z = rs.randn(</span><span class="s4">200</span><span class="s1">)</span>
        <span class="s1">x[:</span><span class="s3">, </span><span class="s4">0</span><span class="s1">] = np.sqrt(</span><span class="s4">0.5</span><span class="s1">) * x[:</span><span class="s3">, </span><span class="s4">0</span><span class="s1">] + np.sqrt(</span><span class="s4">0.5</span><span class="s1">) * z</span>
        <span class="s1">z = np.column_stack((x[:</span><span class="s3">, </span><span class="s1">[</span><span class="s4">1</span><span class="s1">]]</span><span class="s3">, </span><span class="s1">z[:</span><span class="s3">, None</span><span class="s1">]))</span>
        <span class="s1">e = np.sqrt(</span><span class="s4">0.5</span><span class="s1">) * rs.randn(</span><span class="s4">200</span><span class="s1">) + np.sqrt(</span><span class="s4">0.5</span><span class="s1">) * x[:</span><span class="s3">, </span><span class="s4">0</span><span class="s1">]</span>

        <span class="s1">y_1d = y = x[:</span><span class="s3">, </span><span class="s4">0</span><span class="s1">] + x[:</span><span class="s3">, </span><span class="s4">1</span><span class="s1">] + e</span>
        <span class="s1">y_2d = y[:</span><span class="s3">, None</span><span class="s1">]</span>
        <span class="s1">y_series = pd.Series(y)</span>
        <span class="s1">y_df = pd.DataFrame(y_series)</span>
        <span class="s1">x_1d = x[:</span><span class="s3">, </span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">x_2d = x</span>
        <span class="s1">x_df = pd.DataFrame(x)</span>
        <span class="s1">x_df_single = x_df.iloc[:</span><span class="s3">, </span><span class="s1">[</span><span class="s4">0</span><span class="s1">]]</span>
        <span class="s1">x_series = x_df.iloc[:</span><span class="s3">, </span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">z_2d = z</span>
        <span class="s1">z_series = pd.Series(z[:</span><span class="s3">, </span><span class="s4">1</span><span class="s1">])</span>
        <span class="s1">z_1d = z_series.values</span>
        <span class="s1">z_df = pd.DataFrame(z)</span>

        <span class="s1">ys = (y_df</span><span class="s3">, </span><span class="s1">y_series</span><span class="s3">, </span><span class="s1">y_2d</span><span class="s3">, </span><span class="s1">y_1d)</span>
        <span class="s1">xs = (x_2d</span><span class="s3">, </span><span class="s1">x_1d</span><span class="s3">, </span><span class="s1">x_df_single</span><span class="s3">, </span><span class="s1">x_df</span><span class="s3">, </span><span class="s1">x_series)</span>
        <span class="s1">zs = (z_1d</span><span class="s3">, </span><span class="s1">z_2d</span><span class="s3">, </span><span class="s1">z_series</span><span class="s3">, </span><span class="s1">z_df)</span>
        <span class="s1">res2 = gmm.IV2SLS(y_1d</span><span class="s3">, </span><span class="s1">x_2d</span><span class="s3">, </span><span class="s1">z_2d).fit()</span>
        <span class="s1">res1 = gmm.IV2SLS(y_1d</span><span class="s3">, </span><span class="s1">x_1d</span><span class="s3">, </span><span class="s1">z_1d).fit()</span>
        <span class="s1">res1_2sintr = gmm.IV2SLS(y_1d</span><span class="s3">, </span><span class="s1">x_1d</span><span class="s3">, </span><span class="s1">z_2d).fit()</span>


        <span class="s3">for </span><span class="s1">_y </span><span class="s3">in </span><span class="s1">ys:</span>
            <span class="s3">for </span><span class="s1">_x </span><span class="s3">in </span><span class="s1">xs:</span>
                <span class="s3">for </span><span class="s1">_z </span><span class="s3">in </span><span class="s1">zs:</span>
                    <span class="s1">x_1d = np.size(_x) == _x.shape[</span><span class="s4">0</span><span class="s1">]</span>
                    <span class="s1">z_1d = np.size(_z) == _z.shape[</span><span class="s4">0</span><span class="s1">]</span>
                    <span class="s3">if </span><span class="s1">z_1d </span><span class="s3">and not </span><span class="s1">x_1d:</span>
                        <span class="s3">continue</span>
                    <span class="s1">res = gmm.IV2SLS(_y</span><span class="s3">, </span><span class="s1">_x</span><span class="s3">, </span><span class="s1">_z).fit()</span>
                    <span class="s3">if </span><span class="s1">z_1d:</span>
                        <span class="s1">assert_allclose(res.params</span><span class="s3">, </span><span class="s1">res1.params)</span>
                    <span class="s3">elif </span><span class="s1">x_1d </span><span class="s3">and not </span><span class="s1">z_1d:</span>
                        <span class="s1">assert_allclose(res.params</span><span class="s3">, </span><span class="s1">res1_2sintr.params)</span>
                    <span class="s3">else</span><span class="s1">:</span>
                        <span class="s1">assert_allclose(res.params</span><span class="s3">, </span><span class="s1">res2.params)</span>

<span class="s3">def </span><span class="s1">test_noconstant():</span>
    <span class="s1">exog = exog_st[:</span><span class="s3">, </span><span class="s1">:-</span><span class="s4">1</span><span class="s1">]  </span><span class="s0"># with const removed at end</span>

    <span class="s1">mod = gmm.IV2SLS(endog</span><span class="s3">, </span><span class="s1">exog</span><span class="s3">, </span><span class="s1">instrument)</span>
    <span class="s1">res = mod.fit()</span>

    <span class="s1">assert_equal(res.fvalue</span><span class="s3">, </span><span class="s1">np.nan)</span>
    <span class="s0"># smoke test</span>
    <span class="s1">summ = res.summary()</span>
    <span class="s1">assert_equal(len(summ.tables[</span><span class="s4">1</span><span class="s1">])</span><span class="s3">, </span><span class="s1">len(res.params) + </span><span class="s4">1</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">test_gmm_basic():</span>
    <span class="s0"># this currently tests mainly the param names, exog_names</span>
    <span class="s0"># see #4340</span>
    <span class="s1">cd = np.array([</span><span class="s4">1.5</span><span class="s3">, </span><span class="s4">1.5</span><span class="s3">, </span><span class="s4">1.7</span><span class="s3">, </span><span class="s4">2.2</span><span class="s3">, </span><span class="s4">2.0</span><span class="s3">, </span><span class="s4">1.8</span><span class="s3">, </span><span class="s4">1.8</span><span class="s3">, </span><span class="s4">2.2</span><span class="s3">, </span><span class="s4">1.9</span><span class="s3">, </span><span class="s4">1.6</span><span class="s3">, </span><span class="s4">1.8</span><span class="s3">, </span><span class="s4">2.2</span><span class="s3">,</span>
                   <span class="s4">2.0</span><span class="s3">, </span><span class="s4">1.5</span><span class="s3">, </span><span class="s4">1.1</span><span class="s3">, </span><span class="s4">1.5</span><span class="s3">, </span><span class="s4">1.4</span><span class="s3">, </span><span class="s4">1.7</span><span class="s3">, </span><span class="s4">1.42</span><span class="s3">, </span><span class="s4">1.9</span><span class="s1">])</span>
    <span class="s1">dcd = np.array([</span><span class="s4">0</span><span class="s3">, </span><span class="s4">0.2 </span><span class="s3">,</span><span class="s4">0.5</span><span class="s3">, </span><span class="s1">-</span><span class="s4">0.2</span><span class="s3">, </span><span class="s1">-</span><span class="s4">0.2</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">0.4</span><span class="s3">, </span><span class="s1">-</span><span class="s4">0.3</span><span class="s3">, </span><span class="s1">-</span><span class="s4">0.3</span><span class="s3">, </span><span class="s4">0.2</span><span class="s3">, </span><span class="s4">0.4</span><span class="s3">,</span>
                    <span class="s1">-</span><span class="s4">0.2</span><span class="s3">, </span><span class="s1">-</span><span class="s4">0.5</span><span class="s3">, </span><span class="s1">-</span><span class="s4">0.4</span><span class="s3">, </span><span class="s4">0.4</span><span class="s3">, </span><span class="s1">-</span><span class="s4">0.1</span><span class="s3">, </span><span class="s4">0.3</span><span class="s3">, </span><span class="s1">-</span><span class="s4">0.28</span><span class="s3">, </span><span class="s4">0.48</span><span class="s3">, </span><span class="s4">0.2</span><span class="s1">])</span>
    <span class="s1">inst = np.column_stack((np.ones(len(cd))</span><span class="s3">, </span><span class="s1">cd))</span>

    <span class="s3">class </span><span class="s1">GMMbase(gmm.GMM):</span>
        <span class="s3">def </span><span class="s1">momcond(self</span><span class="s3">, </span><span class="s1">params):</span>
            <span class="s1">p0</span><span class="s3">, </span><span class="s1">p1</span><span class="s3">, </span><span class="s1">p2</span><span class="s3">, </span><span class="s1">p3 = params</span>
            <span class="s1">endog = self.endog[:</span><span class="s3">, None</span><span class="s1">]</span>
            <span class="s1">exog = self.exog</span>
            <span class="s1">inst = self.instrument</span>

            <span class="s1">mom0 = (endog - p0 - p1 * exog) * inst</span>
            <span class="s1">mom1 = ((endog - p0 - p1 * exog)**</span><span class="s4">2 </span><span class="s1">-</span>
                    <span class="s1">p2 * (exog**(</span><span class="s4">2 </span><span class="s1">* p3)) / </span><span class="s4">12</span><span class="s1">) * inst</span>
            <span class="s1">g = np.column_stack((mom0</span><span class="s3">, </span><span class="s1">mom1))</span>
            <span class="s3">return </span><span class="s1">g</span>

    <span class="s1">beta0 = np.array([</span><span class="s4">0.1</span><span class="s3">, </span><span class="s4">0.1</span><span class="s3">, </span><span class="s4">0.01</span><span class="s3">, </span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">res = GMMbase(endog=dcd</span><span class="s3">, </span><span class="s1">exog=cd</span><span class="s3">, </span><span class="s1">instrument=inst</span><span class="s3">, </span><span class="s1">k_moms=</span><span class="s4">4</span><span class="s3">,</span>
                  <span class="s1">k_params=</span><span class="s4">4</span><span class="s1">).fit(beta0</span><span class="s3">, </span><span class="s1">optim_args={</span><span class="s5">'disp'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">})</span>
    <span class="s1">summ = res.summary()</span>
    <span class="s1">assert_equal(len(summ.tables[</span><span class="s4">1</span><span class="s1">])</span><span class="s3">, </span><span class="s1">len(res.params) + </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">pnames = [</span><span class="s5">'p%2d' </span><span class="s1">% i </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(len(res.params))]</span>
    <span class="s1">assert_equal(res.model.exog_names</span><span class="s3">, </span><span class="s1">pnames)</span>

    <span class="s0"># check set_param_names method</span>
    <span class="s1">mod = GMMbase(endog=dcd</span><span class="s3">, </span><span class="s1">exog=cd</span><span class="s3">, </span><span class="s1">instrument=inst</span><span class="s3">, </span><span class="s1">k_moms=</span><span class="s4">4</span><span class="s3">,</span>
                  <span class="s1">k_params=</span><span class="s4">4</span><span class="s1">)</span>
    <span class="s0"># use arbitrary names</span>
    <span class="s1">pnames = [</span><span class="s5">'beta'</span><span class="s3">, </span><span class="s5">'gamma'</span><span class="s3">, </span><span class="s5">'psi'</span><span class="s3">, </span><span class="s5">'phi'</span><span class="s1">]</span>
    <span class="s1">mod.set_param_names(pnames)</span>
    <span class="s1">res1 = mod.fit(beta0</span><span class="s3">, </span><span class="s1">optim_args={</span><span class="s5">'disp'</span><span class="s1">: </span><span class="s4">0</span><span class="s1">})</span>
    <span class="s1">assert_equal(res1.model.exog_names</span><span class="s3">, </span><span class="s1">pnames)</span>
</pre>
</body>
</html>