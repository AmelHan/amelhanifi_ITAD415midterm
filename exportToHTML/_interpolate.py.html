<html>
<head>
<title>_interpolate.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #a9b7c6;}
.s1 { color: #6a8759;}
.s2 { color: #cc7832;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_interpolate.py</font>
</center></td></tr></table>
<pre><span class="s0">__all__ = [</span><span class="s1">'interp1d'</span><span class="s2">, </span><span class="s1">'interp2d'</span><span class="s2">, </span><span class="s1">'lagrange'</span><span class="s2">, </span><span class="s1">'PPoly'</span><span class="s2">, </span><span class="s1">'BPoly'</span><span class="s2">, </span><span class="s1">'NdPPoly'</span><span class="s0">]</span>

<span class="s2">from </span><span class="s0">math </span><span class="s2">import </span><span class="s0">prod</span>

<span class="s2">import </span><span class="s0">numpy </span><span class="s2">as </span><span class="s0">np</span>
<span class="s2">from </span><span class="s0">numpy </span><span class="s2">import </span><span class="s0">(array</span><span class="s2">, </span><span class="s0">transpose</span><span class="s2">, </span><span class="s0">searchsorted</span><span class="s2">, </span><span class="s0">atleast_1d</span><span class="s2">, </span><span class="s0">atleast_2d</span><span class="s2">,</span>
                   <span class="s0">ravel</span><span class="s2">, </span><span class="s0">poly1d</span><span class="s2">, </span><span class="s0">asarray</span><span class="s2">, </span><span class="s0">intp)</span>

<span class="s2">import </span><span class="s0">scipy.special </span><span class="s2">as </span><span class="s0">spec</span>
<span class="s2">from </span><span class="s0">scipy.special </span><span class="s2">import </span><span class="s0">comb</span>

<span class="s2">from </span><span class="s0">. </span><span class="s2">import </span><span class="s0">_fitpack_py</span>
<span class="s2">from </span><span class="s0">. </span><span class="s2">import </span><span class="s0">dfitpack</span>
<span class="s2">from </span><span class="s0">._polyint </span><span class="s2">import </span><span class="s0">_Interpolator1D</span>
<span class="s2">from </span><span class="s0">. </span><span class="s2">import </span><span class="s0">_ppoly</span>
<span class="s2">from </span><span class="s0">.interpnd </span><span class="s2">import </span><span class="s0">_ndim_coords_from_arrays</span>
<span class="s2">from </span><span class="s0">._bsplines </span><span class="s2">import </span><span class="s0">make_interp_spline</span><span class="s2">, </span><span class="s0">BSpline</span>


<span class="s2">def </span><span class="s0">lagrange(x</span><span class="s2">, </span><span class="s0">w):</span>
    <span class="s3">r&quot;&quot;&quot; 
    Return a Lagrange interpolating polynomial. 
 
    Given two 1-D arrays `x` and `w,` returns the Lagrange interpolating 
    polynomial through the points ``(x, w)``. 
 
    Warning: This implementation is numerically unstable. Do not expect to 
    be able to use more than about 20 points even if they are chosen optimally. 
 
    Parameters 
    ---------- 
    x : array_like 
        `x` represents the x-coordinates of a set of datapoints. 
    w : array_like 
        `w` represents the y-coordinates of a set of datapoints, i.e., f(`x`). 
 
    Returns 
    ------- 
    lagrange : `numpy.poly1d` instance 
        The Lagrange interpolating polynomial. 
 
    Examples 
    -------- 
    Interpolate :math:`f(x) = x^3` by 3 points. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.interpolate import lagrange 
    &gt;&gt;&gt; x = np.array([0, 1, 2]) 
    &gt;&gt;&gt; y = x**3 
    &gt;&gt;&gt; poly = lagrange(x, y) 
 
    Since there are only 3 points, Lagrange polynomial has degree 2. Explicitly, 
    it is given by 
 
    .. math:: 
 
        \begin{aligned} 
            L(x) &amp;= 1\times \frac{x (x - 2)}{-1} + 8\times \frac{x (x-1)}{2} \\ 
                 &amp;= x (-2 + 3x) 
        \end{aligned} 
 
    &gt;&gt;&gt; from numpy.polynomial.polynomial import Polynomial 
    &gt;&gt;&gt; Polynomial(poly.coef[::-1]).coef 
    array([ 0., -2.,  3.]) 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; x_new = np.arange(0, 2.1, 0.1) 
    &gt;&gt;&gt; plt.scatter(x, y, label='data') 
    &gt;&gt;&gt; plt.plot(x_new, Polynomial(poly.coef[::-1])(x_new), label='Polynomial') 
    &gt;&gt;&gt; plt.plot(x_new, 3*x_new**2 - 2*x_new + 0*x_new, 
    ...          label=r&quot;$3 x^2 - 2 x$&quot;, linestyle='-.') 
    &gt;&gt;&gt; plt.legend() 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>

    <span class="s0">M = len(x)</span>
    <span class="s0">p = poly1d(</span><span class="s4">0.0</span><span class="s0">)</span>
    <span class="s2">for </span><span class="s0">j </span><span class="s2">in </span><span class="s0">range(M):</span>
        <span class="s0">pt = poly1d(w[j])</span>
        <span class="s2">for </span><span class="s0">k </span><span class="s2">in </span><span class="s0">range(M):</span>
            <span class="s2">if </span><span class="s0">k == j:</span>
                <span class="s2">continue</span>
            <span class="s0">fac = x[j]-x[k]</span>
            <span class="s0">pt *= poly1d([</span><span class="s4">1.0</span><span class="s2">, </span><span class="s0">-x[k]])/fac</span>
        <span class="s0">p += pt</span>
    <span class="s2">return </span><span class="s0">p</span>


<span class="s5"># !! Need to find argument for keeping initialize. If it isn't</span>
<span class="s5"># !! found, get rid of it!</span>


<span class="s0">dep_mesg = </span><span class="s1">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s1">`interp2d` is deprecated in SciPy 1.10 and will be removed in SciPy 1.13.0. 
 
For legacy code, nearly bug-for-bug compatible replacements are 
`RectBivariateSpline` on regular grids, and `bisplrep`/`bisplev` for 
scattered 2D data. 
 
In new code, for regular grids use `RegularGridInterpolator` instead. 
For scattered data, prefer `LinearNDInterpolator` or 
`CloughTocher2DInterpolator`. 
 
For more details see 
`https://scipy.github.io/devdocs/notebooks/interp_transition_guide.html` 
&quot;&quot;&quot;</span>

<span class="s2">class </span><span class="s0">interp2d:</span>
    <span class="s3">&quot;&quot;&quot; 
    interp2d(x, y, z, kind='linear', copy=True, bounds_error=False, 
             fill_value=None) 
 
    .. deprecated:: 1.10.0 
 
        `interp2d` is deprecated in SciPy 1.10 and will be removed in SciPy 
        1.13.0. 
 
        For legacy code, nearly bug-for-bug compatible replacements are 
        `RectBivariateSpline` on regular grids, and `bisplrep`/`bisplev` for 
        scattered 2D data. 
 
        In new code, for regular grids use `RegularGridInterpolator` instead. 
        For scattered data, prefer `LinearNDInterpolator` or 
        `CloughTocher2DInterpolator`. 
 
        For more details see 
        `https://scipy.github.io/devdocs/notebooks/interp_transition_guide.html 
        &lt;https://scipy.github.io/devdocs/notebooks/interp_transition_guide.html&gt;`_ 
 
 
    Interpolate over a 2-D grid. 
 
    `x`, `y` and `z` are arrays of values used to approximate some function 
    f: ``z = f(x, y)`` which returns a scalar value `z`. This class returns a 
    function whose call method uses spline interpolation to find the value 
    of new points. 
 
    If `x` and `y` represent a regular grid, consider using 
    `RectBivariateSpline`. 
 
    If `z` is a vector value, consider using `interpn`. 
 
    Note that calling `interp2d` with NaNs present in input values, or with 
    decreasing values in `x` an `y` results in undefined behaviour. 
 
    Methods 
    ------- 
    __call__ 
 
    Parameters 
    ---------- 
    x, y : array_like 
        Arrays defining the data point coordinates. 
        The data point coordinates need to be sorted by increasing order. 
 
        If the points lie on a regular grid, `x` can specify the column 
        coordinates and `y` the row coordinates, for example:: 
 
          &gt;&gt;&gt; x = [0,1,2];  y = [0,3]; z = [[1,2,3], [4,5,6]] 
 
        Otherwise, `x` and `y` must specify the full coordinates for each 
        point, for example:: 
 
          &gt;&gt;&gt; x = [0,1,2,0,1,2];  y = [0,0,0,3,3,3]; z = [1,4,2,5,3,6] 
 
        If `x` and `y` are multidimensional, they are flattened before use. 
    z : array_like 
        The values of the function to interpolate at the data points. If 
        `z` is a multidimensional array, it is flattened before use assuming 
        Fortran-ordering (order='F').  The length of a flattened `z` array 
        is either len(`x`)*len(`y`) if `x` and `y` specify the column and 
        row coordinates or ``len(z) == len(x) == len(y)`` if `x` and `y` 
        specify coordinates for each point. 
    kind : {'linear', 'cubic', 'quintic'}, optional 
        The kind of spline interpolation to use. Default is 'linear'. 
    copy : bool, optional 
        If True, the class makes internal copies of x, y and z. 
        If False, references may be used. The default is to copy. 
    bounds_error : bool, optional 
        If True, when interpolated values are requested outside of the 
        domain of the input data (x,y), a ValueError is raised. 
        If False, then `fill_value` is used. 
    fill_value : number, optional 
        If provided, the value to use for points outside of the 
        interpolation domain. If omitted (None), values outside 
        the domain are extrapolated via nearest-neighbor extrapolation. 
 
    See Also 
    -------- 
    RectBivariateSpline : 
        Much faster 2-D interpolation if your input data is on a grid 
    bisplrep, bisplev : 
        Spline interpolation based on FITPACK 
    BivariateSpline : a more recent wrapper of the FITPACK routines 
    interp1d : 1-D version of this function 
    RegularGridInterpolator : interpolation on a regular or rectilinear grid 
        in arbitrary dimensions. 
    interpn : Multidimensional interpolation on regular grids (wraps 
        `RegularGridInterpolator` and `RectBivariateSpline`). 
 
    Notes 
    ----- 
    The minimum number of data points required along the interpolation 
    axis is ``(k+1)**2``, with k=1 for linear, k=3 for cubic and k=5 for 
    quintic interpolation. 
 
    The interpolator is constructed by `bisplrep`, with a smoothing factor 
    of 0. If more control over smoothing is needed, `bisplrep` should be 
    used directly. 
 
    The coordinates of the data points to interpolate `xnew` and `ynew` 
    have to be sorted by ascending order. 
    `interp2d` is legacy and is not 
    recommended for use in new code. New code should use 
    `RegularGridInterpolator` instead. 
 
    Examples 
    -------- 
    Construct a 2-D grid and interpolate on it: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import interpolate 
    &gt;&gt;&gt; x = np.arange(-5.01, 5.01, 0.25) 
    &gt;&gt;&gt; y = np.arange(-5.01, 5.01, 0.25) 
    &gt;&gt;&gt; xx, yy = np.meshgrid(x, y) 
    &gt;&gt;&gt; z = np.sin(xx**2+yy**2) 
    &gt;&gt;&gt; f = interpolate.interp2d(x, y, z, kind='cubic') 
 
    Now use the obtained interpolation function and plot the result: 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; xnew = np.arange(-5.01, 5.01, 1e-2) 
    &gt;&gt;&gt; ynew = np.arange(-5.01, 5.01, 1e-2) 
    &gt;&gt;&gt; znew = f(xnew, ynew) 
    &gt;&gt;&gt; plt.plot(x, z[0, :], 'ro-', xnew, znew[0, :], 'b-') 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span>

    <span class="s0">@np.deprecate(old_name=</span><span class="s1">'interp2d'</span><span class="s2">, </span><span class="s0">message=dep_mesg)</span>
    <span class="s2">def </span><span class="s0">__init__(self</span><span class="s2">, </span><span class="s0">x</span><span class="s2">, </span><span class="s0">y</span><span class="s2">, </span><span class="s0">z</span><span class="s2">, </span><span class="s0">kind=</span><span class="s1">'linear'</span><span class="s2">, </span><span class="s0">copy=</span><span class="s2">True, </span><span class="s0">bounds_error=</span><span class="s2">False,</span>
                 <span class="s0">fill_value=</span><span class="s2">None</span><span class="s0">):</span>
        <span class="s0">x = ravel(x)</span>
        <span class="s0">y = ravel(y)</span>
        <span class="s0">z = asarray(z)</span>

        <span class="s0">rectangular_grid = (z.size == len(x) * len(y))</span>
        <span class="s2">if </span><span class="s0">rectangular_grid:</span>
            <span class="s2">if </span><span class="s0">z.ndim == </span><span class="s4">2</span><span class="s0">:</span>
                <span class="s2">if </span><span class="s0">z.shape != (len(y)</span><span class="s2">, </span><span class="s0">len(x)):</span>
                    <span class="s2">raise </span><span class="s0">ValueError(</span><span class="s1">&quot;When on a regular grid with x.size = m &quot;</span>
                                     <span class="s1">&quot;and y.size = n, if z.ndim == 2, then z &quot;</span>
                                     <span class="s1">&quot;must have shape (n, m)&quot;</span><span class="s0">)</span>
            <span class="s2">if not </span><span class="s0">np.all(x[</span><span class="s4">1</span><span class="s0">:] &gt;= x[:-</span><span class="s4">1</span><span class="s0">]):</span>
                <span class="s0">j = np.argsort(x)</span>
                <span class="s0">x = x[j]</span>
                <span class="s0">z = z[:</span><span class="s2">, </span><span class="s0">j]</span>
            <span class="s2">if not </span><span class="s0">np.all(y[</span><span class="s4">1</span><span class="s0">:] &gt;= y[:-</span><span class="s4">1</span><span class="s0">]):</span>
                <span class="s0">j = np.argsort(y)</span>
                <span class="s0">y = y[j]</span>
                <span class="s0">z = z[j</span><span class="s2">, </span><span class="s0">:]</span>
            <span class="s0">z = ravel(z.T)</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s0">z = ravel(z)</span>
            <span class="s2">if </span><span class="s0">len(x) != len(y):</span>
                <span class="s2">raise </span><span class="s0">ValueError(</span>
                    <span class="s1">&quot;x and y must have equal lengths for non rectangular grid&quot;</span><span class="s0">)</span>
            <span class="s2">if </span><span class="s0">len(z) != len(x):</span>
                <span class="s2">raise </span><span class="s0">ValueError(</span>
                    <span class="s1">&quot;Invalid length for input z for non rectangular grid&quot;</span><span class="s0">)</span>

        <span class="s0">interpolation_types = {</span><span class="s1">'linear'</span><span class="s0">: </span><span class="s4">1</span><span class="s2">, </span><span class="s1">'cubic'</span><span class="s0">: </span><span class="s4">3</span><span class="s2">, </span><span class="s1">'quintic'</span><span class="s0">: </span><span class="s4">5</span><span class="s0">}</span>
        <span class="s2">try</span><span class="s0">:</span>
            <span class="s0">kx = ky = interpolation_types[kind]</span>
        <span class="s2">except </span><span class="s0">KeyError </span><span class="s2">as </span><span class="s0">e:</span>
            <span class="s2">raise </span><span class="s0">ValueError(</span>
                <span class="s1">f&quot;Unsupported interpolation type </span><span class="s2">{</span><span class="s0">repr(kind)</span><span class="s2">}</span><span class="s1">, must be &quot;</span>
                <span class="s1">f&quot;either of </span><span class="s2">{</span><span class="s1">', '</span><span class="s0">.join(map(repr</span><span class="s2">, </span><span class="s0">interpolation_types))</span><span class="s2">}</span><span class="s1">.&quot;</span>
            <span class="s0">) </span><span class="s2">from </span><span class="s0">e</span>

        <span class="s2">if not </span><span class="s0">rectangular_grid:</span>
            <span class="s5"># TODO: surfit is really not meant for interpolation!</span>
            <span class="s0">self.tck = _fitpack_py.bisplrep(x</span><span class="s2">, </span><span class="s0">y</span><span class="s2">, </span><span class="s0">z</span><span class="s2">, </span><span class="s0">kx=kx</span><span class="s2">, </span><span class="s0">ky=ky</span><span class="s2">, </span><span class="s0">s=</span><span class="s4">0.0</span><span class="s0">)</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s0">nx</span><span class="s2">, </span><span class="s0">tx</span><span class="s2">, </span><span class="s0">ny</span><span class="s2">, </span><span class="s0">ty</span><span class="s2">, </span><span class="s0">c</span><span class="s2">, </span><span class="s0">fp</span><span class="s2">, </span><span class="s0">ier = dfitpack.regrid_smth(</span>
                <span class="s0">x</span><span class="s2">, </span><span class="s0">y</span><span class="s2">, </span><span class="s0">z</span><span class="s2">, None, None, None, None,</span>
                <span class="s0">kx=kx</span><span class="s2">, </span><span class="s0">ky=ky</span><span class="s2">, </span><span class="s0">s=</span><span class="s4">0.0</span><span class="s0">)</span>
            <span class="s0">self.tck = (tx[:nx]</span><span class="s2">, </span><span class="s0">ty[:ny]</span><span class="s2">, </span><span class="s0">c[:(nx - kx - </span><span class="s4">1</span><span class="s0">) * (ny - ky - </span><span class="s4">1</span><span class="s0">)]</span><span class="s2">,</span>
                        <span class="s0">kx</span><span class="s2">, </span><span class="s0">ky)</span>

        <span class="s0">self.bounds_error = bounds_error</span>
        <span class="s0">self.fill_value = fill_value</span>
        <span class="s0">self.x</span><span class="s2">, </span><span class="s0">self.y</span><span class="s2">, </span><span class="s0">self.z = (array(a</span><span class="s2">, </span><span class="s0">copy=copy) </span><span class="s2">for </span><span class="s0">a </span><span class="s2">in </span><span class="s0">(x</span><span class="s2">, </span><span class="s0">y</span><span class="s2">, </span><span class="s0">z))</span>

        <span class="s0">self.x_min</span><span class="s2">, </span><span class="s0">self.x_max = np.amin(x)</span><span class="s2">, </span><span class="s0">np.amax(x)</span>
        <span class="s0">self.y_min</span><span class="s2">, </span><span class="s0">self.y_max = np.amin(y)</span><span class="s2">, </span><span class="s0">np.amax(y)</span>

    <span class="s0">@np.deprecate(old_name=</span><span class="s1">'interp2d'</span><span class="s2">, </span><span class="s0">message=dep_mesg)</span>
    <span class="s2">def </span><span class="s0">__call__(self</span><span class="s2">, </span><span class="s0">x</span><span class="s2">, </span><span class="s0">y</span><span class="s2">, </span><span class="s0">dx=</span><span class="s4">0</span><span class="s2">, </span><span class="s0">dy=</span><span class="s4">0</span><span class="s2">, </span><span class="s0">assume_sorted=</span><span class="s2">False</span><span class="s0">):</span>
        <span class="s3">&quot;&quot;&quot;Interpolate the function. 
 
        Parameters 
        ---------- 
        x : 1-D array 
            x-coordinates of the mesh on which to interpolate. 
        y : 1-D array 
            y-coordinates of the mesh on which to interpolate. 
        dx : int &gt;= 0, &lt; kx 
            Order of partial derivatives in x. 
        dy : int &gt;= 0, &lt; ky 
            Order of partial derivatives in y. 
        assume_sorted : bool, optional 
            If False, values of `x` and `y` can be in any order and they are 
            sorted first. 
            If True, `x` and `y` have to be arrays of monotonically 
            increasing values. 
 
        Returns 
        ------- 
        z : 2-D array with shape (len(y), len(x)) 
            The interpolated values. 
        &quot;&quot;&quot;</span>

        <span class="s0">x = atleast_1d(x)</span>
        <span class="s0">y = atleast_1d(y)</span>

        <span class="s2">if </span><span class="s0">x.ndim != </span><span class="s4">1 </span><span class="s2">or </span><span class="s0">y.ndim != </span><span class="s4">1</span><span class="s0">:</span>
            <span class="s2">raise </span><span class="s0">ValueError(</span><span class="s1">&quot;x and y should both be 1-D arrays&quot;</span><span class="s0">)</span>

        <span class="s2">if not </span><span class="s0">assume_sorted:</span>
            <span class="s0">x = np.sort(x</span><span class="s2">, </span><span class="s0">kind=</span><span class="s1">&quot;mergesort&quot;</span><span class="s0">)</span>
            <span class="s0">y = np.sort(y</span><span class="s2">, </span><span class="s0">kind=</span><span class="s1">&quot;mergesort&quot;</span><span class="s0">)</span>

        <span class="s2">if </span><span class="s0">self.bounds_error </span><span class="s2">or </span><span class="s0">self.fill_value </span><span class="s2">is not None</span><span class="s0">:</span>
            <span class="s0">out_of_bounds_x = (x &lt; self.x_min) | (x &gt; self.x_max)</span>
            <span class="s0">out_of_bounds_y = (y &lt; self.y_min) | (y &gt; self.y_max)</span>

            <span class="s0">any_out_of_bounds_x = np.any(out_of_bounds_x)</span>
            <span class="s0">any_out_of_bounds_y = np.any(out_of_bounds_y)</span>

        <span class="s2">if </span><span class="s0">self.bounds_error </span><span class="s2">and </span><span class="s0">(any_out_of_bounds_x </span><span class="s2">or </span><span class="s0">any_out_of_bounds_y):</span>
            <span class="s2">raise </span><span class="s0">ValueError(</span><span class="s1">&quot;Values out of range; x must be in %r, y in %r&quot;</span>
                             <span class="s0">% ((self.x_min</span><span class="s2">, </span><span class="s0">self.x_max)</span><span class="s2">,</span>
                                <span class="s0">(self.y_min</span><span class="s2">, </span><span class="s0">self.y_max)))</span>

        <span class="s0">z = _fitpack_py.bisplev(x</span><span class="s2">, </span><span class="s0">y</span><span class="s2">, </span><span class="s0">self.tck</span><span class="s2">, </span><span class="s0">dx</span><span class="s2">, </span><span class="s0">dy)</span>
        <span class="s0">z = atleast_2d(z)</span>
        <span class="s0">z = transpose(z)</span>

        <span class="s2">if </span><span class="s0">self.fill_value </span><span class="s2">is not None</span><span class="s0">:</span>
            <span class="s2">if </span><span class="s0">any_out_of_bounds_x:</span>
                <span class="s0">z[:</span><span class="s2">, </span><span class="s0">out_of_bounds_x] = self.fill_value</span>
            <span class="s2">if </span><span class="s0">any_out_of_bounds_y:</span>
                <span class="s0">z[out_of_bounds_y</span><span class="s2">, </span><span class="s0">:] = self.fill_value</span>

        <span class="s2">if </span><span class="s0">len(z) == </span><span class="s4">1</span><span class="s0">:</span>
            <span class="s0">z = z[</span><span class="s4">0</span><span class="s0">]</span>
        <span class="s2">return </span><span class="s0">array(z)</span>


<span class="s2">def </span><span class="s0">_check_broadcast_up_to(arr_from</span><span class="s2">, </span><span class="s0">shape_to</span><span class="s2">, </span><span class="s0">name):</span>
    <span class="s3">&quot;&quot;&quot;Helper to check that arr_from broadcasts up to shape_to&quot;&quot;&quot;</span>
    <span class="s0">shape_from = arr_from.shape</span>
    <span class="s2">if </span><span class="s0">len(shape_to) &gt;= len(shape_from):</span>
        <span class="s2">for </span><span class="s0">t</span><span class="s2">, </span><span class="s0">f </span><span class="s2">in </span><span class="s0">zip(shape_to[::-</span><span class="s4">1</span><span class="s0">]</span><span class="s2">, </span><span class="s0">shape_from[::-</span><span class="s4">1</span><span class="s0">]):</span>
            <span class="s2">if </span><span class="s0">f != </span><span class="s4">1 </span><span class="s2">and </span><span class="s0">f != t:</span>
                <span class="s2">break</span>
        <span class="s2">else</span><span class="s0">:  </span><span class="s5"># all checks pass, do the upcasting that we need later</span>
            <span class="s2">if </span><span class="s0">arr_from.size != </span><span class="s4">1 </span><span class="s2">and </span><span class="s0">arr_from.shape != shape_to:</span>
                <span class="s0">arr_from = np.ones(shape_to</span><span class="s2">, </span><span class="s0">arr_from.dtype) * arr_from</span>
            <span class="s2">return </span><span class="s0">arr_from.ravel()</span>
    <span class="s5"># at least one check failed</span>
    <span class="s2">raise </span><span class="s0">ValueError(</span><span class="s1">'%s argument must be able to broadcast up '</span>
                     <span class="s1">'to shape %s but had shape %s'</span>
                     <span class="s0">% (name</span><span class="s2">, </span><span class="s0">shape_to</span><span class="s2">, </span><span class="s0">shape_from))</span>


<span class="s2">def </span><span class="s0">_do_extrapolate(fill_value):</span>
    <span class="s3">&quot;&quot;&quot;Helper to check if fill_value == &quot;extrapolate&quot; without warnings&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s0">(isinstance(fill_value</span><span class="s2">, </span><span class="s0">str) </span><span class="s2">and</span>
            <span class="s0">fill_value == </span><span class="s1">'extrapolate'</span><span class="s0">)</span>


<span class="s2">class </span><span class="s0">interp1d(_Interpolator1D):</span>
    <span class="s3">&quot;&quot;&quot; 
    Interpolate a 1-D function. 
 
    .. legacy:: class 
 
    `x` and `y` are arrays of values used to approximate some function f: 
    ``y = f(x)``. This class returns a function whose call method uses 
    interpolation to find the value of new points. 
 
    Parameters 
    ---------- 
    x : (npoints, ) array_like 
        A 1-D array of real values. 
    y : (..., npoints, ...) array_like 
        A N-D array of real values. The length of `y` along the interpolation 
        axis must be equal to the length of `x`. Use the ``axis`` parameter 
        to select correct axis. Unlike other interpolators, the default 
        interpolation axis is the last axis of `y`. 
    kind : str or int, optional 
        Specifies the kind of interpolation as a string or as an integer 
        specifying the order of the spline interpolator to use. 
        The string has to be one of 'linear', 'nearest', 'nearest-up', 'zero', 
        'slinear', 'quadratic', 'cubic', 'previous', or 'next'. 'zero', 
        'slinear', 'quadratic' and 'cubic' refer to a spline interpolation of 
        zeroth, first, second or third order; 'previous' and 'next' simply 
        return the previous or next value of the point; 'nearest-up' and 
        'nearest' differ when interpolating half-integers (e.g. 0.5, 1.5) 
        in that 'nearest-up' rounds up and 'nearest' rounds down. Default 
        is 'linear'. 
    axis : int, optional 
        Axis in the ``y`` array corresponding to the x-coordinate values. Unlike 
        other interpolators, defaults to ``axis=-1``. 
    copy : bool, optional 
        If True, the class makes internal copies of x and y. 
        If False, references to `x` and `y` are used. The default is to copy. 
    bounds_error : bool, optional 
        If True, a ValueError is raised any time interpolation is attempted on 
        a value outside of the range of x (where extrapolation is 
        necessary). If False, out of bounds values are assigned `fill_value`. 
        By default, an error is raised unless ``fill_value=&quot;extrapolate&quot;``. 
    fill_value : array-like or (array-like, array_like) or &quot;extrapolate&quot;, optional 
        - if a ndarray (or float), this value will be used to fill in for 
          requested points outside of the data range. If not provided, then 
          the default is NaN. The array-like must broadcast properly to the 
          dimensions of the non-interpolation axes. 
        - If a two-element tuple, then the first element is used as a 
          fill value for ``x_new &lt; x[0]`` and the second element is used for 
          ``x_new &gt; x[-1]``. Anything that is not a 2-element tuple (e.g., 
          list or ndarray, regardless of shape) is taken to be a single 
          array-like argument meant to be used for both bounds as 
          ``below, above = fill_value, fill_value``. Using a two-element tuple 
          or ndarray requires ``bounds_error=False``. 
 
          .. versionadded:: 0.17.0 
        - If &quot;extrapolate&quot;, then points outside the data range will be 
          extrapolated. 
 
          .. versionadded:: 0.17.0 
    assume_sorted : bool, optional 
        If False, values of `x` can be in any order and they are sorted first. 
        If True, `x` has to be an array of monotonically increasing values. 
 
    Attributes 
    ---------- 
    fill_value 
 
    Methods 
    ------- 
    __call__ 
 
    See Also 
    -------- 
    splrep, splev 
        Spline interpolation/smoothing based on FITPACK. 
    UnivariateSpline : An object-oriented wrapper of the FITPACK routines. 
    interp2d : 2-D interpolation 
 
    Notes 
    ----- 
    Calling `interp1d` with NaNs present in input values results in 
    undefined behaviour. 
 
    Input values `x` and `y` must be convertible to `float` values like 
    `int` or `float`. 
 
    If the values in `x` are not unique, the resulting behavior is 
    undefined and specific to the choice of `kind`, i.e., changing 
    `kind` will change the behavior for duplicates. 
 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; from scipy import interpolate 
    &gt;&gt;&gt; x = np.arange(0, 10) 
    &gt;&gt;&gt; y = np.exp(-x/3.0) 
    &gt;&gt;&gt; f = interpolate.interp1d(x, y) 
 
    &gt;&gt;&gt; xnew = np.arange(0, 9, 0.1) 
    &gt;&gt;&gt; ynew = f(xnew)   # use interpolation function returned by `interp1d` 
    &gt;&gt;&gt; plt.plot(x, y, 'o', xnew, ynew, '-') 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s0">__init__(self</span><span class="s2">, </span><span class="s0">x</span><span class="s2">, </span><span class="s0">y</span><span class="s2">, </span><span class="s0">kind=</span><span class="s1">'linear'</span><span class="s2">, </span><span class="s0">axis=-</span><span class="s4">1</span><span class="s2">,</span>
                 <span class="s0">copy=</span><span class="s2">True, </span><span class="s0">bounds_error=</span><span class="s2">None, </span><span class="s0">fill_value=np.nan</span><span class="s2">,</span>
                 <span class="s0">assume_sorted=</span><span class="s2">False</span><span class="s0">):</span>
        <span class="s3">&quot;&quot;&quot; Initialize a 1-D linear interpolation class.&quot;&quot;&quot;</span>
        <span class="s0">_Interpolator1D.__init__(self</span><span class="s2">, </span><span class="s0">x</span><span class="s2">, </span><span class="s0">y</span><span class="s2">, </span><span class="s0">axis=axis)</span>

        <span class="s0">self.bounds_error = bounds_error  </span><span class="s5"># used by fill_value setter</span>
        <span class="s0">self.copy = copy</span>

        <span class="s2">if </span><span class="s0">kind </span><span class="s2">in </span><span class="s0">[</span><span class="s1">'zero'</span><span class="s2">, </span><span class="s1">'slinear'</span><span class="s2">, </span><span class="s1">'quadratic'</span><span class="s2">, </span><span class="s1">'cubic'</span><span class="s0">]:</span>
            <span class="s0">order = {</span><span class="s1">'zero'</span><span class="s0">: </span><span class="s4">0</span><span class="s2">, </span><span class="s1">'slinear'</span><span class="s0">: </span><span class="s4">1</span><span class="s2">,</span>
                     <span class="s1">'quadratic'</span><span class="s0">: </span><span class="s4">2</span><span class="s2">, </span><span class="s1">'cubic'</span><span class="s0">: </span><span class="s4">3</span><span class="s0">}[kind]</span>
            <span class="s0">kind = </span><span class="s1">'spline'</span>
        <span class="s2">elif </span><span class="s0">isinstance(kind</span><span class="s2">, </span><span class="s0">int):</span>
            <span class="s0">order = kind</span>
            <span class="s0">kind = </span><span class="s1">'spline'</span>
        <span class="s2">elif </span><span class="s0">kind </span><span class="s2">not in </span><span class="s0">(</span><span class="s1">'linear'</span><span class="s2">, </span><span class="s1">'nearest'</span><span class="s2">, </span><span class="s1">'nearest-up'</span><span class="s2">, </span><span class="s1">'previous'</span><span class="s2">,</span>
                          <span class="s1">'next'</span><span class="s0">):</span>
            <span class="s2">raise </span><span class="s0">NotImplementedError(</span><span class="s1">&quot;%s is unsupported: Use fitpack &quot;</span>
                                      <span class="s1">&quot;routines for other types.&quot; </span><span class="s0">% kind)</span>
        <span class="s0">x = array(x</span><span class="s2">, </span><span class="s0">copy=self.copy)</span>
        <span class="s0">y = array(y</span><span class="s2">, </span><span class="s0">copy=self.copy)</span>

        <span class="s2">if not </span><span class="s0">assume_sorted:</span>
            <span class="s0">ind = np.argsort(x</span><span class="s2">, </span><span class="s0">kind=</span><span class="s1">&quot;mergesort&quot;</span><span class="s0">)</span>
            <span class="s0">x = x[ind]</span>
            <span class="s0">y = np.take(y</span><span class="s2">, </span><span class="s0">ind</span><span class="s2">, </span><span class="s0">axis=axis)</span>

        <span class="s2">if </span><span class="s0">x.ndim != </span><span class="s4">1</span><span class="s0">:</span>
            <span class="s2">raise </span><span class="s0">ValueError(</span><span class="s1">&quot;the x array must have exactly one dimension.&quot;</span><span class="s0">)</span>
        <span class="s2">if </span><span class="s0">y.ndim == </span><span class="s4">0</span><span class="s0">:</span>
            <span class="s2">raise </span><span class="s0">ValueError(</span><span class="s1">&quot;the y array must have at least one dimension.&quot;</span><span class="s0">)</span>

        <span class="s5"># Force-cast y to a floating-point type, if it's not yet one</span>
        <span class="s2">if not </span><span class="s0">issubclass(y.dtype.type</span><span class="s2">, </span><span class="s0">np.inexact):</span>
            <span class="s0">y = y.astype(np.float_)</span>

        <span class="s5"># Backward compatibility</span>
        <span class="s0">self.axis = axis % y.ndim</span>

        <span class="s5"># Interpolation goes internally along the first axis</span>
        <span class="s0">self.y = y</span>
        <span class="s0">self._y = self._reshape_yi(self.y)</span>
        <span class="s0">self.x = x</span>
        <span class="s2">del </span><span class="s0">y</span><span class="s2">, </span><span class="s0">x  </span><span class="s5"># clean up namespace to prevent misuse; use attributes</span>
        <span class="s0">self._kind = kind</span>

        <span class="s5"># Adjust to interpolation kind; store reference to *unbound*</span>
        <span class="s5"># interpolation methods, in order to avoid circular references to self</span>
        <span class="s5"># stored in the bound instance methods, and therefore delayed garbage</span>
        <span class="s5"># collection.  See: https://docs.python.org/reference/datamodel.html</span>
        <span class="s2">if </span><span class="s0">kind </span><span class="s2">in </span><span class="s0">(</span><span class="s1">'linear'</span><span class="s2">, </span><span class="s1">'nearest'</span><span class="s2">, </span><span class="s1">'nearest-up'</span><span class="s2">, </span><span class="s1">'previous'</span><span class="s2">, </span><span class="s1">'next'</span><span class="s0">):</span>
            <span class="s5"># Make a &quot;view&quot; of the y array that is rotated to the interpolation</span>
            <span class="s5"># axis.</span>
            <span class="s0">minval = </span><span class="s4">1</span>
            <span class="s2">if </span><span class="s0">kind == </span><span class="s1">'nearest'</span><span class="s0">:</span>
                <span class="s5"># Do division before addition to prevent possible integer</span>
                <span class="s5"># overflow</span>
                <span class="s0">self._side = </span><span class="s1">'left'</span>
                <span class="s0">self.x_bds = self.x / </span><span class="s4">2.0</span>
                <span class="s0">self.x_bds = self.x_bds[</span><span class="s4">1</span><span class="s0">:] + self.x_bds[:-</span><span class="s4">1</span><span class="s0">]</span>

                <span class="s0">self._call = self.__class__._call_nearest</span>
            <span class="s2">elif </span><span class="s0">kind == </span><span class="s1">'nearest-up'</span><span class="s0">:</span>
                <span class="s5"># Do division before addition to prevent possible integer</span>
                <span class="s5"># overflow</span>
                <span class="s0">self._side = </span><span class="s1">'right'</span>
                <span class="s0">self.x_bds = self.x / </span><span class="s4">2.0</span>
                <span class="s0">self.x_bds = self.x_bds[</span><span class="s4">1</span><span class="s0">:] + self.x_bds[:-</span><span class="s4">1</span><span class="s0">]</span>

                <span class="s0">self._call = self.__class__._call_nearest</span>
            <span class="s2">elif </span><span class="s0">kind == </span><span class="s1">'previous'</span><span class="s0">:</span>
                <span class="s5"># Side for np.searchsorted and index for clipping</span>
                <span class="s0">self._side = </span><span class="s1">'left'</span>
                <span class="s0">self._ind = </span><span class="s4">0</span>
                <span class="s5"># Move x by one floating point value to the left</span>
                <span class="s0">self._x_shift = np.nextafter(self.x</span><span class="s2">, </span><span class="s0">-np.inf)</span>
                <span class="s0">self._call = self.__class__._call_previousnext</span>
                <span class="s2">if </span><span class="s0">_do_extrapolate(fill_value):</span>
                    <span class="s0">self._check_and_update_bounds_error_for_extrapolation()</span>
                    <span class="s5"># assume y is sorted by x ascending order here.</span>
                    <span class="s0">fill_value = (np.nan</span><span class="s2">, </span><span class="s0">np.take(self.y</span><span class="s2">, </span><span class="s0">-</span><span class="s4">1</span><span class="s2">, </span><span class="s0">axis))</span>
            <span class="s2">elif </span><span class="s0">kind == </span><span class="s1">'next'</span><span class="s0">:</span>
                <span class="s0">self._side = </span><span class="s1">'right'</span>
                <span class="s0">self._ind = </span><span class="s4">1</span>
                <span class="s5"># Move x by one floating point value to the right</span>
                <span class="s0">self._x_shift = np.nextafter(self.x</span><span class="s2">, </span><span class="s0">np.inf)</span>
                <span class="s0">self._call = self.__class__._call_previousnext</span>
                <span class="s2">if </span><span class="s0">_do_extrapolate(fill_value):</span>
                    <span class="s0">self._check_and_update_bounds_error_for_extrapolation()</span>
                    <span class="s5"># assume y is sorted by x ascending order here.</span>
                    <span class="s0">fill_value = (np.take(self.y</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s0">axis)</span><span class="s2">, </span><span class="s0">np.nan)</span>
            <span class="s2">else</span><span class="s0">:</span>
                <span class="s5"># Check if we can delegate to numpy.interp (2x-10x faster).</span>
                <span class="s0">np_types = (np.float_</span><span class="s2">, </span><span class="s0">np.int_)</span>
                <span class="s0">cond = self.x.dtype </span><span class="s2">in </span><span class="s0">np_types </span><span class="s2">and </span><span class="s0">self.y.dtype </span><span class="s2">in </span><span class="s0">np_types</span>
                <span class="s0">cond = cond </span><span class="s2">and </span><span class="s0">self.y.ndim == </span><span class="s4">1</span>
                <span class="s0">cond = cond </span><span class="s2">and not </span><span class="s0">_do_extrapolate(fill_value)</span>

                <span class="s2">if </span><span class="s0">cond:</span>
                    <span class="s0">self._call = self.__class__._call_linear_np</span>
                <span class="s2">else</span><span class="s0">:</span>
                    <span class="s0">self._call = self.__class__._call_linear</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s0">minval = order + </span><span class="s4">1</span>

            <span class="s0">rewrite_nan = </span><span class="s2">False</span>
            <span class="s0">xx</span><span class="s2">, </span><span class="s0">yy = self.x</span><span class="s2">, </span><span class="s0">self._y</span>
            <span class="s2">if </span><span class="s0">order &gt; </span><span class="s4">1</span><span class="s0">:</span>
                <span class="s5"># Quadratic or cubic spline. If input contains even a single</span>
                <span class="s5"># nan, then the output is all nans. We cannot just feed data</span>
                <span class="s5"># with nans to make_interp_spline because it calls LAPACK.</span>
                <span class="s5"># So, we make up a bogus x and y with no nans and use it</span>
                <span class="s5"># to get the correct shape of the output, which we then fill</span>
                <span class="s5"># with nans.</span>
                <span class="s5"># For slinear or zero order spline, we just pass nans through.</span>
                <span class="s0">mask = np.isnan(self.x)</span>
                <span class="s2">if </span><span class="s0">mask.any():</span>
                    <span class="s0">sx = self.x[~mask]</span>
                    <span class="s2">if </span><span class="s0">sx.size == </span><span class="s4">0</span><span class="s0">:</span>
                        <span class="s2">raise </span><span class="s0">ValueError(</span><span class="s1">&quot;`x` array is all-nan&quot;</span><span class="s0">)</span>
                    <span class="s0">xx = np.linspace(np.nanmin(self.x)</span><span class="s2">,</span>
                                     <span class="s0">np.nanmax(self.x)</span><span class="s2">,</span>
                                     <span class="s0">len(self.x))</span>
                    <span class="s0">rewrite_nan = </span><span class="s2">True</span>
                <span class="s2">if </span><span class="s0">np.isnan(self._y).any():</span>
                    <span class="s0">yy = np.ones_like(self._y)</span>
                    <span class="s0">rewrite_nan = </span><span class="s2">True</span>

            <span class="s0">self._spline = make_interp_spline(xx</span><span class="s2">, </span><span class="s0">yy</span><span class="s2">, </span><span class="s0">k=order</span><span class="s2">,</span>
                                              <span class="s0">check_finite=</span><span class="s2">False</span><span class="s0">)</span>
            <span class="s2">if </span><span class="s0">rewrite_nan:</span>
                <span class="s0">self._call = self.__class__._call_nan_spline</span>
            <span class="s2">else</span><span class="s0">:</span>
                <span class="s0">self._call = self.__class__._call_spline</span>

        <span class="s2">if </span><span class="s0">len(self.x) &lt; minval:</span>
            <span class="s2">raise </span><span class="s0">ValueError(</span><span class="s1">&quot;x and y arrays must have at &quot;</span>
                             <span class="s1">&quot;least %d entries&quot; </span><span class="s0">% minval)</span>

        <span class="s0">self.fill_value = fill_value  </span><span class="s5"># calls the setter, can modify bounds_err</span>

    <span class="s0">@property</span>
    <span class="s2">def </span><span class="s0">fill_value(self):</span>
        <span class="s3">&quot;&quot;&quot;The fill value.&quot;&quot;&quot;</span>
        <span class="s5"># backwards compat: mimic a public attribute</span>
        <span class="s2">return </span><span class="s0">self._fill_value_orig</span>

    <span class="s0">@fill_value.setter</span>
    <span class="s2">def </span><span class="s0">fill_value(self</span><span class="s2">, </span><span class="s0">fill_value):</span>
        <span class="s5"># extrapolation only works for nearest neighbor and linear methods</span>
        <span class="s2">if </span><span class="s0">_do_extrapolate(fill_value):</span>
            <span class="s0">self._check_and_update_bounds_error_for_extrapolation()</span>
            <span class="s0">self._extrapolate = </span><span class="s2">True</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s0">broadcast_shape = (self.y.shape[:self.axis] +</span>
                               <span class="s0">self.y.shape[self.axis + </span><span class="s4">1</span><span class="s0">:])</span>
            <span class="s2">if </span><span class="s0">len(broadcast_shape) == </span><span class="s4">0</span><span class="s0">:</span>
                <span class="s0">broadcast_shape = (</span><span class="s4">1</span><span class="s2">,</span><span class="s0">)</span>
            <span class="s5"># it's either a pair (_below_range, _above_range) or a single value</span>
            <span class="s5"># for both above and below range</span>
            <span class="s2">if </span><span class="s0">isinstance(fill_value</span><span class="s2">, </span><span class="s0">tuple) </span><span class="s2">and </span><span class="s0">len(fill_value) == </span><span class="s4">2</span><span class="s0">:</span>
                <span class="s0">below_above = [np.asarray(fill_value[</span><span class="s4">0</span><span class="s0">])</span><span class="s2">,</span>
                               <span class="s0">np.asarray(fill_value[</span><span class="s4">1</span><span class="s0">])]</span>
                <span class="s0">names = (</span><span class="s1">'fill_value (below)'</span><span class="s2">, </span><span class="s1">'fill_value (above)'</span><span class="s0">)</span>
                <span class="s2">for </span><span class="s0">ii </span><span class="s2">in </span><span class="s0">range(</span><span class="s4">2</span><span class="s0">):</span>
                    <span class="s0">below_above[ii] = _check_broadcast_up_to(</span>
                        <span class="s0">below_above[ii]</span><span class="s2">, </span><span class="s0">broadcast_shape</span><span class="s2">, </span><span class="s0">names[ii])</span>
            <span class="s2">else</span><span class="s0">:</span>
                <span class="s0">fill_value = np.asarray(fill_value)</span>
                <span class="s0">below_above = [_check_broadcast_up_to(</span>
                    <span class="s0">fill_value</span><span class="s2">, </span><span class="s0">broadcast_shape</span><span class="s2">, </span><span class="s1">'fill_value'</span><span class="s0">)] * </span><span class="s4">2</span>
            <span class="s0">self._fill_value_below</span><span class="s2">, </span><span class="s0">self._fill_value_above = below_above</span>
            <span class="s0">self._extrapolate = </span><span class="s2">False</span>
            <span class="s2">if </span><span class="s0">self.bounds_error </span><span class="s2">is None</span><span class="s0">:</span>
                <span class="s0">self.bounds_error = </span><span class="s2">True</span>
        <span class="s5"># backwards compat: fill_value was a public attr; make it writeable</span>
        <span class="s0">self._fill_value_orig = fill_value</span>

    <span class="s2">def </span><span class="s0">_check_and_update_bounds_error_for_extrapolation(self):</span>
        <span class="s2">if </span><span class="s0">self.bounds_error:</span>
            <span class="s2">raise </span><span class="s0">ValueError(</span><span class="s1">&quot;Cannot extrapolate and raise &quot;</span>
                             <span class="s1">&quot;at the same time.&quot;</span><span class="s0">)</span>
        <span class="s0">self.bounds_error = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s0">_call_linear_np(self</span><span class="s2">, </span><span class="s0">x_new):</span>
        <span class="s5"># Note that out-of-bounds values are taken care of in self._evaluate</span>
        <span class="s2">return </span><span class="s0">np.interp(x_new</span><span class="s2">, </span><span class="s0">self.x</span><span class="s2">, </span><span class="s0">self.y)</span>

    <span class="s2">def </span><span class="s0">_call_linear(self</span><span class="s2">, </span><span class="s0">x_new):</span>
        <span class="s5"># 2. Find where in the original data, the values to interpolate</span>
        <span class="s5">#    would be inserted.</span>
        <span class="s5">#    Note: If x_new[n] == x[m], then m is returned by searchsorted.</span>
        <span class="s0">x_new_indices = searchsorted(self.x</span><span class="s2">, </span><span class="s0">x_new)</span>

        <span class="s5"># 3. Clip x_new_indices so that they are within the range of</span>
        <span class="s5">#    self.x indices and at least 1. Removes mis-interpolation</span>
        <span class="s5">#    of x_new[n] = x[0]</span>
        <span class="s0">x_new_indices = x_new_indices.clip(</span><span class="s4">1</span><span class="s2">, </span><span class="s0">len(self.x)-</span><span class="s4">1</span><span class="s0">).astype(int)</span>

        <span class="s5"># 4. Calculate the slope of regions that each x_new value falls in.</span>
        <span class="s0">lo = x_new_indices - </span><span class="s4">1</span>
        <span class="s0">hi = x_new_indices</span>

        <span class="s0">x_lo = self.x[lo]</span>
        <span class="s0">x_hi = self.x[hi]</span>
        <span class="s0">y_lo = self._y[lo]</span>
        <span class="s0">y_hi = self._y[hi]</span>

        <span class="s5"># Note that the following two expressions rely on the specifics of the</span>
        <span class="s5"># broadcasting semantics.</span>
        <span class="s0">slope = (y_hi - y_lo) / (x_hi - x_lo)[:</span><span class="s2">, None</span><span class="s0">]</span>

        <span class="s5"># 5. Calculate the actual value for each entry in x_new.</span>
        <span class="s0">y_new = slope*(x_new - x_lo)[:</span><span class="s2">, None</span><span class="s0">] + y_lo</span>

        <span class="s2">return </span><span class="s0">y_new</span>

    <span class="s2">def </span><span class="s0">_call_nearest(self</span><span class="s2">, </span><span class="s0">x_new):</span>
        <span class="s3">&quot;&quot;&quot; Find nearest neighbor interpolated y_new = f(x_new).&quot;&quot;&quot;</span>

        <span class="s5"># 2. Find where in the averaged data the values to interpolate</span>
        <span class="s5">#    would be inserted.</span>
        <span class="s5">#    Note: use side='left' (right) to searchsorted() to define the</span>
        <span class="s5">#    halfway point to be nearest to the left (right) neighbor</span>
        <span class="s0">x_new_indices = searchsorted(self.x_bds</span><span class="s2">, </span><span class="s0">x_new</span><span class="s2">, </span><span class="s0">side=self._side)</span>

        <span class="s5"># 3. Clip x_new_indices so that they are within the range of x indices.</span>
        <span class="s0">x_new_indices = x_new_indices.clip(</span><span class="s4">0</span><span class="s2">, </span><span class="s0">len(self.x)-</span><span class="s4">1</span><span class="s0">).astype(intp)</span>

        <span class="s5"># 4. Calculate the actual value for each entry in x_new.</span>
        <span class="s0">y_new = self._y[x_new_indices]</span>

        <span class="s2">return </span><span class="s0">y_new</span>

    <span class="s2">def </span><span class="s0">_call_previousnext(self</span><span class="s2">, </span><span class="s0">x_new):</span>
        <span class="s3">&quot;&quot;&quot;Use previous/next neighbor of x_new, y_new = f(x_new).&quot;&quot;&quot;</span>

        <span class="s5"># 1. Get index of left/right value</span>
        <span class="s0">x_new_indices = searchsorted(self._x_shift</span><span class="s2">, </span><span class="s0">x_new</span><span class="s2">, </span><span class="s0">side=self._side)</span>

        <span class="s5"># 2. Clip x_new_indices so that they are within the range of x indices.</span>
        <span class="s0">x_new_indices = x_new_indices.clip(</span><span class="s4">1</span><span class="s0">-self._ind</span><span class="s2">,</span>
                                           <span class="s0">len(self.x)-self._ind).astype(intp)</span>

        <span class="s5"># 3. Calculate the actual value for each entry in x_new.</span>
        <span class="s0">y_new = self._y[x_new_indices+self._ind-</span><span class="s4">1</span><span class="s0">]</span>

        <span class="s2">return </span><span class="s0">y_new</span>

    <span class="s2">def </span><span class="s0">_call_spline(self</span><span class="s2">, </span><span class="s0">x_new):</span>
        <span class="s2">return </span><span class="s0">self._spline(x_new)</span>

    <span class="s2">def </span><span class="s0">_call_nan_spline(self</span><span class="s2">, </span><span class="s0">x_new):</span>
        <span class="s0">out = self._spline(x_new)</span>
        <span class="s0">out[...] = np.nan</span>
        <span class="s2">return </span><span class="s0">out</span>

    <span class="s2">def </span><span class="s0">_evaluate(self</span><span class="s2">, </span><span class="s0">x_new):</span>
        <span class="s5"># 1. Handle values in x_new that are outside of x. Throw error,</span>
        <span class="s5">#    or return a list of mask array indicating the outofbounds values.</span>
        <span class="s5">#    The behavior is set by the bounds_error variable.</span>
        <span class="s0">x_new = asarray(x_new)</span>
        <span class="s0">y_new = self._call(self</span><span class="s2">, </span><span class="s0">x_new)</span>
        <span class="s2">if not </span><span class="s0">self._extrapolate:</span>
            <span class="s0">below_bounds</span><span class="s2">, </span><span class="s0">above_bounds = self._check_bounds(x_new)</span>
            <span class="s2">if </span><span class="s0">len(y_new) &gt; </span><span class="s4">0</span><span class="s0">:</span>
                <span class="s5"># Note fill_value must be broadcast up to the proper size</span>
                <span class="s5"># and flattened to work here</span>
                <span class="s0">y_new[below_bounds] = self._fill_value_below</span>
                <span class="s0">y_new[above_bounds] = self._fill_value_above</span>
        <span class="s2">return </span><span class="s0">y_new</span>

    <span class="s2">def </span><span class="s0">_check_bounds(self</span><span class="s2">, </span><span class="s0">x_new):</span>
        <span class="s3">&quot;&quot;&quot;Check the inputs for being in the bounds of the interpolated data. 
 
        Parameters 
        ---------- 
        x_new : array 
 
        Returns 
        ------- 
        out_of_bounds : bool array 
            The mask on x_new of values that are out of the bounds. 
        &quot;&quot;&quot;</span>

        <span class="s5"># If self.bounds_error is True, we raise an error if any x_new values</span>
        <span class="s5"># fall outside the range of x. Otherwise, we return an array indicating</span>
        <span class="s5"># which values are outside the boundary region.</span>
        <span class="s0">below_bounds = x_new &lt; self.x[</span><span class="s4">0</span><span class="s0">]</span>
        <span class="s0">above_bounds = x_new &gt; self.x[-</span><span class="s4">1</span><span class="s0">]</span>

        <span class="s2">if </span><span class="s0">self.bounds_error </span><span class="s2">and </span><span class="s0">below_bounds.any():</span>
            <span class="s0">below_bounds_value = x_new[np.argmax(below_bounds)]</span>
            <span class="s2">raise </span><span class="s0">ValueError(</span><span class="s1">&quot;A value ({}) in x_new is below &quot;</span>
                             <span class="s1">&quot;the interpolation range's minimum value ({}).&quot;</span>
                             <span class="s0">.format(below_bounds_value</span><span class="s2">, </span><span class="s0">self.x[</span><span class="s4">0</span><span class="s0">]))</span>
        <span class="s2">if </span><span class="s0">self.bounds_error </span><span class="s2">and </span><span class="s0">above_bounds.any():</span>
            <span class="s0">above_bounds_value = x_new[np.argmax(above_bounds)]</span>
            <span class="s2">raise </span><span class="s0">ValueError(</span><span class="s1">&quot;A value ({}) in x_new is above &quot;</span>
                             <span class="s1">&quot;the interpolation range's maximum value ({}).&quot;</span>
                             <span class="s0">.format(above_bounds_value</span><span class="s2">, </span><span class="s0">self.x[-</span><span class="s4">1</span><span class="s0">]))</span>

        <span class="s5"># !! Should we emit a warning if some values are out of bounds?</span>
        <span class="s5"># !! matlab does not.</span>
        <span class="s2">return </span><span class="s0">below_bounds</span><span class="s2">, </span><span class="s0">above_bounds</span>


<span class="s2">class </span><span class="s0">_PPolyBase:</span>
    <span class="s3">&quot;&quot;&quot;Base class for piecewise polynomials.&quot;&quot;&quot;</span>
    <span class="s0">__slots__ = (</span><span class="s1">'c'</span><span class="s2">, </span><span class="s1">'x'</span><span class="s2">, </span><span class="s1">'extrapolate'</span><span class="s2">, </span><span class="s1">'axis'</span><span class="s0">)</span>

    <span class="s2">def </span><span class="s0">__init__(self</span><span class="s2">, </span><span class="s0">c</span><span class="s2">, </span><span class="s0">x</span><span class="s2">, </span><span class="s0">extrapolate=</span><span class="s2">None, </span><span class="s0">axis=</span><span class="s4">0</span><span class="s0">):</span>
        <span class="s0">self.c = np.asarray(c)</span>
        <span class="s0">self.x = np.ascontiguousarray(x</span><span class="s2">, </span><span class="s0">dtype=np.float64)</span>

        <span class="s2">if </span><span class="s0">extrapolate </span><span class="s2">is None</span><span class="s0">:</span>
            <span class="s0">extrapolate = </span><span class="s2">True</span>
        <span class="s2">elif </span><span class="s0">extrapolate != </span><span class="s1">'periodic'</span><span class="s0">:</span>
            <span class="s0">extrapolate = bool(extrapolate)</span>
        <span class="s0">self.extrapolate = extrapolate</span>

        <span class="s2">if </span><span class="s0">self.c.ndim &lt; </span><span class="s4">2</span><span class="s0">:</span>
            <span class="s2">raise </span><span class="s0">ValueError(</span><span class="s1">&quot;Coefficients array must be at least &quot;</span>
                             <span class="s1">&quot;2-dimensional.&quot;</span><span class="s0">)</span>

        <span class="s2">if not </span><span class="s0">(</span><span class="s4">0 </span><span class="s0">&lt;= axis &lt; self.c.ndim - </span><span class="s4">1</span><span class="s0">):</span>
            <span class="s2">raise </span><span class="s0">ValueError(</span><span class="s1">&quot;axis=%s must be between 0 and %s&quot; </span><span class="s0">%</span>
                             <span class="s0">(axis</span><span class="s2">, </span><span class="s0">self.c.ndim-</span><span class="s4">1</span><span class="s0">))</span>

        <span class="s0">self.axis = axis</span>
        <span class="s2">if </span><span class="s0">axis != </span><span class="s4">0</span><span class="s0">:</span>
            <span class="s5"># move the interpolation axis to be the first one in self.c</span>
            <span class="s5"># More specifically, the target shape for self.c is (k, m, ...),</span>
            <span class="s5"># and axis !=0 means that we have c.shape (..., k, m, ...)</span>
            <span class="s5">#                                               ^</span>
            <span class="s5">#                                              axis</span>
            <span class="s5"># So we roll two of them.</span>
            <span class="s0">self.c = np.moveaxis(self.c</span><span class="s2">, </span><span class="s0">axis+</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s0">)</span>
            <span class="s0">self.c = np.moveaxis(self.c</span><span class="s2">, </span><span class="s0">axis+</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s0">)</span>

        <span class="s2">if </span><span class="s0">self.x.ndim != </span><span class="s4">1</span><span class="s0">:</span>
            <span class="s2">raise </span><span class="s0">ValueError(</span><span class="s1">&quot;x must be 1-dimensional&quot;</span><span class="s0">)</span>
        <span class="s2">if </span><span class="s0">self.x.size &lt; </span><span class="s4">2</span><span class="s0">:</span>
            <span class="s2">raise </span><span class="s0">ValueError(</span><span class="s1">&quot;at least 2 breakpoints are needed&quot;</span><span class="s0">)</span>
        <span class="s2">if </span><span class="s0">self.c.ndim &lt; </span><span class="s4">2</span><span class="s0">:</span>
            <span class="s2">raise </span><span class="s0">ValueError(</span><span class="s1">&quot;c must have at least 2 dimensions&quot;</span><span class="s0">)</span>
        <span class="s2">if </span><span class="s0">self.c.shape[</span><span class="s4">0</span><span class="s0">] == </span><span class="s4">0</span><span class="s0">:</span>
            <span class="s2">raise </span><span class="s0">ValueError(</span><span class="s1">&quot;polynomial must be at least of order 0&quot;</span><span class="s0">)</span>
        <span class="s2">if </span><span class="s0">self.c.shape[</span><span class="s4">1</span><span class="s0">] != self.x.size-</span><span class="s4">1</span><span class="s0">:</span>
            <span class="s2">raise </span><span class="s0">ValueError(</span><span class="s1">&quot;number of coefficients != len(x)-1&quot;</span><span class="s0">)</span>
        <span class="s0">dx = np.diff(self.x)</span>
        <span class="s2">if not </span><span class="s0">(np.all(dx &gt;= </span><span class="s4">0</span><span class="s0">) </span><span class="s2">or </span><span class="s0">np.all(dx &lt;= </span><span class="s4">0</span><span class="s0">)):</span>
            <span class="s2">raise </span><span class="s0">ValueError(</span><span class="s1">&quot;`x` must be strictly increasing or decreasing.&quot;</span><span class="s0">)</span>

        <span class="s0">dtype = self._get_dtype(self.c.dtype)</span>
        <span class="s0">self.c = np.ascontiguousarray(self.c</span><span class="s2">, </span><span class="s0">dtype=dtype)</span>

    <span class="s2">def </span><span class="s0">_get_dtype(self</span><span class="s2">, </span><span class="s0">dtype):</span>
        <span class="s2">if </span><span class="s0">np.issubdtype(dtype</span><span class="s2">, </span><span class="s0">np.complexfloating) \</span>
               <span class="s2">or </span><span class="s0">np.issubdtype(self.c.dtype</span><span class="s2">, </span><span class="s0">np.complexfloating):</span>
            <span class="s2">return </span><span class="s0">np.complex_</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s2">return </span><span class="s0">np.float_</span>

    <span class="s0">@classmethod</span>
    <span class="s2">def </span><span class="s0">construct_fast(cls</span><span class="s2">, </span><span class="s0">c</span><span class="s2">, </span><span class="s0">x</span><span class="s2">, </span><span class="s0">extrapolate=</span><span class="s2">None, </span><span class="s0">axis=</span><span class="s4">0</span><span class="s0">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Construct the piecewise polynomial without making checks. 
 
        Takes the same parameters as the constructor. Input arguments 
        ``c`` and ``x`` must be arrays of the correct shape and type. The 
        ``c`` array can only be of dtypes float and complex, and ``x`` 
        array must have dtype float. 
        &quot;&quot;&quot;</span>
        <span class="s0">self = object.__new__(cls)</span>
        <span class="s0">self.c = c</span>
        <span class="s0">self.x = x</span>
        <span class="s0">self.axis = axis</span>
        <span class="s2">if </span><span class="s0">extrapolate </span><span class="s2">is None</span><span class="s0">:</span>
            <span class="s0">extrapolate = </span><span class="s2">True</span>
        <span class="s0">self.extrapolate = extrapolate</span>
        <span class="s2">return </span><span class="s0">self</span>

    <span class="s2">def </span><span class="s0">_ensure_c_contiguous(self):</span>
        <span class="s3">&quot;&quot;&quot; 
        c and x may be modified by the user. The Cython code expects 
        that they are C contiguous. 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s0">self.x.flags.c_contiguous:</span>
            <span class="s0">self.x = self.x.copy()</span>
        <span class="s2">if not </span><span class="s0">self.c.flags.c_contiguous:</span>
            <span class="s0">self.c = self.c.copy()</span>

    <span class="s2">def </span><span class="s0">extend(self</span><span class="s2">, </span><span class="s0">c</span><span class="s2">, </span><span class="s0">x):</span>
        <span class="s3">&quot;&quot;&quot; 
        Add additional breakpoints and coefficients to the polynomial. 
 
        Parameters 
        ---------- 
        c : ndarray, size (k, m, ...) 
            Additional coefficients for polynomials in intervals. Note that 
            the first additional interval will be formed using one of the 
            ``self.x`` end points. 
        x : ndarray, size (m,) 
            Additional breakpoints. Must be sorted in the same order as 
            ``self.x`` and either to the right or to the left of the current 
            breakpoints. 
        &quot;&quot;&quot;</span>

        <span class="s0">c = np.asarray(c)</span>
        <span class="s0">x = np.asarray(x)</span>

        <span class="s2">if </span><span class="s0">c.ndim &lt; </span><span class="s4">2</span><span class="s0">:</span>
            <span class="s2">raise </span><span class="s0">ValueError(</span><span class="s1">&quot;invalid dimensions for c&quot;</span><span class="s0">)</span>
        <span class="s2">if </span><span class="s0">x.ndim != </span><span class="s4">1</span><span class="s0">:</span>
            <span class="s2">raise </span><span class="s0">ValueError(</span><span class="s1">&quot;invalid dimensions for x&quot;</span><span class="s0">)</span>
        <span class="s2">if </span><span class="s0">x.shape[</span><span class="s4">0</span><span class="s0">] != c.shape[</span><span class="s4">1</span><span class="s0">]:</span>
            <span class="s2">raise </span><span class="s0">ValueError(</span><span class="s1">&quot;Shapes of x {} and c {} are incompatible&quot;</span>
                             <span class="s0">.format(x.shape</span><span class="s2">, </span><span class="s0">c.shape))</span>
        <span class="s2">if </span><span class="s0">c.shape[</span><span class="s4">2</span><span class="s0">:] != self.c.shape[</span><span class="s4">2</span><span class="s0">:] </span><span class="s2">or </span><span class="s0">c.ndim != self.c.ndim:</span>
            <span class="s2">raise </span><span class="s0">ValueError(</span><span class="s1">&quot;Shapes of c {} and self.c {} are incompatible&quot;</span>
                             <span class="s0">.format(c.shape</span><span class="s2">, </span><span class="s0">self.c.shape))</span>

        <span class="s2">if </span><span class="s0">c.size == </span><span class="s4">0</span><span class="s0">:</span>
            <span class="s2">return</span>

        <span class="s0">dx = np.diff(x)</span>
        <span class="s2">if not </span><span class="s0">(np.all(dx &gt;= </span><span class="s4">0</span><span class="s0">) </span><span class="s2">or </span><span class="s0">np.all(dx &lt;= </span><span class="s4">0</span><span class="s0">)):</span>
            <span class="s2">raise </span><span class="s0">ValueError(</span><span class="s1">&quot;`x` is not sorted.&quot;</span><span class="s0">)</span>

        <span class="s2">if </span><span class="s0">self.x[-</span><span class="s4">1</span><span class="s0">] &gt;= self.x[</span><span class="s4">0</span><span class="s0">]:</span>
            <span class="s2">if not </span><span class="s0">x[-</span><span class="s4">1</span><span class="s0">] &gt;= x[</span><span class="s4">0</span><span class="s0">]:</span>
                <span class="s2">raise </span><span class="s0">ValueError(</span><span class="s1">&quot;`x` is in the different order &quot;</span>
                                 <span class="s1">&quot;than `self.x`.&quot;</span><span class="s0">)</span>

            <span class="s2">if </span><span class="s0">x[</span><span class="s4">0</span><span class="s0">] &gt;= self.x[-</span><span class="s4">1</span><span class="s0">]:</span>
                <span class="s0">action = </span><span class="s1">'append'</span>
            <span class="s2">elif </span><span class="s0">x[-</span><span class="s4">1</span><span class="s0">] &lt;= self.x[</span><span class="s4">0</span><span class="s0">]:</span>
                <span class="s0">action = </span><span class="s1">'prepend'</span>
            <span class="s2">else</span><span class="s0">:</span>
                <span class="s2">raise </span><span class="s0">ValueError(</span><span class="s1">&quot;`x` is neither on the left or on the right &quot;</span>
                                 <span class="s1">&quot;from `self.x`.&quot;</span><span class="s0">)</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s2">if not </span><span class="s0">x[-</span><span class="s4">1</span><span class="s0">] &lt;= x[</span><span class="s4">0</span><span class="s0">]:</span>
                <span class="s2">raise </span><span class="s0">ValueError(</span><span class="s1">&quot;`x` is in the different order &quot;</span>
                                 <span class="s1">&quot;than `self.x`.&quot;</span><span class="s0">)</span>

            <span class="s2">if </span><span class="s0">x[</span><span class="s4">0</span><span class="s0">] &lt;= self.x[-</span><span class="s4">1</span><span class="s0">]:</span>
                <span class="s0">action = </span><span class="s1">'append'</span>
            <span class="s2">elif </span><span class="s0">x[-</span><span class="s4">1</span><span class="s0">] &gt;= self.x[</span><span class="s4">0</span><span class="s0">]:</span>
                <span class="s0">action = </span><span class="s1">'prepend'</span>
            <span class="s2">else</span><span class="s0">:</span>
                <span class="s2">raise </span><span class="s0">ValueError(</span><span class="s1">&quot;`x` is neither on the left or on the right &quot;</span>
                                 <span class="s1">&quot;from `self.x`.&quot;</span><span class="s0">)</span>

        <span class="s0">dtype = self._get_dtype(c.dtype)</span>

        <span class="s0">k2 = max(c.shape[</span><span class="s4">0</span><span class="s0">]</span><span class="s2">, </span><span class="s0">self.c.shape[</span><span class="s4">0</span><span class="s0">])</span>
        <span class="s0">c2 = np.zeros((k2</span><span class="s2">, </span><span class="s0">self.c.shape[</span><span class="s4">1</span><span class="s0">] + c.shape[</span><span class="s4">1</span><span class="s0">]) + self.c.shape[</span><span class="s4">2</span><span class="s0">:]</span><span class="s2">,</span>
                      <span class="s0">dtype=dtype)</span>

        <span class="s2">if </span><span class="s0">action == </span><span class="s1">'append'</span><span class="s0">:</span>
            <span class="s0">c2[k2-self.c.shape[</span><span class="s4">0</span><span class="s0">]:</span><span class="s2">, </span><span class="s0">:self.c.shape[</span><span class="s4">1</span><span class="s0">]] = self.c</span>
            <span class="s0">c2[k2-c.shape[</span><span class="s4">0</span><span class="s0">]:</span><span class="s2">, </span><span class="s0">self.c.shape[</span><span class="s4">1</span><span class="s0">]:] = c</span>
            <span class="s0">self.x = np.r_[self.x</span><span class="s2">, </span><span class="s0">x]</span>
        <span class="s2">elif </span><span class="s0">action == </span><span class="s1">'prepend'</span><span class="s0">:</span>
            <span class="s0">c2[k2-self.c.shape[</span><span class="s4">0</span><span class="s0">]:</span><span class="s2">, </span><span class="s0">:c.shape[</span><span class="s4">1</span><span class="s0">]] = c</span>
            <span class="s0">c2[k2-c.shape[</span><span class="s4">0</span><span class="s0">]:</span><span class="s2">, </span><span class="s0">c.shape[</span><span class="s4">1</span><span class="s0">]:] = self.c</span>
            <span class="s0">self.x = np.r_[x</span><span class="s2">, </span><span class="s0">self.x]</span>

        <span class="s0">self.c = c2</span>

    <span class="s2">def </span><span class="s0">__call__(self</span><span class="s2">, </span><span class="s0">x</span><span class="s2">, </span><span class="s0">nu=</span><span class="s4">0</span><span class="s2">, </span><span class="s0">extrapolate=</span><span class="s2">None</span><span class="s0">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Evaluate the piecewise polynomial or its derivative. 
 
        Parameters 
        ---------- 
        x : array_like 
            Points to evaluate the interpolant at. 
        nu : int, optional 
            Order of derivative to evaluate. Must be non-negative. 
        extrapolate : {bool, 'periodic', None}, optional 
            If bool, determines whether to extrapolate to out-of-bounds points 
            based on first and last intervals, or to return NaNs. 
            If 'periodic', periodic extrapolation is used. 
            If None (default), use `self.extrapolate`. 
 
        Returns 
        ------- 
        y : array_like 
            Interpolated values. Shape is determined by replacing 
            the interpolation axis in the original array with the shape of x. 
 
        Notes 
        ----- 
        Derivatives are evaluated piecewise for each polynomial 
        segment, even if the polynomial is not differentiable at the 
        breakpoints. The polynomial intervals are considered half-open, 
        ``[a, b)``, except for the last interval which is closed 
        ``[a, b]``. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s0">extrapolate </span><span class="s2">is None</span><span class="s0">:</span>
            <span class="s0">extrapolate = self.extrapolate</span>
        <span class="s0">x = np.asarray(x)</span>
        <span class="s0">x_shape</span><span class="s2">, </span><span class="s0">x_ndim = x.shape</span><span class="s2">, </span><span class="s0">x.ndim</span>
        <span class="s0">x = np.ascontiguousarray(x.ravel()</span><span class="s2">, </span><span class="s0">dtype=np.float_)</span>

        <span class="s5"># With periodic extrapolation we map x to the segment</span>
        <span class="s5"># [self.x[0], self.x[-1]].</span>
        <span class="s2">if </span><span class="s0">extrapolate == </span><span class="s1">'periodic'</span><span class="s0">:</span>
            <span class="s0">x = self.x[</span><span class="s4">0</span><span class="s0">] + (x - self.x[</span><span class="s4">0</span><span class="s0">]) % (self.x[-</span><span class="s4">1</span><span class="s0">] - self.x[</span><span class="s4">0</span><span class="s0">])</span>
            <span class="s0">extrapolate = </span><span class="s2">False</span>

        <span class="s0">out = np.empty((len(x)</span><span class="s2">, </span><span class="s0">prod(self.c.shape[</span><span class="s4">2</span><span class="s0">:]))</span><span class="s2">, </span><span class="s0">dtype=self.c.dtype)</span>
        <span class="s0">self._ensure_c_contiguous()</span>
        <span class="s0">self._evaluate(x</span><span class="s2">, </span><span class="s0">nu</span><span class="s2">, </span><span class="s0">extrapolate</span><span class="s2">, </span><span class="s0">out)</span>
        <span class="s0">out = out.reshape(x_shape + self.c.shape[</span><span class="s4">2</span><span class="s0">:])</span>
        <span class="s2">if </span><span class="s0">self.axis != </span><span class="s4">0</span><span class="s0">:</span>
            <span class="s5"># transpose to move the calculated values to the interpolation axis</span>
            <span class="s0">l = list(range(out.ndim))</span>
            <span class="s0">l = l[x_ndim:x_ndim+self.axis] + l[:x_ndim] + l[x_ndim+self.axis:]</span>
            <span class="s0">out = out.transpose(l)</span>
        <span class="s2">return </span><span class="s0">out</span>


<span class="s2">class </span><span class="s0">PPoly(_PPolyBase):</span>
    <span class="s3">&quot;&quot;&quot; 
    Piecewise polynomial in terms of coefficients and breakpoints 
 
    The polynomial between ``x[i]`` and ``x[i + 1]`` is written in the 
    local power basis:: 
 
        S = sum(c[m, i] * (xp - x[i])**(k-m) for m in range(k+1)) 
 
    where ``k`` is the degree of the polynomial. 
 
    Parameters 
    ---------- 
    c : ndarray, shape (k, m, ...) 
        Polynomial coefficients, order `k` and `m` intervals. 
    x : ndarray, shape (m+1,) 
        Polynomial breakpoints. Must be sorted in either increasing or 
        decreasing order. 
    extrapolate : bool or 'periodic', optional 
        If bool, determines whether to extrapolate to out-of-bounds points 
        based on first and last intervals, or to return NaNs. If 'periodic', 
        periodic extrapolation is used. Default is True. 
    axis : int, optional 
        Interpolation axis. Default is zero. 
 
    Attributes 
    ---------- 
    x : ndarray 
        Breakpoints. 
    c : ndarray 
        Coefficients of the polynomials. They are reshaped 
        to a 3-D array with the last dimension representing 
        the trailing dimensions of the original coefficient array. 
    axis : int 
        Interpolation axis. 
 
    Methods 
    ------- 
    __call__ 
    derivative 
    antiderivative 
    integrate 
    solve 
    roots 
    extend 
    from_spline 
    from_bernstein_basis 
    construct_fast 
 
    See also 
    -------- 
    BPoly : piecewise polynomials in the Bernstein basis 
 
    Notes 
    ----- 
    High-order polynomials in the power basis can be numerically 
    unstable. Precision problems can start to appear for orders 
    larger than 20-30. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s0">_evaluate(self</span><span class="s2">, </span><span class="s0">x</span><span class="s2">, </span><span class="s0">nu</span><span class="s2">, </span><span class="s0">extrapolate</span><span class="s2">, </span><span class="s0">out):</span>
        <span class="s0">_ppoly.evaluate(self.c.reshape(self.c.shape[</span><span class="s4">0</span><span class="s0">]</span><span class="s2">, </span><span class="s0">self.c.shape[</span><span class="s4">1</span><span class="s0">]</span><span class="s2">, </span><span class="s0">-</span><span class="s4">1</span><span class="s0">)</span><span class="s2">,</span>
                        <span class="s0">self.x</span><span class="s2">, </span><span class="s0">x</span><span class="s2">, </span><span class="s0">nu</span><span class="s2">, </span><span class="s0">bool(extrapolate)</span><span class="s2">, </span><span class="s0">out)</span>

    <span class="s2">def </span><span class="s0">derivative(self</span><span class="s2">, </span><span class="s0">nu=</span><span class="s4">1</span><span class="s0">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Construct a new piecewise polynomial representing the derivative. 
 
        Parameters 
        ---------- 
        nu : int, optional 
            Order of derivative to evaluate. Default is 1, i.e., compute the 
            first derivative. If negative, the antiderivative is returned. 
 
        Returns 
        ------- 
        pp : PPoly 
            Piecewise polynomial of order k2 = k - n representing the derivative 
            of this polynomial. 
 
        Notes 
        ----- 
        Derivatives are evaluated piecewise for each polynomial 
        segment, even if the polynomial is not differentiable at the 
        breakpoints. The polynomial intervals are considered half-open, 
        ``[a, b)``, except for the last interval which is closed 
        ``[a, b]``. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s0">nu &lt; </span><span class="s4">0</span><span class="s0">:</span>
            <span class="s2">return </span><span class="s0">self.antiderivative(-nu)</span>

        <span class="s5"># reduce order</span>
        <span class="s2">if </span><span class="s0">nu == </span><span class="s4">0</span><span class="s0">:</span>
            <span class="s0">c2 = self.c.copy()</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s0">c2 = self.c[:-nu</span><span class="s2">, </span><span class="s0">:].copy()</span>

        <span class="s2">if </span><span class="s0">c2.shape[</span><span class="s4">0</span><span class="s0">] == </span><span class="s4">0</span><span class="s0">:</span>
            <span class="s5"># derivative of order 0 is zero</span>
            <span class="s0">c2 = np.zeros((</span><span class="s4">1</span><span class="s2">,</span><span class="s0">) + c2.shape[</span><span class="s4">1</span><span class="s0">:]</span><span class="s2">, </span><span class="s0">dtype=c2.dtype)</span>

        <span class="s5"># multiply by the correct rising factorials</span>
        <span class="s0">factor = spec.poch(np.arange(c2.shape[</span><span class="s4">0</span><span class="s0">]</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s0">-</span><span class="s4">1</span><span class="s0">)</span><span class="s2">, </span><span class="s0">nu)</span>
        <span class="s0">c2 *= factor[(slice(</span><span class="s2">None</span><span class="s0">)</span><span class="s2">,</span><span class="s0">) + (</span><span class="s2">None,</span><span class="s0">)*(c2.ndim-</span><span class="s4">1</span><span class="s0">)]</span>

        <span class="s5"># construct a compatible polynomial</span>
        <span class="s2">return </span><span class="s0">self.construct_fast(c2</span><span class="s2">, </span><span class="s0">self.x</span><span class="s2">, </span><span class="s0">self.extrapolate</span><span class="s2">, </span><span class="s0">self.axis)</span>

    <span class="s2">def </span><span class="s0">antiderivative(self</span><span class="s2">, </span><span class="s0">nu=</span><span class="s4">1</span><span class="s0">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Construct a new piecewise polynomial representing the antiderivative. 
 
        Antiderivative is also the indefinite integral of the function, 
        and derivative is its inverse operation. 
 
        Parameters 
        ---------- 
        nu : int, optional 
            Order of antiderivative to evaluate. Default is 1, i.e., compute 
            the first integral. If negative, the derivative is returned. 
 
        Returns 
        ------- 
        pp : PPoly 
            Piecewise polynomial of order k2 = k + n representing 
            the antiderivative of this polynomial. 
 
        Notes 
        ----- 
        The antiderivative returned by this function is continuous and 
        continuously differentiable to order n-1, up to floating point 
        rounding error. 
 
        If antiderivative is computed and ``self.extrapolate='periodic'``, 
        it will be set to False for the returned instance. This is done because 
        the antiderivative is no longer periodic and its correct evaluation 
        outside of the initially given x interval is difficult. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s0">nu &lt;= </span><span class="s4">0</span><span class="s0">:</span>
            <span class="s2">return </span><span class="s0">self.derivative(-nu)</span>

        <span class="s0">c = np.zeros((self.c.shape[</span><span class="s4">0</span><span class="s0">] + nu</span><span class="s2">, </span><span class="s0">self.c.shape[</span><span class="s4">1</span><span class="s0">]) + self.c.shape[</span><span class="s4">2</span><span class="s0">:]</span><span class="s2">,</span>
                     <span class="s0">dtype=self.c.dtype)</span>
        <span class="s0">c[:-nu] = self.c</span>

        <span class="s5"># divide by the correct rising factorials</span>
        <span class="s0">factor = spec.poch(np.arange(self.c.shape[</span><span class="s4">0</span><span class="s0">]</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s0">-</span><span class="s4">1</span><span class="s0">)</span><span class="s2">, </span><span class="s0">nu)</span>
        <span class="s0">c[:-nu] /= factor[(slice(</span><span class="s2">None</span><span class="s0">)</span><span class="s2">,</span><span class="s0">) + (</span><span class="s2">None,</span><span class="s0">)*(c.ndim-</span><span class="s4">1</span><span class="s0">)]</span>

        <span class="s5"># fix continuity of added degrees of freedom</span>
        <span class="s0">self._ensure_c_contiguous()</span>
        <span class="s0">_ppoly.fix_continuity(c.reshape(c.shape[</span><span class="s4">0</span><span class="s0">]</span><span class="s2">, </span><span class="s0">c.shape[</span><span class="s4">1</span><span class="s0">]</span><span class="s2">, </span><span class="s0">-</span><span class="s4">1</span><span class="s0">)</span><span class="s2">,</span>
                              <span class="s0">self.x</span><span class="s2">, </span><span class="s0">nu - </span><span class="s4">1</span><span class="s0">)</span>

        <span class="s2">if </span><span class="s0">self.extrapolate == </span><span class="s1">'periodic'</span><span class="s0">:</span>
            <span class="s0">extrapolate = </span><span class="s2">False</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s0">extrapolate = self.extrapolate</span>

        <span class="s5"># construct a compatible polynomial</span>
        <span class="s2">return </span><span class="s0">self.construct_fast(c</span><span class="s2">, </span><span class="s0">self.x</span><span class="s2">, </span><span class="s0">extrapolate</span><span class="s2">, </span><span class="s0">self.axis)</span>

    <span class="s2">def </span><span class="s0">integrate(self</span><span class="s2">, </span><span class="s0">a</span><span class="s2">, </span><span class="s0">b</span><span class="s2">, </span><span class="s0">extrapolate=</span><span class="s2">None</span><span class="s0">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Compute a definite integral over a piecewise polynomial. 
 
        Parameters 
        ---------- 
        a : float 
            Lower integration bound 
        b : float 
            Upper integration bound 
        extrapolate : {bool, 'periodic', None}, optional 
            If bool, determines whether to extrapolate to out-of-bounds points 
            based on first and last intervals, or to return NaNs. 
            If 'periodic', periodic extrapolation is used. 
            If None (default), use `self.extrapolate`. 
 
        Returns 
        ------- 
        ig : array_like 
            Definite integral of the piecewise polynomial over [a, b] 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s0">extrapolate </span><span class="s2">is None</span><span class="s0">:</span>
            <span class="s0">extrapolate = self.extrapolate</span>

        <span class="s5"># Swap integration bounds if needed</span>
        <span class="s0">sign = </span><span class="s4">1</span>
        <span class="s2">if </span><span class="s0">b &lt; a:</span>
            <span class="s0">a</span><span class="s2">, </span><span class="s0">b = b</span><span class="s2">, </span><span class="s0">a</span>
            <span class="s0">sign = -</span><span class="s4">1</span>

        <span class="s0">range_int = np.empty((prod(self.c.shape[</span><span class="s4">2</span><span class="s0">:])</span><span class="s2">,</span><span class="s0">)</span><span class="s2">, </span><span class="s0">dtype=self.c.dtype)</span>
        <span class="s0">self._ensure_c_contiguous()</span>

        <span class="s5"># Compute the integral.</span>
        <span class="s2">if </span><span class="s0">extrapolate == </span><span class="s1">'periodic'</span><span class="s0">:</span>
            <span class="s5"># Split the integral into the part over period (can be several</span>
            <span class="s5"># of them) and the remaining part.</span>

            <span class="s0">xs</span><span class="s2">, </span><span class="s0">xe = self.x[</span><span class="s4">0</span><span class="s0">]</span><span class="s2">, </span><span class="s0">self.x[-</span><span class="s4">1</span><span class="s0">]</span>
            <span class="s0">period = xe - xs</span>
            <span class="s0">interval = b - a</span>
            <span class="s0">n_periods</span><span class="s2">, </span><span class="s0">left = divmod(interval</span><span class="s2">, </span><span class="s0">period)</span>

            <span class="s2">if </span><span class="s0">n_periods &gt; </span><span class="s4">0</span><span class="s0">:</span>
                <span class="s0">_ppoly.integrate(</span>
                    <span class="s0">self.c.reshape(self.c.shape[</span><span class="s4">0</span><span class="s0">]</span><span class="s2">, </span><span class="s0">self.c.shape[</span><span class="s4">1</span><span class="s0">]</span><span class="s2">, </span><span class="s0">-</span><span class="s4">1</span><span class="s0">)</span><span class="s2">,</span>
                    <span class="s0">self.x</span><span class="s2">, </span><span class="s0">xs</span><span class="s2">, </span><span class="s0">xe</span><span class="s2">, False, </span><span class="s0">out=range_int)</span>
                <span class="s0">range_int *= n_periods</span>
            <span class="s2">else</span><span class="s0">:</span>
                <span class="s0">range_int.fill(</span><span class="s4">0</span><span class="s0">)</span>

            <span class="s5"># Map a to [xs, xe], b is always a + left.</span>
            <span class="s0">a = xs + (a - xs) % period</span>
            <span class="s0">b = a + left</span>

            <span class="s5"># If b &lt;= xe then we need to integrate over [a, b], otherwise</span>
            <span class="s5"># over [a, xe] and from xs to what is remained.</span>
            <span class="s0">remainder_int = np.empty_like(range_int)</span>
            <span class="s2">if </span><span class="s0">b &lt;= xe:</span>
                <span class="s0">_ppoly.integrate(</span>
                    <span class="s0">self.c.reshape(self.c.shape[</span><span class="s4">0</span><span class="s0">]</span><span class="s2">, </span><span class="s0">self.c.shape[</span><span class="s4">1</span><span class="s0">]</span><span class="s2">, </span><span class="s0">-</span><span class="s4">1</span><span class="s0">)</span><span class="s2">,</span>
                    <span class="s0">self.x</span><span class="s2">, </span><span class="s0">a</span><span class="s2">, </span><span class="s0">b</span><span class="s2">, False, </span><span class="s0">out=remainder_int)</span>
                <span class="s0">range_int += remainder_int</span>
            <span class="s2">else</span><span class="s0">:</span>
                <span class="s0">_ppoly.integrate(</span>
                    <span class="s0">self.c.reshape(self.c.shape[</span><span class="s4">0</span><span class="s0">]</span><span class="s2">, </span><span class="s0">self.c.shape[</span><span class="s4">1</span><span class="s0">]</span><span class="s2">, </span><span class="s0">-</span><span class="s4">1</span><span class="s0">)</span><span class="s2">,</span>
                    <span class="s0">self.x</span><span class="s2">, </span><span class="s0">a</span><span class="s2">, </span><span class="s0">xe</span><span class="s2">, False, </span><span class="s0">out=remainder_int)</span>
                <span class="s0">range_int += remainder_int</span>

                <span class="s0">_ppoly.integrate(</span>
                    <span class="s0">self.c.reshape(self.c.shape[</span><span class="s4">0</span><span class="s0">]</span><span class="s2">, </span><span class="s0">self.c.shape[</span><span class="s4">1</span><span class="s0">]</span><span class="s2">, </span><span class="s0">-</span><span class="s4">1</span><span class="s0">)</span><span class="s2">,</span>
                    <span class="s0">self.x</span><span class="s2">, </span><span class="s0">xs</span><span class="s2">, </span><span class="s0">xs + left + a - xe</span><span class="s2">, False, </span><span class="s0">out=remainder_int)</span>
                <span class="s0">range_int += remainder_int</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s0">_ppoly.integrate(</span>
                <span class="s0">self.c.reshape(self.c.shape[</span><span class="s4">0</span><span class="s0">]</span><span class="s2">, </span><span class="s0">self.c.shape[</span><span class="s4">1</span><span class="s0">]</span><span class="s2">, </span><span class="s0">-</span><span class="s4">1</span><span class="s0">)</span><span class="s2">,</span>
                <span class="s0">self.x</span><span class="s2">, </span><span class="s0">a</span><span class="s2">, </span><span class="s0">b</span><span class="s2">, </span><span class="s0">bool(extrapolate)</span><span class="s2">, </span><span class="s0">out=range_int)</span>

        <span class="s5"># Return</span>
        <span class="s0">range_int *= sign</span>
        <span class="s2">return </span><span class="s0">range_int.reshape(self.c.shape[</span><span class="s4">2</span><span class="s0">:])</span>

    <span class="s2">def </span><span class="s0">solve(self</span><span class="s2">, </span><span class="s0">y=</span><span class="s4">0.</span><span class="s2">, </span><span class="s0">discontinuity=</span><span class="s2">True, </span><span class="s0">extrapolate=</span><span class="s2">None</span><span class="s0">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Find real solutions of the equation ``pp(x) == y``. 
 
        Parameters 
        ---------- 
        y : float, optional 
            Right-hand side. Default is zero. 
        discontinuity : bool, optional 
            Whether to report sign changes across discontinuities at 
            breakpoints as roots. 
        extrapolate : {bool, 'periodic', None}, optional 
            If bool, determines whether to return roots from the polynomial 
            extrapolated based on first and last intervals, 'periodic' works 
            the same as False. If None (default), use `self.extrapolate`. 
 
        Returns 
        ------- 
        roots : ndarray 
            Roots of the polynomial(s). 
 
            If the PPoly object describes multiple polynomials, the 
            return value is an object array whose each element is an 
            ndarray containing the roots. 
 
        Notes 
        ----- 
        This routine works only on real-valued polynomials. 
 
        If the piecewise polynomial contains sections that are 
        identically zero, the root list will contain the start point 
        of the corresponding interval, followed by a ``nan`` value. 
 
        If the polynomial is discontinuous across a breakpoint, and 
        there is a sign change across the breakpoint, this is reported 
        if the `discont` parameter is True. 
 
        Examples 
        -------- 
 
        Finding roots of ``[x**2 - 1, (x - 1)**2]`` defined on intervals 
        ``[-2, 1], [1, 2]``: 
 
        &gt;&gt;&gt; import numpy as np 
        &gt;&gt;&gt; from scipy.interpolate import PPoly 
        &gt;&gt;&gt; pp = PPoly(np.array([[1, -4, 3], [1, 0, 0]]).T, [-2, 1, 2]) 
        &gt;&gt;&gt; pp.solve() 
        array([-1.,  1.]) 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s0">extrapolate </span><span class="s2">is None</span><span class="s0">:</span>
            <span class="s0">extrapolate = self.extrapolate</span>

        <span class="s0">self._ensure_c_contiguous()</span>

        <span class="s2">if </span><span class="s0">np.issubdtype(self.c.dtype</span><span class="s2">, </span><span class="s0">np.complexfloating):</span>
            <span class="s2">raise </span><span class="s0">ValueError(</span><span class="s1">&quot;Root finding is only for &quot;</span>
                             <span class="s1">&quot;real-valued polynomials&quot;</span><span class="s0">)</span>

        <span class="s0">y = float(y)</span>
        <span class="s0">r = _ppoly.real_roots(self.c.reshape(self.c.shape[</span><span class="s4">0</span><span class="s0">]</span><span class="s2">, </span><span class="s0">self.c.shape[</span><span class="s4">1</span><span class="s0">]</span><span class="s2">, </span><span class="s0">-</span><span class="s4">1</span><span class="s0">)</span><span class="s2">,</span>
                              <span class="s0">self.x</span><span class="s2">, </span><span class="s0">y</span><span class="s2">, </span><span class="s0">bool(discontinuity)</span><span class="s2">,</span>
                              <span class="s0">bool(extrapolate))</span>
        <span class="s2">if </span><span class="s0">self.c.ndim == </span><span class="s4">2</span><span class="s0">:</span>
            <span class="s2">return </span><span class="s0">r[</span><span class="s4">0</span><span class="s0">]</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s0">r2 = np.empty(prod(self.c.shape[</span><span class="s4">2</span><span class="s0">:])</span><span class="s2">, </span><span class="s0">dtype=object)</span>
            <span class="s5"># this for-loop is equivalent to ``r2[...] = r``, but that's broken</span>
            <span class="s5"># in NumPy 1.6.0</span>
            <span class="s2">for </span><span class="s0">ii</span><span class="s2">, </span><span class="s0">root </span><span class="s2">in </span><span class="s0">enumerate(r):</span>
                <span class="s0">r2[ii] = root</span>

            <span class="s2">return </span><span class="s0">r2.reshape(self.c.shape[</span><span class="s4">2</span><span class="s0">:])</span>

    <span class="s2">def </span><span class="s0">roots(self</span><span class="s2">, </span><span class="s0">discontinuity=</span><span class="s2">True, </span><span class="s0">extrapolate=</span><span class="s2">None</span><span class="s0">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Find real roots of the piecewise polynomial. 
 
        Parameters 
        ---------- 
        discontinuity : bool, optional 
            Whether to report sign changes across discontinuities at 
            breakpoints as roots. 
        extrapolate : {bool, 'periodic', None}, optional 
            If bool, determines whether to return roots from the polynomial 
            extrapolated based on first and last intervals, 'periodic' works 
            the same as False. If None (default), use `self.extrapolate`. 
 
        Returns 
        ------- 
        roots : ndarray 
            Roots of the polynomial(s). 
 
            If the PPoly object describes multiple polynomials, the 
            return value is an object array whose each element is an 
            ndarray containing the roots. 
 
        See Also 
        -------- 
        PPoly.solve 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s0">self.solve(</span><span class="s4">0</span><span class="s2">, </span><span class="s0">discontinuity</span><span class="s2">, </span><span class="s0">extrapolate)</span>

    <span class="s0">@classmethod</span>
    <span class="s2">def </span><span class="s0">from_spline(cls</span><span class="s2">, </span><span class="s0">tck</span><span class="s2">, </span><span class="s0">extrapolate=</span><span class="s2">None</span><span class="s0">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Construct a piecewise polynomial from a spline 
 
        Parameters 
        ---------- 
        tck 
            A spline, as returned by `splrep` or a BSpline object. 
        extrapolate : bool or 'periodic', optional 
            If bool, determines whether to extrapolate to out-of-bounds points 
            based on first and last intervals, or to return NaNs. 
            If 'periodic', periodic extrapolation is used. Default is True. 
 
        Examples 
        -------- 
        Construct an interpolating spline and convert it to a `PPoly` instance  
 
        &gt;&gt;&gt; import numpy as np 
        &gt;&gt;&gt; from scipy.interpolate import splrep, PPoly 
        &gt;&gt;&gt; x = np.linspace(0, 1, 11) 
        &gt;&gt;&gt; y = np.sin(2*np.pi*x) 
        &gt;&gt;&gt; tck = splrep(x, y, s=0) 
        &gt;&gt;&gt; p = PPoly.from_spline(tck) 
        &gt;&gt;&gt; isinstance(p, PPoly) 
        True 
 
        Note that this function only supports 1D splines out of the box. 
 
        If the ``tck`` object represents a parametric spline (e.g. constructed 
        by `splprep` or a `BSpline` with ``c.ndim &gt; 1``), you will need to loop 
        over the dimensions manually. 
 
        &gt;&gt;&gt; from scipy.interpolate import splprep, splev 
        &gt;&gt;&gt; t = np.linspace(0, 1, 11) 
        &gt;&gt;&gt; x = np.sin(2*np.pi*t) 
        &gt;&gt;&gt; y = np.cos(2*np.pi*t) 
        &gt;&gt;&gt; (t, c, k), u = splprep([x, y], s=0) 
 
        Note that ``c`` is a list of two arrays of length 11. 
 
        &gt;&gt;&gt; unew = np.arange(0, 1.01, 0.01) 
        &gt;&gt;&gt; out = splev(unew, (t, c, k)) 
 
        To convert this spline to the power basis, we convert each 
        component of the list of b-spline coefficients, ``c``, into the 
        corresponding cubic polynomial. 
 
        &gt;&gt;&gt; polys = [PPoly.from_spline((t, cj, k)) for cj in c] 
        &gt;&gt;&gt; polys[0].c.shape 
        (4, 14) 
 
        Note that the coefficients of the polynomials `polys` are in the 
        power basis and their dimensions reflect just that: here 4 is the order 
        (degree+1), and 14 is the number of intervals---which is nothing but 
        the length of the knot array of the original `tck` minus one. 
 
        Optionally, we can stack the components into a single `PPoly` along 
        the third dimension: 
 
        &gt;&gt;&gt; cc = np.dstack([p.c for p in polys])    # has shape = (4, 14, 2) 
        &gt;&gt;&gt; poly = PPoly(cc, polys[0].x) 
        &gt;&gt;&gt; np.allclose(poly(unew).T,     # note the transpose to match `splev` 
        ...             out, atol=1e-15) 
        True 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s0">isinstance(tck</span><span class="s2">, </span><span class="s0">BSpline):</span>
            <span class="s0">t</span><span class="s2">, </span><span class="s0">c</span><span class="s2">, </span><span class="s0">k = tck.tck</span>
            <span class="s2">if </span><span class="s0">extrapolate </span><span class="s2">is None</span><span class="s0">:</span>
                <span class="s0">extrapolate = tck.extrapolate</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s0">t</span><span class="s2">, </span><span class="s0">c</span><span class="s2">, </span><span class="s0">k = tck</span>

        <span class="s0">cvals = np.empty((k + </span><span class="s4">1</span><span class="s2">, </span><span class="s0">len(t)-</span><span class="s4">1</span><span class="s0">)</span><span class="s2">, </span><span class="s0">dtype=c.dtype)</span>
        <span class="s2">for </span><span class="s0">m </span><span class="s2">in </span><span class="s0">range(k</span><span class="s2">, </span><span class="s0">-</span><span class="s4">1</span><span class="s2">, </span><span class="s0">-</span><span class="s4">1</span><span class="s0">):</span>
            <span class="s0">y = _fitpack_py.splev(t[:-</span><span class="s4">1</span><span class="s0">]</span><span class="s2">, </span><span class="s0">tck</span><span class="s2">, </span><span class="s0">der=m)</span>
            <span class="s0">cvals[k - m</span><span class="s2">, </span><span class="s0">:] = y/spec.gamma(m+</span><span class="s4">1</span><span class="s0">)</span>

        <span class="s2">return </span><span class="s0">cls.construct_fast(cvals</span><span class="s2">, </span><span class="s0">t</span><span class="s2">, </span><span class="s0">extrapolate)</span>

    <span class="s0">@classmethod</span>
    <span class="s2">def </span><span class="s0">from_bernstein_basis(cls</span><span class="s2">, </span><span class="s0">bp</span><span class="s2">, </span><span class="s0">extrapolate=</span><span class="s2">None</span><span class="s0">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Construct a piecewise polynomial in the power basis 
        from a polynomial in Bernstein basis. 
 
        Parameters 
        ---------- 
        bp : BPoly 
            A Bernstein basis polynomial, as created by BPoly 
        extrapolate : bool or 'periodic', optional 
            If bool, determines whether to extrapolate to out-of-bounds points 
            based on first and last intervals, or to return NaNs. 
            If 'periodic', periodic extrapolation is used. Default is True. 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s0">isinstance(bp</span><span class="s2">, </span><span class="s0">BPoly):</span>
            <span class="s2">raise </span><span class="s0">TypeError(</span><span class="s1">&quot;.from_bernstein_basis only accepts BPoly instances. &quot;</span>
                            <span class="s1">&quot;Got %s instead.&quot; </span><span class="s0">% type(bp))</span>

        <span class="s0">dx = np.diff(bp.x)</span>
        <span class="s0">k = bp.c.shape[</span><span class="s4">0</span><span class="s0">] - </span><span class="s4">1  </span><span class="s5"># polynomial order</span>

        <span class="s0">rest = (</span><span class="s2">None,</span><span class="s0">)*(bp.c.ndim-</span><span class="s4">2</span><span class="s0">)</span>

        <span class="s0">c = np.zeros_like(bp.c)</span>
        <span class="s2">for </span><span class="s0">a </span><span class="s2">in </span><span class="s0">range(k+</span><span class="s4">1</span><span class="s0">):</span>
            <span class="s0">factor = (-</span><span class="s4">1</span><span class="s0">)**a * comb(k</span><span class="s2">, </span><span class="s0">a) * bp.c[a]</span>
            <span class="s2">for </span><span class="s0">s </span><span class="s2">in </span><span class="s0">range(a</span><span class="s2">, </span><span class="s0">k+</span><span class="s4">1</span><span class="s0">):</span>
                <span class="s0">val = comb(k-a</span><span class="s2">, </span><span class="s0">s-a) * (-</span><span class="s4">1</span><span class="s0">)**s</span>
                <span class="s0">c[k-s] += factor * val / dx[(slice(</span><span class="s2">None</span><span class="s0">)</span><span class="s2">,</span><span class="s0">)+rest]**s</span>

        <span class="s2">if </span><span class="s0">extrapolate </span><span class="s2">is None</span><span class="s0">:</span>
            <span class="s0">extrapolate = bp.extrapolate</span>

        <span class="s2">return </span><span class="s0">cls.construct_fast(c</span><span class="s2">, </span><span class="s0">bp.x</span><span class="s2">, </span><span class="s0">extrapolate</span><span class="s2">, </span><span class="s0">bp.axis)</span>


<span class="s2">class </span><span class="s0">BPoly(_PPolyBase):</span>
    <span class="s3">&quot;&quot;&quot;Piecewise polynomial in terms of coefficients and breakpoints. 
 
    The polynomial between ``x[i]`` and ``x[i + 1]`` is written in the 
    Bernstein polynomial basis:: 
 
        S = sum(c[a, i] * b(a, k; x) for a in range(k+1)), 
 
    where ``k`` is the degree of the polynomial, and:: 
 
        b(a, k; x) = binom(k, a) * t**a * (1 - t)**(k - a), 
 
    with ``t = (x - x[i]) / (x[i+1] - x[i])`` and ``binom`` is the binomial 
    coefficient. 
 
    Parameters 
    ---------- 
    c : ndarray, shape (k, m, ...) 
        Polynomial coefficients, order `k` and `m` intervals 
    x : ndarray, shape (m+1,) 
        Polynomial breakpoints. Must be sorted in either increasing or 
        decreasing order. 
    extrapolate : bool, optional 
        If bool, determines whether to extrapolate to out-of-bounds points 
        based on first and last intervals, or to return NaNs. If 'periodic', 
        periodic extrapolation is used. Default is True. 
    axis : int, optional 
        Interpolation axis. Default is zero. 
 
    Attributes 
    ---------- 
    x : ndarray 
        Breakpoints. 
    c : ndarray 
        Coefficients of the polynomials. They are reshaped 
        to a 3-D array with the last dimension representing 
        the trailing dimensions of the original coefficient array. 
    axis : int 
        Interpolation axis. 
 
    Methods 
    ------- 
    __call__ 
    extend 
    derivative 
    antiderivative 
    integrate 
    construct_fast 
    from_power_basis 
    from_derivatives 
 
    See also 
    -------- 
    PPoly : piecewise polynomials in the power basis 
 
    Notes 
    ----- 
    Properties of Bernstein polynomials are well documented in the literature, 
    see for example [1]_ [2]_ [3]_. 
 
    References 
    ---------- 
    .. [1] https://en.wikipedia.org/wiki/Bernstein_polynomial 
 
    .. [2] Kenneth I. Joy, Bernstein polynomials, 
       http://www.idav.ucdavis.edu/education/CAGDNotes/Bernstein-Polynomials.pdf 
 
    .. [3] E. H. Doha, A. H. Bhrawy, and M. A. Saker, Boundary Value Problems, 
           vol 2011, article ID 829546, :doi:`10.1155/2011/829543`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.interpolate import BPoly 
    &gt;&gt;&gt; x = [0, 1] 
    &gt;&gt;&gt; c = [[1], [2], [3]] 
    &gt;&gt;&gt; bp = BPoly(c, x) 
 
    This creates a 2nd order polynomial 
 
    .. math:: 
 
        B(x) = 1 \\times b_{0, 2}(x) + 2 \\times b_{1, 2}(x) + 3 \\times b_{2, 2}(x) \\\\ 
             = 1 \\times (1-x)^2 + 2 \\times 2 x (1 - x) + 3 \\times x^2 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s0">_evaluate(self</span><span class="s2">, </span><span class="s0">x</span><span class="s2">, </span><span class="s0">nu</span><span class="s2">, </span><span class="s0">extrapolate</span><span class="s2">, </span><span class="s0">out):</span>
        <span class="s0">_ppoly.evaluate_bernstein(</span>
            <span class="s0">self.c.reshape(self.c.shape[</span><span class="s4">0</span><span class="s0">]</span><span class="s2">, </span><span class="s0">self.c.shape[</span><span class="s4">1</span><span class="s0">]</span><span class="s2">, </span><span class="s0">-</span><span class="s4">1</span><span class="s0">)</span><span class="s2">,</span>
            <span class="s0">self.x</span><span class="s2">, </span><span class="s0">x</span><span class="s2">, </span><span class="s0">nu</span><span class="s2">, </span><span class="s0">bool(extrapolate)</span><span class="s2">, </span><span class="s0">out)</span>

    <span class="s2">def </span><span class="s0">derivative(self</span><span class="s2">, </span><span class="s0">nu=</span><span class="s4">1</span><span class="s0">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Construct a new piecewise polynomial representing the derivative. 
 
        Parameters 
        ---------- 
        nu : int, optional 
            Order of derivative to evaluate. Default is 1, i.e., compute the 
            first derivative. If negative, the antiderivative is returned. 
 
        Returns 
        ------- 
        bp : BPoly 
            Piecewise polynomial of order k - nu representing the derivative of 
            this polynomial. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s0">nu &lt; </span><span class="s4">0</span><span class="s0">:</span>
            <span class="s2">return </span><span class="s0">self.antiderivative(-nu)</span>

        <span class="s2">if </span><span class="s0">nu &gt; </span><span class="s4">1</span><span class="s0">:</span>
            <span class="s0">bp = self</span>
            <span class="s2">for </span><span class="s0">k </span><span class="s2">in </span><span class="s0">range(nu):</span>
                <span class="s0">bp = bp.derivative()</span>
            <span class="s2">return </span><span class="s0">bp</span>

        <span class="s5"># reduce order</span>
        <span class="s2">if </span><span class="s0">nu == </span><span class="s4">0</span><span class="s0">:</span>
            <span class="s0">c2 = self.c.copy()</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s5"># For a polynomial</span>
            <span class="s5">#    B(x) = \sum_{a=0}^{k} c_a b_{a, k}(x),</span>
            <span class="s5"># we use the fact that</span>
            <span class="s5">#   b'_{a, k} = k ( b_{a-1, k-1} - b_{a, k-1} ),</span>
            <span class="s5"># which leads to</span>
            <span class="s5">#   B'(x) = \sum_{a=0}^{k-1} (c_{a+1} - c_a) b_{a, k-1}</span>
            <span class="s5">#</span>
            <span class="s5"># finally, for an interval [y, y + dy] with dy != 1,</span>
            <span class="s5"># we need to correct for an extra power of dy</span>

            <span class="s0">rest = (</span><span class="s2">None,</span><span class="s0">)*(self.c.ndim-</span><span class="s4">2</span><span class="s0">)</span>

            <span class="s0">k = self.c.shape[</span><span class="s4">0</span><span class="s0">] - </span><span class="s4">1</span>
            <span class="s0">dx = np.diff(self.x)[(</span><span class="s2">None, </span><span class="s0">slice(</span><span class="s2">None</span><span class="s0">))+rest]</span>
            <span class="s0">c2 = k * np.diff(self.c</span><span class="s2">, </span><span class="s0">axis=</span><span class="s4">0</span><span class="s0">) / dx</span>

        <span class="s2">if </span><span class="s0">c2.shape[</span><span class="s4">0</span><span class="s0">] == </span><span class="s4">0</span><span class="s0">:</span>
            <span class="s5"># derivative of order 0 is zero</span>
            <span class="s0">c2 = np.zeros((</span><span class="s4">1</span><span class="s2">,</span><span class="s0">) + c2.shape[</span><span class="s4">1</span><span class="s0">:]</span><span class="s2">, </span><span class="s0">dtype=c2.dtype)</span>

        <span class="s5"># construct a compatible polynomial</span>
        <span class="s2">return </span><span class="s0">self.construct_fast(c2</span><span class="s2">, </span><span class="s0">self.x</span><span class="s2">, </span><span class="s0">self.extrapolate</span><span class="s2">, </span><span class="s0">self.axis)</span>

    <span class="s2">def </span><span class="s0">antiderivative(self</span><span class="s2">, </span><span class="s0">nu=</span><span class="s4">1</span><span class="s0">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Construct a new piecewise polynomial representing the antiderivative. 
 
        Parameters 
        ---------- 
        nu : int, optional 
            Order of antiderivative to evaluate. Default is 1, i.e., compute 
            the first integral. If negative, the derivative is returned. 
 
        Returns 
        ------- 
        bp : BPoly 
            Piecewise polynomial of order k + nu representing the 
            antiderivative of this polynomial. 
 
        Notes 
        ----- 
        If antiderivative is computed and ``self.extrapolate='periodic'``, 
        it will be set to False for the returned instance. This is done because 
        the antiderivative is no longer periodic and its correct evaluation 
        outside of the initially given x interval is difficult. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s0">nu &lt;= </span><span class="s4">0</span><span class="s0">:</span>
            <span class="s2">return </span><span class="s0">self.derivative(-nu)</span>

        <span class="s2">if </span><span class="s0">nu &gt; </span><span class="s4">1</span><span class="s0">:</span>
            <span class="s0">bp = self</span>
            <span class="s2">for </span><span class="s0">k </span><span class="s2">in </span><span class="s0">range(nu):</span>
                <span class="s0">bp = bp.antiderivative()</span>
            <span class="s2">return </span><span class="s0">bp</span>

        <span class="s5"># Construct the indefinite integrals on individual intervals</span>
        <span class="s0">c</span><span class="s2">, </span><span class="s0">x = self.c</span><span class="s2">, </span><span class="s0">self.x</span>
        <span class="s0">k = c.shape[</span><span class="s4">0</span><span class="s0">]</span>
        <span class="s0">c2 = np.zeros((k+</span><span class="s4">1</span><span class="s2">,</span><span class="s0">) + c.shape[</span><span class="s4">1</span><span class="s0">:]</span><span class="s2">, </span><span class="s0">dtype=c.dtype)</span>

        <span class="s0">c2[</span><span class="s4">1</span><span class="s0">:</span><span class="s2">, </span><span class="s0">...] = np.cumsum(c</span><span class="s2">, </span><span class="s0">axis=</span><span class="s4">0</span><span class="s0">) / k</span>
        <span class="s0">delta = x[</span><span class="s4">1</span><span class="s0">:] - x[:-</span><span class="s4">1</span><span class="s0">]</span>
        <span class="s0">c2 *= delta[(</span><span class="s2">None, </span><span class="s0">slice(</span><span class="s2">None</span><span class="s0">)) + (</span><span class="s2">None,</span><span class="s0">)*(c.ndim-</span><span class="s4">2</span><span class="s0">)]</span>

        <span class="s5"># Now fix continuity: on the very first interval, take the integration</span>
        <span class="s5"># constant to be zero; on an interval [x_j, x_{j+1}) with j&gt;0,</span>
        <span class="s5"># the integration constant is then equal to the jump of the `bp` at x_j.</span>
        <span class="s5"># The latter is given by the coefficient of B_{n+1, n+1}</span>
        <span class="s5"># *on the previous interval* (other B. polynomials are zero at the</span>
        <span class="s5"># breakpoint). Finally, use the fact that BPs form a partition of unity.</span>
        <span class="s0">c2[:</span><span class="s2">,</span><span class="s4">1</span><span class="s0">:] += np.cumsum(c2[k</span><span class="s2">, </span><span class="s0">:]</span><span class="s2">, </span><span class="s0">axis=</span><span class="s4">0</span><span class="s0">)[:-</span><span class="s4">1</span><span class="s0">]</span>

        <span class="s2">if </span><span class="s0">self.extrapolate == </span><span class="s1">'periodic'</span><span class="s0">:</span>
            <span class="s0">extrapolate = </span><span class="s2">False</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s0">extrapolate = self.extrapolate</span>

        <span class="s2">return </span><span class="s0">self.construct_fast(c2</span><span class="s2">, </span><span class="s0">x</span><span class="s2">, </span><span class="s0">extrapolate</span><span class="s2">, </span><span class="s0">axis=self.axis)</span>

    <span class="s2">def </span><span class="s0">integrate(self</span><span class="s2">, </span><span class="s0">a</span><span class="s2">, </span><span class="s0">b</span><span class="s2">, </span><span class="s0">extrapolate=</span><span class="s2">None</span><span class="s0">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Compute a definite integral over a piecewise polynomial. 
 
        Parameters 
        ---------- 
        a : float 
            Lower integration bound 
        b : float 
            Upper integration bound 
        extrapolate : {bool, 'periodic', None}, optional 
            Whether to extrapolate to out-of-bounds points based on first 
            and last intervals, or to return NaNs. If 'periodic', periodic 
            extrapolation is used. If None (default), use `self.extrapolate`. 
 
        Returns 
        ------- 
        array_like 
            Definite integral of the piecewise polynomial over [a, b] 
 
        &quot;&quot;&quot;</span>
        <span class="s5"># XXX: can probably use instead the fact that</span>
        <span class="s5"># \int_0^{1} B_{j, n}(x) \dx = 1/(n+1)</span>
        <span class="s0">ib = self.antiderivative()</span>
        <span class="s2">if </span><span class="s0">extrapolate </span><span class="s2">is None</span><span class="s0">:</span>
            <span class="s0">extrapolate = self.extrapolate</span>

        <span class="s5"># ib.extrapolate shouldn't be 'periodic', it is converted to</span>
        <span class="s5"># False for 'periodic. in antiderivative() call.</span>
        <span class="s2">if </span><span class="s0">extrapolate != </span><span class="s1">'periodic'</span><span class="s0">:</span>
            <span class="s0">ib.extrapolate = extrapolate</span>

        <span class="s2">if </span><span class="s0">extrapolate == </span><span class="s1">'periodic'</span><span class="s0">:</span>
            <span class="s5"># Split the integral into the part over period (can be several</span>
            <span class="s5"># of them) and the remaining part.</span>

            <span class="s5"># For simplicity and clarity convert to a &lt;= b case.</span>
            <span class="s2">if </span><span class="s0">a &lt;= b:</span>
                <span class="s0">sign = </span><span class="s4">1</span>
            <span class="s2">else</span><span class="s0">:</span>
                <span class="s0">a</span><span class="s2">, </span><span class="s0">b = b</span><span class="s2">, </span><span class="s0">a</span>
                <span class="s0">sign = -</span><span class="s4">1</span>

            <span class="s0">xs</span><span class="s2">, </span><span class="s0">xe = self.x[</span><span class="s4">0</span><span class="s0">]</span><span class="s2">, </span><span class="s0">self.x[-</span><span class="s4">1</span><span class="s0">]</span>
            <span class="s0">period = xe - xs</span>
            <span class="s0">interval = b - a</span>
            <span class="s0">n_periods</span><span class="s2">, </span><span class="s0">left = divmod(interval</span><span class="s2">, </span><span class="s0">period)</span>
            <span class="s0">res = n_periods * (ib(xe) - ib(xs))</span>

            <span class="s5"># Map a and b to [xs, xe].</span>
            <span class="s0">a = xs + (a - xs) % period</span>
            <span class="s0">b = a + left</span>

            <span class="s5"># If b &lt;= xe then we need to integrate over [a, b], otherwise</span>
            <span class="s5"># over [a, xe] and from xs to what is remained.</span>
            <span class="s2">if </span><span class="s0">b &lt;= xe:</span>
                <span class="s0">res += ib(b) - ib(a)</span>
            <span class="s2">else</span><span class="s0">:</span>
                <span class="s0">res += ib(xe) - ib(a) + ib(xs + left + a - xe) - ib(xs)</span>

            <span class="s2">return </span><span class="s0">sign * res</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s2">return </span><span class="s0">ib(b) - ib(a)</span>

    <span class="s2">def </span><span class="s0">extend(self</span><span class="s2">, </span><span class="s0">c</span><span class="s2">, </span><span class="s0">x):</span>
        <span class="s0">k = max(self.c.shape[</span><span class="s4">0</span><span class="s0">]</span><span class="s2">, </span><span class="s0">c.shape[</span><span class="s4">0</span><span class="s0">])</span>
        <span class="s0">self.c = self._raise_degree(self.c</span><span class="s2">, </span><span class="s0">k - self.c.shape[</span><span class="s4">0</span><span class="s0">])</span>
        <span class="s0">c = self._raise_degree(c</span><span class="s2">, </span><span class="s0">k - c.shape[</span><span class="s4">0</span><span class="s0">])</span>
        <span class="s2">return </span><span class="s0">_PPolyBase.extend(self</span><span class="s2">, </span><span class="s0">c</span><span class="s2">, </span><span class="s0">x)</span>
    <span class="s0">extend.__doc__ = _PPolyBase.extend.__doc__</span>

    <span class="s0">@classmethod</span>
    <span class="s2">def </span><span class="s0">from_power_basis(cls</span><span class="s2">, </span><span class="s0">pp</span><span class="s2">, </span><span class="s0">extrapolate=</span><span class="s2">None</span><span class="s0">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Construct a piecewise polynomial in Bernstein basis 
        from a power basis polynomial. 
 
        Parameters 
        ---------- 
        pp : PPoly 
            A piecewise polynomial in the power basis 
        extrapolate : bool or 'periodic', optional 
            If bool, determines whether to extrapolate to out-of-bounds points 
            based on first and last intervals, or to return NaNs. 
            If 'periodic', periodic extrapolation is used. Default is True. 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s0">isinstance(pp</span><span class="s2">, </span><span class="s0">PPoly):</span>
            <span class="s2">raise </span><span class="s0">TypeError(</span><span class="s1">&quot;.from_power_basis only accepts PPoly instances. &quot;</span>
                            <span class="s1">&quot;Got %s instead.&quot; </span><span class="s0">% type(pp))</span>

        <span class="s0">dx = np.diff(pp.x)</span>
        <span class="s0">k = pp.c.shape[</span><span class="s4">0</span><span class="s0">] - </span><span class="s4">1   </span><span class="s5"># polynomial order</span>

        <span class="s0">rest = (</span><span class="s2">None,</span><span class="s0">)*(pp.c.ndim-</span><span class="s4">2</span><span class="s0">)</span>

        <span class="s0">c = np.zeros_like(pp.c)</span>
        <span class="s2">for </span><span class="s0">a </span><span class="s2">in </span><span class="s0">range(k+</span><span class="s4">1</span><span class="s0">):</span>
            <span class="s0">factor = pp.c[a] / comb(k</span><span class="s2">, </span><span class="s0">k-a) * dx[(slice(</span><span class="s2">None</span><span class="s0">)</span><span class="s2">,</span><span class="s0">)+rest]**(k-a)</span>
            <span class="s2">for </span><span class="s0">j </span><span class="s2">in </span><span class="s0">range(k-a</span><span class="s2">, </span><span class="s0">k+</span><span class="s4">1</span><span class="s0">):</span>
                <span class="s0">c[j] += factor * comb(j</span><span class="s2">, </span><span class="s0">k-a)</span>

        <span class="s2">if </span><span class="s0">extrapolate </span><span class="s2">is None</span><span class="s0">:</span>
            <span class="s0">extrapolate = pp.extrapolate</span>

        <span class="s2">return </span><span class="s0">cls.construct_fast(c</span><span class="s2">, </span><span class="s0">pp.x</span><span class="s2">, </span><span class="s0">extrapolate</span><span class="s2">, </span><span class="s0">pp.axis)</span>

    <span class="s0">@classmethod</span>
    <span class="s2">def </span><span class="s0">from_derivatives(cls</span><span class="s2">, </span><span class="s0">xi</span><span class="s2">, </span><span class="s0">yi</span><span class="s2">, </span><span class="s0">orders=</span><span class="s2">None, </span><span class="s0">extrapolate=</span><span class="s2">None</span><span class="s0">):</span>
        <span class="s3">&quot;&quot;&quot;Construct a piecewise polynomial in the Bernstein basis, 
        compatible with the specified values and derivatives at breakpoints. 
 
        Parameters 
        ---------- 
        xi : array_like 
            sorted 1-D array of x-coordinates 
        yi : array_like or list of array_likes 
            ``yi[i][j]`` is the ``j``th derivative known at ``xi[i]`` 
        orders : None or int or array_like of ints. Default: None. 
            Specifies the degree of local polynomials. If not None, some 
            derivatives are ignored. 
        extrapolate : bool or 'periodic', optional 
            If bool, determines whether to extrapolate to out-of-bounds points 
            based on first and last intervals, or to return NaNs. 
            If 'periodic', periodic extrapolation is used. Default is True. 
 
        Notes 
        ----- 
        If ``k`` derivatives are specified at a breakpoint ``x``, the 
        constructed polynomial is exactly ``k`` times continuously 
        differentiable at ``x``, unless the ``order`` is provided explicitly. 
        In the latter case, the smoothness of the polynomial at 
        the breakpoint is controlled by the ``order``. 
 
        Deduces the number of derivatives to match at each end 
        from ``order`` and the number of derivatives available. If 
        possible it uses the same number of derivatives from 
        each end; if the number is odd it tries to take the 
        extra one from y2. In any case if not enough derivatives 
        are available at one end or another it draws enough to 
        make up the total from the other end. 
 
        If the order is too high and not enough derivatives are available, 
        an exception is raised. 
 
        Examples 
        -------- 
 
        &gt;&gt;&gt; from scipy.interpolate import BPoly 
        &gt;&gt;&gt; BPoly.from_derivatives([0, 1], [[1, 2], [3, 4]]) 
 
        Creates a polynomial `f(x)` of degree 3, defined on `[0, 1]` 
        such that `f(0) = 1, df/dx(0) = 2, f(1) = 3, df/dx(1) = 4` 
 
        &gt;&gt;&gt; BPoly.from_derivatives([0, 1, 2], [[0, 1], [0], [2]]) 
 
        Creates a piecewise polynomial `f(x)`, such that 
        `f(0) = f(1) = 0`, `f(2) = 2`, and `df/dx(0) = 1`. 
        Based on the number of derivatives provided, the order of the 
        local polynomials is 2 on `[0, 1]` and 1 on `[1, 2]`. 
        Notice that no restriction is imposed on the derivatives at 
        ``x = 1`` and ``x = 2``. 
 
        Indeed, the explicit form of the polynomial is:: 
 
            f(x) = | x * (1 - x),  0 &lt;= x &lt; 1 
                   | 2 * (x - 1),  1 &lt;= x &lt;= 2 
 
        So that f'(1-0) = -1 and f'(1+0) = 2 
 
        &quot;&quot;&quot;</span>
        <span class="s0">xi = np.asarray(xi)</span>
        <span class="s2">if </span><span class="s0">len(xi) != len(yi):</span>
            <span class="s2">raise </span><span class="s0">ValueError(</span><span class="s1">&quot;xi and yi need to have the same length&quot;</span><span class="s0">)</span>
        <span class="s2">if </span><span class="s0">np.any(xi[</span><span class="s4">1</span><span class="s0">:] - xi[:</span><span class="s4">1</span><span class="s0">] &lt;= </span><span class="s4">0</span><span class="s0">):</span>
            <span class="s2">raise </span><span class="s0">ValueError(</span><span class="s1">&quot;x coordinates are not in increasing order&quot;</span><span class="s0">)</span>

        <span class="s5"># number of intervals</span>
        <span class="s0">m = len(xi) - </span><span class="s4">1</span>

        <span class="s5"># global poly order is k-1, local orders are &lt;=k and can vary</span>
        <span class="s2">try</span><span class="s0">:</span>
            <span class="s0">k = max(len(yi[i]) + len(yi[i+</span><span class="s4">1</span><span class="s0">]) </span><span class="s2">for </span><span class="s0">i </span><span class="s2">in </span><span class="s0">range(m))</span>
        <span class="s2">except </span><span class="s0">TypeError </span><span class="s2">as </span><span class="s0">e:</span>
            <span class="s2">raise </span><span class="s0">ValueError(</span>
                <span class="s1">&quot;Using a 1-D array for y? Please .reshape(-1, 1).&quot;</span>
            <span class="s0">) </span><span class="s2">from </span><span class="s0">e</span>

        <span class="s2">if </span><span class="s0">orders </span><span class="s2">is None</span><span class="s0">:</span>
            <span class="s0">orders = [</span><span class="s2">None</span><span class="s0">] * m</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s2">if </span><span class="s0">isinstance(orders</span><span class="s2">, </span><span class="s0">(int</span><span class="s2">, </span><span class="s0">np.integer)):</span>
                <span class="s0">orders = [orders] * m</span>
            <span class="s0">k = max(k</span><span class="s2">, </span><span class="s0">max(orders))</span>

            <span class="s2">if </span><span class="s0">any(o &lt;= </span><span class="s4">0 </span><span class="s2">for </span><span class="s0">o </span><span class="s2">in </span><span class="s0">orders):</span>
                <span class="s2">raise </span><span class="s0">ValueError(</span><span class="s1">&quot;Orders must be positive.&quot;</span><span class="s0">)</span>

        <span class="s0">c = []</span>
        <span class="s2">for </span><span class="s0">i </span><span class="s2">in </span><span class="s0">range(m):</span>
            <span class="s0">y1</span><span class="s2">, </span><span class="s0">y2 = yi[i]</span><span class="s2">, </span><span class="s0">yi[i+</span><span class="s4">1</span><span class="s0">]</span>
            <span class="s2">if </span><span class="s0">orders[i] </span><span class="s2">is None</span><span class="s0">:</span>
                <span class="s0">n1</span><span class="s2">, </span><span class="s0">n2 = len(y1)</span><span class="s2">, </span><span class="s0">len(y2)</span>
            <span class="s2">else</span><span class="s0">:</span>
                <span class="s0">n = orders[i]+</span><span class="s4">1</span>
                <span class="s0">n1 = min(n//</span><span class="s4">2</span><span class="s2">, </span><span class="s0">len(y1))</span>
                <span class="s0">n2 = min(n - n1</span><span class="s2">, </span><span class="s0">len(y2))</span>
                <span class="s0">n1 = min(n - n2</span><span class="s2">, </span><span class="s0">len(y2))</span>
                <span class="s2">if </span><span class="s0">n1+n2 != n:</span>
                    <span class="s0">mesg = (</span><span class="s1">&quot;Point %g has %d derivatives, point %g&quot;</span>
                            <span class="s1">&quot; has %d derivatives, but order %d requested&quot; </span><span class="s0">% (</span>
                               <span class="s0">xi[i]</span><span class="s2">, </span><span class="s0">len(y1)</span><span class="s2">, </span><span class="s0">xi[i+</span><span class="s4">1</span><span class="s0">]</span><span class="s2">, </span><span class="s0">len(y2)</span><span class="s2">, </span><span class="s0">orders[i]))</span>
                    <span class="s2">raise </span><span class="s0">ValueError(mesg)</span>

                <span class="s2">if not </span><span class="s0">(n1 &lt;= len(y1) </span><span class="s2">and </span><span class="s0">n2 &lt;= len(y2)):</span>
                    <span class="s2">raise </span><span class="s0">ValueError(</span><span class="s1">&quot;`order` input incompatible with&quot;</span>
                                     <span class="s1">&quot; length y1 or y2.&quot;</span><span class="s0">)</span>

            <span class="s0">b = BPoly._construct_from_derivatives(xi[i]</span><span class="s2">, </span><span class="s0">xi[i+</span><span class="s4">1</span><span class="s0">]</span><span class="s2">,</span>
                                                  <span class="s0">y1[:n1]</span><span class="s2">, </span><span class="s0">y2[:n2])</span>
            <span class="s2">if </span><span class="s0">len(b) &lt; k:</span>
                <span class="s0">b = BPoly._raise_degree(b</span><span class="s2">, </span><span class="s0">k - len(b))</span>
            <span class="s0">c.append(b)</span>

        <span class="s0">c = np.asarray(c)</span>
        <span class="s2">return </span><span class="s0">cls(c.swapaxes(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s0">)</span><span class="s2">, </span><span class="s0">xi</span><span class="s2">, </span><span class="s0">extrapolate)</span>

    <span class="s0">@staticmethod</span>
    <span class="s2">def </span><span class="s0">_construct_from_derivatives(xa</span><span class="s2">, </span><span class="s0">xb</span><span class="s2">, </span><span class="s0">ya</span><span class="s2">, </span><span class="s0">yb):</span>
        <span class="s3">r&quot;&quot;&quot;Compute the coefficients of a polynomial in the Bernstein basis 
        given the values and derivatives at the edges. 
 
        Return the coefficients of a polynomial in the Bernstein basis 
        defined on ``[xa, xb]`` and having the values and derivatives at the 
        endpoints `xa` and `xb` as specified by `ya`` and `yb`. 
        The polynomial constructed is of the minimal possible degree, i.e., 
        if the lengths of `ya` and `yb` are `na` and `nb`, the degree 
        of the polynomial is ``na + nb - 1``. 
 
        Parameters 
        ---------- 
        xa : float 
            Left-hand end point of the interval 
        xb : float 
            Right-hand end point of the interval 
        ya : array_like 
            Derivatives at `xa`. `ya[0]` is the value of the function, and 
            `ya[i]` for ``i &gt; 0`` is the value of the ``i``th derivative. 
        yb : array_like 
            Derivatives at `xb`. 
 
        Returns 
        ------- 
        array 
            coefficient array of a polynomial having specified derivatives 
 
        Notes 
        ----- 
        This uses several facts from life of Bernstein basis functions. 
        First of all, 
 
            .. math:: b'_{a, n} = n (b_{a-1, n-1} - b_{a, n-1}) 
 
        If B(x) is a linear combination of the form 
 
            .. math:: B(x) = \sum_{a=0}^{n} c_a b_{a, n}, 
 
        then :math: B'(x) = n \sum_{a=0}^{n-1} (c_{a+1} - c_{a}) b_{a, n-1}. 
        Iterating the latter one, one finds for the q-th derivative 
 
            .. math:: B^{q}(x) = n!/(n-q)! \sum_{a=0}^{n-q} Q_a b_{a, n-q}, 
 
        with 
 
          .. math:: Q_a = \sum_{j=0}^{q} (-)^{j+q} comb(q, j) c_{j+a} 
 
        This way, only `a=0` contributes to :math: `B^{q}(x = xa)`, and 
        `c_q` are found one by one by iterating `q = 0, ..., na`. 
 
        At ``x = xb`` it's the same with ``a = n - q``. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">ya</span><span class="s2">, </span><span class="s0">yb = np.asarray(ya)</span><span class="s2">, </span><span class="s0">np.asarray(yb)</span>
        <span class="s2">if </span><span class="s0">ya.shape[</span><span class="s4">1</span><span class="s0">:] != yb.shape[</span><span class="s4">1</span><span class="s0">:]:</span>
            <span class="s2">raise </span><span class="s0">ValueError(</span><span class="s1">'Shapes of ya {} and yb {} are incompatible'</span>
                             <span class="s0">.format(ya.shape</span><span class="s2">, </span><span class="s0">yb.shape))</span>

        <span class="s0">dta</span><span class="s2">, </span><span class="s0">dtb = ya.dtype</span><span class="s2">, </span><span class="s0">yb.dtype</span>
        <span class="s2">if </span><span class="s0">(np.issubdtype(dta</span><span class="s2">, </span><span class="s0">np.complexfloating) </span><span class="s2">or</span>
               <span class="s0">np.issubdtype(dtb</span><span class="s2">, </span><span class="s0">np.complexfloating)):</span>
            <span class="s0">dt = np.complex_</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s0">dt = np.float_</span>

        <span class="s0">na</span><span class="s2">, </span><span class="s0">nb = len(ya)</span><span class="s2">, </span><span class="s0">len(yb)</span>
        <span class="s0">n = na + nb</span>

        <span class="s0">c = np.empty((na+nb</span><span class="s2">,</span><span class="s0">) + ya.shape[</span><span class="s4">1</span><span class="s0">:]</span><span class="s2">, </span><span class="s0">dtype=dt)</span>

        <span class="s5"># compute coefficients of a polynomial degree na+nb-1</span>
        <span class="s5"># walk left-to-right</span>
        <span class="s2">for </span><span class="s0">q </span><span class="s2">in </span><span class="s0">range(</span><span class="s4">0</span><span class="s2">, </span><span class="s0">na):</span>
            <span class="s0">c[q] = ya[q] / spec.poch(n - q</span><span class="s2">, </span><span class="s0">q) * (xb - xa)**q</span>
            <span class="s2">for </span><span class="s0">j </span><span class="s2">in </span><span class="s0">range(</span><span class="s4">0</span><span class="s2">, </span><span class="s0">q):</span>
                <span class="s0">c[q] -= (-</span><span class="s4">1</span><span class="s0">)**(j+q) * comb(q</span><span class="s2">, </span><span class="s0">j) * c[j]</span>

        <span class="s5"># now walk right-to-left</span>
        <span class="s2">for </span><span class="s0">q </span><span class="s2">in </span><span class="s0">range(</span><span class="s4">0</span><span class="s2">, </span><span class="s0">nb):</span>
            <span class="s0">c[-q-</span><span class="s4">1</span><span class="s0">] = yb[q] / spec.poch(n - q</span><span class="s2">, </span><span class="s0">q) * (-</span><span class="s4">1</span><span class="s0">)**q * (xb - xa)**q</span>
            <span class="s2">for </span><span class="s0">j </span><span class="s2">in </span><span class="s0">range(</span><span class="s4">0</span><span class="s2">, </span><span class="s0">q):</span>
                <span class="s0">c[-q-</span><span class="s4">1</span><span class="s0">] -= (-</span><span class="s4">1</span><span class="s0">)**(j+</span><span class="s4">1</span><span class="s0">) * comb(q</span><span class="s2">, </span><span class="s0">j+</span><span class="s4">1</span><span class="s0">) * c[-q+j]</span>

        <span class="s2">return </span><span class="s0">c</span>

    <span class="s0">@staticmethod</span>
    <span class="s2">def </span><span class="s0">_raise_degree(c</span><span class="s2">, </span><span class="s0">d):</span>
        <span class="s3">r&quot;&quot;&quot;Raise a degree of a polynomial in the Bernstein basis. 
 
        Given the coefficients of a polynomial degree `k`, return (the 
        coefficients of) the equivalent polynomial of degree `k+d`. 
 
        Parameters 
        ---------- 
        c : array_like 
            coefficient array, 1-D 
        d : integer 
 
        Returns 
        ------- 
        array 
            coefficient array, 1-D array of length `c.shape[0] + d` 
 
        Notes 
        ----- 
        This uses the fact that a Bernstein polynomial `b_{a, k}` can be 
        identically represented as a linear combination of polynomials of 
        a higher degree `k+d`: 
 
            .. math:: b_{a, k} = comb(k, a) \sum_{j=0}^{d} b_{a+j, k+d} \ 
                                 comb(d, j) / comb(k+d, a+j) 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s0">d == </span><span class="s4">0</span><span class="s0">:</span>
            <span class="s2">return </span><span class="s0">c</span>

        <span class="s0">k = c.shape[</span><span class="s4">0</span><span class="s0">] - </span><span class="s4">1</span>
        <span class="s0">out = np.zeros((c.shape[</span><span class="s4">0</span><span class="s0">] + d</span><span class="s2">,</span><span class="s0">) + c.shape[</span><span class="s4">1</span><span class="s0">:]</span><span class="s2">, </span><span class="s0">dtype=c.dtype)</span>

        <span class="s2">for </span><span class="s0">a </span><span class="s2">in </span><span class="s0">range(c.shape[</span><span class="s4">0</span><span class="s0">]):</span>
            <span class="s0">f = c[a] * comb(k</span><span class="s2">, </span><span class="s0">a)</span>
            <span class="s2">for </span><span class="s0">j </span><span class="s2">in </span><span class="s0">range(d+</span><span class="s4">1</span><span class="s0">):</span>
                <span class="s0">out[a+j] += f * comb(d</span><span class="s2">, </span><span class="s0">j) / comb(k+d</span><span class="s2">, </span><span class="s0">a+j)</span>
        <span class="s2">return </span><span class="s0">out</span>


<span class="s2">class </span><span class="s0">NdPPoly:</span>
    <span class="s3">&quot;&quot;&quot; 
    Piecewise tensor product polynomial 
 
    The value at point ``xp = (x', y', z', ...)`` is evaluated by first 
    computing the interval indices `i` such that:: 
 
        x[0][i[0]] &lt;= x' &lt; x[0][i[0]+1] 
        x[1][i[1]] &lt;= y' &lt; x[1][i[1]+1] 
        ... 
 
    and then computing:: 
 
        S = sum(c[k0-m0-1,...,kn-mn-1,i[0],...,i[n]] 
                * (xp[0] - x[0][i[0]])**m0 
                * ... 
                * (xp[n] - x[n][i[n]])**mn 
                for m0 in range(k[0]+1) 
                ... 
                for mn in range(k[n]+1)) 
 
    where ``k[j]`` is the degree of the polynomial in dimension j. This 
    representation is the piecewise multivariate power basis. 
 
    Parameters 
    ---------- 
    c : ndarray, shape (k0, ..., kn, m0, ..., mn, ...) 
        Polynomial coefficients, with polynomial order `kj` and 
        `mj+1` intervals for each dimension `j`. 
    x : ndim-tuple of ndarrays, shapes (mj+1,) 
        Polynomial breakpoints for each dimension. These must be 
        sorted in increasing order. 
    extrapolate : bool, optional 
        Whether to extrapolate to out-of-bounds points based on first 
        and last intervals, or to return NaNs. Default: True. 
 
    Attributes 
    ---------- 
    x : tuple of ndarrays 
        Breakpoints. 
    c : ndarray 
        Coefficients of the polynomials. 
 
    Methods 
    ------- 
    __call__ 
    derivative 
    antiderivative 
    integrate 
    integrate_1d 
    construct_fast 
 
    See also 
    -------- 
    PPoly : piecewise polynomials in 1D 
 
    Notes 
    ----- 
    High-order polynomials in the power basis can be numerically 
    unstable. 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s0">__init__(self</span><span class="s2">, </span><span class="s0">c</span><span class="s2">, </span><span class="s0">x</span><span class="s2">, </span><span class="s0">extrapolate=</span><span class="s2">None</span><span class="s0">):</span>
        <span class="s0">self.x = tuple(np.ascontiguousarray(v</span><span class="s2">, </span><span class="s0">dtype=np.float64) </span><span class="s2">for </span><span class="s0">v </span><span class="s2">in </span><span class="s0">x)</span>
        <span class="s0">self.c = np.asarray(c)</span>
        <span class="s2">if </span><span class="s0">extrapolate </span><span class="s2">is None</span><span class="s0">:</span>
            <span class="s0">extrapolate = </span><span class="s2">True</span>
        <span class="s0">self.extrapolate = bool(extrapolate)</span>

        <span class="s0">ndim = len(self.x)</span>
        <span class="s2">if </span><span class="s0">any(v.ndim != </span><span class="s4">1 </span><span class="s2">for </span><span class="s0">v </span><span class="s2">in </span><span class="s0">self.x):</span>
            <span class="s2">raise </span><span class="s0">ValueError(</span><span class="s1">&quot;x arrays must all be 1-dimensional&quot;</span><span class="s0">)</span>
        <span class="s2">if </span><span class="s0">any(v.size &lt; </span><span class="s4">2 </span><span class="s2">for </span><span class="s0">v </span><span class="s2">in </span><span class="s0">self.x):</span>
            <span class="s2">raise </span><span class="s0">ValueError(</span><span class="s1">&quot;x arrays must all contain at least 2 points&quot;</span><span class="s0">)</span>
        <span class="s2">if </span><span class="s0">c.ndim &lt; </span><span class="s4">2</span><span class="s0">*ndim:</span>
            <span class="s2">raise </span><span class="s0">ValueError(</span><span class="s1">&quot;c must have at least 2*len(x) dimensions&quot;</span><span class="s0">)</span>
        <span class="s2">if </span><span class="s0">any(np.any(v[</span><span class="s4">1</span><span class="s0">:] - v[:-</span><span class="s4">1</span><span class="s0">] &lt; </span><span class="s4">0</span><span class="s0">) </span><span class="s2">for </span><span class="s0">v </span><span class="s2">in </span><span class="s0">self.x):</span>
            <span class="s2">raise </span><span class="s0">ValueError(</span><span class="s1">&quot;x-coordinates are not in increasing order&quot;</span><span class="s0">)</span>
        <span class="s2">if </span><span class="s0">any(a != b.size - </span><span class="s4">1 </span><span class="s2">for </span><span class="s0">a</span><span class="s2">, </span><span class="s0">b </span><span class="s2">in </span><span class="s0">zip(c.shape[ndim:</span><span class="s4">2</span><span class="s0">*ndim]</span><span class="s2">, </span><span class="s0">self.x)):</span>
            <span class="s2">raise </span><span class="s0">ValueError(</span><span class="s1">&quot;x and c do not agree on the number of intervals&quot;</span><span class="s0">)</span>

        <span class="s0">dtype = self._get_dtype(self.c.dtype)</span>
        <span class="s0">self.c = np.ascontiguousarray(self.c</span><span class="s2">, </span><span class="s0">dtype=dtype)</span>

    <span class="s0">@classmethod</span>
    <span class="s2">def </span><span class="s0">construct_fast(cls</span><span class="s2">, </span><span class="s0">c</span><span class="s2">, </span><span class="s0">x</span><span class="s2">, </span><span class="s0">extrapolate=</span><span class="s2">None</span><span class="s0">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Construct the piecewise polynomial without making checks. 
 
        Takes the same parameters as the constructor. Input arguments 
        ``c`` and ``x`` must be arrays of the correct shape and type.  The 
        ``c`` array can only be of dtypes float and complex, and ``x`` 
        array must have dtype float. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">self = object.__new__(cls)</span>
        <span class="s0">self.c = c</span>
        <span class="s0">self.x = x</span>
        <span class="s2">if </span><span class="s0">extrapolate </span><span class="s2">is None</span><span class="s0">:</span>
            <span class="s0">extrapolate = </span><span class="s2">True</span>
        <span class="s0">self.extrapolate = extrapolate</span>
        <span class="s2">return </span><span class="s0">self</span>

    <span class="s2">def </span><span class="s0">_get_dtype(self</span><span class="s2">, </span><span class="s0">dtype):</span>
        <span class="s2">if </span><span class="s0">np.issubdtype(dtype</span><span class="s2">, </span><span class="s0">np.complexfloating) \</span>
               <span class="s2">or </span><span class="s0">np.issubdtype(self.c.dtype</span><span class="s2">, </span><span class="s0">np.complexfloating):</span>
            <span class="s2">return </span><span class="s0">np.complex_</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s2">return </span><span class="s0">np.float_</span>

    <span class="s2">def </span><span class="s0">_ensure_c_contiguous(self):</span>
        <span class="s2">if not </span><span class="s0">self.c.flags.c_contiguous:</span>
            <span class="s0">self.c = self.c.copy()</span>
        <span class="s2">if not </span><span class="s0">isinstance(self.x</span><span class="s2">, </span><span class="s0">tuple):</span>
            <span class="s0">self.x = tuple(self.x)</span>

    <span class="s2">def </span><span class="s0">__call__(self</span><span class="s2">, </span><span class="s0">x</span><span class="s2">, </span><span class="s0">nu=</span><span class="s2">None, </span><span class="s0">extrapolate=</span><span class="s2">None</span><span class="s0">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Evaluate the piecewise polynomial or its derivative 
 
        Parameters 
        ---------- 
        x : array-like 
            Points to evaluate the interpolant at. 
        nu : tuple, optional 
            Orders of derivatives to evaluate. Each must be non-negative. 
        extrapolate : bool, optional 
            Whether to extrapolate to out-of-bounds points based on first 
            and last intervals, or to return NaNs. 
 
        Returns 
        ------- 
        y : array-like 
            Interpolated values. Shape is determined by replacing 
            the interpolation axis in the original array with the shape of x. 
 
        Notes 
        ----- 
        Derivatives are evaluated piecewise for each polynomial 
        segment, even if the polynomial is not differentiable at the 
        breakpoints. The polynomial intervals are considered half-open, 
        ``[a, b)``, except for the last interval which is closed 
        ``[a, b]``. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s0">extrapolate </span><span class="s2">is None</span><span class="s0">:</span>
            <span class="s0">extrapolate = self.extrapolate</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s0">extrapolate = bool(extrapolate)</span>

        <span class="s0">ndim = len(self.x)</span>

        <span class="s0">x = _ndim_coords_from_arrays(x)</span>
        <span class="s0">x_shape = x.shape</span>
        <span class="s0">x = np.ascontiguousarray(x.reshape(-</span><span class="s4">1</span><span class="s2">, </span><span class="s0">x.shape[-</span><span class="s4">1</span><span class="s0">])</span><span class="s2">, </span><span class="s0">dtype=np.float_)</span>

        <span class="s2">if </span><span class="s0">nu </span><span class="s2">is None</span><span class="s0">:</span>
            <span class="s0">nu = np.zeros((ndim</span><span class="s2">,</span><span class="s0">)</span><span class="s2">, </span><span class="s0">dtype=np.intc)</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s0">nu = np.asarray(nu</span><span class="s2">, </span><span class="s0">dtype=np.intc)</span>
            <span class="s2">if </span><span class="s0">nu.ndim != </span><span class="s4">1 </span><span class="s2">or </span><span class="s0">nu.shape[</span><span class="s4">0</span><span class="s0">] != ndim:</span>
                <span class="s2">raise </span><span class="s0">ValueError(</span><span class="s1">&quot;invalid number of derivative orders nu&quot;</span><span class="s0">)</span>

        <span class="s0">dim1 = prod(self.c.shape[:ndim])</span>
        <span class="s0">dim2 = prod(self.c.shape[ndim:</span><span class="s4">2</span><span class="s0">*ndim])</span>
        <span class="s0">dim3 = prod(self.c.shape[</span><span class="s4">2</span><span class="s0">*ndim:])</span>
        <span class="s0">ks = np.array(self.c.shape[:ndim]</span><span class="s2">, </span><span class="s0">dtype=np.intc)</span>

        <span class="s0">out = np.empty((x.shape[</span><span class="s4">0</span><span class="s0">]</span><span class="s2">, </span><span class="s0">dim3)</span><span class="s2">, </span><span class="s0">dtype=self.c.dtype)</span>
        <span class="s0">self._ensure_c_contiguous()</span>

        <span class="s0">_ppoly.evaluate_nd(self.c.reshape(dim1</span><span class="s2">, </span><span class="s0">dim2</span><span class="s2">, </span><span class="s0">dim3)</span><span class="s2">,</span>
                           <span class="s0">self.x</span><span class="s2">,</span>
                           <span class="s0">ks</span><span class="s2">,</span>
                           <span class="s0">x</span><span class="s2">,</span>
                           <span class="s0">nu</span><span class="s2">,</span>
                           <span class="s0">bool(extrapolate)</span><span class="s2">,</span>
                           <span class="s0">out)</span>

        <span class="s2">return </span><span class="s0">out.reshape(x_shape[:-</span><span class="s4">1</span><span class="s0">] + self.c.shape[</span><span class="s4">2</span><span class="s0">*ndim:])</span>

    <span class="s2">def </span><span class="s0">_derivative_inplace(self</span><span class="s2">, </span><span class="s0">nu</span><span class="s2">, </span><span class="s0">axis):</span>
        <span class="s3">&quot;&quot;&quot; 
        Compute 1-D derivative along a selected dimension in-place 
        May result to non-contiguous c array. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s0">nu &lt; </span><span class="s4">0</span><span class="s0">:</span>
            <span class="s2">return </span><span class="s0">self._antiderivative_inplace(-nu</span><span class="s2">, </span><span class="s0">axis)</span>

        <span class="s0">ndim = len(self.x)</span>
        <span class="s0">axis = axis % ndim</span>

        <span class="s5"># reduce order</span>
        <span class="s2">if </span><span class="s0">nu == </span><span class="s4">0</span><span class="s0">:</span>
            <span class="s5"># noop</span>
            <span class="s2">return</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s0">sl = [slice(</span><span class="s2">None</span><span class="s0">)]*ndim</span>
            <span class="s0">sl[axis] = slice(</span><span class="s2">None, </span><span class="s0">-nu</span><span class="s2">, None</span><span class="s0">)</span>
            <span class="s0">c2 = self.c[tuple(sl)]</span>

        <span class="s2">if </span><span class="s0">c2.shape[axis] == </span><span class="s4">0</span><span class="s0">:</span>
            <span class="s5"># derivative of order 0 is zero</span>
            <span class="s0">shp = list(c2.shape)</span>
            <span class="s0">shp[axis] = </span><span class="s4">1</span>
            <span class="s0">c2 = np.zeros(shp</span><span class="s2">, </span><span class="s0">dtype=c2.dtype)</span>

        <span class="s5"># multiply by the correct rising factorials</span>
        <span class="s0">factor = spec.poch(np.arange(c2.shape[axis]</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s0">-</span><span class="s4">1</span><span class="s0">)</span><span class="s2">, </span><span class="s0">nu)</span>
        <span class="s0">sl = [</span><span class="s2">None</span><span class="s0">]*c2.ndim</span>
        <span class="s0">sl[axis] = slice(</span><span class="s2">None</span><span class="s0">)</span>
        <span class="s0">c2 *= factor[tuple(sl)]</span>

        <span class="s0">self.c = c2</span>

    <span class="s2">def </span><span class="s0">_antiderivative_inplace(self</span><span class="s2">, </span><span class="s0">nu</span><span class="s2">, </span><span class="s0">axis):</span>
        <span class="s3">&quot;&quot;&quot; 
        Compute 1-D antiderivative along a selected dimension 
        May result to non-contiguous c array. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s0">nu &lt;= </span><span class="s4">0</span><span class="s0">:</span>
            <span class="s2">return </span><span class="s0">self._derivative_inplace(-nu</span><span class="s2">, </span><span class="s0">axis)</span>

        <span class="s0">ndim = len(self.x)</span>
        <span class="s0">axis = axis % ndim</span>

        <span class="s0">perm = list(range(ndim))</span>
        <span class="s0">perm[</span><span class="s4">0</span><span class="s0">]</span><span class="s2">, </span><span class="s0">perm[axis] = perm[axis]</span><span class="s2">, </span><span class="s0">perm[</span><span class="s4">0</span><span class="s0">]</span>
        <span class="s0">perm = perm + list(range(ndim</span><span class="s2">, </span><span class="s0">self.c.ndim))</span>

        <span class="s0">c = self.c.transpose(perm)</span>

        <span class="s0">c2 = np.zeros((c.shape[</span><span class="s4">0</span><span class="s0">] + nu</span><span class="s2">,</span><span class="s0">) + c.shape[</span><span class="s4">1</span><span class="s0">:]</span><span class="s2">,</span>
                     <span class="s0">dtype=c.dtype)</span>
        <span class="s0">c2[:-nu] = c</span>

        <span class="s5"># divide by the correct rising factorials</span>
        <span class="s0">factor = spec.poch(np.arange(c.shape[</span><span class="s4">0</span><span class="s0">]</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s0">-</span><span class="s4">1</span><span class="s0">)</span><span class="s2">, </span><span class="s0">nu)</span>
        <span class="s0">c2[:-nu] /= factor[(slice(</span><span class="s2">None</span><span class="s0">)</span><span class="s2">,</span><span class="s0">) + (</span><span class="s2">None,</span><span class="s0">)*(c.ndim-</span><span class="s4">1</span><span class="s0">)]</span>

        <span class="s5"># fix continuity of added degrees of freedom</span>
        <span class="s0">perm2 = list(range(c2.ndim))</span>
        <span class="s0">perm2[</span><span class="s4">1</span><span class="s0">]</span><span class="s2">, </span><span class="s0">perm2[ndim+axis] = perm2[ndim+axis]</span><span class="s2">, </span><span class="s0">perm2[</span><span class="s4">1</span><span class="s0">]</span>

        <span class="s0">c2 = c2.transpose(perm2)</span>
        <span class="s0">c2 = c2.copy()</span>
        <span class="s0">_ppoly.fix_continuity(c2.reshape(c2.shape[</span><span class="s4">0</span><span class="s0">]</span><span class="s2">, </span><span class="s0">c2.shape[</span><span class="s4">1</span><span class="s0">]</span><span class="s2">, </span><span class="s0">-</span><span class="s4">1</span><span class="s0">)</span><span class="s2">,</span>
                              <span class="s0">self.x[axis]</span><span class="s2">, </span><span class="s0">nu-</span><span class="s4">1</span><span class="s0">)</span>

        <span class="s0">c2 = c2.transpose(perm2)</span>
        <span class="s0">c2 = c2.transpose(perm)</span>

        <span class="s5"># Done</span>
        <span class="s0">self.c = c2</span>

    <span class="s2">def </span><span class="s0">derivative(self</span><span class="s2">, </span><span class="s0">nu):</span>
        <span class="s3">&quot;&quot;&quot; 
        Construct a new piecewise polynomial representing the derivative. 
 
        Parameters 
        ---------- 
        nu : ndim-tuple of int 
            Order of derivatives to evaluate for each dimension. 
            If negative, the antiderivative is returned. 
 
        Returns 
        ------- 
        pp : NdPPoly 
            Piecewise polynomial of orders (k[0] - nu[0], ..., k[n] - nu[n]) 
            representing the derivative of this polynomial. 
 
        Notes 
        ----- 
        Derivatives are evaluated piecewise for each polynomial 
        segment, even if the polynomial is not differentiable at the 
        breakpoints. The polynomial intervals in each dimension are 
        considered half-open, ``[a, b)``, except for the last interval 
        which is closed ``[a, b]``. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">p = self.construct_fast(self.c.copy()</span><span class="s2">, </span><span class="s0">self.x</span><span class="s2">, </span><span class="s0">self.extrapolate)</span>

        <span class="s2">for </span><span class="s0">axis</span><span class="s2">, </span><span class="s0">n </span><span class="s2">in </span><span class="s0">enumerate(nu):</span>
            <span class="s0">p._derivative_inplace(n</span><span class="s2">, </span><span class="s0">axis)</span>

        <span class="s0">p._ensure_c_contiguous()</span>
        <span class="s2">return </span><span class="s0">p</span>

    <span class="s2">def </span><span class="s0">antiderivative(self</span><span class="s2">, </span><span class="s0">nu):</span>
        <span class="s3">&quot;&quot;&quot; 
        Construct a new piecewise polynomial representing the antiderivative. 
 
        Antiderivative is also the indefinite integral of the function, 
        and derivative is its inverse operation. 
 
        Parameters 
        ---------- 
        nu : ndim-tuple of int 
            Order of derivatives to evaluate for each dimension. 
            If negative, the derivative is returned. 
 
        Returns 
        ------- 
        pp : PPoly 
            Piecewise polynomial of order k2 = k + n representing 
            the antiderivative of this polynomial. 
 
        Notes 
        ----- 
        The antiderivative returned by this function is continuous and 
        continuously differentiable to order n-1, up to floating point 
        rounding error. 
 
        &quot;&quot;&quot;</span>
        <span class="s0">p = self.construct_fast(self.c.copy()</span><span class="s2">, </span><span class="s0">self.x</span><span class="s2">, </span><span class="s0">self.extrapolate)</span>

        <span class="s2">for </span><span class="s0">axis</span><span class="s2">, </span><span class="s0">n </span><span class="s2">in </span><span class="s0">enumerate(nu):</span>
            <span class="s0">p._antiderivative_inplace(n</span><span class="s2">, </span><span class="s0">axis)</span>

        <span class="s0">p._ensure_c_contiguous()</span>
        <span class="s2">return </span><span class="s0">p</span>

    <span class="s2">def </span><span class="s0">integrate_1d(self</span><span class="s2">, </span><span class="s0">a</span><span class="s2">, </span><span class="s0">b</span><span class="s2">, </span><span class="s0">axis</span><span class="s2">, </span><span class="s0">extrapolate=</span><span class="s2">None</span><span class="s0">):</span>
        <span class="s3">r&quot;&quot;&quot; 
        Compute NdPPoly representation for one dimensional definite integral 
 
        The result is a piecewise polynomial representing the integral: 
 
        .. math:: 
 
           p(y, z, ...) = \int_a^b dx\, p(x, y, z, ...) 
 
        where the dimension integrated over is specified with the 
        `axis` parameter. 
 
        Parameters 
        ---------- 
        a, b : float 
            Lower and upper bound for integration. 
        axis : int 
            Dimension over which to compute the 1-D integrals 
        extrapolate : bool, optional 
            Whether to extrapolate to out-of-bounds points based on first 
            and last intervals, or to return NaNs. 
 
        Returns 
        ------- 
        ig : NdPPoly or array-like 
            Definite integral of the piecewise polynomial over [a, b]. 
            If the polynomial was 1D, an array is returned, 
            otherwise, an NdPPoly object. 
 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s0">extrapolate </span><span class="s2">is None</span><span class="s0">:</span>
            <span class="s0">extrapolate = self.extrapolate</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s0">extrapolate = bool(extrapolate)</span>

        <span class="s0">ndim = len(self.x)</span>
        <span class="s0">axis = int(axis) % ndim</span>

        <span class="s5"># reuse 1-D integration routines</span>
        <span class="s0">c = self.c</span>
        <span class="s0">swap = list(range(c.ndim))</span>
        <span class="s0">swap.insert(</span><span class="s4">0</span><span class="s2">, </span><span class="s0">swap[axis])</span>
        <span class="s2">del </span><span class="s0">swap[axis + </span><span class="s4">1</span><span class="s0">]</span>
        <span class="s0">swap.insert(</span><span class="s4">1</span><span class="s2">, </span><span class="s0">swap[ndim + axis])</span>
        <span class="s2">del </span><span class="s0">swap[ndim + axis + </span><span class="s4">1</span><span class="s0">]</span>

        <span class="s0">c = c.transpose(swap)</span>
        <span class="s0">p = PPoly.construct_fast(c.reshape(c.shape[</span><span class="s4">0</span><span class="s0">]</span><span class="s2">, </span><span class="s0">c.shape[</span><span class="s4">1</span><span class="s0">]</span><span class="s2">, </span><span class="s0">-</span><span class="s4">1</span><span class="s0">)</span><span class="s2">,</span>
                                 <span class="s0">self.x[axis]</span><span class="s2">,</span>
                                 <span class="s0">extrapolate=extrapolate)</span>
        <span class="s0">out = p.integrate(a</span><span class="s2">, </span><span class="s0">b</span><span class="s2">, </span><span class="s0">extrapolate=extrapolate)</span>

        <span class="s5"># Construct result</span>
        <span class="s2">if </span><span class="s0">ndim == </span><span class="s4">1</span><span class="s0">:</span>
            <span class="s2">return </span><span class="s0">out.reshape(c.shape[</span><span class="s4">2</span><span class="s0">:])</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s0">c = out.reshape(c.shape[</span><span class="s4">2</span><span class="s0">:])</span>
            <span class="s0">x = self.x[:axis] + self.x[axis+</span><span class="s4">1</span><span class="s0">:]</span>
            <span class="s2">return </span><span class="s0">self.construct_fast(c</span><span class="s2">, </span><span class="s0">x</span><span class="s2">, </span><span class="s0">extrapolate=extrapolate)</span>

    <span class="s2">def </span><span class="s0">integrate(self</span><span class="s2">, </span><span class="s0">ranges</span><span class="s2">, </span><span class="s0">extrapolate=</span><span class="s2">None</span><span class="s0">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Compute a definite integral over a piecewise polynomial. 
 
        Parameters 
        ---------- 
        ranges : ndim-tuple of 2-tuples float 
            Sequence of lower and upper bounds for each dimension, 
            ``[(a[0], b[0]), ..., (a[ndim-1], b[ndim-1])]`` 
        extrapolate : bool, optional 
            Whether to extrapolate to out-of-bounds points based on first 
            and last intervals, or to return NaNs. 
 
        Returns 
        ------- 
        ig : array_like 
            Definite integral of the piecewise polynomial over 
            [a[0], b[0]] x ... x [a[ndim-1], b[ndim-1]] 
 
        &quot;&quot;&quot;</span>

        <span class="s0">ndim = len(self.x)</span>

        <span class="s2">if </span><span class="s0">extrapolate </span><span class="s2">is None</span><span class="s0">:</span>
            <span class="s0">extrapolate = self.extrapolate</span>
        <span class="s2">else</span><span class="s0">:</span>
            <span class="s0">extrapolate = bool(extrapolate)</span>

        <span class="s2">if not </span><span class="s0">hasattr(ranges</span><span class="s2">, </span><span class="s1">'__len__'</span><span class="s0">) </span><span class="s2">or </span><span class="s0">len(ranges) != ndim:</span>
            <span class="s2">raise </span><span class="s0">ValueError(</span><span class="s1">&quot;Range not a sequence of correct length&quot;</span><span class="s0">)</span>

        <span class="s0">self._ensure_c_contiguous()</span>

        <span class="s5"># Reuse 1D integration routine</span>
        <span class="s0">c = self.c</span>
        <span class="s2">for </span><span class="s0">n</span><span class="s2">, </span><span class="s0">(a</span><span class="s2">, </span><span class="s0">b) </span><span class="s2">in </span><span class="s0">enumerate(ranges):</span>
            <span class="s0">swap = list(range(c.ndim))</span>
            <span class="s0">swap.insert(</span><span class="s4">1</span><span class="s2">, </span><span class="s0">swap[ndim - n])</span>
            <span class="s2">del </span><span class="s0">swap[ndim - n + </span><span class="s4">1</span><span class="s0">]</span>

            <span class="s0">c = c.transpose(swap)</span>

            <span class="s0">p = PPoly.construct_fast(c</span><span class="s2">, </span><span class="s0">self.x[n]</span><span class="s2">, </span><span class="s0">extrapolate=extrapolate)</span>
            <span class="s0">out = p.integrate(a</span><span class="s2">, </span><span class="s0">b</span><span class="s2">, </span><span class="s0">extrapolate=extrapolate)</span>
            <span class="s0">c = out.reshape(c.shape[</span><span class="s4">2</span><span class="s0">:])</span>

        <span class="s2">return </span><span class="s0">c</span>
</pre>
</body>
</html>