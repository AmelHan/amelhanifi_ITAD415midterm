<html>
<head>
<title>test_ar.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #6a8759;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_ar.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Test AR Model 
&quot;&quot;&quot;</span>
<span class="s2">from </span><span class="s1">statsmodels.compat.pytest </span><span class="s2">import </span><span class="s1">pytest_warns</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">NamedTuple</span><span class="s2">, </span><span class="s1">Union</span>

<span class="s2">import </span><span class="s1">datetime </span><span class="s2">as </span><span class="s1">dt</span>
<span class="s2">from </span><span class="s1">itertools </span><span class="s2">import </span><span class="s1">product</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">numpy.testing </span><span class="s2">import </span><span class="s1">assert_allclose</span><span class="s2">, </span><span class="s1">assert_almost_equal</span>
<span class="s2">import </span><span class="s1">pandas </span><span class="s2">as </span><span class="s1">pd</span>
<span class="s2">from </span><span class="s1">pandas </span><span class="s2">import </span><span class="s1">Index</span><span class="s2">, </span><span class="s1">Series</span><span class="s2">, </span><span class="s1">date_range</span><span class="s2">, </span><span class="s1">period_range</span>
<span class="s2">from </span><span class="s1">pandas.testing </span><span class="s2">import </span><span class="s1">assert_series_equal</span>
<span class="s2">import </span><span class="s1">pytest</span>

<span class="s2">from </span><span class="s1">statsmodels.datasets </span><span class="s2">import </span><span class="s1">macrodata</span><span class="s2">, </span><span class="s1">sunspots</span>
<span class="s2">from </span><span class="s1">statsmodels.iolib.summary </span><span class="s2">import </span><span class="s1">Summary</span>
<span class="s2">from </span><span class="s1">statsmodels.regression.linear_model </span><span class="s2">import </span><span class="s1">OLS</span>
<span class="s2">from </span><span class="s1">statsmodels.tools.sm_exceptions </span><span class="s2">import </span><span class="s1">SpecificationWarning</span><span class="s2">, </span><span class="s1">ValueWarning</span>
<span class="s2">from </span><span class="s1">statsmodels.tools.tools </span><span class="s2">import </span><span class="s1">Bunch</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.ar_model </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">AutoReg</span><span class="s2">,</span>
    <span class="s1">AutoRegResultsWrapper</span><span class="s2">,</span>
    <span class="s1">ar_select_order</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.arima_process </span><span class="s2">import </span><span class="s1">arma_generate_sample</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.deterministic </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">DeterministicProcess</span><span class="s2">,</span>
    <span class="s1">Seasonality</span><span class="s2">,</span>
    <span class="s1">TimeTrend</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.statespace.sarimax </span><span class="s2">import </span><span class="s1">SARIMAX</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.tests.results </span><span class="s2">import </span><span class="s1">results_ar</span>

<span class="s1">DECIMAL_6 = </span><span class="s3">6</span>
<span class="s1">DECIMAL_5 = </span><span class="s3">5</span>
<span class="s1">DECIMAL_4 = </span><span class="s3">4</span>


<span class="s2">def </span><span class="s1">gen_ar_data(nobs):</span>
    <span class="s1">rs = np.random.RandomState(</span><span class="s3">982739</span><span class="s1">)</span>
    <span class="s1">idx = pd.date_range(dt.datetime(</span><span class="s3">1900</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">freq=</span><span class="s4">&quot;M&quot;</span><span class="s2">, </span><span class="s1">periods=nobs)</span>
    <span class="s2">return </span><span class="s1">pd.Series(rs.standard_normal(nobs)</span><span class="s2">, </span><span class="s1">index=idx)</span><span class="s2">, </span><span class="s1">rs</span>


<span class="s2">def </span><span class="s1">gen_ols_regressors(ar</span><span class="s2">, </span><span class="s1">seasonal</span><span class="s2">, </span><span class="s1">trend</span><span class="s2">, </span><span class="s1">exog):</span>
    <span class="s1">nobs = </span><span class="s3">500</span>
    <span class="s1">y</span><span class="s2">, </span><span class="s1">rs = gen_ar_data(nobs)</span>
    <span class="s1">maxlag = ar </span><span class="s2">if </span><span class="s1">isinstance(ar</span><span class="s2">, </span><span class="s1">int) </span><span class="s2">else </span><span class="s1">max(ar)</span>
    <span class="s1">reg = []</span>
    <span class="s2">if </span><span class="s4">&quot;c&quot; </span><span class="s2">in </span><span class="s1">trend:</span>
        <span class="s1">const = pd.Series(np.ones(nobs)</span><span class="s2">, </span><span class="s1">index=y.index</span><span class="s2">, </span><span class="s1">name=</span><span class="s4">&quot;const&quot;</span><span class="s1">)</span>
        <span class="s1">reg.append(const)</span>
    <span class="s2">if </span><span class="s4">&quot;t&quot; </span><span class="s2">in </span><span class="s1">trend:</span>
        <span class="s1">time = np.arange(</span><span class="s3">1</span><span class="s2">, </span><span class="s1">nobs + </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">time = pd.Series(time</span><span class="s2">, </span><span class="s1">index=y.index</span><span class="s2">, </span><span class="s1">name=</span><span class="s4">&quot;time&quot;</span><span class="s1">)</span>
        <span class="s1">reg.append(time)</span>
    <span class="s2">if </span><span class="s1">isinstance(ar</span><span class="s2">, </span><span class="s1">int) </span><span class="s2">and </span><span class="s1">ar:</span>
        <span class="s1">lags = np.arange(</span><span class="s3">1</span><span class="s2">, </span><span class="s1">ar + </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s2">elif </span><span class="s1">ar == </span><span class="s3">0</span><span class="s1">:</span>
        <span class="s1">lags = </span><span class="s2">None</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">lags = ar</span>
    <span class="s2">if </span><span class="s1">seasonal:</span>
        <span class="s1">seasons = np.zeros((</span><span class="s3">500</span><span class="s2">, </span><span class="s3">12</span><span class="s1">))</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s3">12</span><span class="s1">):</span>
            <span class="s1">seasons[i::</span><span class="s3">12</span><span class="s2">, </span><span class="s1">i] = </span><span class="s3">1</span>
        <span class="s1">cols = [</span><span class="s4">&quot;s.{0}&quot;</span><span class="s1">.format(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s3">12</span><span class="s1">)]</span>
        <span class="s1">seasons = pd.DataFrame(seasons</span><span class="s2">, </span><span class="s1">columns=cols</span><span class="s2">, </span><span class="s1">index=y.index)</span>
        <span class="s2">if </span><span class="s4">&quot;c&quot; </span><span class="s2">in </span><span class="s1">trend:</span>
            <span class="s1">seasons = seasons.iloc[:</span><span class="s2">, </span><span class="s3">1</span><span class="s1">:]</span>
        <span class="s1">reg.append(seasons)</span>
    <span class="s2">if </span><span class="s1">maxlag:</span>
        <span class="s2">for </span><span class="s1">lag </span><span class="s2">in </span><span class="s1">lags:</span>
            <span class="s1">reg.append(y.shift(lag))</span>
    <span class="s2">if </span><span class="s1">exog:</span>
        <span class="s1">x = rs.standard_normal((nobs</span><span class="s2">, </span><span class="s1">exog))</span>
        <span class="s1">cols = [</span><span class="s4">&quot;x.{0}&quot;</span><span class="s1">.format(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(exog)]</span>
        <span class="s1">x = pd.DataFrame(x</span><span class="s2">, </span><span class="s1">columns=cols</span><span class="s2">, </span><span class="s1">index=y.index)</span>
        <span class="s1">reg.append(x)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">x = </span><span class="s2">None</span>
    <span class="s1">reg.insert(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">y)</span>
    <span class="s1">df = pd.concat(reg</span><span class="s2">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">).dropna()</span>
    <span class="s1">endog = df.iloc[:</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span>
    <span class="s1">exog = df.iloc[:</span><span class="s2">, </span><span class="s3">1</span><span class="s1">:]</span>
    <span class="s2">return </span><span class="s1">y</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">endog</span><span class="s2">, </span><span class="s1">exog</span>


<span class="s1">ar = [</span><span class="s3">0</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">3</span><span class="s1">]]</span>
<span class="s1">seasonal = [</span><span class="s2">True, False</span><span class="s1">]</span>
<span class="s1">trend = [</span><span class="s4">&quot;n&quot;</span><span class="s2">, </span><span class="s4">&quot;c&quot;</span><span class="s2">, </span><span class="s4">&quot;t&quot;</span><span class="s2">, </span><span class="s4">&quot;ct&quot;</span><span class="s1">]</span>
<span class="s1">exog = [</span><span class="s2">None, </span><span class="s3">2</span><span class="s1">]</span>
<span class="s1">covs = [</span><span class="s4">&quot;nonrobust&quot;</span><span class="s2">, </span><span class="s4">&quot;HC0&quot;</span><span class="s1">]</span>
<span class="s1">params = list(product(ar</span><span class="s2">, </span><span class="s1">seasonal</span><span class="s2">, </span><span class="s1">trend</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">covs))</span>
<span class="s1">final = []</span>
<span class="s2">for </span><span class="s1">param </span><span class="s2">in </span><span class="s1">params:</span>
    <span class="s2">if </span><span class="s1">param[</span><span class="s3">0</span><span class="s1">] != </span><span class="s3">0 </span><span class="s2">or </span><span class="s1">param[</span><span class="s3">1</span><span class="s1">] </span><span class="s2">or </span><span class="s1">param[</span><span class="s3">2</span><span class="s1">] != </span><span class="s4">&quot;n&quot; </span><span class="s2">or </span><span class="s1">param[</span><span class="s3">3</span><span class="s1">]:</span>
        <span class="s1">final.append(param)</span>
<span class="s1">params = final</span>
<span class="s1">names = (</span><span class="s4">&quot;AR&quot;</span><span class="s2">, </span><span class="s4">&quot;Seasonal&quot;</span><span class="s2">, </span><span class="s4">&quot;Trend&quot;</span><span class="s2">, </span><span class="s4">&quot;Exog&quot;</span><span class="s2">, </span><span class="s4">&quot;Cov Type&quot;</span><span class="s1">)</span>
<span class="s1">ids = [</span>
    <span class="s4">&quot;, &quot;</span><span class="s1">.join([n + </span><span class="s4">&quot;: &quot; </span><span class="s1">+ str(p) </span><span class="s2">for </span><span class="s1">n</span><span class="s2">, </span><span class="s1">p </span><span class="s2">in </span><span class="s1">zip(names</span><span class="s2">, </span><span class="s1">param)])</span>
    <span class="s2">for </span><span class="s1">param </span><span class="s2">in </span><span class="s1">params</span>
<span class="s1">]</span>


<span class="s1">@pytest.fixture(scope=</span><span class="s4">&quot;module&quot;</span><span class="s2">, </span><span class="s1">params=params</span><span class="s2">, </span><span class="s1">ids=ids)</span>
<span class="s2">def </span><span class="s1">ols_autoreg_result(request):</span>
    <span class="s1">ar</span><span class="s2">, </span><span class="s1">seasonal</span><span class="s2">, </span><span class="s1">trend</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">cov_type = request.param</span>
    <span class="s1">y</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">endog</span><span class="s2">, </span><span class="s1">exog = gen_ols_regressors(ar</span><span class="s2">, </span><span class="s1">seasonal</span><span class="s2">, </span><span class="s1">trend</span><span class="s2">, </span><span class="s1">exog)</span>
    <span class="s1">ar_mod = AutoReg(y</span><span class="s2">, </span><span class="s1">ar</span><span class="s2">, </span><span class="s1">seasonal=seasonal</span><span class="s2">, </span><span class="s1">trend=trend</span><span class="s2">, </span><span class="s1">exog=x)</span>
    <span class="s1">ar_res = ar_mod.fit(cov_type=cov_type)</span>
    <span class="s1">ols = OLS(endog</span><span class="s2">, </span><span class="s1">exog)</span>
    <span class="s1">ols_res = ols.fit(cov_type=cov_type</span><span class="s2">, </span><span class="s1">use_t=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">ar_res</span><span class="s2">, </span><span class="s1">ols_res</span>


<span class="s1">attributes = [</span>
    <span class="s4">&quot;bse&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;cov_params&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;df_model&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;df_resid&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;fittedvalues&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;llf&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;nobs&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;params&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;resid&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;scale&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;tvalues&quot;</span><span class="s2">,</span>
    <span class="s4">&quot;use_t&quot;</span><span class="s2">,</span>
<span class="s1">]</span>


<span class="s2">def </span><span class="s1">fix_ols_attribute(val</span><span class="s2">, </span><span class="s1">attrib</span><span class="s2">, </span><span class="s1">res):</span>
    <span class="s0">&quot;&quot;&quot; 
    fixes to correct for df adjustment b/t OLS and AutoReg with nonrobust cov 
    &quot;&quot;&quot;</span>
    <span class="s1">nparam = res.k_constant + res.df_model</span>
    <span class="s1">nobs = nparam + res.df_resid</span>
    <span class="s1">df_correction = (nobs - nparam) / nobs</span>
    <span class="s2">if </span><span class="s1">attrib </span><span class="s2">in </span><span class="s1">(</span><span class="s4">&quot;scale&quot;</span><span class="s2">,</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s1">val * df_correction</span>
    <span class="s2">elif </span><span class="s1">attrib == </span><span class="s4">&quot;df_model&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">val + res.k_constant</span>
    <span class="s2">elif </span><span class="s1">res.cov_type != </span><span class="s4">&quot;nonrobust&quot;</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">val</span>
    <span class="s2">elif </span><span class="s1">attrib </span><span class="s2">in </span><span class="s1">(</span><span class="s4">&quot;bse&quot;</span><span class="s2">, </span><span class="s4">&quot;conf_int&quot;</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s1">val * np.sqrt(df_correction)</span>
    <span class="s2">elif </span><span class="s1">attrib </span><span class="s2">in </span><span class="s1">(</span><span class="s4">&quot;cov_params&quot;</span><span class="s2">, </span><span class="s4">&quot;scale&quot;</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s1">val * df_correction</span>
    <span class="s2">elif </span><span class="s1">attrib </span><span class="s2">in </span><span class="s1">(</span><span class="s4">&quot;f_test&quot;</span><span class="s2">,</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s1">val / df_correction</span>
    <span class="s2">elif </span><span class="s1">attrib </span><span class="s2">in </span><span class="s1">(</span><span class="s4">&quot;tvalues&quot;</span><span class="s2">,</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s1">val / np.sqrt(df_correction)</span>

    <span class="s2">return </span><span class="s1">val</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;attribute&quot;</span><span class="s2">, </span><span class="s1">attributes)</span>
<span class="s2">def </span><span class="s1">test_equiv_ols_autoreg(ols_autoreg_result</span><span class="s2">, </span><span class="s1">attribute):</span>
    <span class="s1">a</span><span class="s2">, </span><span class="s1">o = ols_autoreg_result</span>
    <span class="s1">ols_a = getattr(o</span><span class="s2">, </span><span class="s1">attribute)</span>
    <span class="s1">ar_a = getattr(a</span><span class="s2">, </span><span class="s1">attribute)</span>
    <span class="s2">if </span><span class="s1">callable(ols_a):</span>
        <span class="s1">ols_a = ols_a()</span>
        <span class="s1">ar_a = ar_a()</span>
    <span class="s1">ols_a = fix_ols_attribute(ols_a</span><span class="s2">, </span><span class="s1">attribute</span><span class="s2">, </span><span class="s1">o)</span>
    <span class="s1">assert_allclose(ols_a</span><span class="s2">, </span><span class="s1">ar_a)</span>


<span class="s2">def </span><span class="s1">test_conf_int_ols_autoreg(ols_autoreg_result):</span>
    <span class="s1">a</span><span class="s2">, </span><span class="s1">o = ols_autoreg_result</span>
    <span class="s1">a_ci = a.conf_int()</span>
    <span class="s1">o_ci = o.conf_int()</span>
    <span class="s2">if </span><span class="s1">o.cov_type == </span><span class="s4">&quot;nonrobust&quot;</span><span class="s1">:</span>
        <span class="s1">spread = o_ci.T - o.params</span>
        <span class="s1">spread = fix_ols_attribute(spread</span><span class="s2">, </span><span class="s4">&quot;conf_int&quot;</span><span class="s2">, </span><span class="s1">o)</span>
        <span class="s1">o_ci = (spread + o.params).T</span>

    <span class="s1">assert_allclose(a_ci</span><span class="s2">, </span><span class="s1">o_ci)</span>


<span class="s2">def </span><span class="s1">test_f_test_ols_autoreg(ols_autoreg_result):</span>
    <span class="s1">a</span><span class="s2">, </span><span class="s1">o = ols_autoreg_result</span>
    <span class="s1">r = np.eye(a.params.shape[</span><span class="s3">0</span><span class="s1">])</span>
    <span class="s1">a_f = a.f_test(r).fvalue</span>
    <span class="s1">o_f = o.f_test(r).fvalue</span>
    <span class="s1">o_f = fix_ols_attribute(o_f</span><span class="s2">, </span><span class="s4">&quot;f_test&quot;</span><span class="s2">, </span><span class="s1">o)</span>

    <span class="s1">assert_allclose(a_f</span><span class="s2">, </span><span class="s1">o_f)</span>


<span class="s1">@pytest.mark.smoke</span>
<span class="s2">def </span><span class="s1">test_other_tests_autoreg(ols_autoreg_result):</span>
    <span class="s1">a</span><span class="s2">, </span><span class="s1">_ = ols_autoreg_result</span>
    <span class="s1">r = np.ones_like(a.params)</span>
    <span class="s1">a.t_test(r)</span>
    <span class="s1">r = np.eye(a.params.shape[</span><span class="s3">0</span><span class="s1">])</span>
    <span class="s1">a.wald_test(r</span><span class="s2">, </span><span class="s1">scalar=</span><span class="s2">True</span><span class="s1">)</span>


<span class="s5"># TODO: test likelihood for ARX model?</span>


<span class="s2">class </span><span class="s1">CheckARMixin:</span>
    <span class="s2">def </span><span class="s1">test_params(self):</span>
        <span class="s1">assert_almost_equal(self.res1.params</span><span class="s2">, </span><span class="s1">self.res2.params</span><span class="s2">, </span><span class="s1">DECIMAL_6)</span>

    <span class="s2">def </span><span class="s1">test_bse(self):</span>
        <span class="s1">bse = np.sqrt(np.diag(self.res1.cov_params()))</span>
        <span class="s5"># no dof correction for compatability with Stata</span>
        <span class="s1">assert_almost_equal(bse</span><span class="s2">, </span><span class="s1">self.res2.bse_stata</span><span class="s2">, </span><span class="s1">DECIMAL_6)</span>
        <span class="s1">assert_almost_equal(self.res1.bse</span><span class="s2">, </span><span class="s1">self.res2.bse_gretl</span><span class="s2">, </span><span class="s1">DECIMAL_5)</span>

    <span class="s2">def </span><span class="s1">test_llf(self):</span>
        <span class="s1">assert_almost_equal(self.res1.llf</span><span class="s2">, </span><span class="s1">self.res2.llf</span><span class="s2">, </span><span class="s1">DECIMAL_6)</span>

    <span class="s2">def </span><span class="s1">test_fpe(self):</span>
        <span class="s1">assert_almost_equal(self.res1.fpe</span><span class="s2">, </span><span class="s1">self.res2.fpe</span><span class="s2">, </span><span class="s1">DECIMAL_6)</span>

    <span class="s2">def </span><span class="s1">test_pickle(self):</span>
        <span class="s2">from </span><span class="s1">io </span><span class="s2">import </span><span class="s1">BytesIO</span>

        <span class="s1">fh = BytesIO()</span>
        <span class="s5"># test wrapped results load save pickle</span>
        <span class="s1">self.res1.save(fh)</span>
        <span class="s1">fh.seek(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">res_unpickled = self.res1.__class__.load(fh)</span>
        <span class="s2">assert </span><span class="s1">type(res_unpickled) </span><span class="s2">is </span><span class="s1">type(self.res1)  </span><span class="s5"># noqa: E721</span>

    <span class="s1">@pytest.mark.smoke</span>
    <span class="s2">def </span><span class="s1">test_summary(self):</span>
        <span class="s2">assert </span><span class="s1">isinstance(self.res1.summary().as_text()</span><span class="s2">, </span><span class="s1">str)</span>

    <span class="s1">@pytest.mark.smoke</span>
    <span class="s2">def </span><span class="s1">test_pvalues(self):</span>
        <span class="s2">assert </span><span class="s1">isinstance(self.res1.pvalues</span><span class="s2">, </span><span class="s1">(np.ndarray</span><span class="s2">, </span><span class="s1">pd.Series))</span>


<span class="s1">params = product(</span>
    <span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">3</span><span class="s1">]]</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">&quot;n&quot;</span><span class="s2">, </span><span class="s4">&quot;c&quot;</span><span class="s2">, </span><span class="s4">&quot;t&quot;</span><span class="s2">, </span><span class="s4">&quot;ct&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s2">True, False</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">2</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s2">None, </span><span class="s3">11</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">&quot;none&quot;</span><span class="s2">, </span><span class="s4">&quot;drop&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s2">True, False</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s2">None, </span><span class="s3">12</span><span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s1">params = list(params)</span>
<span class="s1">params = [</span>
    <span class="s1">param</span>
    <span class="s2">for </span><span class="s1">param </span><span class="s2">in </span><span class="s1">params</span>
    <span class="s2">if </span><span class="s1">(param[</span><span class="s3">0</span><span class="s1">] </span><span class="s2">or </span><span class="s1">param[</span><span class="s3">1</span><span class="s1">] != </span><span class="s4">&quot;n&quot; </span><span class="s2">or </span><span class="s1">param[</span><span class="s3">2</span><span class="s1">] </span><span class="s2">or </span><span class="s1">param[</span><span class="s3">3</span><span class="s1">])</span>
<span class="s1">]</span>
<span class="s1">params = [</span>
    <span class="s1">param</span>
    <span class="s2">for </span><span class="s1">param </span><span class="s2">in </span><span class="s1">params</span>
    <span class="s2">if not </span><span class="s1">param[</span><span class="s3">2</span><span class="s1">] </span><span class="s2">or </span><span class="s1">(param[</span><span class="s3">2</span><span class="s1">] </span><span class="s2">and </span><span class="s1">(param[</span><span class="s3">4</span><span class="s1">] </span><span class="s2">or </span><span class="s1">param[</span><span class="s3">6</span><span class="s1">]))</span>
<span class="s1">]</span>
<span class="s1">param_fmt = </span><span class="s4">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s4">lags: {0}, trend: {1}, seasonal: {2}, nexog: {3}, periods: {4}, </span><span class="s2">\ 
</span><span class="s4">missing: {5}, pandas: {6}, hold_back{7}&quot;&quot;&quot;</span>

<span class="s1">ids = [param_fmt.format(*param) </span><span class="s2">for </span><span class="s1">param </span><span class="s2">in </span><span class="s1">params]</span>


<span class="s2">def </span><span class="s1">gen_data(nobs</span><span class="s2">, </span><span class="s1">nexog</span><span class="s2">, </span><span class="s1">pandas</span><span class="s2">, </span><span class="s1">seed=</span><span class="s3">92874765</span><span class="s1">):</span>
    <span class="s1">rs = np.random.RandomState(seed)</span>
    <span class="s1">endog = rs.standard_normal((nobs))</span>
    <span class="s1">exog = rs.standard_normal((nobs</span><span class="s2">, </span><span class="s1">nexog)) </span><span class="s2">if </span><span class="s1">nexog </span><span class="s2">else None</span>
    <span class="s2">if </span><span class="s1">pandas:</span>
        <span class="s1">index = pd.date_range(</span>
            <span class="s1">dt.datetime(</span><span class="s3">1999</span><span class="s2">, </span><span class="s3">12</span><span class="s2">, </span><span class="s3">31</span><span class="s1">)</span><span class="s2">, </span><span class="s1">periods=nobs</span><span class="s2">, </span><span class="s1">freq=</span><span class="s4">&quot;M&quot;</span>
        <span class="s1">)</span>
        <span class="s1">endog = pd.Series(endog</span><span class="s2">, </span><span class="s1">name=</span><span class="s4">&quot;endog&quot;</span><span class="s2">, </span><span class="s1">index=index)</span>
        <span class="s2">if </span><span class="s1">nexog:</span>
            <span class="s1">cols = [</span><span class="s4">&quot;exog.{0}&quot;</span><span class="s1">.format(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(exog.shape[</span><span class="s3">1</span><span class="s1">])]</span>
            <span class="s1">exog = pd.DataFrame(exog</span><span class="s2">, </span><span class="s1">columns=cols</span><span class="s2">, </span><span class="s1">index=index)</span>

    <span class="s2">class </span><span class="s1">DataSet(NamedTuple):</span>
        <span class="s1">endog: Union[np.ndarray</span><span class="s2">, </span><span class="s1">pd.Series]</span>
        <span class="s1">exog: Union[np.ndarray</span><span class="s2">, </span><span class="s1">pd.DataFrame]</span>

    <span class="s2">return </span><span class="s1">DataSet(endog=endog</span><span class="s2">, </span><span class="s1">exog=exog)</span>


<span class="s1">@pytest.fixture(scope=</span><span class="s4">&quot;module&quot;</span><span class="s2">, </span><span class="s1">params=params</span><span class="s2">, </span><span class="s1">ids=ids)</span>
<span class="s2">def </span><span class="s1">ar_data(request):</span>
    <span class="s1">lags</span><span class="s2">, </span><span class="s1">trend</span><span class="s2">, </span><span class="s1">seasonal = request.param[:</span><span class="s3">3</span><span class="s1">]</span>
    <span class="s1">nexog</span><span class="s2">, </span><span class="s1">period</span><span class="s2">, </span><span class="s1">missing</span><span class="s2">, </span><span class="s1">use_pandas</span><span class="s2">, </span><span class="s1">hold_back = request.param[</span><span class="s3">3</span><span class="s1">:]</span>
    <span class="s1">data = gen_data(</span><span class="s3">250</span><span class="s2">, </span><span class="s1">nexog</span><span class="s2">, </span><span class="s1">use_pandas)</span>
    <span class="s2">return </span><span class="s1">Bunch(</span>
        <span class="s1">trend=trend</span><span class="s2">,</span>
        <span class="s1">lags=lags</span><span class="s2">,</span>
        <span class="s1">seasonal=seasonal</span><span class="s2">,</span>
        <span class="s1">period=period</span><span class="s2">,</span>
        <span class="s1">endog=data.endog</span><span class="s2">,</span>
        <span class="s1">exog=data.exog</span><span class="s2">,</span>
        <span class="s1">missing=missing</span><span class="s2">,</span>
        <span class="s1">hold_back=hold_back</span><span class="s2">,</span>
    <span class="s1">)</span>


<span class="s1">@pytest.fixture(scope=</span><span class="s4">&quot;module&quot;</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">ar2(request):</span>
    <span class="s1">gen = np.random.RandomState(</span><span class="s3">20210623</span><span class="s1">)</span>
    <span class="s1">e = gen.standard_normal(</span><span class="s3">52</span><span class="s1">)</span>
    <span class="s1">y = </span><span class="s3">10 </span><span class="s1">* np.ones_like(e)</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s3">2</span><span class="s2">, </span><span class="s1">y.shape[</span><span class="s3">0</span><span class="s1">]):</span>
        <span class="s1">y[i] = </span><span class="s3">1 </span><span class="s1">+ </span><span class="s3">0.5 </span><span class="s1">* y[i - </span><span class="s3">1</span><span class="s1">] + </span><span class="s3">0.4 </span><span class="s1">* y[i - </span><span class="s3">2</span><span class="s1">] + e[i]</span>
    <span class="s1">index = pd.period_range(</span><span class="s4">&quot;2000-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=e.shape[</span><span class="s3">0</span><span class="s1">] - </span><span class="s3">2</span><span class="s2">, </span><span class="s1">freq=</span><span class="s4">&quot;M&quot;</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">pd.Series(y[</span><span class="s3">2</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">index=index)</span>


<span class="s1">params = product(</span>
    <span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">3</span><span class="s1">]]</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">&quot;c&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s2">True, False</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s2">None, </span><span class="s3">11</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s4">&quot;drop&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s2">True, False</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">[</span><span class="s2">None, </span><span class="s3">12</span><span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s1">params = list(params)</span>
<span class="s1">params = [</span>
    <span class="s1">param</span>
    <span class="s2">for </span><span class="s1">param </span><span class="s2">in </span><span class="s1">params</span>
    <span class="s2">if </span><span class="s1">(param[</span><span class="s3">0</span><span class="s1">] </span><span class="s2">or </span><span class="s1">param[</span><span class="s3">1</span><span class="s1">] != </span><span class="s4">&quot;n&quot; </span><span class="s2">or </span><span class="s1">param[</span><span class="s3">2</span><span class="s1">] </span><span class="s2">or </span><span class="s1">param[</span><span class="s3">3</span><span class="s1">])</span>
<span class="s1">]</span>
<span class="s1">params = [</span>
    <span class="s1">param</span>
    <span class="s2">for </span><span class="s1">param </span><span class="s2">in </span><span class="s1">params</span>
    <span class="s2">if not </span><span class="s1">param[</span><span class="s3">2</span><span class="s1">] </span><span class="s2">or </span><span class="s1">(param[</span><span class="s3">2</span><span class="s1">] </span><span class="s2">and </span><span class="s1">(param[</span><span class="s3">4</span><span class="s1">] </span><span class="s2">or </span><span class="s1">param[</span><span class="s3">6</span><span class="s1">]))</span>
<span class="s1">]</span>
<span class="s1">param_fmt = </span><span class="s4">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s4">lags: {0}, trend: {1}, seasonal: {2}, nexog: {3}, periods: {4}, </span><span class="s2">\ 
</span><span class="s4">missing: {5}, pandas: {6}, hold_back: {7}&quot;&quot;&quot;</span>

<span class="s1">ids = [param_fmt.format(*param) </span><span class="s2">for </span><span class="s1">param </span><span class="s2">in </span><span class="s1">params]</span>


<span class="s5"># Only test 1/3 to save time</span>
<span class="s1">@pytest.fixture(scope=</span><span class="s4">&quot;module&quot;</span><span class="s2">, </span><span class="s1">params=params[::</span><span class="s3">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">ids=ids[::</span><span class="s3">3</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">plot_data(request):</span>
    <span class="s1">lags</span><span class="s2">, </span><span class="s1">trend</span><span class="s2">, </span><span class="s1">seasonal = request.param[:</span><span class="s3">3</span><span class="s1">]</span>
    <span class="s1">nexog</span><span class="s2">, </span><span class="s1">period</span><span class="s2">, </span><span class="s1">missing</span><span class="s2">, </span><span class="s1">use_pandas</span><span class="s2">, </span><span class="s1">hold_back = request.param[</span><span class="s3">3</span><span class="s1">:]</span>
    <span class="s1">data = gen_data(</span><span class="s3">250</span><span class="s2">, </span><span class="s1">nexog</span><span class="s2">, </span><span class="s1">use_pandas)</span>
    <span class="s2">return </span><span class="s1">Bunch(</span>
        <span class="s1">trend=trend</span><span class="s2">,</span>
        <span class="s1">lags=lags</span><span class="s2">,</span>
        <span class="s1">seasonal=seasonal</span><span class="s2">,</span>
        <span class="s1">period=period</span><span class="s2">,</span>
        <span class="s1">endog=data.endog</span><span class="s2">,</span>
        <span class="s1">exog=data.exog</span><span class="s2">,</span>
        <span class="s1">missing=missing</span><span class="s2">,</span>
        <span class="s1">hold_back=hold_back</span><span class="s2">,</span>
    <span class="s1">)</span>


<span class="s1">@pytest.mark.matplotlib</span>
<span class="s1">@pytest.mark.smoke</span>
<span class="s2">def </span><span class="s1">test_autoreg_smoke_plots(plot_data</span><span class="s2">, </span><span class="s1">close_figures):</span>
    <span class="s2">from </span><span class="s1">matplotlib.figure </span><span class="s2">import </span><span class="s1">Figure</span>

    <span class="s1">mod = AutoReg(</span>
        <span class="s1">plot_data.endog</span><span class="s2">,</span>
        <span class="s1">plot_data.lags</span><span class="s2">,</span>
        <span class="s1">trend=plot_data.trend</span><span class="s2">,</span>
        <span class="s1">seasonal=plot_data.seasonal</span><span class="s2">,</span>
        <span class="s1">exog=plot_data.exog</span><span class="s2">,</span>
        <span class="s1">hold_back=plot_data.hold_back</span><span class="s2">,</span>
        <span class="s1">period=plot_data.period</span><span class="s2">,</span>
        <span class="s1">missing=plot_data.missing</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">res = mod.fit()</span>
    <span class="s1">fig = res.plot_diagnostics()</span>
    <span class="s2">assert </span><span class="s1">isinstance(fig</span><span class="s2">, </span><span class="s1">Figure)</span>
    <span class="s2">if </span><span class="s1">plot_data.exog </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">fig = res.plot_predict(end=</span><span class="s3">300</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">isinstance(fig</span><span class="s2">, </span><span class="s1">Figure)</span>
        <span class="s1">fig = res.plot_predict(end=</span><span class="s3">300</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s2">None, </span><span class="s1">in_sample=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">isinstance(fig</span><span class="s2">, </span><span class="s1">Figure)</span>
    <span class="s2">assert </span><span class="s1">isinstance(res.summary()</span><span class="s2">, </span><span class="s1">Summary)</span>


<span class="s1">@pytest.mark.smoke</span>
<span class="s2">def </span><span class="s1">test_autoreg_predict_smoke(ar_data):</span>
    <span class="s1">mod = AutoReg(</span>
        <span class="s1">ar_data.endog</span><span class="s2">,</span>
        <span class="s1">ar_data.lags</span><span class="s2">,</span>
        <span class="s1">trend=ar_data.trend</span><span class="s2">,</span>
        <span class="s1">seasonal=ar_data.seasonal</span><span class="s2">,</span>
        <span class="s1">exog=ar_data.exog</span><span class="s2">,</span>
        <span class="s1">hold_back=ar_data.hold_back</span><span class="s2">,</span>
        <span class="s1">period=ar_data.period</span><span class="s2">,</span>
        <span class="s1">missing=ar_data.missing</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">res = mod.fit()</span>
    <span class="s1">exog_oos = </span><span class="s2">None</span>
    <span class="s2">if </span><span class="s1">ar_data.exog </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">exog_oos = np.empty((</span><span class="s3">1</span><span class="s2">, </span><span class="s1">ar_data.exog.shape[</span><span class="s3">1</span><span class="s1">]))</span>
    <span class="s1">mod.predict(res.params</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">250</span><span class="s2">, </span><span class="s1">exog_oos=exog_oos)</span>
    <span class="s2">if </span><span class="s1">ar_data.lags == </span><span class="s3">0 </span><span class="s2">and </span><span class="s1">ar_data.exog </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">mod.predict(res.params</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">350</span><span class="s2">, </span><span class="s1">exog_oos=exog_oos)</span>
    <span class="s2">if </span><span class="s1">isinstance(ar_data.endog</span><span class="s2">, </span><span class="s1">pd.Series) </span><span class="s2">and </span><span class="s1">(</span>
        <span class="s2">not </span><span class="s1">ar_data.seasonal </span><span class="s2">or </span><span class="s1">ar_data.period </span><span class="s2">is not None</span>
    <span class="s1">):</span>
        <span class="s1">ar_data.endog.index = list(range(ar_data.endog.shape[</span><span class="s3">0</span><span class="s1">]))</span>
        <span class="s2">if </span><span class="s1">ar_data.exog </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">ar_data.exog.index = list(range(ar_data.endog.shape[</span><span class="s3">0</span><span class="s1">]))</span>
        <span class="s1">mod = AutoReg(</span>
            <span class="s1">ar_data.endog</span><span class="s2">,</span>
            <span class="s1">ar_data.lags</span><span class="s2">,</span>
            <span class="s1">trend=ar_data.trend</span><span class="s2">,</span>
            <span class="s1">seasonal=ar_data.seasonal</span><span class="s2">,</span>
            <span class="s1">exog=ar_data.exog</span><span class="s2">,</span>
            <span class="s1">period=ar_data.period</span><span class="s2">,</span>
            <span class="s1">missing=ar_data.missing</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">mod.predict(res.params</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">250</span><span class="s2">, </span><span class="s1">exog_oos=exog_oos)</span>


<span class="s1">@pytest.mark.matplotlib</span>
<span class="s2">def </span><span class="s1">test_parameterless_autoreg():</span>
    <span class="s1">data = gen_data(</span><span class="s3">250</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, False</span><span class="s1">)</span>
    <span class="s1">mod = AutoReg(data.endog</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s1">trend=</span><span class="s4">&quot;n&quot;</span><span class="s2">, </span><span class="s1">seasonal=</span><span class="s2">False, </span><span class="s1">exog=</span><span class="s2">None</span><span class="s1">)</span>
    <span class="s1">res = mod.fit()</span>
    <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">dir(res):</span>
        <span class="s2">if </span><span class="s1">attr.startswith(</span><span class="s4">&quot;_&quot;</span><span class="s1">):</span>
            <span class="s2">continue</span>

        <span class="s5"># TODO</span>
        <span class="s2">if </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">(</span>
            <span class="s4">&quot;predict&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;f_test&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;t_test&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;initialize&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;load&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;remove_data&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;save&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;t_test&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;t_test_pairwise&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;wald_test&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;wald_test_terms&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;apply&quot;</span><span class="s2">,</span>
            <span class="s4">&quot;append&quot;</span><span class="s2">,</span>
        <span class="s1">):</span>
            <span class="s2">continue</span>
        <span class="s1">attr = getattr(res</span><span class="s2">, </span><span class="s1">attr)</span>
        <span class="s2">if </span><span class="s1">callable(attr):</span>
            <span class="s1">attr()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">assert </span><span class="s1">isinstance(attr</span><span class="s2">, </span><span class="s1">object)</span>


<span class="s2">def </span><span class="s1">test_predict_errors():</span>
    <span class="s1">data = gen_data(</span><span class="s3">250</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, True</span><span class="s1">)</span>
    <span class="s1">mod = AutoReg(data.endog</span><span class="s2">, </span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">res = mod.fit()</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s4">&quot;exog and exog_oos cannot be used&quot;</span><span class="s1">):</span>
        <span class="s1">mod.predict(res.params</span><span class="s2">, </span><span class="s1">exog=data.exog)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s4">&quot;exog and exog_oos cannot be used&quot;</span><span class="s1">):</span>
        <span class="s1">mod.predict(res.params</span><span class="s2">, </span><span class="s1">exog_oos=data.exog)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s4">&quot;hold_back must be &gt;= lags&quot;</span><span class="s1">):</span>
        <span class="s1">AutoReg(data.endog</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s1">hold_back=</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s4">&quot;freq cannot be inferred&quot;</span><span class="s1">):</span>
        <span class="s1">AutoReg(data.endog.values</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s1">seasonal=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s1">mod = AutoReg(data.endog</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s1">exog=data.exog)</span>
    <span class="s1">res = mod.fit()</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s4">r&quot;The shape of exog \(200, 2\)&quot;</span><span class="s1">):</span>
        <span class="s1">mod.predict(res.params</span><span class="s2">, </span><span class="s1">exog=data.exog.iloc[:</span><span class="s3">200</span><span class="s1">])</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s4">&quot;The number of columns in exog_oos&quot;</span><span class="s1">):</span>
        <span class="s1">mod.predict(res.params</span><span class="s2">, </span><span class="s1">exog_oos=data.exog.iloc[:</span><span class="s2">, </span><span class="s1">:</span><span class="s3">1</span><span class="s1">])</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s4">&quot;Prediction must have `end` after&quot;</span><span class="s1">):</span>
        <span class="s1">mod.predict(res.params</span><span class="s2">, </span><span class="s1">start=</span><span class="s3">200</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">199</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s4">&quot;exog_oos must be provided&quot;</span><span class="s1">):</span>
        <span class="s1">mod.predict(res.params</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">250</span><span class="s2">, </span><span class="s1">exog_oos=</span><span class="s2">None</span><span class="s1">)</span>

    <span class="s1">mod = AutoReg(data.endog</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s1">exog=data.exog)</span>
    <span class="s1">res = mod.fit()</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s4">&quot;start and end indicate that 10&quot;</span><span class="s1">):</span>
        <span class="s1">mod.predict(res.params</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">259</span><span class="s2">, </span><span class="s1">exog_oos=data.exog.iloc[:</span><span class="s3">5</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">test_spec_errors():</span>
    <span class="s1">data = gen_data(</span><span class="s3">250</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, True</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s4">&quot;lags must be a non-negative scalar&quot;</span><span class="s1">):</span>
        <span class="s1">AutoReg(data.endog</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s4">&quot;All values in lags must be pos&quot;</span><span class="s1">):</span>
        <span class="s1">AutoReg(data.endog</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">])</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s4">&quot;All values in lags must be pos&quot;</span><span class="s1">):</span>
        <span class="s1">AutoReg(data.endog</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s1">])</span>


<span class="s1">@pytest.mark.smoke</span>
<span class="s2">def </span><span class="s1">test_dynamic_forecast_smoke(ar_data):</span>
    <span class="s1">mod = AutoReg(</span>
        <span class="s1">ar_data.endog</span><span class="s2">,</span>
        <span class="s1">ar_data.lags</span><span class="s2">,</span>
        <span class="s1">trend=ar_data.trend</span><span class="s2">,</span>
        <span class="s1">seasonal=ar_data.seasonal</span><span class="s2">,</span>
        <span class="s1">exog=ar_data.exog</span><span class="s2">,</span>
        <span class="s1">hold_back=ar_data.hold_back</span><span class="s2">,</span>
        <span class="s1">period=ar_data.period</span><span class="s2">,</span>
        <span class="s1">missing=ar_data.missing</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">res = mod.fit()</span>
    <span class="s1">res.predict(dynamic=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">ar_data.exog </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">res.predict(end=</span><span class="s3">260</span><span class="s2">, </span><span class="s1">dynamic=</span><span class="s2">True</span><span class="s1">)</span>


<span class="s1">@pytest.mark.smoke</span>
<span class="s2">def </span><span class="s1">test_ar_select_order_smoke():</span>
    <span class="s1">data = sunspots.load().data[</span><span class="s4">&quot;SUNACTIVITY&quot;</span><span class="s1">]</span>
    <span class="s1">ar_select_order(data</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s1">glob=</span><span class="s2">True, </span><span class="s1">trend=</span><span class="s4">&quot;n&quot;</span><span class="s1">)</span>
    <span class="s1">ar_select_order(data</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s1">glob=</span><span class="s2">False, </span><span class="s1">trend=</span><span class="s4">&quot;n&quot;</span><span class="s1">)</span>
    <span class="s1">ar_select_order(data</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s1">seasonal=</span><span class="s2">True, </span><span class="s1">period=</span><span class="s3">12</span><span class="s1">)</span>
    <span class="s1">ar_select_order(data</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s1">seasonal=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">ar_select_order(data</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s1">glob=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">ar_select_order(data</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s1">glob=</span><span class="s2">True, </span><span class="s1">seasonal=</span><span class="s2">True, </span><span class="s1">period=</span><span class="s3">12</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">CheckAutoRegMixin(CheckARMixin):</span>
    <span class="s2">def </span><span class="s1">test_bse(self):</span>
        <span class="s1">assert_almost_equal(self.res1.bse</span><span class="s2">, </span><span class="s1">self.res2.bse_stata</span><span class="s2">, </span><span class="s1">DECIMAL_6)</span>


<span class="s2">class </span><span class="s1">TestAutoRegOLSConstant(CheckAutoRegMixin):</span>
    <span class="s0">&quot;&quot;&quot; 
    Test AutoReg fit by OLS with a constant. 
    &quot;&quot;&quot;</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">data = sunspots.load()</span>
        <span class="s1">data.endog.index = list(range(len(data.endog)))</span>
        <span class="s1">cls.res1 = AutoReg(data.endog</span><span class="s2">, </span><span class="s1">lags=</span><span class="s3">9</span><span class="s1">).fit()</span>
        <span class="s1">cls.res2 = results_ar.ARResultsOLS(constant=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_predict(self):</span>
        <span class="s1">model = self.res1.model</span>
        <span class="s1">params = self.res1.params</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">model.predict(params)[model.hold_back :]</span><span class="s2">,</span>
            <span class="s1">self.res2.FVOLSnneg1start0</span><span class="s2">,</span>
            <span class="s1">DECIMAL_4</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">model.predict(params)[model.hold_back :]</span><span class="s2">,</span>
            <span class="s1">self.res2.FVOLSnneg1start9</span><span class="s2">,</span>
            <span class="s1">DECIMAL_4</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">model.predict(params</span><span class="s2">, </span><span class="s1">start=</span><span class="s3">100</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">self.res2.FVOLSnneg1start100</span><span class="s2">,</span>
            <span class="s1">DECIMAL_4</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">model.predict(params</span><span class="s2">, </span><span class="s1">start=</span><span class="s3">9</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">200</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">self.res2.FVOLSn200start0</span><span class="s2">,</span>
            <span class="s1">DECIMAL_4</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">model.predict(params)[model.hold_back :]</span><span class="s2">,</span>
            <span class="s1">self.res2.FVOLSdefault</span><span class="s2">,</span>
            <span class="s1">DECIMAL_4</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">model.predict(params</span><span class="s2">, </span><span class="s1">start=</span><span class="s3">200</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">400</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">self.res2.FVOLSn200start200</span><span class="s2">,</span>
            <span class="s1">DECIMAL_4</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">model.predict(params</span><span class="s2">, </span><span class="s1">start=</span><span class="s3">308</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">424</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">self.res2.FVOLSn100start325</span><span class="s2">,</span>
            <span class="s1">DECIMAL_4</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">model.predict(params</span><span class="s2">, </span><span class="s1">start=</span><span class="s3">9</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">310</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">self.res2.FVOLSn301start9</span><span class="s2">,</span>
            <span class="s1">DECIMAL_4</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">model.predict(params</span><span class="s2">, </span><span class="s1">start=</span><span class="s3">308</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">316</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">self.res2.FVOLSn4start312</span><span class="s2">,</span>
            <span class="s1">DECIMAL_4</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">model.predict(params</span><span class="s2">, </span><span class="s1">start=</span><span class="s3">308</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">327</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">self.res2.FVOLSn15start312</span><span class="s2">,</span>
            <span class="s1">DECIMAL_4</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestAutoRegOLSNoConstant(CheckAutoRegMixin):</span>
    <span class="s0">&quot;&quot;&quot;f 
    Test AR fit by OLS without a constant. 
    &quot;&quot;&quot;</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">data = sunspots.load()</span>
        <span class="s1">cls.res1 = AutoReg(np.asarray(data.endog)</span><span class="s2">, </span><span class="s1">lags=</span><span class="s3">9</span><span class="s2">, </span><span class="s1">trend=</span><span class="s4">&quot;n&quot;</span><span class="s1">).fit()</span>
        <span class="s1">cls.res2 = results_ar.ARResultsOLS(constant=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_predict(self):</span>
        <span class="s1">model = self.res1.model</span>
        <span class="s1">params = self.res1.params</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">model.predict(params)[model.hold_back :]</span><span class="s2">,</span>
            <span class="s1">self.res2.FVOLSnneg1start0</span><span class="s2">,</span>
            <span class="s1">DECIMAL_4</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">model.predict(params)[model.hold_back :]</span><span class="s2">,</span>
            <span class="s1">self.res2.FVOLSnneg1start9</span><span class="s2">,</span>
            <span class="s1">DECIMAL_4</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">model.predict(params</span><span class="s2">, </span><span class="s1">start=</span><span class="s3">100</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">self.res2.FVOLSnneg1start100</span><span class="s2">,</span>
            <span class="s1">DECIMAL_4</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">model.predict(params</span><span class="s2">, </span><span class="s1">start=</span><span class="s3">9</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">200</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">self.res2.FVOLSn200start0</span><span class="s2">,</span>
            <span class="s1">DECIMAL_4</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">model.predict(params)[model.hold_back :]</span><span class="s2">,</span>
            <span class="s1">self.res2.FVOLSdefault</span><span class="s2">,</span>
            <span class="s1">DECIMAL_4</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">model.predict(params</span><span class="s2">, </span><span class="s1">start=</span><span class="s3">200</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">400</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">self.res2.FVOLSn200start200</span><span class="s2">,</span>
            <span class="s1">DECIMAL_4</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">model.predict(params</span><span class="s2">, </span><span class="s1">start=</span><span class="s3">308</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">424</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">self.res2.FVOLSn100start325</span><span class="s2">,</span>
            <span class="s1">DECIMAL_4</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">model.predict(params</span><span class="s2">, </span><span class="s1">start=</span><span class="s3">9</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">310</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">self.res2.FVOLSn301start9</span><span class="s2">,</span>
            <span class="s1">DECIMAL_4</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">model.predict(params</span><span class="s2">, </span><span class="s1">start=</span><span class="s3">308</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">316</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">self.res2.FVOLSn4start312</span><span class="s2">,</span>
            <span class="s1">DECIMAL_4</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">model.predict(params</span><span class="s2">, </span><span class="s1">start=</span><span class="s3">308</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">327</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">self.res2.FVOLSn15start312</span><span class="s2">,</span>
            <span class="s1">DECIMAL_4</span><span class="s2">,</span>
        <span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;lag&quot;</span><span class="s2">, </span><span class="s1">list(np.arange(</span><span class="s3">1</span><span class="s2">, </span><span class="s3">16 </span><span class="s1">+ </span><span class="s3">1</span><span class="s1">)))</span>
<span class="s2">def </span><span class="s1">test_autoreg_info_criterion(lag):</span>
    <span class="s1">data = sunspots.load()</span>
    <span class="s1">endog = np.asarray(data.endog)</span>
    <span class="s1">endog_tmp = endog[</span><span class="s3">16 </span><span class="s1">- lag :]</span>
    <span class="s1">r = AutoReg(endog_tmp</span><span class="s2">, </span><span class="s1">lags=lag).fit()</span>
    <span class="s5"># See issue #324 for the corrections vs. R</span>
    <span class="s1">aic = r.aic</span>
    <span class="s1">hqic = r.hqic</span>
    <span class="s1">bic = r.bic</span>

    <span class="s1">res1 = np.array([aic</span><span class="s2">, </span><span class="s1">hqic</span><span class="s2">, </span><span class="s1">bic</span><span class="s2">, </span><span class="s1">r.fpe])</span>
    <span class="s5"># aic correction to match R</span>
    <span class="s1">res2 = results_ar.ARLagResults(</span><span class="s4">&quot;const&quot;</span><span class="s1">).ic.T</span>
    <span class="s1">comp = res2[lag - </span><span class="s3">1</span><span class="s2">, </span><span class="s1">:].copy()</span>
    <span class="s1">k = </span><span class="s3">2 </span><span class="s1">+ lag</span>
    <span class="s1">pen = np.array([</span><span class="s3">2</span><span class="s2">, </span><span class="s3">2 </span><span class="s1">* np.log(np.log(r.nobs))</span><span class="s2">, </span><span class="s1">np.log(r.nobs)])</span>
    <span class="s1">comp[:</span><span class="s3">3</span><span class="s1">] = -</span><span class="s3">2 </span><span class="s1">* r.llf + pen * k</span>
    <span class="s1">assert_almost_equal(res1</span><span class="s2">, </span><span class="s1">comp</span><span class="s2">, </span><span class="s1">DECIMAL_6)</span>

    <span class="s1">r2 = AutoReg(endog</span><span class="s2">, </span><span class="s1">lags=lag</span><span class="s2">, </span><span class="s1">hold_back=</span><span class="s3">16</span><span class="s1">).fit()</span>
    <span class="s1">assert_allclose(r.aic</span><span class="s2">, </span><span class="s1">r2.aic)</span>
    <span class="s1">assert_allclose(r.bic</span><span class="s2">, </span><span class="s1">r2.bic)</span>
    <span class="s1">assert_allclose(r.hqic</span><span class="s2">, </span><span class="s1">r2.hqic)</span>
    <span class="s1">assert_allclose(r.fpe</span><span class="s2">, </span><span class="s1">r2.fpe)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;old_names&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_autoreg_named_series(reset_randomstate</span><span class="s2">, </span><span class="s1">old_names):</span>
    <span class="s1">warning = FutureWarning </span><span class="s2">if </span><span class="s1">old_names </span><span class="s2">else None</span>
    <span class="s1">dates = period_range(start=</span><span class="s4">&quot;2011-1&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s3">72</span><span class="s2">, </span><span class="s1">freq=</span><span class="s4">&quot;M&quot;</span><span class="s1">)</span>
    <span class="s1">y = Series(np.random.randn(</span><span class="s3">72</span><span class="s1">)</span><span class="s2">, </span><span class="s1">name=</span><span class="s4">&quot;foobar&quot;</span><span class="s2">, </span><span class="s1">index=dates)</span>
    <span class="s2">with </span><span class="s1">pytest_warns(warning):</span>
        <span class="s1">results = AutoReg(y</span><span class="s2">, </span><span class="s1">lags=</span><span class="s3">2</span><span class="s2">, </span><span class="s1">old_names=old_names).fit()</span>

    <span class="s2">if </span><span class="s1">old_names:</span>
        <span class="s1">idx = Index([</span><span class="s4">&quot;intercept&quot;</span><span class="s2">, </span><span class="s4">&quot;foobar.L1&quot;</span><span class="s2">, </span><span class="s4">&quot;foobar.L2&quot;</span><span class="s1">])</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">idx = Index([</span><span class="s4">&quot;const&quot;</span><span class="s2">, </span><span class="s4">&quot;foobar.L1&quot;</span><span class="s2">, </span><span class="s4">&quot;foobar.L2&quot;</span><span class="s1">])</span>
    <span class="s2">assert </span><span class="s1">results.params.index.equals(idx)</span>


<span class="s1">@pytest.mark.smoke</span>
<span class="s2">def </span><span class="s1">test_autoreg_series():</span>
    <span class="s5"># GH#773</span>
    <span class="s1">dta = macrodata.load_pandas().data[</span><span class="s4">&quot;cpi&quot;</span><span class="s1">].diff().dropna()</span>
    <span class="s1">dates = period_range(start=</span><span class="s4">&quot;1959Q1&quot;</span><span class="s2">, </span><span class="s1">periods=len(dta)</span><span class="s2">, </span><span class="s1">freq=</span><span class="s4">&quot;Q&quot;</span><span class="s1">)</span>
    <span class="s1">dta.index = dates</span>
    <span class="s1">ar = AutoReg(dta</span><span class="s2">, </span><span class="s1">lags=</span><span class="s3">15</span><span class="s1">).fit()</span>
    <span class="s1">ar.bse</span>


<span class="s2">def </span><span class="s1">test_ar_order_select():</span>
    <span class="s5"># GH#2118</span>
    <span class="s1">np.random.seed(</span><span class="s3">12345</span><span class="s1">)</span>
    <span class="s1">y = arma_generate_sample([</span><span class="s3">1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.75</span><span class="s2">, </span><span class="s3">0.3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s3">100</span><span class="s1">)</span>
    <span class="s1">ts = Series(</span>
        <span class="s1">y</span><span class="s2">,</span>
        <span class="s1">index=date_range(start=dt.datetime(</span><span class="s3">1990</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">periods=</span><span class="s3">100</span><span class="s2">, </span><span class="s1">freq=</span><span class="s4">&quot;M&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">res = ar_select_order(ts</span><span class="s2">, </span><span class="s1">maxlag=</span><span class="s3">12</span><span class="s2">, </span><span class="s1">ic=</span><span class="s4">&quot;aic&quot;</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">tuple(res.ar_lags) == (</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">isinstance(res.aic</span><span class="s2">, </span><span class="s1">dict)</span>
    <span class="s2">assert </span><span class="s1">isinstance(res.bic</span><span class="s2">, </span><span class="s1">dict)</span>
    <span class="s2">assert </span><span class="s1">isinstance(res.hqic</span><span class="s2">, </span><span class="s1">dict)</span>
    <span class="s2">assert </span><span class="s1">isinstance(res.model</span><span class="s2">, </span><span class="s1">AutoReg)</span>
    <span class="s2">assert not </span><span class="s1">res.seasonal</span>
    <span class="s2">assert </span><span class="s1">res.trend == </span><span class="s4">&quot;c&quot;</span>
    <span class="s2">assert </span><span class="s1">res.period </span><span class="s2">is None</span>


<span class="s2">def </span><span class="s1">test_autoreg_constant_column_trend():</span>
    <span class="s1">sample = np.array(</span>
        <span class="s1">[</span>
            <span class="s3">0.46341460943222046</span><span class="s2">,</span>
            <span class="s3">0.46341460943222046</span><span class="s2">,</span>
            <span class="s3">0.39024388790130615</span><span class="s2">,</span>
            <span class="s3">0.4146341383457184</span><span class="s2">,</span>
            <span class="s3">0.4146341383457184</span><span class="s2">,</span>
            <span class="s3">0.4146341383457184</span><span class="s2">,</span>
            <span class="s3">0.3414634168148041</span><span class="s2">,</span>
            <span class="s3">0.4390243887901306</span><span class="s2">,</span>
            <span class="s3">0.46341460943222046</span><span class="s2">,</span>
            <span class="s3">0.4390243887901306</span><span class="s2">,</span>
        <span class="s1">]</span>
    <span class="s1">)</span>

    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s4">&quot;The model specification cannot&quot;</span><span class="s1">):</span>
        <span class="s1">AutoReg(sample</span><span class="s2">, </span><span class="s1">lags=</span><span class="s3">7</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s4">&quot;The model specification cannot&quot;</span><span class="s1">):</span>
        <span class="s1">AutoReg(sample</span><span class="s2">, </span><span class="s1">lags=</span><span class="s3">7</span><span class="s2">, </span><span class="s1">trend=</span><span class="s4">&quot;n&quot;</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;old_names&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_autoreg_summary_corner(old_names):</span>
    <span class="s1">data = macrodata.load_pandas().data[</span><span class="s4">&quot;cpi&quot;</span><span class="s1">].diff().dropna()</span>
    <span class="s1">dates = period_range(start=</span><span class="s4">&quot;1959Q1&quot;</span><span class="s2">, </span><span class="s1">periods=len(data)</span><span class="s2">, </span><span class="s1">freq=</span><span class="s4">&quot;Q&quot;</span><span class="s1">)</span>
    <span class="s1">data.index = dates</span>
    <span class="s1">warning = FutureWarning </span><span class="s2">if </span><span class="s1">old_names </span><span class="s2">else None</span>
    <span class="s2">with </span><span class="s1">pytest_warns(warning):</span>
        <span class="s1">res = AutoReg(data</span><span class="s2">, </span><span class="s1">lags=</span><span class="s3">4</span><span class="s2">, </span><span class="s1">old_names=old_names).fit()</span>
    <span class="s1">summ = res.summary().as_text()</span>
    <span class="s2">assert </span><span class="s4">&quot;AutoReg(4)&quot; </span><span class="s2">in </span><span class="s1">summ</span>
    <span class="s2">assert </span><span class="s4">&quot;cpi.L4&quot; </span><span class="s2">in </span><span class="s1">summ</span>
    <span class="s2">assert </span><span class="s4">&quot;03-31-1960&quot; </span><span class="s2">in </span><span class="s1">summ</span>
    <span class="s2">with </span><span class="s1">pytest_warns(warning):</span>
        <span class="s1">res = AutoReg(data</span><span class="s2">, </span><span class="s1">lags=</span><span class="s3">0</span><span class="s2">, </span><span class="s1">old_names=old_names).fit()</span>
    <span class="s1">summ = res.summary().as_text()</span>
    <span class="s2">if </span><span class="s1">old_names:</span>
        <span class="s2">assert </span><span class="s4">&quot;intercept&quot; </span><span class="s2">in </span><span class="s1">summ</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">assert </span><span class="s4">&quot;const&quot; </span><span class="s2">in </span><span class="s1">summ</span>
    <span class="s2">assert </span><span class="s4">&quot;AutoReg(0)&quot; </span><span class="s2">in </span><span class="s1">summ</span>


<span class="s1">@pytest.mark.smoke</span>
<span class="s2">def </span><span class="s1">test_autoreg_score():</span>
    <span class="s1">data = sunspots.load_pandas()</span>
    <span class="s1">ar = AutoReg(np.asarray(data.endog)</span><span class="s2">, </span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">res = ar.fit()</span>
    <span class="s1">score = ar.score(res.params)</span>
    <span class="s2">assert </span><span class="s1">isinstance(score</span><span class="s2">, </span><span class="s1">np.ndarray)</span>
    <span class="s2">assert </span><span class="s1">score.shape == (</span><span class="s3">4</span><span class="s2">,</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">ar.information(res.params).shape == (</span><span class="s3">4</span><span class="s2">, </span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">assert_allclose(-ar.hessian(res.params)</span><span class="s2">, </span><span class="s1">ar.information(res.params))</span>


<span class="s2">def </span><span class="s1">test_autoreg_roots():</span>
    <span class="s1">data = sunspots.load_pandas()</span>
    <span class="s1">ar = AutoReg(np.asarray(data.endog)</span><span class="s2">, </span><span class="s1">lags=</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">res = ar.fit()</span>
    <span class="s1">assert_almost_equal(res.roots</span><span class="s2">, </span><span class="s1">np.array([</span><span class="s3">1.0 </span><span class="s1">/ res.params[-</span><span class="s3">1</span><span class="s1">]]))</span>


<span class="s2">def </span><span class="s1">test_equiv_dynamic(reset_randomstate):</span>
    <span class="s1">e = np.random.standard_normal(</span><span class="s3">1001</span><span class="s1">)</span>
    <span class="s1">y = np.empty(</span><span class="s3">1001</span><span class="s1">)</span>
    <span class="s1">y[</span><span class="s3">0</span><span class="s1">] = e[</span><span class="s3">0</span><span class="s1">] * np.sqrt(</span><span class="s3">1.0 </span><span class="s1">/ (</span><span class="s3">1 </span><span class="s1">- </span><span class="s3">0.9 </span><span class="s1">** </span><span class="s3">2</span><span class="s1">))</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1001</span><span class="s1">):</span>
        <span class="s1">y[i] = </span><span class="s3">0.9 </span><span class="s1">* y[i - </span><span class="s3">1</span><span class="s1">] + e[i]</span>
    <span class="s1">mod = AutoReg(y</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">res = mod.fit()</span>
    <span class="s1">pred0 = res.predict(</span><span class="s3">500</span><span class="s2">, </span><span class="s3">800</span><span class="s2">, </span><span class="s1">dynamic=</span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">pred1 = res.predict(</span><span class="s3">500</span><span class="s2">, </span><span class="s3">800</span><span class="s2">, </span><span class="s1">dynamic=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">idx = pd.date_range(dt.datetime(</span><span class="s3">2000</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">30</span><span class="s1">)</span><span class="s2">, </span><span class="s1">periods=</span><span class="s3">1001</span><span class="s2">, </span><span class="s1">freq=</span><span class="s4">&quot;M&quot;</span><span class="s1">)</span>
    <span class="s1">y = pd.Series(y</span><span class="s2">, </span><span class="s1">index=idx)</span>
    <span class="s1">mod = AutoReg(y</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">res = mod.fit()</span>
    <span class="s1">pred2 = res.predict(idx[</span><span class="s3">500</span><span class="s1">]</span><span class="s2">, </span><span class="s1">idx[</span><span class="s3">800</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dynamic=idx[</span><span class="s3">500</span><span class="s1">])</span>
    <span class="s1">pred3 = res.predict(idx[</span><span class="s3">500</span><span class="s1">]</span><span class="s2">, </span><span class="s1">idx[</span><span class="s3">800</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dynamic=</span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">pred4 = res.predict(idx[</span><span class="s3">500</span><span class="s1">]</span><span class="s2">, </span><span class="s1">idx[</span><span class="s3">800</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dynamic=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">assert_allclose(pred0</span><span class="s2">, </span><span class="s1">pred1)</span>
    <span class="s1">assert_allclose(pred0</span><span class="s2">, </span><span class="s1">pred2)</span>
    <span class="s1">assert_allclose(pred0</span><span class="s2">, </span><span class="s1">pred3)</span>
    <span class="s1">assert_allclose(pred0</span><span class="s2">, </span><span class="s1">pred4)</span>


<span class="s2">def </span><span class="s1">test_dynamic_against_sarimax():</span>
    <span class="s1">rs = np.random.RandomState(</span><span class="s3">12345678</span><span class="s1">)</span>
    <span class="s1">e = rs.standard_normal(</span><span class="s3">1001</span><span class="s1">)</span>
    <span class="s1">y = np.empty(</span><span class="s3">1001</span><span class="s1">)</span>
    <span class="s1">y[</span><span class="s3">0</span><span class="s1">] = e[</span><span class="s3">0</span><span class="s1">] * np.sqrt(</span><span class="s3">1.0 </span><span class="s1">/ (</span><span class="s3">1 </span><span class="s1">- </span><span class="s3">0.9 </span><span class="s1">** </span><span class="s3">2</span><span class="s1">))</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1001</span><span class="s1">):</span>
        <span class="s1">y[i] = </span><span class="s3">0.9 </span><span class="s1">* y[i - </span><span class="s3">1</span><span class="s1">] + e[i]</span>
    <span class="s1">smod = SARIMAX(y</span><span class="s2">, </span><span class="s1">order=(</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s4">&quot;c&quot;</span><span class="s1">)</span>
    <span class="s1">sres = smod.fit(disp=</span><span class="s2">False, </span><span class="s1">iprint=-</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">mod = AutoReg(y</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">spred = sres.predict(</span><span class="s3">900</span><span class="s2">, </span><span class="s3">1100</span><span class="s1">)</span>
    <span class="s1">pred = mod.predict(sres.params[:</span><span class="s3">2</span><span class="s1">]</span><span class="s2">, </span><span class="s3">900</span><span class="s2">, </span><span class="s3">1100</span><span class="s1">)</span>
    <span class="s1">assert_allclose(spred</span><span class="s2">, </span><span class="s1">pred)</span>

    <span class="s1">spred = sres.predict(</span><span class="s3">900</span><span class="s2">, </span><span class="s3">1100</span><span class="s2">, </span><span class="s1">dynamic=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">pred = mod.predict(sres.params[:</span><span class="s3">2</span><span class="s1">]</span><span class="s2">, </span><span class="s3">900</span><span class="s2">, </span><span class="s3">1100</span><span class="s2">, </span><span class="s1">dynamic=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">assert_allclose(spred</span><span class="s2">, </span><span class="s1">pred)</span>

    <span class="s1">spred = sres.predict(</span><span class="s3">900</span><span class="s2">, </span><span class="s3">1100</span><span class="s2">, </span><span class="s1">dynamic=</span><span class="s3">50</span><span class="s1">)</span>
    <span class="s1">pred = mod.predict(sres.params[:</span><span class="s3">2</span><span class="s1">]</span><span class="s2">, </span><span class="s3">900</span><span class="s2">, </span><span class="s3">1100</span><span class="s2">, </span><span class="s1">dynamic=</span><span class="s3">50</span><span class="s1">)</span>
    <span class="s1">assert_allclose(spred</span><span class="s2">, </span><span class="s1">pred)</span>


<span class="s2">def </span><span class="s1">test_predict_seasonal():</span>
    <span class="s1">rs = np.random.RandomState(</span><span class="s3">12345678</span><span class="s1">)</span>
    <span class="s1">e = rs.standard_normal(</span><span class="s3">1001</span><span class="s1">)</span>
    <span class="s1">y = np.empty(</span><span class="s3">1001</span><span class="s1">)</span>
    <span class="s1">y[</span><span class="s3">0</span><span class="s1">] = e[</span><span class="s3">0</span><span class="s1">] * np.sqrt(</span><span class="s3">1.0 </span><span class="s1">/ (</span><span class="s3">1 </span><span class="s1">- </span><span class="s3">0.9 </span><span class="s1">** </span><span class="s3">2</span><span class="s1">))</span>
    <span class="s1">effects = </span><span class="s3">10 </span><span class="s1">* np.cos(np.arange(</span><span class="s3">12</span><span class="s1">) / </span><span class="s3">11 </span><span class="s1">* </span><span class="s3">2 </span><span class="s1">* np.pi)</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1001</span><span class="s1">):</span>
        <span class="s1">y[i] = </span><span class="s3">10 </span><span class="s1">+ </span><span class="s3">0.9 </span><span class="s1">* y[i - </span><span class="s3">1</span><span class="s1">] + e[i] + effects[i % </span><span class="s3">12</span><span class="s1">]</span>
    <span class="s1">ys = pd.Series(</span>
        <span class="s1">y</span><span class="s2">, </span><span class="s1">index=pd.date_range(dt.datetime(</span><span class="s3">1950</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">periods=</span><span class="s3">1001</span><span class="s2">, </span><span class="s1">freq=</span><span class="s4">&quot;M&quot;</span><span class="s1">)</span>
    <span class="s1">)</span>
    <span class="s1">mod = AutoReg(ys</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s1">seasonal=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">res = mod.fit()</span>
    <span class="s1">c = res.params.iloc[</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s1">seasons = np.zeros(</span><span class="s3">12</span><span class="s1">)</span>
    <span class="s1">seasons[</span><span class="s3">1</span><span class="s1">:] = res.params.iloc[</span><span class="s3">1</span><span class="s1">:-</span><span class="s3">1</span><span class="s1">]</span>
    <span class="s1">ar = res.params.iloc[-</span><span class="s3">1</span><span class="s1">]</span>
    <span class="s1">pred = res.predict(</span><span class="s3">900</span><span class="s2">, </span><span class="s3">1100</span><span class="s2">, True</span><span class="s1">)</span>
    <span class="s1">direct = np.zeros(</span><span class="s3">201</span><span class="s1">)</span>
    <span class="s1">direct[</span><span class="s3">0</span><span class="s1">] = y[</span><span class="s3">899</span><span class="s1">] * ar + c + seasons[</span><span class="s3">900 </span><span class="s1">% </span><span class="s3">12</span><span class="s1">]</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s3">1</span><span class="s2">, </span><span class="s3">201</span><span class="s1">):</span>
        <span class="s1">direct[i] = direct[i - </span><span class="s3">1</span><span class="s1">] * ar + c + seasons[(</span><span class="s3">900 </span><span class="s1">+ i) % </span><span class="s3">12</span><span class="s1">]</span>
    <span class="s1">direct = pd.Series(</span>
        <span class="s1">direct</span><span class="s2">, </span><span class="s1">index=pd.date_range(ys.index[</span><span class="s3">900</span><span class="s1">]</span><span class="s2">, </span><span class="s1">periods=</span><span class="s3">201</span><span class="s2">, </span><span class="s1">freq=</span><span class="s4">&quot;M&quot;</span><span class="s1">)</span>
    <span class="s1">)</span>
    <span class="s1">assert_series_equal(pred</span><span class="s2">, </span><span class="s1">direct)</span>

    <span class="s1">pred = res.predict(</span><span class="s3">900</span><span class="s2">, </span><span class="s1">dynamic=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">direct = y[</span><span class="s3">899</span><span class="s1">:-</span><span class="s3">1</span><span class="s1">] * ar + c + seasons[np.arange(</span><span class="s3">900</span><span class="s2">, </span><span class="s3">1001</span><span class="s1">) % </span><span class="s3">12</span><span class="s1">]</span>
    <span class="s1">direct = pd.Series(</span>
        <span class="s1">direct</span><span class="s2">, </span><span class="s1">index=pd.date_range(ys.index[</span><span class="s3">900</span><span class="s1">]</span><span class="s2">, </span><span class="s1">periods=</span><span class="s3">101</span><span class="s2">, </span><span class="s1">freq=</span><span class="s4">&quot;M&quot;</span><span class="s1">)</span>
    <span class="s1">)</span>
    <span class="s1">assert_series_equal(pred</span><span class="s2">, </span><span class="s1">direct)</span>


<span class="s2">def </span><span class="s1">test_predict_exog():</span>
    <span class="s1">rs = np.random.RandomState(</span><span class="s3">12345678</span><span class="s1">)</span>
    <span class="s1">e = rs.standard_normal(</span><span class="s3">1001</span><span class="s1">)</span>
    <span class="s1">y = np.empty(</span><span class="s3">1001</span><span class="s1">)</span>
    <span class="s1">x = rs.standard_normal((</span><span class="s3">1001</span><span class="s2">, </span><span class="s3">2</span><span class="s1">))</span>
    <span class="s1">y[:</span><span class="s3">3</span><span class="s1">] = e[:</span><span class="s3">3</span><span class="s1">] * np.sqrt(</span><span class="s3">1.0 </span><span class="s1">/ (</span><span class="s3">1 </span><span class="s1">- </span><span class="s3">0.9 </span><span class="s1">** </span><span class="s3">2</span><span class="s1">)) + x[:</span><span class="s3">3</span><span class="s1">].sum(</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s3">3</span><span class="s2">, </span><span class="s3">1001</span><span class="s1">):</span>
        <span class="s1">y[i] = </span><span class="s3">10 </span><span class="s1">+ </span><span class="s3">0.9 </span><span class="s1">* y[i - </span><span class="s3">1</span><span class="s1">] - </span><span class="s3">0.5 </span><span class="s1">* y[i - </span><span class="s3">3</span><span class="s1">] + e[i] + x[i].sum()</span>
    <span class="s1">ys = pd.Series(</span>
        <span class="s1">y</span><span class="s2">, </span><span class="s1">index=pd.date_range(dt.datetime(</span><span class="s3">1950</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">periods=</span><span class="s3">1001</span><span class="s2">, </span><span class="s1">freq=</span><span class="s4">&quot;M&quot;</span><span class="s1">)</span>
    <span class="s1">)</span>
    <span class="s1">xdf = pd.DataFrame(x</span><span class="s2">, </span><span class="s1">columns=[</span><span class="s4">&quot;x0&quot;</span><span class="s2">, </span><span class="s4">&quot;x1&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">index=ys.index)</span>
    <span class="s1">mod = AutoReg(ys</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">trend=</span><span class="s4">&quot;c&quot;</span><span class="s2">, </span><span class="s1">exog=xdf)</span>
    <span class="s1">res = mod.fit()</span>
    <span class="s2">assert </span><span class="s4">&quot;-X&quot; </span><span class="s2">in </span><span class="s1">str(res.summary())</span>

    <span class="s1">pred = res.predict(</span><span class="s3">900</span><span class="s1">)</span>
    <span class="s1">c = res.params.iloc[</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s1">ar = res.params.iloc[</span><span class="s3">1</span><span class="s1">:</span><span class="s3">3</span><span class="s1">]</span>
    <span class="s1">ex = np.asarray(res.params.iloc[</span><span class="s3">3</span><span class="s1">:])</span>
    <span class="s1">direct = c + ar[</span><span class="s3">0</span><span class="s1">] * y[</span><span class="s3">899</span><span class="s1">:-</span><span class="s3">1</span><span class="s1">] + ar[</span><span class="s3">1</span><span class="s1">] * y[</span><span class="s3">897</span><span class="s1">:-</span><span class="s3">3</span><span class="s1">]</span>
    <span class="s1">direct += ex[</span><span class="s3">0</span><span class="s1">] * x[</span><span class="s3">900</span><span class="s1">:</span><span class="s2">, </span><span class="s3">0</span><span class="s1">] + ex[</span><span class="s3">1</span><span class="s1">] * x[</span><span class="s3">900</span><span class="s1">:</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]</span>
    <span class="s1">idx = pd.date_range(ys.index[</span><span class="s3">900</span><span class="s1">]</span><span class="s2">, </span><span class="s1">periods=</span><span class="s3">101</span><span class="s2">, </span><span class="s1">freq=</span><span class="s4">&quot;M&quot;</span><span class="s1">)</span>
    <span class="s1">direct = pd.Series(direct</span><span class="s2">, </span><span class="s1">index=idx)</span>
    <span class="s1">assert_series_equal(pred</span><span class="s2">, </span><span class="s1">direct)</span>
    <span class="s1">exog_oos = rs.standard_normal((</span><span class="s3">100</span><span class="s2">, </span><span class="s3">2</span><span class="s1">))</span>

    <span class="s1">pred = res.predict(</span><span class="s3">900</span><span class="s2">, </span><span class="s3">1100</span><span class="s2">, </span><span class="s1">dynamic=</span><span class="s2">True, </span><span class="s1">exog_oos=exog_oos)</span>
    <span class="s1">direct = np.zeros(</span><span class="s3">201</span><span class="s1">)</span>
    <span class="s1">direct[</span><span class="s3">0</span><span class="s1">] = c + ar[</span><span class="s3">0</span><span class="s1">] * y[</span><span class="s3">899</span><span class="s1">] + ar[</span><span class="s3">1</span><span class="s1">] * y[</span><span class="s3">897</span><span class="s1">] + x[</span><span class="s3">900</span><span class="s1">] @ ex</span>
    <span class="s1">direct[</span><span class="s3">1</span><span class="s1">] = c + ar[</span><span class="s3">0</span><span class="s1">] * direct[</span><span class="s3">0</span><span class="s1">] + ar[</span><span class="s3">1</span><span class="s1">] * y[</span><span class="s3">898</span><span class="s1">] + x[</span><span class="s3">901</span><span class="s1">] @ ex</span>
    <span class="s1">direct[</span><span class="s3">2</span><span class="s1">] = c + ar[</span><span class="s3">0</span><span class="s1">] * direct[</span><span class="s3">1</span><span class="s1">] + ar[</span><span class="s3">1</span><span class="s1">] * y[</span><span class="s3">899</span><span class="s1">] + x[</span><span class="s3">902</span><span class="s1">] @ ex</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s3">3</span><span class="s2">, </span><span class="s3">201</span><span class="s1">):</span>
        <span class="s1">direct[i] = c + ar[</span><span class="s3">0</span><span class="s1">] * direct[i - </span><span class="s3">1</span><span class="s1">] + ar[</span><span class="s3">1</span><span class="s1">] * direct[i - </span><span class="s3">3</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s3">900 </span><span class="s1">+ i &lt; x.shape[</span><span class="s3">0</span><span class="s1">]:</span>
            <span class="s1">direct[i] += x[</span><span class="s3">900 </span><span class="s1">+ i] @ ex</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">direct[i] += exog_oos[i - </span><span class="s3">101</span><span class="s1">] @ ex</span>

    <span class="s1">direct = pd.Series(</span>
        <span class="s1">direct</span><span class="s2">, </span><span class="s1">index=pd.date_range(ys.index[</span><span class="s3">900</span><span class="s1">]</span><span class="s2">, </span><span class="s1">periods=</span><span class="s3">201</span><span class="s2">, </span><span class="s1">freq=</span><span class="s4">&quot;M&quot;</span><span class="s1">)</span>
    <span class="s1">)</span>
    <span class="s1">assert_series_equal(pred</span><span class="s2">, </span><span class="s1">direct)</span>


<span class="s2">def </span><span class="s1">test_predict_irregular_ar():</span>
    <span class="s1">rs = np.random.RandomState(</span><span class="s3">12345678</span><span class="s1">)</span>
    <span class="s1">e = rs.standard_normal(</span><span class="s3">1001</span><span class="s1">)</span>
    <span class="s1">y = np.empty(</span><span class="s3">1001</span><span class="s1">)</span>
    <span class="s1">y[:</span><span class="s3">3</span><span class="s1">] = e[:</span><span class="s3">3</span><span class="s1">] * np.sqrt(</span><span class="s3">1.0 </span><span class="s1">/ (</span><span class="s3">1 </span><span class="s1">- </span><span class="s3">0.9 </span><span class="s1">** </span><span class="s3">2</span><span class="s1">))</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s3">3</span><span class="s2">, </span><span class="s3">1001</span><span class="s1">):</span>
        <span class="s1">y[i] = </span><span class="s3">10 </span><span class="s1">+ </span><span class="s3">0.9 </span><span class="s1">* y[i - </span><span class="s3">1</span><span class="s1">] - </span><span class="s3">0.5 </span><span class="s1">* y[i - </span><span class="s3">3</span><span class="s1">] + e[i]</span>
    <span class="s1">ys = pd.Series(</span>
        <span class="s1">y</span><span class="s2">, </span><span class="s1">index=pd.date_range(dt.datetime(</span><span class="s3">1950</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">periods=</span><span class="s3">1001</span><span class="s2">, </span><span class="s1">freq=</span><span class="s4">&quot;M&quot;</span><span class="s1">)</span>
    <span class="s1">)</span>
    <span class="s1">mod = AutoReg(ys</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">trend=</span><span class="s4">&quot;ct&quot;</span><span class="s1">)</span>
    <span class="s1">res = mod.fit()</span>
    <span class="s1">c = res.params.iloc[</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s1">t = res.params.iloc[</span><span class="s3">1</span><span class="s1">]</span>
    <span class="s1">ar = np.asarray(res.params.iloc[</span><span class="s3">2</span><span class="s1">:])</span>

    <span class="s1">pred = res.predict(</span><span class="s3">900</span><span class="s2">, </span><span class="s3">1100</span><span class="s2">, True</span><span class="s1">)</span>
    <span class="s1">direct = np.zeros(</span><span class="s3">201</span><span class="s1">)</span>
    <span class="s1">direct[</span><span class="s3">0</span><span class="s1">] = c + t * </span><span class="s3">901 </span><span class="s1">+ ar[</span><span class="s3">0</span><span class="s1">] * y[</span><span class="s3">899</span><span class="s1">] + ar[</span><span class="s3">1</span><span class="s1">] * y[</span><span class="s3">897</span><span class="s1">]</span>
    <span class="s1">direct[</span><span class="s3">1</span><span class="s1">] = c + t * </span><span class="s3">902 </span><span class="s1">+ ar[</span><span class="s3">0</span><span class="s1">] * direct[</span><span class="s3">0</span><span class="s1">] + ar[</span><span class="s3">1</span><span class="s1">] * y[</span><span class="s3">898</span><span class="s1">]</span>
    <span class="s1">direct[</span><span class="s3">2</span><span class="s1">] = c + t * </span><span class="s3">903 </span><span class="s1">+ ar[</span><span class="s3">0</span><span class="s1">] * direct[</span><span class="s3">1</span><span class="s1">] + ar[</span><span class="s3">1</span><span class="s1">] * y[</span><span class="s3">899</span><span class="s1">]</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s3">3</span><span class="s2">, </span><span class="s3">201</span><span class="s1">):</span>
        <span class="s1">direct[i] = (</span>
            <span class="s1">c + t * (</span><span class="s3">901 </span><span class="s1">+ i) + ar[</span><span class="s3">0</span><span class="s1">] * direct[i - </span><span class="s3">1</span><span class="s1">] + ar[</span><span class="s3">1</span><span class="s1">] * direct[i - </span><span class="s3">3</span><span class="s1">]</span>
        <span class="s1">)</span>
    <span class="s1">direct = pd.Series(</span>
        <span class="s1">direct</span><span class="s2">, </span><span class="s1">index=pd.date_range(ys.index[</span><span class="s3">900</span><span class="s1">]</span><span class="s2">, </span><span class="s1">periods=</span><span class="s3">201</span><span class="s2">, </span><span class="s1">freq=</span><span class="s4">&quot;M&quot;</span><span class="s1">)</span>
    <span class="s1">)</span>
    <span class="s1">assert_series_equal(pred</span><span class="s2">, </span><span class="s1">direct)</span>

    <span class="s1">pred = res.predict(</span><span class="s3">900</span><span class="s1">)</span>
    <span class="s1">direct = (</span>
        <span class="s1">c</span>
        <span class="s1">+ t * np.arange(</span><span class="s3">901</span><span class="s2">, </span><span class="s3">901 </span><span class="s1">+ </span><span class="s3">101</span><span class="s1">)</span>
        <span class="s1">+ ar[</span><span class="s3">0</span><span class="s1">] * y[</span><span class="s3">899</span><span class="s1">:-</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s1">+ ar[</span><span class="s3">1</span><span class="s1">] * y[</span><span class="s3">897</span><span class="s1">:-</span><span class="s3">3</span><span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s1">idx = pd.date_range(ys.index[</span><span class="s3">900</span><span class="s1">]</span><span class="s2">, </span><span class="s1">periods=</span><span class="s3">101</span><span class="s2">, </span><span class="s1">freq=</span><span class="s4">&quot;M&quot;</span><span class="s1">)</span>
    <span class="s1">direct = pd.Series(direct</span><span class="s2">, </span><span class="s1">index=idx)</span>
    <span class="s1">assert_series_equal(pred</span><span class="s2">, </span><span class="s1">direct)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;dynamic&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_forecast_start_end_equiv(dynamic):</span>
    <span class="s1">rs = np.random.RandomState(</span><span class="s3">12345678</span><span class="s1">)</span>
    <span class="s1">e = rs.standard_normal(</span><span class="s3">1001</span><span class="s1">)</span>
    <span class="s1">y = np.empty(</span><span class="s3">1001</span><span class="s1">)</span>
    <span class="s1">y[</span><span class="s3">0</span><span class="s1">] = e[</span><span class="s3">0</span><span class="s1">] * np.sqrt(</span><span class="s3">1.0 </span><span class="s1">/ (</span><span class="s3">1 </span><span class="s1">- </span><span class="s3">0.9 </span><span class="s1">** </span><span class="s3">2</span><span class="s1">))</span>
    <span class="s1">effects = </span><span class="s3">10 </span><span class="s1">* np.cos(np.arange(</span><span class="s3">12</span><span class="s1">) / </span><span class="s3">11 </span><span class="s1">* </span><span class="s3">2 </span><span class="s1">* np.pi)</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1001</span><span class="s1">):</span>
        <span class="s1">y[i] = </span><span class="s3">10 </span><span class="s1">+ </span><span class="s3">0.9 </span><span class="s1">* y[i - </span><span class="s3">1</span><span class="s1">] + e[i] + effects[i % </span><span class="s3">12</span><span class="s1">]</span>
    <span class="s1">ys = pd.Series(</span>
        <span class="s1">y</span><span class="s2">, </span><span class="s1">index=pd.date_range(dt.datetime(</span><span class="s3">1950</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">periods=</span><span class="s3">1001</span><span class="s2">, </span><span class="s1">freq=</span><span class="s4">&quot;M&quot;</span><span class="s1">)</span>
    <span class="s1">)</span>
    <span class="s1">mod = AutoReg(ys</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s1">seasonal=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">res = mod.fit()</span>
    <span class="s1">pred_int = res.predict(</span><span class="s3">1000</span><span class="s2">, </span><span class="s3">1020</span><span class="s2">, </span><span class="s1">dynamic=dynamic)</span>
    <span class="s1">dates = pd.date_range(dt.datetime(</span><span class="s3">1950</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">periods=</span><span class="s3">1021</span><span class="s2">, </span><span class="s1">freq=</span><span class="s4">&quot;M&quot;</span><span class="s1">)</span>
    <span class="s1">pred_dates = res.predict(dates[</span><span class="s3">1000</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dates[</span><span class="s3">1020</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dynamic=dynamic)</span>
    <span class="s1">assert_series_equal(pred_int</span><span class="s2">, </span><span class="s1">pred_dates)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;start&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">21</span><span class="s2">, </span><span class="s3">25</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_autoreg_start(start):</span>
    <span class="s1">y_train = pd.Series(np.random.normal(size=</span><span class="s3">20</span><span class="s1">))</span>
    <span class="s1">m = AutoReg(y_train</span><span class="s2">, </span><span class="s1">lags=</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">mf = m.fit()</span>
    <span class="s1">end = start + </span><span class="s3">5</span>
    <span class="s1">pred = mf.predict(start=start</span><span class="s2">, </span><span class="s1">end=end)</span>
    <span class="s2">assert </span><span class="s1">pred.shape[</span><span class="s3">0</span><span class="s1">] == end - start + </span><span class="s3">1</span>


<span class="s2">def </span><span class="s1">test_deterministic(reset_randomstate):</span>
    <span class="s1">y = pd.Series(np.random.normal(size=</span><span class="s3">200</span><span class="s1">))</span>
    <span class="s1">terms = [TimeTrend(constant=</span><span class="s2">True, </span><span class="s1">order=</span><span class="s3">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Seasonality(</span><span class="s3">12</span><span class="s1">)]</span>
    <span class="s1">dp = DeterministicProcess(y.index</span><span class="s2">, </span><span class="s1">additional_terms=terms)</span>
    <span class="s1">m = AutoReg(y</span><span class="s2">, </span><span class="s1">trend=</span><span class="s4">&quot;n&quot;</span><span class="s2">, </span><span class="s1">seasonal=</span><span class="s2">False, </span><span class="s1">lags=</span><span class="s3">2</span><span class="s2">, </span><span class="s1">deterministic=dp)</span>
    <span class="s1">res = m.fit()</span>
    <span class="s1">m2 = AutoReg(y</span><span class="s2">, </span><span class="s1">trend=</span><span class="s4">&quot;ct&quot;</span><span class="s2">, </span><span class="s1">seasonal=</span><span class="s2">True, </span><span class="s1">lags=</span><span class="s3">2</span><span class="s2">, </span><span class="s1">period=</span><span class="s3">12</span><span class="s1">)</span>
    <span class="s1">res2 = m2.fit()</span>
    <span class="s1">assert_almost_equal(np.asarray(res.params)</span><span class="s2">, </span><span class="s1">np.asarray(res2.params))</span>
    <span class="s2">with </span><span class="s1">pytest.warns(</span>
        <span class="s1">SpecificationWarning</span><span class="s2">, </span><span class="s1">match=</span><span class="s4">&quot;When using deterministic, trend&quot;</span>
    <span class="s1">):</span>
        <span class="s1">AutoReg(y</span><span class="s2">, </span><span class="s1">trend=</span><span class="s4">&quot;ct&quot;</span><span class="s2">, </span><span class="s1">seasonal=</span><span class="s2">False, </span><span class="s1">lags=</span><span class="s3">2</span><span class="s2">, </span><span class="s1">deterministic=dp)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=</span><span class="s4">&quot;deterministic must be&quot;</span><span class="s1">):</span>
        <span class="s1">AutoReg(y</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s1">deterministic=</span><span class="s4">&quot;ct&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_autoreg_predict_forecast_equiv(reset_randomstate):</span>
    <span class="s1">e = np.random.normal(size=</span><span class="s3">1000</span><span class="s1">)</span>
    <span class="s1">nobs = e.shape[</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s1">idx = pd.date_range(dt.datetime(</span><span class="s3">2020</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">freq=</span><span class="s4">&quot;D&quot;</span><span class="s2">, </span><span class="s1">periods=nobs)</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s3">1</span><span class="s2">, </span><span class="s1">nobs):</span>
        <span class="s1">e[i] = </span><span class="s3">0.95 </span><span class="s1">* e[i - </span><span class="s3">1</span><span class="s1">] + e[i]</span>
    <span class="s1">y = pd.Series(e</span><span class="s2">, </span><span class="s1">index=idx)</span>
    <span class="s1">m = AutoReg(y</span><span class="s2">, </span><span class="s1">trend=</span><span class="s4">&quot;c&quot;</span><span class="s2">, </span><span class="s1">lags=</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">res = m.fit()</span>
    <span class="s1">a = res.forecast(</span><span class="s3">12</span><span class="s1">)</span>
    <span class="s1">b = res.predict(nobs</span><span class="s2">, </span><span class="s1">nobs + </span><span class="s3">11</span><span class="s1">)</span>
    <span class="s1">c = res.forecast(</span><span class="s4">&quot;2022-10-08&quot;</span><span class="s1">)</span>
    <span class="s1">assert_series_equal(a</span><span class="s2">, </span><span class="s1">b)</span>
    <span class="s1">assert_series_equal(a</span><span class="s2">, </span><span class="s1">c)</span>
    <span class="s1">sarimax_res = SARIMAX(y</span><span class="s2">, </span><span class="s1">order=(</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s4">&quot;c&quot;</span><span class="s1">).fit(disp=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">d = sarimax_res.forecast(</span><span class="s3">12</span><span class="s1">)</span>
    <span class="s1">pd.testing.assert_index_equal(a.index</span><span class="s2">, </span><span class="s1">d.index)</span>


<span class="s2">def </span><span class="s1">test_autoreg_forecast_period_index():</span>
    <span class="s1">pi = pd.period_range(</span><span class="s4">&quot;1990-1-1&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s3">524</span><span class="s2">, </span><span class="s1">freq=</span><span class="s4">&quot;M&quot;</span><span class="s1">)</span>
    <span class="s1">y = np.random.RandomState(</span><span class="s3">0</span><span class="s1">).standard_normal(</span><span class="s3">500</span><span class="s1">)</span>
    <span class="s1">ys = pd.Series(y</span><span class="s2">, </span><span class="s1">index=pi[:</span><span class="s3">500</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=</span><span class="s4">&quot;y&quot;</span><span class="s1">)</span>
    <span class="s1">mod = AutoReg(ys</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s1">seasonal=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">res = mod.fit()</span>
    <span class="s1">fcast = res.forecast(</span><span class="s3">24</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">isinstance(fcast.index</span><span class="s2">, </span><span class="s1">pd.PeriodIndex)</span>
    <span class="s1">pd.testing.assert_index_equal(fcast.index</span><span class="s2">, </span><span class="s1">pi[-</span><span class="s3">24</span><span class="s1">:])</span>


<span class="s1">@pytest.mark.matplotlib</span>
<span class="s2">def </span><span class="s1">test_autoreg_plot_err():</span>
    <span class="s1">y = np.random.standard_normal(</span><span class="s3">100</span><span class="s1">)</span>
    <span class="s1">mod = AutoReg(y</span><span class="s2">, </span><span class="s1">lags=[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">3</span><span class="s1">])</span>
    <span class="s1">res = mod.fit()</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">res.plot_predict(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">50</span><span class="s2">, </span><span class="s1">in_sample=</span><span class="s2">False</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_autoreg_resids():</span>
    <span class="s1">idx = pd.date_range(dt.datetime(</span><span class="s3">1900</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">periods=</span><span class="s3">250</span><span class="s2">, </span><span class="s1">freq=</span><span class="s4">&quot;M&quot;</span><span class="s1">)</span>
    <span class="s1">rs = np.random.RandomState(</span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">idx_dates = sorted(rs.choice(idx</span><span class="s2">, </span><span class="s1">size=</span><span class="s3">100</span><span class="s2">, </span><span class="s1">replace=</span><span class="s2">False</span><span class="s1">))</span>
    <span class="s1">e = rs.standard_normal(</span><span class="s3">250</span><span class="s1">)</span>
    <span class="s1">y = np.zeros(</span><span class="s3">250</span><span class="s1">)</span>
    <span class="s1">y[:</span><span class="s3">2</span><span class="s1">] = e[:</span><span class="s3">2</span><span class="s1">]</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s3">2</span><span class="s2">, </span><span class="s3">250</span><span class="s1">):</span>
        <span class="s1">y[i] = </span><span class="s3">2 </span><span class="s1">+ </span><span class="s3">1.8 </span><span class="s1">* y[i - </span><span class="s3">1</span><span class="s1">] - </span><span class="s3">0.95 </span><span class="s1">* y[i - </span><span class="s3">2</span><span class="s1">] + e[i]</span>
    <span class="s1">ys = pd.Series(y[-</span><span class="s3">100</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">index=idx_dates</span><span class="s2">, </span><span class="s1">name=</span><span class="s4">&quot;y&quot;</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.warns(ValueWarning):</span>
        <span class="s1">res = AutoReg(ys</span><span class="s2">, </span><span class="s1">lags=</span><span class="s3">2</span><span class="s1">).fit()</span>
    <span class="s2">assert </span><span class="s1">np.all(np.isfinite(res.resid))</span>


<span class="s2">def </span><span class="s1">test_dynamic_predictions(ar2):</span>
    <span class="s1">mod = AutoReg(ar2</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s1">trend=</span><span class="s4">&quot;c&quot;</span><span class="s1">)</span>
    <span class="s1">res = mod.fit()</span>

    <span class="s1">d25 = res.predict(dynamic=</span><span class="s3">25</span><span class="s1">)</span>
    <span class="s1">s10_d15 = res.predict(start=</span><span class="s3">10</span><span class="s2">, </span><span class="s1">dynamic=</span><span class="s3">15</span><span class="s1">)</span>
    <span class="s1">sd_index = res.predict(start=ar2.index[</span><span class="s3">10</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dynamic=ar2.index[</span><span class="s3">25</span><span class="s1">])</span>
    <span class="s1">reference = [np.nan</span><span class="s2">, </span><span class="s1">np.nan]</span>
    <span class="s1">p = np.asarray(res.params)</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s3">2</span><span class="s2">, </span><span class="s1">ar2.shape[</span><span class="s3">0</span><span class="s1">]):</span>
        <span class="s1">lag1 = ar2[i - </span><span class="s3">1</span><span class="s1">]</span>
        <span class="s1">lag2 = ar2[i - </span><span class="s3">2</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">i &gt; </span><span class="s3">25</span><span class="s1">:</span>
            <span class="s1">lag1 = reference[i - </span><span class="s3">1</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">i &gt; </span><span class="s3">26</span><span class="s1">:</span>
            <span class="s1">lag2 = reference[i - </span><span class="s3">2</span><span class="s1">]</span>
        <span class="s1">reference.append(p[</span><span class="s3">0</span><span class="s1">] + p[</span><span class="s3">1</span><span class="s1">] * lag1 + p[</span><span class="s3">2</span><span class="s1">] * lag2)</span>
    <span class="s1">expected = pd.Series(reference</span><span class="s2">, </span><span class="s1">index=ar2.index)</span>
    <span class="s1">assert_allclose(expected</span><span class="s2">, </span><span class="s1">d25)</span>

    <span class="s1">assert_allclose(s10_d15</span><span class="s2">, </span><span class="s1">sd_index)</span>
    <span class="s1">assert_allclose(d25[</span><span class="s3">25</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">sd_index[</span><span class="s3">15</span><span class="s1">:])</span>

    <span class="s1">full = res.predict()</span>
    <span class="s1">assert_allclose(d25[:</span><span class="s3">25</span><span class="s1">]</span><span class="s2">, </span><span class="s1">full[:</span><span class="s3">25</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">test_dynamic_predictions_oos(ar2):</span>
    <span class="s1">mod = AutoReg(ar2</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s1">trend=</span><span class="s4">&quot;c&quot;</span><span class="s1">)</span>
    <span class="s1">res = mod.fit()</span>

    <span class="s1">d25_end = res.predict(dynamic=</span><span class="s3">25</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">61</span><span class="s1">)</span>
    <span class="s1">s10_d15_end = res.predict(start=</span><span class="s3">10</span><span class="s2">, </span><span class="s1">dynamic=</span><span class="s3">15</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">61</span><span class="s1">)</span>
    <span class="s1">end = ar2.index[-</span><span class="s3">1</span><span class="s1">] + </span><span class="s3">12 </span><span class="s1">* (ar2.index[-</span><span class="s3">1</span><span class="s1">] - ar2.index[-</span><span class="s3">2</span><span class="s1">])</span>
    <span class="s1">sd_index_end = res.predict(</span>
        <span class="s1">start=ar2.index[</span><span class="s3">10</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dynamic=ar2.index[</span><span class="s3">25</span><span class="s1">]</span><span class="s2">, </span><span class="s1">end=end</span>
    <span class="s1">)</span>
    <span class="s1">assert_allclose(s10_d15_end</span><span class="s2">, </span><span class="s1">sd_index_end)</span>
    <span class="s1">assert_allclose(d25_end[</span><span class="s3">25</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">sd_index_end[</span><span class="s3">15</span><span class="s1">:])</span>

    <span class="s1">reference = [np.nan</span><span class="s2">, </span><span class="s1">np.nan]</span>
    <span class="s1">p = np.asarray(res.params)</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s3">2</span><span class="s2">, </span><span class="s1">d25_end.shape[</span><span class="s3">0</span><span class="s1">]):</span>
        <span class="s2">if </span><span class="s1">i &lt; ar2.shape[</span><span class="s3">0</span><span class="s1">]:</span>
            <span class="s1">lag1 = ar2[i - </span><span class="s3">1</span><span class="s1">]</span>
            <span class="s1">lag2 = ar2[i - </span><span class="s3">2</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">i &gt; </span><span class="s3">25</span><span class="s1">:</span>
            <span class="s1">lag1 = reference[i - </span><span class="s3">1</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">i &gt; </span><span class="s3">26</span><span class="s1">:</span>
            <span class="s1">lag2 = reference[i - </span><span class="s3">2</span><span class="s1">]</span>
        <span class="s1">reference.append(p[</span><span class="s3">0</span><span class="s1">] + p[</span><span class="s3">1</span><span class="s1">] * lag1 + p[</span><span class="s3">2</span><span class="s1">] * lag2)</span>
    <span class="s1">expected = pd.Series(reference</span><span class="s2">, </span><span class="s1">index=d25_end.index)</span>
    <span class="s1">assert_allclose(expected</span><span class="s2">, </span><span class="s1">d25_end)</span>


<span class="s2">def </span><span class="s1">test_invalid_dynamic(ar2):</span>
    <span class="s1">mod = AutoReg(ar2</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s1">trend=</span><span class="s4">&quot;c&quot;</span><span class="s1">)</span>
    <span class="s1">res = mod.fit()</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s4">&quot;Dynamic prediction cannot&quot;</span><span class="s1">):</span>
        <span class="s1">res.predict(dynamic=-</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s4">&quot;Dynamic prediction cannot&quot;</span><span class="s1">):</span>
        <span class="s1">res.predict(start=ar2.index[</span><span class="s3">10</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dynamic=ar2.index[</span><span class="s3">5</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">test_exog_prediction(ar2):</span>
    <span class="s1">gen = np.random.RandomState(</span><span class="s3">20210623</span><span class="s1">)</span>
    <span class="s1">exog = pd.DataFrame(</span>
        <span class="s1">gen.standard_normal((ar2.shape[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s3">2</span><span class="s1">))</span><span class="s2">,</span>
        <span class="s1">columns=[</span><span class="s4">&quot;x1&quot;</span><span class="s2">, </span><span class="s4">&quot;x2&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">index=ar2.index</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">mod = AutoReg(ar2</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s1">trend=</span><span class="s4">&quot;c&quot;</span><span class="s2">, </span><span class="s1">exog=exog)</span>
    <span class="s1">res = mod.fit()</span>
    <span class="s1">pred_base = res.predict()</span>
    <span class="s1">pred_repl = res.predict(exog=exog)</span>
    <span class="s1">assert_allclose(pred_base</span><span class="s2">, </span><span class="s1">pred_repl)</span>

    <span class="s1">dyn_base = res.predict(dynamic=</span><span class="s3">25</span><span class="s1">)</span>
    <span class="s1">dyn_repl = res.predict(dynamic=</span><span class="s3">25</span><span class="s2">, </span><span class="s1">exog=exog)</span>
    <span class="s1">assert_allclose(dyn_base</span><span class="s2">, </span><span class="s1">dyn_repl)</span>


<span class="s2">def </span><span class="s1">test_old_names(ar2):</span>
    <span class="s2">with </span><span class="s1">pytest.warns(FutureWarning):</span>
        <span class="s1">mod = AutoReg(ar2</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s1">trend=</span><span class="s4">&quot;ct&quot;</span><span class="s2">, </span><span class="s1">seasonal=</span><span class="s2">True, </span><span class="s1">old_names=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">new = AutoReg(ar2</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s1">trend=</span><span class="s4">&quot;ct&quot;</span><span class="s2">, </span><span class="s1">seasonal=</span><span class="s2">True, </span><span class="s1">old_names=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s2">assert </span><span class="s1">new.trend == </span><span class="s4">&quot;ct&quot;</span>
    <span class="s2">assert </span><span class="s1">new.period == </span><span class="s3">12</span>

    <span class="s2">assert </span><span class="s4">&quot;intercept&quot; </span><span class="s2">in </span><span class="s1">mod.exog_names</span>
    <span class="s2">assert </span><span class="s4">&quot;seasonal.1&quot; </span><span class="s2">in </span><span class="s1">mod.exog_names</span>

    <span class="s2">assert </span><span class="s4">&quot;const&quot; </span><span class="s2">in </span><span class="s1">new.exog_names</span>
    <span class="s2">assert </span><span class="s4">&quot;s(2,12)&quot; </span><span class="s2">in </span><span class="s1">new.exog_names</span>


<span class="s2">def </span><span class="s1">test_diagnostic_summary_short(ar2):</span>
    <span class="s1">res = AutoReg(ar2[:</span><span class="s3">10</span><span class="s1">]</span><span class="s2">, </span><span class="s3">2</span><span class="s1">).fit()</span>
    <span class="s2">assert </span><span class="s1">isinstance(res.diagnostic_summary()</span><span class="s2">, </span><span class="s1">Summary)</span>


<span class="s2">def </span><span class="s1">test_ar_model_predict(ar2):</span>
    <span class="s1">mod = AutoReg(ar2[:</span><span class="s3">10</span><span class="s1">]</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">res = mod.fit()</span>
    <span class="s1">res_pred = res.predict()</span>
    <span class="s1">mod_pred = mod.predict(res.params)</span>
    <span class="s1">assert_allclose(res_pred</span><span class="s2">, </span><span class="s1">mod_pred)</span>


<span class="s2">def </span><span class="s1">test_autoreg_no_variables(ar2):</span>
    <span class="s1">mod = AutoReg(ar2[:</span><span class="s3">10</span><span class="s1">]</span><span class="s2">, None, </span><span class="s1">trend=</span><span class="s4">&quot;n&quot;</span><span class="s1">)</span>
    <span class="s1">res = mod.fit()</span>
    <span class="s1">summary = res.summary()</span>
    <span class="s1">summ_txt = summary.as_text()</span>
    <span class="s2">assert </span><span class="s4">&quot;AutoReg(0)&quot; </span><span class="s2">in </span><span class="s1">summ_txt</span>
    <span class="s2">assert </span><span class="s4">&quot;No Model Parameters&quot; </span><span class="s2">in </span><span class="s1">summ_txt</span>


<span class="s2">def </span><span class="s1">test_removal(ar2):</span>
    <span class="s2">from </span><span class="s1">statsmodels.tsa.ar_model </span><span class="s2">import </span><span class="s1">AR</span><span class="s2">, </span><span class="s1">ARResults</span>

    <span class="s2">with </span><span class="s1">pytest.raises(NotImplementedError):</span>
        <span class="s1">AR(ar2)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(NotImplementedError):</span>
        <span class="s1">ARResults(ar2)</span>


<span class="s2">def </span><span class="s1">test_autoreg_apply(ols_autoreg_result):</span>
    <span class="s1">res</span><span class="s2">, </span><span class="s1">_ = ols_autoreg_result</span>
    <span class="s1">y = res.model.endog</span>
    <span class="s1">n = y.shape[</span><span class="s3">0</span><span class="s1">] // </span><span class="s3">2</span>
    <span class="s1">y = y[:n]</span>
    <span class="s1">x = res.model.exog</span>
    <span class="s2">if </span><span class="s1">x </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">x = x[:n]</span>
    <span class="s1">res_apply = res.apply(endog=y</span><span class="s2">, </span><span class="s1">exog=x)</span>
    <span class="s2">assert </span><span class="s4">&quot;using a different&quot; </span><span class="s2">in </span><span class="s1">str(res_apply.summary())</span>
    <span class="s2">assert </span><span class="s1">isinstance(res_apply</span><span class="s2">, </span><span class="s1">AutoRegResultsWrapper)</span>
    <span class="s1">assert_allclose(res.params</span><span class="s2">, </span><span class="s1">res_apply.params)</span>
    <span class="s1">exog_oos = </span><span class="s2">None</span>
    <span class="s2">if </span><span class="s1">res.model.exog </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">exog_oos = res.model.exog[-</span><span class="s3">10</span><span class="s1">:]</span>
    <span class="s1">fcasts_apply = res_apply.forecast(</span><span class="s3">10</span><span class="s2">, </span><span class="s1">exog=exog_oos)</span>
    <span class="s2">assert </span><span class="s1">isinstance(fcasts_apply</span><span class="s2">, </span><span class="s1">np.ndarray)</span>
    <span class="s2">assert </span><span class="s1">fcasts_apply.shape == (</span><span class="s3">10</span><span class="s2">,</span><span class="s1">)</span>

    <span class="s1">res_refit = res.apply(endog=y</span><span class="s2">, </span><span class="s1">exog=x</span><span class="s2">, </span><span class="s1">refit=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s2">assert not </span><span class="s1">np.allclose(res.params</span><span class="s2">, </span><span class="s1">res_refit.params)</span>
    <span class="s2">assert not </span><span class="s1">np.allclose(res.llf</span><span class="s2">, </span><span class="s1">res_refit.llf)</span>
    <span class="s2">assert </span><span class="s1">res_apply.fittedvalues.shape == res_refit.fittedvalues.shape</span>
    <span class="s2">assert not </span><span class="s1">np.allclose(res_apply.llf</span><span class="s2">, </span><span class="s1">res_refit.llf)</span>
    <span class="s2">if </span><span class="s1">res.model.exog </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">fcasts_refit = res_refit.forecast(</span><span class="s3">10</span><span class="s2">, </span><span class="s1">exog=exog_oos)</span>
        <span class="s2">assert </span><span class="s1">isinstance(fcasts_refit</span><span class="s2">, </span><span class="s1">np.ndarray)</span>
        <span class="s2">assert </span><span class="s1">fcasts_refit.shape == (</span><span class="s3">10</span><span class="s2">,</span><span class="s1">)</span>
        <span class="s2">assert not </span><span class="s1">np.allclose(fcasts_refit</span><span class="s2">, </span><span class="s1">fcasts_apply)</span>


<span class="s2">def </span><span class="s1">test_autoreg_apply_exception(reset_randomstate):</span>
    <span class="s1">y = np.random.standard_normal(</span><span class="s3">250</span><span class="s1">)</span>
    <span class="s1">mod = AutoReg(y</span><span class="s2">, </span><span class="s1">lags=</span><span class="s3">10</span><span class="s1">)</span>
    <span class="s1">res = mod.fit()</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s4">&quot;An exception occured&quot;</span><span class="s1">):</span>
        <span class="s1">res.apply(y[:</span><span class="s3">5</span><span class="s1">])</span>

    <span class="s1">x = np.random.standard_normal((y.shape[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s3">3</span><span class="s1">))</span>
    <span class="s1">res = AutoReg(y</span><span class="s2">, </span><span class="s1">lags=</span><span class="s3">1</span><span class="s2">, </span><span class="s1">exog=x).fit()</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s4">&quot;exog must be provided&quot;</span><span class="s1">):</span>
        <span class="s1">res.apply(y[</span><span class="s3">50</span><span class="s1">:</span><span class="s3">150</span><span class="s1">])</span>
    <span class="s1">x = np.random.standard_normal((y.shape[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s3">3</span><span class="s1">))</span>
    <span class="s1">res = AutoReg(y</span><span class="s2">, </span><span class="s1">lags=</span><span class="s3">1</span><span class="s2">, </span><span class="s1">exog=x).fit()</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s4">&quot;The number of exog&quot;</span><span class="s1">):</span>
        <span class="s1">res.apply(y[</span><span class="s3">50</span><span class="s1">:</span><span class="s3">150</span><span class="s1">]</span><span class="s2">, </span><span class="s1">exog=x[</span><span class="s3">50</span><span class="s1">:</span><span class="s3">150</span><span class="s2">, </span><span class="s1">:</span><span class="s3">2</span><span class="s1">])</span>

    <span class="s1">res = AutoReg(y</span><span class="s2">, </span><span class="s1">lags=</span><span class="s3">1</span><span class="s1">).fit()</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s4">&quot;exog must be None&quot;</span><span class="s1">):</span>
        <span class="s1">res.apply(y[</span><span class="s3">50</span><span class="s1">:</span><span class="s3">150</span><span class="s1">]</span><span class="s2">, </span><span class="s1">exog=x[</span><span class="s3">50</span><span class="s1">:</span><span class="s3">150</span><span class="s1">])</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">append_data():</span>
    <span class="s1">rs = np.random.RandomState(</span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">y = rs.standard_normal(</span><span class="s3">250</span><span class="s1">)</span>
    <span class="s1">x = rs.standard_normal((</span><span class="s3">250</span><span class="s2">, </span><span class="s3">3</span><span class="s1">))</span>
    <span class="s1">x_oos = rs.standard_normal((</span><span class="s3">10</span><span class="s2">, </span><span class="s3">3</span><span class="s1">))</span>
    <span class="s1">y_oos = rs.standard_normal(</span><span class="s3">10</span><span class="s1">)</span>
    <span class="s1">index = pd.date_range(</span>
        <span class="s4">&quot;2020-1-1&quot;</span><span class="s2">, </span><span class="s1">periods=y.shape[</span><span class="s3">0</span><span class="s1">] + y_oos.shape[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">freq=</span><span class="s4">&quot;M&quot;</span>
    <span class="s1">)</span>
    <span class="s1">y = pd.Series(y</span><span class="s2">, </span><span class="s1">index=index[: y.shape[</span><span class="s3">0</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">name=</span><span class="s4">&quot;y&quot;</span><span class="s1">)</span>
    <span class="s1">x = pd.DataFrame(</span>
        <span class="s1">x</span><span class="s2">,</span>
        <span class="s1">index=index[: y.shape[</span><span class="s3">0</span><span class="s1">]]</span><span class="s2">,</span>
        <span class="s1">columns=[</span><span class="s4">f&quot;x</span><span class="s2">{</span><span class="s1">i</span><span class="s2">}</span><span class="s4">&quot; </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(x.shape[</span><span class="s3">1</span><span class="s1">])]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">y_oos = pd.Series(y_oos</span><span class="s2">, </span><span class="s1">index=index[y.shape[</span><span class="s3">0</span><span class="s1">] :]</span><span class="s2">, </span><span class="s1">name=</span><span class="s4">&quot;y&quot;</span><span class="s1">)</span>
    <span class="s1">x_oos = pd.DataFrame(x_oos</span><span class="s2">, </span><span class="s1">index=index[y.shape[</span><span class="s3">0</span><span class="s1">] :]</span><span class="s2">, </span><span class="s1">columns=x.columns)</span>
    <span class="s1">y_both = pd.concat([y</span><span class="s2">, </span><span class="s1">y_oos]</span><span class="s2">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">x_both = pd.concat([x</span><span class="s2">, </span><span class="s1">x_oos]</span><span class="s2">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)</span>

    <span class="s2">class </span><span class="s1">AppendData(NamedTuple):</span>
        <span class="s1">y: pd.Series</span>
        <span class="s1">y_oos: pd.Series</span>
        <span class="s1">y_both: pd.Series</span>
        <span class="s1">x: pd.Series</span>
        <span class="s1">x_oos: pd.DataFrame</span>
        <span class="s1">x_both: pd.DataFrame</span>

    <span class="s2">return </span><span class="s1">AppendData(y</span><span class="s2">, </span><span class="s1">y_oos</span><span class="s2">, </span><span class="s1">y_both</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">x_oos</span><span class="s2">, </span><span class="s1">x_both)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;trend&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s4">&quot;n&quot;</span><span class="s2">, </span><span class="s4">&quot;ct&quot;</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;use_pandas&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;lags&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">3</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;seasonal&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_autoreg_append(append_data</span><span class="s2">, </span><span class="s1">use_pandas</span><span class="s2">, </span><span class="s1">lags</span><span class="s2">, </span><span class="s1">trend</span><span class="s2">, </span><span class="s1">seasonal):</span>
    <span class="s1">period = </span><span class="s3">12 </span><span class="s2">if not </span><span class="s1">use_pandas </span><span class="s2">else None</span>
    <span class="s1">y = append_data.y</span>
    <span class="s1">y_oos = append_data.y_oos</span>
    <span class="s1">y_both = append_data.y_both</span>
    <span class="s1">x = append_data.x</span>
    <span class="s1">x_oos = append_data.x_oos</span>
    <span class="s1">x_both = append_data.x_both</span>
    <span class="s2">if not </span><span class="s1">use_pandas:</span>
        <span class="s1">y = np.asarray(y)</span>
        <span class="s1">x = np.asarray(x)</span>
        <span class="s1">y_oos = np.asarray(y_oos)</span>
        <span class="s1">x_oos = np.asarray(x_oos)</span>
        <span class="s1">y_both = np.asarray(y_both)</span>
        <span class="s1">x_both = np.asarray(x_both)</span>

    <span class="s1">res = AutoReg(</span>
        <span class="s1">y</span><span class="s2">, </span><span class="s1">lags=lags</span><span class="s2">, </span><span class="s1">trend=trend</span><span class="s2">, </span><span class="s1">seasonal=seasonal</span><span class="s2">, </span><span class="s1">period=period</span>
    <span class="s1">).fit()</span>
    <span class="s1">res_append = res.append(y_oos</span><span class="s2">, </span><span class="s1">refit=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">res_direct = AutoReg(</span>
        <span class="s1">y_both</span><span class="s2">, </span><span class="s1">lags=lags</span><span class="s2">, </span><span class="s1">trend=trend</span><span class="s2">, </span><span class="s1">seasonal=seasonal</span><span class="s2">, </span><span class="s1">period=period</span>
    <span class="s1">).fit()</span>
    <span class="s1">res_exog = AutoReg(</span>
        <span class="s1">y</span><span class="s2">, </span><span class="s1">exog=x</span><span class="s2">, </span><span class="s1">lags=lags</span><span class="s2">, </span><span class="s1">trend=trend</span><span class="s2">, </span><span class="s1">seasonal=seasonal</span><span class="s2">, </span><span class="s1">period=period</span>
    <span class="s1">).fit()</span>
    <span class="s1">res_exog_append = res_exog.append(y_oos</span><span class="s2">, </span><span class="s1">exog=x_oos</span><span class="s2">, </span><span class="s1">refit=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">res_exog_direct = AutoReg(</span>
        <span class="s1">y_both</span><span class="s2">,</span>
        <span class="s1">exog=x_both</span><span class="s2">,</span>
        <span class="s1">lags=lags</span><span class="s2">,</span>
        <span class="s1">trend=trend</span><span class="s2">,</span>
        <span class="s1">seasonal=seasonal</span><span class="s2">,</span>
        <span class="s1">period=period</span><span class="s2">,</span>
    <span class="s1">).fit()</span>

    <span class="s1">assert_allclose(res_direct.params</span><span class="s2">, </span><span class="s1">res_append.params)</span>
    <span class="s1">assert_allclose(res_exog_direct.params</span><span class="s2">, </span><span class="s1">res_exog_append.params)</span>
    <span class="s2">if </span><span class="s1">use_pandas:</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=</span><span class="s4">&quot;endog must have the same type&quot;</span><span class="s1">):</span>
            <span class="s1">res.append(np.asarray(y_oos))</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=</span><span class="s4">&quot;exog must have the same type&quot;</span><span class="s1">):</span>
            <span class="s1">res_exog.append(y_oos</span><span class="s2">, </span><span class="s1">np.asarray(x_oos))</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s4">&quot;Original model does&quot;</span><span class="s1">):</span>
        <span class="s1">res.append(y_oos</span><span class="s2">, </span><span class="s1">exog=x_oos)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s4">&quot;Original model has exog&quot;</span><span class="s1">):</span>
        <span class="s1">res_exog.append(y_oos)</span>


<span class="s2">def </span><span class="s1">test_autoreg_append_deterministic(append_data):</span>
    <span class="s1">y = append_data.y</span>
    <span class="s1">y_oos = append_data.y_oos</span>
    <span class="s1">y_both = append_data.y_both</span>
    <span class="s1">x = append_data.x</span>
    <span class="s1">x_oos = append_data.x_oos</span>
    <span class="s1">x_both = append_data.x_both</span>

    <span class="s1">terms = [TimeTrend(constant=</span><span class="s2">True, </span><span class="s1">order=</span><span class="s3">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Seasonality(</span><span class="s3">12</span><span class="s1">)]</span>
    <span class="s1">dp = DeterministicProcess(y.index</span><span class="s2">, </span><span class="s1">additional_terms=terms)</span>

    <span class="s1">res = AutoReg(y</span><span class="s2">, </span><span class="s1">lags=</span><span class="s3">3</span><span class="s2">, </span><span class="s1">trend=</span><span class="s4">&quot;n&quot;</span><span class="s2">, </span><span class="s1">deterministic=dp).fit()</span>
    <span class="s1">res_append = res.append(y_oos</span><span class="s2">, </span><span class="s1">refit=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">res_direct = AutoReg(</span>
        <span class="s1">y_both</span><span class="s2">, </span><span class="s1">lags=</span><span class="s3">3</span><span class="s2">, </span><span class="s1">trend=</span><span class="s4">&quot;n&quot;</span><span class="s2">, </span><span class="s1">deterministic=dp.apply(y_both.index)</span>
    <span class="s1">).fit()</span>
    <span class="s1">assert_allclose(res_append.params</span><span class="s2">, </span><span class="s1">res_direct.params)</span>

    <span class="s1">res_np = AutoReg(np.asarray(y)</span><span class="s2">, </span><span class="s1">lags=</span><span class="s3">3</span><span class="s2">, </span><span class="s1">trend=</span><span class="s4">&quot;n&quot;</span><span class="s2">, </span><span class="s1">deterministic=dp).fit()</span>
    <span class="s1">res_append_np = res_np.append(np.asarray(y_oos))</span>
    <span class="s1">assert_allclose(res_np.params</span><span class="s2">, </span><span class="s1">res_append_np.params)</span>

    <span class="s1">res = AutoReg(y</span><span class="s2">, </span><span class="s1">exog=x</span><span class="s2">, </span><span class="s1">lags=</span><span class="s3">3</span><span class="s2">, </span><span class="s1">trend=</span><span class="s4">&quot;n&quot;</span><span class="s2">, </span><span class="s1">deterministic=dp).fit()</span>
    <span class="s1">res_append = res.append(y_oos</span><span class="s2">, </span><span class="s1">exog=x_oos</span><span class="s2">, </span><span class="s1">refit=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">res_direct = AutoReg(</span>
        <span class="s1">y_both</span><span class="s2">,</span>
        <span class="s1">exog=x_both</span><span class="s2">,</span>
        <span class="s1">lags=</span><span class="s3">3</span><span class="s2">,</span>
        <span class="s1">trend=</span><span class="s4">&quot;n&quot;</span><span class="s2">,</span>
        <span class="s1">deterministic=dp.apply(y_both.index)</span><span class="s2">,</span>
    <span class="s1">).fit()</span>
    <span class="s1">assert_allclose(res_append.params</span><span class="s2">, </span><span class="s1">res_direct.params)</span>
</pre>
</body>
</html>