<html>
<head>
<title>test_real_transforms.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_real_transforms.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">os.path </span><span class="s0">import </span><span class="s1">join</span><span class="s0">, </span><span class="s1">dirname</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">numpy.testing </span><span class="s0">import </span><span class="s1">assert_array_almost_equal</span><span class="s0">, </span><span class="s1">assert_equal</span>
<span class="s0">import </span><span class="s1">pytest</span>
<span class="s0">from </span><span class="s1">pytest </span><span class="s0">import </span><span class="s1">raises </span><span class="s0">as </span><span class="s1">assert_raises</span>

<span class="s0">from </span><span class="s1">scipy.fftpack._realtransforms </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">dct</span><span class="s0">, </span><span class="s1">idct</span><span class="s0">, </span><span class="s1">dst</span><span class="s0">, </span><span class="s1">idst</span><span class="s0">, </span><span class="s1">dctn</span><span class="s0">, </span><span class="s1">idctn</span><span class="s0">, </span><span class="s1">dstn</span><span class="s0">, </span><span class="s1">idstn)</span>

<span class="s2"># Matlab reference data</span>
<span class="s1">MDATA = np.load(join(dirname(__file__)</span><span class="s0">, </span><span class="s3">'test.npz'</span><span class="s1">))</span>
<span class="s1">X = [MDATA[</span><span class="s3">'x%d' </span><span class="s1">% i] </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">8</span><span class="s1">)]</span>
<span class="s1">Y = [MDATA[</span><span class="s3">'y%d' </span><span class="s1">% i] </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">8</span><span class="s1">)]</span>

<span class="s2"># FFTW reference data: the data are organized as follows:</span>
<span class="s2">#    * SIZES is an array containing all available sizes</span>
<span class="s2">#    * for every type (1, 2, 3, 4) and every size, the array dct_type_size</span>
<span class="s2">#    contains the output of the DCT applied to the input np.linspace(0, size-1,</span>
<span class="s2">#    size)</span>
<span class="s1">FFTWDATA_DOUBLE = np.load(join(dirname(__file__)</span><span class="s0">, </span><span class="s3">'fftw_double_ref.npz'</span><span class="s1">))</span>
<span class="s1">FFTWDATA_SINGLE = np.load(join(dirname(__file__)</span><span class="s0">, </span><span class="s3">'fftw_single_ref.npz'</span><span class="s1">))</span>
<span class="s1">FFTWDATA_SIZES = FFTWDATA_DOUBLE[</span><span class="s3">'sizes'</span><span class="s1">]</span>


<span class="s0">def </span><span class="s1">fftw_dct_ref(type</span><span class="s0">, </span><span class="s1">size</span><span class="s0">, </span><span class="s1">dt):</span>
    <span class="s1">x = np.linspace(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">size-</span><span class="s4">1</span><span class="s0">, </span><span class="s1">size).astype(dt)</span>
    <span class="s1">dt = np.result_type(np.float32</span><span class="s0">, </span><span class="s1">dt)</span>
    <span class="s0">if </span><span class="s1">dt == np.double:</span>
        <span class="s1">data = FFTWDATA_DOUBLE</span>
    <span class="s0">elif </span><span class="s1">dt == np.float32:</span>
        <span class="s1">data = FFTWDATA_SINGLE</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError()</span>
    <span class="s1">y = (data[</span><span class="s3">'dct_%d_%d' </span><span class="s1">% (type</span><span class="s0">, </span><span class="s1">size)]).astype(dt)</span>
    <span class="s0">return </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">dt</span>


<span class="s0">def </span><span class="s1">fftw_dst_ref(type</span><span class="s0">, </span><span class="s1">size</span><span class="s0">, </span><span class="s1">dt):</span>
    <span class="s1">x = np.linspace(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">size-</span><span class="s4">1</span><span class="s0">, </span><span class="s1">size).astype(dt)</span>
    <span class="s1">dt = np.result_type(np.float32</span><span class="s0">, </span><span class="s1">dt)</span>
    <span class="s0">if </span><span class="s1">dt == np.double:</span>
        <span class="s1">data = FFTWDATA_DOUBLE</span>
    <span class="s0">elif </span><span class="s1">dt == np.float32:</span>
        <span class="s1">data = FFTWDATA_SINGLE</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError()</span>
    <span class="s1">y = (data[</span><span class="s3">'dst_%d_%d' </span><span class="s1">% (type</span><span class="s0">, </span><span class="s1">size)]).astype(dt)</span>
    <span class="s0">return </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">dt</span>


<span class="s0">def </span><span class="s1">dct_2d_ref(x</span><span class="s0">, </span><span class="s1">**kwargs):</span>
    <span class="s5">&quot;&quot;&quot;Calculate reference values for testing dct2.&quot;&quot;&quot;</span>
    <span class="s1">x = np.array(x</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">for </span><span class="s1">row </span><span class="s0">in </span><span class="s1">range(x.shape[</span><span class="s4">0</span><span class="s1">]):</span>
        <span class="s1">x[row</span><span class="s0">, </span><span class="s1">:] = dct(x[row</span><span class="s0">, </span><span class="s1">:]</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">range(x.shape[</span><span class="s4">1</span><span class="s1">]):</span>
        <span class="s1">x[:</span><span class="s0">, </span><span class="s1">col] = dct(x[:</span><span class="s0">, </span><span class="s1">col]</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s0">return </span><span class="s1">x</span>


<span class="s0">def </span><span class="s1">idct_2d_ref(x</span><span class="s0">, </span><span class="s1">**kwargs):</span>
    <span class="s5">&quot;&quot;&quot;Calculate reference values for testing idct2.&quot;&quot;&quot;</span>
    <span class="s1">x = np.array(x</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">for </span><span class="s1">row </span><span class="s0">in </span><span class="s1">range(x.shape[</span><span class="s4">0</span><span class="s1">]):</span>
        <span class="s1">x[row</span><span class="s0">, </span><span class="s1">:] = idct(x[row</span><span class="s0">, </span><span class="s1">:]</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">range(x.shape[</span><span class="s4">1</span><span class="s1">]):</span>
        <span class="s1">x[:</span><span class="s0">, </span><span class="s1">col] = idct(x[:</span><span class="s0">, </span><span class="s1">col]</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s0">return </span><span class="s1">x</span>


<span class="s0">def </span><span class="s1">dst_2d_ref(x</span><span class="s0">, </span><span class="s1">**kwargs):</span>
    <span class="s5">&quot;&quot;&quot;Calculate reference values for testing dst2.&quot;&quot;&quot;</span>
    <span class="s1">x = np.array(x</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">for </span><span class="s1">row </span><span class="s0">in </span><span class="s1">range(x.shape[</span><span class="s4">0</span><span class="s1">]):</span>
        <span class="s1">x[row</span><span class="s0">, </span><span class="s1">:] = dst(x[row</span><span class="s0">, </span><span class="s1">:]</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">range(x.shape[</span><span class="s4">1</span><span class="s1">]):</span>
        <span class="s1">x[:</span><span class="s0">, </span><span class="s1">col] = dst(x[:</span><span class="s0">, </span><span class="s1">col]</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s0">return </span><span class="s1">x</span>


<span class="s0">def </span><span class="s1">idst_2d_ref(x</span><span class="s0">, </span><span class="s1">**kwargs):</span>
    <span class="s5">&quot;&quot;&quot;Calculate reference values for testing idst2.&quot;&quot;&quot;</span>
    <span class="s1">x = np.array(x</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">for </span><span class="s1">row </span><span class="s0">in </span><span class="s1">range(x.shape[</span><span class="s4">0</span><span class="s1">]):</span>
        <span class="s1">x[row</span><span class="s0">, </span><span class="s1">:] = idst(x[row</span><span class="s0">, </span><span class="s1">:]</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">range(x.shape[</span><span class="s4">1</span><span class="s1">]):</span>
        <span class="s1">x[:</span><span class="s0">, </span><span class="s1">col] = idst(x[:</span><span class="s0">, </span><span class="s1">col]</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s0">return </span><span class="s1">x</span>


<span class="s0">def </span><span class="s1">naive_dct1(x</span><span class="s0">, </span><span class="s1">norm=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot;Calculate textbook definition version of DCT-I.&quot;&quot;&quot;</span>
    <span class="s1">x = np.array(x</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">N = len(x)</span>
    <span class="s1">M = N-</span><span class="s4">1</span>
    <span class="s1">y = np.zeros(N)</span>
    <span class="s1">m0</span><span class="s0">, </span><span class="s1">m = </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span>
    <span class="s0">if </span><span class="s1">norm == </span><span class="s3">'ortho'</span><span class="s1">:</span>
        <span class="s1">m0 = np.sqrt(</span><span class="s4">1.0</span><span class="s1">/M)</span>
        <span class="s1">m = np.sqrt(</span><span class="s4">2.0</span><span class="s1">/M)</span>
    <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range(N):</span>
        <span class="s0">for </span><span class="s1">n </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s0">, </span><span class="s1">N-</span><span class="s4">1</span><span class="s1">):</span>
            <span class="s1">y[k] += m*x[n]*np.cos(np.pi*n*k/M)</span>
        <span class="s1">y[k] += m0 * x[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">y[k] += m0 * x[N-</span><span class="s4">1</span><span class="s1">] * (</span><span class="s4">1 </span><span class="s0">if </span><span class="s1">k % </span><span class="s4">2 </span><span class="s1">== </span><span class="s4">0 </span><span class="s0">else </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">norm == </span><span class="s3">'ortho'</span><span class="s1">:</span>
        <span class="s1">y[</span><span class="s4">0</span><span class="s1">] *= </span><span class="s4">1</span><span class="s1">/np.sqrt(</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">y[N-</span><span class="s4">1</span><span class="s1">] *= </span><span class="s4">1</span><span class="s1">/np.sqrt(</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">y</span>


<span class="s0">def </span><span class="s1">naive_dst1(x</span><span class="s0">, </span><span class="s1">norm=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot;Calculate textbook definition version  of DST-I.&quot;&quot;&quot;</span>
    <span class="s1">x = np.array(x</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">N = len(x)</span>
    <span class="s1">M = N+</span><span class="s4">1</span>
    <span class="s1">y = np.zeros(N)</span>
    <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range(N):</span>
        <span class="s0">for </span><span class="s1">n </span><span class="s0">in </span><span class="s1">range(N):</span>
            <span class="s1">y[k] += </span><span class="s4">2</span><span class="s1">*x[n]*np.sin(np.pi*(n+</span><span class="s4">1.0</span><span class="s1">)*(k+</span><span class="s4">1.0</span><span class="s1">)/M)</span>
    <span class="s0">if </span><span class="s1">norm == </span><span class="s3">'ortho'</span><span class="s1">:</span>
        <span class="s1">y *= np.sqrt(</span><span class="s4">0.5</span><span class="s1">/M)</span>
    <span class="s0">return </span><span class="s1">y</span>


<span class="s0">def </span><span class="s1">naive_dct4(x</span><span class="s0">, </span><span class="s1">norm=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot;Calculate textbook definition version of DCT-IV.&quot;&quot;&quot;</span>
    <span class="s1">x = np.array(x</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">N = len(x)</span>
    <span class="s1">y = np.zeros(N)</span>
    <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range(N):</span>
        <span class="s0">for </span><span class="s1">n </span><span class="s0">in </span><span class="s1">range(N):</span>
            <span class="s1">y[k] += x[n]*np.cos(np.pi*(n+</span><span class="s4">0.5</span><span class="s1">)*(k+</span><span class="s4">0.5</span><span class="s1">)/(N))</span>
    <span class="s0">if </span><span class="s1">norm == </span><span class="s3">'ortho'</span><span class="s1">:</span>
        <span class="s1">y *= np.sqrt(</span><span class="s4">2.0</span><span class="s1">/N)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">y *= </span><span class="s4">2</span>
    <span class="s0">return </span><span class="s1">y</span>


<span class="s0">def </span><span class="s1">naive_dst4(x</span><span class="s0">, </span><span class="s1">norm=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot;Calculate textbook definition version of DST-IV.&quot;&quot;&quot;</span>
    <span class="s1">x = np.array(x</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">N = len(x)</span>
    <span class="s1">y = np.zeros(N)</span>
    <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range(N):</span>
        <span class="s0">for </span><span class="s1">n </span><span class="s0">in </span><span class="s1">range(N):</span>
            <span class="s1">y[k] += x[n]*np.sin(np.pi*(n+</span><span class="s4">0.5</span><span class="s1">)*(k+</span><span class="s4">0.5</span><span class="s1">)/(N))</span>
    <span class="s0">if </span><span class="s1">norm == </span><span class="s3">'ortho'</span><span class="s1">:</span>
        <span class="s1">y *= np.sqrt(</span><span class="s4">2.0</span><span class="s1">/N)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">y *= </span><span class="s4">2</span>
    <span class="s0">return </span><span class="s1">y</span>


<span class="s0">class </span><span class="s1">TestComplex:</span>
    <span class="s0">def </span><span class="s1">test_dct_complex64(self):</span>
        <span class="s1">y = dct(</span><span class="s4">1j</span><span class="s1">*np.arange(</span><span class="s4">5</span><span class="s0">, </span><span class="s1">dtype=np.complex64))</span>
        <span class="s1">x = </span><span class="s4">1j</span><span class="s1">*dct(np.arange(</span><span class="s4">5</span><span class="s1">))</span>
        <span class="s1">assert_array_almost_equal(x</span><span class="s0">, </span><span class="s1">y)</span>

    <span class="s0">def </span><span class="s1">test_dct_complex(self):</span>
        <span class="s1">y = dct(np.arange(</span><span class="s4">5</span><span class="s1">)*</span><span class="s4">1j</span><span class="s1">)</span>
        <span class="s1">x = </span><span class="s4">1j</span><span class="s1">*dct(np.arange(</span><span class="s4">5</span><span class="s1">))</span>
        <span class="s1">assert_array_almost_equal(x</span><span class="s0">, </span><span class="s1">y)</span>

    <span class="s0">def </span><span class="s1">test_idct_complex(self):</span>
        <span class="s1">y = idct(np.arange(</span><span class="s4">5</span><span class="s1">)*</span><span class="s4">1j</span><span class="s1">)</span>
        <span class="s1">x = </span><span class="s4">1j</span><span class="s1">*idct(np.arange(</span><span class="s4">5</span><span class="s1">))</span>
        <span class="s1">assert_array_almost_equal(x</span><span class="s0">, </span><span class="s1">y)</span>

    <span class="s0">def </span><span class="s1">test_dst_complex64(self):</span>
        <span class="s1">y = dst(np.arange(</span><span class="s4">5</span><span class="s0">, </span><span class="s1">dtype=np.complex64)*</span><span class="s4">1j</span><span class="s1">)</span>
        <span class="s1">x = </span><span class="s4">1j</span><span class="s1">*dst(np.arange(</span><span class="s4">5</span><span class="s1">))</span>
        <span class="s1">assert_array_almost_equal(x</span><span class="s0">, </span><span class="s1">y)</span>

    <span class="s0">def </span><span class="s1">test_dst_complex(self):</span>
        <span class="s1">y = dst(np.arange(</span><span class="s4">5</span><span class="s1">)*</span><span class="s4">1j</span><span class="s1">)</span>
        <span class="s1">x = </span><span class="s4">1j</span><span class="s1">*dst(np.arange(</span><span class="s4">5</span><span class="s1">))</span>
        <span class="s1">assert_array_almost_equal(x</span><span class="s0">, </span><span class="s1">y)</span>

    <span class="s0">def </span><span class="s1">test_idst_complex(self):</span>
        <span class="s1">y = idst(np.arange(</span><span class="s4">5</span><span class="s1">)*</span><span class="s4">1j</span><span class="s1">)</span>
        <span class="s1">x = </span><span class="s4">1j</span><span class="s1">*idst(np.arange(</span><span class="s4">5</span><span class="s1">))</span>
        <span class="s1">assert_array_almost_equal(x</span><span class="s0">, </span><span class="s1">y)</span>


<span class="s0">class </span><span class="s1">_TestDCTBase:</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = </span><span class="s0">None</span>
        <span class="s1">self.dec = </span><span class="s4">14</span>
        <span class="s1">self.type = </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">test_definition(self):</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">FFTWDATA_SIZES:</span>
            <span class="s1">x</span><span class="s0">, </span><span class="s1">yr</span><span class="s0">, </span><span class="s1">dt = fftw_dct_ref(self.type</span><span class="s0">, </span><span class="s1">i</span><span class="s0">, </span><span class="s1">self.rdt)</span>
            <span class="s1">y = dct(x</span><span class="s0">, </span><span class="s1">type=self.type)</span>
            <span class="s1">assert_equal(y.dtype</span><span class="s0">, </span><span class="s1">dt)</span>
            <span class="s2"># XXX: we divide by np.max(y) because the tests fail otherwise. We</span>
            <span class="s2"># should really use something like assert_array_approx_equal. The</span>
            <span class="s2"># difference is due to fftw using a better algorithm w.r.t error</span>
            <span class="s2"># propagation compared to the ones from fftpack.</span>
            <span class="s1">assert_array_almost_equal(y / np.max(y)</span><span class="s0">, </span><span class="s1">yr / np.max(y)</span><span class="s0">, </span><span class="s1">decimal=self.dec</span><span class="s0">,</span>
                    <span class="s1">err_msg=</span><span class="s3">&quot;Size %d failed&quot; </span><span class="s1">% i)</span>

    <span class="s0">def </span><span class="s1">test_axis(self):</span>
        <span class="s1">nt = </span><span class="s4">2</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">[</span><span class="s4">7</span><span class="s0">, </span><span class="s4">8</span><span class="s0">, </span><span class="s4">9</span><span class="s0">, </span><span class="s4">16</span><span class="s0">, </span><span class="s4">32</span><span class="s0">, </span><span class="s4">64</span><span class="s1">]:</span>
            <span class="s1">x = np.random.randn(nt</span><span class="s0">, </span><span class="s1">i)</span>
            <span class="s1">y = dct(x</span><span class="s0">, </span><span class="s1">type=self.type)</span>
            <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(nt):</span>
                <span class="s1">assert_array_almost_equal(y[j]</span><span class="s0">, </span><span class="s1">dct(x[j]</span><span class="s0">, </span><span class="s1">type=self.type)</span><span class="s0">,</span>
                        <span class="s1">decimal=self.dec)</span>

            <span class="s1">x = x.T</span>
            <span class="s1">y = dct(x</span><span class="s0">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s0">, </span><span class="s1">type=self.type)</span>
            <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(nt):</span>
                <span class="s1">assert_array_almost_equal(y[:</span><span class="s0">,</span><span class="s1">j]</span><span class="s0">, </span><span class="s1">dct(x[:</span><span class="s0">,</span><span class="s1">j]</span><span class="s0">, </span><span class="s1">type=self.type)</span><span class="s0">,</span>
                        <span class="s1">decimal=self.dec)</span>


<span class="s0">class </span><span class="s1">_TestDCTIBase(_TestDCTBase):</span>
    <span class="s0">def </span><span class="s1">test_definition_ortho(self):</span>
        <span class="s2"># Test orthornomal mode.</span>
        <span class="s1">dt = np.result_type(np.float32</span><span class="s0">, </span><span class="s1">self.rdt)</span>
        <span class="s0">for </span><span class="s1">xr </span><span class="s0">in </span><span class="s1">X:</span>
            <span class="s1">x = np.array(xr</span><span class="s0">, </span><span class="s1">dtype=self.rdt)</span>
            <span class="s1">y = dct(x</span><span class="s0">, </span><span class="s1">norm=</span><span class="s3">'ortho'</span><span class="s0">, </span><span class="s1">type=</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">y2 = naive_dct1(x</span><span class="s0">, </span><span class="s1">norm=</span><span class="s3">'ortho'</span><span class="s1">)</span>
            <span class="s1">assert_equal(y.dtype</span><span class="s0">, </span><span class="s1">dt)</span>
            <span class="s1">assert_array_almost_equal(y / np.max(y)</span><span class="s0">, </span><span class="s1">y2 / np.max(y)</span><span class="s0">, </span><span class="s1">decimal=self.dec)</span>

<span class="s0">class </span><span class="s1">_TestDCTIIBase(_TestDCTBase):</span>
    <span class="s0">def </span><span class="s1">test_definition_matlab(self):</span>
        <span class="s2"># Test correspondence with MATLAB (orthornomal mode).</span>
        <span class="s1">dt = np.result_type(np.float32</span><span class="s0">, </span><span class="s1">self.rdt)</span>
        <span class="s0">for </span><span class="s1">xr</span><span class="s0">, </span><span class="s1">yr </span><span class="s0">in </span><span class="s1">zip(X</span><span class="s0">, </span><span class="s1">Y):</span>
            <span class="s1">x = np.array(xr</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
            <span class="s1">y = dct(x</span><span class="s0">, </span><span class="s1">norm=</span><span class="s3">&quot;ortho&quot;</span><span class="s0">, </span><span class="s1">type=</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s1">assert_equal(y.dtype</span><span class="s0">, </span><span class="s1">dt)</span>
            <span class="s1">assert_array_almost_equal(y</span><span class="s0">, </span><span class="s1">yr</span><span class="s0">, </span><span class="s1">decimal=self.dec)</span>


<span class="s0">class </span><span class="s1">_TestDCTIIIBase(_TestDCTBase):</span>
    <span class="s0">def </span><span class="s1">test_definition_ortho(self):</span>
        <span class="s2"># Test orthornomal mode.</span>
        <span class="s1">dt = np.result_type(np.float32</span><span class="s0">, </span><span class="s1">self.rdt)</span>
        <span class="s0">for </span><span class="s1">xr </span><span class="s0">in </span><span class="s1">X:</span>
            <span class="s1">x = np.array(xr</span><span class="s0">, </span><span class="s1">dtype=self.rdt)</span>
            <span class="s1">y = dct(x</span><span class="s0">, </span><span class="s1">norm=</span><span class="s3">'ortho'</span><span class="s0">, </span><span class="s1">type=</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s1">xi = dct(y</span><span class="s0">, </span><span class="s1">norm=</span><span class="s3">&quot;ortho&quot;</span><span class="s0">, </span><span class="s1">type=</span><span class="s4">3</span><span class="s1">)</span>
            <span class="s1">assert_equal(xi.dtype</span><span class="s0">, </span><span class="s1">dt)</span>
            <span class="s1">assert_array_almost_equal(xi</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">decimal=self.dec)</span>

<span class="s0">class </span><span class="s1">_TestDCTIVBase(_TestDCTBase):</span>
    <span class="s0">def </span><span class="s1">test_definition_ortho(self):</span>
        <span class="s2"># Test orthornomal mode.</span>
        <span class="s1">dt = np.result_type(np.float32</span><span class="s0">, </span><span class="s1">self.rdt)</span>
        <span class="s0">for </span><span class="s1">xr </span><span class="s0">in </span><span class="s1">X:</span>
            <span class="s1">x = np.array(xr</span><span class="s0">, </span><span class="s1">dtype=self.rdt)</span>
            <span class="s1">y = dct(x</span><span class="s0">, </span><span class="s1">norm=</span><span class="s3">'ortho'</span><span class="s0">, </span><span class="s1">type=</span><span class="s4">4</span><span class="s1">)</span>
            <span class="s1">y2 = naive_dct4(x</span><span class="s0">, </span><span class="s1">norm=</span><span class="s3">'ortho'</span><span class="s1">)</span>
            <span class="s1">assert_equal(y.dtype</span><span class="s0">, </span><span class="s1">dt)</span>
            <span class="s1">assert_array_almost_equal(y / np.max(y)</span><span class="s0">, </span><span class="s1">y2 / np.max(y)</span><span class="s0">, </span><span class="s1">decimal=self.dec)</span>


<span class="s0">class </span><span class="s1">TestDCTIDouble(_TestDCTIBase):</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = np.double</span>
        <span class="s1">self.dec = </span><span class="s4">10</span>
        <span class="s1">self.type = </span><span class="s4">1</span>


<span class="s0">class </span><span class="s1">TestDCTIFloat(_TestDCTIBase):</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = np.float32</span>
        <span class="s1">self.dec = </span><span class="s4">4</span>
        <span class="s1">self.type = </span><span class="s4">1</span>


<span class="s0">class </span><span class="s1">TestDCTIInt(_TestDCTIBase):</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = int</span>
        <span class="s1">self.dec = </span><span class="s4">5</span>
        <span class="s1">self.type = </span><span class="s4">1</span>


<span class="s0">class </span><span class="s1">TestDCTIIDouble(_TestDCTIIBase):</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = np.double</span>
        <span class="s1">self.dec = </span><span class="s4">10</span>
        <span class="s1">self.type = </span><span class="s4">2</span>


<span class="s0">class </span><span class="s1">TestDCTIIFloat(_TestDCTIIBase):</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = np.float32</span>
        <span class="s1">self.dec = </span><span class="s4">5</span>
        <span class="s1">self.type = </span><span class="s4">2</span>


<span class="s0">class </span><span class="s1">TestDCTIIInt(_TestDCTIIBase):</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = int</span>
        <span class="s1">self.dec = </span><span class="s4">5</span>
        <span class="s1">self.type = </span><span class="s4">2</span>


<span class="s0">class </span><span class="s1">TestDCTIIIDouble(_TestDCTIIIBase):</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = np.double</span>
        <span class="s1">self.dec = </span><span class="s4">14</span>
        <span class="s1">self.type = </span><span class="s4">3</span>


<span class="s0">class </span><span class="s1">TestDCTIIIFloat(_TestDCTIIIBase):</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = np.float32</span>
        <span class="s1">self.dec = </span><span class="s4">5</span>
        <span class="s1">self.type = </span><span class="s4">3</span>


<span class="s0">class </span><span class="s1">TestDCTIIIInt(_TestDCTIIIBase):</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = int</span>
        <span class="s1">self.dec = </span><span class="s4">5</span>
        <span class="s1">self.type = </span><span class="s4">3</span>


<span class="s0">class </span><span class="s1">TestDCTIVDouble(_TestDCTIVBase):</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = np.double</span>
        <span class="s1">self.dec = </span><span class="s4">12</span>
        <span class="s1">self.type = </span><span class="s4">3</span>


<span class="s0">class </span><span class="s1">TestDCTIVFloat(_TestDCTIVBase):</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = np.float32</span>
        <span class="s1">self.dec = </span><span class="s4">5</span>
        <span class="s1">self.type = </span><span class="s4">3</span>


<span class="s0">class </span><span class="s1">TestDCTIVInt(_TestDCTIVBase):</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = int</span>
        <span class="s1">self.dec = </span><span class="s4">5</span>
        <span class="s1">self.type = </span><span class="s4">3</span>


<span class="s0">class </span><span class="s1">_TestIDCTBase:</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = </span><span class="s0">None</span>
        <span class="s1">self.dec = </span><span class="s4">14</span>
        <span class="s1">self.type = </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">test_definition(self):</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">FFTWDATA_SIZES:</span>
            <span class="s1">xr</span><span class="s0">, </span><span class="s1">yr</span><span class="s0">, </span><span class="s1">dt = fftw_dct_ref(self.type</span><span class="s0">, </span><span class="s1">i</span><span class="s0">, </span><span class="s1">self.rdt)</span>
            <span class="s1">x = idct(yr</span><span class="s0">, </span><span class="s1">type=self.type)</span>
            <span class="s0">if </span><span class="s1">self.type == </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">x /= </span><span class="s4">2 </span><span class="s1">* (i-</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">x /= </span><span class="s4">2 </span><span class="s1">* i</span>
            <span class="s1">assert_equal(x.dtype</span><span class="s0">, </span><span class="s1">dt)</span>
            <span class="s2"># XXX: we divide by np.max(y) because the tests fail otherwise. We</span>
            <span class="s2"># should really use something like assert_array_approx_equal. The</span>
            <span class="s2"># difference is due to fftw using a better algorithm w.r.t error</span>
            <span class="s2"># propagation compared to the ones from fftpack.</span>
            <span class="s1">assert_array_almost_equal(x / np.max(x)</span><span class="s0">, </span><span class="s1">xr / np.max(x)</span><span class="s0">, </span><span class="s1">decimal=self.dec</span><span class="s0">,</span>
                    <span class="s1">err_msg=</span><span class="s3">&quot;Size %d failed&quot; </span><span class="s1">% i)</span>


<span class="s0">class </span><span class="s1">TestIDCTIDouble(_TestIDCTBase):</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = np.double</span>
        <span class="s1">self.dec = </span><span class="s4">10</span>
        <span class="s1">self.type = </span><span class="s4">1</span>


<span class="s0">class </span><span class="s1">TestIDCTIFloat(_TestIDCTBase):</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = np.float32</span>
        <span class="s1">self.dec = </span><span class="s4">4</span>
        <span class="s1">self.type = </span><span class="s4">1</span>


<span class="s0">class </span><span class="s1">TestIDCTIInt(_TestIDCTBase):</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = int</span>
        <span class="s1">self.dec = </span><span class="s4">4</span>
        <span class="s1">self.type = </span><span class="s4">1</span>


<span class="s0">class </span><span class="s1">TestIDCTIIDouble(_TestIDCTBase):</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = np.double</span>
        <span class="s1">self.dec = </span><span class="s4">10</span>
        <span class="s1">self.type = </span><span class="s4">2</span>


<span class="s0">class </span><span class="s1">TestIDCTIIFloat(_TestIDCTBase):</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = np.float32</span>
        <span class="s1">self.dec = </span><span class="s4">5</span>
        <span class="s1">self.type = </span><span class="s4">2</span>


<span class="s0">class </span><span class="s1">TestIDCTIIInt(_TestIDCTBase):</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = int</span>
        <span class="s1">self.dec = </span><span class="s4">5</span>
        <span class="s1">self.type = </span><span class="s4">2</span>


<span class="s0">class </span><span class="s1">TestIDCTIIIDouble(_TestIDCTBase):</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = np.double</span>
        <span class="s1">self.dec = </span><span class="s4">14</span>
        <span class="s1">self.type = </span><span class="s4">3</span>


<span class="s0">class </span><span class="s1">TestIDCTIIIFloat(_TestIDCTBase):</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = np.float32</span>
        <span class="s1">self.dec = </span><span class="s4">5</span>
        <span class="s1">self.type = </span><span class="s4">3</span>


<span class="s0">class </span><span class="s1">TestIDCTIIIInt(_TestIDCTBase):</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = int</span>
        <span class="s1">self.dec = </span><span class="s4">5</span>
        <span class="s1">self.type = </span><span class="s4">3</span>

<span class="s0">class </span><span class="s1">TestIDCTIVDouble(_TestIDCTBase):</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = np.double</span>
        <span class="s1">self.dec = </span><span class="s4">12</span>
        <span class="s1">self.type = </span><span class="s4">4</span>


<span class="s0">class </span><span class="s1">TestIDCTIVFloat(_TestIDCTBase):</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = np.float32</span>
        <span class="s1">self.dec = </span><span class="s4">5</span>
        <span class="s1">self.type = </span><span class="s4">4</span>


<span class="s0">class </span><span class="s1">TestIDCTIVInt(_TestIDCTBase):</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = int</span>
        <span class="s1">self.dec = </span><span class="s4">5</span>
        <span class="s1">self.type = </span><span class="s4">4</span>

<span class="s0">class </span><span class="s1">_TestDSTBase:</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = </span><span class="s0">None  </span><span class="s2"># dtype</span>
        <span class="s1">self.dec = </span><span class="s0">None  </span><span class="s2"># number of decimals to match</span>
        <span class="s1">self.type = </span><span class="s0">None  </span><span class="s2"># dst type</span>

    <span class="s0">def </span><span class="s1">test_definition(self):</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">FFTWDATA_SIZES:</span>
            <span class="s1">xr</span><span class="s0">, </span><span class="s1">yr</span><span class="s0">, </span><span class="s1">dt = fftw_dst_ref(self.type</span><span class="s0">, </span><span class="s1">i</span><span class="s0">, </span><span class="s1">self.rdt)</span>
            <span class="s1">y = dst(xr</span><span class="s0">, </span><span class="s1">type=self.type)</span>
            <span class="s1">assert_equal(y.dtype</span><span class="s0">, </span><span class="s1">dt)</span>
            <span class="s2"># XXX: we divide by np.max(y) because the tests fail otherwise. We</span>
            <span class="s2"># should really use something like assert_array_approx_equal. The</span>
            <span class="s2"># difference is due to fftw using a better algorithm w.r.t error</span>
            <span class="s2"># propagation compared to the ones from fftpack.</span>
            <span class="s1">assert_array_almost_equal(y / np.max(y)</span><span class="s0">, </span><span class="s1">yr / np.max(y)</span><span class="s0">, </span><span class="s1">decimal=self.dec</span><span class="s0">,</span>
                    <span class="s1">err_msg=</span><span class="s3">&quot;Size %d failed&quot; </span><span class="s1">% i)</span>


<span class="s0">class </span><span class="s1">_TestDSTIBase(_TestDSTBase):</span>
    <span class="s0">def </span><span class="s1">test_definition_ortho(self):</span>
        <span class="s2"># Test orthornomal mode.</span>
        <span class="s1">dt = np.result_type(np.float32</span><span class="s0">, </span><span class="s1">self.rdt)</span>
        <span class="s0">for </span><span class="s1">xr </span><span class="s0">in </span><span class="s1">X:</span>
            <span class="s1">x = np.array(xr</span><span class="s0">, </span><span class="s1">dtype=self.rdt)</span>
            <span class="s1">y = dst(x</span><span class="s0">, </span><span class="s1">norm=</span><span class="s3">'ortho'</span><span class="s0">, </span><span class="s1">type=</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">y2 = naive_dst1(x</span><span class="s0">, </span><span class="s1">norm=</span><span class="s3">'ortho'</span><span class="s1">)</span>
            <span class="s1">assert_equal(y.dtype</span><span class="s0">, </span><span class="s1">dt)</span>
            <span class="s1">assert_array_almost_equal(y / np.max(y)</span><span class="s0">, </span><span class="s1">y2 / np.max(y)</span><span class="s0">, </span><span class="s1">decimal=self.dec)</span>

<span class="s0">class </span><span class="s1">_TestDSTIVBase(_TestDSTBase):</span>
    <span class="s0">def </span><span class="s1">test_definition_ortho(self):</span>
        <span class="s2"># Test orthornomal mode.</span>
        <span class="s1">dt = np.result_type(np.float32</span><span class="s0">, </span><span class="s1">self.rdt)</span>
        <span class="s0">for </span><span class="s1">xr </span><span class="s0">in </span><span class="s1">X:</span>
            <span class="s1">x = np.array(xr</span><span class="s0">, </span><span class="s1">dtype=self.rdt)</span>
            <span class="s1">y = dst(x</span><span class="s0">, </span><span class="s1">norm=</span><span class="s3">'ortho'</span><span class="s0">, </span><span class="s1">type=</span><span class="s4">4</span><span class="s1">)</span>
            <span class="s1">y2 = naive_dst4(x</span><span class="s0">, </span><span class="s1">norm=</span><span class="s3">'ortho'</span><span class="s1">)</span>
            <span class="s1">assert_equal(y.dtype</span><span class="s0">, </span><span class="s1">dt)</span>
            <span class="s1">assert_array_almost_equal(y</span><span class="s0">, </span><span class="s1">y2</span><span class="s0">, </span><span class="s1">decimal=self.dec)</span>

<span class="s0">class </span><span class="s1">TestDSTIDouble(_TestDSTIBase):</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = np.double</span>
        <span class="s1">self.dec = </span><span class="s4">12</span>
        <span class="s1">self.type = </span><span class="s4">1</span>


<span class="s0">class </span><span class="s1">TestDSTIFloat(_TestDSTIBase):</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = np.float32</span>
        <span class="s1">self.dec = </span><span class="s4">4</span>
        <span class="s1">self.type = </span><span class="s4">1</span>


<span class="s0">class </span><span class="s1">TestDSTIInt(_TestDSTIBase):</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = int</span>
        <span class="s1">self.dec = </span><span class="s4">5</span>
        <span class="s1">self.type = </span><span class="s4">1</span>


<span class="s0">class </span><span class="s1">TestDSTIIDouble(_TestDSTBase):</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = np.double</span>
        <span class="s1">self.dec = </span><span class="s4">14</span>
        <span class="s1">self.type = </span><span class="s4">2</span>


<span class="s0">class </span><span class="s1">TestDSTIIFloat(_TestDSTBase):</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = np.float32</span>
        <span class="s1">self.dec = </span><span class="s4">6</span>
        <span class="s1">self.type = </span><span class="s4">2</span>


<span class="s0">class </span><span class="s1">TestDSTIIInt(_TestDSTBase):</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = int</span>
        <span class="s1">self.dec = </span><span class="s4">6</span>
        <span class="s1">self.type = </span><span class="s4">2</span>


<span class="s0">class </span><span class="s1">TestDSTIIIDouble(_TestDSTBase):</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = np.double</span>
        <span class="s1">self.dec = </span><span class="s4">14</span>
        <span class="s1">self.type = </span><span class="s4">3</span>


<span class="s0">class </span><span class="s1">TestDSTIIIFloat(_TestDSTBase):</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = np.float32</span>
        <span class="s1">self.dec = </span><span class="s4">7</span>
        <span class="s1">self.type = </span><span class="s4">3</span>


<span class="s0">class </span><span class="s1">TestDSTIIIInt(_TestDSTBase):</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = int</span>
        <span class="s1">self.dec = </span><span class="s4">7</span>
        <span class="s1">self.type = </span><span class="s4">3</span>


<span class="s0">class </span><span class="s1">TestDSTIVDouble(_TestDSTIVBase):</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = np.double</span>
        <span class="s1">self.dec = </span><span class="s4">12</span>
        <span class="s1">self.type = </span><span class="s4">4</span>


<span class="s0">class </span><span class="s1">TestDSTIVFloat(_TestDSTIVBase):</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = np.float32</span>
        <span class="s1">self.dec = </span><span class="s4">4</span>
        <span class="s1">self.type = </span><span class="s4">4</span>


<span class="s0">class </span><span class="s1">TestDSTIVInt(_TestDSTIVBase):</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = int</span>
        <span class="s1">self.dec = </span><span class="s4">5</span>
        <span class="s1">self.type = </span><span class="s4">4</span>


<span class="s0">class </span><span class="s1">_TestIDSTBase:</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = </span><span class="s0">None</span>
        <span class="s1">self.dec = </span><span class="s0">None</span>
        <span class="s1">self.type = </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">test_definition(self):</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">FFTWDATA_SIZES:</span>
            <span class="s1">xr</span><span class="s0">, </span><span class="s1">yr</span><span class="s0">, </span><span class="s1">dt = fftw_dst_ref(self.type</span><span class="s0">, </span><span class="s1">i</span><span class="s0">, </span><span class="s1">self.rdt)</span>
            <span class="s1">x = idst(yr</span><span class="s0">, </span><span class="s1">type=self.type)</span>
            <span class="s0">if </span><span class="s1">self.type == </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">x /= </span><span class="s4">2 </span><span class="s1">* (i+</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">x /= </span><span class="s4">2 </span><span class="s1">* i</span>
            <span class="s1">assert_equal(x.dtype</span><span class="s0">, </span><span class="s1">dt)</span>
            <span class="s2"># XXX: we divide by np.max(x) because the tests fail otherwise. We</span>
            <span class="s2"># should really use something like assert_array_approx_equal. The</span>
            <span class="s2"># difference is due to fftw using a better algorithm w.r.t error</span>
            <span class="s2"># propagation compared to the ones from fftpack.</span>
            <span class="s1">assert_array_almost_equal(x / np.max(x)</span><span class="s0">, </span><span class="s1">xr / np.max(x)</span><span class="s0">, </span><span class="s1">decimal=self.dec</span><span class="s0">,</span>
                    <span class="s1">err_msg=</span><span class="s3">&quot;Size %d failed&quot; </span><span class="s1">% i)</span>


<span class="s0">class </span><span class="s1">TestIDSTIDouble(_TestIDSTBase):</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = np.double</span>
        <span class="s1">self.dec = </span><span class="s4">12</span>
        <span class="s1">self.type = </span><span class="s4">1</span>


<span class="s0">class </span><span class="s1">TestIDSTIFloat(_TestIDSTBase):</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = np.float32</span>
        <span class="s1">self.dec = </span><span class="s4">4</span>
        <span class="s1">self.type = </span><span class="s4">1</span>


<span class="s0">class </span><span class="s1">TestIDSTIInt(_TestIDSTBase):</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = int</span>
        <span class="s1">self.dec = </span><span class="s4">4</span>
        <span class="s1">self.type = </span><span class="s4">1</span>


<span class="s0">class </span><span class="s1">TestIDSTIIDouble(_TestIDSTBase):</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = np.double</span>
        <span class="s1">self.dec = </span><span class="s4">14</span>
        <span class="s1">self.type = </span><span class="s4">2</span>


<span class="s0">class </span><span class="s1">TestIDSTIIFloat(_TestIDSTBase):</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = np.float32</span>
        <span class="s1">self.dec = </span><span class="s4">6</span>
        <span class="s1">self.type = </span><span class="s4">2</span>


<span class="s0">class </span><span class="s1">TestIDSTIIInt(_TestIDSTBase):</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = int</span>
        <span class="s1">self.dec = </span><span class="s4">6</span>
        <span class="s1">self.type = </span><span class="s4">2</span>


<span class="s0">class </span><span class="s1">TestIDSTIIIDouble(_TestIDSTBase):</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = np.double</span>
        <span class="s1">self.dec = </span><span class="s4">14</span>
        <span class="s1">self.type = </span><span class="s4">3</span>


<span class="s0">class </span><span class="s1">TestIDSTIIIFloat(_TestIDSTBase):</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = np.float32</span>
        <span class="s1">self.dec = </span><span class="s4">6</span>
        <span class="s1">self.type = </span><span class="s4">3</span>


<span class="s0">class </span><span class="s1">TestIDSTIIIInt(_TestIDSTBase):</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = int</span>
        <span class="s1">self.dec = </span><span class="s4">6</span>
        <span class="s1">self.type = </span><span class="s4">3</span>


<span class="s0">class </span><span class="s1">TestIDSTIVDouble(_TestIDSTBase):</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = np.double</span>
        <span class="s1">self.dec = </span><span class="s4">12</span>
        <span class="s1">self.type = </span><span class="s4">4</span>


<span class="s0">class </span><span class="s1">TestIDSTIVFloat(_TestIDSTBase):</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = np.float32</span>
        <span class="s1">self.dec = </span><span class="s4">6</span>
        <span class="s1">self.type = </span><span class="s4">4</span>


<span class="s0">class </span><span class="s1">TestIDSTIVnt(_TestIDSTBase):</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rdt = int</span>
        <span class="s1">self.dec = </span><span class="s4">6</span>
        <span class="s1">self.type = </span><span class="s4">4</span>


<span class="s0">class </span><span class="s1">TestOverwrite:</span>
    <span class="s5">&quot;&quot;&quot;Check input overwrite behavior.&quot;&quot;&quot;</span>

    <span class="s1">real_dtypes = [np.float32</span><span class="s0">, </span><span class="s1">np.float64]</span>

    <span class="s0">def </span><span class="s1">_check(self</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">routine</span><span class="s0">, </span><span class="s1">type</span><span class="s0">, </span><span class="s1">fftsize</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">norm</span><span class="s0">, </span><span class="s1">overwrite_x</span><span class="s0">, </span><span class="s1">**kw):</span>
        <span class="s1">x2 = x.copy()</span>
        <span class="s1">routine(x2</span><span class="s0">, </span><span class="s1">type</span><span class="s0">, </span><span class="s1">fftsize</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">norm</span><span class="s0">, </span><span class="s1">overwrite_x=overwrite_x)</span>

        <span class="s1">sig = </span><span class="s3">&quot;{}({}{!r}, {!r}, axis={!r}, overwrite_x={!r})&quot;</span><span class="s1">.format(</span>
            <span class="s1">routine.__name__</span><span class="s0">, </span><span class="s1">x.dtype</span><span class="s0">, </span><span class="s1">x.shape</span><span class="s0">, </span><span class="s1">fftsize</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">overwrite_x)</span>
        <span class="s0">if not </span><span class="s1">overwrite_x:</span>
            <span class="s1">assert_equal(x2</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">err_msg=</span><span class="s3">&quot;spurious overwrite in %s&quot; </span><span class="s1">% sig)</span>

    <span class="s0">def </span><span class="s1">_check_1d(self</span><span class="s0">, </span><span class="s1">routine</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">shape</span><span class="s0">, </span><span class="s1">axis):</span>
        <span class="s1">np.random.seed(</span><span class="s4">1234</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">np.issubdtype(dtype</span><span class="s0">, </span><span class="s1">np.complexfloating):</span>
            <span class="s1">data = np.random.randn(*shape) + </span><span class="s4">1j</span><span class="s1">*np.random.randn(*shape)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">data = np.random.randn(*shape)</span>
        <span class="s1">data = data.astype(dtype)</span>

        <span class="s0">for </span><span class="s1">type </span><span class="s0">in </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">4</span><span class="s1">]:</span>
            <span class="s0">for </span><span class="s1">overwrite_x </span><span class="s0">in </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">]:</span>
                <span class="s0">for </span><span class="s1">norm </span><span class="s0">in </span><span class="s1">[</span><span class="s0">None, </span><span class="s3">'ortho'</span><span class="s1">]:</span>
                    <span class="s1">self._check(data</span><span class="s0">, </span><span class="s1">routine</span><span class="s0">, </span><span class="s1">type</span><span class="s0">, None, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">norm</span><span class="s0">,</span>
                                <span class="s1">overwrite_x)</span>

    <span class="s0">def </span><span class="s1">test_dct(self):</span>
        <span class="s0">for </span><span class="s1">dtype </span><span class="s0">in </span><span class="s1">self.real_dtypes:</span>
            <span class="s1">self._check_1d(dct</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">(</span><span class="s4">16</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">self._check_1d(dct</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">(</span><span class="s4">16</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
            <span class="s1">self._check_1d(dct</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">(</span><span class="s4">2</span><span class="s0">, </span><span class="s4">16</span><span class="s1">)</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_idct(self):</span>
        <span class="s0">for </span><span class="s1">dtype </span><span class="s0">in </span><span class="s1">self.real_dtypes:</span>
            <span class="s1">self._check_1d(idct</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">(</span><span class="s4">16</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">self._check_1d(idct</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">(</span><span class="s4">16</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
            <span class="s1">self._check_1d(idct</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">(</span><span class="s4">2</span><span class="s0">, </span><span class="s4">16</span><span class="s1">)</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_dst(self):</span>
        <span class="s0">for </span><span class="s1">dtype </span><span class="s0">in </span><span class="s1">self.real_dtypes:</span>
            <span class="s1">self._check_1d(dst</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">(</span><span class="s4">16</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">self._check_1d(dst</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">(</span><span class="s4">16</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
            <span class="s1">self._check_1d(dst</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">(</span><span class="s4">2</span><span class="s0">, </span><span class="s4">16</span><span class="s1">)</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_idst(self):</span>
        <span class="s0">for </span><span class="s1">dtype </span><span class="s0">in </span><span class="s1">self.real_dtypes:</span>
            <span class="s1">self._check_1d(idst</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">(</span><span class="s4">16</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">self._check_1d(idst</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">(</span><span class="s4">16</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span>
            <span class="s1">self._check_1d(idst</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">(</span><span class="s4">2</span><span class="s0">, </span><span class="s4">16</span><span class="s1">)</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">Test_DCTN_IDCTN:</span>
    <span class="s1">dec = </span><span class="s4">14</span>
    <span class="s1">dct_type = [</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">4</span><span class="s1">]</span>
    <span class="s1">norms = [</span><span class="s0">None, </span><span class="s3">'ortho'</span><span class="s1">]</span>
    <span class="s1">rstate = np.random.RandomState(</span><span class="s4">1234</span><span class="s1">)</span>
    <span class="s1">shape = (</span><span class="s4">32</span><span class="s0">, </span><span class="s4">16</span><span class="s1">)</span>
    <span class="s1">data = rstate.randn(*shape)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'fforward,finverse'</span><span class="s0">, </span><span class="s1">[(dctn</span><span class="s0">, </span><span class="s1">idctn)</span><span class="s0">,</span>
                                                   <span class="s1">(dstn</span><span class="s0">, </span><span class="s1">idstn)])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'axes'</span><span class="s0">, </span><span class="s1">[</span><span class="s0">None,</span>
                                      <span class="s4">1</span><span class="s0">, </span><span class="s1">(</span><span class="s4">1</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">,</span>
                                      <span class="s4">0</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">,</span>
                                      <span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">,</span>
                                      <span class="s1">(-</span><span class="s4">2</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[-</span><span class="s4">2</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'dct_type'</span><span class="s0">, </span><span class="s1">dct_type)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'norm'</span><span class="s0">, </span><span class="s1">[</span><span class="s3">'ortho'</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_axes_round_trip(self</span><span class="s0">, </span><span class="s1">fforward</span><span class="s0">, </span><span class="s1">finverse</span><span class="s0">, </span><span class="s1">axes</span><span class="s0">, </span><span class="s1">dct_type</span><span class="s0">, </span><span class="s1">norm):</span>
        <span class="s1">tmp = fforward(self.data</span><span class="s0">, </span><span class="s1">type=dct_type</span><span class="s0">, </span><span class="s1">axes=axes</span><span class="s0">, </span><span class="s1">norm=norm)</span>
        <span class="s1">tmp = finverse(tmp</span><span class="s0">, </span><span class="s1">type=dct_type</span><span class="s0">, </span><span class="s1">axes=axes</span><span class="s0">, </span><span class="s1">norm=norm)</span>
        <span class="s1">assert_array_almost_equal(self.data</span><span class="s0">, </span><span class="s1">tmp</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s4">12</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'fforward,fforward_ref'</span><span class="s0">, </span><span class="s1">[(dctn</span><span class="s0">, </span><span class="s1">dct_2d_ref)</span><span class="s0">,</span>
                                                       <span class="s1">(dstn</span><span class="s0">, </span><span class="s1">dst_2d_ref)])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'dct_type'</span><span class="s0">, </span><span class="s1">dct_type)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'norm'</span><span class="s0">, </span><span class="s1">norms)</span>
    <span class="s0">def </span><span class="s1">test_dctn_vs_2d_reference(self</span><span class="s0">, </span><span class="s1">fforward</span><span class="s0">, </span><span class="s1">fforward_ref</span><span class="s0">,</span>
                                  <span class="s1">dct_type</span><span class="s0">, </span><span class="s1">norm):</span>
        <span class="s1">y1 = fforward(self.data</span><span class="s0">, </span><span class="s1">type=dct_type</span><span class="s0">, </span><span class="s1">axes=</span><span class="s0">None, </span><span class="s1">norm=norm)</span>
        <span class="s1">y2 = fforward_ref(self.data</span><span class="s0">, </span><span class="s1">type=dct_type</span><span class="s0">, </span><span class="s1">norm=norm)</span>
        <span class="s1">assert_array_almost_equal(y1</span><span class="s0">, </span><span class="s1">y2</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s4">11</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'finverse,finverse_ref'</span><span class="s0">, </span><span class="s1">[(idctn</span><span class="s0">, </span><span class="s1">idct_2d_ref)</span><span class="s0">,</span>
                                                       <span class="s1">(idstn</span><span class="s0">, </span><span class="s1">idst_2d_ref)])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'dct_type'</span><span class="s0">, </span><span class="s1">dct_type)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'norm'</span><span class="s0">, </span><span class="s1">[</span><span class="s0">None, </span><span class="s3">'ortho'</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_idctn_vs_2d_reference(self</span><span class="s0">, </span><span class="s1">finverse</span><span class="s0">, </span><span class="s1">finverse_ref</span><span class="s0">,</span>
                                   <span class="s1">dct_type</span><span class="s0">, </span><span class="s1">norm):</span>
        <span class="s1">fdata = dctn(self.data</span><span class="s0">, </span><span class="s1">type=dct_type</span><span class="s0">, </span><span class="s1">norm=norm)</span>
        <span class="s1">y1 = finverse(fdata</span><span class="s0">, </span><span class="s1">type=dct_type</span><span class="s0">, </span><span class="s1">norm=norm)</span>
        <span class="s1">y2 = finverse_ref(fdata</span><span class="s0">, </span><span class="s1">type=dct_type</span><span class="s0">, </span><span class="s1">norm=norm)</span>
        <span class="s1">assert_array_almost_equal(y1</span><span class="s0">, </span><span class="s1">y2</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s4">11</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'fforward,finverse'</span><span class="s0">, </span><span class="s1">[(dctn</span><span class="s0">, </span><span class="s1">idctn)</span><span class="s0">,</span>
                                                   <span class="s1">(dstn</span><span class="s0">, </span><span class="s1">idstn)])</span>
    <span class="s0">def </span><span class="s1">test_axes_and_shape(self</span><span class="s0">, </span><span class="s1">fforward</span><span class="s0">, </span><span class="s1">finverse):</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError</span><span class="s0">,</span>
                           <span class="s1">match=</span><span class="s3">&quot;when given, axes and shape arguments&quot;</span>
                           <span class="s3">&quot; have to be of the same length&quot;</span><span class="s1">):</span>
            <span class="s1">fforward(self.data</span><span class="s0">, </span><span class="s1">shape=self.data.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">axes=(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">))</span>

        <span class="s0">with </span><span class="s1">assert_raises(ValueError</span><span class="s0">,</span>
                           <span class="s1">match=</span><span class="s3">&quot;when given, axes and shape arguments&quot;</span>
                           <span class="s3">&quot; have to be of the same length&quot;</span><span class="s1">):</span>
            <span class="s1">fforward(self.data</span><span class="s0">, </span><span class="s1">shape=self.data.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">axes=</span><span class="s0">None</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">assert_raises(ValueError</span><span class="s0">,</span>
                           <span class="s1">match=</span><span class="s3">&quot;when given, axes and shape arguments&quot;</span>
                           <span class="s3">&quot; have to be of the same length&quot;</span><span class="s1">):</span>
            <span class="s1">fforward(self.data</span><span class="s0">, </span><span class="s1">shape=self.data.shape</span><span class="s0">, </span><span class="s1">axes=</span><span class="s4">0</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'fforward'</span><span class="s0">, </span><span class="s1">[dctn</span><span class="s0">, </span><span class="s1">dstn])</span>
    <span class="s0">def </span><span class="s1">test_shape(self</span><span class="s0">, </span><span class="s1">fforward):</span>
        <span class="s1">tmp = fforward(self.data</span><span class="s0">, </span><span class="s1">shape=(</span><span class="s4">128</span><span class="s0">, </span><span class="s4">128</span><span class="s1">)</span><span class="s0">, </span><span class="s1">axes=</span><span class="s0">None</span><span class="s1">)</span>
        <span class="s1">assert_equal(tmp.shape</span><span class="s0">, </span><span class="s1">(</span><span class="s4">128</span><span class="s0">, </span><span class="s4">128</span><span class="s1">))</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'fforward,finverse'</span><span class="s0">, </span><span class="s1">[(dctn</span><span class="s0">, </span><span class="s1">idctn)</span><span class="s0">,</span>
                                                   <span class="s1">(dstn</span><span class="s0">, </span><span class="s1">idstn)])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">'axes'</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s1">(</span><span class="s4">1</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">,</span>
                                      <span class="s4">0</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s1">]])</span>
    <span class="s0">def </span><span class="s1">test_shape_is_none_with_axes(self</span><span class="s0">, </span><span class="s1">fforward</span><span class="s0">, </span><span class="s1">finverse</span><span class="s0">, </span><span class="s1">axes):</span>
        <span class="s1">tmp = fforward(self.data</span><span class="s0">, </span><span class="s1">shape=</span><span class="s0">None, </span><span class="s1">axes=axes</span><span class="s0">, </span><span class="s1">norm=</span><span class="s3">'ortho'</span><span class="s1">)</span>
        <span class="s1">tmp = finverse(tmp</span><span class="s0">, </span><span class="s1">shape=</span><span class="s0">None, </span><span class="s1">axes=axes</span><span class="s0">, </span><span class="s1">norm=</span><span class="s3">'ortho'</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(self.data</span><span class="s0">, </span><span class="s1">tmp</span><span class="s0">, </span><span class="s1">decimal=self.dec)</span>
</pre>
</body>
</html>