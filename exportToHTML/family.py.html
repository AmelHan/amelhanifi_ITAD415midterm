<html>
<head>
<title>family.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
family.py</font>
</center></td></tr></table>
<pre><span class="s0">''' 
The one parameter exponential family distributions used by GLM. 
'''</span>
<span class="s2"># TODO: quasi, quasibinomial, quasipoisson</span>
<span class="s2"># see</span>
<span class="s2"># http://www.biostat.jhsph.edu/~qli/biostatistics_r_doc/library/stats/html/family.html</span>
<span class="s2"># for comparison to R, and McCullagh and Nelder</span>


<span class="s3">import </span><span class="s1">inspect</span>
<span class="s3">import </span><span class="s1">warnings</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">from </span><span class="s1">scipy </span><span class="s3">import </span><span class="s1">special</span><span class="s3">, </span><span class="s1">stats</span>

<span class="s3">from </span><span class="s1">statsmodels.compat.scipy </span><span class="s3">import </span><span class="s1">SP_LT_17</span>
<span class="s3">from </span><span class="s1">statsmodels.tools.sm_exceptions </span><span class="s3">import </span><span class="s1">(</span>
    <span class="s1">ValueWarning</span><span class="s3">,</span>
    <span class="s1">)</span>
<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">links </span><span class="s3">as </span><span class="s1">L</span><span class="s3">, </span><span class="s1">varfuncs </span><span class="s3">as </span><span class="s1">V</span>

<span class="s1">FLOAT_EPS = np.finfo(float).eps</span>


<span class="s3">class </span><span class="s1">Family:</span>
    <span class="s0">&quot;&quot;&quot; 
    The parent class for one-parameter exponential families. 
 
    Parameters 
    ---------- 
    link : a link function instance 
        Link is the linear transformation function. 
        See the individual families for available links. 
    variance : a variance function 
        Measures the variance as a function of the mean probabilities. 
        See the individual families for the default variance function. 
    check_link : bool 
        If True (default), then and exception is raised if the link is invalid 
        for the family. 
        If False, then the link is not checked. 
 
    See Also 
    -------- 
    :ref:`links` : Further details on links. 
    &quot;&quot;&quot;</span>
    <span class="s2"># TODO: change these class attributes, use valid somewhere...</span>
    <span class="s1">valid = [-np.inf</span><span class="s3">, </span><span class="s1">np.inf]</span>
    <span class="s1">links = []</span>

    <span class="s3">def </span><span class="s1">_setlink(self</span><span class="s3">, </span><span class="s1">link):</span>
        <span class="s0">&quot;&quot;&quot; 
        Helper method to set the link for a family. 
 
        Raises a ``ValueError`` exception if the link is not available. Note 
        that  the error message might not be that informative because it tells 
        you that the link should be in the base class for the link function. 
 
        See statsmodels.genmod.generalized_linear_model.GLM for a list of 
        appropriate links for each family but note that not all of these are 
        currently available. 
        &quot;&quot;&quot;</span>
        <span class="s2"># TODO: change the links class attribute in the families to hold</span>
        <span class="s2"># meaningful information instead of a list of links instances such as</span>
        <span class="s2"># [&lt;statsmodels.family.links.Log object at 0x9a4240c&gt;,</span>
        <span class="s2">#  &lt;statsmodels.family.links.Power object at 0x9a423ec&gt;,</span>
        <span class="s2">#  &lt;statsmodels.family.links.Power object at 0x9a4236c&gt;]</span>
        <span class="s2"># for Poisson...</span>
        <span class="s1">self._link = link</span>
        <span class="s3">if </span><span class="s1">self._check_link:</span>
            <span class="s3">if not </span><span class="s1">isinstance(link</span><span class="s3">, </span><span class="s1">L.Link):</span>
                <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;The input should be a valid Link object.&quot;</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">hasattr(self</span><span class="s3">, </span><span class="s4">&quot;links&quot;</span><span class="s1">):</span>
                <span class="s1">validlink = max([isinstance(link</span><span class="s3">, </span><span class="s1">_) </span><span class="s3">for </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">self.links])</span>
                <span class="s3">if not </span><span class="s1">validlink:</span>
                    <span class="s1">msg = </span><span class="s4">&quot;Invalid link for family, should be in %s. (got %s)&quot;</span>
                    <span class="s3">raise </span><span class="s1">ValueError(msg % (repr(self.links)</span><span class="s3">, </span><span class="s1">link))</span>

    <span class="s3">def </span><span class="s1">_getlink(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Helper method to get the link for a family. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self._link</span>

    <span class="s2"># link property for each family is a pointer to link instance</span>
    <span class="s1">link = property(_getlink</span><span class="s3">, </span><span class="s1">_setlink</span><span class="s3">, </span><span class="s1">doc=</span><span class="s4">&quot;Link function for family&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">link</span><span class="s3">, </span><span class="s1">variance</span><span class="s3">, </span><span class="s1">check_link=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s1">self._check_link = check_link</span>
        <span class="s3">if </span><span class="s1">inspect.isclass(link):</span>
            <span class="s1">warnmssg = (</span>
                <span class="s4">&quot;Calling Family(..) with a link class is not allowed. Use an &quot;</span>
                <span class="s4">&quot;instance of a link class instead.&quot;</span>
            <span class="s1">)</span>
            <span class="s3">raise </span><span class="s1">TypeError(warnmssg)</span>

        <span class="s1">self.link = link</span>
        <span class="s1">self.variance = variance</span>

    <span class="s3">def </span><span class="s1">starting_mu(self</span><span class="s3">, </span><span class="s1">y):</span>
        <span class="s0">r&quot;&quot;&quot; 
        Starting value for mu in the IRLS algorithm. 
 
        Parameters 
        ---------- 
        y : ndarray 
            The untransformed response variable. 
 
        Returns 
        ------- 
        mu_0 : ndarray 
            The first guess on the transformed response variable. 
 
        Notes 
        ----- 
        .. math:: 
 
           \mu_0 = (Y + \overline{Y})/2 
 
        Only the Binomial family takes a different initial value. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">(y + y.mean())/</span><span class="s5">2.</span>

    <span class="s3">def </span><span class="s1">weights(self</span><span class="s3">, </span><span class="s1">mu):</span>
        <span class="s0">r&quot;&quot;&quot; 
        Weights for IRLS steps 
 
        Parameters 
        ---------- 
        mu : array_like 
            The transformed mean response variable in the exponential family 
 
        Returns 
        ------- 
        w : ndarray 
            The weights for the IRLS steps 
 
        Notes 
        ----- 
        .. math:: 
 
           w = 1 / (g'(\mu)^2  * Var(\mu)) 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s5">1. </span><span class="s1">/ (self.link.deriv(mu)**</span><span class="s5">2 </span><span class="s1">* self.variance(mu))</span>

    <span class="s3">def </span><span class="s1">deviance(self</span><span class="s3">, </span><span class="s1">endog</span><span class="s3">, </span><span class="s1">mu</span><span class="s3">, </span><span class="s1">var_weights=</span><span class="s5">1.</span><span class="s3">, </span><span class="s1">freq_weights=</span><span class="s5">1.</span><span class="s3">, </span><span class="s1">scale=</span><span class="s5">1.</span><span class="s1">):</span>
        <span class="s0">r&quot;&quot;&quot; 
        The deviance function evaluated at (endog, mu, var_weights, 
        freq_weights, scale) for the distribution. 
 
        Deviance is usually defined as twice the loglikelihood ratio. 
 
        Parameters 
        ---------- 
        endog : array_like 
            The endogenous response variable 
        mu : array_like 
            The inverse of the link function at the linear predicted values. 
        var_weights : array_like 
            1d array of variance (analytic) weights. The default is 1. 
        freq_weights : array_like 
            1d array of frequency weights. The default is 1. 
        scale : float, optional 
            An optional scale argument. The default is 1. 
 
        Returns 
        ------- 
        Deviance : ndarray 
            The value of deviance function defined below. 
 
        Notes 
        ----- 
        Deviance is defined 
 
        .. math:: 
 
           D = 2\sum_i (freq\_weights_i * var\_weights * 
           (llf(endog_i, endog_i) - llf(endog_i, \mu_i))) 
 
        where y is the endogenous variable. The deviance functions are 
        analytically defined for each family. 
 
        Internally, we calculate deviance as: 
 
        .. math:: 
           D = \sum_i freq\_weights_i * var\_weights * resid\_dev_i  / scale 
        &quot;&quot;&quot;</span>
        <span class="s1">resid_dev = self._resid_dev(endog</span><span class="s3">, </span><span class="s1">mu)</span>
        <span class="s3">return </span><span class="s1">np.sum(resid_dev * freq_weights * var_weights / scale)</span>

    <span class="s3">def </span><span class="s1">resid_dev(self</span><span class="s3">, </span><span class="s1">endog</span><span class="s3">, </span><span class="s1">mu</span><span class="s3">, </span><span class="s1">var_weights=</span><span class="s5">1.</span><span class="s3">, </span><span class="s1">scale=</span><span class="s5">1.</span><span class="s1">):</span>
        <span class="s0">r&quot;&quot;&quot; 
        The deviance residuals 
 
        Parameters 
        ---------- 
        endog : array_like 
            The endogenous response variable 
        mu : array_like 
            The inverse of the link function at the linear predicted values. 
        var_weights : array_like 
            1d array of variance (analytic) weights. The default is 1. 
        scale : float, optional 
            An optional scale argument. The default is 1. 
 
        Returns 
        ------- 
        resid_dev : float 
            Deviance residuals as defined below. 
 
        Notes 
        ----- 
        The deviance residuals are defined by the contribution D_i of 
        observation i to the deviance as 
 
        .. math:: 
           resid\_dev_i = sign(y_i-\mu_i) \sqrt{D_i} 
 
        D_i is calculated from the _resid_dev method in each family. 
        Distribution-specific documentation of the calculation is available 
        there. 
        &quot;&quot;&quot;</span>
        <span class="s1">resid_dev = self._resid_dev(endog</span><span class="s3">, </span><span class="s1">mu)</span>
        <span class="s1">resid_dev *= var_weights / scale</span>
        <span class="s3">return </span><span class="s1">np.sign(endog - mu) * np.sqrt(np.clip(resid_dev</span><span class="s3">, </span><span class="s5">0.</span><span class="s3">, </span><span class="s1">np.inf))</span>

    <span class="s3">def </span><span class="s1">fitted(self</span><span class="s3">, </span><span class="s1">lin_pred):</span>
        <span class="s0">r&quot;&quot;&quot; 
        Fitted values based on linear predictors lin_pred. 
 
        Parameters 
        ---------- 
        lin_pred : ndarray 
            Values of the linear predictor of the model. 
            :math:`X \cdot \beta` in a classical linear model. 
 
        Returns 
        ------- 
        mu : ndarray 
            The mean response variables given by the inverse of the link 
            function. 
        &quot;&quot;&quot;</span>
        <span class="s1">fits = self.link.inverse(lin_pred)</span>
        <span class="s3">return </span><span class="s1">fits</span>

    <span class="s3">def </span><span class="s1">predict(self</span><span class="s3">, </span><span class="s1">mu):</span>
        <span class="s0">&quot;&quot;&quot; 
        Linear predictors based on given mu values. 
 
        Parameters 
        ---------- 
        mu : ndarray 
            The mean response variables 
 
        Returns 
        ------- 
        lin_pred : ndarray 
            Linear predictors based on the mean response variables.  The value 
            of the link function at the given mu. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.link(mu)</span>

    <span class="s3">def </span><span class="s1">loglike_obs(self</span><span class="s3">, </span><span class="s1">endog</span><span class="s3">, </span><span class="s1">mu</span><span class="s3">, </span><span class="s1">var_weights=</span><span class="s5">1.</span><span class="s3">, </span><span class="s1">scale=</span><span class="s5">1.</span><span class="s1">):</span>
        <span class="s0">r&quot;&quot;&quot; 
        The log-likelihood function for each observation in terms of the fitted 
        mean response for the distribution. 
 
        Parameters 
        ---------- 
        endog : ndarray 
            Usually the endogenous response variable. 
        mu : ndarray 
            Usually but not always the fitted mean response variable. 
        var_weights : array_like 
            1d array of variance (analytic) weights. The default is 1. 
        scale : float 
            The scale parameter. The default is 1. 
 
        Returns 
        ------- 
        ll_i : float 
            The value of the loglikelihood evaluated at 
            (endog, mu, var_weights, scale) as defined below. 
 
        Notes 
        ----- 
        This is defined for each family. endog and mu are not restricted to 
        ``endog`` and ``mu`` respectively.  For instance, you could call 
        both ``loglike(endog, endog)`` and ``loglike(endog, mu)`` to get the 
        log-likelihood ratio. 
        &quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span>

    <span class="s3">def </span><span class="s1">loglike(self</span><span class="s3">, </span><span class="s1">endog</span><span class="s3">, </span><span class="s1">mu</span><span class="s3">, </span><span class="s1">var_weights=</span><span class="s5">1.</span><span class="s3">, </span><span class="s1">freq_weights=</span><span class="s5">1.</span><span class="s3">, </span><span class="s1">scale=</span><span class="s5">1.</span><span class="s1">):</span>
        <span class="s0">r&quot;&quot;&quot; 
        The log-likelihood function in terms of the fitted mean response. 
 
        Parameters 
        ---------- 
        endog : ndarray 
            Usually the endogenous response variable. 
        mu : ndarray 
            Usually but not always the fitted mean response variable. 
        var_weights : array_like 
            1d array of variance (analytic) weights. The default is 1. 
        freq_weights : array_like 
            1d array of frequency weights. The default is 1. 
        scale : float 
            The scale parameter. The default is 1. 
 
        Returns 
        ------- 
        ll : float 
            The value of the loglikelihood evaluated at 
            (endog, mu, var_weights, freq_weights, scale) as defined below. 
 
        Notes 
        ----- 
        Where :math:`ll_i` is the by-observation log-likelihood: 
 
        .. math:: 
           ll = \sum(ll_i * freq\_weights_i) 
 
        ``ll_i`` is defined for each family. endog and mu are not restricted 
        to ``endog`` and ``mu`` respectively.  For instance, you could call 
        both ``loglike(endog, endog)`` and ``loglike(endog, mu)`` to get the 
        log-likelihood ratio. 
        &quot;&quot;&quot;</span>
        <span class="s1">ll_obs = self.loglike_obs(endog</span><span class="s3">, </span><span class="s1">mu</span><span class="s3">, </span><span class="s1">var_weights</span><span class="s3">, </span><span class="s1">scale)</span>
        <span class="s3">return </span><span class="s1">np.sum(ll_obs * freq_weights)</span>

    <span class="s3">def </span><span class="s1">resid_anscombe(self</span><span class="s3">, </span><span class="s1">endog</span><span class="s3">, </span><span class="s1">mu</span><span class="s3">, </span><span class="s1">var_weights=</span><span class="s5">1.</span><span class="s3">, </span><span class="s1">scale=</span><span class="s5">1.</span><span class="s1">):</span>
        <span class="s0">r&quot;&quot;&quot; 
        The Anscombe residuals 
 
        Parameters 
        ---------- 
        endog : ndarray 
            The endogenous response variable 
        mu : ndarray 
            The inverse of the link function at the linear predicted values. 
        var_weights : array_like 
            1d array of variance (analytic) weights. The default is 1. 
        scale : float, optional 
            An optional argument to divide the residuals by sqrt(scale). 
            The default is 1. 
 
        See Also 
        -------- 
        statsmodels.genmod.families.family.Family : `resid_anscombe` for the 
          individual families for more information 
 
        Notes 
        ----- 
        Anscombe residuals are defined by 
 
        .. math:: 
           resid\_anscombe_i = \frac{A(y)-A(\mu)}{A'(\mu)\sqrt{Var[\mu]}} * 
           \sqrt(var\_weights) 
 
        where :math:`A'(y)=v(y)^{-\frac{1}{3}}` and :math:`v(\mu)` is the 
        variance function :math:`Var[y]=\frac{\phi}{w}v(mu)`. 
        The transformation :math:`A(y)` makes the residuals more normal 
        distributed. 
        &quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span>

    <span class="s3">def </span><span class="s1">_clean(self</span><span class="s3">, </span><span class="s1">x):</span>
        <span class="s0">&quot;&quot;&quot; 
        Helper function to trim the data so that it is in (0,inf) 
 
        Notes 
        ----- 
        The need for this function was discovered through usage and its 
        possible that other families might need a check for validity of the 
        domain. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">np.clip(x</span><span class="s3">, </span><span class="s1">FLOAT_EPS</span><span class="s3">, </span><span class="s1">np.inf)</span>


<span class="s3">class </span><span class="s1">Poisson(Family):</span>
    <span class="s0">&quot;&quot;&quot; 
    Poisson exponential family. 
 
    Parameters 
    ---------- 
    link : a link instance, optional 
        The default link for the Poisson family is the log link. Available 
        links are log, identity, and sqrt. See statsmodels.families.links for 
        more information. 
    check_link : bool 
        If True (default), then and exception is raised if the link is invalid 
        for the family. 
        If False, then the link is not checked. 
 
    Attributes 
    ---------- 
    Poisson.link : a link instance 
        The link function of the Poisson instance. 
    Poisson.variance : varfuncs instance 
        ``variance`` is an instance of 
        statsmodels.genmod.families.varfuncs.mu 
 
    See Also 
    -------- 
    statsmodels.genmod.families.family.Family : Parent class for all links. 
    :ref:`links` : Further details on links. 
    &quot;&quot;&quot;</span>
    <span class="s1">links = [L.Log</span><span class="s3">, </span><span class="s1">L.Identity</span><span class="s3">, </span><span class="s1">L.Sqrt]</span>
    <span class="s1">variance = V.mu</span>
    <span class="s1">valid = [</span><span class="s5">0</span><span class="s3">, </span><span class="s1">np.inf]</span>
    <span class="s1">safe_links = [L.Log</span><span class="s3">, </span><span class="s1">]</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">link=</span><span class="s3">None, </span><span class="s1">check_link=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">link </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">link = L.Log()</span>
        <span class="s1">super(Poisson</span><span class="s3">, </span><span class="s1">self).__init__(</span>
            <span class="s1">link=link</span><span class="s3">,</span>
            <span class="s1">variance=Poisson.variance</span><span class="s3">,</span>
            <span class="s1">check_link=check_link</span>
            <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_resid_dev(self</span><span class="s3">, </span><span class="s1">endog</span><span class="s3">, </span><span class="s1">mu):</span>
        <span class="s0">r&quot;&quot;&quot; 
        Poisson deviance residuals 
 
        Parameters 
        ---------- 
        endog : ndarray 
            The endogenous response variable. 
        mu : ndarray 
            The inverse of the link function at the linear predicted values. 
 
        Returns 
        ------- 
        resid_dev : float 
            Deviance residuals as defined below. 
 
        Notes 
        ----- 
        .. math:: 
 
           resid\_dev_i = 2 * (endog_i * \ln(endog_i / \mu_i) - 
           (endog_i - \mu_i)) 
        &quot;&quot;&quot;</span>
        <span class="s1">endog_mu = self._clean(endog / mu)</span>
        <span class="s1">resid_dev = endog * np.log(endog_mu) - (endog - mu)</span>
        <span class="s3">return </span><span class="s5">2 </span><span class="s1">* resid_dev</span>

    <span class="s3">def </span><span class="s1">loglike_obs(self</span><span class="s3">, </span><span class="s1">endog</span><span class="s3">, </span><span class="s1">mu</span><span class="s3">, </span><span class="s1">var_weights=</span><span class="s5">1.</span><span class="s3">, </span><span class="s1">scale=</span><span class="s5">1.</span><span class="s1">):</span>
        <span class="s0">r&quot;&quot;&quot; 
        The log-likelihood function for each observation in terms of the fitted 
        mean response for the Poisson distribution. 
 
        Parameters 
        ---------- 
        endog : ndarray 
            Usually the endogenous response variable. 
        mu : ndarray 
            Usually but not always the fitted mean response variable. 
        var_weights : array_like 
            1d array of variance (analytic) weights. The default is 1. 
        scale : float 
            The scale parameter. The default is 1. 
 
        Returns 
        ------- 
        ll_i : float 
            The value of the loglikelihood evaluated at 
            (endog, mu, var_weights, scale) as defined below. 
 
        Notes 
        ----- 
        .. math:: 
            ll_i = var\_weights_i / scale * (endog_i * \ln(\mu_i) - \mu_i - 
            \ln \Gamma(endog_i + 1)) 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">var_weights / scale * (endog * np.log(mu) - mu -</span>
                                      <span class="s1">special.gammaln(endog + </span><span class="s5">1</span><span class="s1">))</span>

    <span class="s3">def </span><span class="s1">resid_anscombe(self</span><span class="s3">, </span><span class="s1">endog</span><span class="s3">, </span><span class="s1">mu</span><span class="s3">, </span><span class="s1">var_weights=</span><span class="s5">1.</span><span class="s3">, </span><span class="s1">scale=</span><span class="s5">1.</span><span class="s1">):</span>
        <span class="s0">r&quot;&quot;&quot; 
        The Anscombe residuals 
 
        Parameters 
        ---------- 
        endog : ndarray 
            The endogenous response variable 
        mu : ndarray 
            The inverse of the link function at the linear predicted values. 
        var_weights : array_like 
            1d array of variance (analytic) weights. The default is 1. 
        scale : float, optional 
            An optional argument to divide the residuals by sqrt(scale). 
            The default is 1. 
 
        Returns 
        ------- 
        resid_anscombe : ndarray 
            The Anscombe residuals for the Poisson family defined below 
 
        Notes 
        ----- 
        .. math:: 
 
           resid\_anscombe_i = (3/2) * (endog_i^{2/3} - \mu_i^{2/3}) / 
           \mu_i^{1/6} * \sqrt(var\_weights) 
        &quot;&quot;&quot;</span>
        <span class="s1">resid = ((</span><span class="s5">3 </span><span class="s1">/ </span><span class="s5">2.</span><span class="s1">) * (endog**(</span><span class="s5">2 </span><span class="s1">/ </span><span class="s5">3.</span><span class="s1">) - mu**(</span><span class="s5">2 </span><span class="s1">/ </span><span class="s5">3.</span><span class="s1">)) /</span>
                 <span class="s1">(mu ** (</span><span class="s5">1 </span><span class="s1">/ </span><span class="s5">6.</span><span class="s1">) * scale ** </span><span class="s5">0.5</span><span class="s1">))</span>
        <span class="s1">resid *= np.sqrt(var_weights)</span>
        <span class="s3">return </span><span class="s1">resid</span>

    <span class="s3">def </span><span class="s1">get_distribution(self</span><span class="s3">, </span><span class="s1">mu</span><span class="s3">, </span><span class="s1">scale=</span><span class="s5">1.</span><span class="s3">, </span><span class="s1">var_weights=</span><span class="s5">1.</span><span class="s1">):</span>
        <span class="s0">r&quot;&quot;&quot; 
        Frozen Poisson distribution instance for given parameters 
 
        Parameters 
        ---------- 
        mu : ndarray 
            Usually but not always the fitted mean response variable. 
        scale : float 
            The scale parameter is ignored. 
        var_weights : array_like 
            1d array of variance (analytic) weights. The default is 1. 
            var_weights are ignored for Poisson. 
 
        Returns 
        ------- 
        distribution instance 
 
        &quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">stats.poisson(mu)</span>


<span class="s3">class </span><span class="s1">Gaussian(Family):</span>
    <span class="s0">&quot;&quot;&quot; 
    Gaussian exponential family distribution. 
 
    Parameters 
    ---------- 
    link : a link instance, optional 
        The default link for the Gaussian family is the identity link. 
        Available links are log, identity, and inverse. 
        See statsmodels.genmod.families.links for more information. 
    check_link : bool 
        If True (default), then and exception is raised if the link is invalid 
        for the family. 
        If False, then the link is not checked. 
 
    Attributes 
    ---------- 
    Gaussian.link : a link instance 
        The link function of the Gaussian instance 
    Gaussian.variance : varfunc instance 
        ``variance`` is an instance of 
        statsmodels.genmod.families.varfuncs.constant 
 
    See Also 
    -------- 
    statsmodels.genmod.families.family.Family : Parent class for all links. 
    :ref:`links` : Further details on links. 
    &quot;&quot;&quot;</span>

    <span class="s1">links = [L.Log</span><span class="s3">, </span><span class="s1">L.Identity</span><span class="s3">, </span><span class="s1">L.InversePower]</span>
    <span class="s1">variance = V.constant</span>
    <span class="s1">safe_links = links</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">link=</span><span class="s3">None, </span><span class="s1">check_link=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">link </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">link = L.Identity()</span>
        <span class="s1">super(Gaussian</span><span class="s3">, </span><span class="s1">self).__init__(</span>
            <span class="s1">link=link</span><span class="s3">,</span>
            <span class="s1">variance=Gaussian.variance</span><span class="s3">,</span>
            <span class="s1">check_link=check_link</span>
            <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_resid_dev(self</span><span class="s3">, </span><span class="s1">endog</span><span class="s3">, </span><span class="s1">mu):</span>
        <span class="s0">r&quot;&quot;&quot; 
        Gaussian deviance residuals 
 
        Parameters 
        ---------- 
        endog : ndarray 
            The endogenous response variable. 
        mu : ndarray 
            The inverse of the link function at the linear predicted values. 
 
        Returns 
        ------- 
        resid_dev : float 
            Deviance residuals as defined below. 
 
        Notes 
        ----- 
        .. math:: 
 
           resid\_dev_i = (endog_i - \mu_i) ** 2 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">(endog - mu) ** </span><span class="s5">2</span>

    <span class="s3">def </span><span class="s1">loglike_obs(self</span><span class="s3">, </span><span class="s1">endog</span><span class="s3">, </span><span class="s1">mu</span><span class="s3">, </span><span class="s1">var_weights=</span><span class="s5">1.</span><span class="s3">, </span><span class="s1">scale=</span><span class="s5">1.</span><span class="s1">):</span>
        <span class="s0">r&quot;&quot;&quot; 
        The log-likelihood function for each observation in terms of the fitted 
        mean response for the Gaussian distribution. 
 
        Parameters 
        ---------- 
        endog : ndarray 
            Usually the endogenous response variable. 
        mu : ndarray 
            Usually but not always the fitted mean response variable. 
        var_weights : array_like 
            1d array of variance (analytic) weights. The default is 1. 
        scale : float 
            The scale parameter. The default is 1. 
 
        Returns 
        ------- 
        ll_i : float 
            The value of the loglikelihood evaluated at 
            (endog, mu, var_weights, scale) as defined below. 
 
        Notes 
        ----- 
        If the link is the identity link function then the 
        loglikelihood function is the same as the classical OLS model. 
 
        .. math:: 
 
           llf = -nobs / 2 * (\log(SSR) + (1 + \log(2 \pi / nobs))) 
 
        where 
 
        .. math:: 
 
           SSR = \sum_i (Y_i - g^{-1}(\mu_i))^2 
 
        If the links is not the identity link then the loglikelihood 
        function is defined as 
 
        .. math:: 
 
           ll_i = -1 / 2 \sum_i  * var\_weights * ((Y_i - mu_i)^2 / scale + 
                                                \log(2 * \pi * scale)) 
        &quot;&quot;&quot;</span>
        <span class="s1">ll_obs = -var_weights * (endog - mu) ** </span><span class="s5">2 </span><span class="s1">/ scale</span>
        <span class="s1">ll_obs += -np.log(scale / var_weights) - np.log(</span><span class="s5">2 </span><span class="s1">* np.pi)</span>
        <span class="s1">ll_obs /= </span><span class="s5">2</span>
        <span class="s3">return </span><span class="s1">ll_obs</span>

    <span class="s3">def </span><span class="s1">resid_anscombe(self</span><span class="s3">, </span><span class="s1">endog</span><span class="s3">, </span><span class="s1">mu</span><span class="s3">, </span><span class="s1">var_weights=</span><span class="s5">1.</span><span class="s3">, </span><span class="s1">scale=</span><span class="s5">1.</span><span class="s1">):</span>
        <span class="s0">r&quot;&quot;&quot; 
        The Anscombe residuals 
 
        Parameters 
        ---------- 
        endog : ndarray 
            The endogenous response variable 
        mu : ndarray 
            The inverse of the link function at the linear predicted values. 
        var_weights : array_like 
            1d array of variance (analytic) weights. The default is 1. 
        scale : float, optional 
            An optional argument to divide the residuals by sqrt(scale). 
            The default is 1. 
 
        Returns 
        ------- 
        resid_anscombe : ndarray 
            The Anscombe residuals for the Gaussian family defined below 
 
        Notes 
        ----- 
        For the Gaussian distribution, Anscombe residuals are the same as 
        deviance residuals. 
 
        .. math:: 
 
           resid\_anscombe_i = (Y_i - \mu_i) / \sqrt{scale} * 
           \sqrt(var\_weights) 
        &quot;&quot;&quot;</span>
        <span class="s1">resid = (endog - mu) / scale ** </span><span class="s5">0.5</span>
        <span class="s1">resid *= np.sqrt(var_weights)</span>
        <span class="s3">return </span><span class="s1">resid</span>

    <span class="s3">def </span><span class="s1">get_distribution(self</span><span class="s3">, </span><span class="s1">mu</span><span class="s3">, </span><span class="s1">scale</span><span class="s3">, </span><span class="s1">var_weights=</span><span class="s5">1.</span><span class="s1">):</span>
        <span class="s0">r&quot;&quot;&quot; 
        Frozen Gaussian distribution instance for given parameters 
 
        Parameters 
        ---------- 
        mu : ndarray 
            Usually but not always the fitted mean response variable. 
        scale : float 
            The scale parameter is required argument for get_distribution. 
        var_weights : array_like 
            1d array of variance (analytic) weights. The default is 1. 
 
        Returns 
        ------- 
        distribution instance 
 
        &quot;&quot;&quot;</span>

        <span class="s1">scale_n = scale / var_weights</span>
        <span class="s3">return </span><span class="s1">stats.norm(loc=mu</span><span class="s3">, </span><span class="s1">scale=np.sqrt(scale_n))</span>


<span class="s3">class </span><span class="s1">Gamma(Family):</span>
    <span class="s0">&quot;&quot;&quot; 
    Gamma exponential family distribution. 
 
    Parameters 
    ---------- 
    link : a link instance, optional 
        The default link for the Gamma family is the inverse link. 
        Available links are log, identity, and inverse. 
        See statsmodels.genmod.families.links for more information. 
    check_link : bool 
        If True (default), then and exception is raised if the link is invalid 
        for the family. 
        If False, then the link is not checked. 
 
    Attributes 
    ---------- 
    Gamma.link : a link instance 
        The link function of the Gamma instance 
    Gamma.variance : varfunc instance 
        ``variance`` is an instance of 
        statsmodels.genmod.family.varfuncs.mu_squared 
 
    See Also 
    -------- 
    statsmodels.genmod.families.family.Family : Parent class for all links. 
    :ref:`links` : Further details on links. 
    &quot;&quot;&quot;</span>
    <span class="s1">links = [L.Log</span><span class="s3">, </span><span class="s1">L.Identity</span><span class="s3">, </span><span class="s1">L.InversePower]</span>
    <span class="s1">variance = V.mu_squared</span>
    <span class="s1">safe_links = [L.Log</span><span class="s3">, </span><span class="s1">]</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">link=</span><span class="s3">None, </span><span class="s1">check_link=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">link </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">link = L.InversePower()</span>
        <span class="s1">super(Gamma</span><span class="s3">, </span><span class="s1">self).__init__(</span>
            <span class="s1">link=link</span><span class="s3">,</span>
            <span class="s1">variance=Gamma.variance</span><span class="s3">,</span>
            <span class="s1">check_link=check_link</span>
            <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_resid_dev(self</span><span class="s3">, </span><span class="s1">endog</span><span class="s3">, </span><span class="s1">mu):</span>
        <span class="s0">r&quot;&quot;&quot; 
        Gamma deviance residuals 
 
        Parameters 
        ---------- 
        endog : ndarray 
            The endogenous response variable. 
        mu : ndarray 
            The inverse of the link function at the linear predicted values. 
 
        Returns 
        ------- 
        resid_dev : float 
            Deviance residuals as defined below. 
 
        Notes 
        ----- 
        .. math:: 
 
           resid\_dev_i = 2 * ((endog_i - \mu_i) / \mu_i - 
           \log(endog_i / \mu_i)) 
        &quot;&quot;&quot;</span>
        <span class="s1">endog_mu = self._clean(endog / mu)</span>
        <span class="s1">resid_dev = -np.log(endog_mu) + (endog - mu) / mu</span>
        <span class="s3">return </span><span class="s5">2 </span><span class="s1">* resid_dev</span>

    <span class="s3">def </span><span class="s1">loglike_obs(self</span><span class="s3">, </span><span class="s1">endog</span><span class="s3">, </span><span class="s1">mu</span><span class="s3">, </span><span class="s1">var_weights=</span><span class="s5">1.</span><span class="s3">, </span><span class="s1">scale=</span><span class="s5">1.</span><span class="s1">):</span>
        <span class="s0">r&quot;&quot;&quot; 
        The log-likelihood function for each observation in terms of the fitted 
        mean response for the Gamma distribution. 
 
        Parameters 
        ---------- 
        endog : ndarray 
            Usually the endogenous response variable. 
        mu : ndarray 
            Usually but not always the fitted mean response variable. 
        var_weights : array_like 
            1d array of variance (analytic) weights. The default is 1. 
        scale : float 
            The scale parameter. The default is 1. 
 
        Returns 
        ------- 
        ll_i : float 
            The value of the loglikelihood evaluated at 
            (endog, mu, var_weights, scale) as defined below. 
 
        Notes 
        ----- 
        .. math:: 
 
           ll_i = var\_weights_i / scale * (\ln(var\_weights_i * endog_i / 
           (scale * \mu_i)) - (var\_weights_i * endog_i) / 
           (scale * \mu_i)) - \ln \Gamma(var\_weights_i / scale) - \ln(\mu_i) 
        &quot;&quot;&quot;</span>
        <span class="s1">endog_mu = self._clean(endog / mu)</span>
        <span class="s1">weight_scale = var_weights / scale</span>
        <span class="s1">ll_obs = weight_scale * np.log(weight_scale * endog_mu)</span>
        <span class="s1">ll_obs -= weight_scale * endog_mu</span>
        <span class="s1">ll_obs -= special.gammaln(weight_scale) + np.log(endog)</span>
        <span class="s3">return </span><span class="s1">ll_obs</span>

        <span class="s2"># in Stata scale is set to equal 1 for reporting llf</span>
        <span class="s2"># in R it's the dispersion, though there is a loss of precision vs.</span>
        <span class="s2"># our results due to an assumed difference in implementation</span>

    <span class="s3">def </span><span class="s1">resid_anscombe(self</span><span class="s3">, </span><span class="s1">endog</span><span class="s3">, </span><span class="s1">mu</span><span class="s3">, </span><span class="s1">var_weights=</span><span class="s5">1.</span><span class="s3">, </span><span class="s1">scale=</span><span class="s5">1.</span><span class="s1">):</span>
        <span class="s0">r&quot;&quot;&quot; 
        The Anscombe residuals 
 
        Parameters 
        ---------- 
        endog : ndarray 
            The endogenous response variable 
        mu : ndarray 
            The inverse of the link function at the linear predicted values. 
        var_weights : array_like 
            1d array of variance (analytic) weights. The default is 1. 
        scale : float, optional 
            An optional argument to divide the residuals by sqrt(scale). 
            The default is 1. 
 
        Returns 
        ------- 
        resid_anscombe : ndarray 
            The Anscombe residuals for the Gamma family defined below 
 
        Notes 
        ----- 
        .. math:: 
 
           resid\_anscombe_i = 3 * (endog_i^{1/3} - \mu_i^{1/3}) / \mu_i^{1/3} 
           / \sqrt{scale} * \sqrt(var\_weights) 
        &quot;&quot;&quot;</span>
        <span class="s1">resid = </span><span class="s5">3 </span><span class="s1">* (endog**(</span><span class="s5">1</span><span class="s1">/</span><span class="s5">3.</span><span class="s1">) - mu**(</span><span class="s5">1</span><span class="s1">/</span><span class="s5">3.</span><span class="s1">)) / mu**(</span><span class="s5">1</span><span class="s1">/</span><span class="s5">3.</span><span class="s1">) / scale ** </span><span class="s5">0.5</span>
        <span class="s1">resid *= np.sqrt(var_weights)</span>
        <span class="s3">return </span><span class="s1">resid</span>

    <span class="s3">def </span><span class="s1">get_distribution(self</span><span class="s3">, </span><span class="s1">mu</span><span class="s3">, </span><span class="s1">scale</span><span class="s3">, </span><span class="s1">var_weights=</span><span class="s5">1.</span><span class="s1">):</span>
        <span class="s0">r&quot;&quot;&quot; 
        Frozen Gamma distribution instance for given parameters 
 
        Parameters 
        ---------- 
        mu : ndarray 
            Usually but not always the fitted mean response variable. 
        scale : float 
            The scale parameter is required argument for get_distribution. 
        var_weights : array_like 
            1d array of variance (analytic) weights. The default is 1. 
 
        Returns 
        ------- 
        distribution instance 
 
        &quot;&quot;&quot;</span>
        <span class="s2"># combine var_weights with scale</span>
        <span class="s1">scale_ = scale / var_weights</span>
        <span class="s1">shape = </span><span class="s5">1 </span><span class="s1">/ scale_</span>
        <span class="s1">scale_g = mu * scale_</span>
        <span class="s3">return </span><span class="s1">stats.gamma(shape</span><span class="s3">, </span><span class="s1">scale=scale_g)</span>


<span class="s3">class </span><span class="s1">Binomial(Family):</span>
    <span class="s0">&quot;&quot;&quot; 
    Binomial exponential family distribution. 
 
    Parameters 
    ---------- 
    link : a link instance, optional 
        The default link for the Binomial family is the logit link. 
        Available links are logit, probit, cauchy, log, loglog, and cloglog. 
        See statsmodels.genmod.families.links for more information. 
    check_link : bool 
        If True (default), then and exception is raised if the link is invalid 
        for the family. 
        If False, then the link is not checked. 
 
    Attributes 
    ---------- 
    Binomial.link : a link instance 
        The link function of the Binomial instance 
    Binomial.variance : varfunc instance 
        ``variance`` is an instance of 
        statsmodels.genmod.families.varfuncs.binary 
 
    See Also 
    -------- 
    statsmodels.genmod.families.family.Family : Parent class for all links. 
    :ref:`links` : Further details on links. 
 
    Notes 
    ----- 
    endog for Binomial can be specified in one of three ways: 
    A 1d array of 0 or 1 values, indicating failure or success 
    respectively. 
    A 2d array, with two columns. The first column represents the 
    success count and the second column represents the failure 
    count. 
    A 1d array of proportions, indicating the proportion of 
    successes, with parameter `var_weights` containing the 
    number of trials for each row. 
    &quot;&quot;&quot;</span>

    <span class="s1">links = [L.Logit</span><span class="s3">, </span><span class="s1">L.Probit</span><span class="s3">, </span><span class="s1">L.Cauchy</span><span class="s3">, </span><span class="s1">L.Log</span><span class="s3">, </span><span class="s1">L.LogC</span><span class="s3">, </span><span class="s1">L.CLogLog</span><span class="s3">, </span><span class="s1">L.LogLog</span><span class="s3">,</span>
             <span class="s1">L.Identity]</span>
    <span class="s1">variance = V.binary  </span><span class="s2"># this is not used below in an effort to include n</span>

    <span class="s2"># Other safe links, e.g. cloglog and probit are subclasses</span>
    <span class="s1">safe_links = [L.Logit</span><span class="s3">, </span><span class="s1">L.CDFLink]</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">link=</span><span class="s3">None, </span><span class="s1">check_link=</span><span class="s3">True</span><span class="s1">):  </span><span class="s2"># , n=1.):</span>
        <span class="s3">if </span><span class="s1">link </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">link = L.Logit()</span>
        <span class="s2"># TODO: it *should* work for a constant n&gt;1 actually, if freq_weights</span>
        <span class="s2"># is equal to n</span>
        <span class="s1">self.n = </span><span class="s5">1</span>
        <span class="s2"># overwritten by initialize if needed but always used to initialize</span>
        <span class="s2"># variance since endog is assumed/forced to be (0,1)</span>
        <span class="s1">super(Binomial</span><span class="s3">, </span><span class="s1">self).__init__(</span>
            <span class="s1">link=link</span><span class="s3">,</span>
            <span class="s1">variance=V.Binomial(n=self.n)</span><span class="s3">,</span>
            <span class="s1">check_link=check_link</span>
            <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">starting_mu(self</span><span class="s3">, </span><span class="s1">y):</span>
        <span class="s0">r&quot;&quot;&quot; 
        The starting values for the IRLS algorithm for the Binomial family. 
        A good choice for the binomial family is :math:`\mu_0 = (Y_i + 0.5)/2` 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">(y + </span><span class="s5">.5</span><span class="s1">)/</span><span class="s5">2</span>

    <span class="s3">def </span><span class="s1">initialize(self</span><span class="s3">, </span><span class="s1">endog</span><span class="s3">, </span><span class="s1">freq_weights):</span>
        <span class="s0">''' 
        Initialize the response variable. 
 
        Parameters 
        ---------- 
        endog : ndarray 
            Endogenous response variable 
        freq_weights : ndarray 
            1d array of frequency weights 
 
        Returns 
        ------- 
        If `endog` is binary, returns `endog` 
 
        If `endog` is a 2d array, then the input is assumed to be in the format 
        (successes, failures) and 
        successes/(success + failures) is returned.  And n is set to 
        successes + failures. 
        '''</span>
        <span class="s2"># if not np.all(np.asarray(freq_weights) == 1):</span>
        <span class="s2">#     self.variance = V.Binomial(n=freq_weights)</span>
        <span class="s3">if </span><span class="s1">endog.ndim &gt; </span><span class="s5">1 </span><span class="s3">and </span><span class="s1">endog.shape[</span><span class="s5">1</span><span class="s1">] &gt; </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'endog has more than 2 columns. The Binomial '</span>
                             <span class="s4">'link supports either a single response variable '</span>
                             <span class="s4">'or a paired response variable.'</span><span class="s1">)</span>
        <span class="s3">elif </span><span class="s1">endog.ndim &gt; </span><span class="s5">1 </span><span class="s3">and </span><span class="s1">endog.shape[</span><span class="s5">1</span><span class="s1">] &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">y = endog[:</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]</span>
            <span class="s2"># overwrite self.freq_weights for deviance below</span>
            <span class="s1">self.n = endog.sum(</span><span class="s5">1</span><span class="s1">)</span>
            <span class="s3">return </span><span class="s1">y*</span><span class="s5">1.</span><span class="s1">/self.n</span><span class="s3">, </span><span class="s1">self.n</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">endog</span><span class="s3">, </span><span class="s1">np.ones(endog.shape[</span><span class="s5">0</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">_resid_dev(self</span><span class="s3">, </span><span class="s1">endog</span><span class="s3">, </span><span class="s1">mu):</span>
        <span class="s0">r&quot;&quot;&quot; 
        Binomial deviance residuals 
 
        Parameters 
        ---------- 
        endog : ndarray 
            The endogenous response variable. 
        mu : ndarray 
            The inverse of the link function at the linear predicted values. 
 
        Returns 
        ------- 
        resid_dev : float 
            Deviance residuals as defined below. 
 
        Notes 
        ----- 
        .. math:: 
 
           resid\_dev_i = 2 * n * (endog_i * \ln(endog_i /\mu_i) + 
           (1 - endog_i) * \ln((1 - endog_i) / (1 - \mu_i))) 
        &quot;&quot;&quot;</span>
        <span class="s1">endog_mu = self._clean(endog / (mu + </span><span class="s5">1e-20</span><span class="s1">))</span>
        <span class="s1">n_endog_mu = self._clean((</span><span class="s5">1. </span><span class="s1">- endog) / (</span><span class="s5">1. </span><span class="s1">- mu + </span><span class="s5">1e-20</span><span class="s1">))</span>
        <span class="s1">resid_dev = endog * np.log(endog_mu) + (</span><span class="s5">1 </span><span class="s1">- endog) * np.log(n_endog_mu)</span>
        <span class="s3">return </span><span class="s5">2 </span><span class="s1">* self.n * resid_dev</span>

    <span class="s3">def </span><span class="s1">loglike_obs(self</span><span class="s3">, </span><span class="s1">endog</span><span class="s3">, </span><span class="s1">mu</span><span class="s3">, </span><span class="s1">var_weights=</span><span class="s5">1.</span><span class="s3">, </span><span class="s1">scale=</span><span class="s5">1.</span><span class="s1">):</span>
        <span class="s0">r&quot;&quot;&quot; 
        The log-likelihood function for each observation in terms of the fitted 
        mean response for the Binomial distribution. 
 
        Parameters 
        ---------- 
        endog : ndarray 
            Usually the endogenous response variable. 
        mu : ndarray 
            Usually but not always the fitted mean response variable. 
        var_weights : array_like 
            1d array of variance (analytic) weights. The default is 1. 
        scale : float 
            The scale parameter. The default is 1. 
 
        Returns 
        ------- 
        ll_i : float 
            The value of the loglikelihood evaluated at 
            (endog, mu, var_weights, scale) as defined below. 
 
        Notes 
        ----- 
        If the endogenous variable is binary: 
 
        .. math:: 
 
         ll_i = \sum_i (y_i * \log(\mu_i/(1-\mu_i)) + \log(1-\mu_i)) * 
               var\_weights_i 
 
        If the endogenous variable is binomial: 
 
        .. math:: 
 
           ll_i = \sum_i var\_weights_i * (\ln \Gamma(n+1) - 
                  \ln \Gamma(y_i + 1) - \ln \Gamma(n_i - y_i +1) + y_i * 
                  \log(\mu_i / (n_i - \mu_i)) + n * \log(1 - \mu_i/n_i)) 
 
        where :math:`y_i = Y_i * n_i` with :math:`Y_i` and :math:`n_i` as 
        defined in Binomial initialize.  This simply makes :math:`y_i` the 
        original number of successes. 
        &quot;&quot;&quot;</span>
        <span class="s1">n = self.n     </span><span class="s2"># Number of trials</span>
        <span class="s1">y = endog * n  </span><span class="s2"># Number of successes</span>

        <span class="s2"># note that mu is still in (0,1), i.e. not converted back</span>
        <span class="s3">return </span><span class="s1">(</span>
            <span class="s1">special.gammaln(n + </span><span class="s5">1</span><span class="s1">) - special.gammaln(y + </span><span class="s5">1</span><span class="s1">) -</span>
            <span class="s1">special.gammaln(n - y + </span><span class="s5">1</span><span class="s1">) + y * np.log(mu / (</span><span class="s5">1 </span><span class="s1">- mu + </span><span class="s5">1e-20</span><span class="s1">)) +</span>
            <span class="s1">n * np.log(</span><span class="s5">1 </span><span class="s1">- mu + </span><span class="s5">1e-20</span><span class="s1">)) * var_weights</span>

    <span class="s3">def </span><span class="s1">resid_anscombe(self</span><span class="s3">, </span><span class="s1">endog</span><span class="s3">, </span><span class="s1">mu</span><span class="s3">, </span><span class="s1">var_weights=</span><span class="s5">1.</span><span class="s3">, </span><span class="s1">scale=</span><span class="s5">1.</span><span class="s1">):</span>
        <span class="s0">r''' 
        The Anscombe residuals 
 
        Parameters 
        ---------- 
        endog : ndarray 
            The endogenous response variable 
        mu : ndarray 
            The inverse of the link function at the linear predicted values. 
        var_weights : array_like 
            1d array of variance (analytic) weights. The default is 1. 
        scale : float, optional 
            An optional argument to divide the residuals by sqrt(scale). 
            The default is 1. 
 
        Returns 
        ------- 
        resid_anscombe : ndarray 
            The Anscombe residuals as defined below. 
 
        Notes 
        ----- 
        .. math:: 
 
            n^{2/3}*(cox\_snell(endog)-cox\_snell(mu)) / 
            (mu*(1-mu/n)*scale^3)^{1/6} * \sqrt(var\_weights) 
 
        where cox_snell is defined as 
        cox_snell(x) = betainc(2/3., 2/3., x)*betainc(2/3.,2/3.) 
        where betainc is the incomplete beta function as defined in scipy, 
        which uses a regularized version (with the unregularized version, one 
        would just have :math:`cox_snell(x) = Betainc(2/3., 2/3., x)`). 
 
        The name 'cox_snell' is idiosyncratic and is simply used for 
        convenience following the approach suggested in Cox and Snell (1968). 
        Further note that 
        :math:`cox\_snell(x) = \frac{3}{2}*x^{2/3} * 
        hyp2f1(2/3.,1/3.,5/3.,x)` 
        where hyp2f1 is the hypergeometric 2f1 function.  The Anscombe 
        residuals are sometimes defined in the literature using the 
        hyp2f1 formulation.  Both betainc and hyp2f1 can be found in scipy. 
 
        References 
        ---------- 
        Anscombe, FJ. (1953) &quot;Contribution to the discussion of H. Hotelling's 
            paper.&quot; Journal of the Royal Statistical Society B. 15, 229-30. 
 
        Cox, DR and Snell, EJ. (1968) &quot;A General Definition of Residuals.&quot; 
            Journal of the Royal Statistical Society B. 30, 248-75. 
        '''</span>
        <span class="s1">endog = endog * self.n  </span><span class="s2"># convert back to successes</span>
        <span class="s1">mu = mu * self.n  </span><span class="s2"># convert back to successes</span>

        <span class="s3">def </span><span class="s1">cox_snell(x):</span>
            <span class="s3">return </span><span class="s1">special.betainc(</span><span class="s5">2</span><span class="s1">/</span><span class="s5">3.</span><span class="s3">, </span><span class="s5">2</span><span class="s1">/</span><span class="s5">3.</span><span class="s3">, </span><span class="s1">x) * special.beta(</span><span class="s5">2</span><span class="s1">/</span><span class="s5">3.</span><span class="s3">, </span><span class="s5">2</span><span class="s1">/</span><span class="s5">3.</span><span class="s1">)</span>

        <span class="s1">resid = (self.n ** (</span><span class="s5">2</span><span class="s1">/</span><span class="s5">3.</span><span class="s1">) * (cox_snell(endog * </span><span class="s5">1. </span><span class="s1">/ self.n) -</span>
                                     <span class="s1">cox_snell(mu * </span><span class="s5">1. </span><span class="s1">/ self.n)) /</span>
                 <span class="s1">(mu * (</span><span class="s5">1 </span><span class="s1">- mu * </span><span class="s5">1. </span><span class="s1">/ self.n) * scale ** </span><span class="s5">3</span><span class="s1">) ** (</span><span class="s5">1 </span><span class="s1">/ </span><span class="s5">6.</span><span class="s1">))</span>
        <span class="s1">resid *= np.sqrt(var_weights)</span>
        <span class="s3">return </span><span class="s1">resid</span>

    <span class="s3">def </span><span class="s1">get_distribution(self</span><span class="s3">, </span><span class="s1">mu</span><span class="s3">, </span><span class="s1">scale=</span><span class="s5">1.</span><span class="s3">, </span><span class="s1">var_weights=</span><span class="s5">1.</span><span class="s3">, </span><span class="s1">n_trials=</span><span class="s5">1</span><span class="s1">):</span>
        <span class="s0">r&quot;&quot;&quot; 
        Frozen Binomial distribution instance for given parameters 
 
        Parameters 
        ---------- 
        mu : ndarray 
            Usually but not always the fitted mean response variable. 
        scale : float 
            The scale parameter is ignored. 
        var_weights : array_like 
            1d array of variance (analytic) weights. The default is 1. 
            var_weights are ignored for Poisson. 
        n_trials : int 
            Number of trials for the binomial distribution. The default is 1 
            which corresponds to a Bernoulli random variable. 
 
        Returns 
        ------- 
        distribution instance 
 
        &quot;&quot;&quot;</span>

        <span class="s3">return </span><span class="s1">stats.binom(n=n_trials</span><span class="s3">, </span><span class="s1">p=mu)</span>


<span class="s3">class </span><span class="s1">InverseGaussian(Family):</span>
    <span class="s0">&quot;&quot;&quot; 
    InverseGaussian exponential family. 
 
    Parameters 
    ---------- 
    link : a link instance, optional 
        The default link for the inverse Gaussian family is the 
        inverse squared link. 
        Available links are InverseSquared, Inverse, Log, and Identity. 
        See statsmodels.genmod.families.links for more information. 
    check_link : bool 
        If True (default), then and exception is raised if the link is invalid 
        for the family. 
        If False, then the link is not checked. 
 
    Attributes 
    ---------- 
    InverseGaussian.link : a link instance 
        The link function of the inverse Gaussian instance 
    InverseGaussian.variance : varfunc instance 
        ``variance`` is an instance of 
        statsmodels.genmod.families.varfuncs.mu_cubed 
 
    See Also 
    -------- 
    statsmodels.genmod.families.family.Family : Parent class for all links. 
    :ref:`links` : Further details on links. 
 
    Notes 
    ----- 
    The inverse Gaussian distribution is sometimes referred to in the 
    literature as the Wald distribution. 
    &quot;&quot;&quot;</span>

    <span class="s1">links = [L.InverseSquared</span><span class="s3">, </span><span class="s1">L.InversePower</span><span class="s3">, </span><span class="s1">L.Identity</span><span class="s3">, </span><span class="s1">L.Log]</span>
    <span class="s1">variance = V.mu_cubed</span>
    <span class="s1">safe_links = [L.InverseSquared</span><span class="s3">, </span><span class="s1">L.Log</span><span class="s3">, </span><span class="s1">]</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">link=</span><span class="s3">None, </span><span class="s1">check_link=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">link </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">link = L.InverseSquared()</span>
        <span class="s1">super(InverseGaussian</span><span class="s3">, </span><span class="s1">self).__init__(</span>
            <span class="s1">link=link</span><span class="s3">,</span>
            <span class="s1">variance=InverseGaussian.variance</span><span class="s3">,</span>
            <span class="s1">check_link=check_link</span>
            <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_resid_dev(self</span><span class="s3">, </span><span class="s1">endog</span><span class="s3">, </span><span class="s1">mu):</span>
        <span class="s0">r&quot;&quot;&quot; 
        Inverse Gaussian deviance residuals 
 
        Parameters 
        ---------- 
        endog : ndarray 
            The endogenous response variable. 
        mu : ndarray 
            The inverse of the link function at the linear predicted values. 
 
        Returns 
        ------- 
        resid_dev : float 
            Deviance residuals as defined below. 
 
        Notes 
        ----- 
        .. math:: 
 
           resid\_dev_i = 1 / (endog_i * \mu_i^2) * (endog_i - \mu_i)^2 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s5">1. </span><span class="s1">/ (endog * mu ** </span><span class="s5">2</span><span class="s1">) * (endog - mu) ** </span><span class="s5">2</span>

    <span class="s3">def </span><span class="s1">loglike_obs(self</span><span class="s3">, </span><span class="s1">endog</span><span class="s3">, </span><span class="s1">mu</span><span class="s3">, </span><span class="s1">var_weights=</span><span class="s5">1.</span><span class="s3">, </span><span class="s1">scale=</span><span class="s5">1.</span><span class="s1">):</span>
        <span class="s0">r&quot;&quot;&quot; 
        The log-likelihood function for each observation in terms of the fitted 
        mean response for the Inverse Gaussian distribution. 
 
        Parameters 
        ---------- 
        endog : ndarray 
            Usually the endogenous response variable. 
        mu : ndarray 
            Usually but not always the fitted mean response variable. 
        var_weights : array_like 
            1d array of variance (analytic) weights. The default is 1. 
        scale : float 
            The scale parameter. The default is 1. 
 
        Returns 
        ------- 
        ll_i : float 
            The value of the loglikelihood evaluated at 
            (endog, mu, var_weights, scale) as defined below. 
 
        Notes 
        ----- 
        .. math:: 
 
           ll_i = -1/2 * (var\_weights_i * (endog_i - \mu_i)^2 / 
           (scale * endog_i * \mu_i^2) + \ln(scale * \endog_i^3 / 
           var\_weights_i) - \ln(2 * \pi)) 
        &quot;&quot;&quot;</span>
        <span class="s1">ll_obs = -var_weights * (endog - mu) ** </span><span class="s5">2 </span><span class="s1">/ (scale * endog * mu ** </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">ll_obs += -np.log(scale * endog ** </span><span class="s5">3 </span><span class="s1">/ var_weights) - np.log(</span><span class="s5">2 </span><span class="s1">* np.pi)</span>
        <span class="s1">ll_obs /= </span><span class="s5">2</span>
        <span class="s3">return </span><span class="s1">ll_obs</span>

    <span class="s3">def </span><span class="s1">resid_anscombe(self</span><span class="s3">, </span><span class="s1">endog</span><span class="s3">, </span><span class="s1">mu</span><span class="s3">, </span><span class="s1">var_weights=</span><span class="s5">1.</span><span class="s3">, </span><span class="s1">scale=</span><span class="s5">1.</span><span class="s1">):</span>
        <span class="s0">r&quot;&quot;&quot; 
        The Anscombe residuals 
 
        Parameters 
        ---------- 
        endog : ndarray 
            The endogenous response variable 
        mu : ndarray 
            The inverse of the link function at the linear predicted values. 
        var_weights : array_like 
            1d array of variance (analytic) weights. The default is 1. 
        scale : float, optional 
            An optional argument to divide the residuals by sqrt(scale). 
            The default is 1. 
 
        Returns 
        ------- 
        resid_anscombe : ndarray 
            The Anscombe residuals for the inverse Gaussian distribution  as 
            defined below 
 
        Notes 
        ----- 
        .. math:: 
 
           resid\_anscombe_i = \log(Y_i / \mu_i) / \sqrt{\mu_i * scale} * 
           \sqrt(var\_weights) 
        &quot;&quot;&quot;</span>
        <span class="s1">resid = np.log(endog / mu) / np.sqrt(mu * scale)</span>
        <span class="s1">resid *= np.sqrt(var_weights)</span>
        <span class="s3">return </span><span class="s1">resid</span>

    <span class="s3">def </span><span class="s1">get_distribution(self</span><span class="s3">, </span><span class="s1">mu</span><span class="s3">, </span><span class="s1">scale</span><span class="s3">, </span><span class="s1">var_weights=</span><span class="s5">1.</span><span class="s1">):</span>
        <span class="s0">r&quot;&quot;&quot; 
        Frozen Inverse Gaussian distribution instance for given parameters 
 
        Parameters 
        ---------- 
        mu : ndarray 
            Usually but not always the fitted mean response variable. 
        scale : float 
            The scale parameter is required argument for get_distribution. 
        var_weights : array_like 
            1d array of variance (analytic) weights. The default is 1. 
 
        Returns 
        ------- 
        distribution instance 
 
        &quot;&quot;&quot;</span>
        <span class="s2"># combine var_weights with scale</span>
        <span class="s1">scale_ = scale / var_weights</span>
        <span class="s1">mu_ig = mu * scale_</span>
        <span class="s3">return </span><span class="s1">stats.invgauss(mu_ig</span><span class="s3">, </span><span class="s1">scale=</span><span class="s5">1 </span><span class="s1">/ scale_)</span>


<span class="s3">class </span><span class="s1">NegativeBinomial(Family):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Negative Binomial exponential family (corresponds to NB2). 
 
    Parameters 
    ---------- 
    link : a link instance, optional 
        The default link for the negative binomial family is the log link. 
        Available links are log, cloglog, identity, nbinom and power. 
        See statsmodels.genmod.families.links for more information. 
    alpha : float, optional 
        The ancillary parameter for the negative binomial distribution. 
        For now ``alpha`` is assumed to be nonstochastic.  The default value 
        is 1.  Permissible values are usually assumed to be between .01 and 2. 
    check_link : bool 
        If True (default), then and exception is raised if the link is invalid 
        for the family. 
        If False, then the link is not checked. 
 
    Attributes 
    ---------- 
    NegativeBinomial.link : a link instance 
        The link function of the negative binomial instance 
    NegativeBinomial.variance : varfunc instance 
        ``variance`` is an instance of 
        statsmodels.genmod.families.varfuncs.nbinom 
 
    See Also 
    -------- 
    statsmodels.genmod.families.family.Family : Parent class for all links. 
    :ref:`links` : Further details on links. 
 
    Notes 
    ----- 
    Power link functions are not yet supported. 
 
    Parameterization for :math:`y=0, 1, 2, \ldots` is 
 
    .. math:: 
 
       f(y) = \frac{\Gamma(y+\frac{1}{\alpha})}{y!\Gamma(\frac{1}{\alpha})} 
              \left(\frac{1}{1+\alpha\mu}\right)^{\frac{1}{\alpha}} 
              \left(\frac{\alpha\mu}{1+\alpha\mu}\right)^y 
 
    with :math:`E[Y]=\mu\,` and :math:`Var[Y]=\mu+\alpha\mu^2`. 
    &quot;&quot;&quot;</span>
    <span class="s1">links = [L.Log</span><span class="s3">, </span><span class="s1">L.CLogLog</span><span class="s3">, </span><span class="s1">L.Identity</span><span class="s3">, </span><span class="s1">L.NegativeBinomial</span><span class="s3">, </span><span class="s1">L.Power]</span>
    <span class="s2"># TODO: add the ability to use the power links with an if test</span>
    <span class="s2"># similar to below</span>
    <span class="s1">variance = V.nbinom</span>
    <span class="s1">safe_links = [L.Log</span><span class="s3">, </span><span class="s1">]</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">link=</span><span class="s3">None, </span><span class="s1">alpha=</span><span class="s5">1.</span><span class="s3">, </span><span class="s1">check_link=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s1">self.alpha = </span><span class="s5">1. </span><span class="s1">* alpha  </span><span class="s2"># make it at least float</span>
        <span class="s3">if </span><span class="s1">alpha </span><span class="s3">is </span><span class="s1">self.__init__.__defaults__[</span><span class="s5">1</span><span class="s1">]:  </span><span class="s2"># `is` is intentional</span>
            <span class="s1">warnings.warn(</span><span class="s4">&quot;Negative binomial dispersion parameter alpha not &quot;</span>
                          <span class="s4">f&quot;set. Using default value alpha=</span><span class="s3">{</span><span class="s1">alpha</span><span class="s3">}</span><span class="s4">.&quot;</span><span class="s3">,</span>
                          <span class="s1">ValueWarning)</span>
        <span class="s3">if </span><span class="s1">link </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">link = L.Log()</span>
        <span class="s1">super(NegativeBinomial</span><span class="s3">, </span><span class="s1">self).__init__(</span>
            <span class="s1">link=link</span><span class="s3">,</span>
            <span class="s1">variance=V.NegativeBinomial(alpha=self.alpha)</span><span class="s3">,</span>
            <span class="s1">check_link=check_link</span>
            <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_resid_dev(self</span><span class="s3">, </span><span class="s1">endog</span><span class="s3">, </span><span class="s1">mu):</span>
        <span class="s0">r&quot;&quot;&quot; 
        Negative Binomial deviance residuals 
 
        Parameters 
        ---------- 
        endog : ndarray 
            The endogenous response variable. 
        mu : ndarray 
            The inverse of the link function at the linear predicted values. 
 
        Returns 
        ------- 
        resid_dev : float 
            Deviance residuals as defined below. 
 
        Notes 
        ----- 
        .. math:: 
 
            resid_dev_i = 2 * (endog_i * \ln(endog_i / 
            \mu_i) - (endog_i + 1 / \alpha) * \ln((endog_i + 1 / \alpha) / 
            (\mu_i + 1 / \alpha))) 
        &quot;&quot;&quot;</span>
        <span class="s1">endog_mu = self._clean(endog / mu)</span>
        <span class="s1">endog_alpha = endog + </span><span class="s5">1 </span><span class="s1">/ self.alpha</span>
        <span class="s1">mu_alpha = mu + </span><span class="s5">1 </span><span class="s1">/ self.alpha</span>
        <span class="s1">resid_dev = endog * np.log(endog_mu)</span>
        <span class="s1">resid_dev -= endog_alpha * np.log(endog_alpha / mu_alpha)</span>
        <span class="s3">return </span><span class="s5">2 </span><span class="s1">* resid_dev</span>

    <span class="s3">def </span><span class="s1">loglike_obs(self</span><span class="s3">, </span><span class="s1">endog</span><span class="s3">, </span><span class="s1">mu</span><span class="s3">, </span><span class="s1">var_weights=</span><span class="s5">1.</span><span class="s3">, </span><span class="s1">scale=</span><span class="s5">1.</span><span class="s1">):</span>
        <span class="s0">r&quot;&quot;&quot; 
        The log-likelihood function for each observation in terms of the fitted 
        mean response for the Negative Binomial distribution. 
 
        Parameters 
        ---------- 
        endog : ndarray 
            Usually the endogenous response variable. 
        mu : ndarray 
            Usually but not always the fitted mean response variable. 
        var_weights : array_like 
            1d array of variance (analytic) weights. The default is 1. 
        scale : float 
            The scale parameter. The default is 1. 
 
        Returns 
        ------- 
        ll_i : float 
            The value of the loglikelihood evaluated at 
            (endog, mu, var_weights, scale) as defined below. 
 
        Notes 
        ----- 
        Defined as: 
 
        .. math:: 
 
           llf = \sum_i var\_weights_i / scale * (Y_i * \log{(\alpha * \mu_i / 
                 (1 + \alpha * \mu_i))} - \log{(1 + \alpha * \mu_i)}/ 
                 \alpha + Constant) 
 
        where :math:`Constant` is defined as: 
 
        .. math:: 
 
           Constant = \ln \Gamma{(Y_i + 1/ \alpha )} - \ln \Gamma(Y_i + 1) - 
                      \ln \Gamma{(1/ \alpha )} 
 
        constant = (special.gammaln(endog + 1 / self.alpha) - 
                    special.gammaln(endog+1)-special.gammaln(1/self.alpha)) 
        return (endog * np.log(self.alpha * mu / (1 + self.alpha * mu)) - 
                np.log(1 + self.alpha * mu) / self.alpha + 
                constant) * var_weights / scale 
        &quot;&quot;&quot;</span>
        <span class="s1">ll_obs = endog * np.log(self.alpha * mu)</span>
        <span class="s1">ll_obs -= (endog + </span><span class="s5">1 </span><span class="s1">/ self.alpha) * np.log(</span><span class="s5">1 </span><span class="s1">+ self.alpha * mu)</span>
        <span class="s1">ll_obs += special.gammaln(endog + </span><span class="s5">1 </span><span class="s1">/ self.alpha)</span>
        <span class="s1">ll_obs -= special.gammaln(</span><span class="s5">1 </span><span class="s1">/ self.alpha)</span>
        <span class="s1">ll_obs -= special.gammaln(endog + </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">var_weights / scale * ll_obs</span>

    <span class="s3">def </span><span class="s1">resid_anscombe(self</span><span class="s3">, </span><span class="s1">endog</span><span class="s3">, </span><span class="s1">mu</span><span class="s3">, </span><span class="s1">var_weights=</span><span class="s5">1.</span><span class="s3">, </span><span class="s1">scale=</span><span class="s5">1.</span><span class="s1">):</span>
        <span class="s0">r&quot;&quot;&quot; 
        The Anscombe residuals 
 
        Parameters 
        ---------- 
        endog : ndarray 
            The endogenous response variable 
        mu : ndarray 
            The inverse of the link function at the linear predicted values. 
        var_weights : array_like 
            1d array of variance (analytic) weights. The default is 1. 
        scale : float, optional 
            An optional argument to divide the residuals by sqrt(scale). 
            The default is 1. 
 
        Returns 
        ------- 
        resid_anscombe : ndarray 
            The Anscombe residuals as defined below. 
 
        Notes 
        ----- 
        Anscombe residuals for Negative Binomial are the same as for Binomial 
        upon setting :math:`n=-\frac{1}{\alpha}`. Due to the negative value of 
        :math:`-\alpha*Y` the representation with the hypergeometric function 
        :math:`H2F1(x) =  hyp2f1(2/3.,1/3.,5/3.,x)` is advantageous 
 
        .. math:: 
 
            resid\_anscombe_i = \frac{3}{2} * 
            (Y_i^(2/3)*H2F1(-\alpha*Y_i) - \mu_i^(2/3)*H2F1(-\alpha*\mu_i)) 
            / (\mu_i * (1+\alpha*\mu_i) * scale^3)^(1/6) * \sqrt(var\_weights) 
 
        Note that for the (unregularized) Beta function, one has 
        :math:`Beta(z,a,b) = z^a/a * H2F1(a,1-b,a+1,z)` 
        &quot;&quot;&quot;</span>
        <span class="s3">def </span><span class="s1">hyp2f1(x):</span>
            <span class="s3">return </span><span class="s1">special.hyp2f1(</span><span class="s5">2 </span><span class="s1">/ </span><span class="s5">3.</span><span class="s3">, </span><span class="s5">1 </span><span class="s1">/ </span><span class="s5">3.</span><span class="s3">, </span><span class="s5">5 </span><span class="s1">/ </span><span class="s5">3.</span><span class="s3">, </span><span class="s1">x)</span>

        <span class="s1">resid = (</span><span class="s5">3 </span><span class="s1">/ </span><span class="s5">2. </span><span class="s1">* (endog ** (</span><span class="s5">2 </span><span class="s1">/ </span><span class="s5">3.</span><span class="s1">) * hyp2f1(-self.alpha * endog) -</span>
                           <span class="s1">mu ** (</span><span class="s5">2 </span><span class="s1">/ </span><span class="s5">3.</span><span class="s1">) * hyp2f1(-self.alpha * mu)) /</span>
                 <span class="s1">(mu * (</span><span class="s5">1 </span><span class="s1">+ self.alpha * mu) *</span>
                 <span class="s1">scale ** </span><span class="s5">3</span><span class="s1">) ** (</span><span class="s5">1 </span><span class="s1">/ </span><span class="s5">6.</span><span class="s1">))</span>
        <span class="s1">resid *= np.sqrt(var_weights)</span>
        <span class="s3">return </span><span class="s1">resid</span>

    <span class="s3">def </span><span class="s1">get_distribution(self</span><span class="s3">, </span><span class="s1">mu</span><span class="s3">, </span><span class="s1">scale=</span><span class="s5">1.</span><span class="s3">, </span><span class="s1">var_weights=</span><span class="s5">1.</span><span class="s1">):</span>
        <span class="s0">r&quot;&quot;&quot; 
        Frozen NegativeBinomial distribution instance for given parameters 
 
        Parameters 
        ---------- 
        mu : ndarray 
            Usually but not always the fitted mean response variable. 
        scale : float 
            The scale parameter is ignored. 
        var_weights : array_like 
            1d array of variance (analytic) weights. The default is 1. 
            var_weights are ignored for NegativeBinomial. 
 
        Returns 
        ------- 
        distribution instance 
 
        &quot;&quot;&quot;</span>
        <span class="s1">size = </span><span class="s5">1. </span><span class="s1">/ self.alpha</span>
        <span class="s1">prob = size / (size + mu)</span>
        <span class="s3">return </span><span class="s1">stats.nbinom(size</span><span class="s3">, </span><span class="s1">prob)</span>


<span class="s3">class </span><span class="s1">Tweedie(Family):</span>
    <span class="s0">&quot;&quot;&quot; 
    Tweedie family. 
 
    Parameters 
    ---------- 
    link : a link instance, optional 
        The default link for the Tweedie family is the log link. 
        Available links are log, Power and any aliases of power. 
        See statsmodels.genmod.families.links for more information. 
    var_power : float, optional 
        The variance power. The default is 1. 
    eql : bool 
        If True, the Extended Quasi-Likelihood is used, else the 
        likelihood is used. 
        In both cases, for likelihood computations the var_power 
        must be between 1 and 2. 
    check_link : bool 
        If True (default), then and exception is raised if the link is invalid 
        for the family. 
        If False, then the link is not checked. 
 
    Attributes 
    ---------- 
    Tweedie.link : a link instance 
        The link function of the Tweedie instance 
    Tweedie.variance : varfunc instance 
        ``variance`` is an instance of 
        statsmodels.genmod.families.varfuncs.Power 
    Tweedie.var_power : float 
        The power parameter of the variance function. 
 
    See Also 
    -------- 
    statsmodels.genmod.families.family.Family : Parent class for all links. 
    :ref:`links` : Further details on links. 
 
    Notes 
    ----- 
    Loglikelihood function not implemented because of the complexity of 
    calculating an infinite series of summations. The variance power can be 
    estimated using the ``estimate_tweedie_power`` function that is part of the 
    statsmodels.genmod.generalized_linear_model.GLM class. 
    &quot;&quot;&quot;</span>
    <span class="s1">links = [L.Log</span><span class="s3">, </span><span class="s1">L.Power]</span>
    <span class="s1">variance = V.Power(power=</span><span class="s5">1.5</span><span class="s1">)</span>
    <span class="s1">safe_links = [L.Log</span><span class="s3">, </span><span class="s1">L.Power]</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">link=</span><span class="s3">None, </span><span class="s1">var_power=</span><span class="s5">1.</span><span class="s3">, </span><span class="s1">eql=</span><span class="s3">False, </span><span class="s1">check_link=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s1">self.var_power = var_power</span>
        <span class="s1">self.eql = eql</span>
        <span class="s3">if </span><span class="s1">eql </span><span class="s3">and </span><span class="s1">(var_power &lt; </span><span class="s5">1 </span><span class="s3">or </span><span class="s1">var_power &gt; </span><span class="s5">2</span><span class="s1">):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Tweedie: if EQL=True then var_power must fall &quot;</span>
                             <span class="s4">&quot;between 1 and 2&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">link </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">link = L.Log()</span>
        <span class="s1">super(Tweedie</span><span class="s3">, </span><span class="s1">self).__init__(</span>
            <span class="s1">link=link</span><span class="s3">,</span>
            <span class="s1">variance=V.Power(power=var_power * </span><span class="s5">1.</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">check_link=check_link</span>
            <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_resid_dev(self</span><span class="s3">, </span><span class="s1">endog</span><span class="s3">, </span><span class="s1">mu):</span>
        <span class="s0">r&quot;&quot;&quot; 
        Tweedie deviance residuals 
 
        Parameters 
        ---------- 
        endog : ndarray 
            The endogenous response variable. 
        mu : ndarray 
            The inverse of the link function at the linear predicted values. 
 
        Returns 
        ------- 
        resid_dev : float 
            Deviance residuals as defined below. 
 
        Notes 
        ----- 
        When :math:`p = 1`, 
 
        .. math:: 
 
            dev_i = \mu_i 
 
        when :math:`endog_i = 0` and 
 
        .. math:: 
 
            dev_i = endog_i * \log(endog_i / \mu_i) + (\mu_i - endog_i) 
 
        otherwise. 
 
        When :math:`p = 2`, 
 
        .. math:: 
 
            dev_i =  (endog_i - \mu_i) / \mu_i - \log(endog_i / \mu_i) 
 
        For all other p, 
 
        .. math:: 
 
            dev_i = endog_i^{2 - p} / ((1 - p) * (2 - p)) - 
                    endog_i * \mu_i^{1 - p} / (1 - p) + \mu_i^{2 - p} / 
                    (2 - p) 
 
        The deviance residual is then 
 
        .. math:: 
 
            resid\_dev_i = 2 * dev_i 
        &quot;&quot;&quot;</span>
        <span class="s1">p = self.var_power</span>
        <span class="s3">if </span><span class="s1">p == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">dev = np.where(endog == </span><span class="s5">0</span><span class="s3">,</span>
                           <span class="s1">mu</span><span class="s3">,</span>
                           <span class="s1">endog * np.log(endog / mu) + (mu - endog))</span>
        <span class="s3">elif </span><span class="s1">p == </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">endog1 = self._clean(endog)</span>
            <span class="s1">dev = ((endog - mu) / mu) - np.log(endog1 / mu)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">dev = (endog ** (</span><span class="s5">2 </span><span class="s1">- p) / ((</span><span class="s5">1 </span><span class="s1">- p) * (</span><span class="s5">2 </span><span class="s1">- p)) -</span>
                   <span class="s1">endog * mu ** (</span><span class="s5">1</span><span class="s1">-p) / (</span><span class="s5">1 </span><span class="s1">- p) + mu ** (</span><span class="s5">2 </span><span class="s1">- p) / (</span><span class="s5">2 </span><span class="s1">- p))</span>
        <span class="s3">return </span><span class="s5">2 </span><span class="s1">* dev</span>

    <span class="s3">def </span><span class="s1">loglike_obs(self</span><span class="s3">, </span><span class="s1">endog</span><span class="s3">, </span><span class="s1">mu</span><span class="s3">, </span><span class="s1">var_weights=</span><span class="s5">1.</span><span class="s3">, </span><span class="s1">scale=</span><span class="s5">1.</span><span class="s1">):</span>
        <span class="s0">r&quot;&quot;&quot; 
        The log-likelihood function for each observation in terms of the fitted 
        mean response for the Tweedie distribution. 
 
        Parameters 
        ---------- 
        endog : ndarray 
            Usually the endogenous response variable. 
        mu : ndarray 
            Usually but not always the fitted mean response variable. 
        var_weights : array_like 
            1d array of variance (analytic) weights. The default is 1. 
        scale : float 
            The scale parameter. The default is 1. 
 
        Returns 
        ------- 
        ll_i : float 
            The value of the loglikelihood evaluated at 
            (endog, mu, var_weights, scale) as defined below. 
 
        Notes 
        ----- 
        If eql is True, the Extended Quasi-Likelihood is used.  At present, 
        this method returns NaN if eql is False.  When the actual likelihood 
        is implemented, it will be accessible by setting eql to False. 
 
        References 
        ---------- 
        R Kaas (2005).  Compound Poisson Distributions and GLM's -- Tweedie's 
        Distribution. 
        https://core.ac.uk/download/pdf/6347266.pdf#page=11 
 
        JA Nelder, D Pregibon (1987).  An extended quasi-likelihood function. 
        Biometrika 74:2, pp 221-232.  https://www.jstor.org/stable/2336136 
        &quot;&quot;&quot;</span>
        <span class="s1">p = self.var_power</span>
        <span class="s1">endog = np.atleast_1d(endog)</span>
        <span class="s3">if </span><span class="s1">p == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">Poisson().loglike_obs(</span>
                <span class="s1">endog=endog</span><span class="s3">,</span>
                <span class="s1">mu=mu</span><span class="s3">,</span>
                <span class="s1">var_weights=var_weights</span><span class="s3">,</span>
                <span class="s1">scale=scale</span>
            <span class="s1">)</span>
        <span class="s3">elif </span><span class="s1">p == </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">Gamma().loglike_obs(</span>
                <span class="s1">endog=endog</span><span class="s3">,</span>
                <span class="s1">mu=mu</span><span class="s3">,</span>
                <span class="s1">var_weights=var_weights</span><span class="s3">,</span>
                <span class="s1">scale=scale</span>
            <span class="s1">)</span>

        <span class="s3">if not </span><span class="s1">self.eql:</span>
            <span class="s3">if </span><span class="s1">p &lt; </span><span class="s5">1 </span><span class="s3">or </span><span class="s1">p &gt; </span><span class="s5">2</span><span class="s1">:</span>
                <span class="s2"># We have not yet implemented the actual likelihood</span>
                <span class="s3">return </span><span class="s1">np.nan</span>

            <span class="s2"># scipy compat bessel_wright added in 1.7</span>
            <span class="s3">if </span><span class="s1">SP_LT_17:</span>
                <span class="s2"># old return was nan</span>
                <span class="s3">return </span><span class="s1">np.nan</span>

            <span class="s2"># See: Dunn, Smyth (2004) &quot;Series evaluation of Tweedie</span>
            <span class="s2"># exponential dispersion model densities&quot;</span>
            <span class="s2"># pdf(y, mu, p, phi) = f(y, theta, phi)</span>
            <span class="s2"># = c(y, phi) * exp(1/phi (y theta - kappa(theta)))</span>
            <span class="s2"># kappa = cumulant function</span>
            <span class="s2"># theta = function of expectation mu and power p</span>
            <span class="s2"># alpha = (2-p)/(1-p)</span>
            <span class="s2"># phi = scale</span>
            <span class="s2"># for 1&lt;p&lt;2:</span>
            <span class="s2"># c(y, phi) = 1/y * wright_bessel(a, b, x)</span>
            <span class="s2"># a = -alpha</span>
            <span class="s2"># b = 0</span>
            <span class="s2"># x = (p-1)**alpha/(2-p) / y**alpha / phi**(1-alpha)</span>
            <span class="s1">scale = scale / var_weights</span>
            <span class="s1">theta = mu ** (</span><span class="s5">1 </span><span class="s1">- p) / (</span><span class="s5">1 </span><span class="s1">- p)</span>
            <span class="s1">kappa = mu ** (</span><span class="s5">2 </span><span class="s1">- p) / (</span><span class="s5">2 </span><span class="s1">- p)</span>
            <span class="s1">alpha = (</span><span class="s5">2 </span><span class="s1">- p) / (</span><span class="s5">1 </span><span class="s1">- p)</span>

            <span class="s1">ll_obs = (endog * theta - kappa) / scale</span>
            <span class="s1">idx = endog &gt; </span><span class="s5">0</span>
            <span class="s3">if </span><span class="s1">np.any(idx):</span>
                <span class="s3">if not </span><span class="s1">np.isscalar(endog):</span>
                    <span class="s1">endog = endog[idx]</span>
                <span class="s3">if not </span><span class="s1">np.isscalar(scale):</span>
                    <span class="s1">scale = scale[idx]</span>
                <span class="s1">x = ((p - </span><span class="s5">1</span><span class="s1">) * scale / endog) ** alpha</span>
                <span class="s1">x /= (</span><span class="s5">2 </span><span class="s1">- p) * scale</span>
                <span class="s1">wb = special.wright_bessel(-alpha</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">x)</span>
                <span class="s1">ll_obs[idx] += np.log(</span><span class="s5">1</span><span class="s1">/endog * wb)</span>
            <span class="s3">return </span><span class="s1">ll_obs</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s2"># Equations 4 of Kaas</span>
            <span class="s1">llf = np.log(</span><span class="s5">2 </span><span class="s1">* np.pi * scale) + p * np.log(endog)</span>
            <span class="s1">llf -= np.log(var_weights)</span>
            <span class="s1">llf /= -</span><span class="s5">2</span>
            <span class="s1">u = (endog ** (</span><span class="s5">2 </span><span class="s1">- p)</span>
                 <span class="s1">- (</span><span class="s5">2 </span><span class="s1">- p) * endog * mu ** (</span><span class="s5">1 </span><span class="s1">- p)</span>
                 <span class="s1">+ (</span><span class="s5">1 </span><span class="s1">- p) * mu ** (</span><span class="s5">2 </span><span class="s1">- p))</span>
            <span class="s1">u *= var_weights / (scale * (</span><span class="s5">1 </span><span class="s1">- p) * (</span><span class="s5">2 </span><span class="s1">- p))</span>

        <span class="s3">return </span><span class="s1">llf - u</span>

    <span class="s3">def </span><span class="s1">resid_anscombe(self</span><span class="s3">, </span><span class="s1">endog</span><span class="s3">, </span><span class="s1">mu</span><span class="s3">, </span><span class="s1">var_weights=</span><span class="s5">1.</span><span class="s3">, </span><span class="s1">scale=</span><span class="s5">1.</span><span class="s1">):</span>
        <span class="s0">r&quot;&quot;&quot; 
        The Anscombe residuals 
 
        Parameters 
        ---------- 
        endog : ndarray 
            The endogenous response variable 
        mu : ndarray 
            The inverse of the link function at the linear predicted values. 
        var_weights : array_like 
            1d array of variance (analytic) weights. The default is 1. 
        scale : float, optional 
            An optional argument to divide the residuals by sqrt(scale). 
            The default is 1. 
 
        Returns 
        ------- 
        resid_anscombe : ndarray 
            The Anscombe residuals as defined below. 
 
        Notes 
        ----- 
        When :math:`p = 3`, then 
 
        .. math:: 
 
            resid\_anscombe_i = \log(endog_i / \mu_i) / \sqrt{\mu_i * scale} * 
            \sqrt(var\_weights) 
 
        Otherwise, 
 
        .. math:: 
 
            c = (3 - p) / 3 
 
        .. math:: 
 
            resid\_anscombe_i = (1 / c) * (endog_i^c - \mu_i^c) / \mu_i^{p / 6} 
            / \sqrt{scale} * \sqrt(var\_weights) 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self.var_power == </span><span class="s5">3</span><span class="s1">:</span>
            <span class="s1">resid = np.log(endog / mu) / np.sqrt(mu * scale)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">c = (</span><span class="s5">3. </span><span class="s1">- self.var_power) / </span><span class="s5">3.</span>
            <span class="s1">resid = ((</span><span class="s5">1. </span><span class="s1">/ c) * (endog ** c - mu ** c) /</span>
                     <span class="s1">mu ** (self.var_power / </span><span class="s5">6.</span><span class="s1">)) / scale ** </span><span class="s5">0.5</span>
        <span class="s1">resid *= np.sqrt(var_weights)</span>
        <span class="s3">return </span><span class="s1">resid</span>
</pre>
</body>
</html>