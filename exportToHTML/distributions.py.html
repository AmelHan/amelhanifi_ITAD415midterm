<html>
<head>
<title>distributions.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
distributions.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Plotting functions for visualizing distributions.&quot;&quot;&quot;</span>
<span class="s2">from </span><span class="s1">numbers </span><span class="s2">import </span><span class="s1">Number</span>
<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">partial</span>
<span class="s2">import </span><span class="s1">math</span>
<span class="s2">import </span><span class="s1">textwrap</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pandas </span><span class="s2">as </span><span class="s1">pd</span>
<span class="s2">import </span><span class="s1">matplotlib </span><span class="s2">as </span><span class="s1">mpl</span>
<span class="s2">import </span><span class="s1">matplotlib.pyplot </span><span class="s2">as </span><span class="s1">plt</span>
<span class="s2">import </span><span class="s1">matplotlib.transforms </span><span class="s2">as </span><span class="s1">tx</span>
<span class="s2">from </span><span class="s1">matplotlib.colors </span><span class="s2">import </span><span class="s1">to_rgba</span>
<span class="s2">from </span><span class="s1">matplotlib.collections </span><span class="s2">import </span><span class="s1">LineCollection</span>

<span class="s2">from </span><span class="s1">._base </span><span class="s2">import </span><span class="s1">VectorPlotter</span>

<span class="s3"># We have moved univariate histogram computation over to the new Hist class,</span>
<span class="s3"># but still use the older Histogram for bivariate computation.</span>
<span class="s2">from </span><span class="s1">._statistics </span><span class="s2">import </span><span class="s1">ECDF</span><span class="s2">, </span><span class="s1">Histogram</span><span class="s2">, </span><span class="s1">KDE</span>
<span class="s2">from </span><span class="s1">._stats.counting </span><span class="s2">import </span><span class="s1">Hist</span>

<span class="s2">from </span><span class="s1">.axisgrid </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">FacetGrid</span><span class="s2">,</span>
    <span class="s1">_facet_docs</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">.utils </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">remove_na</span><span class="s2">,</span>
    <span class="s1">_get_transform_functions</span><span class="s2">,</span>
    <span class="s1">_kde_support</span><span class="s2">,</span>
    <span class="s1">_normalize_kwargs</span><span class="s2">,</span>
    <span class="s1">_check_argument</span><span class="s2">,</span>
    <span class="s1">_assign_default_kwargs</span><span class="s2">,</span>
    <span class="s1">_default_color</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">.palettes </span><span class="s2">import </span><span class="s1">color_palette</span>
<span class="s2">from </span><span class="s1">.external </span><span class="s2">import </span><span class="s1">husl</span>
<span class="s2">from </span><span class="s1">.external.kde </span><span class="s2">import </span><span class="s1">gaussian_kde</span>
<span class="s2">from </span><span class="s1">._docstrings </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">DocstringComponents</span><span class="s2">,</span>
    <span class="s1">_core_docs</span><span class="s2">,</span>
<span class="s1">)</span>


<span class="s1">__all__ = [</span><span class="s4">&quot;displot&quot;</span><span class="s2">, </span><span class="s4">&quot;histplot&quot;</span><span class="s2">, </span><span class="s4">&quot;kdeplot&quot;</span><span class="s2">, </span><span class="s4">&quot;ecdfplot&quot;</span><span class="s2">, </span><span class="s4">&quot;rugplot&quot;</span><span class="s2">, </span><span class="s4">&quot;distplot&quot;</span><span class="s1">]</span>

<span class="s3"># ==================================================================================== #</span>
<span class="s3"># Module documentation</span>
<span class="s3"># ==================================================================================== #</span>

<span class="s1">_dist_params = dict(</span>

    <span class="s1">multiple=</span><span class="s4">&quot;&quot;&quot; 
multiple : {{&quot;layer&quot;, &quot;stack&quot;, &quot;fill&quot;}} 
    Method for drawing multiple elements when semantic mapping creates subsets. 
    Only relevant with univariate data. 
    &quot;&quot;&quot;</span><span class="s2">,</span>
    <span class="s1">log_scale=</span><span class="s4">&quot;&quot;&quot; 
log_scale : bool or number, or pair of bools or numbers 
    Set axis scale(s) to log. A single value sets the data axis for any numeric 
    axes in the plot. A pair of values sets each axis independently. 
    Numeric values are interpreted as the desired base (default 10). 
    When `None` or `False`, seaborn defers to the existing Axes scale. 
    &quot;&quot;&quot;</span><span class="s2">,</span>
    <span class="s1">legend=</span><span class="s4">&quot;&quot;&quot; 
legend : bool 
    If False, suppress the legend for semantic variables. 
    &quot;&quot;&quot;</span><span class="s2">,</span>
    <span class="s1">cbar=</span><span class="s4">&quot;&quot;&quot; 
cbar : bool 
    If True, add a colorbar to annotate the color mapping in a bivariate plot. 
    Note: Does not currently support plots with a ``hue`` variable well. 
    &quot;&quot;&quot;</span><span class="s2">,</span>
    <span class="s1">cbar_ax=</span><span class="s4">&quot;&quot;&quot; 
cbar_ax : :class:`matplotlib.axes.Axes` 
    Pre-existing axes for the colorbar. 
    &quot;&quot;&quot;</span><span class="s2">,</span>
    <span class="s1">cbar_kws=</span><span class="s4">&quot;&quot;&quot; 
cbar_kws : dict 
    Additional parameters passed to :meth:`matplotlib.figure.Figure.colorbar`. 
    &quot;&quot;&quot;</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s1">_param_docs = DocstringComponents.from_nested_components(</span>
    <span class="s1">core=_core_docs[</span><span class="s4">&quot;params&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">facets=DocstringComponents(_facet_docs)</span><span class="s2">,</span>
    <span class="s1">dist=DocstringComponents(_dist_params)</span><span class="s2">,</span>
    <span class="s1">kde=DocstringComponents.from_function_params(KDE.__init__)</span><span class="s2">,</span>
    <span class="s1">hist=DocstringComponents.from_function_params(Histogram.__init__)</span><span class="s2">,</span>
    <span class="s1">ecdf=DocstringComponents.from_function_params(ECDF.__init__)</span><span class="s2">,</span>
<span class="s1">)</span>


<span class="s3"># ==================================================================================== #</span>
<span class="s3"># Internal API</span>
<span class="s3"># ==================================================================================== #</span>


<span class="s2">class </span><span class="s1">_DistributionPlotter(VectorPlotter):</span>

    <span class="s1">wide_structure = {</span><span class="s4">&quot;x&quot;</span><span class="s1">: </span><span class="s4">&quot;@values&quot;</span><span class="s2">, </span><span class="s4">&quot;hue&quot;</span><span class="s1">: </span><span class="s4">&quot;@columns&quot;</span><span class="s1">}</span>
    <span class="s1">flat_structure = {</span><span class="s4">&quot;x&quot;</span><span class="s1">: </span><span class="s4">&quot;@values&quot;</span><span class="s1">}</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">data=</span><span class="s2">None,</span>
        <span class="s1">variables={}</span><span class="s2">,</span>
    <span class="s1">):</span>

        <span class="s1">super().__init__(data=data</span><span class="s2">, </span><span class="s1">variables=variables)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">univariate(self):</span>
        <span class="s0">&quot;&quot;&quot;Return True if only x or y are used.&quot;&quot;&quot;</span>
        <span class="s3"># TODO this could go down to core, but putting it here now.</span>
        <span class="s3"># We'd want to be conceptually clear that univariate only applies</span>
        <span class="s3"># to x/y and not to other semantics, which can exist.</span>
        <span class="s3"># We haven't settled on a good conceptual name for x/y.</span>
        <span class="s2">return </span><span class="s1">bool({</span><span class="s4">&quot;x&quot;</span><span class="s2">, </span><span class="s4">&quot;y&quot;</span><span class="s1">} - set(self.variables))</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">data_variable(self):</span>
        <span class="s0">&quot;&quot;&quot;Return the variable with data for univariate plots.&quot;&quot;&quot;</span>
        <span class="s3"># TODO This could also be in core, but it should have a better name.</span>
        <span class="s2">if not </span><span class="s1">self.univariate:</span>
            <span class="s2">raise </span><span class="s1">AttributeError(</span><span class="s4">&quot;This is not a univariate plot&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">{</span><span class="s4">&quot;x&quot;</span><span class="s2">, </span><span class="s4">&quot;y&quot;</span><span class="s1">}.intersection(self.variables).pop()</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">has_xy_data(self):</span>
        <span class="s0">&quot;&quot;&quot;Return True at least one of x or y is defined.&quot;&quot;&quot;</span>
        <span class="s3"># TODO see above points about where this should go</span>
        <span class="s2">return </span><span class="s1">bool({</span><span class="s4">&quot;x&quot;</span><span class="s2">, </span><span class="s4">&quot;y&quot;</span><span class="s1">} &amp; set(self.variables))</span>

    <span class="s2">def </span><span class="s1">_add_legend(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">ax_obj</span><span class="s2">, </span><span class="s1">artist</span><span class="s2">, </span><span class="s1">fill</span><span class="s2">, </span><span class="s1">element</span><span class="s2">, </span><span class="s1">multiple</span><span class="s2">, </span><span class="s1">alpha</span><span class="s2">, </span><span class="s1">artist_kws</span><span class="s2">, </span><span class="s1">legend_kws</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Add artists that reflect semantic mappings and put then in a legend.&quot;&quot;&quot;</span>
        <span class="s3"># TODO note that this doesn't handle numeric mappings like the relational plots</span>
        <span class="s1">handles = []</span>
        <span class="s1">labels = []</span>
        <span class="s2">for </span><span class="s1">level </span><span class="s2">in </span><span class="s1">self._hue_map.levels:</span>
            <span class="s1">color = self._hue_map(level)</span>

            <span class="s1">kws = self._artist_kws(</span>
                <span class="s1">artist_kws</span><span class="s2">, </span><span class="s1">fill</span><span class="s2">, </span><span class="s1">element</span><span class="s2">, </span><span class="s1">multiple</span><span class="s2">, </span><span class="s1">color</span><span class="s2">, </span><span class="s1">alpha</span>
            <span class="s1">)</span>

            <span class="s3"># color gets added to the kws to workaround an issue with barplot's color</span>
            <span class="s3"># cycle integration but it causes problems in this context where we are</span>
            <span class="s3"># setting artist properties directly, so pop it off here</span>
            <span class="s2">if </span><span class="s4">&quot;facecolor&quot; </span><span class="s2">in </span><span class="s1">kws:</span>
                <span class="s1">kws.pop(</span><span class="s4">&quot;color&quot;</span><span class="s2">, None</span><span class="s1">)</span>

            <span class="s1">handles.append(artist(**kws))</span>
            <span class="s1">labels.append(level)</span>

        <span class="s2">if </span><span class="s1">isinstance(ax_obj</span><span class="s2">, </span><span class="s1">mpl.axes.Axes):</span>
            <span class="s1">ax_obj.legend(handles</span><span class="s2">, </span><span class="s1">labels</span><span class="s2">, </span><span class="s1">title=self.variables[</span><span class="s4">&quot;hue&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">**legend_kws)</span>
        <span class="s2">else</span><span class="s1">:  </span><span class="s3"># i.e. a FacetGrid. TODO make this better</span>
            <span class="s1">legend_data = dict(zip(labels</span><span class="s2">, </span><span class="s1">handles))</span>
            <span class="s1">ax_obj.add_legend(</span>
                <span class="s1">legend_data</span><span class="s2">,</span>
                <span class="s1">title=self.variables[</span><span class="s4">&quot;hue&quot;</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">label_order=self.var_levels[</span><span class="s4">&quot;hue&quot;</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">**legend_kws</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_artist_kws(self</span><span class="s2">, </span><span class="s1">kws</span><span class="s2">, </span><span class="s1">fill</span><span class="s2">, </span><span class="s1">element</span><span class="s2">, </span><span class="s1">multiple</span><span class="s2">, </span><span class="s1">color</span><span class="s2">, </span><span class="s1">alpha):</span>
        <span class="s0">&quot;&quot;&quot;Handle differences between artists in filled/unfilled plots.&quot;&quot;&quot;</span>
        <span class="s1">kws = kws.copy()</span>
        <span class="s2">if </span><span class="s1">fill:</span>
            <span class="s1">kws = _normalize_kwargs(kws</span><span class="s2">, </span><span class="s1">mpl.collections.PolyCollection)</span>
            <span class="s1">kws.setdefault(</span><span class="s4">&quot;facecolor&quot;</span><span class="s2">, </span><span class="s1">to_rgba(color</span><span class="s2">, </span><span class="s1">alpha))</span>

            <span class="s2">if </span><span class="s1">element == </span><span class="s4">&quot;bars&quot;</span><span class="s1">:</span>
                <span class="s3"># Make bar() interface with property cycle correctly</span>
                <span class="s3"># https://github.com/matplotlib/matplotlib/issues/19385</span>
                <span class="s1">kws[</span><span class="s4">&quot;color&quot;</span><span class="s1">] = </span><span class="s4">&quot;none&quot;</span>

            <span class="s2">if </span><span class="s1">multiple </span><span class="s2">in </span><span class="s1">[</span><span class="s4">&quot;stack&quot;</span><span class="s2">, </span><span class="s4">&quot;fill&quot;</span><span class="s1">] </span><span class="s2">or </span><span class="s1">element == </span><span class="s4">&quot;bars&quot;</span><span class="s1">:</span>
                <span class="s1">kws.setdefault(</span><span class="s4">&quot;edgecolor&quot;</span><span class="s2">, </span><span class="s1">mpl.rcParams[</span><span class="s4">&quot;patch.edgecolor&quot;</span><span class="s1">])</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">kws.setdefault(</span><span class="s4">&quot;edgecolor&quot;</span><span class="s2">, </span><span class="s1">to_rgba(color</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s2">elif </span><span class="s1">element == </span><span class="s4">&quot;bars&quot;</span><span class="s1">:</span>
            <span class="s1">kws[</span><span class="s4">&quot;facecolor&quot;</span><span class="s1">] = </span><span class="s4">&quot;none&quot;</span>
            <span class="s1">kws[</span><span class="s4">&quot;edgecolor&quot;</span><span class="s1">] = to_rgba(color</span><span class="s2">, </span><span class="s1">alpha)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">kws[</span><span class="s4">&quot;color&quot;</span><span class="s1">] = to_rgba(color</span><span class="s2">, </span><span class="s1">alpha)</span>
        <span class="s2">return </span><span class="s1">kws</span>

    <span class="s2">def </span><span class="s1">_quantile_to_level(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">quantile):</span>
        <span class="s0">&quot;&quot;&quot;Return data levels corresponding to quantile cuts of mass.&quot;&quot;&quot;</span>
        <span class="s1">isoprop = np.asarray(quantile)</span>
        <span class="s1">values = np.ravel(data)</span>
        <span class="s1">sorted_values = np.sort(values)[::-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">normalized_values = np.cumsum(sorted_values) / values.sum()</span>
        <span class="s1">idx = np.searchsorted(normalized_values</span><span class="s2">, </span><span class="s5">1 </span><span class="s1">- isoprop)</span>
        <span class="s1">levels = np.take(sorted_values</span><span class="s2">, </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">mode=</span><span class="s4">&quot;clip&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">levels</span>

    <span class="s2">def </span><span class="s1">_cmap_from_color(self</span><span class="s2">, </span><span class="s1">color):</span>
        <span class="s0">&quot;&quot;&quot;Return a sequential colormap given a color seed.&quot;&quot;&quot;</span>
        <span class="s3"># Like so much else here, this is broadly useful, but keeping it</span>
        <span class="s3"># in this class to signify that I haven't thought overly hard about it...</span>
        <span class="s1">r</span><span class="s2">, </span><span class="s1">g</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">_ = to_rgba(color)</span>
        <span class="s1">h</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">_ = husl.rgb_to_husl(r</span><span class="s2">, </span><span class="s1">g</span><span class="s2">, </span><span class="s1">b)</span>
        <span class="s1">xx = np.linspace(-</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">int(</span><span class="s5">1.15 </span><span class="s1">* </span><span class="s5">256</span><span class="s1">))[:</span><span class="s5">256</span><span class="s1">]</span>
        <span class="s1">ramp = np.zeros((</span><span class="s5">256</span><span class="s2">, </span><span class="s5">3</span><span class="s1">))</span>
        <span class="s1">ramp[:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] = h</span>
        <span class="s1">ramp[:</span><span class="s2">, </span><span class="s5">1</span><span class="s1">] = s * np.cos(xx)</span>
        <span class="s1">ramp[:</span><span class="s2">, </span><span class="s5">2</span><span class="s1">] = np.linspace(</span><span class="s5">35</span><span class="s2">, </span><span class="s5">80</span><span class="s2">, </span><span class="s5">256</span><span class="s1">)</span>
        <span class="s1">colors = np.clip([husl.husl_to_rgb(*hsl) </span><span class="s2">for </span><span class="s1">hsl </span><span class="s2">in </span><span class="s1">ramp]</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">mpl.colors.ListedColormap(colors[::-</span><span class="s5">1</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">_default_discrete(self):</span>
        <span class="s0">&quot;&quot;&quot;Find default values for discrete hist estimation based on variable type.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.univariate:</span>
            <span class="s1">discrete = self.var_types[self.data_variable] == </span><span class="s4">&quot;categorical&quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">discrete_x = self.var_types[</span><span class="s4">&quot;x&quot;</span><span class="s1">] == </span><span class="s4">&quot;categorical&quot;</span>
            <span class="s1">discrete_y = self.var_types[</span><span class="s4">&quot;y&quot;</span><span class="s1">] == </span><span class="s4">&quot;categorical&quot;</span>
            <span class="s1">discrete = discrete_x</span><span class="s2">, </span><span class="s1">discrete_y</span>
        <span class="s2">return </span><span class="s1">discrete</span>

    <span class="s2">def </span><span class="s1">_resolve_multiple(self</span><span class="s2">, </span><span class="s1">curves</span><span class="s2">, </span><span class="s1">multiple):</span>
        <span class="s0">&quot;&quot;&quot;Modify the density data structure to handle multiple densities.&quot;&quot;&quot;</span>

        <span class="s3"># Default baselines have all densities starting at 0</span>
        <span class="s1">baselines = {k: np.zeros_like(v) </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">curves.items()}</span>

        <span class="s3"># TODO we should have some central clearinghouse for checking if any</span>
        <span class="s3"># &quot;grouping&quot; (terminnology?) semantics have been assigned</span>
        <span class="s2">if </span><span class="s4">&quot;hue&quot; </span><span class="s2">not in </span><span class="s1">self.variables:</span>
            <span class="s2">return </span><span class="s1">curves</span><span class="s2">, </span><span class="s1">baselines</span>

        <span class="s2">if </span><span class="s1">multiple </span><span class="s2">in </span><span class="s1">(</span><span class="s4">&quot;stack&quot;</span><span class="s2">, </span><span class="s4">&quot;fill&quot;</span><span class="s1">):</span>

            <span class="s3"># Setting stack or fill means that the curves share a</span>
            <span class="s3"># support grid / set of bin edges, so we can make a dataframe</span>
            <span class="s3"># Reverse the column order to plot from top to bottom</span>
            <span class="s1">curves = pd.DataFrame(curves).iloc[:</span><span class="s2">, </span><span class="s1">::-</span><span class="s5">1</span><span class="s1">]</span>

            <span class="s3"># Find column groups that are nested within col/row variables</span>
            <span class="s1">column_groups = {}</span>
            <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">keyd </span><span class="s2">in </span><span class="s1">enumerate(map(dict</span><span class="s2">, </span><span class="s1">curves.columns)):</span>
                <span class="s1">facet_key = keyd.get(</span><span class="s4">&quot;col&quot;</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">, </span><span class="s1">keyd.get(</span><span class="s4">&quot;row&quot;</span><span class="s2">, None</span><span class="s1">)</span>
                <span class="s1">column_groups.setdefault(facet_key</span><span class="s2">, </span><span class="s1">[])</span>
                <span class="s1">column_groups[facet_key].append(i)</span>

            <span class="s1">baselines = curves.copy()</span>

            <span class="s2">for </span><span class="s1">col_idxs </span><span class="s2">in </span><span class="s1">column_groups.values():</span>
                <span class="s1">cols = curves.columns[col_idxs]</span>

                <span class="s1">norm_constant = curves[cols].sum(axis=</span><span class="s4">&quot;columns&quot;</span><span class="s1">)</span>

                <span class="s3"># Take the cumulative sum to stack</span>
                <span class="s1">curves[cols] = curves[cols].cumsum(axis=</span><span class="s4">&quot;columns&quot;</span><span class="s1">)</span>

                <span class="s3"># Normalize by row sum to fill</span>
                <span class="s2">if </span><span class="s1">multiple == </span><span class="s4">&quot;fill&quot;</span><span class="s1">:</span>
                    <span class="s1">curves[cols] = curves[cols].div(norm_constant</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">&quot;index&quot;</span><span class="s1">)</span>

                <span class="s3"># Define where each segment starts</span>
                <span class="s1">baselines[cols] = curves[cols].shift(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">1</span><span class="s1">).fillna(</span><span class="s5">0</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">multiple == </span><span class="s4">&quot;dodge&quot;</span><span class="s1">:</span>

            <span class="s3"># Account for the unique semantic (non-faceting) levels</span>
            <span class="s3"># This will require rethiniking if we add other semantics!</span>
            <span class="s1">hue_levels = self.var_levels[</span><span class="s4">&quot;hue&quot;</span><span class="s1">]</span>
            <span class="s1">n = len(hue_levels)</span>
            <span class="s1">f_fwd</span><span class="s2">, </span><span class="s1">f_inv = self._get_scale_transforms(self.data_variable)</span>
            <span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">curves:</span>

                <span class="s1">level = dict(key)[</span><span class="s4">&quot;hue&quot;</span><span class="s1">]</span>
                <span class="s1">hist = curves[key].reset_index(name=</span><span class="s4">&quot;heights&quot;</span><span class="s1">)</span>
                <span class="s1">level_idx = hue_levels.index(level)</span>

                <span class="s1">a = f_fwd(hist[</span><span class="s4">&quot;edges&quot;</span><span class="s1">])</span>
                <span class="s1">b = f_fwd(hist[</span><span class="s4">&quot;edges&quot;</span><span class="s1">] + hist[</span><span class="s4">&quot;widths&quot;</span><span class="s1">])</span>
                <span class="s1">w = (b - a) / n</span>
                <span class="s1">new_min = f_inv(a + level_idx * w)</span>
                <span class="s1">new_max = f_inv(a + (level_idx + </span><span class="s5">1</span><span class="s1">) * w)</span>
                <span class="s1">hist[</span><span class="s4">&quot;widths&quot;</span><span class="s1">] = new_max - new_min</span>
                <span class="s1">hist[</span><span class="s4">&quot;edges&quot;</span><span class="s1">] = new_min</span>

                <span class="s1">curves[key] = hist.set_index([</span><span class="s4">&quot;edges&quot;</span><span class="s2">, </span><span class="s4">&quot;widths&quot;</span><span class="s1">])[</span><span class="s4">&quot;heights&quot;</span><span class="s1">]</span>

        <span class="s2">return </span><span class="s1">curves</span><span class="s2">, </span><span class="s1">baselines</span>

    <span class="s3"># -------------------------------------------------------------------------------- #</span>
    <span class="s3"># Computation</span>
    <span class="s3"># -------------------------------------------------------------------------------- #</span>

    <span class="s2">def </span><span class="s1">_compute_univariate_density(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">data_variable</span><span class="s2">,</span>
        <span class="s1">common_norm</span><span class="s2">,</span>
        <span class="s1">common_grid</span><span class="s2">,</span>
        <span class="s1">estimate_kws</span><span class="s2">,</span>
        <span class="s1">warn_singular=</span><span class="s2">True,</span>
    <span class="s1">):</span>

        <span class="s3"># Initialize the estimator object</span>
        <span class="s1">estimator = KDE(**estimate_kws)</span>

        <span class="s2">if </span><span class="s1">set(self.variables) - {</span><span class="s4">&quot;x&quot;</span><span class="s2">, </span><span class="s4">&quot;y&quot;</span><span class="s1">}:</span>
            <span class="s2">if </span><span class="s1">common_grid:</span>
                <span class="s1">all_observations = self.comp_data.dropna()</span>
                <span class="s1">estimator.define_support(all_observations[data_variable])</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">common_norm = </span><span class="s2">False</span>

        <span class="s1">all_data = self.plot_data.dropna()</span>
        <span class="s2">if </span><span class="s1">common_norm </span><span class="s2">and </span><span class="s4">&quot;weights&quot; </span><span class="s2">in </span><span class="s1">all_data:</span>
            <span class="s1">whole_weight = all_data[</span><span class="s4">&quot;weights&quot;</span><span class="s1">].sum()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">whole_weight = len(all_data)</span>

        <span class="s1">densities = {}</span>

        <span class="s2">for </span><span class="s1">sub_vars</span><span class="s2">, </span><span class="s1">sub_data </span><span class="s2">in </span><span class="s1">self.iter_data(</span><span class="s4">&quot;hue&quot;</span><span class="s2">, </span><span class="s1">from_comp_data=</span><span class="s2">True</span><span class="s1">):</span>

            <span class="s3"># Extract the data points from this sub set and remove nulls</span>
            <span class="s1">observations = sub_data[data_variable]</span>

            <span class="s3"># Extract the weights for this subset of observations</span>
            <span class="s2">if </span><span class="s4">&quot;weights&quot; </span><span class="s2">in </span><span class="s1">self.variables:</span>
                <span class="s1">weights = sub_data[</span><span class="s4">&quot;weights&quot;</span><span class="s1">]</span>
                <span class="s1">part_weight = weights.sum()</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">weights = </span><span class="s2">None</span>
                <span class="s1">part_weight = len(sub_data)</span>

            <span class="s3"># Estimate the density of observations at this level</span>
            <span class="s1">variance = np.nan_to_num(observations.var())</span>
            <span class="s1">singular = len(observations) &lt; </span><span class="s5">2 </span><span class="s2">or </span><span class="s1">math.isclose(variance</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">if not </span><span class="s1">singular:</span>
                    <span class="s3"># Convoluted approach needed because numerical failures</span>
                    <span class="s3"># can manifest in a few different ways.</span>
                    <span class="s1">density</span><span class="s2">, </span><span class="s1">support = estimator(observations</span><span class="s2">, </span><span class="s1">weights=weights)</span>
            <span class="s2">except </span><span class="s1">np.linalg.LinAlgError:</span>
                <span class="s1">singular = </span><span class="s2">True</span>

            <span class="s2">if </span><span class="s1">singular:</span>
                <span class="s1">msg = (</span>
                    <span class="s4">&quot;Dataset has 0 variance; skipping density estimate. &quot;</span>
                    <span class="s4">&quot;Pass `warn_singular=False` to disable this warning.&quot;</span>
                <span class="s1">)</span>
                <span class="s2">if </span><span class="s1">warn_singular:</span>
                    <span class="s1">warnings.warn(msg</span><span class="s2">, </span><span class="s1">UserWarning</span><span class="s2">, </span><span class="s1">stacklevel=</span><span class="s5">4</span><span class="s1">)</span>
                <span class="s2">continue</span>

            <span class="s3"># Invert the scaling of the support points</span>
            <span class="s1">_</span><span class="s2">, </span><span class="s1">f_inv = self._get_scale_transforms(self.data_variable)</span>
            <span class="s1">support = f_inv(support)</span>

            <span class="s3"># Apply a scaling factor so that the integral over all subsets is 1</span>
            <span class="s2">if </span><span class="s1">common_norm:</span>
                <span class="s1">density *= part_weight / whole_weight</span>

            <span class="s3"># Store the density for this level</span>
            <span class="s1">key = tuple(sub_vars.items())</span>
            <span class="s1">densities[key] = pd.Series(density</span><span class="s2">, </span><span class="s1">index=support)</span>

        <span class="s2">return </span><span class="s1">densities</span>

    <span class="s3"># -------------------------------------------------------------------------------- #</span>
    <span class="s3"># Plotting</span>
    <span class="s3"># -------------------------------------------------------------------------------- #</span>

    <span class="s2">def </span><span class="s1">plot_univariate_histogram(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">multiple</span><span class="s2">,</span>
        <span class="s1">element</span><span class="s2">,</span>
        <span class="s1">fill</span><span class="s2">,</span>
        <span class="s1">common_norm</span><span class="s2">,</span>
        <span class="s1">common_bins</span><span class="s2">,</span>
        <span class="s1">shrink</span><span class="s2">,</span>
        <span class="s1">kde</span><span class="s2">,</span>
        <span class="s1">kde_kws</span><span class="s2">,</span>
        <span class="s1">color</span><span class="s2">,</span>
        <span class="s1">legend</span><span class="s2">,</span>
        <span class="s1">line_kws</span><span class="s2">,</span>
        <span class="s1">estimate_kws</span><span class="s2">,</span>
        <span class="s1">**plot_kws</span><span class="s2">,</span>
    <span class="s1">):</span>

        <span class="s3"># -- Default keyword dicts</span>
        <span class="s1">kde_kws = {} </span><span class="s2">if </span><span class="s1">kde_kws </span><span class="s2">is None else </span><span class="s1">kde_kws.copy()</span>
        <span class="s1">line_kws = {} </span><span class="s2">if </span><span class="s1">line_kws </span><span class="s2">is None else </span><span class="s1">line_kws.copy()</span>
        <span class="s1">estimate_kws = {} </span><span class="s2">if </span><span class="s1">estimate_kws </span><span class="s2">is None else </span><span class="s1">estimate_kws.copy()</span>

        <span class="s3"># --  Input checking</span>
        <span class="s1">_check_argument(</span><span class="s4">&quot;multiple&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s4">&quot;layer&quot;</span><span class="s2">, </span><span class="s4">&quot;stack&quot;</span><span class="s2">, </span><span class="s4">&quot;fill&quot;</span><span class="s2">, </span><span class="s4">&quot;dodge&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">multiple)</span>
        <span class="s1">_check_argument(</span><span class="s4">&quot;element&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s4">&quot;bars&quot;</span><span class="s2">, </span><span class="s4">&quot;step&quot;</span><span class="s2">, </span><span class="s4">&quot;poly&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">element)</span>

        <span class="s1">auto_bins_with_weights = (</span>
            <span class="s4">&quot;weights&quot; </span><span class="s2">in </span><span class="s1">self.variables</span>
            <span class="s2">and </span><span class="s1">estimate_kws[</span><span class="s4">&quot;bins&quot;</span><span class="s1">] == </span><span class="s4">&quot;auto&quot;</span>
            <span class="s2">and </span><span class="s1">estimate_kws[</span><span class="s4">&quot;binwidth&quot;</span><span class="s1">] </span><span class="s2">is None</span>
            <span class="s2">and not </span><span class="s1">estimate_kws[</span><span class="s4">&quot;discrete&quot;</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">auto_bins_with_weights:</span>
            <span class="s1">msg = (</span>
                <span class="s4">&quot;`bins` cannot be 'auto' when using weights. &quot;</span>
                <span class="s4">&quot;Setting `bins=10`, but you will likely want to adjust.&quot;</span>
            <span class="s1">)</span>
            <span class="s1">warnings.warn(msg</span><span class="s2">, </span><span class="s1">UserWarning)</span>
            <span class="s1">estimate_kws[</span><span class="s4">&quot;bins&quot;</span><span class="s1">] = </span><span class="s5">10</span>

        <span class="s3"># Simplify downstream code if we are not normalizing</span>
        <span class="s2">if </span><span class="s1">estimate_kws[</span><span class="s4">&quot;stat&quot;</span><span class="s1">] == </span><span class="s4">&quot;count&quot;</span><span class="s1">:</span>
            <span class="s1">common_norm = </span><span class="s2">False</span>

        <span class="s1">orient = self.data_variable</span>

        <span class="s3"># Now initialize the Histogram estimator</span>
        <span class="s1">estimator = Hist(**estimate_kws)</span>
        <span class="s1">histograms = {}</span>

        <span class="s3"># Do pre-compute housekeeping related to multiple groups</span>
        <span class="s1">all_data = self.comp_data.dropna()</span>
        <span class="s1">all_weights = all_data.get(</span><span class="s4">&quot;weights&quot;</span><span class="s2">, None</span><span class="s1">)</span>

        <span class="s1">multiple_histograms = set(self.variables) - {</span><span class="s4">&quot;x&quot;</span><span class="s2">, </span><span class="s4">&quot;y&quot;</span><span class="s1">}</span>
        <span class="s2">if </span><span class="s1">multiple_histograms:</span>
            <span class="s2">if </span><span class="s1">common_bins:</span>
                <span class="s1">bin_kws = estimator._define_bin_params(all_data</span><span class="s2">, </span><span class="s1">orient</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">common_norm = </span><span class="s2">False</span>

        <span class="s2">if </span><span class="s1">common_norm </span><span class="s2">and </span><span class="s1">all_weights </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">whole_weight = all_weights.sum()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">whole_weight = len(all_data)</span>

        <span class="s3"># Estimate the smoothed kernel densities, for use later</span>
        <span class="s2">if </span><span class="s1">kde:</span>
            <span class="s3"># TODO alternatively, clip at min/max bins?</span>
            <span class="s1">kde_kws.setdefault(</span><span class="s4">&quot;cut&quot;</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
            <span class="s1">kde_kws[</span><span class="s4">&quot;cumulative&quot;</span><span class="s1">] = estimate_kws[</span><span class="s4">&quot;cumulative&quot;</span><span class="s1">]</span>
            <span class="s1">densities = self._compute_univariate_density(</span>
                <span class="s1">self.data_variable</span><span class="s2">,</span>
                <span class="s1">common_norm</span><span class="s2">,</span>
                <span class="s1">common_bins</span><span class="s2">,</span>
                <span class="s1">kde_kws</span><span class="s2">,</span>
                <span class="s1">warn_singular=</span><span class="s2">False,</span>
            <span class="s1">)</span>

        <span class="s3"># First pass through the data to compute the histograms</span>
        <span class="s2">for </span><span class="s1">sub_vars</span><span class="s2">, </span><span class="s1">sub_data </span><span class="s2">in </span><span class="s1">self.iter_data(</span><span class="s4">&quot;hue&quot;</span><span class="s2">, </span><span class="s1">from_comp_data=</span><span class="s2">True</span><span class="s1">):</span>

            <span class="s3"># Prepare the relevant data</span>
            <span class="s1">key = tuple(sub_vars.items())</span>
            <span class="s1">orient = self.data_variable</span>

            <span class="s2">if </span><span class="s4">&quot;weights&quot; </span><span class="s2">in </span><span class="s1">self.variables:</span>
                <span class="s1">sub_data[</span><span class="s4">&quot;weight&quot;</span><span class="s1">] = sub_data.pop(</span><span class="s4">&quot;weights&quot;</span><span class="s1">)</span>
                <span class="s1">part_weight = sub_data[</span><span class="s4">&quot;weight&quot;</span><span class="s1">].sum()</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">part_weight = len(sub_data)</span>

            <span class="s3"># Do the histogram computation</span>
            <span class="s2">if not </span><span class="s1">(multiple_histograms </span><span class="s2">and </span><span class="s1">common_bins):</span>
                <span class="s1">bin_kws = estimator._define_bin_params(sub_data</span><span class="s2">, </span><span class="s1">orient</span><span class="s2">, None</span><span class="s1">)</span>
            <span class="s1">res = estimator._normalize(estimator._eval(sub_data</span><span class="s2">, </span><span class="s1">orient</span><span class="s2">, </span><span class="s1">bin_kws))</span>
            <span class="s1">heights = res[estimator.stat].to_numpy()</span>
            <span class="s1">widths = res[</span><span class="s4">&quot;space&quot;</span><span class="s1">].to_numpy()</span>
            <span class="s1">edges = res[orient].to_numpy() - widths / </span><span class="s5">2</span>

            <span class="s3"># Rescale the smoothed curve to match the histogram</span>
            <span class="s2">if </span><span class="s1">kde </span><span class="s2">and </span><span class="s1">key </span><span class="s2">in </span><span class="s1">densities:</span>
                <span class="s1">density = densities[key]</span>
                <span class="s2">if </span><span class="s1">estimator.cumulative:</span>
                    <span class="s1">hist_norm = heights.max()</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">hist_norm = (heights * widths).sum()</span>
                <span class="s1">densities[key] *= hist_norm</span>

            <span class="s3"># Convert edges back to original units for plotting</span>
            <span class="s1">ax = self._get_axes(sub_vars)</span>
            <span class="s1">_</span><span class="s2">, </span><span class="s1">inv = _get_transform_functions(ax</span><span class="s2">, </span><span class="s1">self.data_variable)</span>
            <span class="s1">widths = inv(edges + widths) - inv(edges)</span>
            <span class="s1">edges = inv(edges)</span>

            <span class="s3"># Pack the histogram data and metadata together</span>
            <span class="s1">edges = edges + (</span><span class="s5">1 </span><span class="s1">- shrink) / </span><span class="s5">2 </span><span class="s1">* widths</span>
            <span class="s1">widths *= shrink</span>
            <span class="s1">index = pd.MultiIndex.from_arrays([</span>
                <span class="s1">pd.Index(edges</span><span class="s2">, </span><span class="s1">name=</span><span class="s4">&quot;edges&quot;</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">pd.Index(widths</span><span class="s2">, </span><span class="s1">name=</span><span class="s4">&quot;widths&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">])</span>
            <span class="s1">hist = pd.Series(heights</span><span class="s2">, </span><span class="s1">index=index</span><span class="s2">, </span><span class="s1">name=</span><span class="s4">&quot;heights&quot;</span><span class="s1">)</span>

            <span class="s3"># Apply scaling to normalize across groups</span>
            <span class="s2">if </span><span class="s1">common_norm:</span>
                <span class="s1">hist *= part_weight / whole_weight</span>

            <span class="s3"># Store the finalized histogram data for future plotting</span>
            <span class="s1">histograms[key] = hist</span>

        <span class="s3"># Modify the histogram and density data to resolve multiple groups</span>
        <span class="s1">histograms</span><span class="s2">, </span><span class="s1">baselines = self._resolve_multiple(histograms</span><span class="s2">, </span><span class="s1">multiple)</span>
        <span class="s2">if </span><span class="s1">kde:</span>
            <span class="s1">densities</span><span class="s2">, </span><span class="s1">_ = self._resolve_multiple(</span>
                <span class="s1">densities</span><span class="s2">, None if </span><span class="s1">multiple == </span><span class="s4">&quot;dodge&quot; </span><span class="s2">else </span><span class="s1">multiple</span>
            <span class="s1">)</span>

        <span class="s3"># Set autoscaling-related meta</span>
        <span class="s1">sticky_stat = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">) </span><span class="s2">if </span><span class="s1">multiple == </span><span class="s4">&quot;fill&quot; </span><span class="s2">else </span><span class="s1">(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">np.inf)</span>
        <span class="s2">if </span><span class="s1">multiple == </span><span class="s4">&quot;fill&quot;</span><span class="s1">:</span>
            <span class="s3"># Filled plots should not have any margins</span>
            <span class="s1">bin_vals = histograms.index.to_frame()</span>
            <span class="s1">edges = bin_vals[</span><span class="s4">&quot;edges&quot;</span><span class="s1">]</span>
            <span class="s1">widths = bin_vals[</span><span class="s4">&quot;widths&quot;</span><span class="s1">]</span>
            <span class="s1">sticky_data = (</span>
                <span class="s1">edges.min()</span><span class="s2">,</span>
                <span class="s1">edges.max() + widths.loc[edges.idxmax()]</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">sticky_data = []</span>

        <span class="s3"># --- Handle default visual attributes</span>

        <span class="s3"># Note: default linewidth is determined after plotting</span>

        <span class="s3"># Default alpha should depend on other parameters</span>
        <span class="s2">if </span><span class="s1">fill:</span>
            <span class="s3"># Note: will need to account for other grouping semantics if added</span>
            <span class="s2">if </span><span class="s4">&quot;hue&quot; </span><span class="s2">in </span><span class="s1">self.variables </span><span class="s2">and </span><span class="s1">multiple == </span><span class="s4">&quot;layer&quot;</span><span class="s1">:</span>
                <span class="s1">default_alpha = </span><span class="s5">.5 </span><span class="s2">if </span><span class="s1">element == </span><span class="s4">&quot;bars&quot; </span><span class="s2">else </span><span class="s5">.25</span>
            <span class="s2">elif </span><span class="s1">kde:</span>
                <span class="s1">default_alpha = </span><span class="s5">.5</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">default_alpha = </span><span class="s5">.75</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">default_alpha = </span><span class="s5">1</span>
        <span class="s1">alpha = plot_kws.pop(</span><span class="s4">&quot;alpha&quot;</span><span class="s2">, </span><span class="s1">default_alpha)  </span><span class="s3"># TODO make parameter?</span>

        <span class="s1">hist_artists = []</span>

        <span class="s3"># Go back through the dataset and draw the plots</span>
        <span class="s2">for </span><span class="s1">sub_vars</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">self.iter_data(</span><span class="s4">&quot;hue&quot;</span><span class="s2">, </span><span class="s1">reverse=</span><span class="s2">True</span><span class="s1">):</span>

            <span class="s1">key = tuple(sub_vars.items())</span>
            <span class="s1">hist = histograms[key].rename(</span><span class="s4">&quot;heights&quot;</span><span class="s1">).reset_index()</span>
            <span class="s1">bottom = np.asarray(baselines[key])</span>

            <span class="s1">ax = self._get_axes(sub_vars)</span>

            <span class="s3"># Define the matplotlib attributes that depend on semantic mapping</span>
            <span class="s2">if </span><span class="s4">&quot;hue&quot; </span><span class="s2">in </span><span class="s1">self.variables:</span>
                <span class="s1">sub_color = self._hue_map(sub_vars[</span><span class="s4">&quot;hue&quot;</span><span class="s1">])</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">sub_color = color</span>

            <span class="s1">artist_kws = self._artist_kws(</span>
                <span class="s1">plot_kws</span><span class="s2">, </span><span class="s1">fill</span><span class="s2">, </span><span class="s1">element</span><span class="s2">, </span><span class="s1">multiple</span><span class="s2">, </span><span class="s1">sub_color</span><span class="s2">, </span><span class="s1">alpha</span>
            <span class="s1">)</span>

            <span class="s2">if </span><span class="s1">element == </span><span class="s4">&quot;bars&quot;</span><span class="s1">:</span>

                <span class="s3"># Use matplotlib bar plotting</span>

                <span class="s1">plot_func = ax.bar </span><span class="s2">if </span><span class="s1">self.data_variable == </span><span class="s4">&quot;x&quot; </span><span class="s2">else </span><span class="s1">ax.barh</span>
                <span class="s1">artists = plot_func(</span>
                    <span class="s1">hist[</span><span class="s4">&quot;edges&quot;</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s1">hist[</span><span class="s4">&quot;heights&quot;</span><span class="s1">] - bottom</span><span class="s2">,</span>
                    <span class="s1">hist[</span><span class="s4">&quot;widths&quot;</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s1">bottom</span><span class="s2">,</span>
                    <span class="s1">align=</span><span class="s4">&quot;edge&quot;</span><span class="s2">,</span>
                    <span class="s1">**artist_kws</span><span class="s2">,</span>
                <span class="s1">)</span>

                <span class="s2">for </span><span class="s1">bar </span><span class="s2">in </span><span class="s1">artists:</span>
                    <span class="s2">if </span><span class="s1">self.data_variable == </span><span class="s4">&quot;x&quot;</span><span class="s1">:</span>
                        <span class="s1">bar.sticky_edges.x[:] = sticky_data</span>
                        <span class="s1">bar.sticky_edges.y[:] = sticky_stat</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">bar.sticky_edges.x[:] = sticky_stat</span>
                        <span class="s1">bar.sticky_edges.y[:] = sticky_data</span>

                <span class="s1">hist_artists.extend(artists)</span>

            <span class="s2">else</span><span class="s1">:</span>

                <span class="s3"># Use either fill_between or plot to draw hull of histogram</span>
                <span class="s2">if </span><span class="s1">element == </span><span class="s4">&quot;step&quot;</span><span class="s1">:</span>

                    <span class="s1">final = hist.iloc[-</span><span class="s5">1</span><span class="s1">]</span>
                    <span class="s1">x = np.append(hist[</span><span class="s4">&quot;edges&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">final[</span><span class="s4">&quot;edges&quot;</span><span class="s1">] + final[</span><span class="s4">&quot;widths&quot;</span><span class="s1">])</span>
                    <span class="s1">y = np.append(hist[</span><span class="s4">&quot;heights&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">final[</span><span class="s4">&quot;heights&quot;</span><span class="s1">])</span>
                    <span class="s1">b = np.append(bottom</span><span class="s2">, </span><span class="s1">bottom[-</span><span class="s5">1</span><span class="s1">])</span>

                    <span class="s2">if </span><span class="s1">self.data_variable == </span><span class="s4">&quot;x&quot;</span><span class="s1">:</span>
                        <span class="s1">step = </span><span class="s4">&quot;post&quot;</span>
                        <span class="s1">drawstyle = </span><span class="s4">&quot;steps-post&quot;</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">step = </span><span class="s4">&quot;post&quot;  </span><span class="s3"># fillbetweenx handles mapping internally</span>
                        <span class="s1">drawstyle = </span><span class="s4">&quot;steps-pre&quot;</span>

                <span class="s2">elif </span><span class="s1">element == </span><span class="s4">&quot;poly&quot;</span><span class="s1">:</span>

                    <span class="s1">x = hist[</span><span class="s4">&quot;edges&quot;</span><span class="s1">] + hist[</span><span class="s4">&quot;widths&quot;</span><span class="s1">] / </span><span class="s5">2</span>
                    <span class="s1">y = hist[</span><span class="s4">&quot;heights&quot;</span><span class="s1">]</span>
                    <span class="s1">b = bottom</span>

                    <span class="s1">step = </span><span class="s2">None</span>
                    <span class="s1">drawstyle = </span><span class="s2">None</span>

                <span class="s2">if </span><span class="s1">self.data_variable == </span><span class="s4">&quot;x&quot;</span><span class="s1">:</span>
                    <span class="s2">if </span><span class="s1">fill:</span>
                        <span class="s1">artist = ax.fill_between(x</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">step=step</span><span class="s2">, </span><span class="s1">**artist_kws)</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">artist</span><span class="s2">, </span><span class="s1">= ax.plot(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">drawstyle=drawstyle</span><span class="s2">, </span><span class="s1">**artist_kws)</span>
                    <span class="s1">artist.sticky_edges.x[:] = sticky_data</span>
                    <span class="s1">artist.sticky_edges.y[:] = sticky_stat</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">if </span><span class="s1">fill:</span>
                        <span class="s1">artist = ax.fill_betweenx(x</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">step=step</span><span class="s2">, </span><span class="s1">**artist_kws)</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">artist</span><span class="s2">, </span><span class="s1">= ax.plot(y</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">drawstyle=drawstyle</span><span class="s2">, </span><span class="s1">**artist_kws)</span>
                    <span class="s1">artist.sticky_edges.x[:] = sticky_stat</span>
                    <span class="s1">artist.sticky_edges.y[:] = sticky_data</span>

                <span class="s1">hist_artists.append(artist)</span>

            <span class="s2">if </span><span class="s1">kde:</span>

                <span class="s3"># Add in the density curves</span>

                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s1">density = densities[key]</span>
                <span class="s2">except </span><span class="s1">KeyError:</span>
                    <span class="s2">continue</span>
                <span class="s1">support = density.index</span>

                <span class="s2">if </span><span class="s4">&quot;x&quot; </span><span class="s2">in </span><span class="s1">self.variables:</span>
                    <span class="s1">line_args = support</span><span class="s2">, </span><span class="s1">density</span>
                    <span class="s1">sticky_x</span><span class="s2">, </span><span class="s1">sticky_y = </span><span class="s2">None, </span><span class="s1">(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">np.inf)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">line_args = density</span><span class="s2">, </span><span class="s1">support</span>
                    <span class="s1">sticky_x</span><span class="s2">, </span><span class="s1">sticky_y = (</span><span class="s5">0</span><span class="s2">, </span><span class="s1">np.inf)</span><span class="s2">, None</span>

                <span class="s1">line_kws[</span><span class="s4">&quot;color&quot;</span><span class="s1">] = to_rgba(sub_color</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
                <span class="s1">line</span><span class="s2">, </span><span class="s1">= ax.plot(</span>
                    <span class="s1">*line_args</span><span class="s2">, </span><span class="s1">**line_kws</span><span class="s2">,</span>
                <span class="s1">)</span>

                <span class="s2">if </span><span class="s1">sticky_x </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">line.sticky_edges.x[:] = sticky_x</span>
                <span class="s2">if </span><span class="s1">sticky_y </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">line.sticky_edges.y[:] = sticky_y</span>

        <span class="s2">if </span><span class="s1">element == </span><span class="s4">&quot;bars&quot; </span><span class="s2">and </span><span class="s4">&quot;linewidth&quot; </span><span class="s2">not in </span><span class="s1">plot_kws:</span>

            <span class="s3"># Now we handle linewidth, which depends on the scaling of the plot</span>

            <span class="s3"># We will base everything on the minimum bin width</span>
            <span class="s1">hist_metadata = pd.concat([</span>
                <span class="s3"># Use .items for generality over dict or df</span>
                <span class="s1">h.index.to_frame() </span><span class="s2">for </span><span class="s1">_</span><span class="s2">, </span><span class="s1">h </span><span class="s2">in </span><span class="s1">histograms.items()</span>
            <span class="s1">]).reset_index(drop=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s1">thin_bar_idx = hist_metadata[</span><span class="s4">&quot;widths&quot;</span><span class="s1">].idxmin()</span>
            <span class="s1">binwidth = hist_metadata.loc[thin_bar_idx</span><span class="s2">, </span><span class="s4">&quot;widths&quot;</span><span class="s1">]</span>
            <span class="s1">left_edge = hist_metadata.loc[thin_bar_idx</span><span class="s2">, </span><span class="s4">&quot;edges&quot;</span><span class="s1">]</span>

            <span class="s3"># Set initial value</span>
            <span class="s1">default_linewidth = math.inf</span>

            <span class="s3"># Loop through subsets based only on facet variables</span>
            <span class="s2">for </span><span class="s1">sub_vars</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">self.iter_data():</span>

                <span class="s1">ax = self._get_axes(sub_vars)</span>

                <span class="s3"># Needed in some cases to get valid transforms.</span>
                <span class="s3"># Innocuous in other cases?</span>
                <span class="s1">ax.autoscale_view()</span>

                <span class="s3"># Convert binwidth from data coordinates to pixels</span>
                <span class="s1">pts_x</span><span class="s2">, </span><span class="s1">pts_y = </span><span class="s5">72 </span><span class="s1">/ ax.figure.dpi * abs(</span>
                    <span class="s1">ax.transData.transform([left_edge + binwidth] * </span><span class="s5">2</span><span class="s1">)</span>
                    <span class="s1">- ax.transData.transform([left_edge] * </span><span class="s5">2</span><span class="s1">)</span>
                <span class="s1">)</span>
                <span class="s2">if </span><span class="s1">self.data_variable == </span><span class="s4">&quot;x&quot;</span><span class="s1">:</span>
                    <span class="s1">binwidth_points = pts_x</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">binwidth_points = pts_y</span>

                <span class="s3"># The relative size of the lines depends on the appearance</span>
                <span class="s3"># This is a provisional value and may need more tweaking</span>
                <span class="s1">default_linewidth = min(</span><span class="s5">.1 </span><span class="s1">* binwidth_points</span><span class="s2">, </span><span class="s1">default_linewidth)</span>

            <span class="s3"># Set the attributes</span>
            <span class="s2">for </span><span class="s1">bar </span><span class="s2">in </span><span class="s1">hist_artists:</span>

                <span class="s3"># Don't let the lines get too thick</span>
                <span class="s1">max_linewidth = bar.get_linewidth()</span>
                <span class="s2">if not </span><span class="s1">fill:</span>
                    <span class="s1">max_linewidth *= </span><span class="s5">1.5</span>

                <span class="s1">linewidth = min(default_linewidth</span><span class="s2">, </span><span class="s1">max_linewidth)</span>

                <span class="s3"># If not filling, don't let lines disappear</span>
                <span class="s2">if not </span><span class="s1">fill:</span>
                    <span class="s1">min_linewidth = </span><span class="s5">.5</span>
                    <span class="s1">linewidth = max(linewidth</span><span class="s2">, </span><span class="s1">min_linewidth)</span>

                <span class="s1">bar.set_linewidth(linewidth)</span>

        <span class="s3"># --- Finalize the plot ----</span>

        <span class="s3"># Axis labels</span>
        <span class="s1">ax = self.ax </span><span class="s2">if </span><span class="s1">self.ax </span><span class="s2">is not None else </span><span class="s1">self.facets.axes.flat[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">default_x = default_y = </span><span class="s4">&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.data_variable == </span><span class="s4">&quot;x&quot;</span><span class="s1">:</span>
            <span class="s1">default_y = estimator.stat.capitalize()</span>
        <span class="s2">if </span><span class="s1">self.data_variable == </span><span class="s4">&quot;y&quot;</span><span class="s1">:</span>
            <span class="s1">default_x = estimator.stat.capitalize()</span>
        <span class="s1">self._add_axis_labels(ax</span><span class="s2">, </span><span class="s1">default_x</span><span class="s2">, </span><span class="s1">default_y)</span>

        <span class="s3"># Legend for semantic variables</span>
        <span class="s2">if </span><span class="s4">&quot;hue&quot; </span><span class="s2">in </span><span class="s1">self.variables </span><span class="s2">and </span><span class="s1">legend:</span>

            <span class="s2">if </span><span class="s1">fill </span><span class="s2">or </span><span class="s1">element == </span><span class="s4">&quot;bars&quot;</span><span class="s1">:</span>
                <span class="s1">artist = partial(mpl.patches.Patch)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">artist = partial(mpl.lines.Line2D</span><span class="s2">, </span><span class="s1">[]</span><span class="s2">, </span><span class="s1">[])</span>

            <span class="s1">ax_obj = self.ax </span><span class="s2">if </span><span class="s1">self.ax </span><span class="s2">is not None else </span><span class="s1">self.facets</span>
            <span class="s1">self._add_legend(</span>
                <span class="s1">ax_obj</span><span class="s2">, </span><span class="s1">artist</span><span class="s2">, </span><span class="s1">fill</span><span class="s2">, </span><span class="s1">element</span><span class="s2">, </span><span class="s1">multiple</span><span class="s2">, </span><span class="s1">alpha</span><span class="s2">, </span><span class="s1">plot_kws</span><span class="s2">, </span><span class="s1">{}</span><span class="s2">,</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">plot_bivariate_histogram(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">common_bins</span><span class="s2">, </span><span class="s1">common_norm</span><span class="s2">,</span>
        <span class="s1">thresh</span><span class="s2">, </span><span class="s1">pthresh</span><span class="s2">, </span><span class="s1">pmax</span><span class="s2">,</span>
        <span class="s1">color</span><span class="s2">, </span><span class="s1">legend</span><span class="s2">,</span>
        <span class="s1">cbar</span><span class="s2">, </span><span class="s1">cbar_ax</span><span class="s2">, </span><span class="s1">cbar_kws</span><span class="s2">,</span>
        <span class="s1">estimate_kws</span><span class="s2">,</span>
        <span class="s1">**plot_kws</span><span class="s2">,</span>
    <span class="s1">):</span>

        <span class="s3"># Default keyword dicts</span>
        <span class="s1">cbar_kws = {} </span><span class="s2">if </span><span class="s1">cbar_kws </span><span class="s2">is None else </span><span class="s1">cbar_kws.copy()</span>

        <span class="s3"># Now initialize the Histogram estimator</span>
        <span class="s1">estimator = Histogram(**estimate_kws)</span>

        <span class="s3"># Do pre-compute housekeeping related to multiple groups</span>
        <span class="s2">if </span><span class="s1">set(self.variables) - {</span><span class="s4">&quot;x&quot;</span><span class="s2">, </span><span class="s4">&quot;y&quot;</span><span class="s1">}:</span>
            <span class="s1">all_data = self.comp_data.dropna()</span>
            <span class="s2">if </span><span class="s1">common_bins:</span>
                <span class="s1">estimator.define_bin_params(</span>
                    <span class="s1">all_data[</span><span class="s4">&quot;x&quot;</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s1">all_data[</span><span class="s4">&quot;y&quot;</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s1">all_data.get(</span><span class="s4">&quot;weights&quot;</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">common_norm = </span><span class="s2">False</span>

        <span class="s3"># -- Determine colormap threshold and norm based on the full data</span>

        <span class="s1">full_heights = []</span>
        <span class="s2">for </span><span class="s1">_</span><span class="s2">, </span><span class="s1">sub_data </span><span class="s2">in </span><span class="s1">self.iter_data(from_comp_data=</span><span class="s2">True</span><span class="s1">):</span>
            <span class="s1">sub_heights</span><span class="s2">, </span><span class="s1">_ = estimator(</span>
                <span class="s1">sub_data[</span><span class="s4">&quot;x&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">sub_data[</span><span class="s4">&quot;y&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">sub_data.get(</span><span class="s4">&quot;weights&quot;</span><span class="s2">, None</span><span class="s1">)</span>
            <span class="s1">)</span>
            <span class="s1">full_heights.append(sub_heights)</span>

        <span class="s1">common_color_norm = </span><span class="s2">not </span><span class="s1">set(self.variables) - {</span><span class="s4">&quot;x&quot;</span><span class="s2">, </span><span class="s4">&quot;y&quot;</span><span class="s1">} </span><span class="s2">or </span><span class="s1">common_norm</span>

        <span class="s2">if </span><span class="s1">pthresh </span><span class="s2">is not None and </span><span class="s1">common_color_norm:</span>
            <span class="s1">thresh = self._quantile_to_level(full_heights</span><span class="s2">, </span><span class="s1">pthresh)</span>

        <span class="s1">plot_kws.setdefault(</span><span class="s4">&quot;vmin&quot;</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">common_color_norm:</span>
            <span class="s2">if </span><span class="s1">pmax </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">vmax = self._quantile_to_level(full_heights</span><span class="s2">, </span><span class="s1">pmax)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">vmax = plot_kws.pop(</span><span class="s4">&quot;vmax&quot;</span><span class="s2">, </span><span class="s1">max(map(np.max</span><span class="s2">, </span><span class="s1">full_heights)))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">vmax = </span><span class="s2">None</span>

        <span class="s3"># Get a default color</span>
        <span class="s3"># (We won't follow the color cycle here, as multiple plots are unlikely)</span>
        <span class="s2">if </span><span class="s1">color </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">color = </span><span class="s4">&quot;C0&quot;</span>

        <span class="s3"># --- Loop over data (subsets) and draw the histograms</span>
        <span class="s2">for </span><span class="s1">sub_vars</span><span class="s2">, </span><span class="s1">sub_data </span><span class="s2">in </span><span class="s1">self.iter_data(</span><span class="s4">&quot;hue&quot;</span><span class="s2">, </span><span class="s1">from_comp_data=</span><span class="s2">True</span><span class="s1">):</span>

            <span class="s2">if </span><span class="s1">sub_data.empty:</span>
                <span class="s2">continue</span>

            <span class="s3"># Do the histogram computation</span>
            <span class="s1">heights</span><span class="s2">, </span><span class="s1">(x_edges</span><span class="s2">, </span><span class="s1">y_edges) = estimator(</span>
                <span class="s1">sub_data[</span><span class="s4">&quot;x&quot;</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">sub_data[</span><span class="s4">&quot;y&quot;</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">weights=sub_data.get(</span><span class="s4">&quot;weights&quot;</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">)</span>

            <span class="s3"># Get the axes for this plot</span>
            <span class="s1">ax = self._get_axes(sub_vars)</span>

            <span class="s3"># Invert the scale for the edges</span>
            <span class="s1">_</span><span class="s2">, </span><span class="s1">inv_x = _get_transform_functions(ax</span><span class="s2">, </span><span class="s4">&quot;x&quot;</span><span class="s1">)</span>
            <span class="s1">_</span><span class="s2">, </span><span class="s1">inv_y = _get_transform_functions(ax</span><span class="s2">, </span><span class="s4">&quot;y&quot;</span><span class="s1">)</span>
            <span class="s1">x_edges = inv_x(x_edges)</span>
            <span class="s1">y_edges = inv_y(y_edges)</span>

            <span class="s3"># Apply scaling to normalize across groups</span>
            <span class="s2">if </span><span class="s1">estimator.stat != </span><span class="s4">&quot;count&quot; </span><span class="s2">and </span><span class="s1">common_norm:</span>
                <span class="s1">heights *= len(sub_data) / len(all_data)</span>

            <span class="s3"># Define the specific kwargs for this artist</span>
            <span class="s1">artist_kws = plot_kws.copy()</span>
            <span class="s2">if </span><span class="s4">&quot;hue&quot; </span><span class="s2">in </span><span class="s1">self.variables:</span>
                <span class="s1">color = self._hue_map(sub_vars[</span><span class="s4">&quot;hue&quot;</span><span class="s1">])</span>
                <span class="s1">cmap = self._cmap_from_color(color)</span>
                <span class="s1">artist_kws[</span><span class="s4">&quot;cmap&quot;</span><span class="s1">] = cmap</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">cmap = artist_kws.pop(</span><span class="s4">&quot;cmap&quot;</span><span class="s2">, None</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s1">isinstance(cmap</span><span class="s2">, </span><span class="s1">str):</span>
                    <span class="s1">cmap = color_palette(cmap</span><span class="s2">, </span><span class="s1">as_cmap=</span><span class="s2">True</span><span class="s1">)</span>
                <span class="s2">elif </span><span class="s1">cmap </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s1">cmap = self._cmap_from_color(color)</span>
                <span class="s1">artist_kws[</span><span class="s4">&quot;cmap&quot;</span><span class="s1">] = cmap</span>

            <span class="s3"># Set the upper norm on the colormap</span>
            <span class="s2">if not </span><span class="s1">common_color_norm </span><span class="s2">and </span><span class="s1">pmax </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">vmax = self._quantile_to_level(heights</span><span class="s2">, </span><span class="s1">pmax)</span>
            <span class="s2">if </span><span class="s1">vmax </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">artist_kws[</span><span class="s4">&quot;vmax&quot;</span><span class="s1">] = vmax</span>

            <span class="s3"># Make cells at or below the threshold transparent</span>
            <span class="s2">if not </span><span class="s1">common_color_norm </span><span class="s2">and </span><span class="s1">pthresh:</span>
                <span class="s1">thresh = self._quantile_to_level(heights</span><span class="s2">, </span><span class="s1">pthresh)</span>
            <span class="s2">if </span><span class="s1">thresh </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">heights = np.ma.masked_less_equal(heights</span><span class="s2">, </span><span class="s1">thresh)</span>

            <span class="s3"># pcolormesh is going to turn the grid off, but we want to keep it</span>
            <span class="s3"># I'm not sure if there's a better way to get the grid state</span>
            <span class="s1">x_grid = any([l.get_visible() </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">ax.xaxis.get_gridlines()])</span>
            <span class="s1">y_grid = any([l.get_visible() </span><span class="s2">for </span><span class="s1">l </span><span class="s2">in </span><span class="s1">ax.yaxis.get_gridlines()])</span>

            <span class="s1">mesh = ax.pcolormesh(</span>
                <span class="s1">x_edges</span><span class="s2">,</span>
                <span class="s1">y_edges</span><span class="s2">,</span>
                <span class="s1">heights.T</span><span class="s2">,</span>
                <span class="s1">**artist_kws</span><span class="s2">,</span>
            <span class="s1">)</span>

            <span class="s3"># pcolormesh sets sticky edges, but we only want them if not thresholding</span>
            <span class="s2">if </span><span class="s1">thresh </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">mesh.sticky_edges.x[:] = []</span>
                <span class="s1">mesh.sticky_edges.y[:] = []</span>

            <span class="s3"># Add an optional colorbar</span>
            <span class="s3"># Note, we want to improve this. When hue is used, it will stack</span>
            <span class="s3"># multiple colorbars with redundant ticks in an ugly way.</span>
            <span class="s3"># But it's going to take some work to have multiple colorbars that</span>
            <span class="s3"># share ticks nicely.</span>
            <span class="s2">if </span><span class="s1">cbar:</span>
                <span class="s1">ax.figure.colorbar(mesh</span><span class="s2">, </span><span class="s1">cbar_ax</span><span class="s2">, </span><span class="s1">ax</span><span class="s2">, </span><span class="s1">**cbar_kws)</span>

            <span class="s3"># Reset the grid state</span>
            <span class="s2">if </span><span class="s1">x_grid:</span>
                <span class="s1">ax.grid(</span><span class="s2">True, </span><span class="s1">axis=</span><span class="s4">&quot;x&quot;</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">y_grid:</span>
                <span class="s1">ax.grid(</span><span class="s2">True, </span><span class="s1">axis=</span><span class="s4">&quot;y&quot;</span><span class="s1">)</span>

        <span class="s3"># --- Finalize the plot</span>

        <span class="s1">ax = self.ax </span><span class="s2">if </span><span class="s1">self.ax </span><span class="s2">is not None else </span><span class="s1">self.facets.axes.flat[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">self._add_axis_labels(ax)</span>

        <span class="s2">if </span><span class="s4">&quot;hue&quot; </span><span class="s2">in </span><span class="s1">self.variables </span><span class="s2">and </span><span class="s1">legend:</span>

            <span class="s3"># TODO if possible, I would like to move the contour</span>
            <span class="s3"># intensity information into the legend too and label the</span>
            <span class="s3"># iso proportions rather than the raw density values</span>

            <span class="s1">artist_kws = {}</span>
            <span class="s1">artist = partial(mpl.patches.Patch)</span>
            <span class="s1">ax_obj = self.ax </span><span class="s2">if </span><span class="s1">self.ax </span><span class="s2">is not None else </span><span class="s1">self.facets</span>
            <span class="s1">self._add_legend(</span>
                <span class="s1">ax_obj</span><span class="s2">, </span><span class="s1">artist</span><span class="s2">, True, False, </span><span class="s4">&quot;layer&quot;</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">artist_kws</span><span class="s2">, </span><span class="s1">{}</span><span class="s2">,</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">plot_univariate_density(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">multiple</span><span class="s2">,</span>
        <span class="s1">common_norm</span><span class="s2">,</span>
        <span class="s1">common_grid</span><span class="s2">,</span>
        <span class="s1">warn_singular</span><span class="s2">,</span>
        <span class="s1">fill</span><span class="s2">,</span>
        <span class="s1">color</span><span class="s2">,</span>
        <span class="s1">legend</span><span class="s2">,</span>
        <span class="s1">estimate_kws</span><span class="s2">,</span>
        <span class="s1">**plot_kws</span><span class="s2">,</span>
    <span class="s1">):</span>

        <span class="s3"># Handle conditional defaults</span>
        <span class="s2">if </span><span class="s1">fill </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">fill = multiple </span><span class="s2">in </span><span class="s1">(</span><span class="s4">&quot;stack&quot;</span><span class="s2">, </span><span class="s4">&quot;fill&quot;</span><span class="s1">)</span>

        <span class="s3"># Preprocess the matplotlib keyword dictionaries</span>
        <span class="s2">if </span><span class="s1">fill:</span>
            <span class="s1">artist = mpl.collections.PolyCollection</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">artist = mpl.lines.Line2D</span>
        <span class="s1">plot_kws = _normalize_kwargs(plot_kws</span><span class="s2">, </span><span class="s1">artist)</span>

        <span class="s3"># Input checking</span>
        <span class="s1">_check_argument(</span><span class="s4">&quot;multiple&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s4">&quot;layer&quot;</span><span class="s2">, </span><span class="s4">&quot;stack&quot;</span><span class="s2">, </span><span class="s4">&quot;fill&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">multiple)</span>

        <span class="s3"># Always share the evaluation grid when stacking</span>
        <span class="s1">subsets = bool(set(self.variables) - {</span><span class="s4">&quot;x&quot;</span><span class="s2">, </span><span class="s4">&quot;y&quot;</span><span class="s1">})</span>
        <span class="s2">if </span><span class="s1">subsets </span><span class="s2">and </span><span class="s1">multiple </span><span class="s2">in </span><span class="s1">(</span><span class="s4">&quot;stack&quot;</span><span class="s2">, </span><span class="s4">&quot;fill&quot;</span><span class="s1">):</span>
            <span class="s1">common_grid = </span><span class="s2">True</span>

        <span class="s3"># Do the computation</span>
        <span class="s1">densities = self._compute_univariate_density(</span>
            <span class="s1">self.data_variable</span><span class="s2">,</span>
            <span class="s1">common_norm</span><span class="s2">,</span>
            <span class="s1">common_grid</span><span class="s2">,</span>
            <span class="s1">estimate_kws</span><span class="s2">,</span>
            <span class="s1">warn_singular</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s3"># Adjust densities based on the `multiple` rule</span>
        <span class="s1">densities</span><span class="s2">, </span><span class="s1">baselines = self._resolve_multiple(densities</span><span class="s2">, </span><span class="s1">multiple)</span>

        <span class="s3"># Control the interaction with autoscaling by defining sticky_edges</span>
        <span class="s3"># i.e. we don't want autoscale margins below the density curve</span>
        <span class="s1">sticky_density = (</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">) </span><span class="s2">if </span><span class="s1">multiple == </span><span class="s4">&quot;fill&quot; </span><span class="s2">else </span><span class="s1">(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">np.inf)</span>

        <span class="s2">if </span><span class="s1">multiple == </span><span class="s4">&quot;fill&quot;</span><span class="s1">:</span>
            <span class="s3"># Filled plots should not have any margins</span>
            <span class="s1">sticky_support = densities.index.min()</span><span class="s2">, </span><span class="s1">densities.index.max()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">sticky_support = []</span>

        <span class="s2">if </span><span class="s1">fill:</span>
            <span class="s2">if </span><span class="s1">multiple == </span><span class="s4">&quot;layer&quot;</span><span class="s1">:</span>
                <span class="s1">default_alpha = </span><span class="s5">.25</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">default_alpha = </span><span class="s5">.75</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">default_alpha = </span><span class="s5">1</span>
        <span class="s1">alpha = plot_kws.pop(</span><span class="s4">&quot;alpha&quot;</span><span class="s2">, </span><span class="s1">default_alpha)  </span><span class="s3"># TODO make parameter?</span>

        <span class="s3"># Now iterate through the subsets and draw the densities</span>
        <span class="s3"># We go backwards so stacked densities read from top-to-bottom</span>
        <span class="s2">for </span><span class="s1">sub_vars</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">self.iter_data(</span><span class="s4">&quot;hue&quot;</span><span class="s2">, </span><span class="s1">reverse=</span><span class="s2">True</span><span class="s1">):</span>

            <span class="s3"># Extract the support grid and density curve for this level</span>
            <span class="s1">key = tuple(sub_vars.items())</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">density = densities[key]</span>
            <span class="s2">except </span><span class="s1">KeyError:</span>
                <span class="s2">continue</span>
            <span class="s1">support = density.index</span>
            <span class="s1">fill_from = baselines[key]</span>

            <span class="s1">ax = self._get_axes(sub_vars)</span>

            <span class="s2">if </span><span class="s4">&quot;hue&quot; </span><span class="s2">in </span><span class="s1">self.variables:</span>
                <span class="s1">sub_color = self._hue_map(sub_vars[</span><span class="s4">&quot;hue&quot;</span><span class="s1">])</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">sub_color = color</span>

            <span class="s1">artist_kws = self._artist_kws(</span>
                <span class="s1">plot_kws</span><span class="s2">, </span><span class="s1">fill</span><span class="s2">, False, </span><span class="s1">multiple</span><span class="s2">, </span><span class="s1">sub_color</span><span class="s2">, </span><span class="s1">alpha</span>
            <span class="s1">)</span>

            <span class="s3"># Either plot a curve with observation values on the x axis</span>
            <span class="s2">if </span><span class="s4">&quot;x&quot; </span><span class="s2">in </span><span class="s1">self.variables:</span>

                <span class="s2">if </span><span class="s1">fill:</span>
                    <span class="s1">artist = ax.fill_between(support</span><span class="s2">, </span><span class="s1">fill_from</span><span class="s2">, </span><span class="s1">density</span><span class="s2">, </span><span class="s1">**artist_kws)</span>

                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">artist</span><span class="s2">, </span><span class="s1">= ax.plot(support</span><span class="s2">, </span><span class="s1">density</span><span class="s2">, </span><span class="s1">**artist_kws)</span>

                <span class="s1">artist.sticky_edges.x[:] = sticky_support</span>
                <span class="s1">artist.sticky_edges.y[:] = sticky_density</span>

            <span class="s3"># Or plot a curve with observation values on the y axis</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">fill:</span>
                    <span class="s1">artist = ax.fill_betweenx(support</span><span class="s2">, </span><span class="s1">fill_from</span><span class="s2">, </span><span class="s1">density</span><span class="s2">, </span><span class="s1">**artist_kws)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">artist</span><span class="s2">, </span><span class="s1">= ax.plot(density</span><span class="s2">, </span><span class="s1">support</span><span class="s2">, </span><span class="s1">**artist_kws)</span>

                <span class="s1">artist.sticky_edges.x[:] = sticky_density</span>
                <span class="s1">artist.sticky_edges.y[:] = sticky_support</span>

        <span class="s3"># --- Finalize the plot ----</span>

        <span class="s1">ax = self.ax </span><span class="s2">if </span><span class="s1">self.ax </span><span class="s2">is not None else </span><span class="s1">self.facets.axes.flat[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">default_x = default_y = </span><span class="s4">&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.data_variable == </span><span class="s4">&quot;x&quot;</span><span class="s1">:</span>
            <span class="s1">default_y = </span><span class="s4">&quot;Density&quot;</span>
        <span class="s2">if </span><span class="s1">self.data_variable == </span><span class="s4">&quot;y&quot;</span><span class="s1">:</span>
            <span class="s1">default_x = </span><span class="s4">&quot;Density&quot;</span>
        <span class="s1">self._add_axis_labels(ax</span><span class="s2">, </span><span class="s1">default_x</span><span class="s2">, </span><span class="s1">default_y)</span>

        <span class="s2">if </span><span class="s4">&quot;hue&quot; </span><span class="s2">in </span><span class="s1">self.variables </span><span class="s2">and </span><span class="s1">legend:</span>

            <span class="s2">if </span><span class="s1">fill:</span>
                <span class="s1">artist = partial(mpl.patches.Patch)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">artist = partial(mpl.lines.Line2D</span><span class="s2">, </span><span class="s1">[]</span><span class="s2">, </span><span class="s1">[])</span>

            <span class="s1">ax_obj = self.ax </span><span class="s2">if </span><span class="s1">self.ax </span><span class="s2">is not None else </span><span class="s1">self.facets</span>
            <span class="s1">self._add_legend(</span>
                <span class="s1">ax_obj</span><span class="s2">, </span><span class="s1">artist</span><span class="s2">, </span><span class="s1">fill</span><span class="s2">, False, </span><span class="s1">multiple</span><span class="s2">, </span><span class="s1">alpha</span><span class="s2">, </span><span class="s1">plot_kws</span><span class="s2">, </span><span class="s1">{}</span><span class="s2">,</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">plot_bivariate_density(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">common_norm</span><span class="s2">,</span>
        <span class="s1">fill</span><span class="s2">,</span>
        <span class="s1">levels</span><span class="s2">,</span>
        <span class="s1">thresh</span><span class="s2">,</span>
        <span class="s1">color</span><span class="s2">,</span>
        <span class="s1">legend</span><span class="s2">,</span>
        <span class="s1">cbar</span><span class="s2">,</span>
        <span class="s1">warn_singular</span><span class="s2">,</span>
        <span class="s1">cbar_ax</span><span class="s2">,</span>
        <span class="s1">cbar_kws</span><span class="s2">,</span>
        <span class="s1">estimate_kws</span><span class="s2">,</span>
        <span class="s1">**contour_kws</span><span class="s2">,</span>
    <span class="s1">):</span>

        <span class="s1">contour_kws = contour_kws.copy()</span>

        <span class="s1">estimator = KDE(**estimate_kws)</span>

        <span class="s2">if not </span><span class="s1">set(self.variables) - {</span><span class="s4">&quot;x&quot;</span><span class="s2">, </span><span class="s4">&quot;y&quot;</span><span class="s1">}:</span>
            <span class="s1">common_norm = </span><span class="s2">False</span>

        <span class="s1">all_data = self.plot_data.dropna()</span>

        <span class="s3"># Loop through the subsets and estimate the KDEs</span>
        <span class="s1">densities</span><span class="s2">, </span><span class="s1">supports = {}</span><span class="s2">, </span><span class="s1">{}</span>

        <span class="s2">for </span><span class="s1">sub_vars</span><span class="s2">, </span><span class="s1">sub_data </span><span class="s2">in </span><span class="s1">self.iter_data(</span><span class="s4">&quot;hue&quot;</span><span class="s2">, </span><span class="s1">from_comp_data=</span><span class="s2">True</span><span class="s1">):</span>

            <span class="s3"># Extract the data points from this sub set</span>
            <span class="s1">observations = sub_data[[</span><span class="s4">&quot;x&quot;</span><span class="s2">, </span><span class="s4">&quot;y&quot;</span><span class="s1">]]</span>
            <span class="s1">min_variance = observations.var().fillna(</span><span class="s5">0</span><span class="s1">).min()</span>
            <span class="s1">observations = observations[</span><span class="s4">&quot;x&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">observations[</span><span class="s4">&quot;y&quot;</span><span class="s1">]</span>

            <span class="s3"># Extract the weights for this subset of observations</span>
            <span class="s2">if </span><span class="s4">&quot;weights&quot; </span><span class="s2">in </span><span class="s1">self.variables:</span>
                <span class="s1">weights = sub_data[</span><span class="s4">&quot;weights&quot;</span><span class="s1">]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">weights = </span><span class="s2">None</span>

            <span class="s3"># Estimate the density of observations at this level</span>
            <span class="s1">singular = math.isclose(min_variance</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">if not </span><span class="s1">singular:</span>
                    <span class="s1">density</span><span class="s2">, </span><span class="s1">support = estimator(*observations</span><span class="s2">, </span><span class="s1">weights=weights)</span>
            <span class="s2">except </span><span class="s1">np.linalg.LinAlgError:</span>
                <span class="s3"># Testing for 0 variance doesn't catch all cases where scipy raises,</span>
                <span class="s3"># but we can also get a ValueError, so we need this convoluted approach</span>
                <span class="s1">singular = </span><span class="s2">True</span>

            <span class="s2">if </span><span class="s1">singular:</span>
                <span class="s1">msg = (</span>
                    <span class="s4">&quot;KDE cannot be estimated (0 variance or perfect covariance). &quot;</span>
                    <span class="s4">&quot;Pass `warn_singular=False` to disable this warning.&quot;</span>
                <span class="s1">)</span>
                <span class="s2">if </span><span class="s1">warn_singular:</span>
                    <span class="s1">warnings.warn(msg</span><span class="s2">, </span><span class="s1">UserWarning</span><span class="s2">, </span><span class="s1">stacklevel=</span><span class="s5">3</span><span class="s1">)</span>
                <span class="s2">continue</span>

            <span class="s3"># Transform the support grid back to the original scale</span>
            <span class="s1">ax = self._get_axes(sub_vars)</span>
            <span class="s1">_</span><span class="s2">, </span><span class="s1">inv_x = _get_transform_functions(ax</span><span class="s2">, </span><span class="s4">&quot;x&quot;</span><span class="s1">)</span>
            <span class="s1">_</span><span class="s2">, </span><span class="s1">inv_y = _get_transform_functions(ax</span><span class="s2">, </span><span class="s4">&quot;y&quot;</span><span class="s1">)</span>
            <span class="s1">support = inv_x(support[</span><span class="s5">0</span><span class="s1">])</span><span class="s2">, </span><span class="s1">inv_y(support[</span><span class="s5">1</span><span class="s1">])</span>

            <span class="s3"># Apply a scaling factor so that the integral over all subsets is 1</span>
            <span class="s2">if </span><span class="s1">common_norm:</span>
                <span class="s1">density *= len(sub_data) / len(all_data)</span>

            <span class="s1">key = tuple(sub_vars.items())</span>
            <span class="s1">densities[key] = density</span>
            <span class="s1">supports[key] = support</span>

        <span class="s3"># Define a grid of iso-proportion levels</span>
        <span class="s2">if </span><span class="s1">thresh </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">thresh = </span><span class="s5">0</span>
        <span class="s2">if </span><span class="s1">isinstance(levels</span><span class="s2">, </span><span class="s1">Number):</span>
            <span class="s1">levels = np.linspace(thresh</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">levels)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">min(levels) &lt; </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">max(levels) &gt; </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;levels must be in [0, 1]&quot;</span><span class="s1">)</span>

        <span class="s3"># Transform from iso-proportions to iso-densities</span>
        <span class="s2">if </span><span class="s1">common_norm:</span>
            <span class="s1">common_levels = self._quantile_to_level(</span>
                <span class="s1">list(densities.values())</span><span class="s2">, </span><span class="s1">levels</span><span class="s2">,</span>
            <span class="s1">)</span>
            <span class="s1">draw_levels = {k: common_levels </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">densities}</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">draw_levels = {</span>
                <span class="s1">k: self._quantile_to_level(d</span><span class="s2">, </span><span class="s1">levels)</span>
                <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">d </span><span class="s2">in </span><span class="s1">densities.items()</span>
            <span class="s1">}</span>

        <span class="s3"># Define the coloring of the contours</span>
        <span class="s2">if </span><span class="s4">&quot;hue&quot; </span><span class="s2">in </span><span class="s1">self.variables:</span>
            <span class="s2">for </span><span class="s1">param </span><span class="s2">in </span><span class="s1">[</span><span class="s4">&quot;cmap&quot;</span><span class="s2">, </span><span class="s4">&quot;colors&quot;</span><span class="s1">]:</span>
                <span class="s2">if </span><span class="s1">param </span><span class="s2">in </span><span class="s1">contour_kws:</span>
                    <span class="s1">msg = </span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">param</span><span class="s2">} </span><span class="s4">parameter ignored when using hue mapping.&quot;</span>
                    <span class="s1">warnings.warn(msg</span><span class="s2">, </span><span class="s1">UserWarning)</span>
                    <span class="s1">contour_kws.pop(param)</span>
        <span class="s2">else</span><span class="s1">:</span>

            <span class="s3"># Work out a default coloring of the contours</span>
            <span class="s1">coloring_given = set(contour_kws) &amp; {</span><span class="s4">&quot;cmap&quot;</span><span class="s2">, </span><span class="s4">&quot;colors&quot;</span><span class="s1">}</span>
            <span class="s2">if </span><span class="s1">fill </span><span class="s2">and not </span><span class="s1">coloring_given:</span>
                <span class="s1">cmap = self._cmap_from_color(color)</span>
                <span class="s1">contour_kws[</span><span class="s4">&quot;cmap&quot;</span><span class="s1">] = cmap</span>
            <span class="s2">if not </span><span class="s1">fill </span><span class="s2">and not </span><span class="s1">coloring_given:</span>
                <span class="s1">contour_kws[</span><span class="s4">&quot;colors&quot;</span><span class="s1">] = [color]</span>

            <span class="s3"># Use our internal colormap lookup</span>
            <span class="s1">cmap = contour_kws.pop(</span><span class="s4">&quot;cmap&quot;</span><span class="s2">, None</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">isinstance(cmap</span><span class="s2">, </span><span class="s1">str):</span>
                <span class="s1">cmap = color_palette(cmap</span><span class="s2">, </span><span class="s1">as_cmap=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">cmap </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">contour_kws[</span><span class="s4">&quot;cmap&quot;</span><span class="s1">] = cmap</span>

        <span class="s3"># Loop through the subsets again and plot the data</span>
        <span class="s2">for </span><span class="s1">sub_vars</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">self.iter_data(</span><span class="s4">&quot;hue&quot;</span><span class="s1">):</span>

            <span class="s2">if </span><span class="s4">&quot;hue&quot; </span><span class="s2">in </span><span class="s1">sub_vars:</span>
                <span class="s1">color = self._hue_map(sub_vars[</span><span class="s4">&quot;hue&quot;</span><span class="s1">])</span>
                <span class="s2">if </span><span class="s1">fill:</span>
                    <span class="s1">contour_kws[</span><span class="s4">&quot;cmap&quot;</span><span class="s1">] = self._cmap_from_color(color)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">contour_kws[</span><span class="s4">&quot;colors&quot;</span><span class="s1">] = [color]</span>

            <span class="s1">ax = self._get_axes(sub_vars)</span>

            <span class="s3"># Choose the function to plot with</span>
            <span class="s3"># TODO could add a pcolormesh based option as well</span>
            <span class="s3"># Which would look something like element=&quot;raster&quot;</span>
            <span class="s2">if </span><span class="s1">fill:</span>
                <span class="s1">contour_func = ax.contourf</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">contour_func = ax.contour</span>

            <span class="s1">key = tuple(sub_vars.items())</span>
            <span class="s2">if </span><span class="s1">key </span><span class="s2">not in </span><span class="s1">densities:</span>
                <span class="s2">continue</span>
            <span class="s1">density = densities[key]</span>
            <span class="s1">xx</span><span class="s2">, </span><span class="s1">yy = supports[key]</span>

            <span class="s3"># Pop the label kwarg which is unused by contour_func (but warns)</span>
            <span class="s1">contour_kws.pop(</span><span class="s4">&quot;label&quot;</span><span class="s2">, None</span><span class="s1">)</span>

            <span class="s1">cset = contour_func(</span>
                <span class="s1">xx</span><span class="s2">, </span><span class="s1">yy</span><span class="s2">, </span><span class="s1">density</span><span class="s2">,</span>
                <span class="s1">levels=draw_levels[key]</span><span class="s2">,</span>
                <span class="s1">**contour_kws</span><span class="s2">,</span>
            <span class="s1">)</span>

            <span class="s3"># Add a color bar representing the contour heights</span>
            <span class="s3"># Note: this shows iso densities, not iso proportions</span>
            <span class="s3"># See more notes in histplot about how this could be improved</span>
            <span class="s2">if </span><span class="s1">cbar:</span>
                <span class="s1">cbar_kws = {} </span><span class="s2">if </span><span class="s1">cbar_kws </span><span class="s2">is None else </span><span class="s1">cbar_kws</span>
                <span class="s1">ax.figure.colorbar(cset</span><span class="s2">, </span><span class="s1">cbar_ax</span><span class="s2">, </span><span class="s1">ax</span><span class="s2">, </span><span class="s1">**cbar_kws)</span>

        <span class="s3"># --- Finalize the plot</span>
        <span class="s1">ax = self.ax </span><span class="s2">if </span><span class="s1">self.ax </span><span class="s2">is not None else </span><span class="s1">self.facets.axes.flat[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">self._add_axis_labels(ax)</span>

        <span class="s2">if </span><span class="s4">&quot;hue&quot; </span><span class="s2">in </span><span class="s1">self.variables </span><span class="s2">and </span><span class="s1">legend:</span>

            <span class="s3"># TODO if possible, I would like to move the contour</span>
            <span class="s3"># intensity information into the legend too and label the</span>
            <span class="s3"># iso proportions rather than the raw density values</span>

            <span class="s1">artist_kws = {}</span>
            <span class="s2">if </span><span class="s1">fill:</span>
                <span class="s1">artist = partial(mpl.patches.Patch)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">artist = partial(mpl.lines.Line2D</span><span class="s2">, </span><span class="s1">[]</span><span class="s2">, </span><span class="s1">[])</span>

            <span class="s1">ax_obj = self.ax </span><span class="s2">if </span><span class="s1">self.ax </span><span class="s2">is not None else </span><span class="s1">self.facets</span>
            <span class="s1">self._add_legend(</span>
                <span class="s1">ax_obj</span><span class="s2">, </span><span class="s1">artist</span><span class="s2">, </span><span class="s1">fill</span><span class="s2">, False, </span><span class="s4">&quot;layer&quot;</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">artist_kws</span><span class="s2">, </span><span class="s1">{}</span><span class="s2">,</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">plot_univariate_ecdf(self</span><span class="s2">, </span><span class="s1">estimate_kws</span><span class="s2">, </span><span class="s1">legend</span><span class="s2">, </span><span class="s1">**plot_kws):</span>

        <span class="s1">estimator = ECDF(**estimate_kws)</span>

        <span class="s3"># Set the draw style to step the right way for the data variable</span>
        <span class="s1">drawstyles = dict(x=</span><span class="s4">&quot;steps-post&quot;</span><span class="s2">, </span><span class="s1">y=</span><span class="s4">&quot;steps-pre&quot;</span><span class="s1">)</span>
        <span class="s1">plot_kws[</span><span class="s4">&quot;drawstyle&quot;</span><span class="s1">] = drawstyles[self.data_variable]</span>

        <span class="s3"># Loop through the subsets, transform and plot the data</span>
        <span class="s2">for </span><span class="s1">sub_vars</span><span class="s2">, </span><span class="s1">sub_data </span><span class="s2">in </span><span class="s1">self.iter_data(</span>
            <span class="s4">&quot;hue&quot;</span><span class="s2">, </span><span class="s1">reverse=</span><span class="s2">True, </span><span class="s1">from_comp_data=</span><span class="s2">True,</span>
        <span class="s1">):</span>

            <span class="s3"># Compute the ECDF</span>
            <span class="s2">if </span><span class="s1">sub_data.empty:</span>
                <span class="s2">continue</span>

            <span class="s1">observations = sub_data[self.data_variable]</span>
            <span class="s1">weights = sub_data.get(</span><span class="s4">&quot;weights&quot;</span><span class="s2">, None</span><span class="s1">)</span>
            <span class="s1">stat</span><span class="s2">, </span><span class="s1">vals = estimator(observations</span><span class="s2">, </span><span class="s1">weights=weights)</span>

            <span class="s3"># Assign attributes based on semantic mapping</span>
            <span class="s1">artist_kws = plot_kws.copy()</span>
            <span class="s2">if </span><span class="s4">&quot;hue&quot; </span><span class="s2">in </span><span class="s1">self.variables:</span>
                <span class="s1">artist_kws[</span><span class="s4">&quot;color&quot;</span><span class="s1">] = self._hue_map(sub_vars[</span><span class="s4">&quot;hue&quot;</span><span class="s1">])</span>

            <span class="s3"># Return the data variable to the linear domain</span>
            <span class="s1">ax = self._get_axes(sub_vars)</span>
            <span class="s1">_</span><span class="s2">, </span><span class="s1">inv = _get_transform_functions(ax</span><span class="s2">, </span><span class="s1">self.data_variable)</span>
            <span class="s1">vals = inv(vals)</span>

            <span class="s3"># Manually set the minimum value on a &quot;log&quot; scale</span>
            <span class="s2">if </span><span class="s1">isinstance(inv.__self__</span><span class="s2">, </span><span class="s1">mpl.scale.LogTransform):</span>
                <span class="s1">vals[</span><span class="s5">0</span><span class="s1">] = -np.inf</span>

            <span class="s3"># Work out the orientation of the plot</span>
            <span class="s2">if </span><span class="s1">self.data_variable == </span><span class="s4">&quot;x&quot;</span><span class="s1">:</span>
                <span class="s1">plot_args = vals</span><span class="s2">, </span><span class="s1">stat</span>
                <span class="s1">stat_variable = </span><span class="s4">&quot;y&quot;</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">plot_args = stat</span><span class="s2">, </span><span class="s1">vals</span>
                <span class="s1">stat_variable = </span><span class="s4">&quot;x&quot;</span>

            <span class="s2">if </span><span class="s1">estimator.stat == </span><span class="s4">&quot;count&quot;</span><span class="s1">:</span>
                <span class="s1">top_edge = len(observations)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">top_edge = </span><span class="s5">1</span>

            <span class="s3"># Draw the line for this subset</span>
            <span class="s1">artist</span><span class="s2">, </span><span class="s1">= ax.plot(*plot_args</span><span class="s2">, </span><span class="s1">**artist_kws)</span>
            <span class="s1">sticky_edges = getattr(artist.sticky_edges</span><span class="s2">, </span><span class="s1">stat_variable)</span>
            <span class="s1">sticky_edges[:] = </span><span class="s5">0</span><span class="s2">, </span><span class="s1">top_edge</span>

        <span class="s3"># --- Finalize the plot ----</span>
        <span class="s1">ax = self.ax </span><span class="s2">if </span><span class="s1">self.ax </span><span class="s2">is not None else </span><span class="s1">self.facets.axes.flat[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">stat = estimator.stat.capitalize()</span>
        <span class="s1">default_x = default_y = </span><span class="s4">&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.data_variable == </span><span class="s4">&quot;x&quot;</span><span class="s1">:</span>
            <span class="s1">default_y = stat</span>
        <span class="s2">if </span><span class="s1">self.data_variable == </span><span class="s4">&quot;y&quot;</span><span class="s1">:</span>
            <span class="s1">default_x = stat</span>
        <span class="s1">self._add_axis_labels(ax</span><span class="s2">, </span><span class="s1">default_x</span><span class="s2">, </span><span class="s1">default_y)</span>

        <span class="s2">if </span><span class="s4">&quot;hue&quot; </span><span class="s2">in </span><span class="s1">self.variables </span><span class="s2">and </span><span class="s1">legend:</span>
            <span class="s1">artist = partial(mpl.lines.Line2D</span><span class="s2">, </span><span class="s1">[]</span><span class="s2">, </span><span class="s1">[])</span>
            <span class="s1">alpha = plot_kws.get(</span><span class="s4">&quot;alpha&quot;</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">ax_obj = self.ax </span><span class="s2">if </span><span class="s1">self.ax </span><span class="s2">is not None else </span><span class="s1">self.facets</span>
            <span class="s1">self._add_legend(</span>
                <span class="s1">ax_obj</span><span class="s2">, </span><span class="s1">artist</span><span class="s2">, False, False, None, </span><span class="s1">alpha</span><span class="s2">, </span><span class="s1">plot_kws</span><span class="s2">, </span><span class="s1">{}</span><span class="s2">,</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">plot_rug(self</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">expand_margins</span><span class="s2">, </span><span class="s1">legend</span><span class="s2">, </span><span class="s1">**kws):</span>

        <span class="s2">for </span><span class="s1">sub_vars</span><span class="s2">, </span><span class="s1">sub_data</span><span class="s2">, in </span><span class="s1">self.iter_data(from_comp_data=</span><span class="s2">True</span><span class="s1">):</span>

            <span class="s1">ax = self._get_axes(sub_vars)</span>

            <span class="s1">kws.setdefault(</span><span class="s4">&quot;linewidth&quot;</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>

            <span class="s2">if </span><span class="s1">expand_margins:</span>
                <span class="s1">xmarg</span><span class="s2">, </span><span class="s1">ymarg = ax.margins()</span>
                <span class="s2">if </span><span class="s4">&quot;x&quot; </span><span class="s2">in </span><span class="s1">self.variables:</span>
                    <span class="s1">ymarg += height * </span><span class="s5">2</span>
                <span class="s2">if </span><span class="s4">&quot;y&quot; </span><span class="s2">in </span><span class="s1">self.variables:</span>
                    <span class="s1">xmarg += height * </span><span class="s5">2</span>
                <span class="s1">ax.margins(x=xmarg</span><span class="s2">, </span><span class="s1">y=ymarg)</span>

            <span class="s2">if </span><span class="s4">&quot;hue&quot; </span><span class="s2">in </span><span class="s1">self.variables:</span>
                <span class="s1">kws.pop(</span><span class="s4">&quot;c&quot;</span><span class="s2">, None</span><span class="s1">)</span>
                <span class="s1">kws.pop(</span><span class="s4">&quot;color&quot;</span><span class="s2">, None</span><span class="s1">)</span>

            <span class="s2">if </span><span class="s4">&quot;x&quot; </span><span class="s2">in </span><span class="s1">self.variables:</span>
                <span class="s1">self._plot_single_rug(sub_data</span><span class="s2">, </span><span class="s4">&quot;x&quot;</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">ax</span><span class="s2">, </span><span class="s1">kws)</span>
            <span class="s2">if </span><span class="s4">&quot;y&quot; </span><span class="s2">in </span><span class="s1">self.variables:</span>
                <span class="s1">self._plot_single_rug(sub_data</span><span class="s2">, </span><span class="s4">&quot;y&quot;</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">ax</span><span class="s2">, </span><span class="s1">kws)</span>

            <span class="s3"># --- Finalize the plot</span>
            <span class="s1">self._add_axis_labels(ax)</span>
            <span class="s2">if </span><span class="s4">&quot;hue&quot; </span><span class="s2">in </span><span class="s1">self.variables </span><span class="s2">and </span><span class="s1">legend:</span>
                <span class="s3"># TODO ideally i'd like the legend artist to look like a rug</span>
                <span class="s1">legend_artist = partial(mpl.lines.Line2D</span><span class="s2">, </span><span class="s1">[]</span><span class="s2">, </span><span class="s1">[])</span>
                <span class="s1">self._add_legend(</span>
                    <span class="s1">ax</span><span class="s2">, </span><span class="s1">legend_artist</span><span class="s2">, False, False, None, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">{}</span><span class="s2">, </span><span class="s1">{}</span><span class="s2">,</span>
                <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_plot_single_rug(self</span><span class="s2">, </span><span class="s1">sub_data</span><span class="s2">, </span><span class="s1">var</span><span class="s2">, </span><span class="s1">height</span><span class="s2">, </span><span class="s1">ax</span><span class="s2">, </span><span class="s1">kws):</span>
        <span class="s0">&quot;&quot;&quot;Draw a rugplot along one axis of the plot.&quot;&quot;&quot;</span>
        <span class="s1">vector = sub_data[var]</span>
        <span class="s1">n = len(vector)</span>

        <span class="s3"># Return data to linear domain</span>
        <span class="s1">_</span><span class="s2">, </span><span class="s1">inv = _get_transform_functions(ax</span><span class="s2">, </span><span class="s1">var)</span>
        <span class="s1">vector = inv(vector)</span>

        <span class="s3"># We'll always add a single collection with varying colors</span>
        <span class="s2">if </span><span class="s4">&quot;hue&quot; </span><span class="s2">in </span><span class="s1">self.variables:</span>
            <span class="s1">colors = self._hue_map(sub_data[</span><span class="s4">&quot;hue&quot;</span><span class="s1">])</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">colors = </span><span class="s2">None</span>

        <span class="s3"># Build the array of values for the LineCollection</span>
        <span class="s2">if </span><span class="s1">var == </span><span class="s4">&quot;x&quot;</span><span class="s1">:</span>

            <span class="s1">trans = tx.blended_transform_factory(ax.transData</span><span class="s2">, </span><span class="s1">ax.transAxes)</span>
            <span class="s1">xy_pairs = np.column_stack([</span>
                <span class="s1">np.repeat(vector</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.tile([</span><span class="s5">0</span><span class="s2">, </span><span class="s1">height]</span><span class="s2">, </span><span class="s1">n)</span>
            <span class="s1">])</span>

        <span class="s2">if </span><span class="s1">var == </span><span class="s4">&quot;y&quot;</span><span class="s1">:</span>

            <span class="s1">trans = tx.blended_transform_factory(ax.transAxes</span><span class="s2">, </span><span class="s1">ax.transData)</span>
            <span class="s1">xy_pairs = np.column_stack([</span>
                <span class="s1">np.tile([</span><span class="s5">0</span><span class="s2">, </span><span class="s1">height]</span><span class="s2">, </span><span class="s1">n)</span><span class="s2">, </span><span class="s1">np.repeat(vector</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>
            <span class="s1">])</span>

        <span class="s3"># Draw the lines on the plot</span>
        <span class="s1">line_segs = xy_pairs.reshape([n</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s1">])</span>
        <span class="s1">ax.add_collection(LineCollection(</span>
            <span class="s1">line_segs</span><span class="s2">, </span><span class="s1">transform=trans</span><span class="s2">, </span><span class="s1">colors=colors</span><span class="s2">, </span><span class="s1">**kws</span>
        <span class="s1">))</span>

        <span class="s1">ax.autoscale_view(scalex=var == </span><span class="s4">&quot;x&quot;</span><span class="s2">, </span><span class="s1">scaley=var == </span><span class="s4">&quot;y&quot;</span><span class="s1">)</span>


<span class="s3"># ==================================================================================== #</span>
<span class="s3"># External API</span>
<span class="s3"># ==================================================================================== #</span>

<span class="s2">def </span><span class="s1">histplot(</span>
    <span class="s1">data=</span><span class="s2">None, </span><span class="s1">*</span><span class="s2">,</span>
    <span class="s3"># Vector variables</span>
    <span class="s1">x=</span><span class="s2">None, </span><span class="s1">y=</span><span class="s2">None, </span><span class="s1">hue=</span><span class="s2">None, </span><span class="s1">weights=</span><span class="s2">None,</span>
    <span class="s3"># Histogram computation parameters</span>
    <span class="s1">stat=</span><span class="s4">&quot;count&quot;</span><span class="s2">, </span><span class="s1">bins=</span><span class="s4">&quot;auto&quot;</span><span class="s2">, </span><span class="s1">binwidth=</span><span class="s2">None, </span><span class="s1">binrange=</span><span class="s2">None,</span>
    <span class="s1">discrete=</span><span class="s2">None, </span><span class="s1">cumulative=</span><span class="s2">False, </span><span class="s1">common_bins=</span><span class="s2">True, </span><span class="s1">common_norm=</span><span class="s2">True,</span>
    <span class="s3"># Histogram appearance parameters</span>
    <span class="s1">multiple=</span><span class="s4">&quot;layer&quot;</span><span class="s2">, </span><span class="s1">element=</span><span class="s4">&quot;bars&quot;</span><span class="s2">, </span><span class="s1">fill=</span><span class="s2">True, </span><span class="s1">shrink=</span><span class="s5">1</span><span class="s2">,</span>
    <span class="s3"># Histogram smoothing with a kernel density estimate</span>
    <span class="s1">kde=</span><span class="s2">False, </span><span class="s1">kde_kws=</span><span class="s2">None, </span><span class="s1">line_kws=</span><span class="s2">None,</span>
    <span class="s3"># Bivariate histogram parameters</span>
    <span class="s1">thresh=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">pthresh=</span><span class="s2">None, </span><span class="s1">pmax=</span><span class="s2">None, </span><span class="s1">cbar=</span><span class="s2">False, </span><span class="s1">cbar_ax=</span><span class="s2">None, </span><span class="s1">cbar_kws=</span><span class="s2">None,</span>
    <span class="s3"># Hue mapping parameters</span>
    <span class="s1">palette=</span><span class="s2">None, </span><span class="s1">hue_order=</span><span class="s2">None, </span><span class="s1">hue_norm=</span><span class="s2">None, </span><span class="s1">color=</span><span class="s2">None,</span>
    <span class="s3"># Axes information</span>
    <span class="s1">log_scale=</span><span class="s2">None, </span><span class="s1">legend=</span><span class="s2">True, </span><span class="s1">ax=</span><span class="s2">None,</span>
    <span class="s3"># Other appearance keywords</span>
    <span class="s1">**kwargs</span><span class="s2">,</span>
<span class="s1">):</span>

    <span class="s1">p = _DistributionPlotter(</span>
        <span class="s1">data=data</span><span class="s2">,</span>
        <span class="s1">variables=dict(x=x</span><span class="s2">, </span><span class="s1">y=y</span><span class="s2">, </span><span class="s1">hue=hue</span><span class="s2">, </span><span class="s1">weights=weights)</span><span class="s2">,</span>
    <span class="s1">)</span>

    <span class="s1">p.map_hue(palette=palette</span><span class="s2">, </span><span class="s1">order=hue_order</span><span class="s2">, </span><span class="s1">norm=hue_norm)</span>

    <span class="s2">if </span><span class="s1">ax </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">ax = plt.gca()</span>

    <span class="s1">p._attach(ax</span><span class="s2">, </span><span class="s1">log_scale=log_scale)</span>

    <span class="s2">if </span><span class="s1">p.univariate:  </span><span class="s3"># Note, bivariate plots won't cycle</span>
        <span class="s2">if </span><span class="s1">fill:</span>
            <span class="s1">method = ax.bar </span><span class="s2">if </span><span class="s1">element == </span><span class="s4">&quot;bars&quot; </span><span class="s2">else </span><span class="s1">ax.fill_between</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">method = ax.plot</span>
        <span class="s1">color = _default_color(method</span><span class="s2">, </span><span class="s1">hue</span><span class="s2">, </span><span class="s1">color</span><span class="s2">, </span><span class="s1">kwargs)</span>

    <span class="s2">if not </span><span class="s1">p.has_xy_data:</span>
        <span class="s2">return </span><span class="s1">ax</span>

    <span class="s3"># Default to discrete bins for categorical variables</span>
    <span class="s2">if </span><span class="s1">discrete </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">discrete = p._default_discrete()</span>

    <span class="s1">estimate_kws = dict(</span>
        <span class="s1">stat=stat</span><span class="s2">,</span>
        <span class="s1">bins=bins</span><span class="s2">,</span>
        <span class="s1">binwidth=binwidth</span><span class="s2">,</span>
        <span class="s1">binrange=binrange</span><span class="s2">,</span>
        <span class="s1">discrete=discrete</span><span class="s2">,</span>
        <span class="s1">cumulative=cumulative</span><span class="s2">,</span>
    <span class="s1">)</span>

    <span class="s2">if </span><span class="s1">p.univariate:</span>

        <span class="s1">p.plot_univariate_histogram(</span>
            <span class="s1">multiple=multiple</span><span class="s2">,</span>
            <span class="s1">element=element</span><span class="s2">,</span>
            <span class="s1">fill=fill</span><span class="s2">,</span>
            <span class="s1">shrink=shrink</span><span class="s2">,</span>
            <span class="s1">common_norm=common_norm</span><span class="s2">,</span>
            <span class="s1">common_bins=common_bins</span><span class="s2">,</span>
            <span class="s1">kde=kde</span><span class="s2">,</span>
            <span class="s1">kde_kws=kde_kws</span><span class="s2">,</span>
            <span class="s1">color=color</span><span class="s2">,</span>
            <span class="s1">legend=legend</span><span class="s2">,</span>
            <span class="s1">estimate_kws=estimate_kws</span><span class="s2">,</span>
            <span class="s1">line_kws=line_kws</span><span class="s2">,</span>
            <span class="s1">**kwargs</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">else</span><span class="s1">:</span>

        <span class="s1">p.plot_bivariate_histogram(</span>
            <span class="s1">common_bins=common_bins</span><span class="s2">,</span>
            <span class="s1">common_norm=common_norm</span><span class="s2">,</span>
            <span class="s1">thresh=thresh</span><span class="s2">,</span>
            <span class="s1">pthresh=pthresh</span><span class="s2">,</span>
            <span class="s1">pmax=pmax</span><span class="s2">,</span>
            <span class="s1">color=color</span><span class="s2">,</span>
            <span class="s1">legend=legend</span><span class="s2">,</span>
            <span class="s1">cbar=cbar</span><span class="s2">,</span>
            <span class="s1">cbar_ax=cbar_ax</span><span class="s2">,</span>
            <span class="s1">cbar_kws=cbar_kws</span><span class="s2">,</span>
            <span class="s1">estimate_kws=estimate_kws</span><span class="s2">,</span>
            <span class="s1">**kwargs</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">return </span><span class="s1">ax</span>


<span class="s1">histplot.__doc__ = </span><span class="s4">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s4">Plot univariate or bivariate histograms to show distributions of datasets. 
 
A histogram is a classic visualization tool that represents the distribution 
of one or more variables by counting the number of observations that fall within 
discrete bins. 
 
This function can normalize the statistic computed within each bin to estimate 
frequency, density or probability mass, and it can add a smooth curve obtained 
using a kernel density estimate, similar to :func:`kdeplot`. 
 
More information is provided in the :ref:`user guide &lt;tutorial_hist&gt;`. 
 
Parameters 
---------- 
{params.core.data} 
{params.core.xy} 
{params.core.hue} 
weights : vector or key in ``data`` 
    If provided, weight the contribution of the corresponding data points 
    towards the count in each bin by these factors. 
{params.hist.stat} 
{params.hist.bins} 
{params.hist.binwidth} 
{params.hist.binrange} 
discrete : bool 
    If True, default to ``binwidth=1`` and draw the bars so that they are 
    centered on their corresponding data points. This avoids &quot;gaps&quot; that may 
    otherwise appear when using discrete (integer) data. 
cumulative : bool 
    If True, plot the cumulative counts as bins increase. 
common_bins : bool 
    If True, use the same bins when semantic variables produce multiple 
    plots. If using a reference rule to determine the bins, it will be computed 
    with the full dataset. 
common_norm : bool 
    If True and using a normalized statistic, the normalization will apply over 
    the full dataset. Otherwise, normalize each histogram independently. 
multiple : {{&quot;layer&quot;, &quot;dodge&quot;, &quot;stack&quot;, &quot;fill&quot;}} 
    Approach to resolving multiple elements when semantic mapping creates subsets. 
    Only relevant with univariate data. 
element : {{&quot;bars&quot;, &quot;step&quot;, &quot;poly&quot;}} 
    Visual representation of the histogram statistic. 
    Only relevant with univariate data. 
fill : bool 
    If True, fill in the space under the histogram. 
    Only relevant with univariate data. 
shrink : number 
    Scale the width of each bar relative to the binwidth by this factor. 
    Only relevant with univariate data. 
kde : bool 
    If True, compute a kernel density estimate to smooth the distribution 
    and show on the plot as (one or more) line(s). 
    Only relevant with univariate data. 
kde_kws : dict 
    Parameters that control the KDE computation, as in :func:`kdeplot`. 
line_kws : dict 
    Parameters that control the KDE visualization, passed to 
    :meth:`matplotlib.axes.Axes.plot`. 
thresh : number or None 
    Cells with a statistic less than or equal to this value will be transparent. 
    Only relevant with bivariate data. 
pthresh : number or None 
    Like ``thresh``, but a value in [0, 1] such that cells with aggregate counts 
    (or other statistics, when used) up to this proportion of the total will be 
    transparent. 
pmax : number or None 
    A value in [0, 1] that sets that saturation point for the colormap at a value 
    such that cells below constitute this proportion of the total count (or 
    other statistic, when used). 
{params.dist.cbar} 
{params.dist.cbar_ax} 
{params.dist.cbar_kws} 
{params.core.palette} 
{params.core.hue_order} 
{params.core.hue_norm} 
{params.core.color} 
{params.dist.log_scale} 
{params.dist.legend} 
{params.core.ax} 
kwargs 
    Other keyword arguments are passed to one of the following matplotlib 
    functions: 
 
    - :meth:`matplotlib.axes.Axes.bar` (univariate, element=&quot;bars&quot;) 
    - :meth:`matplotlib.axes.Axes.fill_between` (univariate, other element, fill=True) 
    - :meth:`matplotlib.axes.Axes.plot` (univariate, other element, fill=False) 
    - :meth:`matplotlib.axes.Axes.pcolormesh` (bivariate) 
 
Returns 
------- 
{returns.ax} 
 
See Also 
-------- 
{seealso.displot} 
{seealso.kdeplot} 
{seealso.rugplot} 
{seealso.ecdfplot} 
{seealso.jointplot} 
 
Notes 
----- 
 
The choice of bins for computing and plotting a histogram can exert 
substantial influence on the insights that one is able to draw from the 
visualization. If the bins are too large, they may erase important features. 
On the other hand, bins that are too small may be dominated by random 
variability, obscuring the shape of the true underlying distribution. The 
default bin size is determined using a reference rule that depends on the 
sample size and variance. This works well in many cases, (i.e., with 
&quot;well-behaved&quot; data) but it fails in others. It is always a good to try 
different bin sizes to be sure that you are not missing something important. 
This function allows you to specify bins in several different ways, such as 
by setting the total number of bins to use, the width of each bin, or the 
specific locations where the bins should break. 
 
Examples 
-------- 
 
.. include:: ../docstrings/histplot.rst 
 
&quot;&quot;&quot;</span><span class="s1">.format(</span>
    <span class="s1">params=_param_docs</span><span class="s2">,</span>
    <span class="s1">returns=_core_docs[</span><span class="s4">&quot;returns&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">seealso=_core_docs[</span><span class="s4">&quot;seealso&quot;</span><span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>


<span class="s2">def </span><span class="s1">kdeplot(</span>
    <span class="s1">data=</span><span class="s2">None, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">x=</span><span class="s2">None, </span><span class="s1">y=</span><span class="s2">None, </span><span class="s1">hue=</span><span class="s2">None, </span><span class="s1">weights=</span><span class="s2">None,</span>
    <span class="s1">palette=</span><span class="s2">None, </span><span class="s1">hue_order=</span><span class="s2">None, </span><span class="s1">hue_norm=</span><span class="s2">None, </span><span class="s1">color=</span><span class="s2">None, </span><span class="s1">fill=</span><span class="s2">None,</span>
    <span class="s1">multiple=</span><span class="s4">&quot;layer&quot;</span><span class="s2">, </span><span class="s1">common_norm=</span><span class="s2">True, </span><span class="s1">common_grid=</span><span class="s2">False, </span><span class="s1">cumulative=</span><span class="s2">False,</span>
    <span class="s1">bw_method=</span><span class="s4">&quot;scott&quot;</span><span class="s2">, </span><span class="s1">bw_adjust=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">warn_singular=</span><span class="s2">True, </span><span class="s1">log_scale=</span><span class="s2">None,</span>
    <span class="s1">levels=</span><span class="s5">10</span><span class="s2">, </span><span class="s1">thresh=</span><span class="s5">.05</span><span class="s2">, </span><span class="s1">gridsize=</span><span class="s5">200</span><span class="s2">, </span><span class="s1">cut=</span><span class="s5">3</span><span class="s2">, </span><span class="s1">clip=</span><span class="s2">None,</span>
    <span class="s1">legend=</span><span class="s2">True, </span><span class="s1">cbar=</span><span class="s2">False, </span><span class="s1">cbar_ax=</span><span class="s2">None, </span><span class="s1">cbar_kws=</span><span class="s2">None, </span><span class="s1">ax=</span><span class="s2">None,</span>
    <span class="s1">**kwargs</span><span class="s2">,</span>
<span class="s1">):</span>

    <span class="s3"># --- Start with backwards compatability for versions &lt; 0.11.0 ----------------</span>

    <span class="s3"># Handle (past) deprecation of `data2`</span>
    <span class="s2">if </span><span class="s4">&quot;data2&quot; </span><span class="s2">in </span><span class="s1">kwargs:</span>
        <span class="s1">msg = </span><span class="s4">&quot;`data2` has been removed (replaced by `y`); please update your code.&quot;</span>
        <span class="s1">TypeError(msg)</span>

    <span class="s3"># Handle deprecation of `vertical`</span>
    <span class="s1">vertical = kwargs.pop(</span><span class="s4">&quot;vertical&quot;</span><span class="s2">, None</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">vertical </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">vertical:</span>
            <span class="s1">action_taken = </span><span class="s4">&quot;assigning data to `y`.&quot;</span>
            <span class="s2">if </span><span class="s1">x </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">data</span><span class="s2">, </span><span class="s1">y = y</span><span class="s2">, </span><span class="s1">data</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">x</span><span class="s2">, </span><span class="s1">y = y</span><span class="s2">, </span><span class="s1">x</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">action_taken = </span><span class="s4">&quot;assigning data to `x`.&quot;</span>
        <span class="s1">msg = textwrap.dedent(</span><span class="s4">f&quot;&quot;&quot;</span><span class="s2">\n</span>
        <span class="s4">The `vertical` parameter is deprecated; </span><span class="s2">{</span><span class="s1">action_taken</span><span class="s2">}</span>
        <span class="s4">This will become an error in seaborn v0.14.0; please update your code.</span>
        <span class="s4">&quot;&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">warnings.warn(msg</span><span class="s2">, </span><span class="s1">UserWarning</span><span class="s2">, </span><span class="s1">stacklevel=</span><span class="s5">2</span><span class="s1">)</span>

    <span class="s3"># Handle deprecation of `bw`</span>
    <span class="s1">bw = kwargs.pop(</span><span class="s4">&quot;bw&quot;</span><span class="s2">, None</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">bw </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">msg = textwrap.dedent(</span><span class="s4">f&quot;&quot;&quot;</span><span class="s2">\n</span>
        <span class="s4">The `bw` parameter is deprecated in favor of `bw_method` and `bw_adjust`.</span>
        <span class="s4">Setting `bw_method=</span><span class="s2">{</span><span class="s1">bw</span><span class="s2">}</span><span class="s4">`, but please see the docs for the new parameters</span>
        <span class="s4">and update your code. This will become an error in seaborn v0.14.0.</span>
        <span class="s4">&quot;&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">warnings.warn(msg</span><span class="s2">, </span><span class="s1">UserWarning</span><span class="s2">, </span><span class="s1">stacklevel=</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">bw_method = bw</span>

    <span class="s3"># Handle deprecation of `kernel`</span>
    <span class="s2">if </span><span class="s1">kwargs.pop(</span><span class="s4">&quot;kernel&quot;</span><span class="s2">, None</span><span class="s1">) </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">msg = textwrap.dedent(</span><span class="s4">&quot;&quot;&quot;</span><span class="s2">\n</span>
        <span class="s4">Support for alternate kernels has been removed; using Gaussian kernel. 
        This will become an error in seaborn v0.14.0; please update your code. 
        &quot;&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">warnings.warn(msg</span><span class="s2">, </span><span class="s1">UserWarning</span><span class="s2">, </span><span class="s1">stacklevel=</span><span class="s5">2</span><span class="s1">)</span>

    <span class="s3"># Handle deprecation of shade_lowest</span>
    <span class="s1">shade_lowest = kwargs.pop(</span><span class="s4">&quot;shade_lowest&quot;</span><span class="s2">, None</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">shade_lowest </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">shade_lowest:</span>
            <span class="s1">thresh = </span><span class="s5">0</span>
        <span class="s1">msg = textwrap.dedent(</span><span class="s4">f&quot;&quot;&quot;</span><span class="s2">\n</span>
        <span class="s4">`shade_lowest` has been replaced by `thresh`; setting `thresh=</span><span class="s2">{</span><span class="s1">thresh</span><span class="s2">}</span><span class="s4">.</span>
        <span class="s4">This will become an error in seaborn v0.14.0; please update your code.</span>
        <span class="s4">&quot;&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">warnings.warn(msg</span><span class="s2">, </span><span class="s1">UserWarning</span><span class="s2">, </span><span class="s1">stacklevel=</span><span class="s5">2</span><span class="s1">)</span>

    <span class="s3"># Handle &quot;soft&quot; deprecation of shade `shade` is not really the right</span>
    <span class="s3"># terminology here, but unlike some of the other deprecated parameters it</span>
    <span class="s3"># is probably very commonly used and much hard to remove. This is therefore</span>
    <span class="s3"># going to be a longer process where, first, `fill` will be introduced and</span>
    <span class="s3"># be used throughout the documentation. In 0.12, when kwarg-only</span>
    <span class="s3"># enforcement hits, we can remove the shade/shade_lowest out of the</span>
    <span class="s3"># function signature all together and pull them out of the kwargs. Then we</span>
    <span class="s3"># can actually fire a FutureWarning, and eventually remove.</span>
    <span class="s1">shade = kwargs.pop(</span><span class="s4">&quot;shade&quot;</span><span class="s2">, None</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">shade </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">fill = shade</span>
        <span class="s1">msg = textwrap.dedent(</span><span class="s4">f&quot;&quot;&quot;</span><span class="s2">\n</span>
        <span class="s4">`shade` is now deprecated in favor of `fill`; setting `fill=</span><span class="s2">{</span><span class="s1">shade</span><span class="s2">}</span><span class="s4">`.</span>
        <span class="s4">This will become an error in seaborn v0.14.0; please update your code.</span>
        <span class="s4">&quot;&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">warnings.warn(msg</span><span class="s2">, </span><span class="s1">FutureWarning</span><span class="s2">, </span><span class="s1">stacklevel=</span><span class="s5">2</span><span class="s1">)</span>

    <span class="s3"># Handle `n_levels`</span>
    <span class="s3"># This was never in the formal API but it was processed, and appeared in an</span>
    <span class="s3"># example. We can treat as an alias for `levels` now and deprecate later.</span>
    <span class="s1">levels = kwargs.pop(</span><span class="s4">&quot;n_levels&quot;</span><span class="s2">, </span><span class="s1">levels)</span>

    <span class="s3"># - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #</span>

    <span class="s1">p = _DistributionPlotter(</span>
        <span class="s1">data=data</span><span class="s2">,</span>
        <span class="s1">variables=dict(x=x</span><span class="s2">, </span><span class="s1">y=y</span><span class="s2">, </span><span class="s1">hue=hue</span><span class="s2">, </span><span class="s1">weights=weights)</span><span class="s2">,</span>
    <span class="s1">)</span>

    <span class="s1">p.map_hue(palette=palette</span><span class="s2">, </span><span class="s1">order=hue_order</span><span class="s2">, </span><span class="s1">norm=hue_norm)</span>

    <span class="s2">if </span><span class="s1">ax </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">ax = plt.gca()</span>

    <span class="s1">p._attach(ax</span><span class="s2">, </span><span class="s1">allowed_types=[</span><span class="s4">&quot;numeric&quot;</span><span class="s2">, </span><span class="s4">&quot;datetime&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">log_scale=log_scale)</span>

    <span class="s1">method = ax.fill_between </span><span class="s2">if </span><span class="s1">fill </span><span class="s2">else </span><span class="s1">ax.plot</span>
    <span class="s1">color = _default_color(method</span><span class="s2">, </span><span class="s1">hue</span><span class="s2">, </span><span class="s1">color</span><span class="s2">, </span><span class="s1">kwargs)</span>

    <span class="s2">if not </span><span class="s1">p.has_xy_data:</span>
        <span class="s2">return </span><span class="s1">ax</span>

    <span class="s3"># Pack the kwargs for statistics.KDE</span>
    <span class="s1">estimate_kws = dict(</span>
        <span class="s1">bw_method=bw_method</span><span class="s2">,</span>
        <span class="s1">bw_adjust=bw_adjust</span><span class="s2">,</span>
        <span class="s1">gridsize=gridsize</span><span class="s2">,</span>
        <span class="s1">cut=cut</span><span class="s2">,</span>
        <span class="s1">clip=clip</span><span class="s2">,</span>
        <span class="s1">cumulative=cumulative</span><span class="s2">,</span>
    <span class="s1">)</span>

    <span class="s2">if </span><span class="s1">p.univariate:</span>

        <span class="s1">plot_kws = kwargs.copy()</span>

        <span class="s1">p.plot_univariate_density(</span>
            <span class="s1">multiple=multiple</span><span class="s2">,</span>
            <span class="s1">common_norm=common_norm</span><span class="s2">,</span>
            <span class="s1">common_grid=common_grid</span><span class="s2">,</span>
            <span class="s1">fill=fill</span><span class="s2">,</span>
            <span class="s1">color=color</span><span class="s2">,</span>
            <span class="s1">legend=legend</span><span class="s2">,</span>
            <span class="s1">warn_singular=warn_singular</span><span class="s2">,</span>
            <span class="s1">estimate_kws=estimate_kws</span><span class="s2">,</span>
            <span class="s1">**plot_kws</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">else</span><span class="s1">:</span>

        <span class="s1">p.plot_bivariate_density(</span>
            <span class="s1">common_norm=common_norm</span><span class="s2">,</span>
            <span class="s1">fill=fill</span><span class="s2">,</span>
            <span class="s1">levels=levels</span><span class="s2">,</span>
            <span class="s1">thresh=thresh</span><span class="s2">,</span>
            <span class="s1">legend=legend</span><span class="s2">,</span>
            <span class="s1">color=color</span><span class="s2">,</span>
            <span class="s1">warn_singular=warn_singular</span><span class="s2">,</span>
            <span class="s1">cbar=cbar</span><span class="s2">,</span>
            <span class="s1">cbar_ax=cbar_ax</span><span class="s2">,</span>
            <span class="s1">cbar_kws=cbar_kws</span><span class="s2">,</span>
            <span class="s1">estimate_kws=estimate_kws</span><span class="s2">,</span>
            <span class="s1">**kwargs</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">return </span><span class="s1">ax</span>


<span class="s1">kdeplot.__doc__ = </span><span class="s4">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s4">Plot univariate or bivariate distributions using kernel density estimation. 
 
A kernel density estimate (KDE) plot is a method for visualizing the 
distribution of observations in a dataset, analogous to a histogram. KDE 
represents the data using a continuous probability density curve in one or 
more dimensions. 
 
The approach is explained further in the :ref:`user guide &lt;tutorial_kde&gt;`. 
 
Relative to a histogram, KDE can produce a plot that is less cluttered and 
more interpretable, especially when drawing multiple distributions. But it 
has the potential to introduce distortions if the underlying distribution is 
bounded or not smooth. Like a histogram, the quality of the representation 
also depends on the selection of good smoothing parameters. 
 
Parameters 
---------- 
{params.core.data} 
{params.core.xy} 
{params.core.hue} 
weights : vector or key in ``data`` 
    If provided, weight the kernel density estimation using these values. 
{params.core.palette} 
{params.core.hue_order} 
{params.core.hue_norm} 
{params.core.color} 
fill : bool or None 
    If True, fill in the area under univariate density curves or between 
    bivariate contours. If None, the default depends on ``multiple``. 
{params.dist.multiple} 
common_norm : bool 
    If True, scale each conditional density by the number of observations 
    such that the total area under all densities sums to 1. Otherwise, 
    normalize each density independently. 
common_grid : bool 
    If True, use the same evaluation grid for each kernel density estimate. 
    Only relevant with univariate data. 
{params.kde.cumulative} 
{params.kde.bw_method} 
{params.kde.bw_adjust} 
warn_singular : bool 
    If True, issue a warning when trying to estimate the density of data 
    with zero variance. 
{params.dist.log_scale} 
levels : int or vector 
    Number of contour levels or values to draw contours at. A vector argument 
    must have increasing values in [0, 1]. Levels correspond to iso-proportions 
    of the density: e.g., 20% of the probability mass will lie below the 
    contour drawn for 0.2. Only relevant with bivariate data. 
thresh : number in [0, 1] 
    Lowest iso-proportion level at which to draw a contour line. Ignored when 
    ``levels`` is a vector. Only relevant with bivariate data. 
gridsize : int 
    Number of points on each dimension of the evaluation grid. 
{params.kde.cut} 
{params.kde.clip} 
{params.dist.legend} 
{params.dist.cbar} 
{params.dist.cbar_ax} 
{params.dist.cbar_kws} 
{params.core.ax} 
kwargs 
    Other keyword arguments are passed to one of the following matplotlib 
    functions: 
 
    - :meth:`matplotlib.axes.Axes.plot` (univariate, ``fill=False``), 
    - :meth:`matplotlib.axes.Axes.fill_between` (univariate, ``fill=True``), 
    - :meth:`matplotlib.axes.Axes.contour` (bivariate, ``fill=False``), 
    - :meth:`matplotlib.axes.contourf` (bivariate, ``fill=True``). 
 
Returns 
------- 
{returns.ax} 
 
See Also 
-------- 
{seealso.displot} 
{seealso.histplot} 
{seealso.ecdfplot} 
{seealso.jointplot} 
{seealso.violinplot} 
 
Notes 
----- 
 
The *bandwidth*, or standard deviation of the smoothing kernel, is an 
important parameter. Misspecification of the bandwidth can produce a 
distorted representation of the data. Much like the choice of bin width in a 
histogram, an over-smoothed curve can erase true features of a 
distribution, while an under-smoothed curve can create false features out of 
random variability. The rule-of-thumb that sets the default bandwidth works 
best when the true distribution is smooth, unimodal, and roughly bell-shaped. 
It is always a good idea to check the default behavior by using ``bw_adjust`` 
to increase or decrease the amount of smoothing. 
 
Because the smoothing algorithm uses a Gaussian kernel, the estimated density 
curve can extend to values that do not make sense for a particular dataset. 
For example, the curve may be drawn over negative values when smoothing data 
that are naturally positive. The ``cut`` and ``clip`` parameters can be used 
to control the extent of the curve, but datasets that have many observations 
close to a natural boundary may be better served by a different visualization 
method. 
 
Similar considerations apply when a dataset is naturally discrete or &quot;spiky&quot; 
(containing many repeated observations of the same value). Kernel density 
estimation will always produce a smooth curve, which would be misleading 
in these situations. 
 
The units on the density axis are a common source of confusion. While kernel 
density estimation produces a probability distribution, the height of the curve 
at each point gives a density, not a probability. A probability can be obtained 
only by integrating the density across a range. The curve is normalized so 
that the integral over all possible values is 1, meaning that the scale of 
the density axis depends on the data values. 
 
Examples 
-------- 
 
.. include:: ../docstrings/kdeplot.rst 
 
&quot;&quot;&quot;</span><span class="s1">.format(</span>
    <span class="s1">params=_param_docs</span><span class="s2">,</span>
    <span class="s1">returns=_core_docs[</span><span class="s4">&quot;returns&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">seealso=_core_docs[</span><span class="s4">&quot;seealso&quot;</span><span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>


<span class="s2">def </span><span class="s1">ecdfplot(</span>
    <span class="s1">data=</span><span class="s2">None, </span><span class="s1">*</span><span class="s2">,</span>
    <span class="s3"># Vector variables</span>
    <span class="s1">x=</span><span class="s2">None, </span><span class="s1">y=</span><span class="s2">None, </span><span class="s1">hue=</span><span class="s2">None, </span><span class="s1">weights=</span><span class="s2">None,</span>
    <span class="s3"># Computation parameters</span>
    <span class="s1">stat=</span><span class="s4">&quot;proportion&quot;</span><span class="s2">, </span><span class="s1">complementary=</span><span class="s2">False,</span>
    <span class="s3"># Hue mapping parameters</span>
    <span class="s1">palette=</span><span class="s2">None, </span><span class="s1">hue_order=</span><span class="s2">None, </span><span class="s1">hue_norm=</span><span class="s2">None,</span>
    <span class="s3"># Axes information</span>
    <span class="s1">log_scale=</span><span class="s2">None, </span><span class="s1">legend=</span><span class="s2">True, </span><span class="s1">ax=</span><span class="s2">None,</span>
    <span class="s3"># Other appearance keywords</span>
    <span class="s1">**kwargs</span><span class="s2">,</span>
<span class="s1">):</span>

    <span class="s1">p = _DistributionPlotter(</span>
        <span class="s1">data=data</span><span class="s2">,</span>
        <span class="s1">variables=dict(x=x</span><span class="s2">, </span><span class="s1">y=y</span><span class="s2">, </span><span class="s1">hue=hue</span><span class="s2">, </span><span class="s1">weights=weights)</span><span class="s2">,</span>
    <span class="s1">)</span>

    <span class="s1">p.map_hue(palette=palette</span><span class="s2">, </span><span class="s1">order=hue_order</span><span class="s2">, </span><span class="s1">norm=hue_norm)</span>

    <span class="s3"># We could support other semantics (size, style) here fairly easily</span>
    <span class="s3"># But it would make distplot a bit more complicated.</span>
    <span class="s3"># It's always possible to add features like that later, so I am going to defer.</span>
    <span class="s3"># It will be even easier to wait until after there is a more general/abstract</span>
    <span class="s3"># way to go from semantic specs to artist attributes.</span>

    <span class="s2">if </span><span class="s1">ax </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">ax = plt.gca()</span>

    <span class="s1">p._attach(ax</span><span class="s2">, </span><span class="s1">log_scale=log_scale)</span>

    <span class="s1">color = kwargs.pop(</span><span class="s4">&quot;color&quot;</span><span class="s2">, </span><span class="s1">kwargs.pop(</span><span class="s4">&quot;c&quot;</span><span class="s2">, None</span><span class="s1">))</span>
    <span class="s1">kwargs[</span><span class="s4">&quot;color&quot;</span><span class="s1">] = _default_color(ax.plot</span><span class="s2">, </span><span class="s1">hue</span><span class="s2">, </span><span class="s1">color</span><span class="s2">, </span><span class="s1">kwargs)</span>

    <span class="s2">if not </span><span class="s1">p.has_xy_data:</span>
        <span class="s2">return </span><span class="s1">ax</span>

    <span class="s3"># We could add this one day, but it's of dubious value</span>
    <span class="s2">if not </span><span class="s1">p.univariate:</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;Bivariate ECDF plots are not implemented&quot;</span><span class="s1">)</span>

    <span class="s1">estimate_kws = dict(</span>
        <span class="s1">stat=stat</span><span class="s2">,</span>
        <span class="s1">complementary=complementary</span><span class="s2">,</span>
    <span class="s1">)</span>

    <span class="s1">p.plot_univariate_ecdf(</span>
        <span class="s1">estimate_kws=estimate_kws</span><span class="s2">,</span>
        <span class="s1">legend=legend</span><span class="s2">,</span>
        <span class="s1">**kwargs</span><span class="s2">,</span>
    <span class="s1">)</span>

    <span class="s2">return </span><span class="s1">ax</span>


<span class="s1">ecdfplot.__doc__ = </span><span class="s4">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s4">Plot empirical cumulative distribution functions. 
 
An ECDF represents the proportion or count of observations falling below each 
unique value in a dataset. Compared to a histogram or density plot, it has the 
advantage that each observation is visualized directly, meaning that there are 
no binning or smoothing parameters that need to be adjusted. It also aids direct 
comparisons between multiple distributions. A downside is that the relationship 
between the appearance of the plot and the basic properties of the distribution 
(such as its central tendency, variance, and the presence of any bimodality) 
may not be as intuitive. 
 
More information is provided in the :ref:`user guide &lt;tutorial_ecdf&gt;`. 
 
Parameters 
---------- 
{params.core.data} 
{params.core.xy} 
{params.core.hue} 
weights : vector or key in ``data`` 
    If provided, weight the contribution of the corresponding data points 
    towards the cumulative distribution using these values. 
{params.ecdf.stat} 
{params.ecdf.complementary} 
{params.core.palette} 
{params.core.hue_order} 
{params.core.hue_norm} 
{params.dist.log_scale} 
{params.dist.legend} 
{params.core.ax} 
kwargs 
    Other keyword arguments are passed to :meth:`matplotlib.axes.Axes.plot`. 
 
Returns 
------- 
{returns.ax} 
 
See Also 
-------- 
{seealso.displot} 
{seealso.histplot} 
{seealso.kdeplot} 
{seealso.rugplot} 
 
Examples 
-------- 
 
.. include:: ../docstrings/ecdfplot.rst 
 
&quot;&quot;&quot;</span><span class="s1">.format(</span>
    <span class="s1">params=_param_docs</span><span class="s2">,</span>
    <span class="s1">returns=_core_docs[</span><span class="s4">&quot;returns&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">seealso=_core_docs[</span><span class="s4">&quot;seealso&quot;</span><span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>


<span class="s2">def </span><span class="s1">rugplot(</span>
    <span class="s1">data=</span><span class="s2">None, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">x=</span><span class="s2">None, </span><span class="s1">y=</span><span class="s2">None, </span><span class="s1">hue=</span><span class="s2">None, </span><span class="s1">height=</span><span class="s5">.025</span><span class="s2">, </span><span class="s1">expand_margins=</span><span class="s2">True,</span>
    <span class="s1">palette=</span><span class="s2">None, </span><span class="s1">hue_order=</span><span class="s2">None, </span><span class="s1">hue_norm=</span><span class="s2">None, </span><span class="s1">legend=</span><span class="s2">True, </span><span class="s1">ax=</span><span class="s2">None, </span><span class="s1">**kwargs</span>
<span class="s1">):</span>

    <span class="s3"># A note: I think it would make sense to add multiple= to rugplot and allow</span>
    <span class="s3"># rugs for different hue variables to be shifted orthogonal to the data axis</span>
    <span class="s3"># But is this stacking, or dodging?</span>

    <span class="s3"># A note: if we want to add a style semantic to rugplot,</span>
    <span class="s3"># we could make an option that draws the rug using scatterplot</span>

    <span class="s3"># A note, it would also be nice to offer some kind of histogram/density</span>
    <span class="s3"># rugplot, since alpha blending doesn't work great in the large n regime</span>

    <span class="s3"># --- Start with backwards compatability for versions &lt; 0.11.0 ----------------</span>

    <span class="s1">a = kwargs.pop(</span><span class="s4">&quot;a&quot;</span><span class="s2">, None</span><span class="s1">)</span>
    <span class="s1">axis = kwargs.pop(</span><span class="s4">&quot;axis&quot;</span><span class="s2">, None</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">a </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">data = a</span>
        <span class="s1">msg = textwrap.dedent(</span><span class="s4">&quot;&quot;&quot;</span><span class="s2">\n</span>
        <span class="s4">The `a` parameter has been replaced; use `x`, `y`, and/or `data` instead. 
        Please update your code; This will become an error in seaborn v0.14.0. 
        &quot;&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">warnings.warn(msg</span><span class="s2">, </span><span class="s1">UserWarning</span><span class="s2">, </span><span class="s1">stacklevel=</span><span class="s5">2</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">axis </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">axis == </span><span class="s4">&quot;x&quot;</span><span class="s1">:</span>
            <span class="s1">x = data</span>
        <span class="s2">elif </span><span class="s1">axis == </span><span class="s4">&quot;y&quot;</span><span class="s1">:</span>
            <span class="s1">y = data</span>
        <span class="s1">data = </span><span class="s2">None</span>
        <span class="s1">msg = textwrap.dedent(</span><span class="s4">f&quot;&quot;&quot;</span><span class="s2">\n</span>
        <span class="s4">The `axis` parameter has been deprecated; use the `</span><span class="s2">{</span><span class="s1">axis</span><span class="s2">}</span><span class="s4">` parameter instead.</span>
        <span class="s4">Please update your code; this will become an error in seaborn v0.14.0.</span>
        <span class="s4">&quot;&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">warnings.warn(msg</span><span class="s2">, </span><span class="s1">UserWarning</span><span class="s2">, </span><span class="s1">stacklevel=</span><span class="s5">2</span><span class="s1">)</span>

    <span class="s1">vertical = kwargs.pop(</span><span class="s4">&quot;vertical&quot;</span><span class="s2">, None</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">vertical </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">vertical:</span>
            <span class="s1">action_taken = </span><span class="s4">&quot;assigning data to `y`.&quot;</span>
            <span class="s2">if </span><span class="s1">x </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">data</span><span class="s2">, </span><span class="s1">y = y</span><span class="s2">, </span><span class="s1">data</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">x</span><span class="s2">, </span><span class="s1">y = y</span><span class="s2">, </span><span class="s1">x</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">action_taken = </span><span class="s4">&quot;assigning data to `x`.&quot;</span>
        <span class="s1">msg = textwrap.dedent(</span><span class="s4">f&quot;&quot;&quot;</span><span class="s2">\n</span>
        <span class="s4">The `vertical` parameter is deprecated; </span><span class="s2">{</span><span class="s1">action_taken</span><span class="s2">}</span>
        <span class="s4">This will become an error in seaborn v0.14.0; please update your code.</span>
        <span class="s4">&quot;&quot;&quot;</span><span class="s1">)</span>
        <span class="s1">warnings.warn(msg</span><span class="s2">, </span><span class="s1">UserWarning</span><span class="s2">, </span><span class="s1">stacklevel=</span><span class="s5">2</span><span class="s1">)</span>

    <span class="s3"># - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - #</span>

    <span class="s1">p = _DistributionPlotter(</span>
        <span class="s1">data=data</span><span class="s2">,</span>
        <span class="s1">variables=dict(x=x</span><span class="s2">, </span><span class="s1">y=y</span><span class="s2">, </span><span class="s1">hue=hue)</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">p.map_hue(palette=palette</span><span class="s2">, </span><span class="s1">order=hue_order</span><span class="s2">, </span><span class="s1">norm=hue_norm)</span>

    <span class="s2">if </span><span class="s1">ax </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">ax = plt.gca()</span>

    <span class="s1">p._attach(ax)</span>

    <span class="s1">color = kwargs.pop(</span><span class="s4">&quot;color&quot;</span><span class="s2">, </span><span class="s1">kwargs.pop(</span><span class="s4">&quot;c&quot;</span><span class="s2">, None</span><span class="s1">))</span>
    <span class="s1">kwargs[</span><span class="s4">&quot;color&quot;</span><span class="s1">] = _default_color(ax.plot</span><span class="s2">, </span><span class="s1">hue</span><span class="s2">, </span><span class="s1">color</span><span class="s2">, </span><span class="s1">kwargs)</span>

    <span class="s2">if not </span><span class="s1">p.has_xy_data:</span>
        <span class="s2">return </span><span class="s1">ax</span>

    <span class="s1">p.plot_rug(height</span><span class="s2">, </span><span class="s1">expand_margins</span><span class="s2">, </span><span class="s1">legend</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">return </span><span class="s1">ax</span>


<span class="s1">rugplot.__doc__ = </span><span class="s4">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s4">Plot marginal distributions by drawing ticks along the x and y axes. 
 
This function is intended to complement other plots by showing the location 
of individual observations in an unobtrusive way. 
 
Parameters 
---------- 
{params.core.data} 
{params.core.xy} 
{params.core.hue} 
height : float 
    Proportion of axes extent covered by each rug element. Can be negative. 
expand_margins : bool 
    If True, increase the axes margins by the height of the rug to avoid 
    overlap with other elements. 
{params.core.palette} 
{params.core.hue_order} 
{params.core.hue_norm} 
legend : bool 
    If False, do not add a legend for semantic variables. 
{params.core.ax} 
kwargs 
    Other keyword arguments are passed to 
    :meth:`matplotlib.collections.LineCollection` 
 
Returns 
------- 
{returns.ax} 
 
Examples 
-------- 
 
.. include:: ../docstrings/rugplot.rst 
 
&quot;&quot;&quot;</span><span class="s1">.format(</span>
    <span class="s1">params=_param_docs</span><span class="s2">,</span>
    <span class="s1">returns=_core_docs[</span><span class="s4">&quot;returns&quot;</span><span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>


<span class="s2">def </span><span class="s1">displot(</span>
    <span class="s1">data=</span><span class="s2">None, </span><span class="s1">*</span><span class="s2">,</span>
    <span class="s3"># Vector variables</span>
    <span class="s1">x=</span><span class="s2">None, </span><span class="s1">y=</span><span class="s2">None, </span><span class="s1">hue=</span><span class="s2">None, </span><span class="s1">row=</span><span class="s2">None, </span><span class="s1">col=</span><span class="s2">None, </span><span class="s1">weights=</span><span class="s2">None,</span>
    <span class="s3"># Other plot parameters</span>
    <span class="s1">kind=</span><span class="s4">&quot;hist&quot;</span><span class="s2">, </span><span class="s1">rug=</span><span class="s2">False, </span><span class="s1">rug_kws=</span><span class="s2">None, </span><span class="s1">log_scale=</span><span class="s2">None, </span><span class="s1">legend=</span><span class="s2">True,</span>
    <span class="s3"># Hue-mapping parameters</span>
    <span class="s1">palette=</span><span class="s2">None, </span><span class="s1">hue_order=</span><span class="s2">None, </span><span class="s1">hue_norm=</span><span class="s2">None, </span><span class="s1">color=</span><span class="s2">None,</span>
    <span class="s3"># Faceting parameters</span>
    <span class="s1">col_wrap=</span><span class="s2">None, </span><span class="s1">row_order=</span><span class="s2">None, </span><span class="s1">col_order=</span><span class="s2">None,</span>
    <span class="s1">height=</span><span class="s5">5</span><span class="s2">, </span><span class="s1">aspect=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">facet_kws=</span><span class="s2">None,</span>
    <span class="s1">**kwargs</span><span class="s2">,</span>
<span class="s1">):</span>

    <span class="s1">p = _DistributionPlotter(</span>
        <span class="s1">data=data</span><span class="s2">,</span>
        <span class="s1">variables=dict(x=x</span><span class="s2">, </span><span class="s1">y=y</span><span class="s2">, </span><span class="s1">hue=hue</span><span class="s2">, </span><span class="s1">weights=weights</span><span class="s2">, </span><span class="s1">row=row</span><span class="s2">, </span><span class="s1">col=col)</span><span class="s2">,</span>
    <span class="s1">)</span>

    <span class="s1">p.map_hue(palette=palette</span><span class="s2">, </span><span class="s1">order=hue_order</span><span class="s2">, </span><span class="s1">norm=hue_norm)</span>

    <span class="s1">_check_argument(</span><span class="s4">&quot;kind&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s4">&quot;hist&quot;</span><span class="s2">, </span><span class="s4">&quot;kde&quot;</span><span class="s2">, </span><span class="s4">&quot;ecdf&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">kind)</span>

    <span class="s3"># --- Initialize the FacetGrid object</span>

    <span class="s3"># Check for attempt to plot onto specific axes and warn</span>
    <span class="s2">if </span><span class="s4">&quot;ax&quot; </span><span class="s2">in </span><span class="s1">kwargs:</span>
        <span class="s1">msg = (</span>
            <span class="s4">&quot;`displot` is a figure-level function and does not accept &quot;</span>
            <span class="s4">&quot;the ax= parameter. You may wish to try {}plot.&quot;</span><span class="s1">.format(kind)</span>
        <span class="s1">)</span>
        <span class="s1">warnings.warn(msg</span><span class="s2">, </span><span class="s1">UserWarning)</span>
        <span class="s1">kwargs.pop(</span><span class="s4">&quot;ax&quot;</span><span class="s1">)</span>

    <span class="s2">for </span><span class="s1">var </span><span class="s2">in </span><span class="s1">[</span><span class="s4">&quot;row&quot;</span><span class="s2">, </span><span class="s4">&quot;col&quot;</span><span class="s1">]:</span>
        <span class="s3"># Handle faceting variables that lack name information</span>
        <span class="s2">if </span><span class="s1">var </span><span class="s2">in </span><span class="s1">p.variables </span><span class="s2">and </span><span class="s1">p.variables[var] </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">p.variables[var] = </span><span class="s4">f&quot;_</span><span class="s2">{</span><span class="s1">var</span><span class="s2">}</span><span class="s4">_&quot;</span>

    <span class="s3"># Adapt the plot_data dataframe for use with FacetGrid</span>
    <span class="s1">grid_data = p.plot_data.rename(columns=p.variables)</span>
    <span class="s1">grid_data = grid_data.loc[:</span><span class="s2">, </span><span class="s1">~grid_data.columns.duplicated()]</span>

    <span class="s1">col_name = p.variables.get(</span><span class="s4">&quot;col&quot;</span><span class="s1">)</span>
    <span class="s1">row_name = p.variables.get(</span><span class="s4">&quot;row&quot;</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">facet_kws </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">facet_kws = {}</span>

    <span class="s1">g = FacetGrid(</span>
        <span class="s1">data=grid_data</span><span class="s2">, </span><span class="s1">row=row_name</span><span class="s2">, </span><span class="s1">col=col_name</span><span class="s2">,</span>
        <span class="s1">col_wrap=col_wrap</span><span class="s2">, </span><span class="s1">row_order=row_order</span><span class="s2">,</span>
        <span class="s1">col_order=col_order</span><span class="s2">, </span><span class="s1">height=height</span><span class="s2">,</span>
        <span class="s1">aspect=aspect</span><span class="s2">,</span>
        <span class="s1">**facet_kws</span><span class="s2">,</span>
    <span class="s1">)</span>

    <span class="s3"># Now attach the axes object to the plotter object</span>
    <span class="s2">if </span><span class="s1">kind == </span><span class="s4">&quot;kde&quot;</span><span class="s1">:</span>
        <span class="s1">allowed_types = [</span><span class="s4">&quot;numeric&quot;</span><span class="s2">, </span><span class="s4">&quot;datetime&quot;</span><span class="s1">]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">allowed_types = </span><span class="s2">None</span>
    <span class="s1">p._attach(g</span><span class="s2">, </span><span class="s1">allowed_types=allowed_types</span><span class="s2">, </span><span class="s1">log_scale=log_scale)</span>

    <span class="s3"># Check for a specification that lacks x/y data and return early</span>
    <span class="s2">if not </span><span class="s1">p.has_xy_data:</span>
        <span class="s2">return </span><span class="s1">g</span>

    <span class="s2">if </span><span class="s1">color </span><span class="s2">is None and </span><span class="s1">hue </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">color = </span><span class="s4">&quot;C0&quot;</span>
    <span class="s3"># XXX else warn if hue is not None?</span>

    <span class="s1">kwargs[</span><span class="s4">&quot;legend&quot;</span><span class="s1">] = legend</span>

    <span class="s3"># --- Draw the plots</span>

    <span class="s2">if </span><span class="s1">kind == </span><span class="s4">&quot;hist&quot;</span><span class="s1">:</span>

        <span class="s1">hist_kws = kwargs.copy()</span>

        <span class="s3"># Extract the parameters that will go directly to Histogram</span>
        <span class="s1">estimate_defaults = {}</span>
        <span class="s1">_assign_default_kwargs(estimate_defaults</span><span class="s2">, </span><span class="s1">Histogram.__init__</span><span class="s2">, </span><span class="s1">histplot)</span>

        <span class="s1">estimate_kws = {}</span>
        <span class="s2">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">default_val </span><span class="s2">in </span><span class="s1">estimate_defaults.items():</span>
            <span class="s1">estimate_kws[key] = hist_kws.pop(key</span><span class="s2">, </span><span class="s1">default_val)</span>

        <span class="s3"># Handle derivative defaults</span>
        <span class="s2">if </span><span class="s1">estimate_kws[</span><span class="s4">&quot;discrete&quot;</span><span class="s1">] </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">estimate_kws[</span><span class="s4">&quot;discrete&quot;</span><span class="s1">] = p._default_discrete()</span>

        <span class="s1">hist_kws[</span><span class="s4">&quot;estimate_kws&quot;</span><span class="s1">] = estimate_kws</span>

        <span class="s1">hist_kws.setdefault(</span><span class="s4">&quot;color&quot;</span><span class="s2">, </span><span class="s1">color)</span>

        <span class="s2">if </span><span class="s1">p.univariate:</span>

            <span class="s1">_assign_default_kwargs(hist_kws</span><span class="s2">, </span><span class="s1">p.plot_univariate_histogram</span><span class="s2">, </span><span class="s1">histplot)</span>
            <span class="s1">p.plot_univariate_histogram(**hist_kws)</span>

        <span class="s2">else</span><span class="s1">:</span>

            <span class="s1">_assign_default_kwargs(hist_kws</span><span class="s2">, </span><span class="s1">p.plot_bivariate_histogram</span><span class="s2">, </span><span class="s1">histplot)</span>
            <span class="s1">p.plot_bivariate_histogram(**hist_kws)</span>

    <span class="s2">elif </span><span class="s1">kind == </span><span class="s4">&quot;kde&quot;</span><span class="s1">:</span>

        <span class="s1">kde_kws = kwargs.copy()</span>

        <span class="s3"># Extract the parameters that will go directly to KDE</span>
        <span class="s1">estimate_defaults = {}</span>
        <span class="s1">_assign_default_kwargs(estimate_defaults</span><span class="s2">, </span><span class="s1">KDE.__init__</span><span class="s2">, </span><span class="s1">kdeplot)</span>

        <span class="s1">estimate_kws = {}</span>
        <span class="s2">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">default_val </span><span class="s2">in </span><span class="s1">estimate_defaults.items():</span>
            <span class="s1">estimate_kws[key] = kde_kws.pop(key</span><span class="s2">, </span><span class="s1">default_val)</span>

        <span class="s1">kde_kws[</span><span class="s4">&quot;estimate_kws&quot;</span><span class="s1">] = estimate_kws</span>
        <span class="s1">kde_kws[</span><span class="s4">&quot;color&quot;</span><span class="s1">] = color</span>

        <span class="s2">if </span><span class="s1">p.univariate:</span>

            <span class="s1">_assign_default_kwargs(kde_kws</span><span class="s2">, </span><span class="s1">p.plot_univariate_density</span><span class="s2">, </span><span class="s1">kdeplot)</span>
            <span class="s1">p.plot_univariate_density(**kde_kws)</span>

        <span class="s2">else</span><span class="s1">:</span>

            <span class="s1">_assign_default_kwargs(kde_kws</span><span class="s2">, </span><span class="s1">p.plot_bivariate_density</span><span class="s2">, </span><span class="s1">kdeplot)</span>
            <span class="s1">p.plot_bivariate_density(**kde_kws)</span>

    <span class="s2">elif </span><span class="s1">kind == </span><span class="s4">&quot;ecdf&quot;</span><span class="s1">:</span>

        <span class="s1">ecdf_kws = kwargs.copy()</span>

        <span class="s3"># Extract the parameters that will go directly to the estimator</span>
        <span class="s1">estimate_kws = {}</span>
        <span class="s1">estimate_defaults = {}</span>
        <span class="s1">_assign_default_kwargs(estimate_defaults</span><span class="s2">, </span><span class="s1">ECDF.__init__</span><span class="s2">, </span><span class="s1">ecdfplot)</span>
        <span class="s2">for </span><span class="s1">key</span><span class="s2">, </span><span class="s1">default_val </span><span class="s2">in </span><span class="s1">estimate_defaults.items():</span>
            <span class="s1">estimate_kws[key] = ecdf_kws.pop(key</span><span class="s2">, </span><span class="s1">default_val)</span>

        <span class="s1">ecdf_kws[</span><span class="s4">&quot;estimate_kws&quot;</span><span class="s1">] = estimate_kws</span>
        <span class="s1">ecdf_kws[</span><span class="s4">&quot;color&quot;</span><span class="s1">] = color</span>

        <span class="s2">if </span><span class="s1">p.univariate:</span>

            <span class="s1">_assign_default_kwargs(ecdf_kws</span><span class="s2">, </span><span class="s1">p.plot_univariate_ecdf</span><span class="s2">, </span><span class="s1">ecdfplot)</span>
            <span class="s1">p.plot_univariate_ecdf(**ecdf_kws)</span>

        <span class="s2">else</span><span class="s1">:</span>

            <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;Bivariate ECDF plots are not implemented&quot;</span><span class="s1">)</span>

    <span class="s3"># All plot kinds can include a rug</span>
    <span class="s2">if </span><span class="s1">rug:</span>
        <span class="s3"># TODO with expand_margins=True, each facet expands margins... annoying!</span>
        <span class="s2">if </span><span class="s1">rug_kws </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">rug_kws = {}</span>
        <span class="s1">_assign_default_kwargs(rug_kws</span><span class="s2">, </span><span class="s1">p.plot_rug</span><span class="s2">, </span><span class="s1">rugplot)</span>
        <span class="s1">rug_kws[</span><span class="s4">&quot;legend&quot;</span><span class="s1">] = </span><span class="s2">False</span>
        <span class="s2">if </span><span class="s1">color </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">rug_kws[</span><span class="s4">&quot;color&quot;</span><span class="s1">] = color</span>
        <span class="s1">p.plot_rug(**rug_kws)</span>

    <span class="s3"># Call FacetGrid annotation methods</span>
    <span class="s3"># Note that the legend is currently set inside the plotting method</span>
    <span class="s1">g.set_axis_labels(</span>
        <span class="s1">x_var=p.variables.get(</span><span class="s4">&quot;x&quot;</span><span class="s2">, </span><span class="s1">g.axes.flat[</span><span class="s5">0</span><span class="s1">].get_xlabel())</span><span class="s2">,</span>
        <span class="s1">y_var=p.variables.get(</span><span class="s4">&quot;y&quot;</span><span class="s2">, </span><span class="s1">g.axes.flat[</span><span class="s5">0</span><span class="s1">].get_ylabel())</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">g.set_titles()</span>
    <span class="s1">g.tight_layout()</span>

    <span class="s2">if </span><span class="s1">data </span><span class="s2">is not None and </span><span class="s1">(x </span><span class="s2">is not None or </span><span class="s1">y </span><span class="s2">is not None</span><span class="s1">):</span>
        <span class="s2">if not </span><span class="s1">isinstance(data</span><span class="s2">, </span><span class="s1">pd.DataFrame):</span>
            <span class="s1">data = pd.DataFrame(data)</span>
        <span class="s1">g.data = pd.merge(</span>
            <span class="s1">data</span><span class="s2">,</span>
            <span class="s1">g.data[g.data.columns.difference(data.columns)]</span><span class="s2">,</span>
            <span class="s1">left_index=</span><span class="s2">True,</span>
            <span class="s1">right_index=</span><span class="s2">True,</span>
        <span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">wide_cols = {</span>
            <span class="s1">k: </span><span class="s4">f&quot;_</span><span class="s2">{</span><span class="s1">k</span><span class="s2">}</span><span class="s4">_&quot; </span><span class="s2">if </span><span class="s1">v </span><span class="s2">is None else </span><span class="s1">v </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">p.variables.items()</span>
        <span class="s1">}</span>
        <span class="s1">g.data = p.plot_data.rename(columns=wide_cols)</span>

    <span class="s2">return </span><span class="s1">g</span>


<span class="s1">displot.__doc__ = </span><span class="s4">&quot;&quot;&quot;</span><span class="s2">\ 
</span><span class="s4">Figure-level interface for drawing distribution plots onto a FacetGrid. 
 
This function provides access to several approaches for visualizing the 
univariate or bivariate distribution of data, including subsets of data 
defined by semantic mapping and faceting across multiple subplots. The 
``kind`` parameter selects the approach to use: 
 
- :func:`histplot` (with ``kind=&quot;hist&quot;``; the default) 
- :func:`kdeplot` (with ``kind=&quot;kde&quot;``) 
- :func:`ecdfplot` (with ``kind=&quot;ecdf&quot;``; univariate-only) 
 
Additionally, a :func:`rugplot` can be added to any kind of plot to show 
individual observations. 
 
Extra keyword arguments are passed to the underlying function, so you should 
refer to the documentation for each to understand the complete set of options 
for making plots with this interface. 
 
See the :doc:`distribution plots tutorial &lt;../tutorial/distributions&gt;` for a more 
in-depth discussion of the relative strengths and weaknesses of each approach. 
The distinction between figure-level and axes-level functions is explained 
further in the :doc:`user guide &lt;../tutorial/function_overview&gt;`. 
 
Parameters 
---------- 
{params.core.data} 
{params.core.xy} 
{params.core.hue} 
{params.facets.rowcol} 
weights : vector or key in ``data`` 
    Observation weights used for computing the distribution function. 
kind : {{&quot;hist&quot;, &quot;kde&quot;, &quot;ecdf&quot;}} 
    Approach for visualizing the data. Selects the underlying plotting function 
    and determines the additional set of valid parameters. 
rug : bool 
    If True, show each observation with marginal ticks (as in :func:`rugplot`). 
rug_kws : dict 
    Parameters to control the appearance of the rug plot. 
{params.dist.log_scale} 
{params.dist.legend} 
{params.core.palette} 
{params.core.hue_order} 
{params.core.hue_norm} 
{params.core.color} 
{params.facets.col_wrap} 
{params.facets.rowcol_order} 
{params.facets.height} 
{params.facets.aspect} 
{params.facets.facet_kws} 
kwargs 
    Other keyword arguments are documented with the relevant axes-level function: 
 
    - :func:`histplot` (with ``kind=&quot;hist&quot;``) 
    - :func:`kdeplot` (with ``kind=&quot;kde&quot;``) 
    - :func:`ecdfplot` (with ``kind=&quot;ecdf&quot;``) 
 
Returns 
------- 
{returns.facetgrid} 
 
See Also 
-------- 
{seealso.histplot} 
{seealso.kdeplot} 
{seealso.rugplot} 
{seealso.ecdfplot} 
{seealso.jointplot} 
 
Examples 
-------- 
 
See the API documentation for the axes-level functions for more details 
about the breadth of options available for each plot kind. 
 
.. include:: ../docstrings/displot.rst 
 
&quot;&quot;&quot;</span><span class="s1">.format(</span>
    <span class="s1">params=_param_docs</span><span class="s2">,</span>
    <span class="s1">returns=_core_docs[</span><span class="s4">&quot;returns&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">seealso=_core_docs[</span><span class="s4">&quot;seealso&quot;</span><span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>


<span class="s3"># =========================================================================== #</span>
<span class="s3"># DEPRECATED FUNCTIONS LIVE BELOW HERE</span>
<span class="s3"># =========================================================================== #</span>


<span class="s2">def </span><span class="s1">_freedman_diaconis_bins(a):</span>
    <span class="s0">&quot;&quot;&quot;Calculate number of hist bins using Freedman-Diaconis rule.&quot;&quot;&quot;</span>
    <span class="s3"># From https://stats.stackexchange.com/questions/798/</span>
    <span class="s1">a = np.asarray(a)</span>
    <span class="s2">if </span><span class="s1">len(a) &lt; </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s5">1</span>
    <span class="s1">iqr = np.subtract.reduce(np.nanpercentile(a</span><span class="s2">, </span><span class="s1">[</span><span class="s5">75</span><span class="s2">, </span><span class="s5">25</span><span class="s1">]))</span>
    <span class="s1">h = </span><span class="s5">2 </span><span class="s1">* iqr / (len(a) ** (</span><span class="s5">1 </span><span class="s1">/ </span><span class="s5">3</span><span class="s1">))</span>
    <span class="s3"># fall back to sqrt(a) bins if iqr is 0</span>
    <span class="s2">if </span><span class="s1">h == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">int(np.sqrt(a.size))</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">int(np.ceil((a.max() - a.min()) / h))</span>


<span class="s2">def </span><span class="s1">distplot(a=</span><span class="s2">None, </span><span class="s1">bins=</span><span class="s2">None, </span><span class="s1">hist=</span><span class="s2">True, </span><span class="s1">kde=</span><span class="s2">True, </span><span class="s1">rug=</span><span class="s2">False, </span><span class="s1">fit=</span><span class="s2">None,</span>
             <span class="s1">hist_kws=</span><span class="s2">None, </span><span class="s1">kde_kws=</span><span class="s2">None, </span><span class="s1">rug_kws=</span><span class="s2">None, </span><span class="s1">fit_kws=</span><span class="s2">None,</span>
             <span class="s1">color=</span><span class="s2">None, </span><span class="s1">vertical=</span><span class="s2">False, </span><span class="s1">norm_hist=</span><span class="s2">False, </span><span class="s1">axlabel=</span><span class="s2">None,</span>
             <span class="s1">label=</span><span class="s2">None, </span><span class="s1">ax=</span><span class="s2">None, </span><span class="s1">x=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    DEPRECATED 
 
    This function has been deprecated and will be removed in seaborn v0.14.0. 
    It has been replaced by :func:`histplot` and :func:`displot`, two functions 
    with a modern API and many more capabilities. 
 
    For a guide to updating, please see this notebook: 
 
    https://gist.github.com/mwaskom/de44147ed2974457ad6372750bbe5751 
 
    &quot;&quot;&quot;</span>

    <span class="s2">if </span><span class="s1">kde </span><span class="s2">and not </span><span class="s1">hist:</span>
        <span class="s1">axes_level_suggestion = (</span>
            <span class="s4">&quot;`kdeplot` (an axes-level function for kernel density plots)&quot;</span>
        <span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">axes_level_suggestion = (</span>
            <span class="s4">&quot;`histplot` (an axes-level function for histograms)&quot;</span>
        <span class="s1">)</span>

    <span class="s1">msg = textwrap.dedent(</span><span class="s4">f&quot;&quot;&quot;</span>

    <span class="s4">`distplot` is a deprecated function and will be removed in seaborn v0.14.0.</span>

    <span class="s4">Please adapt your code to use either `displot` (a figure-level function with</span>
    <span class="s4">similar flexibility) or </span><span class="s2">{</span><span class="s1">axes_level_suggestion</span><span class="s2">}</span><span class="s4">.</span>

    <span class="s4">For a guide to updating your code to use the new functions, please see</span>
    <span class="s4">https://gist.github.com/mwaskom/de44147ed2974457ad6372750bbe5751</span>
    <span class="s4">&quot;&quot;&quot;</span><span class="s1">)</span>
    <span class="s1">warnings.warn(msg</span><span class="s2">, </span><span class="s1">UserWarning</span><span class="s2">, </span><span class="s1">stacklevel=</span><span class="s5">2</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">ax </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">ax = plt.gca()</span>

    <span class="s3"># Intelligently label the support axis</span>
    <span class="s1">label_ax = bool(axlabel)</span>
    <span class="s2">if </span><span class="s1">axlabel </span><span class="s2">is None and </span><span class="s1">hasattr(a</span><span class="s2">, </span><span class="s4">&quot;name&quot;</span><span class="s1">):</span>
        <span class="s1">axlabel = a.name</span>
        <span class="s2">if </span><span class="s1">axlabel </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">label_ax = </span><span class="s2">True</span>

    <span class="s3"># Support new-style API</span>
    <span class="s2">if </span><span class="s1">x </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">a = x</span>

    <span class="s3"># Make a a 1-d float array</span>
    <span class="s1">a = np.asarray(a</span><span class="s2">, </span><span class="s1">float)</span>
    <span class="s2">if </span><span class="s1">a.ndim &gt; </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">a = a.squeeze()</span>

    <span class="s3"># Drop null values from array</span>
    <span class="s1">a = remove_na(a)</span>

    <span class="s3"># Decide if the hist is normed</span>
    <span class="s1">norm_hist = norm_hist </span><span class="s2">or </span><span class="s1">kde </span><span class="s2">or </span><span class="s1">(fit </span><span class="s2">is not None</span><span class="s1">)</span>

    <span class="s3"># Handle dictionary defaults</span>
    <span class="s1">hist_kws = {} </span><span class="s2">if </span><span class="s1">hist_kws </span><span class="s2">is None else </span><span class="s1">hist_kws.copy()</span>
    <span class="s1">kde_kws = {} </span><span class="s2">if </span><span class="s1">kde_kws </span><span class="s2">is None else </span><span class="s1">kde_kws.copy()</span>
    <span class="s1">rug_kws = {} </span><span class="s2">if </span><span class="s1">rug_kws </span><span class="s2">is None else </span><span class="s1">rug_kws.copy()</span>
    <span class="s1">fit_kws = {} </span><span class="s2">if </span><span class="s1">fit_kws </span><span class="s2">is None else </span><span class="s1">fit_kws.copy()</span>

    <span class="s3"># Get the color from the current color cycle</span>
    <span class="s2">if </span><span class="s1">color </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">vertical:</span>
            <span class="s1">line</span><span class="s2">, </span><span class="s1">= ax.plot(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">a.mean())</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">line</span><span class="s2">, </span><span class="s1">= ax.plot(a.mean()</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">color = line.get_color()</span>
        <span class="s1">line.remove()</span>

    <span class="s3"># Plug the label into the right kwarg dictionary</span>
    <span class="s2">if </span><span class="s1">label </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">hist:</span>
            <span class="s1">hist_kws[</span><span class="s4">&quot;label&quot;</span><span class="s1">] = label</span>
        <span class="s2">elif </span><span class="s1">kde:</span>
            <span class="s1">kde_kws[</span><span class="s4">&quot;label&quot;</span><span class="s1">] = label</span>
        <span class="s2">elif </span><span class="s1">rug:</span>
            <span class="s1">rug_kws[</span><span class="s4">&quot;label&quot;</span><span class="s1">] = label</span>
        <span class="s2">elif </span><span class="s1">fit:</span>
            <span class="s1">fit_kws[</span><span class="s4">&quot;label&quot;</span><span class="s1">] = label</span>

    <span class="s2">if </span><span class="s1">hist:</span>
        <span class="s2">if </span><span class="s1">bins </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">bins = min(_freedman_diaconis_bins(a)</span><span class="s2">, </span><span class="s5">50</span><span class="s1">)</span>
        <span class="s1">hist_kws.setdefault(</span><span class="s4">&quot;alpha&quot;</span><span class="s2">, </span><span class="s5">0.4</span><span class="s1">)</span>
        <span class="s1">hist_kws.setdefault(</span><span class="s4">&quot;density&quot;</span><span class="s2">, </span><span class="s1">norm_hist)</span>

        <span class="s1">orientation = </span><span class="s4">&quot;horizontal&quot; </span><span class="s2">if </span><span class="s1">vertical </span><span class="s2">else </span><span class="s4">&quot;vertical&quot;</span>
        <span class="s1">hist_color = hist_kws.pop(</span><span class="s4">&quot;color&quot;</span><span class="s2">, </span><span class="s1">color)</span>
        <span class="s1">ax.hist(a</span><span class="s2">, </span><span class="s1">bins</span><span class="s2">, </span><span class="s1">orientation=orientation</span><span class="s2">,</span>
                <span class="s1">color=hist_color</span><span class="s2">, </span><span class="s1">**hist_kws)</span>
        <span class="s2">if </span><span class="s1">hist_color != color:</span>
            <span class="s1">hist_kws[</span><span class="s4">&quot;color&quot;</span><span class="s1">] = hist_color</span>

    <span class="s1">axis = </span><span class="s4">&quot;y&quot; </span><span class="s2">if </span><span class="s1">vertical </span><span class="s2">else </span><span class="s4">&quot;x&quot;</span>

    <span class="s2">if </span><span class="s1">kde:</span>
        <span class="s1">kde_color = kde_kws.pop(</span><span class="s4">&quot;color&quot;</span><span class="s2">, </span><span class="s1">color)</span>
        <span class="s1">kdeplot(**{axis: a}</span><span class="s2">, </span><span class="s1">ax=ax</span><span class="s2">, </span><span class="s1">color=kde_color</span><span class="s2">, </span><span class="s1">**kde_kws)</span>
        <span class="s2">if </span><span class="s1">kde_color != color:</span>
            <span class="s1">kde_kws[</span><span class="s4">&quot;color&quot;</span><span class="s1">] = kde_color</span>

    <span class="s2">if </span><span class="s1">rug:</span>
        <span class="s1">rug_color = rug_kws.pop(</span><span class="s4">&quot;color&quot;</span><span class="s2">, </span><span class="s1">color)</span>
        <span class="s1">rugplot(**{axis: a}</span><span class="s2">, </span><span class="s1">ax=ax</span><span class="s2">, </span><span class="s1">color=rug_color</span><span class="s2">, </span><span class="s1">**rug_kws)</span>
        <span class="s2">if </span><span class="s1">rug_color != color:</span>
            <span class="s1">rug_kws[</span><span class="s4">&quot;color&quot;</span><span class="s1">] = rug_color</span>

    <span class="s2">if </span><span class="s1">fit </span><span class="s2">is not None</span><span class="s1">:</span>

        <span class="s2">def </span><span class="s1">pdf(x):</span>
            <span class="s2">return </span><span class="s1">fit.pdf(x</span><span class="s2">, </span><span class="s1">*params)</span>

        <span class="s1">fit_color = fit_kws.pop(</span><span class="s4">&quot;color&quot;</span><span class="s2">, </span><span class="s4">&quot;#282828&quot;</span><span class="s1">)</span>
        <span class="s1">gridsize = fit_kws.pop(</span><span class="s4">&quot;gridsize&quot;</span><span class="s2">, </span><span class="s5">200</span><span class="s1">)</span>
        <span class="s1">cut = fit_kws.pop(</span><span class="s4">&quot;cut&quot;</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span>
        <span class="s1">clip = fit_kws.pop(</span><span class="s4">&quot;clip&quot;</span><span class="s2">, </span><span class="s1">(-np.inf</span><span class="s2">, </span><span class="s1">np.inf))</span>
        <span class="s1">bw = gaussian_kde(a).scotts_factor() * a.std(ddof=</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">x = _kde_support(a</span><span class="s2">, </span><span class="s1">bw</span><span class="s2">, </span><span class="s1">gridsize</span><span class="s2">, </span><span class="s1">cut</span><span class="s2">, </span><span class="s1">clip)</span>
        <span class="s1">params = fit.fit(a)</span>
        <span class="s1">y = pdf(x)</span>
        <span class="s2">if </span><span class="s1">vertical:</span>
            <span class="s1">x</span><span class="s2">, </span><span class="s1">y = y</span><span class="s2">, </span><span class="s1">x</span>
        <span class="s1">ax.plot(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">color=fit_color</span><span class="s2">, </span><span class="s1">**fit_kws)</span>
        <span class="s2">if </span><span class="s1">fit_color != </span><span class="s4">&quot;#282828&quot;</span><span class="s1">:</span>
            <span class="s1">fit_kws[</span><span class="s4">&quot;color&quot;</span><span class="s1">] = fit_color</span>

    <span class="s2">if </span><span class="s1">label_ax:</span>
        <span class="s2">if </span><span class="s1">vertical:</span>
            <span class="s1">ax.set_ylabel(axlabel)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">ax.set_xlabel(axlabel)</span>

    <span class="s2">return </span><span class="s1">ax</span>
</pre>
</body>
</html>