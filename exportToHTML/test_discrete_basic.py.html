<html>
<head>
<title>test_discrete_basic.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6897bb;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_discrete_basic.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">numpy.testing </span><span class="s0">as </span><span class="s1">npt</span>
<span class="s0">from </span><span class="s1">numpy.testing </span><span class="s0">import </span><span class="s1">assert_allclose</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">pytest</span>

<span class="s0">from </span><span class="s1">scipy </span><span class="s0">import </span><span class="s1">stats</span>
<span class="s0">from </span><span class="s1">.common_tests </span><span class="s0">import </span><span class="s1">(check_normalization</span><span class="s0">, </span><span class="s1">check_moment</span><span class="s0">,</span>
                           <span class="s1">check_mean_expect</span><span class="s0">,</span>
                           <span class="s1">check_var_expect</span><span class="s0">, </span><span class="s1">check_skew_expect</span><span class="s0">,</span>
                           <span class="s1">check_kurt_expect</span><span class="s0">, </span><span class="s1">check_entropy</span><span class="s0">,</span>
                           <span class="s1">check_private_entropy</span><span class="s0">, </span><span class="s1">check_edge_support</span><span class="s0">,</span>
                           <span class="s1">check_named_args</span><span class="s0">, </span><span class="s1">check_random_state_property</span><span class="s0">,</span>
                           <span class="s1">check_pickling</span><span class="s0">, </span><span class="s1">check_rvs_broadcast</span><span class="s0">,</span>
                           <span class="s1">check_freezing</span><span class="s0">,</span><span class="s1">)</span>
<span class="s0">from </span><span class="s1">scipy.stats._distr_params </span><span class="s0">import </span><span class="s1">distdiscrete</span><span class="s0">, </span><span class="s1">invdistdiscrete</span>
<span class="s0">from </span><span class="s1">scipy.stats._distn_infrastructure </span><span class="s0">import </span><span class="s1">rv_discrete_frozen</span>

<span class="s1">vals = ([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.1</span><span class="s0">, </span><span class="s2">0.2</span><span class="s0">, </span><span class="s2">0.3</span><span class="s0">, </span><span class="s2">0.4</span><span class="s1">])</span>
<span class="s1">distdiscrete += [[stats.rv_discrete(values=vals)</span><span class="s0">, </span><span class="s1">()]]</span>

<span class="s3"># For these distributions, test_discrete_basic only runs with test mode full</span>
<span class="s1">distslow = {</span><span class="s4">'zipfian'</span><span class="s0">, </span><span class="s4">'nhypergeom'</span><span class="s1">}</span>


<span class="s0">def </span><span class="s1">cases_test_discrete_basic():</span>
    <span class="s1">seen = set()</span>
    <span class="s0">for </span><span class="s1">distname</span><span class="s0">, </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">distdiscrete:</span>
        <span class="s0">if </span><span class="s1">distname </span><span class="s0">in </span><span class="s1">distslow:</span>
            <span class="s0">yield </span><span class="s1">pytest.param(distname</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">distname</span><span class="s0">, </span><span class="s1">marks=pytest.mark.slow)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">yield </span><span class="s1">distname</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">distname </span><span class="s0">not in </span><span class="s1">seen</span>
        <span class="s1">seen.add(distname)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">'distname,arg,first_case'</span><span class="s0">, </span><span class="s1">cases_test_discrete_basic())</span>
<span class="s0">def </span><span class="s1">test_discrete_basic(distname</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">first_case):</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">distfn = getattr(stats</span><span class="s0">, </span><span class="s1">distname)</span>
    <span class="s0">except </span><span class="s1">TypeError:</span>
        <span class="s1">distfn = distname</span>
        <span class="s1">distname = </span><span class="s4">'sample distribution'</span>
    <span class="s1">np.random.seed(</span><span class="s2">9765456</span><span class="s1">)</span>
    <span class="s1">rvs = distfn.rvs(size=</span><span class="s2">2000</span><span class="s0">, </span><span class="s1">*arg)</span>
    <span class="s1">supp = np.unique(rvs)</span>
    <span class="s1">m</span><span class="s0">, </span><span class="s1">v = distfn.stats(*arg)</span>
    <span class="s1">check_cdf_ppf(distfn</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">supp</span><span class="s0">, </span><span class="s1">distname + </span><span class="s4">' cdf_ppf'</span><span class="s1">)</span>

    <span class="s1">check_pmf_cdf(distfn</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">distname)</span>
    <span class="s1">check_oth(distfn</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">supp</span><span class="s0">, </span><span class="s1">distname + </span><span class="s4">' oth'</span><span class="s1">)</span>
    <span class="s1">check_edge_support(distfn</span><span class="s0">, </span><span class="s1">arg)</span>

    <span class="s1">alpha = </span><span class="s2">0.01</span>
    <span class="s1">check_discrete_chisquare(distfn</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">rvs</span><span class="s0">, </span><span class="s1">alpha</span><span class="s0">,</span>
                             <span class="s1">distname + </span><span class="s4">' chisquare'</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">first_case:</span>
        <span class="s1">locscale_defaults = (</span><span class="s2">0</span><span class="s0">,</span><span class="s1">)</span>
        <span class="s1">meths = [distfn.pmf</span><span class="s0">, </span><span class="s1">distfn.logpmf</span><span class="s0">, </span><span class="s1">distfn.cdf</span><span class="s0">, </span><span class="s1">distfn.logcdf</span><span class="s0">,</span>
                 <span class="s1">distfn.logsf]</span>
        <span class="s3"># make sure arguments are within support</span>
        <span class="s3"># for some distributions, this needs to be overridden</span>
        <span class="s1">spec_k = {</span><span class="s4">'randint'</span><span class="s1">: </span><span class="s2">11</span><span class="s0">, </span><span class="s4">'hypergeom'</span><span class="s1">: </span><span class="s2">4</span><span class="s0">, </span><span class="s4">'bernoulli'</span><span class="s1">: </span><span class="s2">0</span><span class="s0">,</span>
                  <span class="s4">'nchypergeom_wallenius'</span><span class="s1">: </span><span class="s2">6</span><span class="s1">}</span>
        <span class="s1">k = spec_k.get(distname</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">check_named_args(distfn</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">locscale_defaults</span><span class="s0">, </span><span class="s1">meths)</span>
        <span class="s0">if </span><span class="s1">distname != </span><span class="s4">'sample distribution'</span><span class="s1">:</span>
            <span class="s1">check_scale_docstring(distfn)</span>
        <span class="s1">check_random_state_property(distfn</span><span class="s0">, </span><span class="s1">arg)</span>
        <span class="s1">check_pickling(distfn</span><span class="s0">, </span><span class="s1">arg)</span>
        <span class="s1">check_freezing(distfn</span><span class="s0">, </span><span class="s1">arg)</span>

        <span class="s3"># Entropy</span>
        <span class="s1">check_entropy(distfn</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">distname)</span>
        <span class="s0">if </span><span class="s1">distfn.__class__._entropy != stats.rv_discrete._entropy:</span>
            <span class="s1">check_private_entropy(distfn</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">stats.rv_discrete)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">'distname,arg'</span><span class="s0">, </span><span class="s1">distdiscrete)</span>
<span class="s0">def </span><span class="s1">test_moments(distname</span><span class="s0">, </span><span class="s1">arg):</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">distfn = getattr(stats</span><span class="s0">, </span><span class="s1">distname)</span>
    <span class="s0">except </span><span class="s1">TypeError:</span>
        <span class="s1">distfn = distname</span>
        <span class="s1">distname = </span><span class="s4">'sample distribution'</span>
    <span class="s1">m</span><span class="s0">, </span><span class="s1">v</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">k = distfn.stats(*arg</span><span class="s0">, </span><span class="s1">moments=</span><span class="s4">'mvsk'</span><span class="s1">)</span>
    <span class="s1">check_normalization(distfn</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">distname)</span>

    <span class="s3"># compare `stats` and `moment` methods</span>
    <span class="s1">check_moment(distfn</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">m</span><span class="s0">, </span><span class="s1">v</span><span class="s0">, </span><span class="s1">distname)</span>
    <span class="s1">check_mean_expect(distfn</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">m</span><span class="s0">, </span><span class="s1">distname)</span>
    <span class="s1">check_var_expect(distfn</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">m</span><span class="s0">, </span><span class="s1">v</span><span class="s0">, </span><span class="s1">distname)</span>
    <span class="s1">check_skew_expect(distfn</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">m</span><span class="s0">, </span><span class="s1">v</span><span class="s0">, </span><span class="s1">s</span><span class="s0">, </span><span class="s1">distname)</span>
    <span class="s0">if </span><span class="s1">distname </span><span class="s0">not in </span><span class="s1">[</span><span class="s4">'zipf'</span><span class="s0">, </span><span class="s4">'yulesimon'</span><span class="s1">]:</span>
        <span class="s1">check_kurt_expect(distfn</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">m</span><span class="s0">, </span><span class="s1">v</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">distname)</span>

    <span class="s3"># frozen distr moments</span>
    <span class="s1">check_moment_frozen(distfn</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">m</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
    <span class="s1">check_moment_frozen(distfn</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">v+m*m</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">'dist,shape_args'</span><span class="s0">, </span><span class="s1">distdiscrete)</span>
<span class="s0">def </span><span class="s1">test_rvs_broadcast(dist</span><span class="s0">, </span><span class="s1">shape_args):</span>
    <span class="s3"># If shape_only is True, it means the _rvs method of the</span>
    <span class="s3"># distribution uses more than one random number to generate a random</span>
    <span class="s3"># variate.  That means the result of using rvs with broadcasting or</span>
    <span class="s3"># with a nontrivial size will not necessarily be the same as using the</span>
    <span class="s3"># numpy.vectorize'd version of rvs(), so we can only compare the shapes</span>
    <span class="s3"># of the results, not the values.</span>
    <span class="s3"># Whether or not a distribution is in the following list is an</span>
    <span class="s3"># implementation detail of the distribution, not a requirement.  If</span>
    <span class="s3"># the implementation the rvs() method of a distribution changes, this</span>
    <span class="s3"># test might also have to be changed.</span>
    <span class="s1">shape_only = dist </span><span class="s0">in </span><span class="s1">[</span><span class="s4">'betabinom'</span><span class="s0">, </span><span class="s4">'skellam'</span><span class="s0">, </span><span class="s4">'yulesimon'</span><span class="s0">, </span><span class="s4">'dlaplace'</span><span class="s0">,</span>
                          <span class="s4">'nchypergeom_fisher'</span><span class="s0">, </span><span class="s4">'nchypergeom_wallenius'</span><span class="s1">]</span>

    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">distfunc = getattr(stats</span><span class="s0">, </span><span class="s1">dist)</span>
    <span class="s0">except </span><span class="s1">TypeError:</span>
        <span class="s1">distfunc = dist</span>
        <span class="s1">dist = </span><span class="s4">f'rv_discrete(values=(</span><span class="s0">{</span><span class="s1">dist.xk</span><span class="s0">!r}</span><span class="s4">, </span><span class="s0">{</span><span class="s1">dist.pk</span><span class="s0">!r}</span><span class="s4">))'</span>
    <span class="s1">loc = np.zeros(</span><span class="s2">2</span><span class="s1">)</span>
    <span class="s1">nargs = distfunc.numargs</span>
    <span class="s1">allargs = []</span>
    <span class="s1">bshape = []</span>
    <span class="s3"># Generate shape parameter arguments...</span>
    <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range(nargs):</span>
        <span class="s1">shp = (k + </span><span class="s2">3</span><span class="s0">,</span><span class="s1">) + (</span><span class="s2">1</span><span class="s0">,</span><span class="s1">)*(k + </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">param_val = shape_args[k]</span>
        <span class="s1">allargs.append(np.full(shp</span><span class="s0">, </span><span class="s1">param_val))</span>
        <span class="s1">bshape.insert(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">shp[</span><span class="s2">0</span><span class="s1">])</span>
    <span class="s1">allargs.append(loc)</span>
    <span class="s1">bshape.append(loc.size)</span>
    <span class="s3"># bshape holds the expected shape when loc, scale, and the shape</span>
    <span class="s3"># parameters are all broadcast together.</span>
    <span class="s1">check_rvs_broadcast(distfunc</span><span class="s0">, </span><span class="s1">dist</span><span class="s0">, </span><span class="s1">allargs</span><span class="s0">, </span><span class="s1">bshape</span><span class="s0">, </span><span class="s1">shape_only</span><span class="s0">, </span><span class="s1">[np.int_])</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">'dist,args'</span><span class="s0">, </span><span class="s1">distdiscrete)</span>
<span class="s0">def </span><span class="s1">test_ppf_with_loc(dist</span><span class="s0">, </span><span class="s1">args):</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">distfn = getattr(stats</span><span class="s0">, </span><span class="s1">dist)</span>
    <span class="s0">except </span><span class="s1">TypeError:</span>
        <span class="s1">distfn = dist</span>
    <span class="s3">#check with a negative, no and positive relocation.</span>
    <span class="s1">np.random.seed(</span><span class="s2">1942349</span><span class="s1">)</span>
    <span class="s1">re_locs = [np.random.randint(-</span><span class="s2">10</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">np.random.randint(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">10</span><span class="s1">)]</span>
    <span class="s1">_a</span><span class="s0">, </span><span class="s1">_b = distfn.support(*args)</span>
    <span class="s0">for </span><span class="s1">loc </span><span class="s0">in </span><span class="s1">re_locs:</span>
        <span class="s1">npt.assert_array_equal(</span>
            <span class="s1">[_a-</span><span class="s2">1</span><span class="s1">+loc</span><span class="s0">, </span><span class="s1">_b+loc]</span><span class="s0">,</span>
            <span class="s1">[distfn.ppf(</span><span class="s2">0.0</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">loc=loc)</span><span class="s0">, </span><span class="s1">distfn.ppf(</span><span class="s2">1.0</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">loc=loc)]</span>
            <span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">'dist, args'</span><span class="s0">, </span><span class="s1">distdiscrete)</span>
<span class="s0">def </span><span class="s1">test_isf_with_loc(dist</span><span class="s0">, </span><span class="s1">args):</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">distfn = getattr(stats</span><span class="s0">, </span><span class="s1">dist)</span>
    <span class="s0">except </span><span class="s1">TypeError:</span>
        <span class="s1">distfn = dist</span>
    <span class="s3"># check with a negative, no and positive relocation.</span>
    <span class="s1">np.random.seed(</span><span class="s2">1942349</span><span class="s1">)</span>
    <span class="s1">re_locs = [np.random.randint(-</span><span class="s2">10</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">np.random.randint(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">10</span><span class="s1">)]</span>
    <span class="s1">_a</span><span class="s0">, </span><span class="s1">_b = distfn.support(*args)</span>
    <span class="s0">for </span><span class="s1">loc </span><span class="s0">in </span><span class="s1">re_locs:</span>
        <span class="s1">expected = _b + loc</span><span class="s0">, </span><span class="s1">_a - </span><span class="s2">1 </span><span class="s1">+ loc</span>
        <span class="s1">res = distfn.isf(</span><span class="s2">0.</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">loc=loc)</span><span class="s0">, </span><span class="s1">distfn.isf(</span><span class="s2">1.</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">loc=loc)</span>
        <span class="s1">npt.assert_array_equal(expected</span><span class="s0">, </span><span class="s1">res)</span>
    <span class="s3"># test broadcasting behaviour</span>
    <span class="s1">re_locs = [np.random.randint(-</span><span class="s2">10</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">size=(</span><span class="s2">5</span><span class="s0">, </span><span class="s2">3</span><span class="s1">))</span><span class="s0">,</span>
               <span class="s1">np.zeros((</span><span class="s2">5</span><span class="s0">, </span><span class="s2">3</span><span class="s1">))</span><span class="s0">,</span>
               <span class="s1">np.random.randint(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s1">size=(</span><span class="s2">5</span><span class="s0">, </span><span class="s2">3</span><span class="s1">))]</span>
    <span class="s1">_a</span><span class="s0">, </span><span class="s1">_b = distfn.support(*args)</span>
    <span class="s0">for </span><span class="s1">loc </span><span class="s0">in </span><span class="s1">re_locs:</span>
        <span class="s1">expected = _b + loc</span><span class="s0">, </span><span class="s1">_a - </span><span class="s2">1 </span><span class="s1">+ loc</span>
        <span class="s1">res = distfn.isf(</span><span class="s2">0.</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">loc=loc)</span><span class="s0">, </span><span class="s1">distfn.isf(</span><span class="s2">1.</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">loc=loc)</span>
        <span class="s1">npt.assert_array_equal(expected</span><span class="s0">, </span><span class="s1">res)</span>


<span class="s0">def </span><span class="s1">check_cdf_ppf(distfn</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">supp</span><span class="s0">, </span><span class="s1">msg):</span>
    <span class="s3"># supp is assumed to be an array of integers in the support of distfn</span>
    <span class="s3"># (but not necessarily all the integers in the support).</span>
    <span class="s3"># This test assumes that the PMF of any value in the support of the</span>
    <span class="s3"># distribution is greater than 1e-8.</span>

    <span class="s3"># cdf is a step function, and ppf(q) = min{k : cdf(k) &gt;= q, k integer}</span>
    <span class="s1">cdf_supp = distfn.cdf(supp</span><span class="s0">, </span><span class="s1">*arg)</span>
    <span class="s3"># In very rare cases, the finite precision calculation of ppf(cdf(supp))</span>
    <span class="s3"># can produce an array in which an element is off by one.  We nudge the</span>
    <span class="s3"># CDF values down by 15 ULPs help to avoid this.</span>
    <span class="s1">cdf_supp0 = cdf_supp - </span><span class="s2">15</span><span class="s1">*np.spacing(cdf_supp)</span>
    <span class="s1">npt.assert_array_equal(distfn.ppf(cdf_supp0</span><span class="s0">, </span><span class="s1">*arg)</span><span class="s0">,</span>
                           <span class="s1">supp</span><span class="s0">, </span><span class="s1">msg + </span><span class="s4">'-roundtrip'</span><span class="s1">)</span>
    <span class="s3"># Repeat the same calculation, but with the CDF values decreased by 1e-8.</span>
    <span class="s1">npt.assert_array_equal(distfn.ppf(distfn.cdf(supp</span><span class="s0">, </span><span class="s1">*arg) - </span><span class="s2">1e-8</span><span class="s0">, </span><span class="s1">*arg)</span><span class="s0">,</span>
                           <span class="s1">supp</span><span class="s0">, </span><span class="s1">msg + </span><span class="s4">'-roundtrip'</span><span class="s1">)</span>

    <span class="s0">if not </span><span class="s1">hasattr(distfn</span><span class="s0">, </span><span class="s4">'xk'</span><span class="s1">):</span>
        <span class="s1">_a</span><span class="s0">, </span><span class="s1">_b = distfn.support(*arg)</span>
        <span class="s1">supp1 = supp[supp &lt; _b]</span>
        <span class="s1">npt.assert_array_equal(distfn.ppf(distfn.cdf(supp1</span><span class="s0">, </span><span class="s1">*arg) + </span><span class="s2">1e-8</span><span class="s0">, </span><span class="s1">*arg)</span><span class="s0">,</span>
                               <span class="s1">supp1 + distfn.inc</span><span class="s0">, </span><span class="s1">msg + </span><span class="s4">' ppf-cdf-next'</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">check_pmf_cdf(distfn</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">distname):</span>
    <span class="s0">if </span><span class="s1">hasattr(distfn</span><span class="s0">, </span><span class="s4">'xk'</span><span class="s1">):</span>
        <span class="s1">index = distfn.xk</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">startind = int(distfn.ppf(</span><span class="s2">0.01</span><span class="s0">, </span><span class="s1">*arg) - </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">index = list(range(startind</span><span class="s0">, </span><span class="s1">startind + </span><span class="s2">10</span><span class="s1">))</span>
    <span class="s1">cdfs = distfn.cdf(index</span><span class="s0">, </span><span class="s1">*arg)</span>
    <span class="s1">pmfs_cum = distfn.pmf(index</span><span class="s0">, </span><span class="s1">*arg).cumsum()</span>

    <span class="s1">atol</span><span class="s0">, </span><span class="s1">rtol = </span><span class="s2">1e-10</span><span class="s0">, </span><span class="s2">1e-10</span>
    <span class="s0">if </span><span class="s1">distname == </span><span class="s4">'skellam'</span><span class="s1">:    </span><span class="s3"># ncx2 accuracy</span>
        <span class="s1">atol</span><span class="s0">, </span><span class="s1">rtol = </span><span class="s2">1e-5</span><span class="s0">, </span><span class="s2">1e-5</span>
    <span class="s1">npt.assert_allclose(cdfs - cdfs[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">pmfs_cum - pmfs_cum[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
                        <span class="s1">atol=atol</span><span class="s0">, </span><span class="s1">rtol=rtol)</span>

    <span class="s3"># also check that pmf at non-integral k is zero</span>
    <span class="s1">k = np.asarray(index)</span>
    <span class="s1">k_shifted = k[:-</span><span class="s2">1</span><span class="s1">] + np.diff(k)/</span><span class="s2">2</span>
    <span class="s1">npt.assert_equal(distfn.pmf(k_shifted</span><span class="s0">, </span><span class="s1">*arg)</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>

    <span class="s3"># better check frozen distributions, and also when loc != 0</span>
    <span class="s1">loc = </span><span class="s2">0.5</span>
    <span class="s1">dist = distfn(loc=loc</span><span class="s0">, </span><span class="s1">*arg)</span>
    <span class="s1">npt.assert_allclose(dist.pmf(k[</span><span class="s2">1</span><span class="s1">:] + loc)</span><span class="s0">, </span><span class="s1">np.diff(dist.cdf(k + loc)))</span>
    <span class="s1">npt.assert_equal(dist.pmf(k_shifted + loc)</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">check_moment_frozen(distfn</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">m</span><span class="s0">, </span><span class="s1">k):</span>
    <span class="s1">npt.assert_allclose(distfn(*arg).moment(k)</span><span class="s0">, </span><span class="s1">m</span><span class="s0">,</span>
                        <span class="s1">atol=</span><span class="s2">1e-10</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-10</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">check_oth(distfn</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">supp</span><span class="s0">, </span><span class="s1">msg):</span>
    <span class="s3"># checking other methods of distfn</span>
    <span class="s1">npt.assert_allclose(distfn.sf(supp</span><span class="s0">, </span><span class="s1">*arg)</span><span class="s0">, </span><span class="s2">1. </span><span class="s1">- distfn.cdf(supp</span><span class="s0">, </span><span class="s1">*arg)</span><span class="s0">,</span>
                        <span class="s1">atol=</span><span class="s2">1e-10</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-10</span><span class="s1">)</span>

    <span class="s1">q = np.linspace(</span><span class="s2">0.01</span><span class="s0">, </span><span class="s2">0.99</span><span class="s0">, </span><span class="s2">20</span><span class="s1">)</span>
    <span class="s1">npt.assert_allclose(distfn.isf(q</span><span class="s0">, </span><span class="s1">*arg)</span><span class="s0">, </span><span class="s1">distfn.ppf(</span><span class="s2">1. </span><span class="s1">- q</span><span class="s0">, </span><span class="s1">*arg)</span><span class="s0">,</span>
                        <span class="s1">atol=</span><span class="s2">1e-10</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-10</span><span class="s1">)</span>

    <span class="s1">median_sf = distfn.isf(</span><span class="s2">0.5</span><span class="s0">, </span><span class="s1">*arg)</span>
    <span class="s1">npt.assert_(distfn.sf(median_sf - </span><span class="s2">1</span><span class="s0">, </span><span class="s1">*arg) &gt; </span><span class="s2">0.5</span><span class="s1">)</span>
    <span class="s1">npt.assert_(distfn.cdf(median_sf + </span><span class="s2">1</span><span class="s0">, </span><span class="s1">*arg) &gt; </span><span class="s2">0.5</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">check_discrete_chisquare(distfn</span><span class="s0">, </span><span class="s1">arg</span><span class="s0">, </span><span class="s1">rvs</span><span class="s0">, </span><span class="s1">alpha</span><span class="s0">, </span><span class="s1">msg):</span>
    <span class="s5">&quot;&quot;&quot;Perform chisquare test for random sample of a discrete distribution 
 
    Parameters 
    ---------- 
    distname : string 
        name of distribution function 
    arg : sequence 
        parameters of distribution 
    alpha : float 
        significance level, threshold for p-value 
 
    Returns 
    ------- 
    result : bool 
        0 if test passes, 1 if test fails 
 
    &quot;&quot;&quot;</span>
    <span class="s1">wsupp = </span><span class="s2">0.05</span>

    <span class="s3"># construct intervals with minimum mass `wsupp`.</span>
    <span class="s3"># intervals are left-half-open as in a cdf difference</span>
    <span class="s1">_a</span><span class="s0">, </span><span class="s1">_b = distfn.support(*arg)</span>
    <span class="s1">lo = int(max(_a</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1000</span><span class="s1">))</span>
    <span class="s1">high = int(min(_b</span><span class="s0">, </span><span class="s2">1000</span><span class="s1">)) + </span><span class="s2">1</span>
    <span class="s1">distsupport = range(lo</span><span class="s0">, </span><span class="s1">high)</span>
    <span class="s1">last = </span><span class="s2">0</span>
    <span class="s1">distsupp = [lo]</span>
    <span class="s1">distmass = []</span>
    <span class="s0">for </span><span class="s1">ii </span><span class="s0">in </span><span class="s1">distsupport:</span>
        <span class="s1">current = distfn.cdf(ii</span><span class="s0">, </span><span class="s1">*arg)</span>
        <span class="s0">if </span><span class="s1">current - last &gt;= wsupp - </span><span class="s2">1e-14</span><span class="s1">:</span>
            <span class="s1">distsupp.append(ii)</span>
            <span class="s1">distmass.append(current - last)</span>
            <span class="s1">last = current</span>
            <span class="s0">if </span><span class="s1">current &gt; (</span><span class="s2">1 </span><span class="s1">- wsupp):</span>
                <span class="s0">break</span>
    <span class="s0">if </span><span class="s1">distsupp[-</span><span class="s2">1</span><span class="s1">] &lt; _b:</span>
        <span class="s1">distsupp.append(_b)</span>
        <span class="s1">distmass.append(</span><span class="s2">1 </span><span class="s1">- last)</span>
    <span class="s1">distsupp = np.array(distsupp)</span>
    <span class="s1">distmass = np.array(distmass)</span>

    <span class="s3"># convert intervals to right-half-open as required by histogram</span>
    <span class="s1">histsupp = distsupp + </span><span class="s2">1e-8</span>
    <span class="s1">histsupp[</span><span class="s2">0</span><span class="s1">] = _a</span>

    <span class="s3"># find sample frequencies and perform chisquare test</span>
    <span class="s1">freq</span><span class="s0">, </span><span class="s1">hsupp = np.histogram(rvs</span><span class="s0">, </span><span class="s1">histsupp)</span>
    <span class="s1">chis</span><span class="s0">, </span><span class="s1">pval = stats.chisquare(np.array(freq)</span><span class="s0">, </span><span class="s1">len(rvs)*distmass)</span>

    <span class="s1">npt.assert_(pval &gt; alpha</span><span class="s0">,</span>
                <span class="s4">'chisquare - test for %s at arg = %s with pval = %s' </span><span class="s1">%</span>
                <span class="s1">(msg</span><span class="s0">, </span><span class="s1">str(arg)</span><span class="s0">, </span><span class="s1">str(pval)))</span>


<span class="s0">def </span><span class="s1">check_scale_docstring(distfn):</span>
    <span class="s0">if </span><span class="s1">distfn.__doc__ </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s3"># Docstrings can be stripped if interpreter is run with -OO</span>
        <span class="s1">npt.assert_(</span><span class="s4">'scale' </span><span class="s0">not in </span><span class="s1">distfn.__doc__)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">'method'</span><span class="s0">, </span><span class="s1">[</span><span class="s4">'pmf'</span><span class="s0">, </span><span class="s4">'logpmf'</span><span class="s0">, </span><span class="s4">'cdf'</span><span class="s0">, </span><span class="s4">'logcdf'</span><span class="s0">,</span>
                                    <span class="s4">'sf'</span><span class="s0">, </span><span class="s4">'logsf'</span><span class="s0">, </span><span class="s4">'ppf'</span><span class="s0">, </span><span class="s4">'isf'</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">'distname, args'</span><span class="s0">, </span><span class="s1">distdiscrete)</span>
<span class="s0">def </span><span class="s1">test_methods_with_lists(method</span><span class="s0">, </span><span class="s1">distname</span><span class="s0">, </span><span class="s1">args):</span>
    <span class="s3"># Test that the discrete distributions can accept Python lists</span>
    <span class="s3"># as arguments.</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">dist = getattr(stats</span><span class="s0">, </span><span class="s1">distname)</span>
    <span class="s0">except </span><span class="s1">TypeError:</span>
        <span class="s0">return</span>
    <span class="s0">if </span><span class="s1">method </span><span class="s0">in </span><span class="s1">[</span><span class="s4">'ppf'</span><span class="s0">, </span><span class="s4">'isf'</span><span class="s1">]:</span>
        <span class="s1">z = [</span><span class="s2">0.1</span><span class="s0">, </span><span class="s2">0.2</span><span class="s1">]</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">z = [</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span>
    <span class="s1">p2 = [[p]*</span><span class="s2">2 </span><span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">args]</span>
    <span class="s1">loc = [</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span>
    <span class="s1">result = dist.pmf(z</span><span class="s0">, </span><span class="s1">*p2</span><span class="s0">, </span><span class="s1">loc=loc)</span>
    <span class="s1">npt.assert_allclose(result</span><span class="s0">,</span>
                        <span class="s1">[dist.pmf(*v) </span><span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">zip(z</span><span class="s0">, </span><span class="s1">*p2</span><span class="s0">, </span><span class="s1">loc)]</span><span class="s0">,</span>
                        <span class="s1">rtol=</span><span class="s2">1e-15</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-15</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">'distname, args'</span><span class="s0">, </span><span class="s1">invdistdiscrete)</span>
<span class="s0">def </span><span class="s1">test_cdf_gh13280_regression(distname</span><span class="s0">, </span><span class="s1">args):</span>
    <span class="s3"># Test for nan output when shape parameters are invalid</span>
    <span class="s1">dist = getattr(stats</span><span class="s0">, </span><span class="s1">distname)</span>
    <span class="s1">x = np.arange(-</span><span class="s2">2</span><span class="s0">, </span><span class="s2">15</span><span class="s1">)</span>
    <span class="s1">vals = dist.cdf(x</span><span class="s0">, </span><span class="s1">*args)</span>
    <span class="s1">expected = np.nan</span>
    <span class="s1">npt.assert_equal(vals</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">cases_test_discrete_integer_shapes():</span>
    <span class="s3"># distributions parameters that are only allowed to be integral when</span>
    <span class="s3"># fitting, but are allowed to be real as input to PDF, etc.</span>
    <span class="s1">integrality_exceptions = {</span><span class="s4">'nbinom'</span><span class="s1">: {</span><span class="s4">'n'</span><span class="s1">}}</span>

    <span class="s1">seen = set()</span>
    <span class="s0">for </span><span class="s1">distname</span><span class="s0">, </span><span class="s1">shapes </span><span class="s0">in </span><span class="s1">distdiscrete:</span>
        <span class="s0">if </span><span class="s1">distname </span><span class="s0">in </span><span class="s1">seen:</span>
            <span class="s0">continue</span>
        <span class="s1">seen.add(distname)</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">dist = getattr(stats</span><span class="s0">, </span><span class="s1">distname)</span>
        <span class="s0">except </span><span class="s1">TypeError:</span>
            <span class="s0">continue</span>

        <span class="s1">shape_info = dist._shape_info()</span>

        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">shape </span><span class="s0">in </span><span class="s1">enumerate(shape_info):</span>
            <span class="s0">if </span><span class="s1">(shape.name </span><span class="s0">in </span><span class="s1">integrality_exceptions.get(distname</span><span class="s0">, </span><span class="s1">set()) </span><span class="s0">or</span>
                    <span class="s0">not </span><span class="s1">shape.integrality):</span>
                <span class="s0">continue</span>

            <span class="s0">yield </span><span class="s1">distname</span><span class="s0">, </span><span class="s1">shape.name</span><span class="s0">, </span><span class="s1">shapes</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">'distname, shapename, shapes'</span><span class="s0">,</span>
                         <span class="s1">cases_test_discrete_integer_shapes())</span>
<span class="s0">def </span><span class="s1">test_integer_shapes(distname</span><span class="s0">, </span><span class="s1">shapename</span><span class="s0">, </span><span class="s1">shapes):</span>
    <span class="s1">dist = getattr(stats</span><span class="s0">, </span><span class="s1">distname)</span>
    <span class="s1">shape_info = dist._shape_info()</span>
    <span class="s1">shape_names = [shape.name </span><span class="s0">for </span><span class="s1">shape </span><span class="s0">in </span><span class="s1">shape_info]</span>
    <span class="s1">i = shape_names.index(shapename)  </span><span class="s3"># this element of params must be integral</span>

    <span class="s1">shapes_copy = list(shapes)</span>

    <span class="s1">valid_shape = shapes[i]</span>
    <span class="s1">invalid_shape = valid_shape - </span><span class="s2">0.5  </span><span class="s3"># arbitrary non-integral value</span>
    <span class="s1">new_valid_shape = valid_shape - </span><span class="s2">1</span>
    <span class="s1">shapes_copy[i] = [[valid_shape]</span><span class="s0">, </span><span class="s1">[invalid_shape]</span><span class="s0">, </span><span class="s1">[new_valid_shape]]</span>

    <span class="s1">a</span><span class="s0">, </span><span class="s1">b = dist.support(*shapes)</span>
    <span class="s1">x = np.round(np.linspace(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s2">5</span><span class="s1">))</span>

    <span class="s1">pmf = dist.pmf(x</span><span class="s0">, </span><span class="s1">*shapes_copy)</span>
    <span class="s0">assert not </span><span class="s1">np.any(np.isnan(pmf[</span><span class="s2">0</span><span class="s0">, </span><span class="s1">:]))</span>
    <span class="s0">assert </span><span class="s1">np.all(np.isnan(pmf[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">:]))</span>
    <span class="s0">assert not </span><span class="s1">np.any(np.isnan(pmf[</span><span class="s2">2</span><span class="s0">, </span><span class="s1">:]))</span>


<span class="s0">def </span><span class="s1">test_frozen_attributes():</span>
    <span class="s3"># gh-14827 reported that all frozen distributions had both pmf and pdf</span>
    <span class="s3"># attributes; continuous should have pdf and discrete should have pmf.</span>
    <span class="s1">message = </span><span class="s4">&quot;'rv_discrete_frozen' object has no attribute&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.raises(AttributeError</span><span class="s0">, </span><span class="s1">match=message):</span>
        <span class="s1">stats.binom(</span><span class="s2">10</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">).pdf</span>
    <span class="s0">with </span><span class="s1">pytest.raises(AttributeError</span><span class="s0">, </span><span class="s1">match=message):</span>
        <span class="s1">stats.binom(</span><span class="s2">10</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">).logpdf</span>
    <span class="s1">stats.binom.pdf = </span><span class="s4">&quot;herring&quot;</span>
    <span class="s1">frozen_binom = stats.binom(</span><span class="s2">10</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">isinstance(frozen_binom</span><span class="s0">, </span><span class="s1">rv_discrete_frozen)</span>
    <span class="s1">delattr(stats.binom</span><span class="s0">, </span><span class="s4">'pdf'</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">'distname, shapes'</span><span class="s0">, </span><span class="s1">distdiscrete)</span>
<span class="s0">def </span><span class="s1">test_interval(distname</span><span class="s0">, </span><span class="s1">shapes):</span>
    <span class="s3"># gh-11026 reported that `interval` returns incorrect values when</span>
    <span class="s3"># `confidence=1`. The values were not incorrect, but it was not intuitive</span>
    <span class="s3"># that the left end of the interval should extend beyond the support of the</span>
    <span class="s3"># distribution. Confirm that this is the behavior for all distributions.</span>
    <span class="s0">if </span><span class="s1">isinstance(distname</span><span class="s0">, </span><span class="s1">str):</span>
        <span class="s1">dist = getattr(stats</span><span class="s0">, </span><span class="s1">distname)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">dist = distname</span>
    <span class="s1">a</span><span class="s0">, </span><span class="s1">b = dist.support(*shapes)</span>
    <span class="s1">npt.assert_equal(dist.ppf([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">*shapes)</span><span class="s0">, </span><span class="s1">(a-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">b))</span>
    <span class="s1">npt.assert_equal(dist.isf([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">*shapes)</span><span class="s0">, </span><span class="s1">(a-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">b))</span>
    <span class="s1">npt.assert_equal(dist.interval(</span><span class="s2">1</span><span class="s0">, </span><span class="s1">*shapes)</span><span class="s0">, </span><span class="s1">(a-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">b))</span>


<span class="s0">def </span><span class="s1">test_rv_sample():</span>
    <span class="s3"># Thoroughly test rv_sample and check that gh-3758 is resolved</span>

    <span class="s3"># Generate a random discrete distribution</span>
    <span class="s1">rng = np.random.default_rng(</span><span class="s2">98430143469</span><span class="s1">)</span>
    <span class="s1">xk = np.sort(rng.random(</span><span class="s2">10</span><span class="s1">) * </span><span class="s2">10</span><span class="s1">)</span>
    <span class="s1">pk = rng.random(</span><span class="s2">10</span><span class="s1">)</span>
    <span class="s1">pk /= np.sum(pk)</span>
    <span class="s1">dist = stats.rv_discrete(values=(xk</span><span class="s0">, </span><span class="s1">pk))</span>

    <span class="s3"># Generate points to the left and right of xk</span>
    <span class="s1">xk_left = (np.array([</span><span class="s2">0</span><span class="s1">] + xk[:-</span><span class="s2">1</span><span class="s1">].tolist()) + xk)/</span><span class="s2">2</span>
    <span class="s1">xk_right = (np.array(xk[</span><span class="s2">1</span><span class="s1">:].tolist() + [xk[-</span><span class="s2">1</span><span class="s1">]+</span><span class="s2">1</span><span class="s1">]) + xk)/</span><span class="s2">2</span>

    <span class="s3"># Generate points to the left and right of cdf</span>
    <span class="s1">cdf2 = np.cumsum(pk)</span>
    <span class="s1">cdf2_left = (np.array([</span><span class="s2">0</span><span class="s1">] + cdf2[:-</span><span class="s2">1</span><span class="s1">].tolist()) + cdf2)/</span><span class="s2">2</span>
    <span class="s1">cdf2_right = (np.array(cdf2[</span><span class="s2">1</span><span class="s1">:].tolist() + [</span><span class="s2">1</span><span class="s1">]) + cdf2)/</span><span class="s2">2</span>

    <span class="s3"># support - leftmost and rightmost xk</span>
    <span class="s1">a</span><span class="s0">, </span><span class="s1">b = dist.support()</span>
    <span class="s1">assert_allclose(a</span><span class="s0">, </span><span class="s1">xk[</span><span class="s2">0</span><span class="s1">])</span>
    <span class="s1">assert_allclose(b</span><span class="s0">, </span><span class="s1">xk[-</span><span class="s2">1</span><span class="s1">])</span>

    <span class="s3"># pmf - supported only on the xk</span>
    <span class="s1">assert_allclose(dist.pmf(xk)</span><span class="s0">, </span><span class="s1">pk)</span>
    <span class="s1">assert_allclose(dist.pmf(xk_right)</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
    <span class="s1">assert_allclose(dist.pmf(xk_left)</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>

    <span class="s3"># logpmf is log of the pmf; log(0) = -np.inf</span>
    <span class="s0">with </span><span class="s1">np.errstate(divide=</span><span class="s4">'ignore'</span><span class="s1">):</span>
        <span class="s1">assert_allclose(dist.logpmf(xk)</span><span class="s0">, </span><span class="s1">np.log(pk))</span>
        <span class="s1">assert_allclose(dist.logpmf(xk_right)</span><span class="s0">, </span><span class="s1">-np.inf)</span>
        <span class="s1">assert_allclose(dist.logpmf(xk_left)</span><span class="s0">, </span><span class="s1">-np.inf)</span>

    <span class="s3"># cdf - the cumulative sum of the pmf</span>
    <span class="s1">assert_allclose(dist.cdf(xk)</span><span class="s0">, </span><span class="s1">cdf2)</span>
    <span class="s1">assert_allclose(dist.cdf(xk_right)</span><span class="s0">, </span><span class="s1">cdf2)</span>
    <span class="s1">assert_allclose(dist.cdf(xk_left)</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s1">]+cdf2[:-</span><span class="s2">1</span><span class="s1">].tolist())</span>

    <span class="s0">with </span><span class="s1">np.errstate(divide=</span><span class="s4">'ignore'</span><span class="s1">):</span>
        <span class="s1">assert_allclose(dist.logcdf(xk)</span><span class="s0">, </span><span class="s1">np.log(dist.cdf(xk))</span><span class="s0">,</span>
                        <span class="s1">atol=</span><span class="s2">1e-15</span><span class="s1">)</span>
        <span class="s1">assert_allclose(dist.logcdf(xk_right)</span><span class="s0">, </span><span class="s1">np.log(dist.cdf(xk_right))</span><span class="s0">,</span>
                        <span class="s1">atol=</span><span class="s2">1e-15</span><span class="s1">)</span>
        <span class="s1">assert_allclose(dist.logcdf(xk_left)</span><span class="s0">, </span><span class="s1">np.log(dist.cdf(xk_left))</span><span class="s0">,</span>
                        <span class="s1">atol=</span><span class="s2">1e-15</span><span class="s1">)</span>

    <span class="s3"># sf is 1-cdf</span>
    <span class="s1">assert_allclose(dist.sf(xk)</span><span class="s0">, </span><span class="s2">1</span><span class="s1">-dist.cdf(xk))</span>
    <span class="s1">assert_allclose(dist.sf(xk_right)</span><span class="s0">, </span><span class="s2">1</span><span class="s1">-dist.cdf(xk_right))</span>
    <span class="s1">assert_allclose(dist.sf(xk_left)</span><span class="s0">, </span><span class="s2">1</span><span class="s1">-dist.cdf(xk_left))</span>

    <span class="s0">with </span><span class="s1">np.errstate(divide=</span><span class="s4">'ignore'</span><span class="s1">):</span>
        <span class="s1">assert_allclose(dist.logsf(xk)</span><span class="s0">, </span><span class="s1">np.log(dist.sf(xk))</span><span class="s0">,</span>
                        <span class="s1">atol=</span><span class="s2">1e-15</span><span class="s1">)</span>
        <span class="s1">assert_allclose(dist.logsf(xk_right)</span><span class="s0">, </span><span class="s1">np.log(dist.sf(xk_right))</span><span class="s0">,</span>
                        <span class="s1">atol=</span><span class="s2">1e-15</span><span class="s1">)</span>
        <span class="s1">assert_allclose(dist.logsf(xk_left)</span><span class="s0">, </span><span class="s1">np.log(dist.sf(xk_left))</span><span class="s0">,</span>
                        <span class="s1">atol=</span><span class="s2">1e-15</span><span class="s1">)</span>

    <span class="s3"># ppf</span>
    <span class="s1">assert_allclose(dist.ppf(cdf2)</span><span class="s0">, </span><span class="s1">xk)</span>
    <span class="s1">assert_allclose(dist.ppf(cdf2_left)</span><span class="s0">, </span><span class="s1">xk)</span>
    <span class="s1">assert_allclose(dist.ppf(cdf2_right)[:-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">xk[</span><span class="s2">1</span><span class="s1">:])</span>
    <span class="s1">assert_allclose(dist.ppf(</span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">a - </span><span class="s2">1</span><span class="s1">)</span>
    <span class="s1">assert_allclose(dist.ppf(</span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">b)</span>

    <span class="s3"># isf</span>
    <span class="s1">sf2 = dist.sf(xk)</span>
    <span class="s1">assert_allclose(dist.isf(sf2)</span><span class="s0">, </span><span class="s1">xk)</span>
    <span class="s1">assert_allclose(dist.isf(</span><span class="s2">1</span><span class="s1">-cdf2_left)</span><span class="s0">, </span><span class="s1">dist.ppf(cdf2_left))</span>
    <span class="s1">assert_allclose(dist.isf(</span><span class="s2">1</span><span class="s1">-cdf2_right)</span><span class="s0">, </span><span class="s1">dist.ppf(cdf2_right))</span>
    <span class="s1">assert_allclose(dist.isf(</span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">b)</span>
    <span class="s1">assert_allclose(dist.isf(</span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">a - </span><span class="s2">1</span><span class="s1">)</span>

    <span class="s3"># interval is (ppf(alpha/2), isf(alpha/2))</span>
    <span class="s1">ps = np.linspace(</span><span class="s2">0.01</span><span class="s0">, </span><span class="s2">0.99</span><span class="s0">, </span><span class="s2">10</span><span class="s1">)</span>
    <span class="s1">int2 = dist.ppf(ps/</span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dist.isf(ps/</span><span class="s2">2</span><span class="s1">)</span>
    <span class="s1">assert_allclose(dist.interval(</span><span class="s2">1</span><span class="s1">-ps)</span><span class="s0">, </span><span class="s1">int2)</span>
    <span class="s1">assert_allclose(dist.interval(</span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dist.median())</span>
    <span class="s1">assert_allclose(dist.interval(</span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(a-</span><span class="s2">1</span><span class="s0">, </span><span class="s1">b))</span>

    <span class="s3"># median is simply ppf(0.5)</span>
    <span class="s1">med2 = dist.ppf(</span><span class="s2">0.5</span><span class="s1">)</span>
    <span class="s1">assert_allclose(dist.median()</span><span class="s0">, </span><span class="s1">med2)</span>

    <span class="s3"># all four stats (mean, var, skew, and kurtosis) from the definitions</span>
    <span class="s1">mean2 = np.sum(xk*pk)</span>
    <span class="s1">var2 = np.sum((xk - mean2)**</span><span class="s2">2 </span><span class="s1">* pk)</span>
    <span class="s1">skew2 = np.sum((xk - mean2)**</span><span class="s2">3 </span><span class="s1">* pk) / var2**(</span><span class="s2">3</span><span class="s1">/</span><span class="s2">2</span><span class="s1">)</span>
    <span class="s1">kurt2 = np.sum((xk - mean2)**</span><span class="s2">4 </span><span class="s1">* pk) / var2**</span><span class="s2">2 </span><span class="s1">- </span><span class="s2">3</span>
    <span class="s1">assert_allclose(dist.mean()</span><span class="s0">, </span><span class="s1">mean2)</span>
    <span class="s1">assert_allclose(dist.std()</span><span class="s0">, </span><span class="s1">np.sqrt(var2))</span>
    <span class="s1">assert_allclose(dist.var()</span><span class="s0">, </span><span class="s1">var2)</span>
    <span class="s1">assert_allclose(dist.stats(moments=</span><span class="s4">'mvsk'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(mean2</span><span class="s0">, </span><span class="s1">var2</span><span class="s0">, </span><span class="s1">skew2</span><span class="s0">, </span><span class="s1">kurt2))</span>

    <span class="s3"># noncentral moment against definition</span>
    <span class="s1">mom3 = np.sum((xk**</span><span class="s2">3</span><span class="s1">) * pk)</span>
    <span class="s1">assert_allclose(dist.moment(</span><span class="s2">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">mom3)</span>

    <span class="s3"># expect - check against moments</span>
    <span class="s1">assert_allclose(dist.expect(</span><span class="s0">lambda </span><span class="s1">x: </span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
    <span class="s1">assert_allclose(dist.expect()</span><span class="s0">, </span><span class="s1">mean2)</span>
    <span class="s1">assert_allclose(dist.expect(</span><span class="s0">lambda </span><span class="s1">x: x**</span><span class="s2">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">mom3)</span>

    <span class="s3"># entropy is the negative of the expected value of log(p)</span>
    <span class="s0">with </span><span class="s1">np.errstate(divide=</span><span class="s4">'ignore'</span><span class="s1">):</span>
        <span class="s1">assert_allclose(-dist.expect(</span><span class="s0">lambda </span><span class="s1">x: dist.logpmf(x))</span><span class="s0">, </span><span class="s1">dist.entropy())</span>

    <span class="s3"># RVS is just ppf of uniform random variates</span>
    <span class="s1">rng = np.random.default_rng(</span><span class="s2">98430143469</span><span class="s1">)</span>
    <span class="s1">rvs = dist.rvs(size=</span><span class="s2">100</span><span class="s0">, </span><span class="s1">random_state=rng)</span>
    <span class="s1">rng = np.random.default_rng(</span><span class="s2">98430143469</span><span class="s1">)</span>
    <span class="s1">rvs0 = dist.ppf(rng.random(size=</span><span class="s2">100</span><span class="s1">))</span>
    <span class="s1">assert_allclose(rvs</span><span class="s0">, </span><span class="s1">rvs0)</span>
</pre>
</body>
</html>