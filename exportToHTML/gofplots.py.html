<html>
<head>
<title>gofplots.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
gofplots.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">statsmodels.compat.python </span><span class="s0">import </span><span class="s1">lzip</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">scipy </span><span class="s0">import </span><span class="s1">stats</span>

<span class="s0">from </span><span class="s1">statsmodels.distributions </span><span class="s0">import </span><span class="s1">ECDF</span>
<span class="s0">from </span><span class="s1">statsmodels.regression.linear_model </span><span class="s0">import </span><span class="s1">OLS</span>
<span class="s0">from </span><span class="s1">statsmodels.tools.decorators </span><span class="s0">import </span><span class="s1">cache_readonly</span>
<span class="s0">from </span><span class="s1">statsmodels.tools.tools </span><span class="s0">import </span><span class="s1">add_constant</span>

<span class="s0">from </span><span class="s1">. </span><span class="s0">import </span><span class="s1">utils</span>

<span class="s1">__all__ = [</span><span class="s2">&quot;qqplot&quot;</span><span class="s0">, </span><span class="s2">&quot;qqplot_2samples&quot;</span><span class="s0">, </span><span class="s2">&quot;qqline&quot;</span><span class="s0">, </span><span class="s2">&quot;ProbPlot&quot;</span><span class="s1">]</span>


<span class="s0">class </span><span class="s1">ProbPlot:</span>
    <span class="s3">&quot;&quot;&quot; 
    Q-Q and P-P Probability Plots 
 
    Can take arguments specifying the parameters for dist or fit them 
    automatically. (See fit under kwargs.) 
 
    Parameters 
    ---------- 
    data : array_like 
        A 1d data array 
    dist : callable 
        Compare x against dist. A scipy.stats or statsmodels distribution. The 
        default is scipy.stats.distributions.norm (a standard normal). Can be 
        a SciPy frozen distribution. 
    fit : bool 
        If fit is false, loc, scale, and distargs are passed to the 
        distribution. If fit is True then the parameters for dist are fit 
        automatically using dist.fit. The quantiles are formed from the 
        standardized data, after subtracting the fitted loc and dividing by 
        the fitted scale. fit cannot be used if dist is a SciPy frozen 
        distribution. 
    distargs : tuple 
        A tuple of arguments passed to dist to specify it fully so dist.ppf 
        may be called. distargs must not contain loc or scale. These values 
        must be passed using the loc or scale inputs. distargs cannot be used 
        if dist is a SciPy frozen distribution. 
    a : float 
        Offset for the plotting position of an expected order statistic, for 
        example. The plotting positions are given by 
        (i - a)/(nobs - 2*a + 1) for i in range(0,nobs+1) 
    loc : float 
        Location parameter for dist. Cannot be used if dist is a SciPy frozen 
        distribution. 
    scale : float 
        Scale parameter for dist. Cannot be used if dist is a SciPy frozen 
        distribution. 
 
    See Also 
    -------- 
    scipy.stats.probplot 
 
    Notes 
    ----- 
    1) Depends on matplotlib. 
    2) If `fit` is True then the parameters are fit using the 
        distribution's `fit()` method. 
    3) The call signatures for the `qqplot`, `ppplot`, and `probplot` 
        methods are similar, so examples 1 through 4 apply to all 
        three methods. 
    4) The three plotting methods are summarized below: 
        ppplot : Probability-Probability plot 
            Compares the sample and theoretical probabilities (percentiles). 
        qqplot : Quantile-Quantile plot 
            Compares the sample and theoretical quantiles 
        probplot : Probability plot 
            Same as a Q-Q plot, however probabilities are shown in the scale of 
            the theoretical distribution (x-axis) and the y-axis contains 
            unscaled quantiles of the sample data. 
 
    Examples 
    -------- 
    The first example shows a Q-Q plot for regression residuals 
 
    &gt;&gt;&gt; # example 1 
    &gt;&gt;&gt; import statsmodels.api as sm 
    &gt;&gt;&gt; from matplotlib import pyplot as plt 
    &gt;&gt;&gt; data = sm.datasets.longley.load() 
    &gt;&gt;&gt; data.exog = sm.add_constant(data.exog) 
    &gt;&gt;&gt; model = sm.OLS(data.endog, data.exog) 
    &gt;&gt;&gt; mod_fit = model.fit() 
    &gt;&gt;&gt; res = mod_fit.resid # residuals 
    &gt;&gt;&gt; pplot = sm.ProbPlot(res) 
    &gt;&gt;&gt; fig = pplot.qqplot() 
    &gt;&gt;&gt; h = plt.title(&quot;Ex. 1 - qqplot - residuals of OLS fit&quot;) 
    &gt;&gt;&gt; plt.show() 
 
    qqplot of the residuals against quantiles of t-distribution with 4 
    degrees of freedom: 
 
    &gt;&gt;&gt; # example 2 
    &gt;&gt;&gt; import scipy.stats as stats 
    &gt;&gt;&gt; pplot = sm.ProbPlot(res, stats.t, distargs=(4,)) 
    &gt;&gt;&gt; fig = pplot.qqplot() 
    &gt;&gt;&gt; h = plt.title(&quot;Ex. 2 - qqplot - residuals against quantiles of t-dist&quot;) 
    &gt;&gt;&gt; plt.show() 
 
    qqplot against same as above, but with mean 3 and std 10: 
 
    &gt;&gt;&gt; # example 3 
    &gt;&gt;&gt; pplot = sm.ProbPlot(res, stats.t, distargs=(4,), loc=3, scale=10) 
    &gt;&gt;&gt; fig = pplot.qqplot() 
    &gt;&gt;&gt; h = plt.title(&quot;Ex. 3 - qqplot - resids vs quantiles of t-dist&quot;) 
    &gt;&gt;&gt; plt.show() 
 
    Automatically determine parameters for t distribution including the 
    loc and scale: 
 
    &gt;&gt;&gt; # example 4 
    &gt;&gt;&gt; pplot = sm.ProbPlot(res, stats.t, fit=True) 
    &gt;&gt;&gt; fig = pplot.qqplot(line=&quot;45&quot;) 
    &gt;&gt;&gt; h = plt.title(&quot;Ex. 4 - qqplot - resids vs. quantiles of fitted t-dist&quot;) 
    &gt;&gt;&gt; plt.show() 
 
    A second `ProbPlot` object can be used to compare two separate sample 
    sets by using the `other` kwarg in the `qqplot` and `ppplot` methods. 
 
    &gt;&gt;&gt; # example 5 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; x = np.random.normal(loc=8.25, scale=2.75, size=37) 
    &gt;&gt;&gt; y = np.random.normal(loc=8.75, scale=3.25, size=37) 
    &gt;&gt;&gt; pp_x = sm.ProbPlot(x, fit=True) 
    &gt;&gt;&gt; pp_y = sm.ProbPlot(y, fit=True) 
    &gt;&gt;&gt; fig = pp_x.qqplot(line=&quot;45&quot;, other=pp_y) 
    &gt;&gt;&gt; h = plt.title(&quot;Ex. 5 - qqplot - compare two sample sets&quot;) 
    &gt;&gt;&gt; plt.show() 
 
    In qqplot, sample size of `other` can be equal or larger than the first. 
    In case of larger, size of `other` samples will be reduced to match the 
    size of the first by interpolation 
 
    &gt;&gt;&gt; # example 6 
    &gt;&gt;&gt; x = np.random.normal(loc=8.25, scale=2.75, size=37) 
    &gt;&gt;&gt; y = np.random.normal(loc=8.75, scale=3.25, size=57) 
    &gt;&gt;&gt; pp_x = sm.ProbPlot(x, fit=True) 
    &gt;&gt;&gt; pp_y = sm.ProbPlot(y, fit=True) 
    &gt;&gt;&gt; fig = pp_x.qqplot(line=&quot;45&quot;, other=pp_y) 
    &gt;&gt;&gt; title = &quot;Ex. 6 - qqplot - compare different sample sizes&quot; 
    &gt;&gt;&gt; h = plt.title(title) 
    &gt;&gt;&gt; plt.show() 
 
    In ppplot, sample size of `other` and the first can be different. `other` 
    will be used to estimate an empirical cumulative distribution function 
    (ECDF). ECDF(x) will be plotted against p(x)=0.5/n, 1.5/n, ..., (n-0.5)/n 
    where x are sorted samples from the first. 
 
    &gt;&gt;&gt; # example 7 
    &gt;&gt;&gt; x = np.random.normal(loc=8.25, scale=2.75, size=37) 
    &gt;&gt;&gt; y = np.random.normal(loc=8.75, scale=3.25, size=57) 
    &gt;&gt;&gt; pp_x = sm.ProbPlot(x, fit=True) 
    &gt;&gt;&gt; pp_y = sm.ProbPlot(y, fit=True) 
    &gt;&gt;&gt; pp_y.ppplot(line=&quot;45&quot;, other=pp_x) 
    &gt;&gt;&gt; plt.title(&quot;Ex. 7A- ppplot - compare two sample sets, other=pp_x&quot;) 
    &gt;&gt;&gt; pp_x.ppplot(line=&quot;45&quot;, other=pp_y) 
    &gt;&gt;&gt; plt.title(&quot;Ex. 7B- ppplot - compare two sample sets, other=pp_y&quot;) 
    &gt;&gt;&gt; plt.show() 
 
    The following plot displays some options, follow the link to see the 
    code. 
 
    .. plot:: plots/graphics_gofplots_qqplot.py 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">data</span><span class="s0">,</span>
        <span class="s1">dist=stats.norm</span><span class="s0">,</span>
        <span class="s1">fit=</span><span class="s0">False,</span>
        <span class="s1">distargs=()</span><span class="s0">,</span>
        <span class="s1">a=</span><span class="s4">0</span><span class="s0">,</span>
        <span class="s1">loc=</span><span class="s4">0</span><span class="s0">,</span>
        <span class="s1">scale=</span><span class="s4">1</span><span class="s0">,</span>
    <span class="s1">):</span>

        <span class="s1">self.data = data</span>
        <span class="s1">self.a = a</span>
        <span class="s1">self.nobs = data.shape[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">self.distargs = distargs</span>
        <span class="s1">self.fit = fit</span>

        <span class="s1">self._is_frozen = isinstance(dist</span><span class="s0">, </span><span class="s1">stats.distributions.rv_frozen)</span>
        <span class="s0">if </span><span class="s1">self._is_frozen </span><span class="s0">and </span><span class="s1">(</span>
            <span class="s1">fit </span><span class="s0">or </span><span class="s1">loc != </span><span class="s4">0 </span><span class="s0">or </span><span class="s1">scale != </span><span class="s4">1 </span><span class="s0">or </span><span class="s1">distargs != ()</span>
        <span class="s1">):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s2">&quot;Frozen distributions cannot be combined with fit, loc, scale&quot;</span>
                <span class="s2">&quot; or distargs.&quot;</span>
            <span class="s1">)</span>
        <span class="s5"># propertes</span>
        <span class="s1">self._cache = {}</span>
        <span class="s0">if </span><span class="s1">self._is_frozen:</span>
            <span class="s1">self.dist = dist</span>
            <span class="s1">dist_gen = dist.dist</span>
            <span class="s1">shapes = dist_gen.shapes</span>
            <span class="s0">if </span><span class="s1">shapes </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">shape_args = tuple(map(str.strip</span><span class="s0">, </span><span class="s1">shapes.split(</span><span class="s2">&quot;,&quot;</span><span class="s1">)))</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">shape_args = ()</span>
            <span class="s1">numargs = len(shape_args)</span>
            <span class="s1">args = dist.args</span>
            <span class="s0">if </span><span class="s1">len(args) &gt;= numargs + </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">self.loc = args[numargs]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">self.loc = dist.kwds.get(</span><span class="s2">&quot;loc&quot;</span><span class="s0">, </span><span class="s1">loc)</span>
            <span class="s0">if </span><span class="s1">len(args) &gt;= numargs + </span><span class="s4">2</span><span class="s1">:</span>
                <span class="s1">self.scale = args[numargs + </span><span class="s4">1</span><span class="s1">]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">self.scale = dist.kwds.get(</span><span class="s2">&quot;scale&quot;</span><span class="s0">, </span><span class="s1">scale)</span>
            <span class="s1">fit_params = []</span>
            <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">enumerate(shape_args):</span>
                <span class="s0">if </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">dist.kwds:</span>
                    <span class="s1">value = dist.kwds[arg]</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">value = dist.args[i]</span>
                <span class="s1">fit_params.append(value)</span>
            <span class="s1">self.fit_params = np.r_[fit_params</span><span class="s0">, </span><span class="s1">self.loc</span><span class="s0">, </span><span class="s1">self.scale]</span>
        <span class="s0">elif </span><span class="s1">fit:</span>
            <span class="s1">self.fit_params = dist.fit(data)</span>
            <span class="s1">self.loc = self.fit_params[-</span><span class="s4">2</span><span class="s1">]</span>
            <span class="s1">self.scale = self.fit_params[-</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s0">if </span><span class="s1">len(self.fit_params) &gt; </span><span class="s4">2</span><span class="s1">:</span>
                <span class="s1">self.dist = dist(*self.fit_params[:-</span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">**dict(loc=</span><span class="s4">0</span><span class="s0">, </span><span class="s1">scale=</span><span class="s4">1</span><span class="s1">))</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">self.dist = dist(loc=</span><span class="s4">0</span><span class="s0">, </span><span class="s1">scale=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">distargs </span><span class="s0">or </span><span class="s1">loc != </span><span class="s4">0 </span><span class="s0">or </span><span class="s1">scale != </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">self.dist = dist(*distargs</span><span class="s0">, </span><span class="s1">**dict(loc=loc</span><span class="s0">, </span><span class="s1">scale=scale))</span>
            <span class="s0">except </span><span class="s1">Exception:</span>
                <span class="s1">distargs = </span><span class="s2">&quot;, &quot;</span><span class="s1">.join([str(da) </span><span class="s0">for </span><span class="s1">da </span><span class="s0">in </span><span class="s1">distargs])</span>
                <span class="s1">cmd = </span><span class="s2">&quot;dist({distargs}, loc={loc}, scale={scale})&quot;</span>
                <span class="s1">cmd = cmd.format(distargs=distargs</span><span class="s0">, </span><span class="s1">loc=loc</span><span class="s0">, </span><span class="s1">scale=scale)</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span>
                    <span class="s2">&quot;Initializing the distribution failed.  This &quot;</span>
                    <span class="s2">&quot;can occur if distargs contains loc or scale. &quot;</span>
                    <span class="s2">&quot;The distribution initialization command &quot;</span>
                    <span class="s2">&quot;is:</span><span class="s0">\n</span><span class="s2">{cmd}&quot;</span><span class="s1">.format(cmd=cmd)</span>
                <span class="s1">)</span>
            <span class="s1">self.loc = loc</span>
            <span class="s1">self.scale = scale</span>
            <span class="s1">self.fit_params = np.r_[distargs</span><span class="s0">, </span><span class="s1">loc</span><span class="s0">, </span><span class="s1">scale]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.dist = dist</span>
            <span class="s1">self.loc = loc</span>
            <span class="s1">self.scale = scale</span>
            <span class="s1">self.fit_params = np.r_[loc</span><span class="s0">, </span><span class="s1">scale]</span>

    <span class="s1">@cache_readonly</span>
    <span class="s0">def </span><span class="s1">theoretical_percentiles(self):</span>
        <span class="s3">&quot;&quot;&quot;Theoretical percentiles&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">plotting_pos(self.nobs</span><span class="s0">, </span><span class="s1">self.a)</span>

    <span class="s1">@cache_readonly</span>
    <span class="s0">def </span><span class="s1">theoretical_quantiles(self):</span>
        <span class="s3">&quot;&quot;&quot;Theoretical quantiles&quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self.dist.ppf(self.theoretical_percentiles)</span>
        <span class="s0">except </span><span class="s1">TypeError:</span>
            <span class="s1">msg = </span><span class="s2">&quot;%s requires more parameters to compute ppf&quot;</span><span class="s1">.format(</span>
                <span class="s1">self.dist.name</span><span class="s0">,</span>
            <span class="s1">)</span>
            <span class="s0">raise </span><span class="s1">TypeError(msg)</span>
        <span class="s0">except </span><span class="s1">Exception </span><span class="s0">as </span><span class="s1">exc:</span>
            <span class="s1">msg = </span><span class="s2">&quot;failed to compute the ppf of {0}&quot;</span><span class="s1">.format(self.dist.name)</span>
            <span class="s0">raise </span><span class="s1">type(exc)(msg)</span>

    <span class="s1">@cache_readonly</span>
    <span class="s0">def </span><span class="s1">sorted_data(self):</span>
        <span class="s3">&quot;&quot;&quot;sorted data&quot;&quot;&quot;</span>
        <span class="s1">sorted_data = np.array(self.data</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">sorted_data.sort()</span>
        <span class="s0">return </span><span class="s1">sorted_data</span>

    <span class="s1">@cache_readonly</span>
    <span class="s0">def </span><span class="s1">sample_quantiles(self):</span>
        <span class="s3">&quot;&quot;&quot;sample quantiles&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">self.fit </span><span class="s0">and </span><span class="s1">self.loc != </span><span class="s4">0 </span><span class="s0">and </span><span class="s1">self.scale != </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">(self.sorted_data - self.loc) / self.scale</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self.sorted_data</span>

    <span class="s1">@cache_readonly</span>
    <span class="s0">def </span><span class="s1">sample_percentiles(self):</span>
        <span class="s3">&quot;&quot;&quot;Sample percentiles&quot;&quot;&quot;</span>
        <span class="s1">_check_for(self.dist</span><span class="s0">, </span><span class="s2">&quot;cdf&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">self._is_frozen:</span>
            <span class="s0">return </span><span class="s1">self.dist.cdf(self.sorted_data)</span>
        <span class="s1">quantiles = (self.sorted_data - self.fit_params[-</span><span class="s4">2</span><span class="s1">]) / self.fit_params[</span>
            <span class="s1">-</span><span class="s4">1</span>
        <span class="s1">]</span>
        <span class="s0">return </span><span class="s1">self.dist.cdf(quantiles)</span>

    <span class="s0">def </span><span class="s1">ppplot(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">xlabel=</span><span class="s0">None,</span>
        <span class="s1">ylabel=</span><span class="s0">None,</span>
        <span class="s1">line=</span><span class="s0">None,</span>
        <span class="s1">other=</span><span class="s0">None,</span>
        <span class="s1">ax=</span><span class="s0">None,</span>
        <span class="s1">**plotkwargs</span><span class="s0">,</span>
    <span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Plot of the percentiles of x versus the percentiles of a distribution. 
 
        Parameters 
        ---------- 
        xlabel : str or None, optional 
            User-provided labels for the x-axis. If None (default), 
            other values are used depending on the status of the kwarg `other`. 
        ylabel : str or None, optional 
            User-provided labels for the y-axis. If None (default), 
            other values are used depending on the status of the kwarg `other`. 
        line : {None, &quot;45&quot;, &quot;s&quot;, &quot;r&quot;, q&quot;}, optional 
            Options for the reference line to which the data is compared: 
 
            - &quot;45&quot;: 45-degree line 
            - &quot;s&quot;: standardized line, the expected order statistics are 
              scaled by the standard deviation of the given sample and have 
              the mean added to them 
            - &quot;r&quot;: A regression line is fit 
            - &quot;q&quot;: A line is fit through the quartiles. 
            - None: by default no reference line is added to the plot. 
 
        other : ProbPlot, array_like, or None, optional 
            If provided, ECDF(x) will be plotted against p(x) where x are 
            sorted samples from `self`. ECDF is an empirical cumulative 
            distribution function estimated from `other` and 
            p(x) = 0.5/n, 1.5/n, ..., (n-0.5)/n where n is the number of 
            samples in `self`. If an array-object is provided, it will be 
            turned into a `ProbPlot` instance default parameters. If not 
            provided (default), `self.dist(x)` is be plotted against p(x). 
 
        ax : AxesSubplot, optional 
            If given, this subplot is used to plot in instead of a new figure 
            being created. 
        **plotkwargs 
            Additional arguments to be passed to the `plot` command. 
 
        Returns 
        ------- 
        Figure 
            If `ax` is None, the created figure.  Otherwise the figure to which 
            `ax` is connected. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">other </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">check_other = isinstance(other</span><span class="s0">, </span><span class="s1">ProbPlot)</span>
            <span class="s0">if not </span><span class="s1">check_other:</span>
                <span class="s1">other = ProbPlot(other)</span>

            <span class="s1">p_x = self.theoretical_percentiles</span>
            <span class="s1">ecdf_x = ECDF(other.sample_quantiles)(self.sample_quantiles)</span>

            <span class="s1">fig</span><span class="s0">, </span><span class="s1">ax = _do_plot(</span>
                <span class="s1">p_x</span><span class="s0">, </span><span class="s1">ecdf_x</span><span class="s0">, </span><span class="s1">self.dist</span><span class="s0">, </span><span class="s1">ax=ax</span><span class="s0">, </span><span class="s1">line=line</span><span class="s0">, </span><span class="s1">**plotkwargs</span>
            <span class="s1">)</span>

            <span class="s0">if </span><span class="s1">xlabel </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">xlabel = </span><span class="s2">&quot;Probabilities of 2nd Sample&quot;</span>
            <span class="s0">if </span><span class="s1">ylabel </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">ylabel = </span><span class="s2">&quot;Probabilities of 1st Sample&quot;</span>

        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">fig</span><span class="s0">, </span><span class="s1">ax = _do_plot(</span>
                <span class="s1">self.theoretical_percentiles</span><span class="s0">,</span>
                <span class="s1">self.sample_percentiles</span><span class="s0">,</span>
                <span class="s1">self.dist</span><span class="s0">,</span>
                <span class="s1">ax=ax</span><span class="s0">,</span>
                <span class="s1">line=line</span><span class="s0">,</span>
                <span class="s1">**plotkwargs</span><span class="s0">,</span>
            <span class="s1">)</span>
            <span class="s0">if </span><span class="s1">xlabel </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">xlabel = </span><span class="s2">&quot;Theoretical Probabilities&quot;</span>
            <span class="s0">if </span><span class="s1">ylabel </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">ylabel = </span><span class="s2">&quot;Sample Probabilities&quot;</span>

        <span class="s1">ax.set_xlabel(xlabel)</span>
        <span class="s1">ax.set_ylabel(ylabel)</span>

        <span class="s1">ax.set_xlim([</span><span class="s4">0.0</span><span class="s0">, </span><span class="s4">1.0</span><span class="s1">])</span>
        <span class="s1">ax.set_ylim([</span><span class="s4">0.0</span><span class="s0">, </span><span class="s4">1.0</span><span class="s1">])</span>

        <span class="s0">return </span><span class="s1">fig</span>

    <span class="s0">def </span><span class="s1">qqplot(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">xlabel=</span><span class="s0">None,</span>
        <span class="s1">ylabel=</span><span class="s0">None,</span>
        <span class="s1">line=</span><span class="s0">None,</span>
        <span class="s1">other=</span><span class="s0">None,</span>
        <span class="s1">ax=</span><span class="s0">None,</span>
        <span class="s1">swap: bool = </span><span class="s0">False,</span>
        <span class="s1">**plotkwargs</span><span class="s0">,</span>
    <span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Plot of the quantiles of x versus the quantiles/ppf of a distribution. 
 
        Can also be used to plot against the quantiles of another `ProbPlot` 
        instance. 
 
        Parameters 
        ---------- 
        xlabel : {None, str} 
            User-provided labels for the x-axis. If None (default), 
            other values are used depending on the status of the kwarg `other`. 
        ylabel : {None, str} 
            User-provided labels for the y-axis. If None (default), 
            other values are used depending on the status of the kwarg `other`. 
        line : {None, &quot;45&quot;, &quot;s&quot;, &quot;r&quot;, q&quot;}, optional 
            Options for the reference line to which the data is compared: 
 
            - &quot;45&quot; - 45-degree line 
            - &quot;s&quot; - standardized line, the expected order statistics are scaled 
              by the standard deviation of the given sample and have the mean 
              added to them 
            - &quot;r&quot; - A regression line is fit 
            - &quot;q&quot; - A line is fit through the quartiles. 
            - None - by default no reference line is added to the plot. 
 
        other : {ProbPlot, array_like, None}, optional 
            If provided, the sample quantiles of this `ProbPlot` instance are 
            plotted against the sample quantiles of the `other` `ProbPlot` 
            instance. Sample size of `other` must be equal or larger than 
            this `ProbPlot` instance. If the sample size is larger, sample 
            quantiles of `other` will be interpolated to match the sample size 
            of this `ProbPlot` instance. If an array-like object is provided, 
            it will be turned into a `ProbPlot` instance using default 
            parameters. If not provided (default), the theoretical quantiles 
            are used. 
        ax : AxesSubplot, optional 
            If given, this subplot is used to plot in instead of a new figure 
            being created. 
        swap : bool, optional 
            Flag indicating to swap the x and y labels. 
        **plotkwargs 
            Additional arguments to be passed to the `plot` command. 
 
        Returns 
        ------- 
        Figure 
            If `ax` is None, the created figure.  Otherwise the figure to which 
            `ax` is connected. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">other </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">check_other = isinstance(other</span><span class="s0">, </span><span class="s1">ProbPlot)</span>
            <span class="s0">if not </span><span class="s1">check_other:</span>
                <span class="s1">other = ProbPlot(other)</span>

            <span class="s1">s_self = self.sample_quantiles</span>
            <span class="s1">s_other = other.sample_quantiles</span>

            <span class="s0">if </span><span class="s1">len(s_self) &gt; len(s_other):</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span>
                    <span class="s2">&quot;Sample size of `other` must be equal or &quot;</span>
                    <span class="s1">+ </span><span class="s2">&quot;larger than this `ProbPlot` instance&quot;</span>
                <span class="s1">)</span>
            <span class="s0">elif </span><span class="s1">len(s_self) &lt; len(s_other):</span>
                <span class="s5"># Use quantiles of the smaller set and interpolate quantiles of</span>
                <span class="s5"># the larger data set</span>
                <span class="s1">p = plotting_pos(self.nobs</span><span class="s0">, </span><span class="s1">self.a)</span>
                <span class="s1">s_other = stats.mstats.mquantiles(s_other</span><span class="s0">, </span><span class="s1">p)</span>
            <span class="s1">fig</span><span class="s0">, </span><span class="s1">ax = _do_plot(</span>
                <span class="s1">s_other</span><span class="s0">, </span><span class="s1">s_self</span><span class="s0">, </span><span class="s1">self.dist</span><span class="s0">, </span><span class="s1">ax=ax</span><span class="s0">, </span><span class="s1">line=line</span><span class="s0">, </span><span class="s1">**plotkwargs</span>
            <span class="s1">)</span>

            <span class="s0">if </span><span class="s1">xlabel </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">xlabel = </span><span class="s2">&quot;Quantiles of 2nd Sample&quot;</span>
            <span class="s0">if </span><span class="s1">ylabel </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">ylabel = </span><span class="s2">&quot;Quantiles of 1st Sample&quot;</span>
            <span class="s0">if </span><span class="s1">swap:</span>
                <span class="s1">xlabel</span><span class="s0">, </span><span class="s1">ylabel = ylabel</span><span class="s0">, </span><span class="s1">xlabel</span>

        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">fig</span><span class="s0">, </span><span class="s1">ax = _do_plot(</span>
                <span class="s1">self.theoretical_quantiles</span><span class="s0">,</span>
                <span class="s1">self.sample_quantiles</span><span class="s0">,</span>
                <span class="s1">self.dist</span><span class="s0">,</span>
                <span class="s1">ax=ax</span><span class="s0">,</span>
                <span class="s1">line=line</span><span class="s0">,</span>
                <span class="s1">**plotkwargs</span><span class="s0">,</span>
            <span class="s1">)</span>
            <span class="s0">if </span><span class="s1">xlabel </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">xlabel = </span><span class="s2">&quot;Theoretical Quantiles&quot;</span>
            <span class="s0">if </span><span class="s1">ylabel </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">ylabel = </span><span class="s2">&quot;Sample Quantiles&quot;</span>

        <span class="s1">ax.set_xlabel(xlabel)</span>
        <span class="s1">ax.set_ylabel(ylabel)</span>

        <span class="s0">return </span><span class="s1">fig</span>

    <span class="s0">def </span><span class="s1">probplot(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">xlabel=</span><span class="s0">None,</span>
        <span class="s1">ylabel=</span><span class="s0">None,</span>
        <span class="s1">line=</span><span class="s0">None,</span>
        <span class="s1">exceed=</span><span class="s0">False,</span>
        <span class="s1">ax=</span><span class="s0">None,</span>
        <span class="s1">**plotkwargs</span><span class="s0">,</span>
    <span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Plot of unscaled quantiles of x against the prob of a distribution. 
 
        The x-axis is scaled linearly with the quantiles, but the probabilities 
        are used to label the axis. 
 
        Parameters 
        ---------- 
        xlabel : {None, str}, optional 
            User-provided labels for the x-axis. If None (default), 
            other values are used depending on the status of the kwarg `other`. 
        ylabel : {None, str}, optional 
            User-provided labels for the y-axis. If None (default), 
            other values are used depending on the status of the kwarg `other`. 
        line : {None, &quot;45&quot;, &quot;s&quot;, &quot;r&quot;, q&quot;}, optional 
            Options for the reference line to which the data is compared: 
 
            - &quot;45&quot; - 45-degree line 
            - &quot;s&quot; - standardized line, the expected order statistics are scaled 
              by the standard deviation of the given sample and have the mean 
              added to them 
            - &quot;r&quot; - A regression line is fit 
            - &quot;q&quot; - A line is fit through the quartiles. 
            - None - by default no reference line is added to the plot. 
 
        exceed : bool, optional 
            If False (default) the raw sample quantiles are plotted against 
            the theoretical quantiles, show the probability that a sample will 
            not exceed a given value. If True, the theoretical quantiles are 
            flipped such that the figure displays the probability that a 
            sample will exceed a given value. 
        ax : AxesSubplot, optional 
            If given, this subplot is used to plot in instead of a new figure 
            being created. 
        **plotkwargs 
            Additional arguments to be passed to the `plot` command. 
 
        Returns 
        ------- 
        Figure 
            If `ax` is None, the created figure.  Otherwise the figure to which 
            `ax` is connected. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">exceed:</span>
            <span class="s1">fig</span><span class="s0">, </span><span class="s1">ax = _do_plot(</span>
                <span class="s1">self.theoretical_quantiles[::-</span><span class="s4">1</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">self.sorted_data</span><span class="s0">,</span>
                <span class="s1">self.dist</span><span class="s0">,</span>
                <span class="s1">ax=ax</span><span class="s0">,</span>
                <span class="s1">line=line</span><span class="s0">,</span>
                <span class="s1">**plotkwargs</span><span class="s0">,</span>
            <span class="s1">)</span>
            <span class="s0">if </span><span class="s1">xlabel </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">xlabel = </span><span class="s2">&quot;Probability of Exceedance (%)&quot;</span>

        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">fig</span><span class="s0">, </span><span class="s1">ax = _do_plot(</span>
                <span class="s1">self.theoretical_quantiles</span><span class="s0">,</span>
                <span class="s1">self.sorted_data</span><span class="s0">,</span>
                <span class="s1">self.dist</span><span class="s0">,</span>
                <span class="s1">ax=ax</span><span class="s0">,</span>
                <span class="s1">line=line</span><span class="s0">,</span>
                <span class="s1">**plotkwargs</span><span class="s0">,</span>
            <span class="s1">)</span>
            <span class="s0">if </span><span class="s1">xlabel </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">xlabel = </span><span class="s2">&quot;Non-exceedance Probability (%)&quot;</span>

        <span class="s0">if </span><span class="s1">ylabel </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">ylabel = </span><span class="s2">&quot;Sample Quantiles&quot;</span>

        <span class="s1">ax.set_xlabel(xlabel)</span>
        <span class="s1">ax.set_ylabel(ylabel)</span>
        <span class="s1">_fmt_probplot_axis(ax</span><span class="s0">, </span><span class="s1">self.dist</span><span class="s0">, </span><span class="s1">self.nobs)</span>

        <span class="s0">return </span><span class="s1">fig</span>


<span class="s0">def </span><span class="s1">qqplot(</span>
    <span class="s1">data</span><span class="s0">,</span>
    <span class="s1">dist=stats.norm</span><span class="s0">,</span>
    <span class="s1">distargs=()</span><span class="s0">,</span>
    <span class="s1">a=</span><span class="s4">0</span><span class="s0">,</span>
    <span class="s1">loc=</span><span class="s4">0</span><span class="s0">,</span>
    <span class="s1">scale=</span><span class="s4">1</span><span class="s0">,</span>
    <span class="s1">fit=</span><span class="s0">False,</span>
    <span class="s1">line=</span><span class="s0">None,</span>
    <span class="s1">ax=</span><span class="s0">None,</span>
    <span class="s1">**plotkwargs</span><span class="s0">,</span>
<span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Q-Q plot of the quantiles of x versus the quantiles/ppf of a distribution. 
 
    Can take arguments specifying the parameters for dist or fit them 
    automatically. (See fit under Parameters.) 
 
    Parameters 
    ---------- 
    data : array_like 
        A 1d data array. 
    dist : callable 
        Comparison distribution. The default is 
        scipy.stats.distributions.norm (a standard normal). 
    distargs : tuple 
        A tuple of arguments passed to dist to specify it fully 
        so dist.ppf may be called. 
    a : float 
        Offset for the plotting position of an expected order statistic, for 
        example. The plotting positions are given by (i - a)/(nobs - 2*a + 1) 
        for i in range(0,nobs+1) 
    loc : float 
        Location parameter for dist 
    scale : float 
        Scale parameter for dist 
    fit : bool 
        If fit is false, loc, scale, and distargs are passed to the 
        distribution. If fit is True then the parameters for dist 
        are fit automatically using dist.fit. The quantiles are formed 
        from the standardized data, after subtracting the fitted loc 
        and dividing by the fitted scale. 
    line : {None, &quot;45&quot;, &quot;s&quot;, &quot;r&quot;, &quot;q&quot;} 
        Options for the reference line to which the data is compared: 
 
        - &quot;45&quot; - 45-degree line 
        - &quot;s&quot; - standardized line, the expected order statistics are scaled 
          by the standard deviation of the given sample and have the mean 
          added to them 
        - &quot;r&quot; - A regression line is fit 
        - &quot;q&quot; - A line is fit through the quartiles. 
        - None - by default no reference line is added to the plot. 
 
    ax : AxesSubplot, optional 
        If given, this subplot is used to plot in instead of a new figure being 
        created. 
    **plotkwargs 
        Additional matplotlib arguments to be passed to the `plot` command. 
 
    Returns 
    ------- 
    Figure 
        If `ax` is None, the created figure.  Otherwise the figure to which 
        `ax` is connected. 
 
    See Also 
    -------- 
    scipy.stats.probplot 
 
    Notes 
    ----- 
    Depends on matplotlib. If `fit` is True then the parameters are fit using 
    the distribution's fit() method. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import statsmodels.api as sm 
    &gt;&gt;&gt; from matplotlib import pyplot as plt 
    &gt;&gt;&gt; data = sm.datasets.longley.load() 
    &gt;&gt;&gt; exog = sm.add_constant(data.exog) 
    &gt;&gt;&gt; mod_fit = sm.OLS(data.endog, exog).fit() 
    &gt;&gt;&gt; res = mod_fit.resid # residuals 
    &gt;&gt;&gt; fig = sm.qqplot(res) 
    &gt;&gt;&gt; plt.show() 
 
    qqplot of the residuals against quantiles of t-distribution with 4 degrees 
    of freedom: 
 
    &gt;&gt;&gt; import scipy.stats as stats 
    &gt;&gt;&gt; fig = sm.qqplot(res, stats.t, distargs=(4,)) 
    &gt;&gt;&gt; plt.show() 
 
    qqplot against same as above, but with mean 3 and std 10: 
 
    &gt;&gt;&gt; fig = sm.qqplot(res, stats.t, distargs=(4,), loc=3, scale=10) 
    &gt;&gt;&gt; plt.show() 
 
    Automatically determine parameters for t distribution including the 
    loc and scale: 
 
    &gt;&gt;&gt; fig = sm.qqplot(res, stats.t, fit=True, line=&quot;45&quot;) 
    &gt;&gt;&gt; plt.show() 
 
    The following plot displays some options, follow the link to see the code. 
 
    .. plot:: plots/graphics_gofplots_qqplot.py 
    &quot;&quot;&quot;</span>
    <span class="s1">probplot = ProbPlot(</span>
        <span class="s1">data</span><span class="s0">, </span><span class="s1">dist=dist</span><span class="s0">, </span><span class="s1">distargs=distargs</span><span class="s0">, </span><span class="s1">fit=fit</span><span class="s0">, </span><span class="s1">a=a</span><span class="s0">, </span><span class="s1">loc=loc</span><span class="s0">, </span><span class="s1">scale=scale</span>
    <span class="s1">)</span>
    <span class="s1">fig = probplot.qqplot(ax=ax</span><span class="s0">, </span><span class="s1">line=line</span><span class="s0">, </span><span class="s1">**plotkwargs)</span>
    <span class="s0">return </span><span class="s1">fig</span>


<span class="s0">def </span><span class="s1">qqplot_2samples(</span>
    <span class="s1">data1</span><span class="s0">, </span><span class="s1">data2</span><span class="s0">, </span><span class="s1">xlabel=</span><span class="s0">None, </span><span class="s1">ylabel=</span><span class="s0">None, </span><span class="s1">line=</span><span class="s0">None, </span><span class="s1">ax=</span><span class="s0">None</span>
<span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Q-Q Plot of two samples' quantiles. 
 
    Can take either two `ProbPlot` instances or two array-like objects. In the 
    case of the latter, both inputs will be converted to `ProbPlot` instances 
    using only the default values - so use `ProbPlot` instances if 
    finer-grained control of the quantile computations is required. 
 
    Parameters 
    ---------- 
    data1 : {array_like, ProbPlot} 
        Data to plot along x axis. If the sample sizes are unequal, the longer 
        series is always plotted along the x-axis. 
    data2 : {array_like, ProbPlot} 
        Data to plot along y axis. Does not need to have the same number of 
        observations as data 1. If the sample sizes are unequal, the longer 
        series is always plotted along the x-axis. 
    xlabel : {None, str} 
        User-provided labels for the x-axis. If None (default), 
        other values are used. 
    ylabel : {None, str} 
        User-provided labels for the y-axis. If None (default), 
        other values are used. 
    line : {None, &quot;45&quot;, &quot;s&quot;, &quot;r&quot;, q&quot;} 
        Options for the reference line to which the data is compared: 
 
        - &quot;45&quot; - 45-degree line 
        - &quot;s&quot; - standardized line, the expected order statistics are scaled 
          by the standard deviation of the given sample and have the mean 
          added to them 
        - &quot;r&quot; - A regression line is fit 
        - &quot;q&quot; - A line is fit through the quartiles. 
        - None - by default no reference line is added to the plot. 
 
    ax : AxesSubplot, optional 
        If given, this subplot is used to plot in instead of a new figure being 
        created. 
 
    Returns 
    ------- 
    Figure 
        If `ax` is None, the created figure.  Otherwise the figure to which 
        `ax` is connected. 
 
    See Also 
    -------- 
    scipy.stats.probplot 
 
    Notes 
    ----- 
    1) Depends on matplotlib. 
    2) If `data1` and `data2` are not `ProbPlot` instances, instances will be 
       created using the default parameters. Therefore, it is recommended to use 
       `ProbPlot` instance if fine-grained control is needed in the computation 
       of the quantiles. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import statsmodels.api as sm 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; from statsmodels.graphics.gofplots import qqplot_2samples 
    &gt;&gt;&gt; x = np.random.normal(loc=8.5, scale=2.5, size=37) 
    &gt;&gt;&gt; y = np.random.normal(loc=8.0, scale=3.0, size=37) 
    &gt;&gt;&gt; pp_x = sm.ProbPlot(x) 
    &gt;&gt;&gt; pp_y = sm.ProbPlot(y) 
    &gt;&gt;&gt; qqplot_2samples(pp_x, pp_y) 
    &gt;&gt;&gt; plt.show() 
 
    .. plot:: plots/graphics_gofplots_qqplot_2samples.py 
 
    &gt;&gt;&gt; fig = qqplot_2samples(pp_x, pp_y, xlabel=None, ylabel=None, 
    ...                       line=None, ax=None) 
    &quot;&quot;&quot;</span>
    <span class="s0">if not </span><span class="s1">isinstance(data1</span><span class="s0">, </span><span class="s1">ProbPlot):</span>
        <span class="s1">data1 = ProbPlot(data1)</span>

    <span class="s0">if not </span><span class="s1">isinstance(data2</span><span class="s0">, </span><span class="s1">ProbPlot):</span>
        <span class="s1">data2 = ProbPlot(data2)</span>
    <span class="s0">if </span><span class="s1">data2.data.shape[</span><span class="s4">0</span><span class="s1">] &gt; data1.data.shape[</span><span class="s4">0</span><span class="s1">]:</span>
        <span class="s1">fig = data1.qqplot(</span>
            <span class="s1">xlabel=ylabel</span><span class="s0">, </span><span class="s1">ylabel=xlabel</span><span class="s0">, </span><span class="s1">line=line</span><span class="s0">, </span><span class="s1">other=data2</span><span class="s0">, </span><span class="s1">ax=ax</span>
        <span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">fig = data2.qqplot(</span>
            <span class="s1">xlabel=ylabel</span><span class="s0">,</span>
            <span class="s1">ylabel=xlabel</span><span class="s0">,</span>
            <span class="s1">line=line</span><span class="s0">,</span>
            <span class="s1">other=data1</span><span class="s0">,</span>
            <span class="s1">ax=ax</span><span class="s0">,</span>
            <span class="s1">swap=</span><span class="s0">True,</span>
        <span class="s1">)</span>

    <span class="s0">return </span><span class="s1">fig</span>


<span class="s0">def </span><span class="s1">qqline(ax</span><span class="s0">, </span><span class="s1">line</span><span class="s0">, </span><span class="s1">x=</span><span class="s0">None, </span><span class="s1">y=</span><span class="s0">None, </span><span class="s1">dist=</span><span class="s0">None, </span><span class="s1">fmt=</span><span class="s2">&quot;r-&quot;</span><span class="s0">, </span><span class="s1">**lineoptions):</span>
    <span class="s3">&quot;&quot;&quot; 
    Plot a reference line for a qqplot. 
 
    Parameters 
    ---------- 
    ax : matplotlib axes instance 
        The axes on which to plot the line 
    line : str {&quot;45&quot;,&quot;r&quot;,&quot;s&quot;,&quot;q&quot;} 
        Options for the reference line to which the data is compared.: 
 
        - &quot;45&quot; - 45-degree line 
        - &quot;s&quot;  - standardized line, the expected order statistics are scaled by 
                 the standard deviation of the given sample and have the mean 
                 added to them 
        - &quot;r&quot;  - A regression line is fit 
        - &quot;q&quot;  - A line is fit through the quartiles. 
        - None - By default no reference line is added to the plot. 
 
    x : ndarray 
        X data for plot. Not needed if line is &quot;45&quot;. 
    y : ndarray 
        Y data for plot. Not needed if line is &quot;45&quot;. 
    dist : scipy.stats.distribution 
        A scipy.stats distribution, needed if line is &quot;q&quot;. 
    fmt : str, optional 
        Line format string passed to `plot`. 
    **lineoptions 
        Additional arguments to be passed to the `plot` command. 
 
    Notes 
    ----- 
    There is no return value. The line is plotted on the given `ax`. 
 
    Examples 
    -------- 
    Import the food expenditure dataset.  Plot annual food expenditure on x-axis 
    and household income on y-axis.  Use qqline to add regression line into the 
    plot. 
 
    &gt;&gt;&gt; import statsmodels.api as sm 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; from statsmodels.graphics.gofplots import qqline 
 
    &gt;&gt;&gt; foodexp = sm.datasets.engel.load() 
    &gt;&gt;&gt; x = foodexp.exog 
    &gt;&gt;&gt; y = foodexp.endog 
    &gt;&gt;&gt; ax = plt.subplot(111) 
    &gt;&gt;&gt; plt.scatter(x, y) 
    &gt;&gt;&gt; ax.set_xlabel(foodexp.exog_name[0]) 
    &gt;&gt;&gt; ax.set_ylabel(foodexp.endog_name) 
    &gt;&gt;&gt; qqline(ax, &quot;r&quot;, x, y) 
    &gt;&gt;&gt; plt.show() 
 
    .. plot:: plots/graphics_gofplots_qqplot_qqline.py 
    &quot;&quot;&quot;</span>
    <span class="s1">lineoptions = lineoptions.copy()</span>
    <span class="s0">for </span><span class="s1">ls </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;-&quot;</span><span class="s0">, </span><span class="s2">&quot;--&quot;</span><span class="s0">, </span><span class="s2">&quot;-.&quot;</span><span class="s0">, </span><span class="s2">&quot;:&quot;</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">ls </span><span class="s0">in </span><span class="s1">fmt:</span>
            <span class="s1">lineoptions.setdefault(</span><span class="s2">&quot;linestyle&quot;</span><span class="s0">, </span><span class="s1">ls)</span>
            <span class="s1">fmt = fmt.replace(ls</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s1">)</span>
            <span class="s0">break</span>
    <span class="s0">for </span><span class="s1">marker </span><span class="s0">in </span><span class="s1">(</span>
        <span class="s2">&quot;.&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;,&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;o&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;v&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;^&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;&lt;&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;&gt;&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;1&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;2&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;3&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;4&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;8&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;s&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;p&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;P&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;*&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;h&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;H&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;+&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;x&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;X&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;D&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;d&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;|&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;_&quot;</span><span class="s0">,</span>
    <span class="s1">):</span>
        <span class="s0">if </span><span class="s1">marker </span><span class="s0">in </span><span class="s1">fmt:</span>
            <span class="s1">lineoptions.setdefault(</span><span class="s2">&quot;marker&quot;</span><span class="s0">, </span><span class="s1">marker)</span>
            <span class="s1">fmt = fmt.replace(marker</span><span class="s0">, </span><span class="s2">&quot;&quot;</span><span class="s1">)</span>
            <span class="s0">break</span>
    <span class="s0">if </span><span class="s1">fmt:</span>
        <span class="s1">lineoptions.setdefault(</span><span class="s2">&quot;color&quot;</span><span class="s0">, </span><span class="s1">fmt)</span>

    <span class="s0">if </span><span class="s1">line == </span><span class="s2">&quot;45&quot;</span><span class="s1">:</span>
        <span class="s1">end_pts = lzip(ax.get_xlim()</span><span class="s0">, </span><span class="s1">ax.get_ylim())</span>
        <span class="s1">end_pts[</span><span class="s4">0</span><span class="s1">] = min(end_pts[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">end_pts[</span><span class="s4">1</span><span class="s1">] = max(end_pts[</span><span class="s4">1</span><span class="s1">])</span>
        <span class="s1">ax.plot(end_pts</span><span class="s0">, </span><span class="s1">end_pts</span><span class="s0">, </span><span class="s1">**lineoptions)</span>
        <span class="s1">ax.set_xlim(end_pts)</span>
        <span class="s1">ax.set_ylim(end_pts)</span>
        <span class="s0">return  </span><span class="s5"># does this have any side effects?</span>
    <span class="s0">if </span><span class="s1">x </span><span class="s0">is None or </span><span class="s1">y </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;If line is not 45, x and y cannot be None.&quot;</span><span class="s1">)</span>
    <span class="s1">x = np.array(x)</span>
    <span class="s1">y = np.array(y)</span>
    <span class="s0">if </span><span class="s1">line == </span><span class="s2">&quot;r&quot;</span><span class="s1">:</span>
        <span class="s5"># could use ax.lines[0].get_xdata(), get_ydata(),</span>
        <span class="s5"># but don't know axes are &quot;clean&quot;</span>
        <span class="s1">y = OLS(y</span><span class="s0">, </span><span class="s1">add_constant(x)).fit().fittedvalues</span>
        <span class="s1">ax.plot(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">**lineoptions)</span>
    <span class="s0">elif </span><span class="s1">line == </span><span class="s2">&quot;s&quot;</span><span class="s1">:</span>
        <span class="s1">m</span><span class="s0">, </span><span class="s1">b = np.std(y)</span><span class="s0">, </span><span class="s1">np.mean(y)</span>
        <span class="s1">ref_line = x * m + b</span>
        <span class="s1">ax.plot(x</span><span class="s0">, </span><span class="s1">ref_line</span><span class="s0">, </span><span class="s1">**lineoptions)</span>
    <span class="s0">elif </span><span class="s1">line == </span><span class="s2">&quot;q&quot;</span><span class="s1">:</span>
        <span class="s1">_check_for(dist</span><span class="s0">, </span><span class="s2">&quot;ppf&quot;</span><span class="s1">)</span>
        <span class="s1">q25 = stats.scoreatpercentile(y</span><span class="s0">, </span><span class="s4">25</span><span class="s1">)</span>
        <span class="s1">q75 = stats.scoreatpercentile(y</span><span class="s0">, </span><span class="s4">75</span><span class="s1">)</span>
        <span class="s1">theoretical_quartiles = dist.ppf([</span><span class="s4">0.25</span><span class="s0">, </span><span class="s4">0.75</span><span class="s1">])</span>
        <span class="s1">m = (q75 - q25) / np.diff(theoretical_quartiles)</span>
        <span class="s1">b = q25 - m * theoretical_quartiles[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">ax.plot(x</span><span class="s0">, </span><span class="s1">m * x + b</span><span class="s0">, </span><span class="s1">**lineoptions)</span>


<span class="s5"># about 10x faster than plotting_position in sandbox and mstats</span>
<span class="s0">def </span><span class="s1">plotting_pos(nobs</span><span class="s0">, </span><span class="s1">a=</span><span class="s4">0.0</span><span class="s0">, </span><span class="s1">b=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Generates sequence of plotting positions 
 
    Parameters 
    ---------- 
    nobs : int 
        Number of probability points to plot 
    a : float, default 0.0 
        alpha parameter for the plotting position of an expected order 
        statistic 
    b : float, default None 
        beta parameter for the plotting position of an expected order 
        statistic. If None, then b is set to a. 
 
    Returns 
    ------- 
    ndarray 
        The plotting positions 
 
    Notes 
    ----- 
    The plotting positions are given by (i - a)/(nobs + 1 - a - b) for i in 
    range(1, nobs+1) 
 
    See Also 
    -------- 
    scipy.stats.mstats.plotting_positions 
        Additional information on alpha and beta 
    &quot;&quot;&quot;</span>
    <span class="s1">b = a </span><span class="s0">if </span><span class="s1">b </span><span class="s0">is None else </span><span class="s1">b</span>
    <span class="s0">return </span><span class="s1">(np.arange(</span><span class="s4">1.0</span><span class="s0">, </span><span class="s1">nobs + </span><span class="s4">1</span><span class="s1">) - a) / (nobs + </span><span class="s4">1 </span><span class="s1">- a - b)</span>


<span class="s0">def </span><span class="s1">_fmt_probplot_axis(ax</span><span class="s0">, </span><span class="s1">dist</span><span class="s0">, </span><span class="s1">nobs):</span>
    <span class="s3">&quot;&quot;&quot; 
    Formats a theoretical quantile axis to display the corresponding 
    probabilities on the quantiles' scale. 
 
    Parameters 
    ---------- 
    ax : AxesSubplot, optional 
        The axis to be formatted 
    nobs : scalar 
        Number of observations in the sample 
    dist : scipy.stats.distribution 
        A scipy.stats distribution sufficiently specified to implement its 
        ppf() method. 
 
    Returns 
    ------- 
    There is no return value. This operates on `ax` in place 
    &quot;&quot;&quot;</span>
    <span class="s1">_check_for(dist</span><span class="s0">, </span><span class="s2">&quot;ppf&quot;</span><span class="s1">)</span>
    <span class="s1">axis_probs = np.linspace(</span><span class="s4">10</span><span class="s0">, </span><span class="s4">90</span><span class="s0">, </span><span class="s4">9</span><span class="s0">, </span><span class="s1">dtype=float)</span>
    <span class="s1">small = np.array([</span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">5</span><span class="s1">])</span>
    <span class="s1">axis_probs = np.r_[small</span><span class="s0">, </span><span class="s1">axis_probs</span><span class="s0">, </span><span class="s4">100 </span><span class="s1">- small[::-</span><span class="s4">1</span><span class="s1">]]</span>
    <span class="s0">if </span><span class="s1">nobs &gt;= </span><span class="s4">50</span><span class="s1">:</span>
        <span class="s1">axis_probs = np.r_[small / </span><span class="s4">10</span><span class="s0">, </span><span class="s1">axis_probs</span><span class="s0">, </span><span class="s4">100 </span><span class="s1">- small[::-</span><span class="s4">1</span><span class="s1">] / </span><span class="s4">10</span><span class="s1">]</span>
    <span class="s0">if </span><span class="s1">nobs &gt;= </span><span class="s4">500</span><span class="s1">:</span>
        <span class="s1">axis_probs = np.r_[small / </span><span class="s4">100</span><span class="s0">, </span><span class="s1">axis_probs</span><span class="s0">, </span><span class="s4">100 </span><span class="s1">- small[::-</span><span class="s4">1</span><span class="s1">] / </span><span class="s4">100</span><span class="s1">]</span>
    <span class="s1">axis_probs /= </span><span class="s4">100.0</span>
    <span class="s1">axis_qntls = dist.ppf(axis_probs)</span>
    <span class="s1">ax.set_xticks(axis_qntls)</span>
    <span class="s1">ax.set_xticklabels(</span>
        <span class="s1">[str(lbl) </span><span class="s0">for </span><span class="s1">lbl </span><span class="s0">in </span><span class="s1">(axis_probs * </span><span class="s4">100</span><span class="s1">)]</span><span class="s0">,</span>
        <span class="s1">rotation=</span><span class="s4">45</span><span class="s0">,</span>
        <span class="s1">rotation_mode=</span><span class="s2">&quot;anchor&quot;</span><span class="s0">,</span>
        <span class="s1">horizontalalignment=</span><span class="s2">&quot;right&quot;</span><span class="s0">,</span>
        <span class="s1">verticalalignment=</span><span class="s2">&quot;center&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">ax.set_xlim([axis_qntls.min()</span><span class="s0">, </span><span class="s1">axis_qntls.max()])</span>


<span class="s0">def </span><span class="s1">_do_plot(</span>
    <span class="s1">x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">dist=</span><span class="s0">None, </span><span class="s1">line=</span><span class="s0">None, </span><span class="s1">ax=</span><span class="s0">None, </span><span class="s1">fmt=</span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s1">step=</span><span class="s0">False, </span><span class="s1">**kwargs</span>
<span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot; 
    Boiler plate plotting function for the `ppplot`, `qqplot`, and 
    `probplot` methods of the `ProbPlot` class 
 
    Parameters 
    ---------- 
    x : array_like 
        X-axis data to be plotted 
    y : array_like 
        Y-axis data to be plotted 
    dist : scipy.stats.distribution 
        A scipy.stats distribution, needed if `line` is &quot;q&quot;. 
    line : {&quot;45&quot;, &quot;s&quot;, &quot;r&quot;, &quot;q&quot;, None}, default None 
        Options for the reference line to which the data is compared. 
    ax : AxesSubplot, optional 
        If given, this subplot is used to plot in instead of a new figure being 
        created. 
    fmt : str, optional 
        matplotlib-compatible formatting string for the data markers 
    kwargs : keywords 
        These are passed to matplotlib.plot 
 
    Returns 
    ------- 
    fig : Figure 
        The figure containing `ax`. 
    ax : AxesSubplot 
        The original axes if provided.  Otherwise a new instance. 
    &quot;&quot;&quot;</span>
    <span class="s1">plot_style = {</span>
        <span class="s2">&quot;marker&quot;</span><span class="s1">: </span><span class="s2">&quot;o&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;markerfacecolor&quot;</span><span class="s1">: </span><span class="s2">&quot;C0&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;markeredgecolor&quot;</span><span class="s1">: </span><span class="s2">&quot;C0&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;linestyle&quot;</span><span class="s1">: </span><span class="s2">&quot;none&quot;</span><span class="s0">,</span>
    <span class="s1">}</span>

    <span class="s1">plot_style.update(**kwargs)</span>
    <span class="s1">where = plot_style.pop(</span><span class="s2">&quot;where&quot;</span><span class="s0">, </span><span class="s2">&quot;pre&quot;</span><span class="s1">)</span>

    <span class="s1">fig</span><span class="s0">, </span><span class="s1">ax = utils.create_mpl_ax(ax)</span>
    <span class="s1">ax.set_xmargin(</span><span class="s4">0.02</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">step:</span>
        <span class="s1">ax.step(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">fmt</span><span class="s0">, </span><span class="s1">where=where</span><span class="s0">, </span><span class="s1">**plot_style)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">ax.plot(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">fmt</span><span class="s0">, </span><span class="s1">**plot_style)</span>
    <span class="s0">if </span><span class="s1">line:</span>
        <span class="s0">if </span><span class="s1">line </span><span class="s0">not in </span><span class="s1">[</span><span class="s2">&quot;r&quot;</span><span class="s0">, </span><span class="s2">&quot;q&quot;</span><span class="s0">, </span><span class="s2">&quot;45&quot;</span><span class="s0">, </span><span class="s2">&quot;s&quot;</span><span class="s1">]:</span>
            <span class="s1">msg = </span><span class="s2">&quot;%s option for line not understood&quot; </span><span class="s1">% line</span>
            <span class="s0">raise </span><span class="s1">ValueError(msg)</span>

        <span class="s1">qqline(ax</span><span class="s0">, </span><span class="s1">line</span><span class="s0">, </span><span class="s1">x=x</span><span class="s0">, </span><span class="s1">y=y</span><span class="s0">, </span><span class="s1">dist=dist)</span>

    <span class="s0">return </span><span class="s1">fig</span><span class="s0">, </span><span class="s1">ax</span>


<span class="s0">def </span><span class="s1">_check_for(dist</span><span class="s0">, </span><span class="s1">attr=</span><span class="s2">&quot;ppf&quot;</span><span class="s1">):</span>
    <span class="s0">if not </span><span class="s1">hasattr(dist</span><span class="s0">, </span><span class="s1">attr):</span>
        <span class="s0">raise </span><span class="s1">AttributeError(</span><span class="s2">f&quot;distribution must have a </span><span class="s0">{</span><span class="s1">attr</span><span class="s0">} </span><span class="s2">method&quot;</span><span class="s1">)</span>
</pre>
</body>
</html>