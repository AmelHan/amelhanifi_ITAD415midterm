<html>
<head>
<title>test_upfirdn.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_upfirdn.py</font>
</center></td></tr></table>
<pre><span class="s0"># Code adapted from &quot;upfirdn&quot; python library with permission:</span>
<span class="s0">#</span>
<span class="s0"># Copyright (c) 2009, Motorola, Inc</span>
<span class="s0">#</span>
<span class="s0"># All Rights Reserved.</span>
<span class="s0">#</span>
<span class="s0"># Redistribution and use in source and binary forms, with or without</span>
<span class="s0"># modification, are permitted provided that the following conditions are</span>
<span class="s0"># met:</span>
<span class="s0">#</span>
<span class="s0"># * Redistributions of source code must retain the above copyright notice,</span>
<span class="s0"># this list of conditions and the following disclaimer.</span>
<span class="s0">#</span>
<span class="s0"># * Redistributions in binary form must reproduce the above copyright</span>
<span class="s0"># notice, this list of conditions and the following disclaimer in the</span>
<span class="s0"># documentation and/or other materials provided with the distribution.</span>
<span class="s0">#</span>
<span class="s0"># * Neither the name of Motorola nor the names of its contributors may be</span>
<span class="s0"># used to endorse or promote products derived from this software without</span>
<span class="s0"># specific prior written permission.</span>
<span class="s0">#</span>
<span class="s0"># THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS</span>
<span class="s0"># IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,</span>
<span class="s0"># THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR</span>
<span class="s0"># PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR</span>
<span class="s0"># CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,</span>
<span class="s0"># EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,</span>
<span class="s0"># PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR</span>
<span class="s0"># PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF</span>
<span class="s0"># LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING</span>
<span class="s0"># NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS</span>
<span class="s0"># SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>


<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">itertools </span><span class="s2">import </span><span class="s1">product</span>

<span class="s2">from </span><span class="s1">numpy.testing </span><span class="s2">import </span><span class="s1">assert_equal</span><span class="s2">, </span><span class="s1">assert_allclose</span>
<span class="s2">from </span><span class="s1">pytest </span><span class="s2">import </span><span class="s1">raises </span><span class="s2">as </span><span class="s1">assert_raises</span>
<span class="s2">import </span><span class="s1">pytest</span>

<span class="s2">from </span><span class="s1">scipy.signal </span><span class="s2">import </span><span class="s1">upfirdn</span><span class="s2">, </span><span class="s1">firwin</span>
<span class="s2">from </span><span class="s1">scipy.signal._upfirdn </span><span class="s2">import </span><span class="s1">_output_len</span><span class="s2">, </span><span class="s1">_upfirdn_modes</span>
<span class="s2">from </span><span class="s1">scipy.signal._upfirdn_apply </span><span class="s2">import </span><span class="s1">_pad_test</span>


<span class="s2">def </span><span class="s1">upfirdn_naive(x</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">up=</span><span class="s3">1</span><span class="s2">, </span><span class="s1">down=</span><span class="s3">1</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot;Naive upfirdn processing in Python. 
 
    Note: arg order (x, h) differs to facilitate apply_along_axis use. 
    &quot;&quot;&quot;</span>
    <span class="s1">h = np.asarray(h)</span>
    <span class="s1">out = np.zeros(len(x) * up</span><span class="s2">, </span><span class="s1">x.dtype)</span>
    <span class="s1">out[::up] = x</span>
    <span class="s1">out = np.convolve(h</span><span class="s2">, </span><span class="s1">out)[::down][:_output_len(len(h)</span><span class="s2">, </span><span class="s1">len(x)</span><span class="s2">, </span><span class="s1">up</span><span class="s2">, </span><span class="s1">down)]</span>
    <span class="s2">return </span><span class="s1">out</span>


<span class="s2">class </span><span class="s1">UpFIRDnCase:</span>
    <span class="s4">&quot;&quot;&quot;Test _UpFIRDn object&quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">up</span><span class="s2">, </span><span class="s1">down</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">x_dtype):</span>
        <span class="s1">self.up = up</span>
        <span class="s1">self.down = down</span>
        <span class="s1">self.h = np.atleast_1d(h)</span>
        <span class="s1">self.x_dtype = x_dtype</span>
        <span class="s1">self.rng = np.random.RandomState(</span><span class="s3">17</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__call__(self):</span>
        <span class="s0"># tiny signal</span>
        <span class="s1">self.scrub(np.ones(</span><span class="s3">1</span><span class="s2">, </span><span class="s1">self.x_dtype))</span>
        <span class="s0"># ones</span>
        <span class="s1">self.scrub(np.ones(</span><span class="s3">10</span><span class="s2">, </span><span class="s1">self.x_dtype))  </span><span class="s0"># ones</span>
        <span class="s0"># randn</span>
        <span class="s1">x = self.rng.randn(</span><span class="s3">10</span><span class="s1">).astype(self.x_dtype)</span>
        <span class="s2">if </span><span class="s1">self.x_dtype </span><span class="s2">in </span><span class="s1">(np.complex64</span><span class="s2">, </span><span class="s1">np.complex128):</span>
            <span class="s1">x += </span><span class="s3">1j </span><span class="s1">* self.rng.randn(</span><span class="s3">10</span><span class="s1">)</span>
        <span class="s1">self.scrub(x)</span>
        <span class="s0"># ramp</span>
        <span class="s1">self.scrub(np.arange(</span><span class="s3">10</span><span class="s1">).astype(self.x_dtype))</span>
        <span class="s0"># 3D, random</span>
        <span class="s1">size = (</span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">5</span><span class="s1">)</span>
        <span class="s1">x = self.rng.randn(*size).astype(self.x_dtype)</span>
        <span class="s2">if </span><span class="s1">self.x_dtype </span><span class="s2">in </span><span class="s1">(np.complex64</span><span class="s2">, </span><span class="s1">np.complex128):</span>
            <span class="s1">x += </span><span class="s3">1j </span><span class="s1">* self.rng.randn(*size)</span>
        <span class="s2">for </span><span class="s1">axis </span><span class="s2">in </span><span class="s1">range(len(size)):</span>
            <span class="s1">self.scrub(x</span><span class="s2">, </span><span class="s1">axis=axis)</span>
        <span class="s1">x = x[:</span><span class="s2">, </span><span class="s1">::</span><span class="s3">2</span><span class="s2">, </span><span class="s3">1</span><span class="s1">::</span><span class="s3">3</span><span class="s1">].T</span>
        <span class="s2">for </span><span class="s1">axis </span><span class="s2">in </span><span class="s1">range(len(size)):</span>
            <span class="s1">self.scrub(x</span><span class="s2">, </span><span class="s1">axis=axis)</span>

    <span class="s2">def </span><span class="s1">scrub(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s1">):</span>
        <span class="s1">yr = np.apply_along_axis(upfirdn_naive</span><span class="s2">, </span><span class="s1">axis</span><span class="s2">, </span><span class="s1">x</span><span class="s2">,</span>
                                 <span class="s1">self.h</span><span class="s2">, </span><span class="s1">self.up</span><span class="s2">, </span><span class="s1">self.down)</span>
        <span class="s1">want_len = _output_len(len(self.h)</span><span class="s2">, </span><span class="s1">x.shape[axis]</span><span class="s2">, </span><span class="s1">self.up</span><span class="s2">, </span><span class="s1">self.down)</span>
        <span class="s2">assert </span><span class="s1">yr.shape[axis] == want_len</span>
        <span class="s1">y = upfirdn(self.h</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">self.up</span><span class="s2">, </span><span class="s1">self.down</span><span class="s2">, </span><span class="s1">axis=axis)</span>
        <span class="s2">assert </span><span class="s1">y.shape[axis] == want_len</span>
        <span class="s2">assert </span><span class="s1">y.shape == yr.shape</span>
        <span class="s1">dtypes = (self.h.dtype</span><span class="s2">, </span><span class="s1">x.dtype)</span>
        <span class="s2">if </span><span class="s1">all(d == np.complex64 </span><span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">dtypes):</span>
            <span class="s1">assert_equal(y.dtype</span><span class="s2">, </span><span class="s1">np.complex64)</span>
        <span class="s2">elif </span><span class="s1">np.complex64 </span><span class="s2">in </span><span class="s1">dtypes </span><span class="s2">and </span><span class="s1">np.float32 </span><span class="s2">in </span><span class="s1">dtypes:</span>
            <span class="s1">assert_equal(y.dtype</span><span class="s2">, </span><span class="s1">np.complex64)</span>
        <span class="s2">elif </span><span class="s1">all(d == np.float32 </span><span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">dtypes):</span>
            <span class="s1">assert_equal(y.dtype</span><span class="s2">, </span><span class="s1">np.float32)</span>
        <span class="s2">elif </span><span class="s1">np.complex128 </span><span class="s2">in </span><span class="s1">dtypes </span><span class="s2">or </span><span class="s1">np.complex64 </span><span class="s2">in </span><span class="s1">dtypes:</span>
            <span class="s1">assert_equal(y.dtype</span><span class="s2">, </span><span class="s1">np.complex128)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">assert_equal(y.dtype</span><span class="s2">, </span><span class="s1">np.float64)</span>
        <span class="s1">assert_allclose(yr</span><span class="s2">, </span><span class="s1">y)</span>


<span class="s1">_UPFIRDN_TYPES = (int</span><span class="s2">, </span><span class="s1">np.float32</span><span class="s2">, </span><span class="s1">np.complex64</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">complex)</span>


<span class="s2">class </span><span class="s1">TestUpfirdn:</span>

    <span class="s2">def </span><span class="s1">test_valid_input(self):</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">upfirdn</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)  </span><span class="s0"># up or down &lt; 1</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">upfirdn</span><span class="s2">, </span><span class="s1">[]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)  </span><span class="s0"># h.ndim != 1</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">upfirdn</span><span class="s2">, </span><span class="s1">[[</span><span class="s3">1</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'len_h'</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">5</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'len_x'</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">5</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_singleton(self</span><span class="s2">, </span><span class="s1">len_h</span><span class="s2">, </span><span class="s1">len_x):</span>
        <span class="s0"># gh-9844: lengths producing expected outputs</span>
        <span class="s1">h = np.zeros(len_h)</span>
        <span class="s1">h[len_h // </span><span class="s3">2</span><span class="s1">] = </span><span class="s3">1.  </span><span class="s0"># make h a delta</span>
        <span class="s1">x = np.ones(len_x)</span>
        <span class="s1">y = upfirdn(h</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">want = np.pad(x</span><span class="s2">, </span><span class="s1">(len_h // </span><span class="s3">2</span><span class="s2">, </span><span class="s1">(len_h - </span><span class="s3">1</span><span class="s1">) // </span><span class="s3">2</span><span class="s1">)</span><span class="s2">, </span><span class="s5">'constant'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(y</span><span class="s2">, </span><span class="s1">want)</span>

    <span class="s2">def </span><span class="s1">test_shift_x(self):</span>
        <span class="s0"># gh-9844: shifted x can change values?</span>
        <span class="s1">y = upfirdn([</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(y</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">])  </span><span class="s0"># was [0, 1] in the issue</span>
        <span class="s1">y = upfirdn([</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0.</span><span class="s2">, </span><span class="s3">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(y</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">])</span>

    <span class="s0"># A bunch of lengths/factors chosen because they exposed differences</span>
    <span class="s0"># between the &quot;old way&quot; and new way of computing length, and then</span>
    <span class="s0"># got `expected` from MATLAB</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'len_h, len_x, up, down, expected'</span><span class="s2">, </span><span class="s1">[</span>
        <span class="s1">(</span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">5</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">6</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">2</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">3</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">6</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">4</span><span class="s2">, </span><span class="s3">11</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">5</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s1">])</span><span class="s2">,</span>
    <span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_length_factors(self</span><span class="s2">, </span><span class="s1">len_h</span><span class="s2">, </span><span class="s1">len_x</span><span class="s2">, </span><span class="s1">up</span><span class="s2">, </span><span class="s1">down</span><span class="s2">, </span><span class="s1">expected):</span>
        <span class="s0"># gh-9844: weird factors</span>
        <span class="s1">h = np.zeros(len_h)</span>
        <span class="s1">h[</span><span class="s3">0</span><span class="s1">] = </span><span class="s3">1.</span>
        <span class="s1">x = np.ones(len_x)</span>
        <span class="s1">y = upfirdn(h</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">up</span><span class="s2">, </span><span class="s1">down)</span>
        <span class="s1">assert_allclose(y</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'down, want_len'</span><span class="s2">, </span><span class="s1">[  </span><span class="s0"># lengths from MATLAB</span>
        <span class="s1">(</span><span class="s3">2</span><span class="s2">, </span><span class="s3">5015</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">11</span><span class="s2">, </span><span class="s3">912</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">79</span><span class="s2">, </span><span class="s3">127</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_vs_convolve(self</span><span class="s2">, </span><span class="s1">down</span><span class="s2">, </span><span class="s1">want_len):</span>
        <span class="s0"># Check that up=1.0 gives same answer as convolve + slicing</span>
        <span class="s1">random_state = np.random.RandomState(</span><span class="s3">17</span><span class="s1">)</span>
        <span class="s1">try_types = (int</span><span class="s2">, </span><span class="s1">np.float32</span><span class="s2">, </span><span class="s1">np.complex64</span><span class="s2">, </span><span class="s1">float</span><span class="s2">, </span><span class="s1">complex)</span>
        <span class="s1">size = </span><span class="s3">10000</span>

        <span class="s2">for </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">try_types:</span>
            <span class="s1">x = random_state.randn(size).astype(dtype)</span>
            <span class="s2">if </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">(np.complex64</span><span class="s2">, </span><span class="s1">np.complex128):</span>
                <span class="s1">x += </span><span class="s3">1j </span><span class="s1">* random_state.randn(size)</span>

            <span class="s1">h = firwin(</span><span class="s3">31</span><span class="s2">, </span><span class="s3">1. </span><span class="s1">/ down</span><span class="s2">, </span><span class="s1">window=</span><span class="s5">'hamming'</span><span class="s1">)</span>
            <span class="s1">yl = upfirdn_naive(x</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s1">down)</span>
            <span class="s1">y = upfirdn(h</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">up=</span><span class="s3">1</span><span class="s2">, </span><span class="s1">down=down)</span>
            <span class="s2">assert </span><span class="s1">y.shape == (want_len</span><span class="s2">,</span><span class="s1">)</span>
            <span class="s2">assert </span><span class="s1">yl.shape[</span><span class="s3">0</span><span class="s1">] == y.shape[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s1">assert_allclose(yl</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">atol=</span><span class="s3">1e-7</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s3">1e-7</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'x_dtype'</span><span class="s2">, </span><span class="s1">_UPFIRDN_TYPES)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'h'</span><span class="s2">, </span><span class="s1">(</span><span class="s3">1.</span><span class="s2">, </span><span class="s3">1j</span><span class="s1">))</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'up, down'</span><span class="s2">, </span><span class="s1">[(</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">3</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_vs_naive_delta(self</span><span class="s2">, </span><span class="s1">x_dtype</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">up</span><span class="s2">, </span><span class="s1">down):</span>
        <span class="s1">UpFIRDnCase(up</span><span class="s2">, </span><span class="s1">down</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">x_dtype)()</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'x_dtype'</span><span class="s2">, </span><span class="s1">_UPFIRDN_TYPES)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'h_dtype'</span><span class="s2">, </span><span class="s1">_UPFIRDN_TYPES)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'p_max, q_max'</span><span class="s2">,</span>
                             <span class="s1">list(product((</span><span class="s3">10</span><span class="s2">, </span><span class="s3">100</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">10</span><span class="s2">, </span><span class="s3">100</span><span class="s1">))))</span>
    <span class="s2">def </span><span class="s1">test_vs_naive(self</span><span class="s2">, </span><span class="s1">x_dtype</span><span class="s2">, </span><span class="s1">h_dtype</span><span class="s2">, </span><span class="s1">p_max</span><span class="s2">, </span><span class="s1">q_max):</span>
        <span class="s1">tests = self._random_factors(p_max</span><span class="s2">, </span><span class="s1">q_max</span><span class="s2">, </span><span class="s1">h_dtype</span><span class="s2">, </span><span class="s1">x_dtype)</span>
        <span class="s2">for </span><span class="s1">test </span><span class="s2">in </span><span class="s1">tests:</span>
            <span class="s1">test()</span>

    <span class="s2">def </span><span class="s1">_random_factors(self</span><span class="s2">, </span><span class="s1">p_max</span><span class="s2">, </span><span class="s1">q_max</span><span class="s2">, </span><span class="s1">h_dtype</span><span class="s2">, </span><span class="s1">x_dtype):</span>
        <span class="s1">n_rep = </span><span class="s3">3</span>
        <span class="s1">longest_h = </span><span class="s3">25</span>
        <span class="s1">random_state = np.random.RandomState(</span><span class="s3">17</span><span class="s1">)</span>
        <span class="s1">tests = []</span>

        <span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range(n_rep):</span>
            <span class="s0"># Randomize the up/down factors somewhat</span>
            <span class="s1">p_add = q_max </span><span class="s2">if </span><span class="s1">p_max &gt; q_max </span><span class="s2">else </span><span class="s3">1</span>
            <span class="s1">q_add = p_max </span><span class="s2">if </span><span class="s1">q_max &gt; p_max </span><span class="s2">else </span><span class="s3">1</span>
            <span class="s1">p = random_state.randint(p_max) + p_add</span>
            <span class="s1">q = random_state.randint(q_max) + q_add</span>

            <span class="s0"># Generate random FIR coefficients</span>
            <span class="s1">len_h = random_state.randint(longest_h) + </span><span class="s3">1</span>
            <span class="s1">h = np.atleast_1d(random_state.randint(len_h))</span>
            <span class="s1">h = h.astype(h_dtype)</span>
            <span class="s2">if </span><span class="s1">h_dtype == complex:</span>
                <span class="s1">h += </span><span class="s3">1j </span><span class="s1">* random_state.randint(len_h)</span>

            <span class="s1">tests.append(UpFIRDnCase(p</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">x_dtype))</span>

        <span class="s2">return </span><span class="s1">tests</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'mode'</span><span class="s2">, </span><span class="s1">_upfirdn_modes)</span>
    <span class="s2">def </span><span class="s1">test_extensions(self</span><span class="s2">, </span><span class="s1">mode):</span>
        <span class="s4">&quot;&quot;&quot;Test vs. manually computed results for modes not in numpy's pad.&quot;&quot;&quot;</span>
        <span class="s1">x = np.array([</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=float)</span>
        <span class="s1">npre</span><span class="s2">, </span><span class="s1">npost = </span><span class="s3">6</span><span class="s2">, </span><span class="s3">6</span>
        <span class="s1">y = _pad_test(x</span><span class="s2">, </span><span class="s1">npre=npre</span><span class="s2">, </span><span class="s1">npost=npost</span><span class="s2">, </span><span class="s1">mode=mode)</span>
        <span class="s2">if </span><span class="s1">mode == </span><span class="s5">'antisymmetric'</span><span class="s1">:</span>
            <span class="s1">y_expected = np.asarray(</span>
                <span class="s1">[</span><span class="s3">3</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">3</span><span class="s2">, </span><span class="s1">-</span><span class="s3">2</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">3</span><span class="s2">, </span><span class="s1">-</span><span class="s3">2</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s1">])</span>
        <span class="s2">elif </span><span class="s1">mode == </span><span class="s5">'antireflect'</span><span class="s1">:</span>
            <span class="s1">y_expected = np.asarray(</span>
                <span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">1</span><span class="s1">])</span>
        <span class="s2">elif </span><span class="s1">mode == </span><span class="s5">'smooth'</span><span class="s1">:</span>
            <span class="s1">y_expected = np.asarray(</span>
                <span class="s1">[-</span><span class="s3">5</span><span class="s2">, </span><span class="s1">-</span><span class="s3">4</span><span class="s2">, </span><span class="s1">-</span><span class="s3">3</span><span class="s2">, </span><span class="s1">-</span><span class="s3">2</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">3</span><span class="s2">, </span><span class="s1">-</span><span class="s3">5</span><span class="s2">, </span><span class="s1">-</span><span class="s3">7</span><span class="s2">, </span><span class="s1">-</span><span class="s3">9</span><span class="s2">, </span><span class="s1">-</span><span class="s3">11</span><span class="s1">])</span>
        <span class="s2">elif </span><span class="s1">mode == </span><span class="s5">&quot;line&quot;</span><span class="s1">:</span>
            <span class="s1">lin_slope = (x[-</span><span class="s3">1</span><span class="s1">] - x[</span><span class="s3">0</span><span class="s1">]) / (len(x) - </span><span class="s3">1</span><span class="s1">)</span>
            <span class="s1">left = x[</span><span class="s3">0</span><span class="s1">] + np.arange(-npre</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s1">) * lin_slope</span>
            <span class="s1">right = x[-</span><span class="s3">1</span><span class="s1">] + np.arange(</span><span class="s3">1</span><span class="s2">, </span><span class="s1">npost + </span><span class="s3">1</span><span class="s1">) * lin_slope</span>
            <span class="s1">y_expected = np.concatenate((left</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">right))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">y_expected = np.pad(x</span><span class="s2">, </span><span class="s1">(npre</span><span class="s2">, </span><span class="s1">npost)</span><span class="s2">, </span><span class="s1">mode=mode)</span>
        <span class="s1">assert_allclose(y</span><span class="s2">, </span><span class="s1">y_expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s5">'size, h_len, mode, dtype'</span><span class="s2">,</span>
        <span class="s1">product(</span>
            <span class="s1">[</span><span class="s3">8</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">4</span><span class="s2">, </span><span class="s3">5</span><span class="s2">, </span><span class="s3">26</span><span class="s1">]</span><span class="s2">,  </span><span class="s0"># include cases with h_len &gt; 2*size</span>
            <span class="s1">_upfirdn_modes</span><span class="s2">,</span>
            <span class="s1">[np.float32</span><span class="s2">, </span><span class="s1">np.float64</span><span class="s2">, </span><span class="s1">np.complex64</span><span class="s2">, </span><span class="s1">np.complex128]</span><span class="s2">,</span>
        <span class="s1">)</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_modes(self</span><span class="s2">, </span><span class="s1">size</span><span class="s2">, </span><span class="s1">h_len</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">, </span><span class="s1">dtype):</span>
        <span class="s1">random_state = np.random.RandomState(</span><span class="s3">5</span><span class="s1">)</span>
        <span class="s1">x = random_state.randn(size).astype(dtype)</span>
        <span class="s2">if </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">(np.complex64</span><span class="s2">, </span><span class="s1">np.complex128):</span>
            <span class="s1">x += </span><span class="s3">1j </span><span class="s1">* random_state.randn(size)</span>
        <span class="s1">h = np.arange(</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1 </span><span class="s1">+ h_len</span><span class="s2">, </span><span class="s1">dtype=x.real.dtype)</span>

        <span class="s1">y = upfirdn(h</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">up=</span><span class="s3">1</span><span class="s2">, </span><span class="s1">down=</span><span class="s3">1</span><span class="s2">, </span><span class="s1">mode=mode)</span>
        <span class="s0"># expected result: pad the input, filter with zero padding, then crop</span>
        <span class="s1">npad = h_len - </span><span class="s3">1</span>
        <span class="s2">if </span><span class="s1">mode </span><span class="s2">in </span><span class="s1">[</span><span class="s5">'antisymmetric'</span><span class="s2">, </span><span class="s5">'antireflect'</span><span class="s2">, </span><span class="s5">'smooth'</span><span class="s2">, </span><span class="s5">'line'</span><span class="s1">]:</span>
            <span class="s0"># use _pad_test test function for modes not supported by np.pad.</span>
            <span class="s1">xpad = _pad_test(x</span><span class="s2">, </span><span class="s1">npre=npad</span><span class="s2">, </span><span class="s1">npost=npad</span><span class="s2">, </span><span class="s1">mode=mode)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">xpad = np.pad(x</span><span class="s2">, </span><span class="s1">npad</span><span class="s2">, </span><span class="s1">mode=mode)</span>
        <span class="s1">ypad = upfirdn(h</span><span class="s2">, </span><span class="s1">xpad</span><span class="s2">, </span><span class="s1">up=</span><span class="s3">1</span><span class="s2">, </span><span class="s1">down=</span><span class="s3">1</span><span class="s2">, </span><span class="s1">mode=</span><span class="s5">'constant'</span><span class="s1">)</span>
        <span class="s1">y_expected = ypad[npad:-npad]</span>

        <span class="s1">atol = rtol = np.finfo(dtype).eps * </span><span class="s3">1e2</span>
        <span class="s1">assert_allclose(y</span><span class="s2">, </span><span class="s1">y_expected</span><span class="s2">, </span><span class="s1">atol=atol</span><span class="s2">, </span><span class="s1">rtol=rtol)</span>


<span class="s2">def </span><span class="s1">test_output_len_long_input():</span>
    <span class="s0"># Regression test for gh-17375.  On Windows, a large enough input</span>
    <span class="s0"># that should have been well within the capabilities of 64 bit integers</span>
    <span class="s0"># would result in a 32 bit overflow because of a bug in Cython 0.29.32.</span>
    <span class="s1">len_h = </span><span class="s3">1001</span>
    <span class="s1">in_len = </span><span class="s3">10</span><span class="s1">**</span><span class="s3">8</span>
    <span class="s1">up = </span><span class="s3">320</span>
    <span class="s1">down = </span><span class="s3">441</span>
    <span class="s1">out_len = _output_len(len_h</span><span class="s2">, </span><span class="s1">in_len</span><span class="s2">, </span><span class="s1">up</span><span class="s2">, </span><span class="s1">down)</span>
    <span class="s0"># The expected value was computed &quot;by hand&quot; from the formula</span>
    <span class="s0">#   (((in_len - 1) * up + len_h) - 1) // down + 1</span>
    <span class="s2">assert </span><span class="s1">out_len == </span><span class="s3">72562360</span>
</pre>
</body>
</html>