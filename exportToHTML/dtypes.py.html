<html>
<head>
<title>dtypes.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
dtypes.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Define extension dtypes. 
&quot;&quot;&quot;</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">from </span><span class="s1">datetime </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">date</span><span class="s2">,</span>
    <span class="s1">datetime</span><span class="s2">,</span>
    <span class="s1">time</span><span class="s2">,</span>
    <span class="s1">timedelta</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">decimal </span><span class="s2">import </span><span class="s1">Decimal</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">TYPE_CHECKING</span><span class="s2">,</span>
    <span class="s1">Any</span><span class="s2">,</span>
    <span class="s1">cast</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pytz</span>

<span class="s2">from </span><span class="s1">pandas._libs </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">lib</span><span class="s2">,</span>
    <span class="s1">missing </span><span class="s2">as </span><span class="s1">libmissing</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas._libs.interval </span><span class="s2">import </span><span class="s1">Interval</span>
<span class="s2">from </span><span class="s1">pandas._libs.properties </span><span class="s2">import </span><span class="s1">cache_readonly</span>
<span class="s2">from </span><span class="s1">pandas._libs.tslibs </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">BaseOffset</span><span class="s2">,</span>
    <span class="s1">NaT</span><span class="s2">,</span>
    <span class="s1">NaTType</span><span class="s2">,</span>
    <span class="s1">Period</span><span class="s2">,</span>
    <span class="s1">Timedelta</span><span class="s2">,</span>
    <span class="s1">Timestamp</span><span class="s2">,</span>
    <span class="s1">timezones</span><span class="s2">,</span>
    <span class="s1">to_offset</span><span class="s2">,</span>
    <span class="s1">tz_compare</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas._libs.tslibs.dtypes </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">PeriodDtypeBase</span><span class="s2">,</span>
    <span class="s1">abbrev_to_npy_unit</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas._libs.tslibs.offsets </span><span class="s2">import </span><span class="s1">BDay</span>
<span class="s2">from </span><span class="s1">pandas.compat </span><span class="s2">import </span><span class="s1">pa_version_under7p0</span>
<span class="s2">from </span><span class="s1">pandas.errors </span><span class="s2">import </span><span class="s1">PerformanceWarning</span>
<span class="s2">from </span><span class="s1">pandas.util._exceptions </span><span class="s2">import </span><span class="s1">find_stack_level</span>

<span class="s2">from </span><span class="s1">pandas.core.dtypes.base </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">ExtensionDtype</span><span class="s2">,</span>
    <span class="s1">StorageExtensionDtype</span><span class="s2">,</span>
    <span class="s1">register_extension_dtype</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.dtypes.generic </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">ABCCategoricalIndex</span><span class="s2">,</span>
    <span class="s1">ABCIndex</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas.core.dtypes.inference </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">is_bool</span><span class="s2">,</span>
    <span class="s1">is_list_like</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">if not </span><span class="s1">pa_version_under7p0:</span>
    <span class="s2">import </span><span class="s1">pyarrow </span><span class="s2">as </span><span class="s1">pa</span>

<span class="s2">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s2">from </span><span class="s1">collections.abc </span><span class="s2">import </span><span class="s1">MutableMapping</span>
    <span class="s2">from </span><span class="s1">datetime </span><span class="s2">import </span><span class="s1">tzinfo</span>

    <span class="s2">import </span><span class="s1">pyarrow </span><span class="s2">as </span><span class="s1">pa  </span><span class="s3"># noqa: F811, TCH004</span>

    <span class="s2">from </span><span class="s1">pandas._typing </span><span class="s2">import </span><span class="s1">(</span>
        <span class="s1">Dtype</span><span class="s2">,</span>
        <span class="s1">DtypeObj</span><span class="s2">,</span>
        <span class="s1">IntervalClosedType</span><span class="s2">,</span>
        <span class="s1">Ordered</span><span class="s2">,</span>
        <span class="s1">npt</span><span class="s2">,</span>
        <span class="s1">type_t</span><span class="s2">,</span>
    <span class="s1">)</span>

    <span class="s2">from </span><span class="s1">pandas </span><span class="s2">import </span><span class="s1">(</span>
        <span class="s1">Categorical</span><span class="s2">,</span>
        <span class="s1">Index</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">from </span><span class="s1">pandas.core.arrays </span><span class="s2">import </span><span class="s1">(</span>
        <span class="s1">BaseMaskedArray</span><span class="s2">,</span>
        <span class="s1">DatetimeArray</span><span class="s2">,</span>
        <span class="s1">IntervalArray</span><span class="s2">,</span>
        <span class="s1">NumpyExtensionArray</span><span class="s2">,</span>
        <span class="s1">PeriodArray</span><span class="s2">,</span>
        <span class="s1">SparseArray</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">from </span><span class="s1">pandas.core.arrays.arrow </span><span class="s2">import </span><span class="s1">ArrowExtensionArray</span>

<span class="s1">str_type = str</span>


<span class="s2">class </span><span class="s1">PandasExtensionDtype(ExtensionDtype):</span>
    <span class="s0">&quot;&quot;&quot; 
    A np.dtype duck-typed class, suitable for holding a custom dtype. 
 
    THIS IS NOT A REAL NUMPY DTYPE 
    &quot;&quot;&quot;</span>

    <span class="s1">type: Any</span>
    <span class="s1">kind: Any</span>
    <span class="s3"># The Any type annotations above are here only because mypy seems to have a</span>
    <span class="s3"># problem dealing with multiple inheritance from PandasExtensionDtype</span>
    <span class="s3"># and ExtensionDtype's @properties in the subclasses below. The kind and</span>
    <span class="s3"># type variables in those subclasses are explicitly typed below.</span>
    <span class="s1">subdtype = </span><span class="s2">None</span>
    <span class="s1">str: str_type</span>
    <span class="s1">num = </span><span class="s4">100</span>
    <span class="s1">shape: tuple[int</span><span class="s2">, </span><span class="s1">...] = ()</span>
    <span class="s1">itemsize = </span><span class="s4">8</span>
    <span class="s1">base: DtypeObj | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None</span>
    <span class="s1">isbuiltin = </span><span class="s4">0</span>
    <span class="s1">isnative = </span><span class="s4">0</span>
    <span class="s1">_cache_dtypes: dict[str_type</span><span class="s2">, </span><span class="s1">PandasExtensionDtype] = {}</span>

    <span class="s2">def </span><span class="s1">__repr__(self) -&gt; str_type:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a string representation for a particular object. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">str(self)</span>

    <span class="s2">def </span><span class="s1">__hash__(self) -&gt; int:</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s5">&quot;sub-classes should implement an __hash__ method&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__getstate__(self) -&gt; dict[str_type</span><span class="s2">, </span><span class="s1">Any]:</span>
        <span class="s3"># pickle support; we don't want to pickle the cache</span>
        <span class="s2">return </span><span class="s1">{k: getattr(self</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, None</span><span class="s1">) </span><span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">self._metadata}</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">reset_cache(cls) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;clear the cache&quot;&quot;&quot;</span>
        <span class="s1">cls._cache_dtypes = {}</span>


<span class="s2">class </span><span class="s1">CategoricalDtypeType(type):</span>
    <span class="s0">&quot;&quot;&quot; 
    the type of CategoricalDtype, this metaclass determines subclass ability 
    &quot;&quot;&quot;</span>


<span class="s1">@register_extension_dtype</span>
<span class="s2">class </span><span class="s1">CategoricalDtype(PandasExtensionDtype</span><span class="s2">, </span><span class="s1">ExtensionDtype):</span>
    <span class="s0">&quot;&quot;&quot; 
    Type for categorical data with the categories and orderedness. 
 
    Parameters 
    ---------- 
    categories : sequence, optional 
        Must be unique, and must not contain any nulls. 
        The categories are stored in an Index, 
        and if an index is provided the dtype of that index will be used. 
    ordered : bool or None, default False 
        Whether or not this categorical is treated as a ordered categorical. 
        None can be used to maintain the ordered value of existing categoricals when 
        used in operations that combine categoricals, e.g. astype, and will resolve to 
        False if there is no existing ordered to maintain. 
 
    Attributes 
    ---------- 
    categories 
    ordered 
 
    Methods 
    ------- 
    None 
 
    See Also 
    -------- 
    Categorical : Represent a categorical variable in classic R / S-plus fashion. 
 
    Notes 
    ----- 
    This class is useful for specifying the type of a ``Categorical`` 
    independent of the values. See :ref:`categorical.categoricaldtype` 
    for more. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; t = pd.CategoricalDtype(categories=['b', 'a'], ordered=True) 
    &gt;&gt;&gt; pd.Series(['a', 'b', 'a', 'c'], dtype=t) 
    0      a 
    1      b 
    2      a 
    3    NaN 
    dtype: category 
    Categories (2, object): ['b' &lt; 'a'] 
 
    An empty CategoricalDtype with a specific dtype can be created 
    by providing an empty index. As follows, 
 
    &gt;&gt;&gt; pd.CategoricalDtype(pd.DatetimeIndex([])).categories.dtype 
    dtype('&lt;M8[ns]') 
    &quot;&quot;&quot;</span>

    <span class="s3"># TODO: Document public vs. private API</span>
    <span class="s1">name = </span><span class="s5">&quot;category&quot;</span>
    <span class="s1">type: type[CategoricalDtypeType] = CategoricalDtypeType</span>
    <span class="s1">kind: str_type = </span><span class="s5">&quot;O&quot;</span>
    <span class="s1">str = </span><span class="s5">&quot;|O08&quot;</span>
    <span class="s1">base = np.dtype(</span><span class="s5">&quot;O&quot;</span><span class="s1">)</span>
    <span class="s1">_metadata = (</span><span class="s5">&quot;categories&quot;</span><span class="s2">, </span><span class="s5">&quot;ordered&quot;</span><span class="s1">)</span>
    <span class="s1">_cache_dtypes: dict[str_type</span><span class="s2">, </span><span class="s1">PandasExtensionDtype] = {}</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">categories=</span><span class="s2">None, </span><span class="s1">ordered: Ordered = </span><span class="s2">False</span><span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self._finalize(categories</span><span class="s2">, </span><span class="s1">ordered</span><span class="s2">, </span><span class="s1">fastpath=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">_from_fastpath(</span>
        <span class="s1">cls</span><span class="s2">, </span><span class="s1">categories=</span><span class="s2">None, </span><span class="s1">ordered: bool | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None</span>
    <span class="s1">) -&gt; CategoricalDtype:</span>
        <span class="s1">self = cls.__new__(cls)</span>
        <span class="s1">self._finalize(categories</span><span class="s2">, </span><span class="s1">ordered</span><span class="s2">, </span><span class="s1">fastpath=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">_from_categorical_dtype(</span>
        <span class="s1">cls</span><span class="s2">, </span><span class="s1">dtype: CategoricalDtype</span><span class="s2">, </span><span class="s1">categories=</span><span class="s2">None, </span><span class="s1">ordered: Ordered | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None</span>
    <span class="s1">) -&gt; CategoricalDtype:</span>
        <span class="s2">if </span><span class="s1">categories </span><span class="s2">is </span><span class="s1">ordered </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">dtype</span>
        <span class="s2">if </span><span class="s1">categories </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">categories = dtype.categories</span>
        <span class="s2">if </span><span class="s1">ordered </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">ordered = dtype.ordered</span>
        <span class="s2">return </span><span class="s1">cls(categories</span><span class="s2">, </span><span class="s1">ordered)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">_from_values_or_dtype(</span>
        <span class="s1">cls</span><span class="s2">,</span>
        <span class="s1">values=</span><span class="s2">None,</span>
        <span class="s1">categories=</span><span class="s2">None,</span>
        <span class="s1">ordered: bool | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">dtype: Dtype | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None,</span>
    <span class="s1">) -&gt; CategoricalDtype:</span>
        <span class="s0">&quot;&quot;&quot; 
        Construct dtype from the input parameters used in :class:`Categorical`. 
 
        This constructor method specifically does not do the factorization 
        step, if that is needed to find the categories. This constructor may 
        therefore return ``CategoricalDtype(categories=None, ordered=None)``, 
        which may not be useful. Additional steps may therefore have to be 
        taken to create the final dtype. 
 
        The return dtype is specified from the inputs in this prioritized 
        order: 
        1. if dtype is a CategoricalDtype, return dtype 
        2. if dtype is the string 'category', create a CategoricalDtype from 
           the supplied categories and ordered parameters, and return that. 
        3. if values is a categorical, use value.dtype, but override it with 
           categories and ordered if either/both of those are not None. 
        4. if dtype is None and values is not a categorical, construct the 
           dtype from categories and ordered, even if either of those is None. 
 
        Parameters 
        ---------- 
        values : list-like, optional 
            The list-like must be 1-dimensional. 
        categories : list-like, optional 
            Categories for the CategoricalDtype. 
        ordered : bool, optional 
            Designating if the categories are ordered. 
        dtype : CategoricalDtype or the string &quot;category&quot;, optional 
            If ``CategoricalDtype``, cannot be used together with 
            `categories` or `ordered`. 
 
        Returns 
        ------- 
        CategoricalDtype 
 
        Examples 
        -------- 
        &gt;&gt;&gt; pd.CategoricalDtype._from_values_or_dtype() 
        CategoricalDtype(categories=None, ordered=None, categories_dtype=None) 
        &gt;&gt;&gt; pd.CategoricalDtype._from_values_or_dtype( 
        ...     categories=['a', 'b'], ordered=True 
        ... ) 
        CategoricalDtype(categories=['a', 'b'], ordered=True, categories_dtype=object) 
        &gt;&gt;&gt; dtype1 = pd.CategoricalDtype(['a', 'b'], ordered=True) 
        &gt;&gt;&gt; dtype2 = pd.CategoricalDtype(['x', 'y'], ordered=False) 
        &gt;&gt;&gt; c = pd.Categorical([0, 1], dtype=dtype1) 
        &gt;&gt;&gt; pd.CategoricalDtype._from_values_or_dtype( 
        ...     c, ['x', 'y'], ordered=True, dtype=dtype2 
        ... ) 
        Traceback (most recent call last): 
            ... 
        ValueError: Cannot specify `categories` or `ordered` together with 
        `dtype`. 
 
        The supplied dtype takes precedence over values' dtype: 
 
        &gt;&gt;&gt; pd.CategoricalDtype._from_values_or_dtype(c, dtype=dtype2) 
        CategoricalDtype(categories=['x', 'y'], ordered=False, categories_dtype=object) 
        &quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">dtype </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s3"># The dtype argument takes precedence over values.dtype (if any)</span>
            <span class="s2">if </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">str):</span>
                <span class="s2">if </span><span class="s1">dtype == </span><span class="s5">&quot;category&quot;</span><span class="s1">:</span>
                    <span class="s2">if </span><span class="s1">ordered </span><span class="s2">is None and </span><span class="s1">cls.is_dtype(values):</span>
                        <span class="s3"># GH#49309 preserve orderedness</span>
                        <span class="s1">ordered = values.dtype.ordered</span>

                    <span class="s1">dtype = CategoricalDtype(categories</span><span class="s2">, </span><span class="s1">ordered)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">f&quot;Unknown dtype </span><span class="s2">{</span><span class="s1">repr(dtype)</span><span class="s2">}</span><span class="s5">&quot;</span><span class="s1">)</span>
            <span class="s2">elif </span><span class="s1">categories </span><span class="s2">is not None or </span><span class="s1">ordered </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s5">&quot;Cannot specify `categories` or `ordered` together with `dtype`.&quot;</span>
                <span class="s1">)</span>
            <span class="s2">elif not </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">CategoricalDtype):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">f&quot;Cannot not construct CategoricalDtype from </span><span class="s2">{</span><span class="s1">dtype</span><span class="s2">}</span><span class="s5">&quot;</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">cls.is_dtype(values):</span>
            <span class="s3"># If no &quot;dtype&quot; was passed, use the one from &quot;values&quot;, but honor</span>
            <span class="s3"># the &quot;ordered&quot; and &quot;categories&quot; arguments</span>
            <span class="s1">dtype = values.dtype._from_categorical_dtype(</span>
                <span class="s1">values.dtype</span><span class="s2">, </span><span class="s1">categories</span><span class="s2">, </span><span class="s1">ordered</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s3"># If dtype=None and values is not categorical, create a new dtype.</span>
            <span class="s3"># Note: This could potentially have categories=None and</span>
            <span class="s3"># ordered=None.</span>
            <span class="s1">dtype = CategoricalDtype(categories</span><span class="s2">, </span><span class="s1">ordered)</span>

        <span class="s2">return </span><span class="s1">cast(CategoricalDtype</span><span class="s2">, </span><span class="s1">dtype)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">construct_from_string(cls</span><span class="s2">, </span><span class="s1">string: str_type) -&gt; CategoricalDtype:</span>
        <span class="s0">&quot;&quot;&quot; 
        Construct a CategoricalDtype from a string. 
 
        Parameters 
        ---------- 
        string : str 
            Must be the string &quot;category&quot; in order to be successfully constructed. 
 
        Returns 
        ------- 
        CategoricalDtype 
            Instance of the dtype. 
 
        Raises 
        ------ 
        TypeError 
            If a CategoricalDtype cannot be constructed from the input. 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">isinstance(string</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s5">f&quot;'construct_from_string' expects a string, got </span><span class="s2">{</span><span class="s1">type(string)</span><span class="s2">}</span><span class="s5">&quot;</span>
            <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">string != cls.name:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s5">f&quot;Cannot construct a 'CategoricalDtype' from '</span><span class="s2">{</span><span class="s1">string</span><span class="s2">}</span><span class="s5">'&quot;</span><span class="s1">)</span>

        <span class="s3"># need ordered=None to ensure that operations specifying dtype=&quot;category&quot; don't</span>
        <span class="s3"># override the ordered value for existing categoricals</span>
        <span class="s2">return </span><span class="s1">cls(ordered=</span><span class="s2">None</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_finalize(self</span><span class="s2">, </span><span class="s1">categories</span><span class="s2">, </span><span class="s1">ordered: Ordered</span><span class="s2">, </span><span class="s1">fastpath: bool = </span><span class="s2">False</span><span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">ordered </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.validate_ordered(ordered)</span>

        <span class="s2">if </span><span class="s1">categories </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">categories = self.validate_categories(categories</span><span class="s2">, </span><span class="s1">fastpath=fastpath)</span>

        <span class="s1">self._categories = categories</span>
        <span class="s1">self._ordered = ordered</span>

    <span class="s2">def </span><span class="s1">__setstate__(self</span><span class="s2">, </span><span class="s1">state: MutableMapping[str_type</span><span class="s2">, </span><span class="s1">Any]) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s3"># for pickle compat. __get_state__ is defined in the</span>
        <span class="s3"># PandasExtensionDtype superclass and uses the public properties to</span>
        <span class="s3"># pickle -&gt; need to set the settable private ones here (see GH26067)</span>
        <span class="s1">self._categories = state.pop(</span><span class="s5">&quot;categories&quot;</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s1">self._ordered = state.pop(</span><span class="s5">&quot;ordered&quot;</span><span class="s2">, False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__hash__(self) -&gt; int:</span>
        <span class="s3"># _hash_categories returns a uint64, so use the negative</span>
        <span class="s3"># space for when we have unknown categories to avoid a conflict</span>
        <span class="s2">if </span><span class="s1">self.categories </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.ordered:</span>
                <span class="s2">return </span><span class="s1">-</span><span class="s4">1</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">-</span><span class="s4">2</span>
        <span class="s3"># We *do* want to include the real self.ordered here</span>
        <span class="s2">return </span><span class="s1">int(self._hash_categories)</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other: Any) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot; 
        Rules for CDT equality: 
        1) Any CDT is equal to the string 'category' 
        2) Any CDT is equal to itself 
        3) Any CDT is equal to a CDT with categories=None regardless of ordered 
        4) A CDT with ordered=True is only equal to another CDT with 
           ordered=True and identical categories in the same order 
        5) A CDT with ordered={False, None} is only equal to another CDT with 
           ordered={False, None} and identical categories, but same order is 
           not required. There is no distinction between False/None. 
        6) Any other comparison returns False 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s2">return </span><span class="s1">other == self.name</span>
        <span class="s2">elif </span><span class="s1">other </span><span class="s2">is </span><span class="s1">self:</span>
            <span class="s2">return True</span>
        <span class="s2">elif not </span><span class="s1">(hasattr(other</span><span class="s2">, </span><span class="s5">&quot;ordered&quot;</span><span class="s1">) </span><span class="s2">and </span><span class="s1">hasattr(other</span><span class="s2">, </span><span class="s5">&quot;categories&quot;</span><span class="s1">)):</span>
            <span class="s2">return False</span>
        <span class="s2">elif </span><span class="s1">self.categories </span><span class="s2">is None or </span><span class="s1">other.categories </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s3"># For non-fully-initialized dtypes, these are only equal to</span>
            <span class="s3">#  - the string &quot;category&quot; (handled above)</span>
            <span class="s3">#  - other CategoricalDtype with categories=None</span>
            <span class="s2">return </span><span class="s1">self.categories </span><span class="s2">is </span><span class="s1">other.categories</span>
        <span class="s2">elif </span><span class="s1">self.ordered </span><span class="s2">or </span><span class="s1">other.ordered:</span>
            <span class="s3"># At least one has ordered=True; equal if both have ordered=True</span>
            <span class="s3"># and the same values for categories in the same order.</span>
            <span class="s2">return </span><span class="s1">(self.ordered == other.ordered) </span><span class="s2">and </span><span class="s1">self.categories.equals(</span>
                <span class="s1">other.categories</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s3"># Neither has ordered=True; equal if both have the same categories,</span>
            <span class="s3"># but same order is not necessary.  There is no distinction between</span>
            <span class="s3"># ordered=False and ordered=None: CDT(., False) and CDT(., None)</span>
            <span class="s3"># will be equal if they have the same categories.</span>
            <span class="s1">left = self.categories</span>
            <span class="s1">right = other.categories</span>

            <span class="s3"># GH#36280 the ordering of checks here is for performance</span>
            <span class="s2">if not </span><span class="s1">left.dtype == right.dtype:</span>
                <span class="s2">return False</span>

            <span class="s2">if </span><span class="s1">len(left) != len(right):</span>
                <span class="s2">return False</span>

            <span class="s2">if </span><span class="s1">self.categories.equals(other.categories):</span>
                <span class="s3"># Check and see if they happen to be identical categories</span>
                <span class="s2">return True</span>

            <span class="s2">if </span><span class="s1">left.dtype != object:</span>
                <span class="s3"># Faster than calculating hash</span>
                <span class="s1">indexer = left.get_indexer(right)</span>
                <span class="s3"># Because left and right have the same length and are unique,</span>
                <span class="s3">#  `indexer` not having any -1s implies that there is a</span>
                <span class="s3">#  bijection between `left` and `right`.</span>
                <span class="s2">return </span><span class="s1">(indexer != -</span><span class="s4">1</span><span class="s1">).all()</span>

            <span class="s3"># With object-dtype we need a comparison that identifies</span>
            <span class="s3">#  e.g. int(2) as distinct from float(2)</span>
            <span class="s2">return </span><span class="s1">hash(self) == hash(other)</span>

    <span class="s2">def </span><span class="s1">__repr__(self) -&gt; str_type:</span>
        <span class="s2">if </span><span class="s1">self.categories </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">data = </span><span class="s5">&quot;None&quot;</span>
            <span class="s1">dtype = </span><span class="s5">&quot;None&quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">data = self.categories._format_data(name=type(self).__name__)</span>
            <span class="s2">if </span><span class="s1">data </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s3"># self.categories is RangeIndex</span>
                <span class="s1">data = str(self.categories._range)</span>
            <span class="s1">data = data.rstrip(</span><span class="s5">&quot;, &quot;</span><span class="s1">)</span>
            <span class="s1">dtype = self.categories.dtype</span>

        <span class="s2">return </span><span class="s1">(</span>
            <span class="s5">f&quot;CategoricalDtype(categories=</span><span class="s2">{</span><span class="s1">data</span><span class="s2">}</span><span class="s5">, ordered=</span><span class="s2">{</span><span class="s1">self.ordered</span><span class="s2">}</span><span class="s5">, &quot;</span>
            <span class="s5">f&quot;categories_dtype=</span><span class="s2">{</span><span class="s1">dtype</span><span class="s2">}</span><span class="s5">)&quot;</span>
        <span class="s1">)</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">_hash_categories(self) -&gt; int:</span>
        <span class="s2">from </span><span class="s1">pandas.core.util.hashing </span><span class="s2">import </span><span class="s1">(</span>
            <span class="s1">combine_hash_arrays</span><span class="s2">,</span>
            <span class="s1">hash_array</span><span class="s2">,</span>
            <span class="s1">hash_tuples</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s1">categories = self.categories</span>
        <span class="s1">ordered = self.ordered</span>

        <span class="s2">if </span><span class="s1">len(categories) </span><span class="s2">and </span><span class="s1">isinstance(categories[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">tuple):</span>
            <span class="s3"># assumes if any individual category is a tuple, then all our. ATM</span>
            <span class="s3"># I don't really want to support just some of the categories being</span>
            <span class="s3"># tuples.</span>
            <span class="s1">cat_list = list(categories)  </span><span class="s3"># breaks if a np.array of categories</span>
            <span class="s1">cat_array = hash_tuples(cat_list)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">categories.dtype == </span><span class="s5">&quot;O&quot; </span><span class="s2">and </span><span class="s1">len({type(x) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">categories}) != </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s3"># TODO: hash_array doesn't handle mixed types. It casts</span>
                <span class="s3"># everything to a str first, which means we treat</span>
                <span class="s3"># {'1', '2'} the same as {'1', 2}</span>
                <span class="s3"># find a better solution</span>
                <span class="s1">hashed = hash((tuple(categories)</span><span class="s2">, </span><span class="s1">ordered))</span>
                <span class="s2">return </span><span class="s1">hashed</span>

            <span class="s2">if </span><span class="s1">DatetimeTZDtype.is_dtype(categories.dtype):</span>
                <span class="s3"># Avoid future warning.</span>
                <span class="s1">categories = categories.view(</span><span class="s5">&quot;datetime64[ns]&quot;</span><span class="s1">)</span>

            <span class="s1">cat_array = hash_array(np.asarray(categories)</span><span class="s2">, </span><span class="s1">categorize=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">ordered:</span>
            <span class="s1">cat_array = np.vstack(</span>
                <span class="s1">[cat_array</span><span class="s2">, </span><span class="s1">np.arange(len(cat_array)</span><span class="s2">, </span><span class="s1">dtype=cat_array.dtype)]</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">cat_array = np.array([cat_array])</span>
        <span class="s1">combined_hashed = combine_hash_arrays(iter(cat_array)</span><span class="s2">, </span><span class="s1">num_items=len(cat_array))</span>
        <span class="s2">return </span><span class="s1">np.bitwise_xor.reduce(combined_hashed)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">construct_array_type(cls) -&gt; type_t[Categorical]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the array type associated with this dtype. 
 
        Returns 
        ------- 
        type 
        &quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s1">pandas </span><span class="s2">import </span><span class="s1">Categorical</span>

        <span class="s2">return </span><span class="s1">Categorical</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">validate_ordered(ordered: Ordered) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot; 
        Validates that we have a valid ordered parameter. If 
        it is not a boolean, a TypeError will be raised. 
 
        Parameters 
        ---------- 
        ordered : object 
            The parameter to be verified. 
 
        Raises 
        ------ 
        TypeError 
            If 'ordered' is not a boolean. 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">is_bool(ordered):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s5">&quot;'ordered' must either be 'True' or 'False'&quot;</span><span class="s1">)</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">validate_categories(categories</span><span class="s2">, </span><span class="s1">fastpath: bool = </span><span class="s2">False</span><span class="s1">) -&gt; Index:</span>
        <span class="s0">&quot;&quot;&quot; 
        Validates that we have good categories 
 
        Parameters 
        ---------- 
        categories : array-like 
        fastpath : bool 
            Whether to skip nan and uniqueness checks 
 
        Returns 
        ------- 
        categories : Index 
        &quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s1">pandas.core.indexes.base </span><span class="s2">import </span><span class="s1">Index</span>

        <span class="s2">if not </span><span class="s1">fastpath </span><span class="s2">and not </span><span class="s1">is_list_like(categories):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s5">f&quot;Parameter 'categories' must be list-like, was </span><span class="s2">{</span><span class="s1">repr(categories)</span><span class="s2">}</span><span class="s5">&quot;</span>
            <span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">isinstance(categories</span><span class="s2">, </span><span class="s1">ABCIndex):</span>
            <span class="s1">categories = Index._with_infer(categories</span><span class="s2">, </span><span class="s1">tupleize_cols=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s2">if not </span><span class="s1">fastpath:</span>
            <span class="s2">if </span><span class="s1">categories.hasnans:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;Categorical categories cannot be null&quot;</span><span class="s1">)</span>

            <span class="s2">if not </span><span class="s1">categories.is_unique:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;Categorical categories must be unique&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">isinstance(categories</span><span class="s2">, </span><span class="s1">ABCCategoricalIndex):</span>
            <span class="s1">categories = categories.categories</span>

        <span class="s2">return </span><span class="s1">categories</span>

    <span class="s2">def </span><span class="s1">update_dtype(self</span><span class="s2">, </span><span class="s1">dtype: str_type | CategoricalDtype) -&gt; CategoricalDtype:</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns a CategoricalDtype with categories and ordered taken from dtype 
        if specified, otherwise falling back to self if unspecified 
 
        Parameters 
        ---------- 
        dtype : CategoricalDtype 
 
        Returns 
        ------- 
        new_dtype : CategoricalDtype 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">and </span><span class="s1">dtype == </span><span class="s5">&quot;category&quot;</span><span class="s1">:</span>
            <span class="s3"># dtype='category' should not change anything</span>
            <span class="s2">return </span><span class="s1">self</span>
        <span class="s2">elif not </span><span class="s1">self.is_dtype(dtype):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s5">f&quot;a CategoricalDtype must be passed to perform an update, &quot;</span>
                <span class="s5">f&quot;got </span><span class="s2">{</span><span class="s1">repr(dtype)</span><span class="s2">}</span><span class="s5">&quot;</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s3"># from here on, dtype is a CategoricalDtype</span>
            <span class="s1">dtype = cast(CategoricalDtype</span><span class="s2">, </span><span class="s1">dtype)</span>

        <span class="s3"># update categories/ordered unless they've been explicitly passed as None</span>
        <span class="s1">new_categories = (</span>
            <span class="s1">dtype.categories </span><span class="s2">if </span><span class="s1">dtype.categories </span><span class="s2">is not None else </span><span class="s1">self.categories</span>
        <span class="s1">)</span>
        <span class="s1">new_ordered = dtype.ordered </span><span class="s2">if </span><span class="s1">dtype.ordered </span><span class="s2">is not None else </span><span class="s1">self.ordered</span>

        <span class="s2">return </span><span class="s1">CategoricalDtype(new_categories</span><span class="s2">, </span><span class="s1">new_ordered)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">categories(self) -&gt; Index:</span>
        <span class="s0">&quot;&quot;&quot; 
        An ``Index`` containing the unique categories allowed. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; cat_type = pd.CategoricalDtype(categories=['a', 'b'], ordered=True) 
        &gt;&gt;&gt; cat_type.categories 
        Index(['a', 'b'], dtype='object') 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._categories</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">ordered(self) -&gt; Ordered:</span>
        <span class="s0">&quot;&quot;&quot; 
        Whether the categories have an ordered relationship. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; cat_type = pd.CategoricalDtype(categories=['a', 'b'], ordered=True) 
        &gt;&gt;&gt; cat_type.ordered 
        True 
 
        &gt;&gt;&gt; cat_type = pd.CategoricalDtype(categories=['a', 'b'], ordered=False) 
        &gt;&gt;&gt; cat_type.ordered 
        False 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._ordered</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_is_boolean(self) -&gt; bool:</span>
        <span class="s2">from </span><span class="s1">pandas.core.dtypes.common </span><span class="s2">import </span><span class="s1">is_bool_dtype</span>

        <span class="s2">return </span><span class="s1">is_bool_dtype(self.categories)</span>

    <span class="s2">def </span><span class="s1">_get_common_dtype(self</span><span class="s2">, </span><span class="s1">dtypes: list[DtypeObj]) -&gt; DtypeObj | </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s3"># check if we have all categorical dtype with identical categories</span>
        <span class="s2">if </span><span class="s1">all(isinstance(x</span><span class="s2">, </span><span class="s1">CategoricalDtype) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">dtypes):</span>
            <span class="s1">first = dtypes[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">all(first == other </span><span class="s2">for </span><span class="s1">other </span><span class="s2">in </span><span class="s1">dtypes[</span><span class="s4">1</span><span class="s1">:]):</span>
                <span class="s2">return </span><span class="s1">first</span>

        <span class="s3"># special case non-initialized categorical</span>
        <span class="s3"># TODO we should figure out the expected return value in general</span>
        <span class="s1">non_init_cats = [</span>
            <span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">CategoricalDtype) </span><span class="s2">and </span><span class="s1">x.categories </span><span class="s2">is None for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">dtypes</span>
        <span class="s1">]</span>
        <span class="s2">if </span><span class="s1">all(non_init_cats):</span>
            <span class="s2">return </span><span class="s1">self</span>
        <span class="s2">elif </span><span class="s1">any(non_init_cats):</span>
            <span class="s2">return None</span>

        <span class="s3"># categorical is aware of Sparse -&gt; extract sparse subdtypes</span>
        <span class="s1">dtypes = [x.subtype </span><span class="s2">if </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">SparseDtype) </span><span class="s2">else </span><span class="s1">x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">dtypes]</span>
        <span class="s3"># extract the categories' dtype</span>
        <span class="s1">non_cat_dtypes = [</span>
            <span class="s1">x.categories.dtype </span><span class="s2">if </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">CategoricalDtype) </span><span class="s2">else </span><span class="s1">x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">dtypes</span>
        <span class="s1">]</span>
        <span class="s3"># TODO should categorical always give an answer?</span>
        <span class="s2">from </span><span class="s1">pandas.core.dtypes.cast </span><span class="s2">import </span><span class="s1">find_common_type</span>

        <span class="s2">return </span><span class="s1">find_common_type(non_cat_dtypes)</span>


<span class="s1">@register_extension_dtype</span>
<span class="s2">class </span><span class="s1">DatetimeTZDtype(PandasExtensionDtype):</span>
    <span class="s0">&quot;&quot;&quot; 
    An ExtensionDtype for timezone-aware datetime data. 
 
    **This is not an actual numpy dtype**, but a duck type. 
 
    Parameters 
    ---------- 
    unit : str, default &quot;ns&quot; 
        The precision of the datetime data. Currently limited 
        to ``&quot;ns&quot;``. 
    tz : str, int, or datetime.tzinfo 
        The timezone. 
 
    Attributes 
    ---------- 
    unit 
    tz 
 
    Methods 
    ------- 
    None 
 
    Raises 
    ------ 
    ZoneInfoNotFoundError 
        When the requested timezone cannot be found. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from zoneinfo import ZoneInfo 
    &gt;&gt;&gt; pd.DatetimeTZDtype(tz=ZoneInfo('UTC')) 
    datetime64[ns, UTC] 
 
    &gt;&gt;&gt; pd.DatetimeTZDtype(tz=ZoneInfo('Europe/Paris')) 
    datetime64[ns, Europe/Paris] 
    &quot;&quot;&quot;</span>

    <span class="s1">type: type[Timestamp] = Timestamp</span>
    <span class="s1">kind: str_type = </span><span class="s5">&quot;M&quot;</span>
    <span class="s1">num = </span><span class="s4">101</span>
    <span class="s1">_metadata = (</span><span class="s5">&quot;unit&quot;</span><span class="s2">, </span><span class="s5">&quot;tz&quot;</span><span class="s1">)</span>
    <span class="s1">_match = re.compile(</span><span class="s5">r&quot;(datetime64|M8)\[(?P&lt;unit&gt;.+), (?P&lt;tz&gt;.+)\]&quot;</span><span class="s1">)</span>
    <span class="s1">_cache_dtypes: dict[str_type</span><span class="s2">, </span><span class="s1">PandasExtensionDtype] = {}</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">na_value(self) -&gt; NaTType:</span>
        <span class="s2">return </span><span class="s1">NaT</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">base(self) -&gt; DtypeObj:  </span><span class="s3"># type: ignore[override]</span>
        <span class="s2">return </span><span class="s1">np.dtype(</span><span class="s5">f&quot;M8[</span><span class="s2">{</span><span class="s1">self.unit</span><span class="s2">}</span><span class="s5">]&quot;</span><span class="s1">)</span>

    <span class="s3"># error: Signature of &quot;str&quot; incompatible with supertype &quot;PandasExtensionDtype&quot;</span>
    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">str(self) -&gt; str:  </span><span class="s3"># type: ignore[override]</span>
        <span class="s2">return </span><span class="s5">f&quot;|M8[</span><span class="s2">{</span><span class="s1">self.unit</span><span class="s2">}</span><span class="s5">]&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">unit: str_type | DatetimeTZDtype = </span><span class="s5">&quot;ns&quot;</span><span class="s2">, </span><span class="s1">tz=</span><span class="s2">None</span><span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">isinstance(unit</span><span class="s2">, </span><span class="s1">DatetimeTZDtype):</span>
            <span class="s3"># error: &quot;str&quot; has no attribute &quot;tz&quot;</span>
            <span class="s1">unit</span><span class="s2">, </span><span class="s1">tz = unit.unit</span><span class="s2">, </span><span class="s1">unit.tz  </span><span class="s3"># type: ignore[attr-defined]</span>

        <span class="s2">if </span><span class="s1">unit != </span><span class="s5">&quot;ns&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">isinstance(unit</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">and </span><span class="s1">tz </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s3"># maybe a string like datetime64[ns, tz], which we support for</span>
                <span class="s3"># now.</span>
                <span class="s1">result = type(self).construct_from_string(unit)</span>
                <span class="s1">unit = result.unit</span>
                <span class="s1">tz = result.tz</span>
                <span class="s1">msg = (</span>
                    <span class="s5">f&quot;Passing a dtype alias like 'datetime64[ns, </span><span class="s2">{</span><span class="s1">tz</span><span class="s2">}</span><span class="s5">]' &quot;</span>
                    <span class="s5">&quot;to DatetimeTZDtype is no longer supported. Use &quot;</span>
                    <span class="s5">&quot;'DatetimeTZDtype.construct_from_string()' instead.&quot;</span>
                <span class="s1">)</span>
                <span class="s2">raise </span><span class="s1">ValueError(msg)</span>
            <span class="s2">if </span><span class="s1">unit </span><span class="s2">not in </span><span class="s1">[</span><span class="s5">&quot;s&quot;</span><span class="s2">, </span><span class="s5">&quot;ms&quot;</span><span class="s2">, </span><span class="s5">&quot;us&quot;</span><span class="s2">, </span><span class="s5">&quot;ns&quot;</span><span class="s1">]:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;DatetimeTZDtype only supports s, ms, us, ns units&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">tz:</span>
            <span class="s1">tz = timezones.maybe_get_tz(tz)</span>
            <span class="s1">tz = timezones.tz_standardize(tz)</span>
        <span class="s2">elif </span><span class="s1">tz </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">pytz.UnknownTimeZoneError(tz)</span>
        <span class="s2">if </span><span class="s1">tz </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s5">&quot;A 'tz' is required.&quot;</span><span class="s1">)</span>

        <span class="s1">self._unit = unit</span>
        <span class="s1">self._tz = tz</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">_creso(self) -&gt; int:</span>
        <span class="s0">&quot;&quot;&quot; 
        The NPY_DATETIMEUNIT corresponding to this dtype's resolution. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">abbrev_to_npy_unit(self.unit)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">unit(self) -&gt; str_type:</span>
        <span class="s0">&quot;&quot;&quot; 
        The precision of the datetime data. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; from zoneinfo import ZoneInfo 
        &gt;&gt;&gt; dtype = pd.DatetimeTZDtype(tz=ZoneInfo('America/Los_Angeles')) 
        &gt;&gt;&gt; dtype.unit 
        'ns' 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._unit</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">tz(self) -&gt; tzinfo:</span>
        <span class="s0">&quot;&quot;&quot; 
        The timezone. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; from zoneinfo import ZoneInfo 
        &gt;&gt;&gt; dtype = pd.DatetimeTZDtype(tz=ZoneInfo('America/Los_Angeles')) 
        &gt;&gt;&gt; dtype.tz 
        zoneinfo.ZoneInfo(key='America/Los_Angeles') 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._tz</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">construct_array_type(cls) -&gt; type_t[DatetimeArray]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the array type associated with this dtype. 
 
        Returns 
        ------- 
        type 
        &quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s1">pandas.core.arrays </span><span class="s2">import </span><span class="s1">DatetimeArray</span>

        <span class="s2">return </span><span class="s1">DatetimeArray</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">construct_from_string(cls</span><span class="s2">, </span><span class="s1">string: str_type) -&gt; DatetimeTZDtype:</span>
        <span class="s0">&quot;&quot;&quot; 
        Construct a DatetimeTZDtype from a string. 
 
        Parameters 
        ---------- 
        string : str 
            The string alias for this DatetimeTZDtype. 
            Should be formatted like ``datetime64[ns, &lt;tz&gt;]``, 
            where ``&lt;tz&gt;`` is the timezone name. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; DatetimeTZDtype.construct_from_string('datetime64[ns, UTC]') 
        datetime64[ns, UTC] 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">isinstance(string</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s5">f&quot;'construct_from_string' expects a string, got </span><span class="s2">{</span><span class="s1">type(string)</span><span class="s2">}</span><span class="s5">&quot;</span>
            <span class="s1">)</span>

        <span class="s1">msg = </span><span class="s5">f&quot;Cannot construct a 'DatetimeTZDtype' from '</span><span class="s2">{</span><span class="s1">string</span><span class="s2">}</span><span class="s5">'&quot;</span>
        <span class="s1">match = cls._match.match(string)</span>
        <span class="s2">if </span><span class="s1">match:</span>
            <span class="s1">d = match.groupdict()</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">cls(unit=d[</span><span class="s5">&quot;unit&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">tz=d[</span><span class="s5">&quot;tz&quot;</span><span class="s1">])</span>
            <span class="s2">except </span><span class="s1">(KeyError</span><span class="s2">, </span><span class="s1">TypeError</span><span class="s2">, </span><span class="s1">ValueError) </span><span class="s2">as </span><span class="s1">err:</span>
                <span class="s3"># KeyError if maybe_get_tz tries and fails to get a</span>
                <span class="s3">#  pytz timezone (actually pytz.UnknownTimeZoneError).</span>
                <span class="s3"># TypeError if we pass a nonsense tz;</span>
                <span class="s3"># ValueError if we pass a unit other than &quot;ns&quot;</span>
                <span class="s2">raise </span><span class="s1">TypeError(msg) </span><span class="s2">from </span><span class="s1">err</span>
        <span class="s2">raise </span><span class="s1">TypeError(msg)</span>

    <span class="s2">def </span><span class="s1">__str__(self) -&gt; str_type:</span>
        <span class="s2">return </span><span class="s5">f&quot;datetime64[</span><span class="s2">{</span><span class="s1">self.unit</span><span class="s2">}</span><span class="s5">, </span><span class="s2">{</span><span class="s1">self.tz</span><span class="s2">}</span><span class="s5">]&quot;</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">name(self) -&gt; str_type:</span>
        <span class="s0">&quot;&quot;&quot;A string representation of the dtype.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">str(self)</span>

    <span class="s2">def </span><span class="s1">__hash__(self) -&gt; int:</span>
        <span class="s3"># make myself hashable</span>
        <span class="s3"># TODO: update this.</span>
        <span class="s2">return </span><span class="s1">hash(str(self))</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other: Any) -&gt; bool:</span>
        <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s2">if </span><span class="s1">other.startswith(</span><span class="s5">&quot;M8[&quot;</span><span class="s1">):</span>
                <span class="s1">other = </span><span class="s5">f&quot;datetime64[</span><span class="s2">{</span><span class="s1">other[</span><span class="s4">3</span><span class="s1">:]</span><span class="s2">}</span><span class="s5">&quot;</span>
            <span class="s2">return </span><span class="s1">other == self.name</span>

        <span class="s2">return </span><span class="s1">(</span>
            <span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">DatetimeTZDtype)</span>
            <span class="s2">and </span><span class="s1">self.unit == other.unit</span>
            <span class="s2">and </span><span class="s1">tz_compare(self.tz</span><span class="s2">, </span><span class="s1">other.tz)</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__from_arrow__(self</span><span class="s2">, </span><span class="s1">array: pa.Array | pa.ChunkedArray) -&gt; DatetimeArray:</span>
        <span class="s0">&quot;&quot;&quot; 
        Construct DatetimeArray from pyarrow Array/ChunkedArray. 
 
        Note: If the units in the pyarrow Array are the same as this 
        DatetimeDtype, then values corresponding to the integer representation 
        of ``NaT`` (e.g. one nanosecond before :attr:`pandas.Timestamp.min`) 
        are converted to ``NaT``, regardless of the null indicator in the 
        pyarrow array. 
 
        Parameters 
        ---------- 
        array : pyarrow.Array or pyarrow.ChunkedArray 
            The Arrow array to convert to DatetimeArray. 
 
        Returns 
        ------- 
        extension array : DatetimeArray 
        &quot;&quot;&quot;</span>
        <span class="s2">import </span><span class="s1">pyarrow</span>

        <span class="s2">from </span><span class="s1">pandas.core.arrays </span><span class="s2">import </span><span class="s1">DatetimeArray</span>

        <span class="s1">array = array.cast(pyarrow.timestamp(unit=self._unit)</span><span class="s2">, </span><span class="s1">safe=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">isinstance(array</span><span class="s2">, </span><span class="s1">pyarrow.Array):</span>
            <span class="s1">np_arr = array.to_numpy(zero_copy_only=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">np_arr = array.to_numpy()</span>

        <span class="s2">return </span><span class="s1">DatetimeArray(np_arr</span><span class="s2">, </span><span class="s1">dtype=self</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__setstate__(self</span><span class="s2">, </span><span class="s1">state) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s3"># for pickle compat. __get_state__ is defined in the</span>
        <span class="s3"># PandasExtensionDtype superclass and uses the public properties to</span>
        <span class="s3"># pickle -&gt; need to set the settable private ones here (see GH26067)</span>
        <span class="s1">self._tz = state[</span><span class="s5">&quot;tz&quot;</span><span class="s1">]</span>
        <span class="s1">self._unit = state[</span><span class="s5">&quot;unit&quot;</span><span class="s1">]</span>


<span class="s1">@register_extension_dtype</span>
<span class="s2">class </span><span class="s1">PeriodDtype(PeriodDtypeBase</span><span class="s2">, </span><span class="s1">PandasExtensionDtype):</span>
    <span class="s0">&quot;&quot;&quot; 
    An ExtensionDtype for Period data. 
 
    **This is not an actual numpy dtype**, but a duck type. 
 
    Parameters 
    ---------- 
    freq : str or DateOffset 
        The frequency of this PeriodDtype. 
 
    Attributes 
    ---------- 
    freq 
 
    Methods 
    ------- 
    None 
 
    Examples 
    -------- 
    &gt;&gt;&gt; pd.PeriodDtype(freq='D') 
    period[D] 
 
    &gt;&gt;&gt; pd.PeriodDtype(freq=pd.offsets.MonthEnd()) 
    period[M] 
    &quot;&quot;&quot;</span>

    <span class="s1">type: type[Period] = Period</span>
    <span class="s1">kind: str_type = </span><span class="s5">&quot;O&quot;</span>
    <span class="s1">str = </span><span class="s5">&quot;|O08&quot;</span>
    <span class="s1">base = np.dtype(</span><span class="s5">&quot;O&quot;</span><span class="s1">)</span>
    <span class="s1">num = </span><span class="s4">102</span>
    <span class="s1">_metadata = (</span><span class="s5">&quot;freq&quot;</span><span class="s2">,</span><span class="s1">)</span>
    <span class="s1">_match = re.compile(</span><span class="s5">r&quot;(P|p)eriod\[(?P&lt;freq&gt;.+)\]&quot;</span><span class="s1">)</span>
    <span class="s3"># error: Incompatible types in assignment (expression has type</span>
    <span class="s3"># &quot;Dict[int, PandasExtensionDtype]&quot;, base class &quot;PandasExtensionDtype&quot;</span>
    <span class="s3"># defined the type as &quot;Dict[str, PandasExtensionDtype]&quot;)  [assignment]</span>
    <span class="s1">_cache_dtypes: dict[BaseOffset</span><span class="s2">, </span><span class="s1">int] = {}  </span><span class="s3"># type: ignore[assignment]</span>
    <span class="s1">__hash__ = PeriodDtypeBase.__hash__</span>
    <span class="s1">_freq: BaseOffset</span>

    <span class="s2">def </span><span class="s1">__new__(cls</span><span class="s2">, </span><span class="s1">freq):</span>
        <span class="s0">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        freq : PeriodDtype, BaseOffset, or string 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(freq</span><span class="s2">, </span><span class="s1">PeriodDtype):</span>
            <span class="s2">return </span><span class="s1">freq</span>

        <span class="s2">if not </span><span class="s1">isinstance(freq</span><span class="s2">, </span><span class="s1">BaseOffset):</span>
            <span class="s1">freq = cls._parse_dtype_strict(freq)</span>

        <span class="s2">if </span><span class="s1">isinstance(freq</span><span class="s2">, </span><span class="s1">BDay):</span>
            <span class="s3"># GH#53446</span>
            <span class="s1">warnings.warn(</span>
                <span class="s5">&quot;PeriodDtype[B] is deprecated and will be removed in a future &quot;</span>
                <span class="s5">&quot;version. Use a DatetimeIndex with freq='B' instead&quot;</span><span class="s2">,</span>
                <span class="s1">FutureWarning</span><span class="s2">,</span>
                <span class="s1">stacklevel=find_stack_level()</span><span class="s2">,</span>
            <span class="s1">)</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">dtype_code = cls._cache_dtypes[freq]</span>
        <span class="s2">except </span><span class="s1">KeyError:</span>
            <span class="s1">dtype_code = freq._period_dtype_code</span>
            <span class="s1">cls._cache_dtypes[freq] = dtype_code</span>
        <span class="s1">u = PeriodDtypeBase.__new__(cls</span><span class="s2">, </span><span class="s1">dtype_code</span><span class="s2">, </span><span class="s1">freq.n)</span>
        <span class="s1">u._freq = freq</span>
        <span class="s2">return </span><span class="s1">u</span>

    <span class="s2">def </span><span class="s1">__reduce__(self):</span>
        <span class="s2">return </span><span class="s1">type(self)</span><span class="s2">, </span><span class="s1">(self.name</span><span class="s2">,</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">freq(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        The frequency object of this PeriodDtype. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; dtype = pd.PeriodDtype(freq='D') 
        &gt;&gt;&gt; dtype.freq 
        &lt;Day&gt; 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._freq</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">_parse_dtype_strict(cls</span><span class="s2">, </span><span class="s1">freq: str_type) -&gt; BaseOffset:</span>
        <span class="s2">if </span><span class="s1">isinstance(freq</span><span class="s2">, </span><span class="s1">str):  </span><span class="s3"># note: freq is already of type str!</span>
            <span class="s2">if </span><span class="s1">freq.startswith((</span><span class="s5">&quot;Period[&quot;</span><span class="s2">, </span><span class="s5">&quot;period[&quot;</span><span class="s1">)):</span>
                <span class="s1">m = cls._match.search(freq)</span>
                <span class="s2">if </span><span class="s1">m </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">freq = m.group(</span><span class="s5">&quot;freq&quot;</span><span class="s1">)</span>

            <span class="s1">freq_offset = to_offset(freq)</span>
            <span class="s2">if </span><span class="s1">freq_offset </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">freq_offset</span>

        <span class="s2">raise </span><span class="s1">TypeError(</span>
            <span class="s5">&quot;PeriodDtype argument should be string or BaseOffset, &quot;</span>
            <span class="s5">f&quot;got </span><span class="s2">{</span><span class="s1">type(freq).__name__</span><span class="s2">}</span><span class="s5">&quot;</span>
        <span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">construct_from_string(cls</span><span class="s2">, </span><span class="s1">string: str_type) -&gt; PeriodDtype:</span>
        <span class="s0">&quot;&quot;&quot; 
        Strict construction from a string, raise a TypeError if not 
        possible 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">isinstance(string</span><span class="s2">, </span><span class="s1">str)</span>
            <span class="s2">and </span><span class="s1">(string.startswith((</span><span class="s5">&quot;period[&quot;</span><span class="s2">, </span><span class="s5">&quot;Period[&quot;</span><span class="s1">)))</span>
            <span class="s2">or </span><span class="s1">isinstance(string</span><span class="s2">, </span><span class="s1">BaseOffset)</span>
        <span class="s1">):</span>
            <span class="s3"># do not parse string like U as period[U]</span>
            <span class="s3"># avoid tuple to be regarded as freq</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">cls(freq=string)</span>
            <span class="s2">except </span><span class="s1">ValueError:</span>
                <span class="s2">pass</span>
        <span class="s2">if </span><span class="s1">isinstance(string</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">msg = </span><span class="s5">f&quot;Cannot construct a 'PeriodDtype' from '</span><span class="s2">{</span><span class="s1">string</span><span class="s2">}</span><span class="s5">'&quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s5">f&quot;'construct_from_string' expects a string, got </span><span class="s2">{</span><span class="s1">type(string)</span><span class="s2">}</span><span class="s5">&quot;</span>
        <span class="s2">raise </span><span class="s1">TypeError(msg)</span>

    <span class="s2">def </span><span class="s1">__str__(self) -&gt; str_type:</span>
        <span class="s2">return </span><span class="s1">self.name</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">name(self) -&gt; str_type:</span>
        <span class="s2">return </span><span class="s5">f&quot;period[</span><span class="s2">{</span><span class="s1">self._freqstr</span><span class="s2">}</span><span class="s5">]&quot;</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">na_value(self) -&gt; NaTType:</span>
        <span class="s2">return </span><span class="s1">NaT</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other: Any) -&gt; bool:</span>
        <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s2">return </span><span class="s1">other </span><span class="s2">in </span><span class="s1">[self.name</span><span class="s2">, </span><span class="s1">self.name.title()]</span>

        <span class="s2">return </span><span class="s1">super().__eq__(other)</span>

    <span class="s2">def </span><span class="s1">__ne__(self</span><span class="s2">, </span><span class="s1">other: Any) -&gt; bool:</span>
        <span class="s2">return not </span><span class="s1">self.__eq__(other)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">is_dtype(cls</span><span class="s2">, </span><span class="s1">dtype: object) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a boolean if we if the passed type is an actual dtype that we 
        can match (via string or type) 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s3"># PeriodDtype can be instantiated from freq string like &quot;U&quot;,</span>
            <span class="s3"># but doesn't regard freq str like &quot;U&quot; as dtype.</span>
            <span class="s2">if </span><span class="s1">dtype.startswith((</span><span class="s5">&quot;period[&quot;</span><span class="s2">, </span><span class="s5">&quot;Period[&quot;</span><span class="s1">)):</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">cls._parse_dtype_strict(dtype) </span><span class="s2">is not None</span>
                <span class="s2">except </span><span class="s1">ValueError:</span>
                    <span class="s2">return False</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return False</span>
        <span class="s2">return </span><span class="s1">super().is_dtype(dtype)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">construct_array_type(cls) -&gt; type_t[PeriodArray]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the array type associated with this dtype. 
 
        Returns 
        ------- 
        type 
        &quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s1">pandas.core.arrays </span><span class="s2">import </span><span class="s1">PeriodArray</span>

        <span class="s2">return </span><span class="s1">PeriodArray</span>

    <span class="s2">def </span><span class="s1">__from_arrow__(self</span><span class="s2">, </span><span class="s1">array: pa.Array | pa.ChunkedArray) -&gt; PeriodArray:</span>
        <span class="s0">&quot;&quot;&quot; 
        Construct PeriodArray from pyarrow Array/ChunkedArray. 
        &quot;&quot;&quot;</span>
        <span class="s2">import </span><span class="s1">pyarrow</span>

        <span class="s2">from </span><span class="s1">pandas.core.arrays </span><span class="s2">import </span><span class="s1">PeriodArray</span>
        <span class="s2">from </span><span class="s1">pandas.core.arrays.arrow._arrow_utils </span><span class="s2">import </span><span class="s1">(</span>
            <span class="s1">pyarrow_array_to_numpy_and_mask</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">isinstance(array</span><span class="s2">, </span><span class="s1">pyarrow.Array):</span>
            <span class="s1">chunks = [array]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">chunks = array.chunks</span>

        <span class="s1">results = []</span>
        <span class="s2">for </span><span class="s1">arr </span><span class="s2">in </span><span class="s1">chunks:</span>
            <span class="s1">data</span><span class="s2">, </span><span class="s1">mask = pyarrow_array_to_numpy_and_mask(arr</span><span class="s2">, </span><span class="s1">dtype=np.dtype(np.int64))</span>
            <span class="s1">parr = PeriodArray(data.copy()</span><span class="s2">, </span><span class="s1">dtype=self</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s3"># error: Invalid index type &quot;ndarray[Any, dtype[bool_]]&quot; for &quot;PeriodArray&quot;;</span>
            <span class="s3"># expected type &quot;Union[int, Sequence[int], Sequence[bool], slice]&quot;</span>
            <span class="s1">parr[~mask] = NaT  </span><span class="s3"># type: ignore[index]</span>
            <span class="s1">results.append(parr)</span>

        <span class="s2">if not </span><span class="s1">results:</span>
            <span class="s2">return </span><span class="s1">PeriodArray(np.array([]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s5">&quot;int64&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=self</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">PeriodArray._concat_same_type(results)</span>


<span class="s1">@register_extension_dtype</span>
<span class="s2">class </span><span class="s1">IntervalDtype(PandasExtensionDtype):</span>
    <span class="s0">&quot;&quot;&quot; 
    An ExtensionDtype for Interval data. 
 
    **This is not an actual numpy dtype**, but a duck type. 
 
    Parameters 
    ---------- 
    subtype : str, np.dtype 
        The dtype of the Interval bounds. 
 
    Attributes 
    ---------- 
    subtype 
 
    Methods 
    ------- 
    None 
 
    Examples 
    -------- 
    &gt;&gt;&gt; pd.IntervalDtype(subtype='int64', closed='both') 
    interval[int64, both] 
    &quot;&quot;&quot;</span>

    <span class="s1">name = </span><span class="s5">&quot;interval&quot;</span>
    <span class="s1">kind: str_type = </span><span class="s5">&quot;O&quot;</span>
    <span class="s1">str = </span><span class="s5">&quot;|O08&quot;</span>
    <span class="s1">base = np.dtype(</span><span class="s5">&quot;O&quot;</span><span class="s1">)</span>
    <span class="s1">num = </span><span class="s4">103</span>
    <span class="s1">_metadata = (</span>
        <span class="s5">&quot;subtype&quot;</span><span class="s2">,</span>
        <span class="s5">&quot;closed&quot;</span><span class="s2">,</span>
    <span class="s1">)</span>

    <span class="s1">_match = re.compile(</span>
        <span class="s5">r&quot;(I|i)nterval\[(?P&lt;subtype&gt;[^,]+(\[.+\])?)&quot;</span>
        <span class="s5">r&quot;(, (?P&lt;closed&gt;(right|left|both|neither)))?\]&quot;</span>
    <span class="s1">)</span>

    <span class="s1">_cache_dtypes: dict[str_type</span><span class="s2">, </span><span class="s1">PandasExtensionDtype] = {}</span>
    <span class="s1">_subtype: </span><span class="s2">None </span><span class="s1">| np.dtype</span>
    <span class="s1">_closed: IntervalClosedType | </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">subtype=</span><span class="s2">None, </span><span class="s1">closed: IntervalClosedType | </span><span class="s2">None </span><span class="s1">= </span><span class="s2">None</span><span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">from </span><span class="s1">pandas.core.dtypes.common </span><span class="s2">import </span><span class="s1">(</span>
            <span class="s1">is_string_dtype</span><span class="s2">,</span>
            <span class="s1">pandas_dtype</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">closed </span><span class="s2">is not None and </span><span class="s1">closed </span><span class="s2">not in </span><span class="s1">{</span><span class="s5">&quot;right&quot;</span><span class="s2">, </span><span class="s5">&quot;left&quot;</span><span class="s2">, </span><span class="s5">&quot;both&quot;</span><span class="s2">, </span><span class="s5">&quot;neither&quot;</span><span class="s1">}:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;closed must be one of 'right', 'left', 'both', 'neither'&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">isinstance(subtype</span><span class="s2">, </span><span class="s1">IntervalDtype):</span>
            <span class="s2">if </span><span class="s1">closed </span><span class="s2">is not None and </span><span class="s1">closed != subtype.closed:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s5">&quot;dtype.closed and 'closed' do not match. &quot;</span>
                    <span class="s5">&quot;Try IntervalDtype(dtype.subtype, closed) instead.&quot;</span>
                <span class="s1">)</span>
            <span class="s1">self._subtype = subtype._subtype</span>
            <span class="s1">self._closed = subtype._closed</span>
        <span class="s2">elif </span><span class="s1">subtype </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s3"># we are called as an empty constructor</span>
            <span class="s3"># generally for pickle compat</span>
            <span class="s1">self._subtype = </span><span class="s2">None</span>
            <span class="s1">self._closed = closed</span>
        <span class="s2">elif </span><span class="s1">isinstance(subtype</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">and </span><span class="s1">subtype.lower() == </span><span class="s5">&quot;interval&quot;</span><span class="s1">:</span>
            <span class="s1">self._subtype = </span><span class="s2">None</span>
            <span class="s1">self._closed = closed</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">isinstance(subtype</span><span class="s2">, </span><span class="s1">str):</span>
                <span class="s1">m = IntervalDtype._match.search(subtype)</span>
                <span class="s2">if </span><span class="s1">m </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">gd = m.groupdict()</span>
                    <span class="s1">subtype = gd[</span><span class="s5">&quot;subtype&quot;</span><span class="s1">]</span>
                    <span class="s2">if </span><span class="s1">gd.get(</span><span class="s5">&quot;closed&quot;</span><span class="s2">, None</span><span class="s1">) </span><span class="s2">is not None</span><span class="s1">:</span>
                        <span class="s2">if </span><span class="s1">closed </span><span class="s2">is not None</span><span class="s1">:</span>
                            <span class="s2">if </span><span class="s1">closed != gd[</span><span class="s5">&quot;closed&quot;</span><span class="s1">]:</span>
                                <span class="s2">raise </span><span class="s1">ValueError(</span>
                                    <span class="s5">&quot;'closed' keyword does not match value &quot;</span>
                                    <span class="s5">&quot;specified in dtype string&quot;</span>
                                <span class="s1">)</span>
                        <span class="s1">closed = gd[</span><span class="s5">&quot;closed&quot;</span><span class="s1">]  </span><span class="s3"># type: ignore[assignment]</span>

            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">subtype = pandas_dtype(subtype)</span>
            <span class="s2">except </span><span class="s1">TypeError </span><span class="s2">as </span><span class="s1">err:</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s5">&quot;could not construct IntervalDtype&quot;</span><span class="s1">) </span><span class="s2">from </span><span class="s1">err</span>
            <span class="s2">if </span><span class="s1">CategoricalDtype.is_dtype(subtype) </span><span class="s2">or </span><span class="s1">is_string_dtype(subtype):</span>
                <span class="s3"># GH 19016</span>
                <span class="s1">msg = (</span>
                    <span class="s5">&quot;category, object, and string subtypes are not supported &quot;</span>
                    <span class="s5">&quot;for IntervalDtype&quot;</span>
                <span class="s1">)</span>
                <span class="s2">raise </span><span class="s1">TypeError(msg)</span>
            <span class="s1">self._subtype = subtype</span>
            <span class="s1">self._closed = closed</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">_can_hold_na(self) -&gt; bool:</span>
        <span class="s1">subtype = self._subtype</span>
        <span class="s2">if </span><span class="s1">subtype </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s3"># partially-initialized</span>
            <span class="s2">raise </span><span class="s1">NotImplementedError(</span>
                <span class="s5">&quot;_can_hold_na is not defined for partially-initialized IntervalDtype&quot;</span>
            <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">subtype.kind </span><span class="s2">in </span><span class="s5">&quot;iu&quot;</span><span class="s1">:</span>
            <span class="s2">return False</span>
        <span class="s2">return True</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">closed(self) -&gt; IntervalClosedType:</span>
        <span class="s2">return </span><span class="s1">self._closed  </span><span class="s3"># type: ignore[return-value]</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">subtype(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        The dtype of the Interval bounds. 
 
        Examples 
        -------- 
        &gt;&gt;&gt; dtype = pd.IntervalDtype(subtype='int64', closed='both') 
        &gt;&gt;&gt; dtype.subtype 
        dtype('int64') 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._subtype</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">construct_array_type(cls) -&gt; type[IntervalArray]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the array type associated with this dtype. 
 
        Returns 
        ------- 
        type 
        &quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s1">pandas.core.arrays </span><span class="s2">import </span><span class="s1">IntervalArray</span>

        <span class="s2">return </span><span class="s1">IntervalArray</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">construct_from_string(cls</span><span class="s2">, </span><span class="s1">string: str_type) -&gt; IntervalDtype:</span>
        <span class="s0">&quot;&quot;&quot; 
        attempt to construct this type from a string, raise a TypeError 
        if its not possible 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">isinstance(string</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s5">f&quot;'construct_from_string' expects a string, got </span><span class="s2">{</span><span class="s1">type(string)</span><span class="s2">}</span><span class="s5">&quot;</span>
            <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">string.lower() == </span><span class="s5">&quot;interval&quot; </span><span class="s2">or </span><span class="s1">cls._match.search(string) </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">cls(string)</span>

        <span class="s1">msg = (</span>
            <span class="s5">f&quot;Cannot construct a 'IntervalDtype' from '</span><span class="s2">{</span><span class="s1">string</span><span class="s2">}</span><span class="s5">'.</span><span class="s2">\n\n</span><span class="s5">&quot;</span>
            <span class="s5">&quot;Incorrectly formatted string passed to constructor. &quot;</span>
            <span class="s5">&quot;Valid formats include Interval or Interval[dtype] &quot;</span>
            <span class="s5">&quot;where dtype is numeric, datetime, or timedelta&quot;</span>
        <span class="s1">)</span>
        <span class="s2">raise </span><span class="s1">TypeError(msg)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">type(self) -&gt; type[Interval]:</span>
        <span class="s2">return </span><span class="s1">Interval</span>

    <span class="s2">def </span><span class="s1">__str__(self) -&gt; str_type:</span>
        <span class="s2">if </span><span class="s1">self.subtype </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s5">&quot;interval&quot;</span>
        <span class="s2">if </span><span class="s1">self.closed </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s3"># Only partially initialized GH#38394</span>
            <span class="s2">return </span><span class="s5">f&quot;interval[</span><span class="s2">{</span><span class="s1">self.subtype</span><span class="s2">}</span><span class="s5">]&quot;</span>
        <span class="s2">return </span><span class="s5">f&quot;interval[</span><span class="s2">{</span><span class="s1">self.subtype</span><span class="s2">}</span><span class="s5">, </span><span class="s2">{</span><span class="s1">self.closed</span><span class="s2">}</span><span class="s5">]&quot;</span>

    <span class="s2">def </span><span class="s1">__hash__(self) -&gt; int:</span>
        <span class="s3"># make myself hashable</span>
        <span class="s2">return </span><span class="s1">hash(str(self))</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other: Any) -&gt; bool:</span>
        <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s2">return </span><span class="s1">other.lower() </span><span class="s2">in </span><span class="s1">(self.name.lower()</span><span class="s2">, </span><span class="s1">str(self).lower())</span>
        <span class="s2">elif not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">IntervalDtype):</span>
            <span class="s2">return False</span>
        <span class="s2">elif </span><span class="s1">self.subtype </span><span class="s2">is None or </span><span class="s1">other.subtype </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s3"># None should match any subtype</span>
            <span class="s2">return True</span>
        <span class="s2">elif </span><span class="s1">self.closed != other.closed:</span>
            <span class="s2">return False</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.subtype == other.subtype</span>

    <span class="s2">def </span><span class="s1">__setstate__(self</span><span class="s2">, </span><span class="s1">state) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s3"># for pickle compat. __get_state__ is defined in the</span>
        <span class="s3"># PandasExtensionDtype superclass and uses the public properties to</span>
        <span class="s3"># pickle -&gt; need to set the settable private ones here (see GH26067)</span>
        <span class="s1">self._subtype = state[</span><span class="s5">&quot;subtype&quot;</span><span class="s1">]</span>

        <span class="s3"># backward-compat older pickles won't have &quot;closed&quot; key</span>
        <span class="s1">self._closed = state.pop(</span><span class="s5">&quot;closed&quot;</span><span class="s2">, None</span><span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">is_dtype(cls</span><span class="s2">, </span><span class="s1">dtype: object) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return a boolean if we if the passed type is an actual dtype that we 
        can match (via string or type) 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s2">if </span><span class="s1">dtype.lower().startswith(</span><span class="s5">&quot;interval&quot;</span><span class="s1">):</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">cls.construct_from_string(dtype) </span><span class="s2">is not None</span>
                <span class="s2">except </span><span class="s1">(ValueError</span><span class="s2">, </span><span class="s1">TypeError):</span>
                    <span class="s2">return False</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return False</span>
        <span class="s2">return </span><span class="s1">super().is_dtype(dtype)</span>

    <span class="s2">def </span><span class="s1">__from_arrow__(self</span><span class="s2">, </span><span class="s1">array: pa.Array | pa.ChunkedArray) -&gt; IntervalArray:</span>
        <span class="s0">&quot;&quot;&quot; 
        Construct IntervalArray from pyarrow Array/ChunkedArray. 
        &quot;&quot;&quot;</span>
        <span class="s2">import </span><span class="s1">pyarrow</span>

        <span class="s2">from </span><span class="s1">pandas.core.arrays </span><span class="s2">import </span><span class="s1">IntervalArray</span>

        <span class="s2">if </span><span class="s1">isinstance(array</span><span class="s2">, </span><span class="s1">pyarrow.Array):</span>
            <span class="s1">chunks = [array]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">chunks = array.chunks</span>

        <span class="s1">results = []</span>
        <span class="s2">for </span><span class="s1">arr </span><span class="s2">in </span><span class="s1">chunks:</span>
            <span class="s2">if </span><span class="s1">isinstance(arr</span><span class="s2">, </span><span class="s1">pyarrow.ExtensionArray):</span>
                <span class="s1">arr = arr.storage</span>
            <span class="s1">left = np.asarray(arr.field(</span><span class="s5">&quot;left&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=self.subtype)</span>
            <span class="s1">right = np.asarray(arr.field(</span><span class="s5">&quot;right&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=self.subtype)</span>
            <span class="s1">iarr = IntervalArray.from_arrays(left</span><span class="s2">, </span><span class="s1">right</span><span class="s2">, </span><span class="s1">closed=self.closed)</span>
            <span class="s1">results.append(iarr)</span>

        <span class="s2">if not </span><span class="s1">results:</span>
            <span class="s2">return </span><span class="s1">IntervalArray.from_arrays(</span>
                <span class="s1">np.array([]</span><span class="s2">, </span><span class="s1">dtype=self.subtype)</span><span class="s2">,</span>
                <span class="s1">np.array([]</span><span class="s2">, </span><span class="s1">dtype=self.subtype)</span><span class="s2">,</span>
                <span class="s1">closed=self.closed</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">IntervalArray._concat_same_type(results)</span>

    <span class="s2">def </span><span class="s1">_get_common_dtype(self</span><span class="s2">, </span><span class="s1">dtypes: list[DtypeObj]) -&gt; DtypeObj | </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if not </span><span class="s1">all(isinstance(x</span><span class="s2">, </span><span class="s1">IntervalDtype) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">dtypes):</span>
            <span class="s2">return None</span>

        <span class="s1">closed = cast(</span><span class="s5">&quot;IntervalDtype&quot;</span><span class="s2">, </span><span class="s1">dtypes[</span><span class="s4">0</span><span class="s1">]).closed</span>
        <span class="s2">if not </span><span class="s1">all(cast(</span><span class="s5">&quot;IntervalDtype&quot;</span><span class="s2">, </span><span class="s1">x).closed == closed </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">dtypes):</span>
            <span class="s2">return </span><span class="s1">np.dtype(object)</span>

        <span class="s2">from </span><span class="s1">pandas.core.dtypes.cast </span><span class="s2">import </span><span class="s1">find_common_type</span>

        <span class="s1">common = find_common_type([cast(</span><span class="s5">&quot;IntervalDtype&quot;</span><span class="s2">, </span><span class="s1">x).subtype </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">dtypes])</span>
        <span class="s2">if </span><span class="s1">common == object:</span>
            <span class="s2">return </span><span class="s1">np.dtype(object)</span>
        <span class="s2">return </span><span class="s1">IntervalDtype(common</span><span class="s2">, </span><span class="s1">closed=closed)</span>


<span class="s2">class </span><span class="s1">NumpyEADtype(ExtensionDtype):</span>
    <span class="s0">&quot;&quot;&quot; 
    A Pandas ExtensionDtype for NumPy dtypes. 
 
    This is mostly for internal compatibility, and is not especially 
    useful on its own. 
 
    Parameters 
    ---------- 
    dtype : object 
        Object to be converted to a NumPy data type object. 
 
    See Also 
    -------- 
    numpy.dtype 
    &quot;&quot;&quot;</span>

    <span class="s1">_metadata = (</span><span class="s5">&quot;_dtype&quot;</span><span class="s2">,</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">dtype: npt.DTypeLike | NumpyEADtype | </span><span class="s2">None</span><span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">NumpyEADtype):</span>
            <span class="s3"># make constructor univalent</span>
            <span class="s1">dtype = dtype.numpy_dtype</span>
        <span class="s1">self._dtype = np.dtype(dtype)</span>

    <span class="s2">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s5">f&quot;NumpyEADtype(</span><span class="s2">{</span><span class="s1">repr(self.name)</span><span class="s2">}</span><span class="s5">)&quot;</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">numpy_dtype(self) -&gt; np.dtype:</span>
        <span class="s0">&quot;&quot;&quot; 
        The NumPy dtype this NumpyEADtype wraps. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._dtype</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">name(self) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot; 
        A bit-width name for this data-type. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._dtype.name</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">type(self) -&gt; type[np.generic]:</span>
        <span class="s0">&quot;&quot;&quot; 
        The type object used to instantiate a scalar of this NumPy data-type. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._dtype.type</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_is_numeric(self) -&gt; bool:</span>
        <span class="s3"># exclude object, str, unicode, void.</span>
        <span class="s2">return </span><span class="s1">self.kind </span><span class="s2">in </span><span class="s1">set(</span><span class="s5">&quot;biufc&quot;</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_is_boolean(self) -&gt; bool:</span>
        <span class="s2">return </span><span class="s1">self.kind == </span><span class="s5">&quot;b&quot;</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">construct_from_string(cls</span><span class="s2">, </span><span class="s1">string: str) -&gt; NumpyEADtype:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">dtype = np.dtype(string)</span>
        <span class="s2">except </span><span class="s1">TypeError </span><span class="s2">as </span><span class="s1">err:</span>
            <span class="s2">if not </span><span class="s1">isinstance(string</span><span class="s2">, </span><span class="s1">str):</span>
                <span class="s1">msg = </span><span class="s5">f&quot;'construct_from_string' expects a string, got </span><span class="s2">{</span><span class="s1">type(string)</span><span class="s2">}</span><span class="s5">&quot;</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">msg = </span><span class="s5">f&quot;Cannot construct a 'NumpyEADtype' from '</span><span class="s2">{</span><span class="s1">string</span><span class="s2">}</span><span class="s5">'&quot;</span>
            <span class="s2">raise </span><span class="s1">TypeError(msg) </span><span class="s2">from </span><span class="s1">err</span>
        <span class="s2">return </span><span class="s1">cls(dtype)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">construct_array_type(cls) -&gt; type_t[NumpyExtensionArray]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the array type associated with this dtype. 
 
        Returns 
        ------- 
        type 
        &quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s1">pandas.core.arrays </span><span class="s2">import </span><span class="s1">NumpyExtensionArray</span>

        <span class="s2">return </span><span class="s1">NumpyExtensionArray</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">kind(self) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot; 
        A character code (one of 'biufcmMOSUV') identifying the general kind of data. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._dtype.kind</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">itemsize(self) -&gt; int:</span>
        <span class="s0">&quot;&quot;&quot; 
        The element size of this data-type object. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._dtype.itemsize</span>


<span class="s2">class </span><span class="s1">BaseMaskedDtype(ExtensionDtype):</span>
    <span class="s0">&quot;&quot;&quot; 
    Base class for dtypes for BaseMaskedArray subclasses. 
    &quot;&quot;&quot;</span>

    <span class="s1">name: str</span>
    <span class="s1">base = </span><span class="s2">None</span>
    <span class="s1">type: type</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">na_value(self) -&gt; libmissing.NAType:</span>
        <span class="s2">return </span><span class="s1">libmissing.NA</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">numpy_dtype(self) -&gt; np.dtype:</span>
        <span class="s0">&quot;&quot;&quot;Return an instance of our numpy dtype&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">np.dtype(self.type)</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">kind(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s1">self.numpy_dtype.kind</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">itemsize(self) -&gt; int:</span>
        <span class="s0">&quot;&quot;&quot;Return the number of bytes in this dtype&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.numpy_dtype.itemsize</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">construct_array_type(cls) -&gt; type_t[BaseMaskedArray]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the array type associated with this dtype. 
 
        Returns 
        ------- 
        type 
        &quot;&quot;&quot;</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_numpy_dtype(cls</span><span class="s2">, </span><span class="s1">dtype: np.dtype) -&gt; BaseMaskedDtype:</span>
        <span class="s0">&quot;&quot;&quot; 
        Construct the MaskedDtype corresponding to the given numpy dtype. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">dtype.kind == </span><span class="s5">&quot;b&quot;</span><span class="s1">:</span>
            <span class="s2">from </span><span class="s1">pandas.core.arrays.boolean </span><span class="s2">import </span><span class="s1">BooleanDtype</span>

            <span class="s2">return </span><span class="s1">BooleanDtype()</span>
        <span class="s2">elif </span><span class="s1">dtype.kind </span><span class="s2">in </span><span class="s5">&quot;iu&quot;</span><span class="s1">:</span>
            <span class="s2">from </span><span class="s1">pandas.core.arrays.integer </span><span class="s2">import </span><span class="s1">NUMPY_INT_TO_DTYPE</span>

            <span class="s2">return </span><span class="s1">NUMPY_INT_TO_DTYPE[dtype]</span>
        <span class="s2">elif </span><span class="s1">dtype.kind == </span><span class="s5">&quot;f&quot;</span><span class="s1">:</span>
            <span class="s2">from </span><span class="s1">pandas.core.arrays.floating </span><span class="s2">import </span><span class="s1">NUMPY_FLOAT_TO_DTYPE</span>

            <span class="s2">return </span><span class="s1">NUMPY_FLOAT_TO_DTYPE[dtype]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">NotImplementedError(dtype)</span>

    <span class="s2">def </span><span class="s1">_get_common_dtype(self</span><span class="s2">, </span><span class="s1">dtypes: list[DtypeObj]) -&gt; DtypeObj | </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s3"># We unwrap any masked dtypes, find the common dtype we would use</span>
        <span class="s3">#  for that, then re-mask the result.</span>
        <span class="s2">from </span><span class="s1">pandas.core.dtypes.cast </span><span class="s2">import </span><span class="s1">find_common_type</span>

        <span class="s1">new_dtype = find_common_type(</span>
            <span class="s1">[</span>
                <span class="s1">dtype.numpy_dtype </span><span class="s2">if </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">BaseMaskedDtype) </span><span class="s2">else </span><span class="s1">dtype</span>
                <span class="s2">for </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">dtypes</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">isinstance(new_dtype</span><span class="s2">, </span><span class="s1">np.dtype):</span>
            <span class="s3"># If we ever support e.g. Masked[DatetimeArray] then this will change</span>
            <span class="s2">return None</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">type(self).from_numpy_dtype(new_dtype)</span>
        <span class="s2">except </span><span class="s1">(KeyError</span><span class="s2">, </span><span class="s1">NotImplementedError):</span>
            <span class="s2">return None</span>


<span class="s1">@register_extension_dtype</span>
<span class="s2">class </span><span class="s1">SparseDtype(ExtensionDtype):</span>
    <span class="s0">&quot;&quot;&quot; 
    Dtype for data stored in :class:`SparseArray`. 
 
    This dtype implements the pandas ExtensionDtype interface. 
 
    Parameters 
    ---------- 
    dtype : str, ExtensionDtype, numpy.dtype, type, default numpy.float64 
        The dtype of the underlying array storing the non-fill value values. 
    fill_value : scalar, optional 
        The scalar value not stored in the SparseArray. By default, this 
        depends on `dtype`. 
 
        =========== ========== 
        dtype       na_value 
        =========== ========== 
        float       ``np.nan`` 
        int         ``0`` 
        bool        ``False`` 
        datetime64  ``pd.NaT`` 
        timedelta64 ``pd.NaT`` 
        =========== ========== 
 
        The default value may be overridden by specifying a `fill_value`. 
 
    Attributes 
    ---------- 
    None 
 
    Methods 
    ------- 
    None 
 
    Examples 
    -------- 
    &gt;&gt;&gt; ser = pd.Series([1, 0, 0], dtype=pd.SparseDtype(dtype=int, fill_value=0)) 
    &gt;&gt;&gt; ser 
    0    1 
    1    0 
    2    0 
    dtype: Sparse[int64, 0] 
    &gt;&gt;&gt; ser.sparse.density 
    0.3333333333333333 
    &quot;&quot;&quot;</span>

    <span class="s1">_is_immutable = </span><span class="s2">True</span>

    <span class="s3"># We include `_is_na_fill_value` in the metadata to avoid hash collisions</span>
    <span class="s3"># between SparseDtype(float, 0.0) and SparseDtype(float, nan).</span>
    <span class="s3"># Without is_na_fill_value in the comparison, those would be equal since</span>
    <span class="s3"># hash(nan) is (sometimes?) 0.</span>
    <span class="s1">_metadata = (</span><span class="s5">&quot;_dtype&quot;</span><span class="s2">, </span><span class="s5">&quot;_fill_value&quot;</span><span class="s2">, </span><span class="s5">&quot;_is_na_fill_value&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">dtype: Dtype = np.float64</span><span class="s2">, </span><span class="s1">fill_value: Any = </span><span class="s2">None</span><span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">type(self)):</span>
            <span class="s2">if </span><span class="s1">fill_value </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">fill_value = dtype.fill_value</span>
            <span class="s1">dtype = dtype.subtype</span>

        <span class="s2">from </span><span class="s1">pandas.core.dtypes.common </span><span class="s2">import </span><span class="s1">(</span>
            <span class="s1">is_string_dtype</span><span class="s2">,</span>
            <span class="s1">pandas_dtype</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s2">from </span><span class="s1">pandas.core.dtypes.missing </span><span class="s2">import </span><span class="s1">na_value_for_dtype</span>

        <span class="s1">dtype = pandas_dtype(dtype)</span>
        <span class="s2">if </span><span class="s1">is_string_dtype(dtype):</span>
            <span class="s1">dtype = np.dtype(</span><span class="s5">&quot;object&quot;</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">np.dtype):</span>
            <span class="s3"># GH#53160</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s5">&quot;SparseDtype subtype must be a numpy dtype&quot;</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">fill_value </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">fill_value = na_value_for_dtype(dtype)</span>

        <span class="s1">self._dtype = dtype</span>
        <span class="s1">self._fill_value = fill_value</span>
        <span class="s1">self._check_fill_value()</span>

    <span class="s2">def </span><span class="s1">__hash__(self) -&gt; int:</span>
        <span class="s3"># Python3 doesn't inherit __hash__ when a base class overrides</span>
        <span class="s3"># __eq__, so we explicitly do it here.</span>
        <span class="s2">return </span><span class="s1">super().__hash__()</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other: Any) -&gt; bool:</span>
        <span class="s3"># We have to override __eq__ to handle NA values in _metadata.</span>
        <span class="s3"># The base class does simple == checks, which fail for NA.</span>
        <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">other = self.construct_from_string(other)</span>
            <span class="s2">except </span><span class="s1">TypeError:</span>
                <span class="s2">return False</span>

        <span class="s2">if </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">type(self)):</span>
            <span class="s1">subtype = self.subtype == other.subtype</span>
            <span class="s2">if </span><span class="s1">self._is_na_fill_value:</span>
                <span class="s3"># this case is complicated by two things:</span>
                <span class="s3"># SparseDtype(float, float(nan)) == SparseDtype(float, np.nan)</span>
                <span class="s3"># SparseDtype(float, np.nan)     != SparseDtype(float, pd.NaT)</span>
                <span class="s3"># i.e. we want to treat any floating-point NaN as equal, but</span>
                <span class="s3"># not a floating-point NaN and a datetime NaT.</span>
                <span class="s1">fill_value = (</span>
                    <span class="s1">other._is_na_fill_value</span>
                    <span class="s2">and </span><span class="s1">isinstance(self.fill_value</span><span class="s2">, </span><span class="s1">type(other.fill_value))</span>
                    <span class="s2">or </span><span class="s1">isinstance(other.fill_value</span><span class="s2">, </span><span class="s1">type(self.fill_value))</span>
                <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">with </span><span class="s1">warnings.catch_warnings():</span>
                    <span class="s3"># Ignore spurious numpy warning</span>
                    <span class="s1">warnings.filterwarnings(</span>
                        <span class="s5">&quot;ignore&quot;</span><span class="s2">,</span>
                        <span class="s5">&quot;elementwise comparison failed&quot;</span><span class="s2">,</span>
                        <span class="s1">category=DeprecationWarning</span><span class="s2">,</span>
                    <span class="s1">)</span>

                    <span class="s1">fill_value = self.fill_value == other.fill_value</span>

            <span class="s2">return </span><span class="s1">subtype </span><span class="s2">and </span><span class="s1">fill_value</span>
        <span class="s2">return False</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">fill_value(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        The fill value of the array. 
 
        Converting the SparseArray to a dense ndarray will fill the 
        array with this value. 
 
        .. warning:: 
 
           It's possible to end up with a SparseArray that has ``fill_value`` 
           values in ``sp_values``. This can occur, for example, when setting 
           ``SparseArray.fill_value`` directly. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._fill_value</span>

    <span class="s2">def </span><span class="s1">_check_fill_value(self):</span>
        <span class="s2">if not </span><span class="s1">lib.is_scalar(self._fill_value):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s5">f&quot;fill_value must be a scalar. Got </span><span class="s2">{</span><span class="s1">self._fill_value</span><span class="s2">} </span><span class="s5">instead&quot;</span>
            <span class="s1">)</span>

        <span class="s2">from </span><span class="s1">pandas.core.dtypes.cast </span><span class="s2">import </span><span class="s1">can_hold_element</span>
        <span class="s2">from </span><span class="s1">pandas.core.dtypes.missing </span><span class="s2">import </span><span class="s1">(</span>
            <span class="s1">is_valid_na_for_dtype</span><span class="s2">,</span>
            <span class="s1">isna</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s2">from </span><span class="s1">pandas.core.construction </span><span class="s2">import </span><span class="s1">ensure_wrapped_if_datetimelike</span>

        <span class="s3"># GH#23124 require fill_value and subtype to match</span>
        <span class="s1">val = self._fill_value</span>
        <span class="s2">if </span><span class="s1">isna(val):</span>
            <span class="s2">if not </span><span class="s1">is_valid_na_for_dtype(val</span><span class="s2">, </span><span class="s1">self.subtype):</span>
                <span class="s1">warnings.warn(</span>
                    <span class="s5">&quot;Allowing arbitrary scalar fill_value in SparseDtype is &quot;</span>
                    <span class="s5">&quot;deprecated. In a future version, the fill_value must be &quot;</span>
                    <span class="s5">&quot;a valid value for the SparseDtype.subtype.&quot;</span><span class="s2">,</span>
                    <span class="s1">FutureWarning</span><span class="s2">,</span>
                    <span class="s1">stacklevel=find_stack_level()</span><span class="s2">,</span>
                <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">dummy = np.empty(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">dtype=self.subtype)</span>
            <span class="s1">dummy = ensure_wrapped_if_datetimelike(dummy)</span>

            <span class="s2">if not </span><span class="s1">can_hold_element(dummy</span><span class="s2">, </span><span class="s1">val):</span>
                <span class="s1">warnings.warn(</span>
                    <span class="s5">&quot;Allowing arbitrary scalar fill_value in SparseDtype is &quot;</span>
                    <span class="s5">&quot;deprecated. In a future version, the fill_value must be &quot;</span>
                    <span class="s5">&quot;a valid value for the SparseDtype.subtype.&quot;</span><span class="s2">,</span>
                    <span class="s1">FutureWarning</span><span class="s2">,</span>
                    <span class="s1">stacklevel=find_stack_level()</span><span class="s2">,</span>
                <span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_is_na_fill_value(self) -&gt; bool:</span>
        <span class="s2">from </span><span class="s1">pandas </span><span class="s2">import </span><span class="s1">isna</span>

        <span class="s2">return </span><span class="s1">isna(self.fill_value)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_is_numeric(self) -&gt; bool:</span>
        <span class="s2">return not </span><span class="s1">self.subtype == object</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_is_boolean(self) -&gt; bool:</span>
        <span class="s2">return </span><span class="s1">self.subtype.kind == </span><span class="s5">&quot;b&quot;</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">kind(self) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot; 
        The sparse kind. Either 'integer', or 'block'. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.subtype.kind</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">type(self):</span>
        <span class="s2">return </span><span class="s1">self.subtype.type</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">subtype(self):</span>
        <span class="s2">return </span><span class="s1">self._dtype</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">name(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s5">f&quot;Sparse[</span><span class="s2">{</span><span class="s1">self.subtype.name</span><span class="s2">}</span><span class="s5">, </span><span class="s2">{</span><span class="s1">repr(self.fill_value)</span><span class="s2">}</span><span class="s5">]&quot;</span>

    <span class="s2">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s1">self.name</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">construct_array_type(cls) -&gt; type_t[SparseArray]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the array type associated with this dtype. 
 
        Returns 
        ------- 
        type 
        &quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s1">pandas.core.arrays.sparse.array </span><span class="s2">import </span><span class="s1">SparseArray</span>

        <span class="s2">return </span><span class="s1">SparseArray</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">construct_from_string(cls</span><span class="s2">, </span><span class="s1">string: str) -&gt; SparseDtype:</span>
        <span class="s0">&quot;&quot;&quot; 
        Construct a SparseDtype from a string form. 
 
        Parameters 
        ---------- 
        string : str 
            Can take the following forms. 
 
            string           dtype 
            ================ ============================ 
            'int'            SparseDtype[np.int64, 0] 
            'Sparse'         SparseDtype[np.float64, nan] 
            'Sparse[int]'    SparseDtype[np.int64, 0] 
            'Sparse[int, 0]' SparseDtype[np.int64, 0] 
            ================ ============================ 
 
            It is not possible to specify non-default fill values 
            with a string. An argument like ``'Sparse[int, 1]'`` 
            will raise a ``TypeError`` because the default fill value 
            for integers is 0. 
 
        Returns 
        ------- 
        SparseDtype 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">isinstance(string</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s5">f&quot;'construct_from_string' expects a string, got </span><span class="s2">{</span><span class="s1">type(string)</span><span class="s2">}</span><span class="s5">&quot;</span>
            <span class="s1">)</span>
        <span class="s1">msg = </span><span class="s5">f&quot;Cannot construct a 'SparseDtype' from '</span><span class="s2">{</span><span class="s1">string</span><span class="s2">}</span><span class="s5">'&quot;</span>
        <span class="s2">if </span><span class="s1">string.startswith(</span><span class="s5">&quot;Sparse&quot;</span><span class="s1">):</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">sub_type</span><span class="s2">, </span><span class="s1">has_fill_value = cls._parse_subtype(string)</span>
            <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">err:</span>
                <span class="s2">raise </span><span class="s1">TypeError(msg) </span><span class="s2">from </span><span class="s1">err</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">result = SparseDtype(sub_type)</span>
                <span class="s1">msg = (</span>
                    <span class="s5">f&quot;Cannot construct a 'SparseDtype' from '</span><span class="s2">{</span><span class="s1">string</span><span class="s2">}</span><span class="s5">'.</span><span class="s2">\n\n</span><span class="s5">It &quot;</span>
                    <span class="s5">&quot;looks like the fill_value in the string is not &quot;</span>
                    <span class="s5">&quot;the default for the dtype. Non-default fill_values &quot;</span>
                    <span class="s5">&quot;are not supported. Use the 'SparseDtype()' &quot;</span>
                    <span class="s5">&quot;constructor instead.&quot;</span>
                <span class="s1">)</span>
                <span class="s2">if </span><span class="s1">has_fill_value </span><span class="s2">and </span><span class="s1">str(result) != string:</span>
                    <span class="s2">raise </span><span class="s1">TypeError(msg)</span>
                <span class="s2">return </span><span class="s1">result</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">TypeError(msg)</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_parse_subtype(dtype: str) -&gt; tuple[str</span><span class="s2">, </span><span class="s1">bool]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Parse a string to get the subtype 
 
        Parameters 
        ---------- 
        dtype : str 
            A string like 
 
            * Sparse[subtype] 
            * Sparse[subtype, fill_value] 
 
        Returns 
        ------- 
        subtype : str 
 
        Raises 
        ------ 
        ValueError 
            When the subtype cannot be extracted. 
        &quot;&quot;&quot;</span>
        <span class="s1">xpr = re.compile(</span><span class="s5">r&quot;Sparse\[(?P&lt;subtype&gt;[^,]*)(, )?(?P&lt;fill_value&gt;.*?)?\]$&quot;</span><span class="s1">)</span>
        <span class="s1">m = xpr.match(dtype)</span>
        <span class="s1">has_fill_value = </span><span class="s2">False</span>
        <span class="s2">if </span><span class="s1">m:</span>
            <span class="s1">subtype = m.groupdict()[</span><span class="s5">&quot;subtype&quot;</span><span class="s1">]</span>
            <span class="s1">has_fill_value = bool(m.groupdict()[</span><span class="s5">&quot;fill_value&quot;</span><span class="s1">])</span>
        <span class="s2">elif </span><span class="s1">dtype == </span><span class="s5">&quot;Sparse&quot;</span><span class="s1">:</span>
            <span class="s1">subtype = </span><span class="s5">&quot;float64&quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">f&quot;Cannot parse </span><span class="s2">{</span><span class="s1">dtype</span><span class="s2">}</span><span class="s5">&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">subtype</span><span class="s2">, </span><span class="s1">has_fill_value</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">is_dtype(cls</span><span class="s2">, </span><span class="s1">dtype: object) -&gt; bool:</span>
        <span class="s1">dtype = getattr(dtype</span><span class="s2">, </span><span class="s5">&quot;dtype&quot;</span><span class="s2">, </span><span class="s1">dtype)</span>
        <span class="s2">if </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">str) </span><span class="s2">and </span><span class="s1">dtype.startswith(</span><span class="s5">&quot;Sparse&quot;</span><span class="s1">):</span>
            <span class="s1">sub_type</span><span class="s2">, </span><span class="s1">_ = cls._parse_subtype(dtype)</span>
            <span class="s1">dtype = np.dtype(sub_type)</span>
        <span class="s2">elif </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">cls):</span>
            <span class="s2">return True</span>
        <span class="s2">return </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">np.dtype) </span><span class="s2">or </span><span class="s1">dtype == </span><span class="s5">&quot;Sparse&quot;</span>

    <span class="s2">def </span><span class="s1">update_dtype(self</span><span class="s2">, </span><span class="s1">dtype) -&gt; SparseDtype:</span>
        <span class="s0">&quot;&quot;&quot; 
        Convert the SparseDtype to a new dtype. 
 
        This takes care of converting the ``fill_value``. 
 
        Parameters 
        ---------- 
        dtype : Union[str, numpy.dtype, SparseDtype] 
            The new dtype to use. 
 
            * For a SparseDtype, it is simply returned 
            * For a NumPy dtype (or str), the current fill value 
              is converted to the new dtype, and a SparseDtype 
              with `dtype` and the new fill value is returned. 
 
        Returns 
        ------- 
        SparseDtype 
            A new SparseDtype with the correct `dtype` and fill value 
            for that `dtype`. 
 
        Raises 
        ------ 
        ValueError 
            When the current fill value cannot be converted to the 
            new `dtype` (e.g. trying to convert ``np.nan`` to an 
            integer dtype). 
 
 
        Examples 
        -------- 
        &gt;&gt;&gt; SparseDtype(int, 0).update_dtype(float) 
        Sparse[float64, 0.0] 
 
        &gt;&gt;&gt; SparseDtype(int, 1).update_dtype(SparseDtype(float, np.nan)) 
        Sparse[float64, nan] 
        &quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s1">pandas.core.dtypes.astype </span><span class="s2">import </span><span class="s1">astype_array</span>
        <span class="s2">from </span><span class="s1">pandas.core.dtypes.common </span><span class="s2">import </span><span class="s1">pandas_dtype</span>

        <span class="s1">cls = type(self)</span>
        <span class="s1">dtype = pandas_dtype(dtype)</span>

        <span class="s2">if not </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">cls):</span>
            <span class="s2">if not </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">np.dtype):</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s5">&quot;sparse arrays of extension dtypes not supported&quot;</span><span class="s1">)</span>

            <span class="s1">fv_asarray = np.atleast_1d(np.array(self.fill_value))</span>
            <span class="s1">fvarr = astype_array(fv_asarray</span><span class="s2">, </span><span class="s1">dtype)</span>
            <span class="s3"># NB: not fv_0d.item(), as that casts dt64-&gt;int</span>
            <span class="s1">fill_value = fvarr[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">dtype = cls(dtype</span><span class="s2">, </span><span class="s1">fill_value=fill_value)</span>

        <span class="s2">return </span><span class="s1">dtype</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_subtype_with_str(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Whether the SparseDtype's subtype should be considered ``str``. 
 
        Typically, pandas will store string data in an object-dtype array. 
        When converting values to a dtype, e.g. in ``.astype``, we need to 
        be more specific, we need the actual underlying type. 
 
        Returns 
        ------- 
        &gt;&gt;&gt; SparseDtype(int, 1)._subtype_with_str 
        dtype('int64') 
 
        &gt;&gt;&gt; SparseDtype(object, 1)._subtype_with_str 
        dtype('O') 
 
        &gt;&gt;&gt; dtype = SparseDtype(str, '') 
        &gt;&gt;&gt; dtype.subtype 
        dtype('O') 
 
        &gt;&gt;&gt; dtype._subtype_with_str 
        &lt;class 'str'&gt; 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(self.fill_value</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s2">return </span><span class="s1">type(self.fill_value)</span>
        <span class="s2">return </span><span class="s1">self.subtype</span>

    <span class="s2">def </span><span class="s1">_get_common_dtype(self</span><span class="s2">, </span><span class="s1">dtypes: list[DtypeObj]) -&gt; DtypeObj | </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s3"># TODO for now only handle SparseDtypes and numpy dtypes =&gt; extend</span>
        <span class="s3"># with other compatible extension dtypes</span>
        <span class="s2">from </span><span class="s1">pandas.core.dtypes.cast </span><span class="s2">import </span><span class="s1">np_find_common_type</span>

        <span class="s2">if </span><span class="s1">any(</span>
            <span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">ExtensionDtype) </span><span class="s2">and not </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">SparseDtype)</span>
            <span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">dtypes</span>
        <span class="s1">):</span>
            <span class="s2">return None</span>

        <span class="s1">fill_values = [x.fill_value </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">dtypes </span><span class="s2">if </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">SparseDtype)]</span>
        <span class="s1">fill_value = fill_values[</span><span class="s4">0</span><span class="s1">]</span>

        <span class="s2">from </span><span class="s1">pandas </span><span class="s2">import </span><span class="s1">isna</span>

        <span class="s3"># np.nan isn't a singleton, so we may end up with multiple</span>
        <span class="s3"># NaNs here, so we ignore the all NA case too.</span>
        <span class="s2">if not </span><span class="s1">(len(set(fill_values)) == </span><span class="s4">1 </span><span class="s2">or </span><span class="s1">isna(fill_values).all()):</span>
            <span class="s1">warnings.warn(</span>
                <span class="s5">&quot;Concatenating sparse arrays with multiple fill &quot;</span>
                <span class="s5">f&quot;values: '</span><span class="s2">{</span><span class="s1">fill_values</span><span class="s2">}</span><span class="s5">'. Picking the first and &quot;</span>
                <span class="s5">&quot;converting the rest.&quot;</span><span class="s2">,</span>
                <span class="s1">PerformanceWarning</span><span class="s2">,</span>
                <span class="s1">stacklevel=find_stack_level()</span><span class="s2">,</span>
            <span class="s1">)</span>

        <span class="s1">np_dtypes = (x.subtype </span><span class="s2">if </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">SparseDtype) </span><span class="s2">else </span><span class="s1">x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">dtypes)</span>
        <span class="s2">return </span><span class="s1">SparseDtype(np_find_common_type(*np_dtypes)</span><span class="s2">, </span><span class="s1">fill_value=fill_value)</span>


<span class="s1">@register_extension_dtype</span>
<span class="s2">class </span><span class="s1">ArrowDtype(StorageExtensionDtype):</span>
    <span class="s0">&quot;&quot;&quot; 
    An ExtensionDtype for PyArrow data types. 
 
    .. warning:: 
 
       ArrowDtype is considered experimental. The implementation and 
       parts of the API may change without warning. 
 
    While most ``dtype`` arguments can accept the &quot;string&quot; 
    constructor, e.g. ``&quot;int64[pyarrow]&quot;``, ArrowDtype is useful 
    if the data type contains parameters like ``pyarrow.timestamp``. 
 
    Parameters 
    ---------- 
    pyarrow_dtype : pa.DataType 
        An instance of a `pyarrow.DataType &lt;https://arrow.apache.org/docs/python/api/datatypes.html#factory-functions&gt;`__. 
 
    Attributes 
    ---------- 
    pyarrow_dtype 
 
    Methods 
    ------- 
    None 
 
    Returns 
    ------- 
    ArrowDtype 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import pyarrow as pa 
    &gt;&gt;&gt; pd.ArrowDtype(pa.int64()) 
    int64[pyarrow] 
 
    Types with parameters must be constructed with ArrowDtype. 
 
    &gt;&gt;&gt; pd.ArrowDtype(pa.timestamp(&quot;s&quot;, tz=&quot;America/New_York&quot;)) 
    timestamp[s, tz=America/New_York][pyarrow] 
    &gt;&gt;&gt; pd.ArrowDtype(pa.list_(pa.int64())) 
    list&lt;item: int64&gt;[pyarrow] 
    &quot;&quot;&quot;</span>

    <span class="s1">_metadata = (</span><span class="s5">&quot;storage&quot;</span><span class="s2">, </span><span class="s5">&quot;pyarrow_dtype&quot;</span><span class="s1">)  </span><span class="s3"># type: ignore[assignment]</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">pyarrow_dtype: pa.DataType) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">super().__init__(</span><span class="s5">&quot;pyarrow&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">pa_version_under7p0:</span>
            <span class="s2">raise </span><span class="s1">ImportError(</span><span class="s5">&quot;pyarrow&gt;=7.0.0 is required for ArrowDtype&quot;</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">isinstance(pyarrow_dtype</span><span class="s2">, </span><span class="s1">pa.DataType):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span>
                <span class="s5">f&quot;pyarrow_dtype (</span><span class="s2">{</span><span class="s1">pyarrow_dtype</span><span class="s2">}</span><span class="s5">) must be an instance &quot;</span>
                <span class="s5">f&quot;of a pyarrow.DataType. Got </span><span class="s2">{</span><span class="s1">type(pyarrow_dtype)</span><span class="s2">} </span><span class="s5">instead.&quot;</span>
            <span class="s1">)</span>
        <span class="s1">self.pyarrow_dtype = pyarrow_dtype</span>

    <span class="s2">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s1">self.name</span>

    <span class="s2">def </span><span class="s1">__hash__(self) -&gt; int:</span>
        <span class="s3"># make myself hashable</span>
        <span class="s2">return </span><span class="s1">hash(str(self))</span>

    <span class="s2">def </span><span class="s1">__eq__(self</span><span class="s2">, </span><span class="s1">other: Any) -&gt; bool:</span>
        <span class="s2">if not </span><span class="s1">isinstance(other</span><span class="s2">, </span><span class="s1">type(self)):</span>
            <span class="s2">return </span><span class="s1">super().__eq__(other)</span>
        <span class="s2">return </span><span class="s1">self.pyarrow_dtype == other.pyarrow_dtype</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">type(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Returns associated scalar type. 
        &quot;&quot;&quot;</span>
        <span class="s1">pa_type = self.pyarrow_dtype</span>
        <span class="s2">if </span><span class="s1">pa.types.is_integer(pa_type):</span>
            <span class="s2">return </span><span class="s1">int</span>
        <span class="s2">elif </span><span class="s1">pa.types.is_floating(pa_type):</span>
            <span class="s2">return </span><span class="s1">float</span>
        <span class="s2">elif </span><span class="s1">pa.types.is_string(pa_type) </span><span class="s2">or </span><span class="s1">pa.types.is_large_string(pa_type):</span>
            <span class="s2">return </span><span class="s1">str</span>
        <span class="s2">elif </span><span class="s1">(</span>
            <span class="s1">pa.types.is_binary(pa_type)</span>
            <span class="s2">or </span><span class="s1">pa.types.is_fixed_size_binary(pa_type)</span>
            <span class="s2">or </span><span class="s1">pa.types.is_large_binary(pa_type)</span>
        <span class="s1">):</span>
            <span class="s2">return </span><span class="s1">bytes</span>
        <span class="s2">elif </span><span class="s1">pa.types.is_boolean(pa_type):</span>
            <span class="s2">return </span><span class="s1">bool</span>
        <span class="s2">elif </span><span class="s1">pa.types.is_duration(pa_type):</span>
            <span class="s2">if </span><span class="s1">pa_type.unit == </span><span class="s5">&quot;ns&quot;</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">Timedelta</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">timedelta</span>
        <span class="s2">elif </span><span class="s1">pa.types.is_timestamp(pa_type):</span>
            <span class="s2">if </span><span class="s1">pa_type.unit == </span><span class="s5">&quot;ns&quot;</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">Timestamp</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">datetime</span>
        <span class="s2">elif </span><span class="s1">pa.types.is_date(pa_type):</span>
            <span class="s2">return </span><span class="s1">date</span>
        <span class="s2">elif </span><span class="s1">pa.types.is_time(pa_type):</span>
            <span class="s2">return </span><span class="s1">time</span>
        <span class="s2">elif </span><span class="s1">pa.types.is_decimal(pa_type):</span>
            <span class="s2">return </span><span class="s1">Decimal</span>
        <span class="s2">elif </span><span class="s1">pa.types.is_dictionary(pa_type):</span>
            <span class="s3"># TODO: Potentially change this &amp; CategoricalDtype.type to</span>
            <span class="s3">#  something more representative of the scalar</span>
            <span class="s2">return </span><span class="s1">CategoricalDtypeType</span>
        <span class="s2">elif </span><span class="s1">pa.types.is_list(pa_type) </span><span class="s2">or </span><span class="s1">pa.types.is_large_list(pa_type):</span>
            <span class="s2">return </span><span class="s1">list</span>
        <span class="s2">elif </span><span class="s1">pa.types.is_fixed_size_list(pa_type):</span>
            <span class="s2">return </span><span class="s1">list</span>
        <span class="s2">elif </span><span class="s1">pa.types.is_map(pa_type):</span>
            <span class="s2">return </span><span class="s1">list</span>
        <span class="s2">elif </span><span class="s1">pa.types.is_struct(pa_type):</span>
            <span class="s2">return </span><span class="s1">dict</span>
        <span class="s2">elif </span><span class="s1">pa.types.is_null(pa_type):</span>
            <span class="s3"># TODO: None? pd.NA? pa.null?</span>
            <span class="s2">return </span><span class="s1">type(pa_type)</span>
        <span class="s2">elif </span><span class="s1">isinstance(pa_type</span><span class="s2">, </span><span class="s1">pa.ExtensionType):</span>
            <span class="s2">return </span><span class="s1">type(self)(pa_type.storage_type).type</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError(pa_type)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">name(self) -&gt; str:  </span><span class="s3"># type: ignore[override]</span>
        <span class="s0">&quot;&quot;&quot; 
        A string identifying the data type. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s5">f&quot;</span><span class="s2">{</span><span class="s1">str(self.pyarrow_dtype)</span><span class="s2">}</span><span class="s5">[</span><span class="s2">{</span><span class="s1">self.storage</span><span class="s2">}</span><span class="s5">]&quot;</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">numpy_dtype(self) -&gt; np.dtype:</span>
        <span class="s0">&quot;&quot;&quot;Return an instance of the related numpy dtype&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">pa.types.is_timestamp(self.pyarrow_dtype):</span>
            <span class="s3"># pa.timestamp(unit).to_pandas_dtype() returns ns units</span>
            <span class="s3"># regardless of the pyarrow timestamp units.</span>
            <span class="s3"># This can be removed if/when pyarrow addresses it:</span>
            <span class="s3"># https://github.com/apache/arrow/issues/34462</span>
            <span class="s2">return </span><span class="s1">np.dtype(</span><span class="s5">f&quot;datetime64[</span><span class="s2">{</span><span class="s1">self.pyarrow_dtype.unit</span><span class="s2">}</span><span class="s5">]&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">pa.types.is_duration(self.pyarrow_dtype):</span>
            <span class="s3"># pa.duration(unit).to_pandas_dtype() returns ns units</span>
            <span class="s3"># regardless of the pyarrow duration units</span>
            <span class="s3"># This can be removed if/when pyarrow addresses it:</span>
            <span class="s3"># https://github.com/apache/arrow/issues/34462</span>
            <span class="s2">return </span><span class="s1">np.dtype(</span><span class="s5">f&quot;timedelta64[</span><span class="s2">{</span><span class="s1">self.pyarrow_dtype.unit</span><span class="s2">}</span><span class="s5">]&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">pa.types.is_string(self.pyarrow_dtype):</span>
            <span class="s3"># pa.string().to_pandas_dtype() = object which we don't want</span>
            <span class="s2">return </span><span class="s1">np.dtype(str)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">np.dtype(self.pyarrow_dtype.to_pandas_dtype())</span>
        <span class="s2">except </span><span class="s1">(NotImplementedError</span><span class="s2">, </span><span class="s1">TypeError):</span>
            <span class="s2">return </span><span class="s1">np.dtype(object)</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">kind(self) -&gt; str:</span>
        <span class="s2">if </span><span class="s1">pa.types.is_timestamp(self.pyarrow_dtype):</span>
            <span class="s3"># To mirror DatetimeTZDtype</span>
            <span class="s2">return </span><span class="s5">&quot;M&quot;</span>
        <span class="s2">return </span><span class="s1">self.numpy_dtype.kind</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">itemsize(self) -&gt; int:</span>
        <span class="s0">&quot;&quot;&quot;Return the number of bytes in this dtype&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.numpy_dtype.itemsize</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">construct_array_type(cls) -&gt; type_t[ArrowExtensionArray]:</span>
        <span class="s0">&quot;&quot;&quot; 
        Return the array type associated with this dtype. 
 
        Returns 
        ------- 
        type 
        &quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s1">pandas.core.arrays.arrow </span><span class="s2">import </span><span class="s1">ArrowExtensionArray</span>

        <span class="s2">return </span><span class="s1">ArrowExtensionArray</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">construct_from_string(cls</span><span class="s2">, </span><span class="s1">string: str) -&gt; ArrowDtype:</span>
        <span class="s0">&quot;&quot;&quot; 
        Construct this type from a string. 
 
        Parameters 
        ---------- 
        string : str 
            string should follow the format f&quot;{pyarrow_type}[pyarrow]&quot; 
            e.g. int64[pyarrow] 
        &quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">isinstance(string</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span>
                <span class="s5">f&quot;'construct_from_string' expects a string, got </span><span class="s2">{</span><span class="s1">type(string)</span><span class="s2">}</span><span class="s5">&quot;</span>
            <span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">string.endswith(</span><span class="s5">&quot;[pyarrow]&quot;</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s5">f&quot;'</span><span class="s2">{</span><span class="s1">string</span><span class="s2">}</span><span class="s5">' must end with '[pyarrow]'&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">string == </span><span class="s5">&quot;string[pyarrow]&quot;</span><span class="s1">:</span>
            <span class="s3"># Ensure Registry.find skips ArrowDtype to use StringDtype instead</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s5">&quot;string[pyarrow] should be constructed by StringDtype&quot;</span><span class="s1">)</span>

        <span class="s1">base_type = string[:-</span><span class="s4">9</span><span class="s1">]  </span><span class="s3"># get rid of &quot;[pyarrow]&quot;</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">pa_dtype = pa.type_for_alias(base_type)</span>
        <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">err:</span>
            <span class="s1">has_parameters = re.search(</span><span class="s5">r&quot;[\[\(].*[\]\)]&quot;</span><span class="s2">, </span><span class="s1">base_type)</span>
            <span class="s2">if </span><span class="s1">has_parameters:</span>
                <span class="s3"># Fallback to try common temporal types</span>
                <span class="s2">try</span><span class="s1">:</span>
                    <span class="s2">return </span><span class="s1">cls._parse_temporal_dtype_string(base_type)</span>
                <span class="s2">except </span><span class="s1">(NotImplementedError</span><span class="s2">, </span><span class="s1">ValueError):</span>
                    <span class="s3"># Fall through to raise with nice exception message below</span>
                    <span class="s2">pass</span>

                <span class="s2">raise </span><span class="s1">NotImplementedError(</span>
                    <span class="s5">&quot;Passing pyarrow type specific parameters &quot;</span>
                    <span class="s5">f&quot;(</span><span class="s2">{</span><span class="s1">has_parameters.group()</span><span class="s2">}</span><span class="s5">) in the string is not supported. &quot;</span>
                    <span class="s5">&quot;Please construct an ArrowDtype object with a pyarrow_dtype &quot;</span>
                    <span class="s5">&quot;instance with specific parameters.&quot;</span>
                <span class="s1">) </span><span class="s2">from </span><span class="s1">err</span>
            <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s5">f&quot;'</span><span class="s2">{</span><span class="s1">base_type</span><span class="s2">}</span><span class="s5">' is not a valid pyarrow data type.&quot;</span><span class="s1">) </span><span class="s2">from </span><span class="s1">err</span>
        <span class="s2">return </span><span class="s1">cls(pa_dtype)</span>

    <span class="s3"># TODO(arrow#33642): This can be removed once supported by pyarrow</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">_parse_temporal_dtype_string(cls</span><span class="s2">, </span><span class="s1">string: str) -&gt; ArrowDtype:</span>
        <span class="s0">&quot;&quot;&quot; 
        Construct a temporal ArrowDtype from string. 
        &quot;&quot;&quot;</span>
        <span class="s3"># we assume</span>
        <span class="s3">#  1) &quot;[pyarrow]&quot; has already been stripped from the end of our string.</span>
        <span class="s3">#  2) we know &quot;[&quot; is present</span>
        <span class="s1">head</span><span class="s2">, </span><span class="s1">tail = string.split(</span><span class="s5">&quot;[&quot;</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>

        <span class="s2">if not </span><span class="s1">tail.endswith(</span><span class="s5">&quot;]&quot;</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValueError</span>
        <span class="s1">tail = tail[:-</span><span class="s4">1</span><span class="s1">]</span>

        <span class="s2">if </span><span class="s1">head == </span><span class="s5">&quot;timestamp&quot;</span><span class="s1">:</span>
            <span class="s2">assert </span><span class="s5">&quot;,&quot; </span><span class="s2">in </span><span class="s1">tail  </span><span class="s3"># otherwise type_for_alias should work</span>
            <span class="s1">unit</span><span class="s2">, </span><span class="s1">tz = tail.split(</span><span class="s5">&quot;,&quot;</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">unit = unit.strip()</span>
            <span class="s1">tz = tz.strip()</span>
            <span class="s2">if </span><span class="s1">tz.startswith(</span><span class="s5">&quot;tz=&quot;</span><span class="s1">):</span>
                <span class="s1">tz = tz[</span><span class="s4">3</span><span class="s1">:]</span>

            <span class="s1">pa_type = pa.timestamp(unit</span><span class="s2">, </span><span class="s1">tz=tz)</span>
            <span class="s1">dtype = cls(pa_type)</span>
            <span class="s2">return </span><span class="s1">dtype</span>

        <span class="s2">raise </span><span class="s1">NotImplementedError(string)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_is_numeric(self) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot; 
        Whether columns with this dtype should be considered numeric. 
        &quot;&quot;&quot;</span>
        <span class="s3"># TODO: pa.types.is_boolean?</span>
        <span class="s2">return </span><span class="s1">(</span>
            <span class="s1">pa.types.is_integer(self.pyarrow_dtype)</span>
            <span class="s2">or </span><span class="s1">pa.types.is_floating(self.pyarrow_dtype)</span>
            <span class="s2">or </span><span class="s1">pa.types.is_decimal(self.pyarrow_dtype)</span>
        <span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_is_boolean(self) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot; 
        Whether this dtype should be considered boolean. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">pa.types.is_boolean(self.pyarrow_dtype)</span>

    <span class="s2">def </span><span class="s1">_get_common_dtype(self</span><span class="s2">, </span><span class="s1">dtypes: list[DtypeObj]) -&gt; DtypeObj | </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s3"># We unwrap any masked dtypes, find the common dtype we would use</span>
        <span class="s3">#  for that, then re-mask the result.</span>
        <span class="s3"># Mirrors BaseMaskedDtype</span>
        <span class="s2">from </span><span class="s1">pandas.core.dtypes.cast </span><span class="s2">import </span><span class="s1">find_common_type</span>

        <span class="s1">null_dtype = type(self)(pa.null())</span>

        <span class="s1">new_dtype = find_common_type(</span>
            <span class="s1">[</span>
                <span class="s1">dtype.numpy_dtype </span><span class="s2">if </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">ArrowDtype) </span><span class="s2">else </span><span class="s1">dtype</span>
                <span class="s2">for </span><span class="s1">dtype </span><span class="s2">in </span><span class="s1">dtypes</span>
                <span class="s2">if </span><span class="s1">dtype != null_dtype</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">isinstance(new_dtype</span><span class="s2">, </span><span class="s1">np.dtype):</span>
            <span class="s2">return None</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">pa_dtype = pa.from_numpy_dtype(new_dtype)</span>
            <span class="s2">return </span><span class="s1">type(self)(pa_dtype)</span>
        <span class="s2">except </span><span class="s1">NotImplementedError:</span>
            <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">__from_arrow__(self</span><span class="s2">, </span><span class="s1">array: pa.Array | pa.ChunkedArray):</span>
        <span class="s0">&quot;&quot;&quot; 
        Construct IntegerArray/FloatingArray from pyarrow Array/ChunkedArray. 
        &quot;&quot;&quot;</span>
        <span class="s1">array_class = self.construct_array_type()</span>
        <span class="s1">arr = array.cast(self.pyarrow_dtype</span><span class="s2">, </span><span class="s1">safe=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">array_class(arr)</span>
</pre>
</body>
</html>