<html>
<head>
<title>test_interpnd.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_interpnd.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">os</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">numpy.testing </span><span class="s0">import </span><span class="s1">(assert_equal</span><span class="s0">, </span><span class="s1">assert_allclose</span><span class="s0">, </span><span class="s1">assert_almost_equal</span><span class="s0">,</span>
                           <span class="s1">suppress_warnings)</span>
<span class="s0">from </span><span class="s1">pytest </span><span class="s0">import </span><span class="s1">raises </span><span class="s0">as </span><span class="s1">assert_raises</span>
<span class="s0">import </span><span class="s1">pytest</span>

<span class="s0">import </span><span class="s1">scipy.interpolate.interpnd </span><span class="s0">as </span><span class="s1">interpnd</span>
<span class="s0">import </span><span class="s1">scipy.spatial._qhull </span><span class="s0">as </span><span class="s1">qhull</span>

<span class="s0">import </span><span class="s1">pickle</span>


<span class="s0">def </span><span class="s1">data_file(basename):</span>
    <span class="s0">return </span><span class="s1">os.path.join(os.path.abspath(os.path.dirname(__file__))</span><span class="s0">,</span>
                        <span class="s2">'data'</span><span class="s0">, </span><span class="s1">basename)</span>


<span class="s0">class </span><span class="s1">TestLinearNDInterpolation:</span>
    <span class="s0">def </span><span class="s1">test_smoketest(self):</span>
        <span class="s3"># Test at single points</span>
        <span class="s1">x = np.array([(</span><span class="s4">0</span><span class="s0">,</span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s4">0.5</span><span class="s0">,</span><span class="s1">-</span><span class="s4">0.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s4">0.5</span><span class="s0">,</span><span class="s4">0.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0.5</span><span class="s0">, </span><span class="s4">0.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0.25</span><span class="s0">, </span><span class="s4">0.3</span><span class="s1">)]</span><span class="s0">,</span>
                     <span class="s1">dtype=np.double)</span>
        <span class="s1">y = np.arange(x.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.double)</span>

        <span class="s1">yi = interpnd.LinearNDInterpolator(x</span><span class="s0">, </span><span class="s1">y)(x)</span>
        <span class="s1">assert_almost_equal(y</span><span class="s0">, </span><span class="s1">yi)</span>

    <span class="s0">def </span><span class="s1">test_smoketest_alternate(self):</span>
        <span class="s3"># Test at single points, alternate calling convention</span>
        <span class="s1">x = np.array([(</span><span class="s4">0</span><span class="s0">,</span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s4">0.5</span><span class="s0">,</span><span class="s1">-</span><span class="s4">0.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s4">0.5</span><span class="s0">,</span><span class="s4">0.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0.5</span><span class="s0">, </span><span class="s4">0.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0.25</span><span class="s0">, </span><span class="s4">0.3</span><span class="s1">)]</span><span class="s0">,</span>
                     <span class="s1">dtype=np.double)</span>
        <span class="s1">y = np.arange(x.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.double)</span>

        <span class="s1">yi = interpnd.LinearNDInterpolator((x[:</span><span class="s0">,</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x[:</span><span class="s0">,</span><span class="s4">1</span><span class="s1">])</span><span class="s0">, </span><span class="s1">y)(x[:</span><span class="s0">,</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x[:</span><span class="s0">,</span><span class="s4">1</span><span class="s1">])</span>
        <span class="s1">assert_almost_equal(y</span><span class="s0">, </span><span class="s1">yi)</span>

    <span class="s0">def </span><span class="s1">test_complex_smoketest(self):</span>
        <span class="s3"># Test at single points</span>
        <span class="s1">x = np.array([(</span><span class="s4">0</span><span class="s0">,</span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s4">0.5</span><span class="s0">,</span><span class="s1">-</span><span class="s4">0.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s4">0.5</span><span class="s0">,</span><span class="s4">0.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0.5</span><span class="s0">, </span><span class="s4">0.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0.25</span><span class="s0">, </span><span class="s4">0.3</span><span class="s1">)]</span><span class="s0">,</span>
                     <span class="s1">dtype=np.double)</span>
        <span class="s1">y = np.arange(x.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">y = y - </span><span class="s4">3j</span><span class="s1">*y</span>

        <span class="s1">yi = interpnd.LinearNDInterpolator(x</span><span class="s0">, </span><span class="s1">y)(x)</span>
        <span class="s1">assert_almost_equal(y</span><span class="s0">, </span><span class="s1">yi)</span>

    <span class="s0">def </span><span class="s1">test_tri_input(self):</span>
        <span class="s3"># Test at single points</span>
        <span class="s1">x = np.array([(</span><span class="s4">0</span><span class="s0">,</span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s4">0.5</span><span class="s0">,</span><span class="s1">-</span><span class="s4">0.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s4">0.5</span><span class="s0">,</span><span class="s4">0.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0.5</span><span class="s0">, </span><span class="s4">0.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0.25</span><span class="s0">, </span><span class="s4">0.3</span><span class="s1">)]</span><span class="s0">,</span>
                     <span class="s1">dtype=np.double)</span>
        <span class="s1">y = np.arange(x.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">y = y - </span><span class="s4">3j</span><span class="s1">*y</span>

        <span class="s1">tri = qhull.Delaunay(x)</span>
        <span class="s1">yi = interpnd.LinearNDInterpolator(tri</span><span class="s0">, </span><span class="s1">y)(x)</span>
        <span class="s1">assert_almost_equal(y</span><span class="s0">, </span><span class="s1">yi)</span>

    <span class="s0">def </span><span class="s1">test_square(self):</span>
        <span class="s3"># Test barycentric interpolation on a square against a manual</span>
        <span class="s3"># implementation</span>

        <span class="s1">points = np.array([(</span><span class="s4">0</span><span class="s0">,</span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">,</span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">1</span><span class="s0">,</span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">1</span><span class="s0">,</span><span class="s4">0</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">values = np.array([</span><span class="s4">1.</span><span class="s0">, </span><span class="s4">2.</span><span class="s0">, </span><span class="s1">-</span><span class="s4">3.</span><span class="s0">, </span><span class="s4">5.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.double)</span>

        <span class="s3"># NB: assume triangles (0, 1, 3) and (1, 2, 3)</span>
        <span class="s3">#</span>
        <span class="s3">#  1----2</span>
        <span class="s3">#  | \  |</span>
        <span class="s3">#  |  \ |</span>
        <span class="s3">#  0----3</span>

        <span class="s0">def </span><span class="s1">ip(x</span><span class="s0">, </span><span class="s1">y):</span>
            <span class="s1">t1 = (x + y &lt;= </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">t2 = ~t1</span>

            <span class="s1">x1 = x[t1]</span>
            <span class="s1">y1 = y[t1]</span>

            <span class="s1">x2 = x[t2]</span>
            <span class="s1">y2 = y[t2]</span>

            <span class="s1">z = </span><span class="s4">0</span><span class="s1">*x</span>

            <span class="s1">z[t1] = (values[</span><span class="s4">0</span><span class="s1">]*(</span><span class="s4">1 </span><span class="s1">- x1 - y1)</span>
                     <span class="s1">+ values[</span><span class="s4">1</span><span class="s1">]*y1</span>
                     <span class="s1">+ values[</span><span class="s4">3</span><span class="s1">]*x1)</span>

            <span class="s1">z[t2] = (values[</span><span class="s4">2</span><span class="s1">]*(x2 + y2 - </span><span class="s4">1</span><span class="s1">)</span>
                     <span class="s1">+ values[</span><span class="s4">1</span><span class="s1">]*(</span><span class="s4">1 </span><span class="s1">- x2)</span>
                     <span class="s1">+ values[</span><span class="s4">3</span><span class="s1">]*(</span><span class="s4">1 </span><span class="s1">- y2))</span>
            <span class="s0">return </span><span class="s1">z</span>

        <span class="s1">xx</span><span class="s0">, </span><span class="s1">yy = np.broadcast_arrays(np.linspace(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">14</span><span class="s1">)[:</span><span class="s0">,None</span><span class="s1">]</span><span class="s0">,</span>
                                     <span class="s1">np.linspace(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">14</span><span class="s1">)[</span><span class="s0">None,</span><span class="s1">:])</span>
        <span class="s1">xx = xx.ravel()</span>
        <span class="s1">yy = yy.ravel()</span>

        <span class="s1">xi = np.array([xx</span><span class="s0">, </span><span class="s1">yy]).T.copy()</span>
        <span class="s1">zi = interpnd.LinearNDInterpolator(points</span><span class="s0">, </span><span class="s1">values)(xi)</span>

        <span class="s1">assert_almost_equal(zi</span><span class="s0">, </span><span class="s1">ip(xx</span><span class="s0">, </span><span class="s1">yy))</span>

    <span class="s0">def </span><span class="s1">test_smoketest_rescale(self):</span>
        <span class="s3"># Test at single points</span>
        <span class="s1">x = np.array([(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s4">5</span><span class="s0">, </span><span class="s1">-</span><span class="s4">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s4">5</span><span class="s0">, </span><span class="s4">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">5</span><span class="s0">, </span><span class="s4">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">2.5</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)]</span><span class="s0">,</span>
                     <span class="s1">dtype=np.double)</span>
        <span class="s1">y = np.arange(x.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.double)</span>

        <span class="s1">yi = interpnd.LinearNDInterpolator(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">rescale=</span><span class="s0">True</span><span class="s1">)(x)</span>
        <span class="s1">assert_almost_equal(y</span><span class="s0">, </span><span class="s1">yi)</span>

    <span class="s0">def </span><span class="s1">test_square_rescale(self):</span>
        <span class="s3"># Test barycentric interpolation on a rectangle with rescaling</span>
        <span class="s3"># agaings the same implementation without rescaling</span>

        <span class="s1">points = np.array([(</span><span class="s4">0</span><span class="s0">,</span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">,</span><span class="s4">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">10</span><span class="s0">,</span><span class="s4">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">10</span><span class="s0">,</span><span class="s4">0</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">values = np.array([</span><span class="s4">1.</span><span class="s0">, </span><span class="s4">2.</span><span class="s0">, </span><span class="s1">-</span><span class="s4">3.</span><span class="s0">, </span><span class="s4">5.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.double)</span>

        <span class="s1">xx</span><span class="s0">, </span><span class="s1">yy = np.broadcast_arrays(np.linspace(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">10</span><span class="s0">, </span><span class="s4">14</span><span class="s1">)[:</span><span class="s0">,None</span><span class="s1">]</span><span class="s0">,</span>
                                     <span class="s1">np.linspace(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">100</span><span class="s0">, </span><span class="s4">14</span><span class="s1">)[</span><span class="s0">None,</span><span class="s1">:])</span>
        <span class="s1">xx = xx.ravel()</span>
        <span class="s1">yy = yy.ravel()</span>
        <span class="s1">xi = np.array([xx</span><span class="s0">, </span><span class="s1">yy]).T.copy()</span>
        <span class="s1">zi = interpnd.LinearNDInterpolator(points</span><span class="s0">, </span><span class="s1">values)(xi)</span>
        <span class="s1">zi_rescaled = interpnd.LinearNDInterpolator(points</span><span class="s0">, </span><span class="s1">values</span><span class="s0">,</span>
                <span class="s1">rescale=</span><span class="s0">True</span><span class="s1">)(xi)</span>

        <span class="s1">assert_almost_equal(zi</span><span class="s0">, </span><span class="s1">zi_rescaled)</span>

    <span class="s0">def </span><span class="s1">test_tripoints_input_rescale(self):</span>
        <span class="s3"># Test at single points</span>
        <span class="s1">x = np.array([(</span><span class="s4">0</span><span class="s0">,</span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s4">5</span><span class="s0">,</span><span class="s1">-</span><span class="s4">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s4">5</span><span class="s0">,</span><span class="s4">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">5</span><span class="s0">, </span><span class="s4">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">2.5</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)]</span><span class="s0">,</span>
                     <span class="s1">dtype=np.double)</span>
        <span class="s1">y = np.arange(x.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">y = y - </span><span class="s4">3j</span><span class="s1">*y</span>

        <span class="s1">tri = qhull.Delaunay(x)</span>
        <span class="s1">yi = interpnd.LinearNDInterpolator(tri.points</span><span class="s0">, </span><span class="s1">y)(x)</span>
        <span class="s1">yi_rescale = interpnd.LinearNDInterpolator(tri.points</span><span class="s0">, </span><span class="s1">y</span><span class="s0">,</span>
                <span class="s1">rescale=</span><span class="s0">True</span><span class="s1">)(x)</span>
        <span class="s1">assert_almost_equal(yi</span><span class="s0">, </span><span class="s1">yi_rescale)</span>

    <span class="s0">def </span><span class="s1">test_tri_input_rescale(self):</span>
        <span class="s3"># Test at single points</span>
        <span class="s1">x = np.array([(</span><span class="s4">0</span><span class="s0">,</span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s4">5</span><span class="s0">,</span><span class="s1">-</span><span class="s4">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s4">5</span><span class="s0">,</span><span class="s4">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">5</span><span class="s0">, </span><span class="s4">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">2.5</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)]</span><span class="s0">,</span>
                     <span class="s1">dtype=np.double)</span>
        <span class="s1">y = np.arange(x.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">y = y - </span><span class="s4">3j</span><span class="s1">*y</span>

        <span class="s1">tri = qhull.Delaunay(x)</span>
        <span class="s1">match = (</span><span class="s2">&quot;Rescaling is not supported when passing a &quot;</span>
                 <span class="s2">&quot;Delaunay triangulation as ``points``.&quot;</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=match):</span>
            <span class="s1">interpnd.LinearNDInterpolator(tri</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">rescale=</span><span class="s0">True</span><span class="s1">)(x)</span>

    <span class="s0">def </span><span class="s1">test_pickle(self):</span>
        <span class="s3"># Test at single points</span>
        <span class="s1">np.random.seed(</span><span class="s4">1234</span><span class="s1">)</span>
        <span class="s1">x = np.random.rand(</span><span class="s4">30</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">y = np.random.rand(</span><span class="s4">30</span><span class="s1">) + </span><span class="s4">1j</span><span class="s1">*np.random.rand(</span><span class="s4">30</span><span class="s1">)</span>

        <span class="s1">ip = interpnd.LinearNDInterpolator(x</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s1">ip2 = pickle.loads(pickle.dumps(ip))</span>

        <span class="s1">assert_almost_equal(ip(</span><span class="s4">0.5</span><span class="s0">, </span><span class="s4">0.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">ip2(</span><span class="s4">0.5</span><span class="s0">, </span><span class="s4">0.5</span><span class="s1">))</span>


<span class="s0">class </span><span class="s1">TestEstimateGradients2DGlobal:</span>
    <span class="s0">def </span><span class="s1">test_smoketest(self):</span>
        <span class="s1">x = np.array([(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span><span class="s0">,</span>
                      <span class="s1">(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0.25</span><span class="s0">, </span><span class="s4">0.75</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0.6</span><span class="s0">, </span><span class="s4">0.8</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">dtype=float)</span>
        <span class="s1">tri = qhull.Delaunay(x)</span>

        <span class="s3"># Should be exact for linear functions, independent of triangulation</span>

        <span class="s1">funcs = [</span>
            <span class="s1">(</span><span class="s0">lambda </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y: </span><span class="s4">0</span><span class="s1">*x + </span><span class="s4">1</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s0">lambda </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y: </span><span class="s4">0 </span><span class="s1">+ x</span><span class="s0">, </span><span class="s1">(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s0">lambda </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y: -</span><span class="s4">2 </span><span class="s1">+ y</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s0">lambda </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y: </span><span class="s4">3 </span><span class="s1">+ </span><span class="s4">3</span><span class="s1">*x + </span><span class="s4">14.15</span><span class="s1">*y</span><span class="s0">, </span><span class="s1">(</span><span class="s4">3</span><span class="s0">, </span><span class="s4">14.15</span><span class="s1">))</span>
        <span class="s1">]</span>

        <span class="s0">for </span><span class="s1">j</span><span class="s0">, </span><span class="s1">(func</span><span class="s0">, </span><span class="s1">grad) </span><span class="s0">in </span><span class="s1">enumerate(funcs):</span>
            <span class="s1">z = func(x[:</span><span class="s0">,</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x[:</span><span class="s0">,</span><span class="s4">1</span><span class="s1">])</span>
            <span class="s1">dz = interpnd.estimate_gradients_2d_global(tri</span><span class="s0">, </span><span class="s1">z</span><span class="s0">, </span><span class="s1">tol=</span><span class="s4">1e-6</span><span class="s1">)</span>

            <span class="s1">assert_equal(dz.shape</span><span class="s0">, </span><span class="s1">(</span><span class="s4">6</span><span class="s0">, </span><span class="s4">2</span><span class="s1">))</span>
            <span class="s1">assert_allclose(dz</span><span class="s0">, </span><span class="s1">np.array(grad)[</span><span class="s0">None,</span><span class="s1">:] + </span><span class="s4">0</span><span class="s1">*dz</span><span class="s0">,</span>
                            <span class="s1">rtol=</span><span class="s4">1e-5</span><span class="s0">, </span><span class="s1">atol=</span><span class="s4">1e-5</span><span class="s0">, </span><span class="s1">err_msg=</span><span class="s2">&quot;item %d&quot; </span><span class="s1">% j)</span>

    <span class="s0">def </span><span class="s1">test_regression_2359(self):</span>
        <span class="s3"># Check regression --- for certain point sets, gradient</span>
        <span class="s3"># estimation could end up in an infinite loop</span>
        <span class="s1">points = np.load(data_file(</span><span class="s2">'estimate_gradients_hang.npy'</span><span class="s1">))</span>
        <span class="s1">values = np.random.rand(points.shape[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">tri = qhull.Delaunay(points)</span>

        <span class="s3"># This should not hang</span>
        <span class="s0">with </span><span class="s1">suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(interpnd.GradientEstimationWarning</span><span class="s0">,</span>
                       <span class="s2">&quot;Gradient estimation did not converge&quot;</span><span class="s1">)</span>
            <span class="s1">interpnd.estimate_gradients_2d_global(tri</span><span class="s0">, </span><span class="s1">values</span><span class="s0">, </span><span class="s1">maxiter=</span><span class="s4">1</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestCloughTocher2DInterpolator:</span>

    <span class="s0">def </span><span class="s1">_check_accuracy(self</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">x=</span><span class="s0">None, </span><span class="s1">tol=</span><span class="s4">1e-6</span><span class="s0">, </span><span class="s1">alternate=</span><span class="s0">False, </span><span class="s1">rescale=</span><span class="s0">False, </span><span class="s1">**kw):</span>
        <span class="s1">np.random.seed(</span><span class="s4">1234</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">x </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">x = np.array([(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">,</span>
                          <span class="s1">(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0.25</span><span class="s0">, </span><span class="s4">0.75</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0.6</span><span class="s0">, </span><span class="s4">0.8</span><span class="s1">)</span><span class="s0">,</span>
                          <span class="s1">(</span><span class="s4">0.5</span><span class="s0">, </span><span class="s4">0.2</span><span class="s1">)]</span><span class="s0">,</span>
                         <span class="s1">dtype=float)</span>

        <span class="s0">if not </span><span class="s1">alternate:</span>
            <span class="s1">ip = interpnd.CloughTocher2DInterpolator(x</span><span class="s0">, </span><span class="s1">func(x[:</span><span class="s0">,</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x[:</span><span class="s0">,</span><span class="s4">1</span><span class="s1">])</span><span class="s0">,</span>
                                                     <span class="s1">tol=</span><span class="s4">1e-6</span><span class="s0">, </span><span class="s1">rescale=rescale)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">ip = interpnd.CloughTocher2DInterpolator((x[:</span><span class="s0">,</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x[:</span><span class="s0">,</span><span class="s4">1</span><span class="s1">])</span><span class="s0">,</span>
                                                     <span class="s1">func(x[:</span><span class="s0">,</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x[:</span><span class="s0">,</span><span class="s4">1</span><span class="s1">])</span><span class="s0">,</span>
                                                     <span class="s1">tol=</span><span class="s4">1e-6</span><span class="s0">, </span><span class="s1">rescale=rescale)</span>

        <span class="s1">p = np.random.rand(</span><span class="s4">50</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span>

        <span class="s0">if not </span><span class="s1">alternate:</span>
            <span class="s1">a = ip(p)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">a = ip(p[:</span><span class="s0">,</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">p[:</span><span class="s0">,</span><span class="s4">1</span><span class="s1">])</span>
        <span class="s1">b = func(p[:</span><span class="s0">,</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">p[:</span><span class="s0">,</span><span class="s4">1</span><span class="s1">])</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">assert_allclose(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">**kw)</span>
        <span class="s0">except </span><span class="s1">AssertionError:</span>
            <span class="s1">print(</span><span class="s2">&quot;_check_accuracy: abs(a-b):&quot;</span><span class="s0">, </span><span class="s1">abs(a - b))</span>
            <span class="s1">print(</span><span class="s2">&quot;ip.grad:&quot;</span><span class="s0">, </span><span class="s1">ip.grad)</span>
            <span class="s0">raise</span>

    <span class="s0">def </span><span class="s1">test_linear_smoketest(self):</span>
        <span class="s3"># Should be exact for linear functions, independent of triangulation</span>
        <span class="s1">funcs = [</span>
            <span class="s0">lambda </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y: </span><span class="s4">0</span><span class="s1">*x + </span><span class="s4">1</span><span class="s0">,</span>
            <span class="s0">lambda </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y: </span><span class="s4">0 </span><span class="s1">+ x</span><span class="s0">,</span>
            <span class="s0">lambda </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y: -</span><span class="s4">2 </span><span class="s1">+ y</span><span class="s0">,</span>
            <span class="s0">lambda </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y: </span><span class="s4">3 </span><span class="s1">+ </span><span class="s4">3</span><span class="s1">*x + </span><span class="s4">14.15</span><span class="s1">*y</span><span class="s0">,</span>
        <span class="s1">]</span>

        <span class="s0">for </span><span class="s1">j</span><span class="s0">, </span><span class="s1">func </span><span class="s0">in </span><span class="s1">enumerate(funcs):</span>
            <span class="s1">self._check_accuracy(func</span><span class="s0">, </span><span class="s1">tol=</span><span class="s4">1e-13</span><span class="s0">, </span><span class="s1">atol=</span><span class="s4">1e-7</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s4">1e-7</span><span class="s0">,</span>
                                 <span class="s1">err_msg=</span><span class="s2">&quot;Function %d&quot; </span><span class="s1">% j)</span>
            <span class="s1">self._check_accuracy(func</span><span class="s0">, </span><span class="s1">tol=</span><span class="s4">1e-13</span><span class="s0">, </span><span class="s1">atol=</span><span class="s4">1e-7</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s4">1e-7</span><span class="s0">,</span>
                                 <span class="s1">alternate=</span><span class="s0">True,</span>
                                 <span class="s1">err_msg=</span><span class="s2">&quot;Function (alternate) %d&quot; </span><span class="s1">% j)</span>
            <span class="s3"># check rescaling</span>
            <span class="s1">self._check_accuracy(func</span><span class="s0">, </span><span class="s1">tol=</span><span class="s4">1e-13</span><span class="s0">, </span><span class="s1">atol=</span><span class="s4">1e-7</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s4">1e-7</span><span class="s0">,</span>
                                 <span class="s1">err_msg=</span><span class="s2">&quot;Function (rescaled) %d&quot; </span><span class="s1">% j</span><span class="s0">, </span><span class="s1">rescale=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s1">self._check_accuracy(func</span><span class="s0">, </span><span class="s1">tol=</span><span class="s4">1e-13</span><span class="s0">, </span><span class="s1">atol=</span><span class="s4">1e-7</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s4">1e-7</span><span class="s0">,</span>
                                 <span class="s1">alternate=</span><span class="s0">True, </span><span class="s1">rescale=</span><span class="s0">True,</span>
                                 <span class="s1">err_msg=</span><span class="s2">&quot;Function (alternate, rescaled) %d&quot; </span><span class="s1">% j)</span>

    <span class="s0">def </span><span class="s1">test_quadratic_smoketest(self):</span>
        <span class="s3"># Should be reasonably accurate for quadratic functions</span>
        <span class="s1">funcs = [</span>
            <span class="s0">lambda </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y: x**</span><span class="s4">2</span><span class="s0">,</span>
            <span class="s0">lambda </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y: y**</span><span class="s4">2</span><span class="s0">,</span>
            <span class="s0">lambda </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y: x**</span><span class="s4">2 </span><span class="s1">- y**</span><span class="s4">2</span><span class="s0">,</span>
            <span class="s0">lambda </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y: x*y</span><span class="s0">,</span>
        <span class="s1">]</span>

        <span class="s0">for </span><span class="s1">j</span><span class="s0">, </span><span class="s1">func </span><span class="s0">in </span><span class="s1">enumerate(funcs):</span>
            <span class="s1">self._check_accuracy(func</span><span class="s0">, </span><span class="s1">tol=</span><span class="s4">1e-9</span><span class="s0">, </span><span class="s1">atol=</span><span class="s4">0.22</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s0">,</span>
                                 <span class="s1">err_msg=</span><span class="s2">&quot;Function %d&quot; </span><span class="s1">% j)</span>
            <span class="s1">self._check_accuracy(func</span><span class="s0">, </span><span class="s1">tol=</span><span class="s4">1e-9</span><span class="s0">, </span><span class="s1">atol=</span><span class="s4">0.22</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s0">,</span>
                                 <span class="s1">err_msg=</span><span class="s2">&quot;Function %d&quot; </span><span class="s1">% j</span><span class="s0">, </span><span class="s1">rescale=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_tri_input(self):</span>
        <span class="s3"># Test at single points</span>
        <span class="s1">x = np.array([(</span><span class="s4">0</span><span class="s0">,</span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s4">0.5</span><span class="s0">,</span><span class="s1">-</span><span class="s4">0.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s4">0.5</span><span class="s0">,</span><span class="s4">0.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0.5</span><span class="s0">, </span><span class="s4">0.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0.25</span><span class="s0">, </span><span class="s4">0.3</span><span class="s1">)]</span><span class="s0">,</span>
                     <span class="s1">dtype=np.double)</span>
        <span class="s1">y = np.arange(x.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">y = y - </span><span class="s4">3j</span><span class="s1">*y</span>

        <span class="s1">tri = qhull.Delaunay(x)</span>
        <span class="s1">yi = interpnd.CloughTocher2DInterpolator(tri</span><span class="s0">, </span><span class="s1">y)(x)</span>
        <span class="s1">assert_almost_equal(y</span><span class="s0">, </span><span class="s1">yi)</span>

    <span class="s0">def </span><span class="s1">test_tri_input_rescale(self):</span>
        <span class="s3"># Test at single points</span>
        <span class="s1">x = np.array([(</span><span class="s4">0</span><span class="s0">,</span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s4">5</span><span class="s0">,</span><span class="s1">-</span><span class="s4">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s4">5</span><span class="s0">,</span><span class="s4">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">5</span><span class="s0">, </span><span class="s4">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">2.5</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)]</span><span class="s0">,</span>
                     <span class="s1">dtype=np.double)</span>
        <span class="s1">y = np.arange(x.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">y = y - </span><span class="s4">3j</span><span class="s1">*y</span>

        <span class="s1">tri = qhull.Delaunay(x)</span>
        <span class="s1">match = (</span><span class="s2">&quot;Rescaling is not supported when passing a &quot;</span>
                 <span class="s2">&quot;Delaunay triangulation as ``points``.&quot;</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=match):</span>
            <span class="s1">interpnd.CloughTocher2DInterpolator(tri</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">rescale=</span><span class="s0">True</span><span class="s1">)(x)</span>

    <span class="s0">def </span><span class="s1">test_tripoints_input_rescale(self):</span>
        <span class="s3"># Test at single points</span>
        <span class="s1">x = np.array([(</span><span class="s4">0</span><span class="s0">,</span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s4">5</span><span class="s0">,</span><span class="s1">-</span><span class="s4">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(-</span><span class="s4">5</span><span class="s0">,</span><span class="s4">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">5</span><span class="s0">, </span><span class="s4">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">2.5</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)]</span><span class="s0">,</span>
                     <span class="s1">dtype=np.double)</span>
        <span class="s1">y = np.arange(x.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.double)</span>
        <span class="s1">y = y - </span><span class="s4">3j</span><span class="s1">*y</span>

        <span class="s1">tri = qhull.Delaunay(x)</span>
        <span class="s1">yi = interpnd.CloughTocher2DInterpolator(tri.points</span><span class="s0">, </span><span class="s1">y)(x)</span>
        <span class="s1">yi_rescale = interpnd.CloughTocher2DInterpolator(tri.points</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">rescale=</span><span class="s0">True</span><span class="s1">)(x)</span>
        <span class="s1">assert_almost_equal(yi</span><span class="s0">, </span><span class="s1">yi_rescale)</span>

    <span class="s0">def </span><span class="s1">test_dense(self):</span>
        <span class="s3"># Should be more accurate for dense meshes</span>
        <span class="s1">funcs = [</span>
            <span class="s0">lambda </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y: x**</span><span class="s4">2</span><span class="s0">,</span>
            <span class="s0">lambda </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y: y**</span><span class="s4">2</span><span class="s0">,</span>
            <span class="s0">lambda </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y: x**</span><span class="s4">2 </span><span class="s1">- y**</span><span class="s4">2</span><span class="s0">,</span>
            <span class="s0">lambda </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y: x*y</span><span class="s0">,</span>
            <span class="s0">lambda </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y: np.cos(</span><span class="s4">2</span><span class="s1">*np.pi*x)*np.sin(</span><span class="s4">2</span><span class="s1">*np.pi*y)</span>
        <span class="s1">]</span>

        <span class="s1">np.random.seed(</span><span class="s4">4321</span><span class="s1">)  </span><span class="s3"># use a different seed than the check!</span>
        <span class="s1">grid = np.r_[np.array([(</span><span class="s4">0</span><span class="s0">,</span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">,</span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">1</span><span class="s0">,</span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">1</span><span class="s0">,</span><span class="s4">1</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">dtype=float)</span><span class="s0">,</span>
                     <span class="s1">np.random.rand(</span><span class="s4">30</span><span class="s1">*</span><span class="s4">30</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)]</span>

        <span class="s0">for </span><span class="s1">j</span><span class="s0">, </span><span class="s1">func </span><span class="s0">in </span><span class="s1">enumerate(funcs):</span>
            <span class="s1">self._check_accuracy(func</span><span class="s0">, </span><span class="s1">x=grid</span><span class="s0">, </span><span class="s1">tol=</span><span class="s4">1e-9</span><span class="s0">, </span><span class="s1">atol=</span><span class="s4">5e-3</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s4">1e-2</span><span class="s0">,</span>
                                 <span class="s1">err_msg=</span><span class="s2">&quot;Function %d&quot; </span><span class="s1">% j)</span>
            <span class="s1">self._check_accuracy(func</span><span class="s0">, </span><span class="s1">x=grid</span><span class="s0">, </span><span class="s1">tol=</span><span class="s4">1e-9</span><span class="s0">, </span><span class="s1">atol=</span><span class="s4">5e-3</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s4">1e-2</span><span class="s0">,</span>
                                 <span class="s1">err_msg=</span><span class="s2">&quot;Function %d&quot; </span><span class="s1">% j</span><span class="s0">, </span><span class="s1">rescale=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_wrong_ndim(self):</span>
        <span class="s1">x = np.random.randn(</span><span class="s4">30</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">y = np.random.randn(</span><span class="s4">30</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">interpnd.CloughTocher2DInterpolator</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y)</span>

    <span class="s0">def </span><span class="s1">test_pickle(self):</span>
        <span class="s3"># Test at single points</span>
        <span class="s1">np.random.seed(</span><span class="s4">1234</span><span class="s1">)</span>
        <span class="s1">x = np.random.rand(</span><span class="s4">30</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">y = np.random.rand(</span><span class="s4">30</span><span class="s1">) + </span><span class="s4">1j</span><span class="s1">*np.random.rand(</span><span class="s4">30</span><span class="s1">)</span>

        <span class="s1">ip = interpnd.CloughTocher2DInterpolator(x</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s1">ip2 = pickle.loads(pickle.dumps(ip))</span>

        <span class="s1">assert_almost_equal(ip(</span><span class="s4">0.5</span><span class="s0">, </span><span class="s4">0.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">ip2(</span><span class="s4">0.5</span><span class="s0">, </span><span class="s4">0.5</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_boundary_tri_symmetry(self):</span>
        <span class="s3"># Interpolation at neighbourless triangles should retain</span>
        <span class="s3"># symmetry with mirroring the triangle.</span>

        <span class="s3"># Equilateral triangle</span>
        <span class="s1">points = np.array([(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0.5</span><span class="s0">, </span><span class="s1">np.sqrt(</span><span class="s4">3</span><span class="s1">)/</span><span class="s4">2</span><span class="s1">)])</span>
        <span class="s1">values = np.array([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">])</span>

        <span class="s1">ip = interpnd.CloughTocher2DInterpolator(points</span><span class="s0">, </span><span class="s1">values)</span>

        <span class="s3"># Set gradient to zero at vertices</span>
        <span class="s1">ip.grad[...] = </span><span class="s4">0</span>

        <span class="s3"># Interpolation should be symmetric vs. bisector</span>
        <span class="s1">alpha = </span><span class="s4">0.3</span>
        <span class="s1">p1 = np.array([</span><span class="s4">0.5 </span><span class="s1">* np.cos(alpha)</span><span class="s0">, </span><span class="s4">0.5 </span><span class="s1">* np.sin(alpha)])</span>
        <span class="s1">p2 = np.array([</span><span class="s4">0.5 </span><span class="s1">* np.cos(np.pi/</span><span class="s4">3 </span><span class="s1">- alpha)</span><span class="s0">, </span><span class="s4">0.5 </span><span class="s1">* np.sin(np.pi/</span><span class="s4">3 </span><span class="s1">- alpha)])</span>

        <span class="s1">v1 = ip(p1)</span>
        <span class="s1">v2 = ip(p2)</span>
        <span class="s1">assert_allclose(v1</span><span class="s0">, </span><span class="s1">v2)</span>

        <span class="s3"># ... and affine invariant</span>
        <span class="s1">np.random.seed(</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">A = np.random.randn(</span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">b = np.random.randn(</span><span class="s4">2</span><span class="s1">)</span>

        <span class="s1">points = A.dot(points.T).T + b[</span><span class="s0">None,</span><span class="s1">:]</span>
        <span class="s1">p1 = A.dot(p1) + b</span>
        <span class="s1">p2 = A.dot(p2) + b</span>

        <span class="s1">ip = interpnd.CloughTocher2DInterpolator(points</span><span class="s0">, </span><span class="s1">values)</span>
        <span class="s1">ip.grad[...] = </span><span class="s4">0</span>

        <span class="s1">w1 = ip(p1)</span>
        <span class="s1">w2 = ip(p2)</span>
        <span class="s1">assert_allclose(w1</span><span class="s0">, </span><span class="s1">v1)</span>
        <span class="s1">assert_allclose(w2</span><span class="s0">, </span><span class="s1">v2)</span>
</pre>
</body>
</html>