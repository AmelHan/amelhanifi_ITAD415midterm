<html>
<head>
<title>_linprog_rs.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_linprog_rs.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Revised simplex method for linear programming 
 
The *revised simplex* method uses the method described in [1]_, except 
that a factorization [2]_ of the basis matrix, rather than its inverse, 
is efficiently maintained and used to solve the linear systems at each 
iteration of the algorithm. 
 
.. versionadded:: 1.3.0 
 
References 
---------- 
.. [1] Bertsimas, Dimitris, and J. Tsitsiklis. &quot;Introduction to linear 
           programming.&quot; Athena Scientific 1 (1997): 997. 
.. [2] Bartels, Richard H. &quot;A stabilization of the simplex method.&quot; 
            Journal in  Numerische Mathematik 16.5 (1971): 414-434. 
 
&quot;&quot;&quot;</span>
<span class="s2"># Author: Matt Haberland</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">from </span><span class="s1">numpy.linalg </span><span class="s3">import </span><span class="s1">LinAlgError</span>

<span class="s3">from </span><span class="s1">scipy.linalg </span><span class="s3">import </span><span class="s1">solve</span>
<span class="s3">from </span><span class="s1">._optimize </span><span class="s3">import </span><span class="s1">_check_unknown_options</span>
<span class="s3">from </span><span class="s1">._bglu_dense </span><span class="s3">import </span><span class="s1">LU</span>
<span class="s3">from </span><span class="s1">._bglu_dense </span><span class="s3">import </span><span class="s1">BGLU </span><span class="s3">as </span><span class="s1">BGLU</span>
<span class="s3">from </span><span class="s1">._linprog_util </span><span class="s3">import </span><span class="s1">_postsolve</span>
<span class="s3">from </span><span class="s1">._optimize </span><span class="s3">import </span><span class="s1">OptimizeResult</span>


<span class="s3">def </span><span class="s1">_phase_one(A</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">x0</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">postsolve_args</span><span class="s3">, </span><span class="s1">maxiter</span><span class="s3">, </span><span class="s1">tol</span><span class="s3">, </span><span class="s1">disp</span><span class="s3">,</span>
               <span class="s1">maxupdate</span><span class="s3">, </span><span class="s1">mast</span><span class="s3">, </span><span class="s1">pivot):</span>
    <span class="s0">&quot;&quot;&quot; 
    The purpose of phase one is to find an initial basic feasible solution 
    (BFS) to the original problem. 
 
    Generates an auxiliary problem with a trivial BFS and an objective that 
    minimizes infeasibility of the original problem. Solves the auxiliary 
    problem using the main simplex routine (phase two). This either yields 
    a BFS to the original problem or determines that the original problem is 
    infeasible. If feasible, phase one detects redundant rows in the original 
    constraint matrix and removes them, then chooses additional indices as 
    necessary to complete a basis/BFS for the original problem. 
    &quot;&quot;&quot;</span>

    <span class="s1">m</span><span class="s3">, </span><span class="s1">n = A.shape</span>
    <span class="s1">status = </span><span class="s4">0</span>

    <span class="s2"># generate auxiliary problem to get initial BFS</span>
    <span class="s1">A</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">basis</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">status = _generate_auxiliary_problem(A</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">x0</span><span class="s3">, </span><span class="s1">tol)</span>

    <span class="s3">if </span><span class="s1">status == </span><span class="s4">6</span><span class="s1">:</span>
        <span class="s1">residual = c.dot(x)</span>
        <span class="s1">iter_k = </span><span class="s4">0</span>
        <span class="s3">return </span><span class="s1">x</span><span class="s3">, </span><span class="s1">basis</span><span class="s3">, </span><span class="s1">A</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">residual</span><span class="s3">, </span><span class="s1">status</span><span class="s3">, </span><span class="s1">iter_k</span>

    <span class="s2"># solve auxiliary problem</span>
    <span class="s1">phase_one_n = n</span>
    <span class="s1">iter_k = </span><span class="s4">0</span>
    <span class="s1">x</span><span class="s3">, </span><span class="s1">basis</span><span class="s3">, </span><span class="s1">status</span><span class="s3">, </span><span class="s1">iter_k = _phase_two(c</span><span class="s3">, </span><span class="s1">A</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">basis</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">,</span>
                                          <span class="s1">postsolve_args</span><span class="s3">,</span>
                                          <span class="s1">maxiter</span><span class="s3">, </span><span class="s1">tol</span><span class="s3">, </span><span class="s1">disp</span><span class="s3">,</span>
                                          <span class="s1">maxupdate</span><span class="s3">, </span><span class="s1">mast</span><span class="s3">, </span><span class="s1">pivot</span><span class="s3">,</span>
                                          <span class="s1">iter_k</span><span class="s3">, </span><span class="s1">phase_one_n)</span>

    <span class="s2"># check for infeasibility</span>
    <span class="s1">residual = c.dot(x)</span>
    <span class="s3">if </span><span class="s1">status == </span><span class="s4">0 </span><span class="s3">and </span><span class="s1">residual &gt; tol:</span>
        <span class="s1">status = </span><span class="s4">2</span>

    <span class="s2"># drive artificial variables out of basis</span>
    <span class="s2"># TODO: test redundant row removal better</span>
    <span class="s2"># TODO: make solve more efficient with BGLU? This could take a while.</span>
    <span class="s1">keep_rows = np.ones(m</span><span class="s3">, </span><span class="s1">dtype=bool)</span>
    <span class="s3">for </span><span class="s1">basis_column </span><span class="s3">in </span><span class="s1">basis[basis &gt;= n]:</span>
        <span class="s1">B = A[:</span><span class="s3">, </span><span class="s1">basis]</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">basis_finder = np.abs(solve(B</span><span class="s3">, </span><span class="s1">A))  </span><span class="s2"># inefficient</span>
            <span class="s1">pertinent_row = np.argmax(basis_finder[:</span><span class="s3">, </span><span class="s1">basis_column])</span>
            <span class="s1">eligible_columns = np.ones(n</span><span class="s3">, </span><span class="s1">dtype=bool)</span>
            <span class="s1">eligible_columns[basis[basis &lt; n]] = </span><span class="s4">0</span>
            <span class="s1">eligible_column_indices = np.where(eligible_columns)[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">index = np.argmax(basis_finder[:</span><span class="s3">, </span><span class="s1">:n]</span>
                              <span class="s1">[pertinent_row</span><span class="s3">, </span><span class="s1">eligible_columns])</span>
            <span class="s1">new_basis_column = eligible_column_indices[index]</span>
            <span class="s3">if </span><span class="s1">basis_finder[pertinent_row</span><span class="s3">, </span><span class="s1">new_basis_column] &lt; tol:</span>
                <span class="s1">keep_rows[pertinent_row] = </span><span class="s3">False</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">basis[basis == basis_column] = new_basis_column</span>
        <span class="s3">except </span><span class="s1">LinAlgError:</span>
            <span class="s1">status = </span><span class="s4">4</span>

    <span class="s2"># form solution to original problem</span>
    <span class="s1">A = A[keep_rows</span><span class="s3">, </span><span class="s1">:n]</span>
    <span class="s1">basis = basis[keep_rows]</span>
    <span class="s1">x = x[:n]</span>
    <span class="s1">m = A.shape[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s3">return </span><span class="s1">x</span><span class="s3">, </span><span class="s1">basis</span><span class="s3">, </span><span class="s1">A</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">residual</span><span class="s3">, </span><span class="s1">status</span><span class="s3">, </span><span class="s1">iter_k</span>


<span class="s3">def </span><span class="s1">_get_more_basis_columns(A</span><span class="s3">, </span><span class="s1">basis):</span>
    <span class="s0">&quot;&quot;&quot; 
    Called when the auxiliary problem terminates with artificial columns in 
    the basis, which must be removed and replaced with non-artificial 
    columns. Finds additional columns that do not make the matrix singular. 
    &quot;&quot;&quot;</span>
    <span class="s1">m</span><span class="s3">, </span><span class="s1">n = A.shape</span>

    <span class="s2"># options for inclusion are those that aren't already in the basis</span>
    <span class="s1">a = np.arange(m+n)</span>
    <span class="s1">bl = np.zeros(len(a)</span><span class="s3">, </span><span class="s1">dtype=bool)</span>
    <span class="s1">bl[basis] = </span><span class="s4">1</span>
    <span class="s1">options = a[~bl]</span>
    <span class="s1">options = options[options &lt; n]  </span><span class="s2"># and they have to be non-artificial</span>

    <span class="s2"># form basis matrix</span>
    <span class="s1">B = np.zeros((m</span><span class="s3">, </span><span class="s1">m))</span>
    <span class="s1">B[:</span><span class="s3">, </span><span class="s4">0</span><span class="s1">:len(basis)] = A[:</span><span class="s3">, </span><span class="s1">basis]</span>

    <span class="s3">if </span><span class="s1">(basis.size &gt; </span><span class="s4">0 </span><span class="s3">and</span>
            <span class="s1">np.linalg.matrix_rank(B[:</span><span class="s3">, </span><span class="s1">:len(basis)]) &lt; len(basis)):</span>
        <span class="s3">raise </span><span class="s1">Exception(</span><span class="s5">&quot;Basis has dependent columns&quot;</span><span class="s1">)</span>

    <span class="s1">rank = </span><span class="s4">0  </span><span class="s2"># just enter the loop</span>
    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(n):  </span><span class="s2"># somewhat arbitrary, but we need another way out</span>
        <span class="s2"># permute the options, and take as many as needed</span>
        <span class="s1">new_basis = np.random.permutation(options)[:m-len(basis)]</span>
        <span class="s1">B[:</span><span class="s3">, </span><span class="s1">len(basis):] = A[:</span><span class="s3">, </span><span class="s1">new_basis]  </span><span class="s2"># update the basis matrix</span>
        <span class="s1">rank = np.linalg.matrix_rank(B)      </span><span class="s2"># check the rank</span>
        <span class="s3">if </span><span class="s1">rank == m:</span>
            <span class="s3">break</span>

    <span class="s3">return </span><span class="s1">np.concatenate((basis</span><span class="s3">, </span><span class="s1">new_basis))</span>


<span class="s3">def </span><span class="s1">_generate_auxiliary_problem(A</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">x0</span><span class="s3">, </span><span class="s1">tol):</span>
    <span class="s0">&quot;&quot;&quot; 
    Modifies original problem to create an auxiliary problem with a trivial 
    initial basic feasible solution and an objective that minimizes 
    infeasibility in the original problem. 
 
    Conceptually, this is done by stacking an identity matrix on the right of 
    the original constraint matrix, adding artificial variables to correspond 
    with each of these new columns, and generating a cost vector that is all 
    zeros except for ones corresponding with each of the new variables. 
 
    A initial basic feasible solution is trivial: all variables are zero 
    except for the artificial variables, which are set equal to the 
    corresponding element of the right hand side `b`. 
 
    Runnning the simplex method on this auxiliary problem drives all of the 
    artificial variables - and thus the cost - to zero if the original problem 
    is feasible. The original problem is declared infeasible otherwise. 
 
    Much of the complexity below is to improve efficiency by using singleton 
    columns in the original problem where possible, thus generating artificial 
    variables only as necessary, and using an initial 'guess' basic feasible 
    solution. 
    &quot;&quot;&quot;</span>
    <span class="s1">status = </span><span class="s4">0</span>
    <span class="s1">m</span><span class="s3">, </span><span class="s1">n = A.shape</span>

    <span class="s3">if </span><span class="s1">x0 </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">x = x0</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">x = np.zeros(n)</span>

    <span class="s1">r = b - A@x  </span><span class="s2"># residual; this must be all zeros for feasibility</span>

    <span class="s1">A[r &lt; </span><span class="s4">0</span><span class="s1">] = -A[r &lt; </span><span class="s4">0</span><span class="s1">]  </span><span class="s2"># express problem with RHS positive for trivial BFS</span>
    <span class="s1">b[r &lt; </span><span class="s4">0</span><span class="s1">] = -b[r &lt; </span><span class="s4">0</span><span class="s1">]  </span><span class="s2"># to the auxiliary problem</span>
    <span class="s1">r[r &lt; </span><span class="s4">0</span><span class="s1">] *= -</span><span class="s4">1</span>

    <span class="s2"># Rows which we will need to find a trivial way to zero.</span>
    <span class="s2"># This should just be the rows where there is a nonzero residual.</span>
    <span class="s2"># But then we would not necessarily have a column singleton in every row.</span>
    <span class="s2"># This makes it difficult to find an initial basis.</span>
    <span class="s3">if </span><span class="s1">x0 </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">nonzero_constraints = np.arange(m)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">nonzero_constraints = np.where(r &gt; tol)[</span><span class="s4">0</span><span class="s1">]</span>

    <span class="s2"># these are (at least some of) the initial basis columns</span>
    <span class="s1">basis = np.where(np.abs(x) &gt; tol)[</span><span class="s4">0</span><span class="s1">]</span>

    <span class="s3">if </span><span class="s1">len(nonzero_constraints) == </span><span class="s4">0 </span><span class="s3">and </span><span class="s1">len(basis) &lt;= m:  </span><span class="s2"># already a BFS</span>
        <span class="s1">c = np.zeros(n)</span>
        <span class="s1">basis = _get_more_basis_columns(A</span><span class="s3">, </span><span class="s1">basis)</span>
        <span class="s3">return </span><span class="s1">A</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">basis</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">status</span>
    <span class="s3">elif </span><span class="s1">(len(nonzero_constraints) &gt; m - len(basis) </span><span class="s3">or</span>
          <span class="s1">np.any(x &lt; </span><span class="s4">0</span><span class="s1">)):  </span><span class="s2"># can't get trivial BFS</span>
        <span class="s1">c = np.zeros(n)</span>
        <span class="s1">status = </span><span class="s4">6</span>
        <span class="s3">return </span><span class="s1">A</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">basis</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">status</span>

    <span class="s2"># chooses existing columns appropriate for inclusion in initial basis</span>
    <span class="s1">cols</span><span class="s3">, </span><span class="s1">rows = _select_singleton_columns(A</span><span class="s3">, </span><span class="s1">r)</span>

    <span class="s2"># find the rows we need to zero that we _can_ zero with column singletons</span>
    <span class="s1">i_tofix = np.isin(rows</span><span class="s3">, </span><span class="s1">nonzero_constraints)</span>
    <span class="s2"># these columns can't already be in the basis, though</span>
    <span class="s2"># we are going to add them to the basis and change the corresponding x val</span>
    <span class="s1">i_notinbasis = np.logical_not(np.isin(cols</span><span class="s3">, </span><span class="s1">basis))</span>
    <span class="s1">i_fix_without_aux = np.logical_and(i_tofix</span><span class="s3">, </span><span class="s1">i_notinbasis)</span>
    <span class="s1">rows = rows[i_fix_without_aux]</span>
    <span class="s1">cols = cols[i_fix_without_aux]</span>

    <span class="s2"># indices of the rows we can only zero with auxiliary variable</span>
    <span class="s2"># these rows will get a one in each auxiliary column</span>
    <span class="s1">arows = nonzero_constraints[np.logical_not(</span>
                                <span class="s1">np.isin(nonzero_constraints</span><span class="s3">, </span><span class="s1">rows))]</span>
    <span class="s1">n_aux = len(arows)</span>
    <span class="s1">acols = n + np.arange(n_aux)          </span><span class="s2"># indices of auxiliary columns</span>

    <span class="s1">basis_ng = np.concatenate((cols</span><span class="s3">, </span><span class="s1">acols))   </span><span class="s2"># basis columns not from guess</span>
    <span class="s1">basis_ng_rows = np.concatenate((rows</span><span class="s3">, </span><span class="s1">arows))  </span><span class="s2"># rows we need to zero</span>

    <span class="s2"># add auxiliary singleton columns</span>
    <span class="s1">A = np.hstack((A</span><span class="s3">, </span><span class="s1">np.zeros((m</span><span class="s3">, </span><span class="s1">n_aux))))</span>
    <span class="s1">A[arows</span><span class="s3">, </span><span class="s1">acols] = </span><span class="s4">1</span>

    <span class="s2"># generate initial BFS</span>
    <span class="s1">x = np.concatenate((x</span><span class="s3">, </span><span class="s1">np.zeros(n_aux)))</span>
    <span class="s1">x[basis_ng] = r[basis_ng_rows]/A[basis_ng_rows</span><span class="s3">, </span><span class="s1">basis_ng]</span>

    <span class="s2"># generate costs to minimize infeasibility</span>
    <span class="s1">c = np.zeros(n_aux + n)</span>
    <span class="s1">c[acols] = </span><span class="s4">1</span>

    <span class="s2"># basis columns correspond with nonzeros in guess, those with column</span>
    <span class="s2"># singletons we used to zero remaining constraints, and any additional</span>
    <span class="s2"># columns to get a full set (m columns)</span>
    <span class="s1">basis = np.concatenate((basis</span><span class="s3">, </span><span class="s1">basis_ng))</span>
    <span class="s1">basis = _get_more_basis_columns(A</span><span class="s3">, </span><span class="s1">basis)  </span><span class="s2"># add columns as needed</span>

    <span class="s3">return </span><span class="s1">A</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">c</span><span class="s3">, </span><span class="s1">basis</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">status</span>


<span class="s3">def </span><span class="s1">_select_singleton_columns(A</span><span class="s3">, </span><span class="s1">b):</span>
    <span class="s0">&quot;&quot;&quot; 
    Finds singleton columns for which the singleton entry is of the same sign 
    as the right-hand side; these columns are eligible for inclusion in an 
    initial basis. Determines the rows in which the singleton entries are 
    located. For each of these rows, returns the indices of the one singleton 
    column and its corresponding row. 
    &quot;&quot;&quot;</span>
    <span class="s2"># find indices of all singleton columns and corresponding row indicies</span>
    <span class="s1">column_indices = np.nonzero(np.sum(np.abs(A) != </span><span class="s4">0</span><span class="s3">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">) == </span><span class="s4">1</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">columns = A[:</span><span class="s3">, </span><span class="s1">column_indices]          </span><span class="s2"># array of singleton columns</span>
    <span class="s1">row_indices = np.zeros(len(column_indices)</span><span class="s3">, </span><span class="s1">dtype=int)</span>
    <span class="s1">nonzero_rows</span><span class="s3">, </span><span class="s1">nonzero_columns = np.nonzero(columns)</span>
    <span class="s1">row_indices[nonzero_columns] = nonzero_rows   </span><span class="s2"># corresponding row indicies</span>

    <span class="s2"># keep only singletons with entries that have same sign as RHS</span>
    <span class="s2"># this is necessary because all elements of BFS must be non-negative</span>
    <span class="s1">same_sign = A[row_indices</span><span class="s3">, </span><span class="s1">column_indices]*b[row_indices] &gt;= </span><span class="s4">0</span>
    <span class="s1">column_indices = column_indices[same_sign][::-</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">row_indices = row_indices[same_sign][::-</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s2"># Reversing the order so that steps below select rightmost columns</span>
    <span class="s2"># for initial basis, which will tend to be slack variables. (If the</span>
    <span class="s2"># guess corresponds with a basic feasible solution but a constraint</span>
    <span class="s2"># is not satisfied with the corresponding slack variable zero, the slack</span>
    <span class="s2"># variable must be basic.)</span>

    <span class="s2"># for each row, keep rightmost singleton column with an entry in that row</span>
    <span class="s1">unique_row_indices</span><span class="s3">, </span><span class="s1">first_columns = np.unique(row_indices</span><span class="s3">,</span>
                                                  <span class="s1">return_index=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">column_indices[first_columns]</span><span class="s3">, </span><span class="s1">unique_row_indices</span>


<span class="s3">def </span><span class="s1">_find_nonzero_rows(A</span><span class="s3">, </span><span class="s1">tol):</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns logical array indicating the locations of rows with at least 
    one nonzero element. 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">np.any(np.abs(A) &gt; tol</span><span class="s3">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">_select_enter_pivot(c_hat</span><span class="s3">, </span><span class="s1">bl</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">rule=</span><span class="s5">&quot;bland&quot;</span><span class="s3">, </span><span class="s1">tol=</span><span class="s4">1e-12</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Selects a pivot to enter the basis. Currently Bland's rule - the smallest 
    index that has a negative reduced cost - is the default. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">rule.lower() == </span><span class="s5">&quot;mrc&quot;</span><span class="s1">:  </span><span class="s2"># index with minimum reduced cost</span>
        <span class="s3">return </span><span class="s1">a[~bl][np.argmin(c_hat)]</span>
    <span class="s3">else</span><span class="s1">:  </span><span class="s2"># smallest index w/ negative reduced cost</span>
        <span class="s3">return </span><span class="s1">a[~bl][c_hat &lt; -tol][</span><span class="s4">0</span><span class="s1">]</span>


<span class="s3">def </span><span class="s1">_display_iter(phase</span><span class="s3">, </span><span class="s1">iteration</span><span class="s3">, </span><span class="s1">slack</span><span class="s3">, </span><span class="s1">con</span><span class="s3">, </span><span class="s1">fun):</span>
    <span class="s0">&quot;&quot;&quot; 
    Print indicators of optimization status to the console. 
    &quot;&quot;&quot;</span>
    <span class="s1">header = </span><span class="s3">True if not </span><span class="s1">iteration % </span><span class="s4">20 </span><span class="s3">else False</span>

    <span class="s3">if </span><span class="s1">header:</span>
        <span class="s1">print(</span><span class="s5">&quot;Phase&quot;</span><span class="s3">,</span>
              <span class="s5">&quot;Iteration&quot;</span><span class="s3">,</span>
              <span class="s5">&quot;Minimum Slack      &quot;</span><span class="s3">,</span>
              <span class="s5">&quot;Constraint Residual&quot;</span><span class="s3">,</span>
              <span class="s5">&quot;Objective          &quot;</span><span class="s1">)</span>

    <span class="s2"># :&lt;X.Y left aligns Y digits in X digit spaces</span>
    <span class="s1">fmt = </span><span class="s5">'{0:&lt;6}{1:&lt;10}{2:&lt;20.13}{3:&lt;20.13}{4:&lt;20.13}'</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s1">slack = np.min(slack)</span>
    <span class="s3">except </span><span class="s1">ValueError:</span>
        <span class="s1">slack = </span><span class="s5">&quot;NA&quot;</span>
    <span class="s1">print(fmt.format(phase</span><span class="s3">, </span><span class="s1">iteration</span><span class="s3">, </span><span class="s1">slack</span><span class="s3">, </span><span class="s1">np.linalg.norm(con)</span><span class="s3">, </span><span class="s1">fun))</span>


<span class="s3">def </span><span class="s1">_display_and_callback(phase_one_n</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">postsolve_args</span><span class="s3">, </span><span class="s1">status</span><span class="s3">,</span>
                          <span class="s1">iteration</span><span class="s3">, </span><span class="s1">disp</span><span class="s3">, </span><span class="s1">callback):</span>
    <span class="s3">if </span><span class="s1">phase_one_n </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">phase = </span><span class="s4">1</span>
        <span class="s1">x_postsolve = x[:phase_one_n]</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">phase = </span><span class="s4">2</span>
        <span class="s1">x_postsolve = x</span>
    <span class="s1">x_o</span><span class="s3">, </span><span class="s1">fun</span><span class="s3">, </span><span class="s1">slack</span><span class="s3">, </span><span class="s1">con = _postsolve(x_postsolve</span><span class="s3">,</span>
                                      <span class="s1">postsolve_args)</span>

    <span class="s3">if </span><span class="s1">callback </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">res = OptimizeResult({</span><span class="s5">'x'</span><span class="s1">: x_o</span><span class="s3">, </span><span class="s5">'fun'</span><span class="s1">: fun</span><span class="s3">, </span><span class="s5">'slack'</span><span class="s1">: slack</span><span class="s3">,</span>
                              <span class="s5">'con'</span><span class="s1">: con</span><span class="s3">, </span><span class="s5">'nit'</span><span class="s1">: iteration</span><span class="s3">,</span>
                              <span class="s5">'phase'</span><span class="s1">: phase</span><span class="s3">, </span><span class="s5">'complete'</span><span class="s1">: </span><span class="s3">False,</span>
                              <span class="s5">'status'</span><span class="s1">: status</span><span class="s3">, </span><span class="s5">'message'</span><span class="s1">: </span><span class="s5">&quot;&quot;</span><span class="s3">,</span>
                              <span class="s5">'success'</span><span class="s1">: </span><span class="s3">False</span><span class="s1">})</span>
        <span class="s1">callback(res)</span>
    <span class="s3">if </span><span class="s1">disp:</span>
        <span class="s1">_display_iter(phase</span><span class="s3">, </span><span class="s1">iteration</span><span class="s3">, </span><span class="s1">slack</span><span class="s3">, </span><span class="s1">con</span><span class="s3">, </span><span class="s1">fun)</span>


<span class="s3">def </span><span class="s1">_phase_two(c</span><span class="s3">, </span><span class="s1">A</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">postsolve_args</span><span class="s3">, </span><span class="s1">maxiter</span><span class="s3">, </span><span class="s1">tol</span><span class="s3">, </span><span class="s1">disp</span><span class="s3">,</span>
               <span class="s1">maxupdate</span><span class="s3">, </span><span class="s1">mast</span><span class="s3">, </span><span class="s1">pivot</span><span class="s3">, </span><span class="s1">iteration=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">phase_one_n=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    The heart of the simplex method. Beginning with a basic feasible solution, 
    moves to adjacent basic feasible solutions successively lower reduced cost. 
    Terminates when there are no basic feasible solutions with lower reduced 
    cost or if the problem is determined to be unbounded. 
 
    This implementation follows the revised simplex method based on LU 
    decomposition. Rather than maintaining a tableau or an inverse of the 
    basis matrix, we keep a factorization of the basis matrix that allows 
    efficient solution of linear systems while avoiding stability issues 
    associated with inverted matrices. 
    &quot;&quot;&quot;</span>
    <span class="s1">m</span><span class="s3">, </span><span class="s1">n = A.shape</span>
    <span class="s1">status = </span><span class="s4">0</span>
    <span class="s1">a = np.arange(n)                    </span><span class="s2"># indices of columns of A</span>
    <span class="s1">ab = np.arange(m)                   </span><span class="s2"># indices of columns of B</span>
    <span class="s3">if </span><span class="s1">maxupdate:</span>
        <span class="s2"># basis matrix factorization object; similar to B = A[:, b]</span>
        <span class="s1">B = BGLU(A</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">maxupdate</span><span class="s3">, </span><span class="s1">mast)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">B = LU(A</span><span class="s3">, </span><span class="s1">b)</span>

    <span class="s3">for </span><span class="s1">iteration </span><span class="s3">in </span><span class="s1">range(iteration</span><span class="s3">, </span><span class="s1">maxiter):</span>

        <span class="s3">if </span><span class="s1">disp </span><span class="s3">or </span><span class="s1">callback </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">_display_and_callback(phase_one_n</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">postsolve_args</span><span class="s3">, </span><span class="s1">status</span><span class="s3">,</span>
                                  <span class="s1">iteration</span><span class="s3">, </span><span class="s1">disp</span><span class="s3">, </span><span class="s1">callback)</span>

        <span class="s1">bl = np.zeros(len(a)</span><span class="s3">, </span><span class="s1">dtype=bool)</span>
        <span class="s1">bl[b] = </span><span class="s4">1</span>

        <span class="s1">xb = x[b]       </span><span class="s2"># basic variables</span>
        <span class="s1">cb = c[b]       </span><span class="s2"># basic costs</span>

        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">v = B.solve(cb</span><span class="s3">, </span><span class="s1">transposed=</span><span class="s3">True</span><span class="s1">)    </span><span class="s2"># similar to v = solve(B.T, cb)</span>
        <span class="s3">except </span><span class="s1">LinAlgError:</span>
            <span class="s1">status = </span><span class="s4">4</span>
            <span class="s3">break</span>

        <span class="s2"># TODO: cythonize?</span>
        <span class="s1">c_hat = c - v.dot(A)    </span><span class="s2"># reduced cost</span>
        <span class="s1">c_hat = c_hat[~bl]</span>
        <span class="s2"># Above is much faster than:</span>
        <span class="s2"># N = A[:, ~bl]                 # slow!</span>
        <span class="s2"># c_hat = c[~bl] - v.T.dot(N)</span>
        <span class="s2"># Can we perform the multiplication only on the nonbasic columns?</span>

        <span class="s3">if </span><span class="s1">np.all(c_hat &gt;= -tol):  </span><span class="s2"># all reduced costs positive -&gt; terminate</span>
            <span class="s3">break</span>

        <span class="s1">j = _select_enter_pivot(c_hat</span><span class="s3">, </span><span class="s1">bl</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">rule=pivot</span><span class="s3">, </span><span class="s1">tol=tol)</span>
        <span class="s1">u = B.solve(A[:</span><span class="s3">, </span><span class="s1">j])        </span><span class="s2"># similar to u = solve(B, A[:, j])</span>

        <span class="s1">i = u &gt; tol                 </span><span class="s2"># if none of the u are positive, unbounded</span>
        <span class="s3">if not </span><span class="s1">np.any(i):</span>
            <span class="s1">status = </span><span class="s4">3</span>
            <span class="s3">break</span>

        <span class="s1">th = xb[i]/u[i]</span>
        <span class="s1">l = np.argmin(th)           </span><span class="s2"># implicitly selects smallest subscript</span>
        <span class="s1">th_star = th[l]             </span><span class="s2"># step size</span>

        <span class="s1">x[b] = x[b] - th_star*u     </span><span class="s2"># take step</span>
        <span class="s1">x[j] = th_star</span>
        <span class="s1">B.update(ab[i][l]</span><span class="s3">, </span><span class="s1">j)       </span><span class="s2"># modify basis</span>
        <span class="s1">b = B.b                     </span><span class="s2"># similar to b[ab[i][l]] =</span>

    <span class="s3">else</span><span class="s1">:</span>
        <span class="s2"># If the end of the for loop is reached (without a break statement),</span>
        <span class="s2"># then another step has been taken, so the iteration counter should</span>
        <span class="s2"># increment, info should be displayed, and callback should be called.</span>
        <span class="s1">iteration += </span><span class="s4">1</span>
        <span class="s1">status = </span><span class="s4">1</span>
        <span class="s3">if </span><span class="s1">disp </span><span class="s3">or </span><span class="s1">callback </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">_display_and_callback(phase_one_n</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">postsolve_args</span><span class="s3">, </span><span class="s1">status</span><span class="s3">,</span>
                                  <span class="s1">iteration</span><span class="s3">, </span><span class="s1">disp</span><span class="s3">, </span><span class="s1">callback)</span>

    <span class="s3">return </span><span class="s1">x</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">status</span><span class="s3">, </span><span class="s1">iteration</span>


<span class="s3">def </span><span class="s1">_linprog_rs(c</span><span class="s3">, </span><span class="s1">c0</span><span class="s3">, </span><span class="s1">A</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">x0</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">postsolve_args</span><span class="s3">,</span>
                <span class="s1">maxiter=</span><span class="s4">5000</span><span class="s3">, </span><span class="s1">tol=</span><span class="s4">1e-12</span><span class="s3">, </span><span class="s1">disp=</span><span class="s3">False,</span>
                <span class="s1">maxupdate=</span><span class="s4">10</span><span class="s3">, </span><span class="s1">mast=</span><span class="s3">False, </span><span class="s1">pivot=</span><span class="s5">&quot;mrc&quot;</span><span class="s3">,</span>
                <span class="s1">**unknown_options):</span>
    <span class="s0">&quot;&quot;&quot; 
    Solve the following linear programming problem via a two-phase 
    revised simplex algorithm.:: 
 
        minimize:     c @ x 
 
        subject to:  A @ x == b 
                     0 &lt;= x &lt; oo 
 
    User-facing documentation is in _linprog_doc.py. 
 
    Parameters 
    ---------- 
    c : 1-D array 
        Coefficients of the linear objective function to be minimized. 
    c0 : float 
        Constant term in objective function due to fixed (and eliminated) 
        variables. (Currently unused.) 
    A : 2-D array 
        2-D array which, when matrix-multiplied by ``x``, gives the values of 
        the equality constraints at ``x``. 
    b : 1-D array 
        1-D array of values representing the RHS of each equality constraint 
        (row) in ``A_eq``. 
    x0 : 1-D array, optional 
        Starting values of the independent variables, which will be refined by 
        the optimization algorithm. For the revised simplex method, these must 
        correspond with a basic feasible solution. 
    callback : callable, optional 
        If a callback function is provided, it will be called within each 
        iteration of the algorithm. The callback function must accept a single 
        `scipy.optimize.OptimizeResult` consisting of the following fields: 
 
            x : 1-D array 
                Current solution vector. 
            fun : float 
                Current value of the objective function ``c @ x``. 
            success : bool 
                True only when an algorithm has completed successfully, 
                so this is always False as the callback function is called 
                only while the algorithm is still iterating. 
            slack : 1-D array 
                The values of the slack variables. Each slack variable 
                corresponds to an inequality constraint. If the slack is zero, 
                the corresponding constraint is active. 
            con : 1-D array 
                The (nominally zero) residuals of the equality constraints, 
                that is, ``b - A_eq @ x``. 
            phase : int 
                The phase of the algorithm being executed. 
            status : int 
                For revised simplex, this is always 0 because if a different 
                status is detected, the algorithm terminates. 
            nit : int 
                The number of iterations performed. 
            message : str 
                A string descriptor of the exit status of the optimization. 
    postsolve_args : tuple 
        Data needed by _postsolve to convert the solution to the standard-form 
        problem into the solution to the original problem. 
 
    Options 
    ------- 
    maxiter : int 
       The maximum number of iterations to perform in either phase. 
    tol : float 
        The tolerance which determines when a solution is &quot;close enough&quot; to 
        zero in Phase 1 to be considered a basic feasible solution or close 
        enough to positive to serve as an optimal solution. 
    disp : bool 
        Set to ``True`` if indicators of optimization status are to be printed 
        to the console each iteration. 
    maxupdate : int 
        The maximum number of updates performed on the LU factorization. 
        After this many updates is reached, the basis matrix is factorized 
        from scratch. 
    mast : bool 
        Minimize Amortized Solve Time. If enabled, the average time to solve 
        a linear system using the basis factorization is measured. Typically, 
        the average solve time will decrease with each successive solve after 
        initial factorization, as factorization takes much more time than the 
        solve operation (and updates). Eventually, however, the updated 
        factorization becomes sufficiently complex that the average solve time 
        begins to increase. When this is detected, the basis is refactorized 
        from scratch. Enable this option to maximize speed at the risk of 
        nondeterministic behavior. Ignored if ``maxupdate`` is 0. 
    pivot : &quot;mrc&quot; or &quot;bland&quot; 
        Pivot rule: Minimum Reduced Cost (default) or Bland's rule. Choose 
        Bland's rule if iteration limit is reached and cycling is suspected. 
    unknown_options : dict 
        Optional arguments not used by this particular solver. If 
        `unknown_options` is non-empty a warning is issued listing all 
        unused options. 
 
    Returns 
    ------- 
    x : 1-D array 
        Solution vector. 
    status : int 
        An integer representing the exit status of the optimization:: 
 
         0 : Optimization terminated successfully 
         1 : Iteration limit reached 
         2 : Problem appears to be infeasible 
         3 : Problem appears to be unbounded 
         4 : Numerical difficulties encountered 
         5 : No constraints; turn presolve on 
         6 : Guess x0 cannot be converted to a basic feasible solution 
 
    message : str 
        A string descriptor of the exit status of the optimization. 
    iteration : int 
        The number of iterations taken to solve the problem. 
    &quot;&quot;&quot;</span>

    <span class="s1">_check_unknown_options(unknown_options)</span>

    <span class="s1">messages = [</span><span class="s5">&quot;Optimization terminated successfully.&quot;</span><span class="s3">,</span>
                <span class="s5">&quot;Iteration limit reached.&quot;</span><span class="s3">,</span>
                <span class="s5">&quot;The problem appears infeasible, as the phase one auxiliary &quot;</span>
                <span class="s5">&quot;problem terminated successfully with a residual of {0:.1e}, &quot;</span>
                <span class="s5">&quot;greater than the tolerance {1} required for the solution to &quot;</span>
                <span class="s5">&quot;be considered feasible. Consider increasing the tolerance to &quot;</span>
                <span class="s5">&quot;be greater than {0:.1e}. If this tolerance is unnaceptably &quot;</span>
                <span class="s5">&quot;large, the problem is likely infeasible.&quot;</span><span class="s3">,</span>
                <span class="s5">&quot;The problem is unbounded, as the simplex algorithm found &quot;</span>
                <span class="s5">&quot;a basic feasible solution from which there is a direction &quot;</span>
                <span class="s5">&quot;with negative reduced cost in which all decision variables &quot;</span>
                <span class="s5">&quot;increase.&quot;</span><span class="s3">,</span>
                <span class="s5">&quot;Numerical difficulties encountered; consider trying &quot;</span>
                <span class="s5">&quot;method='interior-point'.&quot;</span><span class="s3">,</span>
                <span class="s5">&quot;Problems with no constraints are trivially solved; please &quot;</span>
                <span class="s5">&quot;turn presolve on.&quot;</span><span class="s3">,</span>
                <span class="s5">&quot;The guess x0 cannot be converted to a basic feasible &quot;</span>
                <span class="s5">&quot;solution. &quot;</span>
                <span class="s1">]</span>

    <span class="s3">if </span><span class="s1">A.size == </span><span class="s4">0</span><span class="s1">:  </span><span class="s2"># address test_unbounded_below_no_presolve_corrected</span>
        <span class="s3">return </span><span class="s1">np.zeros(c.shape)</span><span class="s3">, </span><span class="s4">5</span><span class="s3">, </span><span class="s1">messages[</span><span class="s4">5</span><span class="s1">]</span><span class="s3">, </span><span class="s4">0</span>

    <span class="s1">x</span><span class="s3">, </span><span class="s1">basis</span><span class="s3">, </span><span class="s1">A</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">residual</span><span class="s3">, </span><span class="s1">status</span><span class="s3">, </span><span class="s1">iteration = (</span>
        <span class="s1">_phase_one(A</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">x0</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">, </span><span class="s1">postsolve_args</span><span class="s3">,</span>
                   <span class="s1">maxiter</span><span class="s3">, </span><span class="s1">tol</span><span class="s3">, </span><span class="s1">disp</span><span class="s3">, </span><span class="s1">maxupdate</span><span class="s3">, </span><span class="s1">mast</span><span class="s3">, </span><span class="s1">pivot))</span>

    <span class="s3">if </span><span class="s1">status == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">x</span><span class="s3">, </span><span class="s1">basis</span><span class="s3">, </span><span class="s1">status</span><span class="s3">, </span><span class="s1">iteration = _phase_two(c</span><span class="s3">, </span><span class="s1">A</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">basis</span><span class="s3">, </span><span class="s1">callback</span><span class="s3">,</span>
                                                 <span class="s1">postsolve_args</span><span class="s3">,</span>
                                                 <span class="s1">maxiter</span><span class="s3">, </span><span class="s1">tol</span><span class="s3">, </span><span class="s1">disp</span><span class="s3">,</span>
                                                 <span class="s1">maxupdate</span><span class="s3">, </span><span class="s1">mast</span><span class="s3">, </span><span class="s1">pivot</span><span class="s3">,</span>
                                                 <span class="s1">iteration)</span>

    <span class="s3">return </span><span class="s1">x</span><span class="s3">, </span><span class="s1">status</span><span class="s3">, </span><span class="s1">messages[status].format(residual</span><span class="s3">, </span><span class="s1">tol)</span><span class="s3">, </span><span class="s1">iteration</span>
</pre>
</body>
</html>