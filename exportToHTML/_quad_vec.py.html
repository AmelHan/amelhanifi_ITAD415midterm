<html>
<head>
<title>_quad_vec.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_quad_vec.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">copy</span>
<span class="s0">import </span><span class="s1">heapq</span>
<span class="s0">import </span><span class="s1">collections</span>
<span class="s0">import </span><span class="s1">functools</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">from </span><span class="s1">scipy._lib._util </span><span class="s0">import </span><span class="s1">MapWrapper</span><span class="s0">, </span><span class="s1">_FunctionWrapper</span>


<span class="s0">class </span><span class="s1">LRUDict(collections.OrderedDict):</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">max_size):</span>
        <span class="s1">self.__max_size = max_size</span>

    <span class="s0">def </span><span class="s1">__setitem__(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s1">existing_key = (key </span><span class="s0">in </span><span class="s1">self)</span>
        <span class="s1">super().__setitem__(key</span><span class="s0">, </span><span class="s1">value)</span>
        <span class="s0">if </span><span class="s1">existing_key:</span>
            <span class="s1">self.move_to_end(key)</span>
        <span class="s0">elif </span><span class="s1">len(self) &gt; self.__max_size:</span>
            <span class="s1">self.popitem(last=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">update(self</span><span class="s0">, </span><span class="s1">other):</span>
        <span class="s2"># Not needed below</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError()</span>


<span class="s0">class </span><span class="s1">SemiInfiniteFunc:</span>
    <span class="s3">&quot;&quot;&quot; 
    Argument transform from (start, +-oo) to (0, 1) 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">start</span><span class="s0">, </span><span class="s1">infty):</span>
        <span class="s1">self._func = func</span>
        <span class="s1">self._start = start</span>
        <span class="s1">self._sgn = -</span><span class="s4">1 </span><span class="s0">if </span><span class="s1">infty &lt; </span><span class="s4">0 </span><span class="s0">else </span><span class="s4">1</span>

        <span class="s2"># Overflow threshold for the 1/t**2 factor</span>
        <span class="s1">self._tmin = sys.float_info.min**</span><span class="s4">0.5</span>

    <span class="s0">def </span><span class="s1">get_t(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s1">z = self._sgn * (x - self._start) + </span><span class="s4">1</span>
        <span class="s0">if </span><span class="s1">z == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s2"># Can happen only if point not in range</span>
            <span class="s0">return </span><span class="s1">np.inf</span>
        <span class="s0">return </span><span class="s4">1 </span><span class="s1">/ z</span>

    <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">t):</span>
        <span class="s0">if </span><span class="s1">t &lt; self._tmin:</span>
            <span class="s0">return </span><span class="s4">0.0</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">x = self._start + self._sgn * (</span><span class="s4">1 </span><span class="s1">- t) / t</span>
            <span class="s1">f = self._func(x)</span>
            <span class="s0">return </span><span class="s1">self._sgn * (f / t) / t</span>


<span class="s0">class </span><span class="s1">DoubleInfiniteFunc:</span>
    <span class="s3">&quot;&quot;&quot; 
    Argument transform from (-oo, oo) to (-1, 1) 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">func):</span>
        <span class="s1">self._func = func</span>

        <span class="s2"># Overflow threshold for the 1/t**2 factor</span>
        <span class="s1">self._tmin = sys.float_info.min**</span><span class="s4">0.5</span>

    <span class="s0">def </span><span class="s1">get_t(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s1">s = -</span><span class="s4">1 </span><span class="s0">if </span><span class="s1">x &lt; </span><span class="s4">0 </span><span class="s0">else </span><span class="s4">1</span>
        <span class="s0">return </span><span class="s1">s / (abs(x) + </span><span class="s4">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">t):</span>
        <span class="s0">if </span><span class="s1">abs(t) &lt; self._tmin:</span>
            <span class="s0">return </span><span class="s4">0.0</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">x = (</span><span class="s4">1 </span><span class="s1">- abs(t)) / t</span>
            <span class="s1">f = self._func(x)</span>
            <span class="s0">return </span><span class="s1">(f / t) / t</span>


<span class="s0">def </span><span class="s1">_max_norm(x):</span>
    <span class="s0">return </span><span class="s1">np.amax(abs(x))</span>


<span class="s0">def </span><span class="s1">_get_sizeof(obj):</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">sys.getsizeof(obj)</span>
    <span class="s0">except </span><span class="s1">TypeError:</span>
        <span class="s2"># occurs on pypy</span>
        <span class="s0">if </span><span class="s1">hasattr(obj</span><span class="s0">, </span><span class="s5">'__sizeof__'</span><span class="s1">):</span>
            <span class="s0">return </span><span class="s1">int(obj.__sizeof__())</span>
        <span class="s0">return </span><span class="s4">64</span>


<span class="s0">class </span><span class="s1">_Bunch:</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">self.__keys = kwargs.keys()</span>
        <span class="s1">self.__dict__.update(**kwargs)</span>

    <span class="s0">def </span><span class="s1">__repr__(self):</span>
        <span class="s0">return </span><span class="s5">&quot;_Bunch({})&quot;</span><span class="s1">.format(</span><span class="s5">&quot;, &quot;</span><span class="s1">.join(</span><span class="s5">f&quot;</span><span class="s0">{</span><span class="s1">k</span><span class="s0">}</span><span class="s5">=</span><span class="s0">{</span><span class="s1">repr(self.__dict__[k])</span><span class="s0">}</span><span class="s5">&quot;</span>
                                             <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">self.__keys))</span>


<span class="s0">def </span><span class="s1">quad_vec(f</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">epsabs=</span><span class="s4">1e-200</span><span class="s0">, </span><span class="s1">epsrel=</span><span class="s4">1e-8</span><span class="s0">, </span><span class="s1">norm=</span><span class="s5">'2'</span><span class="s0">, </span><span class="s1">cache_size=</span><span class="s4">100e6</span><span class="s0">, </span><span class="s1">limit=</span><span class="s4">10000</span><span class="s0">,</span>
             <span class="s1">workers=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">points=</span><span class="s0">None, </span><span class="s1">quadrature=</span><span class="s0">None, </span><span class="s1">full_output=</span><span class="s0">False,</span>
             <span class="s1">*</span><span class="s0">, </span><span class="s1">args=()):</span>
    <span class="s3">r&quot;&quot;&quot;Adaptive integration of a vector-valued function. 
 
    Parameters 
    ---------- 
    f : callable 
        Vector-valued function f(x) to integrate. 
    a : float 
        Initial point. 
    b : float 
        Final point. 
    epsabs : float, optional 
        Absolute tolerance. 
    epsrel : float, optional 
        Relative tolerance. 
    norm : {'max', '2'}, optional 
        Vector norm to use for error estimation. 
    cache_size : int, optional 
        Number of bytes to use for memoization. 
    limit : float or int, optional 
        An upper bound on the number of subintervals used in the adaptive 
        algorithm. 
    workers : int or map-like callable, optional 
        If `workers` is an integer, part of the computation is done in 
        parallel subdivided to this many tasks (using 
        :class:`python:multiprocessing.pool.Pool`). 
        Supply `-1` to use all cores available to the Process. 
        Alternatively, supply a map-like callable, such as 
        :meth:`python:multiprocessing.pool.Pool.map` for evaluating the 
        population in parallel. 
        This evaluation is carried out as ``workers(func, iterable)``. 
    points : list, optional 
        List of additional breakpoints. 
    quadrature : {'gk21', 'gk15', 'trapezoid'}, optional 
        Quadrature rule to use on subintervals. 
        Options: 'gk21' (Gauss-Kronrod 21-point rule), 
        'gk15' (Gauss-Kronrod 15-point rule), 
        'trapezoid' (composite trapezoid rule). 
        Default: 'gk21' for finite intervals and 'gk15' for (semi-)infinite 
    full_output : bool, optional 
        Return an additional ``info`` dictionary. 
    args : tuple, optional 
        Extra arguments to pass to function, if any. 
 
        .. versionadded:: 1.8.0 
 
    Returns 
    ------- 
    res : {float, array-like} 
        Estimate for the result 
    err : float 
        Error estimate for the result in the given norm 
    info : dict 
        Returned only when ``full_output=True``. 
        Info dictionary. Is an object with the attributes: 
 
            success : bool 
                Whether integration reached target precision. 
            status : int 
                Indicator for convergence, success (0), 
                failure (1), and failure due to rounding error (2). 
            neval : int 
                Number of function evaluations. 
            intervals : ndarray, shape (num_intervals, 2) 
                Start and end points of subdivision intervals. 
            integrals : ndarray, shape (num_intervals, ...) 
                Integral for each interval. 
                Note that at most ``cache_size`` values are recorded, 
                and the array may contains *nan* for missing items. 
            errors : ndarray, shape (num_intervals,) 
                Estimated integration error for each interval. 
 
    Notes 
    ----- 
    The algorithm mainly follows the implementation of QUADPACK's 
    DQAG* algorithms, implementing global error control and adaptive 
    subdivision. 
 
    The algorithm here has some differences to the QUADPACK approach: 
 
    Instead of subdividing one interval at a time, the algorithm 
    subdivides N intervals with largest errors at once. This enables 
    (partial) parallelization of the integration. 
 
    The logic of subdividing &quot;next largest&quot; intervals first is then 
    not implemented, and we rely on the above extension to avoid 
    concentrating on &quot;small&quot; intervals only. 
 
    The Wynn epsilon table extrapolation is not used (QUADPACK uses it 
    for infinite intervals). This is because the algorithm here is 
    supposed to work on vector-valued functions, in an user-specified 
    norm, and the extension of the epsilon algorithm to this case does 
    not appear to be widely agreed. For max-norm, using elementwise 
    Wynn epsilon could be possible, but we do not do this here with 
    the hope that the epsilon extrapolation is mainly useful in 
    special cases. 
 
    References 
    ---------- 
    [1] R. Piessens, E. de Doncker, QUADPACK (1983). 
 
    Examples 
    -------- 
    We can compute integrations of a vector-valued function: 
 
    &gt;&gt;&gt; from scipy.integrate import quad_vec 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; alpha = np.linspace(0.0, 2.0, num=30) 
    &gt;&gt;&gt; f = lambda x: x**alpha 
    &gt;&gt;&gt; x0, x1 = 0, 2 
    &gt;&gt;&gt; y, err = quad_vec(f, x0, x1) 
    &gt;&gt;&gt; plt.plot(alpha, y) 
    &gt;&gt;&gt; plt.xlabel(r&quot;$\alpha$&quot;) 
    &gt;&gt;&gt; plt.ylabel(r&quot;$\int_{0}^{2} x^\alpha dx$&quot;) 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a = float(a)</span>
    <span class="s1">b = float(b)</span>

    <span class="s0">if </span><span class="s1">args:</span>
        <span class="s0">if not </span><span class="s1">isinstance(args</span><span class="s0">, </span><span class="s1">tuple):</span>
            <span class="s1">args = (args</span><span class="s0">,</span><span class="s1">)</span>

        <span class="s2"># create a wrapped function to allow the use of map and Pool.map</span>
        <span class="s1">f = _FunctionWrapper(f</span><span class="s0">, </span><span class="s1">args)</span>

    <span class="s2"># Use simple transformations to deal with integrals over infinite</span>
    <span class="s2"># intervals.</span>
    <span class="s1">kwargs = dict(epsabs=epsabs</span><span class="s0">,</span>
                  <span class="s1">epsrel=epsrel</span><span class="s0">,</span>
                  <span class="s1">norm=norm</span><span class="s0">,</span>
                  <span class="s1">cache_size=cache_size</span><span class="s0">,</span>
                  <span class="s1">limit=limit</span><span class="s0">,</span>
                  <span class="s1">workers=workers</span><span class="s0">,</span>
                  <span class="s1">points=points</span><span class="s0">,</span>
                  <span class="s1">quadrature=</span><span class="s5">'gk15' </span><span class="s0">if </span><span class="s1">quadrature </span><span class="s0">is None else </span><span class="s1">quadrature</span><span class="s0">,</span>
                  <span class="s1">full_output=full_output)</span>
    <span class="s0">if </span><span class="s1">np.isfinite(a) </span><span class="s0">and </span><span class="s1">np.isinf(b):</span>
        <span class="s1">f2 = SemiInfiniteFunc(f</span><span class="s0">, </span><span class="s1">start=a</span><span class="s0">, </span><span class="s1">infty=b)</span>
        <span class="s0">if </span><span class="s1">points </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">kwargs[</span><span class="s5">'points'</span><span class="s1">] = tuple(f2.get_t(xp) </span><span class="s0">for </span><span class="s1">xp </span><span class="s0">in </span><span class="s1">points)</span>
        <span class="s0">return </span><span class="s1">quad_vec(f2</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s0">elif </span><span class="s1">np.isfinite(b) </span><span class="s0">and </span><span class="s1">np.isinf(a):</span>
        <span class="s1">f2 = SemiInfiniteFunc(f</span><span class="s0">, </span><span class="s1">start=b</span><span class="s0">, </span><span class="s1">infty=a)</span>
        <span class="s0">if </span><span class="s1">points </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">kwargs[</span><span class="s5">'points'</span><span class="s1">] = tuple(f2.get_t(xp) </span><span class="s0">for </span><span class="s1">xp </span><span class="s0">in </span><span class="s1">points)</span>
        <span class="s1">res = quad_vec(f2</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">return </span><span class="s1">(-res[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">,</span><span class="s1">) + res[</span><span class="s4">1</span><span class="s1">:]</span>
    <span class="s0">elif </span><span class="s1">np.isinf(a) </span><span class="s0">and </span><span class="s1">np.isinf(b):</span>
        <span class="s1">sgn = -</span><span class="s4">1 </span><span class="s0">if </span><span class="s1">b &lt; a </span><span class="s0">else </span><span class="s4">1</span>

        <span class="s2"># NB. explicitly split integral at t=0, which separates</span>
        <span class="s2"># the positive and negative sides</span>
        <span class="s1">f2 = DoubleInfiniteFunc(f)</span>
        <span class="s0">if </span><span class="s1">points </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">kwargs[</span><span class="s5">'points'</span><span class="s1">] = (</span><span class="s4">0</span><span class="s0">,</span><span class="s1">) + tuple(f2.get_t(xp) </span><span class="s0">for </span><span class="s1">xp </span><span class="s0">in </span><span class="s1">points)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">kwargs[</span><span class="s5">'points'</span><span class="s1">] = (</span><span class="s4">0</span><span class="s0">,</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">a != b:</span>
            <span class="s1">res = quad_vec(f2</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">res = quad_vec(f2</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s1">**kwargs)</span>

        <span class="s0">return </span><span class="s1">(res[</span><span class="s4">0</span><span class="s1">]*sgn</span><span class="s0">,</span><span class="s1">) + res[</span><span class="s4">1</span><span class="s1">:]</span>
    <span class="s0">elif not </span><span class="s1">(np.isfinite(a) </span><span class="s0">and </span><span class="s1">np.isfinite(b)):</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s5">f&quot;invalid integration bounds a=</span><span class="s0">{</span><span class="s1">a</span><span class="s0">}</span><span class="s5">, b=</span><span class="s0">{</span><span class="s1">b</span><span class="s0">}</span><span class="s5">&quot;</span><span class="s1">)</span>

    <span class="s1">norm_funcs = {</span>
        <span class="s0">None</span><span class="s1">: _max_norm</span><span class="s0">,</span>
        <span class="s5">'max'</span><span class="s1">: _max_norm</span><span class="s0">,</span>
        <span class="s5">'2'</span><span class="s1">: np.linalg.norm</span>
    <span class="s1">}</span>
    <span class="s0">if </span><span class="s1">callable(norm):</span>
        <span class="s1">norm_func = norm</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">norm_func = norm_funcs[norm]</span>

    <span class="s1">parallel_count = </span><span class="s4">128</span>
    <span class="s1">min_intervals = </span><span class="s4">2</span>

    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">_quadrature = {</span><span class="s0">None</span><span class="s1">: _quadrature_gk21</span><span class="s0">,</span>
                       <span class="s5">'gk21'</span><span class="s1">: _quadrature_gk21</span><span class="s0">,</span>
                       <span class="s5">'gk15'</span><span class="s1">: _quadrature_gk15</span><span class="s0">,</span>
                       <span class="s5">'trapz'</span><span class="s1">: _quadrature_trapezoid</span><span class="s0">,  </span><span class="s2"># alias for backcompat</span>
                       <span class="s5">'trapezoid'</span><span class="s1">: _quadrature_trapezoid}[quadrature]</span>
    <span class="s0">except </span><span class="s1">KeyError </span><span class="s0">as </span><span class="s1">e:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s5">f&quot;unknown quadrature </span><span class="s0">{</span><span class="s1">quadrature</span><span class="s0">!r}</span><span class="s5">&quot;</span><span class="s1">) </span><span class="s0">from </span><span class="s1">e</span>

    <span class="s2"># Initial interval set</span>
    <span class="s0">if </span><span class="s1">points </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">initial_intervals = [(a</span><span class="s0">, </span><span class="s1">b)]</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">prev = a</span>
        <span class="s1">initial_intervals = []</span>
        <span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">sorted(points):</span>
            <span class="s1">p = float(p)</span>
            <span class="s0">if not </span><span class="s1">(a &lt; p &lt; b) </span><span class="s0">or </span><span class="s1">p == prev:</span>
                <span class="s0">continue</span>
            <span class="s1">initial_intervals.append((prev</span><span class="s0">, </span><span class="s1">p))</span>
            <span class="s1">prev = p</span>
        <span class="s1">initial_intervals.append((prev</span><span class="s0">, </span><span class="s1">b))</span>

    <span class="s1">global_integral = </span><span class="s0">None</span>
    <span class="s1">global_error = </span><span class="s0">None</span>
    <span class="s1">rounding_error = </span><span class="s0">None</span>
    <span class="s1">interval_cache = </span><span class="s0">None</span>
    <span class="s1">intervals = []</span>
    <span class="s1">neval = </span><span class="s4">0</span>

    <span class="s0">for </span><span class="s1">x1</span><span class="s0">, </span><span class="s1">x2 </span><span class="s0">in </span><span class="s1">initial_intervals:</span>
        <span class="s1">ig</span><span class="s0">, </span><span class="s1">err</span><span class="s0">, </span><span class="s1">rnd = _quadrature(x1</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">norm_func)</span>
        <span class="s1">neval += _quadrature.num_eval</span>

        <span class="s0">if </span><span class="s1">global_integral </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">isinstance(ig</span><span class="s0">, </span><span class="s1">(float</span><span class="s0">, </span><span class="s1">complex)):</span>
                <span class="s2"># Specialize for scalars</span>
                <span class="s0">if </span><span class="s1">norm_func </span><span class="s0">in </span><span class="s1">(_max_norm</span><span class="s0">, </span><span class="s1">np.linalg.norm):</span>
                    <span class="s1">norm_func = abs</span>

            <span class="s1">global_integral = ig</span>
            <span class="s1">global_error = float(err)</span>
            <span class="s1">rounding_error = float(rnd)</span>

            <span class="s1">cache_count = cache_size // _get_sizeof(ig)</span>
            <span class="s1">interval_cache = LRUDict(cache_count)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">global_integral += ig</span>
            <span class="s1">global_error += err</span>
            <span class="s1">rounding_error += rnd</span>

        <span class="s1">interval_cache[(x1</span><span class="s0">, </span><span class="s1">x2)] = copy.copy(ig)</span>
        <span class="s1">intervals.append((-err</span><span class="s0">, </span><span class="s1">x1</span><span class="s0">, </span><span class="s1">x2))</span>

    <span class="s1">heapq.heapify(intervals)</span>

    <span class="s1">CONVERGED = </span><span class="s4">0</span>
    <span class="s1">NOT_CONVERGED = </span><span class="s4">1</span>
    <span class="s1">ROUNDING_ERROR = </span><span class="s4">2</span>
    <span class="s1">NOT_A_NUMBER = </span><span class="s4">3</span>

    <span class="s1">status_msg = {</span>
        <span class="s1">CONVERGED: </span><span class="s5">&quot;Target precision reached.&quot;</span><span class="s0">,</span>
        <span class="s1">NOT_CONVERGED: </span><span class="s5">&quot;Target precision not reached.&quot;</span><span class="s0">,</span>
        <span class="s1">ROUNDING_ERROR: </span><span class="s5">&quot;Target precision could not be reached due to rounding error.&quot;</span><span class="s0">,</span>
        <span class="s1">NOT_A_NUMBER: </span><span class="s5">&quot;Non-finite values encountered.&quot;</span>
    <span class="s1">}</span>

    <span class="s2"># Process intervals</span>
    <span class="s0">with </span><span class="s1">MapWrapper(workers) </span><span class="s0">as </span><span class="s1">mapwrapper:</span>
        <span class="s1">ier = NOT_CONVERGED</span>

        <span class="s0">while </span><span class="s1">intervals </span><span class="s0">and </span><span class="s1">len(intervals) &lt; limit:</span>
            <span class="s2"># Select intervals with largest errors for subdivision</span>
            <span class="s1">tol = max(epsabs</span><span class="s0">, </span><span class="s1">epsrel*norm_func(global_integral))</span>

            <span class="s1">to_process = []</span>
            <span class="s1">err_sum = </span><span class="s4">0</span>

            <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(parallel_count):</span>
                <span class="s0">if not </span><span class="s1">intervals:</span>
                    <span class="s0">break</span>

                <span class="s0">if </span><span class="s1">j &gt; </span><span class="s4">0 </span><span class="s0">and </span><span class="s1">err_sum &gt; global_error - tol/</span><span class="s4">8</span><span class="s1">:</span>
                    <span class="s2"># avoid unnecessary parallel splitting</span>
                    <span class="s0">break</span>

                <span class="s1">interval = heapq.heappop(intervals)</span>

                <span class="s1">neg_old_err</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b = interval</span>
                <span class="s1">old_int = interval_cache.pop((a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">, None</span><span class="s1">)</span>
                <span class="s1">to_process.append(((-neg_old_err</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">old_int)</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">norm_func</span><span class="s0">, </span><span class="s1">_quadrature))</span>
                <span class="s1">err_sum += -neg_old_err</span>

            <span class="s2"># Subdivide intervals</span>
            <span class="s0">for </span><span class="s1">dint</span><span class="s0">, </span><span class="s1">derr</span><span class="s0">, </span><span class="s1">dround_err</span><span class="s0">, </span><span class="s1">subint</span><span class="s0">, </span><span class="s1">dneval </span><span class="s0">in </span><span class="s1">mapwrapper(_subdivide_interval</span><span class="s0">, </span><span class="s1">to_process):</span>
                <span class="s1">neval += dneval</span>
                <span class="s1">global_integral += dint</span>
                <span class="s1">global_error += derr</span>
                <span class="s1">rounding_error += dround_err</span>
                <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">subint:</span>
                    <span class="s1">x1</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s1">ig</span><span class="s0">, </span><span class="s1">err = x</span>
                    <span class="s1">interval_cache[(x1</span><span class="s0">, </span><span class="s1">x2)] = ig</span>
                    <span class="s1">heapq.heappush(intervals</span><span class="s0">, </span><span class="s1">(-err</span><span class="s0">, </span><span class="s1">x1</span><span class="s0">, </span><span class="s1">x2))</span>

            <span class="s2"># Termination check</span>
            <span class="s0">if </span><span class="s1">len(intervals) &gt;= min_intervals:</span>
                <span class="s1">tol = max(epsabs</span><span class="s0">, </span><span class="s1">epsrel*norm_func(global_integral))</span>
                <span class="s0">if </span><span class="s1">global_error &lt; tol/</span><span class="s4">8</span><span class="s1">:</span>
                    <span class="s1">ier = CONVERGED</span>
                    <span class="s0">break</span>
                <span class="s0">if </span><span class="s1">global_error &lt; rounding_error:</span>
                    <span class="s1">ier = ROUNDING_ERROR</span>
                    <span class="s0">break</span>

            <span class="s0">if not </span><span class="s1">(np.isfinite(global_error) </span><span class="s0">and </span><span class="s1">np.isfinite(rounding_error)):</span>
                <span class="s1">ier = NOT_A_NUMBER</span>
                <span class="s0">break</span>

    <span class="s1">res = global_integral</span>
    <span class="s1">err = global_error + rounding_error</span>

    <span class="s0">if </span><span class="s1">full_output:</span>
        <span class="s1">res_arr = np.asarray(res)</span>
        <span class="s1">dummy = np.full(res_arr.shape</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">dtype=res_arr.dtype)</span>
        <span class="s1">integrals = np.array([interval_cache.get((z[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">z[</span><span class="s4">2</span><span class="s1">])</span><span class="s0">, </span><span class="s1">dummy)</span>
                                      <span class="s0">for </span><span class="s1">z </span><span class="s0">in </span><span class="s1">intervals]</span><span class="s0">, </span><span class="s1">dtype=res_arr.dtype)</span>
        <span class="s1">errors = np.array([-z[</span><span class="s4">0</span><span class="s1">] </span><span class="s0">for </span><span class="s1">z </span><span class="s0">in </span><span class="s1">intervals])</span>
        <span class="s1">intervals = np.array([[z[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">z[</span><span class="s4">2</span><span class="s1">]] </span><span class="s0">for </span><span class="s1">z </span><span class="s0">in </span><span class="s1">intervals])</span>

        <span class="s1">info = _Bunch(neval=neval</span><span class="s0">,</span>
                      <span class="s1">success=(ier == CONVERGED)</span><span class="s0">,</span>
                      <span class="s1">status=ier</span><span class="s0">,</span>
                      <span class="s1">message=status_msg[ier]</span><span class="s0">,</span>
                      <span class="s1">intervals=intervals</span><span class="s0">,</span>
                      <span class="s1">integrals=integrals</span><span class="s0">,</span>
                      <span class="s1">errors=errors)</span>
        <span class="s0">return </span><span class="s1">(res</span><span class="s0">, </span><span class="s1">err</span><span class="s0">, </span><span class="s1">info)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">(res</span><span class="s0">, </span><span class="s1">err)</span>


<span class="s0">def </span><span class="s1">_subdivide_interval(args):</span>
    <span class="s1">interval</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">norm_func</span><span class="s0">, </span><span class="s1">_quadrature = args</span>
    <span class="s1">old_err</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">old_int = interval</span>

    <span class="s1">c = </span><span class="s4">0.5 </span><span class="s1">* (a + b)</span>

    <span class="s2"># Left-hand side</span>
    <span class="s0">if </span><span class="s1">getattr(_quadrature</span><span class="s0">, </span><span class="s5">'cache_size'</span><span class="s0">, </span><span class="s4">0</span><span class="s1">) &gt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">f = functools.lru_cache(_quadrature.cache_size)(f)</span>

    <span class="s1">s1</span><span class="s0">, </span><span class="s1">err1</span><span class="s0">, </span><span class="s1">round1 = _quadrature(a</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">norm_func)</span>
    <span class="s1">dneval = _quadrature.num_eval</span>
    <span class="s1">s2</span><span class="s0">, </span><span class="s1">err2</span><span class="s0">, </span><span class="s1">round2 = _quadrature(c</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">norm_func)</span>
    <span class="s1">dneval += _quadrature.num_eval</span>
    <span class="s0">if </span><span class="s1">old_int </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">old_int</span><span class="s0">, </span><span class="s1">_</span><span class="s0">, </span><span class="s1">_ = _quadrature(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">norm_func)</span>
        <span class="s1">dneval += _quadrature.num_eval</span>

    <span class="s0">if </span><span class="s1">getattr(_quadrature</span><span class="s0">, </span><span class="s5">'cache_size'</span><span class="s0">, </span><span class="s4">0</span><span class="s1">) &gt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">dneval = f.cache_info().misses</span>

    <span class="s1">dint = s1 + s2 - old_int</span>
    <span class="s1">derr = err1 + err2 - old_err</span>
    <span class="s1">dround_err = round1 + round2</span>

    <span class="s1">subintervals = ((a</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">s1</span><span class="s0">, </span><span class="s1">err1)</span><span class="s0">, </span><span class="s1">(c</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">s2</span><span class="s0">, </span><span class="s1">err2))</span>
    <span class="s0">return </span><span class="s1">dint</span><span class="s0">, </span><span class="s1">derr</span><span class="s0">, </span><span class="s1">dround_err</span><span class="s0">, </span><span class="s1">subintervals</span><span class="s0">, </span><span class="s1">dneval</span>


<span class="s0">def </span><span class="s1">_quadrature_trapezoid(x1</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">norm_func):</span>
    <span class="s3">&quot;&quot;&quot; 
    Composite trapezoid quadrature 
    &quot;&quot;&quot;</span>
    <span class="s1">x3 = </span><span class="s4">0.5</span><span class="s1">*(x1 + x2)</span>
    <span class="s1">f1 = f(x1)</span>
    <span class="s1">f2 = f(x2)</span>
    <span class="s1">f3 = f(x3)</span>

    <span class="s1">s2 = </span><span class="s4">0.25 </span><span class="s1">* (x2 - x1) * (f1 + </span><span class="s4">2</span><span class="s1">*f3 + f2)</span>

    <span class="s1">round_err = </span><span class="s4">0.25 </span><span class="s1">* abs(x2 - x1) * (float(norm_func(f1))</span>
                                       <span class="s1">+ </span><span class="s4">2</span><span class="s1">*float(norm_func(f3))</span>
                                       <span class="s1">+ float(norm_func(f2))) * </span><span class="s4">2e-16</span>

    <span class="s1">s1 = </span><span class="s4">0.5 </span><span class="s1">* (x2 - x1) * (f1 + f2)</span>
    <span class="s1">err = </span><span class="s4">1</span><span class="s1">/</span><span class="s4">3 </span><span class="s1">* float(norm_func(s1 - s2))</span>
    <span class="s0">return </span><span class="s1">s2</span><span class="s0">, </span><span class="s1">err</span><span class="s0">, </span><span class="s1">round_err</span>


<span class="s1">_quadrature_trapezoid.cache_size = </span><span class="s4">3 </span><span class="s1">* </span><span class="s4">3</span>
<span class="s1">_quadrature_trapezoid.num_eval = </span><span class="s4">3</span>


<span class="s0">def </span><span class="s1">_quadrature_gk(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">norm_func</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">w</span><span class="s0">, </span><span class="s1">v):</span>
    <span class="s3">&quot;&quot;&quot; 
    Generic Gauss-Kronrod quadrature 
    &quot;&quot;&quot;</span>

    <span class="s1">fv = [</span><span class="s4">0.0</span><span class="s1">]*len(x)</span>

    <span class="s1">c = </span><span class="s4">0.5 </span><span class="s1">* (a + b)</span>
    <span class="s1">h = </span><span class="s4">0.5 </span><span class="s1">* (b - a)</span>

    <span class="s2"># Gauss-Kronrod</span>
    <span class="s1">s_k = </span><span class="s4">0.0</span>
    <span class="s1">s_k_abs = </span><span class="s4">0.0</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(x)):</span>
        <span class="s1">ff = f(c + h*x[i])</span>
        <span class="s1">fv[i] = ff</span>

        <span class="s1">vv = v[i]</span>

        <span class="s2"># \int f(x)</span>
        <span class="s1">s_k += vv * ff</span>
        <span class="s2"># \int |f(x)|</span>
        <span class="s1">s_k_abs += vv * abs(ff)</span>

    <span class="s2"># Gauss</span>
    <span class="s1">s_g = </span><span class="s4">0.0</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(w)):</span>
        <span class="s1">s_g += w[i] * fv[</span><span class="s4">2</span><span class="s1">*i + </span><span class="s4">1</span><span class="s1">]</span>

    <span class="s2"># Quadrature of abs-deviation from average</span>
    <span class="s1">s_k_dabs = </span><span class="s4">0.0</span>
    <span class="s1">y0 = s_k / </span><span class="s4">2.0</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(x)):</span>
        <span class="s2"># \int |f(x) - y0|</span>
        <span class="s1">s_k_dabs += v[i] * abs(fv[i] - y0)</span>

    <span class="s2"># Use similar error estimation as quadpack</span>
    <span class="s1">err = float(norm_func((s_k - s_g) * h))</span>
    <span class="s1">dabs = float(norm_func(s_k_dabs * h))</span>
    <span class="s0">if </span><span class="s1">dabs != </span><span class="s4">0 </span><span class="s0">and </span><span class="s1">err != </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">err = dabs * min(</span><span class="s4">1.0</span><span class="s0">, </span><span class="s1">(</span><span class="s4">200 </span><span class="s1">* err / dabs)**</span><span class="s4">1.5</span><span class="s1">)</span>

    <span class="s1">eps = sys.float_info.epsilon</span>
    <span class="s1">round_err = float(norm_func(</span><span class="s4">50 </span><span class="s1">* eps * h * s_k_abs))</span>

    <span class="s0">if </span><span class="s1">round_err &gt; sys.float_info.min:</span>
        <span class="s1">err = max(err</span><span class="s0">, </span><span class="s1">round_err)</span>

    <span class="s0">return </span><span class="s1">h * s_k</span><span class="s0">, </span><span class="s1">err</span><span class="s0">, </span><span class="s1">round_err</span>


<span class="s0">def </span><span class="s1">_quadrature_gk21(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">norm_func):</span>
    <span class="s3">&quot;&quot;&quot; 
    Gauss-Kronrod 21 quadrature with error estimate 
    &quot;&quot;&quot;</span>
    <span class="s2"># Gauss-Kronrod points</span>
    <span class="s1">x = (</span><span class="s4">0.995657163025808080735527280689003</span><span class="s0">,</span>
         <span class="s4">0.973906528517171720077964012084452</span><span class="s0">,</span>
         <span class="s4">0.930157491355708226001207180059508</span><span class="s0">,</span>
         <span class="s4">0.865063366688984510732096688423493</span><span class="s0">,</span>
         <span class="s4">0.780817726586416897063717578345042</span><span class="s0">,</span>
         <span class="s4">0.679409568299024406234327365114874</span><span class="s0">,</span>
         <span class="s4">0.562757134668604683339000099272694</span><span class="s0">,</span>
         <span class="s4">0.433395394129247190799265943165784</span><span class="s0">,</span>
         <span class="s4">0.294392862701460198131126603103866</span><span class="s0">,</span>
         <span class="s4">0.148874338981631210884826001129720</span><span class="s0">,</span>
         <span class="s4">0</span><span class="s0">,</span>
         <span class="s1">-</span><span class="s4">0.148874338981631210884826001129720</span><span class="s0">,</span>
         <span class="s1">-</span><span class="s4">0.294392862701460198131126603103866</span><span class="s0">,</span>
         <span class="s1">-</span><span class="s4">0.433395394129247190799265943165784</span><span class="s0">,</span>
         <span class="s1">-</span><span class="s4">0.562757134668604683339000099272694</span><span class="s0">,</span>
         <span class="s1">-</span><span class="s4">0.679409568299024406234327365114874</span><span class="s0">,</span>
         <span class="s1">-</span><span class="s4">0.780817726586416897063717578345042</span><span class="s0">,</span>
         <span class="s1">-</span><span class="s4">0.865063366688984510732096688423493</span><span class="s0">,</span>
         <span class="s1">-</span><span class="s4">0.930157491355708226001207180059508</span><span class="s0">,</span>
         <span class="s1">-</span><span class="s4">0.973906528517171720077964012084452</span><span class="s0">,</span>
         <span class="s1">-</span><span class="s4">0.995657163025808080735527280689003</span><span class="s1">)</span>

    <span class="s2"># 10-point weights</span>
    <span class="s1">w = (</span><span class="s4">0.066671344308688137593568809893332</span><span class="s0">,</span>
         <span class="s4">0.149451349150580593145776339657697</span><span class="s0">,</span>
         <span class="s4">0.219086362515982043995534934228163</span><span class="s0">,</span>
         <span class="s4">0.269266719309996355091226921569469</span><span class="s0">,</span>
         <span class="s4">0.295524224714752870173892994651338</span><span class="s0">,</span>
         <span class="s4">0.295524224714752870173892994651338</span><span class="s0">,</span>
         <span class="s4">0.269266719309996355091226921569469</span><span class="s0">,</span>
         <span class="s4">0.219086362515982043995534934228163</span><span class="s0">,</span>
         <span class="s4">0.149451349150580593145776339657697</span><span class="s0">,</span>
         <span class="s4">0.066671344308688137593568809893332</span><span class="s1">)</span>

    <span class="s2"># 21-point weights</span>
    <span class="s1">v = (</span><span class="s4">0.011694638867371874278064396062192</span><span class="s0">,</span>
         <span class="s4">0.032558162307964727478818972459390</span><span class="s0">,</span>
         <span class="s4">0.054755896574351996031381300244580</span><span class="s0">,</span>
         <span class="s4">0.075039674810919952767043140916190</span><span class="s0">,</span>
         <span class="s4">0.093125454583697605535065465083366</span><span class="s0">,</span>
         <span class="s4">0.109387158802297641899210590325805</span><span class="s0">,</span>
         <span class="s4">0.123491976262065851077958109831074</span><span class="s0">,</span>
         <span class="s4">0.134709217311473325928054001771707</span><span class="s0">,</span>
         <span class="s4">0.142775938577060080797094273138717</span><span class="s0">,</span>
         <span class="s4">0.147739104901338491374841515972068</span><span class="s0">,</span>
         <span class="s4">0.149445554002916905664936468389821</span><span class="s0">,</span>
         <span class="s4">0.147739104901338491374841515972068</span><span class="s0">,</span>
         <span class="s4">0.142775938577060080797094273138717</span><span class="s0">,</span>
         <span class="s4">0.134709217311473325928054001771707</span><span class="s0">,</span>
         <span class="s4">0.123491976262065851077958109831074</span><span class="s0">,</span>
         <span class="s4">0.109387158802297641899210590325805</span><span class="s0">,</span>
         <span class="s4">0.093125454583697605535065465083366</span><span class="s0">,</span>
         <span class="s4">0.075039674810919952767043140916190</span><span class="s0">,</span>
         <span class="s4">0.054755896574351996031381300244580</span><span class="s0">,</span>
         <span class="s4">0.032558162307964727478818972459390</span><span class="s0">,</span>
         <span class="s4">0.011694638867371874278064396062192</span><span class="s1">)</span>

    <span class="s0">return </span><span class="s1">_quadrature_gk(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">norm_func</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">w</span><span class="s0">, </span><span class="s1">v)</span>


<span class="s1">_quadrature_gk21.num_eval = </span><span class="s4">21</span>


<span class="s0">def </span><span class="s1">_quadrature_gk15(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">norm_func):</span>
    <span class="s3">&quot;&quot;&quot; 
    Gauss-Kronrod 15 quadrature with error estimate 
    &quot;&quot;&quot;</span>
    <span class="s2"># Gauss-Kronrod points</span>
    <span class="s1">x = (</span><span class="s4">0.991455371120812639206854697526329</span><span class="s0">,</span>
         <span class="s4">0.949107912342758524526189684047851</span><span class="s0">,</span>
         <span class="s4">0.864864423359769072789712788640926</span><span class="s0">,</span>
         <span class="s4">0.741531185599394439863864773280788</span><span class="s0">,</span>
         <span class="s4">0.586087235467691130294144838258730</span><span class="s0">,</span>
         <span class="s4">0.405845151377397166906606412076961</span><span class="s0">,</span>
         <span class="s4">0.207784955007898467600689403773245</span><span class="s0">,</span>
         <span class="s4">0.000000000000000000000000000000000</span><span class="s0">,</span>
         <span class="s1">-</span><span class="s4">0.207784955007898467600689403773245</span><span class="s0">,</span>
         <span class="s1">-</span><span class="s4">0.405845151377397166906606412076961</span><span class="s0">,</span>
         <span class="s1">-</span><span class="s4">0.586087235467691130294144838258730</span><span class="s0">,</span>
         <span class="s1">-</span><span class="s4">0.741531185599394439863864773280788</span><span class="s0">,</span>
         <span class="s1">-</span><span class="s4">0.864864423359769072789712788640926</span><span class="s0">,</span>
         <span class="s1">-</span><span class="s4">0.949107912342758524526189684047851</span><span class="s0">,</span>
         <span class="s1">-</span><span class="s4">0.991455371120812639206854697526329</span><span class="s1">)</span>

    <span class="s2"># 7-point weights</span>
    <span class="s1">w = (</span><span class="s4">0.129484966168869693270611432679082</span><span class="s0">,</span>
         <span class="s4">0.279705391489276667901467771423780</span><span class="s0">,</span>
         <span class="s4">0.381830050505118944950369775488975</span><span class="s0">,</span>
         <span class="s4">0.417959183673469387755102040816327</span><span class="s0">,</span>
         <span class="s4">0.381830050505118944950369775488975</span><span class="s0">,</span>
         <span class="s4">0.279705391489276667901467771423780</span><span class="s0">,</span>
         <span class="s4">0.129484966168869693270611432679082</span><span class="s1">)</span>

    <span class="s2"># 15-point weights</span>
    <span class="s1">v = (</span><span class="s4">0.022935322010529224963732008058970</span><span class="s0">,</span>
         <span class="s4">0.063092092629978553290700663189204</span><span class="s0">,</span>
         <span class="s4">0.104790010322250183839876322541518</span><span class="s0">,</span>
         <span class="s4">0.140653259715525918745189590510238</span><span class="s0">,</span>
         <span class="s4">0.169004726639267902826583426598550</span><span class="s0">,</span>
         <span class="s4">0.190350578064785409913256402421014</span><span class="s0">,</span>
         <span class="s4">0.204432940075298892414161999234649</span><span class="s0">,</span>
         <span class="s4">0.209482141084727828012999174891714</span><span class="s0">,</span>
         <span class="s4">0.204432940075298892414161999234649</span><span class="s0">,</span>
         <span class="s4">0.190350578064785409913256402421014</span><span class="s0">,</span>
         <span class="s4">0.169004726639267902826583426598550</span><span class="s0">,</span>
         <span class="s4">0.140653259715525918745189590510238</span><span class="s0">,</span>
         <span class="s4">0.104790010322250183839876322541518</span><span class="s0">,</span>
         <span class="s4">0.063092092629978553290700663189204</span><span class="s0">,</span>
         <span class="s4">0.022935322010529224963732008058970</span><span class="s1">)</span>

    <span class="s0">return </span><span class="s1">_quadrature_gk(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s1">norm_func</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">w</span><span class="s0">, </span><span class="s1">v)</span>


<span class="s1">_quadrature_gk15.num_eval = </span><span class="s4">15</span>
</pre>
</body>
</html>