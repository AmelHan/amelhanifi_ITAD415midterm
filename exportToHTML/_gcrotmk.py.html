<html>
<head>
<title>_gcrotmk.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_gcrotmk.py</font>
</center></td></tr></table>
<pre><span class="s0"># Copyright (C) 2015, Pauli Virtanen &lt;pav@iki.fi&gt;</span>
<span class="s0"># Distributed under the same license as SciPy.</span>

<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">numpy.linalg </span><span class="s2">import </span><span class="s1">LinAlgError</span>
<span class="s2">from </span><span class="s1">scipy.linalg </span><span class="s2">import </span><span class="s1">(get_blas_funcs</span><span class="s2">, </span><span class="s1">qr</span><span class="s2">, </span><span class="s1">solve</span><span class="s2">, </span><span class="s1">svd</span><span class="s2">, </span><span class="s1">qr_insert</span><span class="s2">, </span><span class="s1">lstsq)</span>
<span class="s2">from </span><span class="s1">scipy.sparse.linalg._isolve.utils </span><span class="s2">import </span><span class="s1">make_system</span>


<span class="s1">__all__ = [</span><span class="s3">'gcrotmk'</span><span class="s1">]</span>


<span class="s2">def </span><span class="s1">_fgmres(matvec</span><span class="s2">, </span><span class="s1">v0</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">atol</span><span class="s2">, </span><span class="s1">lpsolve=</span><span class="s2">None, </span><span class="s1">rpsolve=</span><span class="s2">None, </span><span class="s1">cs=()</span><span class="s2">, </span><span class="s1">outer_v=()</span><span class="s2">,</span>
            <span class="s1">prepend_outer_v=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot; 
    FGMRES Arnoldi process, with optional projection or augmentation 
 
    Parameters 
    ---------- 
    matvec : callable 
        Operation A*x 
    v0 : ndarray 
        Initial vector, normalized to nrm2(v0) == 1 
    m : int 
        Number of GMRES rounds 
    atol : float 
        Absolute tolerance for early exit 
    lpsolve : callable 
        Left preconditioner L 
    rpsolve : callable 
        Right preconditioner R 
    cs : list of (ndarray, ndarray) 
        Columns of matrices C and U in GCROT 
    outer_v : list of ndarrays 
        Augmentation vectors in LGMRES 
    prepend_outer_v : bool, optional 
        Whether augmentation vectors come before or after 
        Krylov iterates 
 
    Raises 
    ------ 
    LinAlgError 
        If nans encountered 
 
    Returns 
    ------- 
    Q, R : ndarray 
        QR decomposition of the upper Hessenberg H=QR 
    B : ndarray 
        Projections corresponding to matrix C 
    vs : list of ndarray 
        Columns of matrix V 
    zs : list of ndarray 
        Columns of matrix Z 
    y : ndarray 
        Solution to ||H y - e_1||_2 = min! 
    res : float 
        The final (preconditioned) residual norm 
 
    &quot;&quot;&quot;</span>

    <span class="s2">if </span><span class="s1">lpsolve </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">def </span><span class="s1">lpsolve(x):</span>
            <span class="s2">return </span><span class="s1">x</span>
    <span class="s2">if </span><span class="s1">rpsolve </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">def </span><span class="s1">rpsolve(x):</span>
            <span class="s2">return </span><span class="s1">x</span>

    <span class="s1">axpy</span><span class="s2">, </span><span class="s1">dot</span><span class="s2">, </span><span class="s1">scal</span><span class="s2">, </span><span class="s1">nrm2 = get_blas_funcs([</span><span class="s3">'axpy'</span><span class="s2">, </span><span class="s3">'dot'</span><span class="s2">, </span><span class="s3">'scal'</span><span class="s2">, </span><span class="s3">'nrm2'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">(v0</span><span class="s2">,</span><span class="s1">))</span>

    <span class="s1">vs = [v0]</span>
    <span class="s1">zs = []</span>
    <span class="s1">y = </span><span class="s2">None</span>
    <span class="s1">res = np.nan</span>

    <span class="s1">m = m + len(outer_v)</span>

    <span class="s0"># Orthogonal projection coefficients</span>
    <span class="s1">B = np.zeros((len(cs)</span><span class="s2">, </span><span class="s1">m)</span><span class="s2">, </span><span class="s1">dtype=v0.dtype)</span>

    <span class="s0"># H is stored in QR factorized form</span>
    <span class="s1">Q = np.ones((</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=v0.dtype)</span>
    <span class="s1">R = np.zeros((</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=v0.dtype)</span>

    <span class="s1">eps = np.finfo(v0.dtype).eps</span>

    <span class="s1">breakdown = </span><span class="s2">False</span>

    <span class="s0"># FGMRES Arnoldi process</span>
    <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(m):</span>
        <span class="s0"># L A Z = C B + V H</span>

        <span class="s2">if </span><span class="s1">prepend_outer_v </span><span class="s2">and </span><span class="s1">j &lt; len(outer_v):</span>
            <span class="s1">z</span><span class="s2">, </span><span class="s1">w = outer_v[j]</span>
        <span class="s2">elif </span><span class="s1">prepend_outer_v </span><span class="s2">and </span><span class="s1">j == len(outer_v):</span>
            <span class="s1">z = rpsolve(v0)</span>
            <span class="s1">w = </span><span class="s2">None</span>
        <span class="s2">elif not </span><span class="s1">prepend_outer_v </span><span class="s2">and </span><span class="s1">j &gt;= m - len(outer_v):</span>
            <span class="s1">z</span><span class="s2">, </span><span class="s1">w = outer_v[j - (m - len(outer_v))]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">z = rpsolve(vs[-</span><span class="s5">1</span><span class="s1">])</span>
            <span class="s1">w = </span><span class="s2">None</span>

        <span class="s2">if </span><span class="s1">w </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">w = lpsolve(matvec(z))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># w is clobbered below</span>
            <span class="s1">w = w.copy()</span>

        <span class="s1">w_norm = nrm2(w)</span>

        <span class="s0"># GCROT projection: L A -&gt; (1 - C C^H) L A</span>
        <span class="s0"># i.e. orthogonalize against C</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">c </span><span class="s2">in </span><span class="s1">enumerate(cs):</span>
            <span class="s1">alpha = dot(c</span><span class="s2">, </span><span class="s1">w)</span>
            <span class="s1">B[i</span><span class="s2">,</span><span class="s1">j] = alpha</span>
            <span class="s1">w = axpy(c</span><span class="s2">, </span><span class="s1">w</span><span class="s2">, </span><span class="s1">c.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">-alpha)  </span><span class="s0"># w -= alpha*c</span>

        <span class="s0"># Orthogonalize against V</span>
        <span class="s1">hcur = np.zeros(j+</span><span class="s5">2</span><span class="s2">, </span><span class="s1">dtype=Q.dtype)</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">enumerate(vs):</span>
            <span class="s1">alpha = dot(v</span><span class="s2">, </span><span class="s1">w)</span>
            <span class="s1">hcur[i] = alpha</span>
            <span class="s1">w = axpy(v</span><span class="s2">, </span><span class="s1">w</span><span class="s2">, </span><span class="s1">v.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">-alpha)  </span><span class="s0"># w -= alpha*v</span>
        <span class="s1">hcur[i+</span><span class="s5">1</span><span class="s1">] = nrm2(w)</span>

        <span class="s2">with </span><span class="s1">np.errstate(over=</span><span class="s3">'ignore'</span><span class="s2">, </span><span class="s1">divide=</span><span class="s3">'ignore'</span><span class="s1">):</span>
            <span class="s0"># Careful with denormals</span>
            <span class="s1">alpha = </span><span class="s5">1</span><span class="s1">/hcur[-</span><span class="s5">1</span><span class="s1">]</span>

        <span class="s2">if </span><span class="s1">np.isfinite(alpha):</span>
            <span class="s1">w = scal(alpha</span><span class="s2">, </span><span class="s1">w)</span>

        <span class="s2">if not </span><span class="s1">(hcur[-</span><span class="s5">1</span><span class="s1">] &gt; eps * w_norm):</span>
            <span class="s0"># w essentially in the span of previous vectors,</span>
            <span class="s0"># or we have nans. Bail out after updating the QR</span>
            <span class="s0"># solution.</span>
            <span class="s1">breakdown = </span><span class="s2">True</span>

        <span class="s1">vs.append(w)</span>
        <span class="s1">zs.append(z)</span>

        <span class="s0"># Arnoldi LSQ problem</span>

        <span class="s0"># Add new column to H=Q@R, padding other columns with zeros</span>
        <span class="s1">Q2 = np.zeros((j+</span><span class="s5">2</span><span class="s2">, </span><span class="s1">j+</span><span class="s5">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=Q.dtype</span><span class="s2">, </span><span class="s1">order=</span><span class="s3">'F'</span><span class="s1">)</span>
        <span class="s1">Q2[:j+</span><span class="s5">1</span><span class="s2">,</span><span class="s1">:j+</span><span class="s5">1</span><span class="s1">] = Q</span>
        <span class="s1">Q2[j+</span><span class="s5">1</span><span class="s2">,</span><span class="s1">j+</span><span class="s5">1</span><span class="s1">] = </span><span class="s5">1</span>

        <span class="s1">R2 = np.zeros((j+</span><span class="s5">2</span><span class="s2">, </span><span class="s1">j)</span><span class="s2">, </span><span class="s1">dtype=R.dtype</span><span class="s2">, </span><span class="s1">order=</span><span class="s3">'F'</span><span class="s1">)</span>
        <span class="s1">R2[:j+</span><span class="s5">1</span><span class="s2">,</span><span class="s1">:] = R</span>

        <span class="s1">Q</span><span class="s2">, </span><span class="s1">R = qr_insert(Q2</span><span class="s2">, </span><span class="s1">R2</span><span class="s2">, </span><span class="s1">hcur</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">which=</span><span class="s3">'col'</span><span class="s2">,</span>
                         <span class="s1">overwrite_qru=</span><span class="s2">True, </span><span class="s1">check_finite=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s0"># Transformed least squares problem</span>
        <span class="s0"># || Q R y - inner_res_0 * e_1 ||_2 = min!</span>
        <span class="s0"># Since R = [R'; 0], solution is y = inner_res_0 (R')^{-1} (Q^H)[:j,0]</span>

        <span class="s0"># Residual is immediately known</span>
        <span class="s1">res = abs(Q[</span><span class="s5">0</span><span class="s2">,</span><span class="s1">-</span><span class="s5">1</span><span class="s1">])</span>

        <span class="s0"># Check for termination</span>
        <span class="s2">if </span><span class="s1">res &lt; atol </span><span class="s2">or </span><span class="s1">breakdown:</span>
            <span class="s2">break</span>

    <span class="s2">if not </span><span class="s1">np.isfinite(R[j</span><span class="s2">,</span><span class="s1">j]):</span>
        <span class="s0"># nans encountered, bail out</span>
        <span class="s2">raise </span><span class="s1">LinAlgError()</span>

    <span class="s0"># -- Get the LSQ problem solution</span>

    <span class="s0"># The problem is triangular, but the condition number may be</span>
    <span class="s0"># bad (or in case of breakdown the last diagonal entry may be</span>
    <span class="s0"># zero), so use lstsq instead of trtrs.</span>
    <span class="s1">y</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">= lstsq(R[:j+</span><span class="s5">1</span><span class="s2">,</span><span class="s1">:j+</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">Q[</span><span class="s5">0</span><span class="s2">,</span><span class="s1">:j+</span><span class="s5">1</span><span class="s1">].conj())</span>

    <span class="s1">B = B[:</span><span class="s2">,</span><span class="s1">:j+</span><span class="s5">1</span><span class="s1">]</span>

    <span class="s2">return </span><span class="s1">Q</span><span class="s2">, </span><span class="s1">R</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, </span><span class="s1">vs</span><span class="s2">, </span><span class="s1">zs</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">res</span>


<span class="s2">def </span><span class="s1">gcrotmk(A</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">x0=</span><span class="s2">None, </span><span class="s1">tol=</span><span class="s5">1e-5</span><span class="s2">, </span><span class="s1">maxiter=</span><span class="s5">1000</span><span class="s2">, </span><span class="s1">M=</span><span class="s2">None, </span><span class="s1">callback=</span><span class="s2">None,</span>
            <span class="s1">m=</span><span class="s5">20</span><span class="s2">, </span><span class="s1">k=</span><span class="s2">None, </span><span class="s1">CU=</span><span class="s2">None, </span><span class="s1">discard_C=</span><span class="s2">False, </span><span class="s1">truncate=</span><span class="s3">'oldest'</span><span class="s2">,</span>
            <span class="s1">atol=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Solve a matrix equation using flexible GCROT(m,k) algorithm. 
 
    Parameters 
    ---------- 
    A : {sparse matrix, ndarray, LinearOperator} 
        The real or complex N-by-N matrix of the linear system. 
        Alternatively, ``A`` can be a linear operator which can 
        produce ``Ax`` using, e.g., 
        ``scipy.sparse.linalg.LinearOperator``. 
    b : ndarray 
        Right hand side of the linear system. Has shape (N,) or (N,1). 
    x0 : ndarray 
        Starting guess for the solution. 
    tol, atol : float, optional 
        Tolerances for convergence, ``norm(residual) &lt;= max(tol*norm(b), atol)``. 
        The default for ``atol`` is `tol`. 
 
        .. warning:: 
 
           The default value for `atol` will be changed in a future release. 
           For future compatibility, specify `atol` explicitly. 
    maxiter : int, optional 
        Maximum number of iterations.  Iteration will stop after maxiter 
        steps even if the specified tolerance has not been achieved. 
    M : {sparse matrix, ndarray, LinearOperator}, optional 
        Preconditioner for A.  The preconditioner should approximate the 
        inverse of A. gcrotmk is a 'flexible' algorithm and the preconditioner 
        can vary from iteration to iteration. Effective preconditioning 
        dramatically improves the rate of convergence, which implies that 
        fewer iterations are needed to reach a given error tolerance. 
    callback : function, optional 
        User-supplied function to call after each iteration.  It is called 
        as callback(xk), where xk is the current solution vector. 
    m : int, optional 
        Number of inner FGMRES iterations per each outer iteration. 
        Default: 20 
    k : int, optional 
        Number of vectors to carry between inner FGMRES iterations. 
        According to [2]_, good values are around m. 
        Default: m 
    CU : list of tuples, optional 
        List of tuples ``(c, u)`` which contain the columns of the matrices 
        C and U in the GCROT(m,k) algorithm. For details, see [2]_. 
        The list given and vectors contained in it are modified in-place. 
        If not given, start from empty matrices. The ``c`` elements in the 
        tuples can be ``None``, in which case the vectors are recomputed 
        via ``c = A u`` on start and orthogonalized as described in [3]_. 
    discard_C : bool, optional 
        Discard the C-vectors at the end. Useful if recycling Krylov subspaces 
        for different linear systems. 
    truncate : {'oldest', 'smallest'}, optional 
        Truncation scheme to use. Drop: oldest vectors, or vectors with 
        smallest singular values using the scheme discussed in [1,2]. 
        See [2]_ for detailed comparison. 
        Default: 'oldest' 
 
    Returns 
    ------- 
    x : ndarray 
        The solution found. 
    info : int 
        Provides convergence information: 
 
        * 0  : successful exit 
        * &gt;0 : convergence to tolerance not achieved, number of iterations 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.sparse import csc_matrix 
    &gt;&gt;&gt; from scipy.sparse.linalg import gcrotmk 
    &gt;&gt;&gt; R = np.random.randn(5, 5) 
    &gt;&gt;&gt; A = csc_matrix(R) 
    &gt;&gt;&gt; b = np.random.randn(5) 
    &gt;&gt;&gt; x, exit_code = gcrotmk(A, b) 
    &gt;&gt;&gt; print(exit_code) 
    0 
    &gt;&gt;&gt; np.allclose(A.dot(x), b) 
    True 
 
    References 
    ---------- 
    .. [1] E. de Sturler, ''Truncation strategies for optimal Krylov subspace 
           methods'', SIAM J. Numer. Anal. 36, 864 (1999). 
    .. [2] J.E. Hicken and D.W. Zingg, ''A simplified and flexible variant 
           of GCROT for solving nonsymmetric linear systems'', 
           SIAM J. Sci. Comput. 32, 172 (2010). 
    .. [3] M.L. Parks, E. de Sturler, G. Mackey, D.D. Johnson, S. Maiti, 
           ''Recycling Krylov subspaces for sequences of linear systems'', 
           SIAM J. Sci. Comput. 28, 1651 (2006). 
 
    &quot;&quot;&quot;</span>
    <span class="s1">A</span><span class="s2">,</span><span class="s1">M</span><span class="s2">,</span><span class="s1">x</span><span class="s2">,</span><span class="s1">b</span><span class="s2">,</span><span class="s1">postprocess = make_system(A</span><span class="s2">,</span><span class="s1">M</span><span class="s2">,</span><span class="s1">x0</span><span class="s2">,</span><span class="s1">b)</span>

    <span class="s2">if not </span><span class="s1">np.isfinite(b).all():</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;RHS must contain only finite numbers&quot;</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">truncate </span><span class="s2">not in </span><span class="s1">(</span><span class="s3">'oldest'</span><span class="s2">, </span><span class="s3">'smallest'</span><span class="s1">):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;Invalid value for 'truncate': </span><span class="s2">{</span><span class="s1">truncate</span><span class="s2">!r}</span><span class="s3">&quot;</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">atol </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">warnings.warn(</span><span class="s3">&quot;scipy.sparse.linalg.gcrotmk called without specifying `atol`. &quot;</span>
                      <span class="s3">&quot;The default value will change in the future. To preserve &quot;</span>
                      <span class="s3">&quot;current behavior, set ``atol=tol``.&quot;</span><span class="s2">,</span>
                      <span class="s1">category=DeprecationWarning</span><span class="s2">, </span><span class="s1">stacklevel=</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">atol = tol</span>

    <span class="s1">matvec = A.matvec</span>
    <span class="s1">psolve = M.matvec</span>

    <span class="s2">if </span><span class="s1">CU </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">CU = []</span>

    <span class="s2">if </span><span class="s1">k </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">k = m</span>

    <span class="s1">axpy</span><span class="s2">, </span><span class="s1">dot</span><span class="s2">, </span><span class="s1">scal = </span><span class="s2">None, None, None</span>

    <span class="s2">if </span><span class="s1">x0 </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">r = b.copy()</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">r = b - matvec(x)</span>

    <span class="s1">axpy</span><span class="s2">, </span><span class="s1">dot</span><span class="s2">, </span><span class="s1">scal</span><span class="s2">, </span><span class="s1">nrm2 = get_blas_funcs([</span><span class="s3">'axpy'</span><span class="s2">, </span><span class="s3">'dot'</span><span class="s2">, </span><span class="s3">'scal'</span><span class="s2">, </span><span class="s3">'nrm2'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">(x</span><span class="s2">, </span><span class="s1">r))</span>

    <span class="s1">b_norm = nrm2(b)</span>
    <span class="s2">if </span><span class="s1">b_norm == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">x = b</span>
        <span class="s2">return </span><span class="s1">(postprocess(x)</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">discard_C:</span>
        <span class="s1">CU[:] = [(</span><span class="s2">None, </span><span class="s1">u) </span><span class="s2">for </span><span class="s1">c</span><span class="s2">, </span><span class="s1">u </span><span class="s2">in </span><span class="s1">CU]</span>

    <span class="s0"># Reorthogonalize old vectors</span>
    <span class="s2">if </span><span class="s1">CU:</span>
        <span class="s0"># Sort already existing vectors to the front</span>
        <span class="s1">CU.sort(key=</span><span class="s2">lambda </span><span class="s1">cu: cu[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">is not None</span><span class="s1">)</span>

        <span class="s0"># Fill-in missing ones</span>
        <span class="s1">C = np.empty((A.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">len(CU))</span><span class="s2">, </span><span class="s1">dtype=r.dtype</span><span class="s2">, </span><span class="s1">order=</span><span class="s3">'F'</span><span class="s1">)</span>
        <span class="s1">us = []</span>
        <span class="s1">j = </span><span class="s5">0</span>
        <span class="s2">while </span><span class="s1">CU:</span>
            <span class="s0"># More memory-efficient: throw away old vectors as we go</span>
            <span class="s1">c</span><span class="s2">, </span><span class="s1">u = CU.pop(</span><span class="s5">0</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">c </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">c = matvec(u)</span>
            <span class="s1">C[:</span><span class="s2">,</span><span class="s1">j] = c</span>
            <span class="s1">j += </span><span class="s5">1</span>
            <span class="s1">us.append(u)</span>

        <span class="s0"># Orthogonalize</span>
        <span class="s1">Q</span><span class="s2">, </span><span class="s1">R</span><span class="s2">, </span><span class="s1">P = qr(C</span><span class="s2">, </span><span class="s1">overwrite_a=</span><span class="s2">True, </span><span class="s1">mode=</span><span class="s3">'economic'</span><span class="s2">, </span><span class="s1">pivoting=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">del </span><span class="s1">C</span>

        <span class="s0"># C := Q</span>
        <span class="s1">cs = list(Q.T)</span>

        <span class="s0"># U := U P R^-1,  back-substitution</span>
        <span class="s1">new_us = []</span>
        <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(len(cs)):</span>
            <span class="s1">u = us[P[j]]</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(j):</span>
                <span class="s1">u = axpy(us[P[i]]</span><span class="s2">, </span><span class="s1">u</span><span class="s2">, </span><span class="s1">u.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">-R[i</span><span class="s2">,</span><span class="s1">j])</span>
            <span class="s2">if </span><span class="s1">abs(R[j</span><span class="s2">,</span><span class="s1">j]) &lt; </span><span class="s5">1e-12 </span><span class="s1">* abs(R[</span><span class="s5">0</span><span class="s2">,</span><span class="s5">0</span><span class="s1">]):</span>
                <span class="s0"># discard rest of the vectors</span>
                <span class="s2">break</span>
            <span class="s1">u = scal(</span><span class="s5">1.0</span><span class="s1">/R[j</span><span class="s2">,</span><span class="s1">j]</span><span class="s2">, </span><span class="s1">u)</span>
            <span class="s1">new_us.append(u)</span>

        <span class="s0"># Form the new CU lists</span>
        <span class="s1">CU[:] = list(zip(cs</span><span class="s2">, </span><span class="s1">new_us))[::-</span><span class="s5">1</span><span class="s1">]</span>

    <span class="s2">if </span><span class="s1">CU:</span>
        <span class="s1">axpy</span><span class="s2">, </span><span class="s1">dot = get_blas_funcs([</span><span class="s3">'axpy'</span><span class="s2">, </span><span class="s3">'dot'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">(r</span><span class="s2">,</span><span class="s1">))</span>

        <span class="s0"># Solve first the projection operation with respect to the CU</span>
        <span class="s0"># vectors. This corresponds to modifying the initial guess to</span>
        <span class="s0"># be</span>
        <span class="s0">#</span>
        <span class="s0">#     x' = x + U y</span>
        <span class="s0">#     y = argmin_y || b - A (x + U y) ||^2</span>
        <span class="s0">#</span>
        <span class="s0"># The solution is y = C^H (b - A x)</span>
        <span class="s2">for </span><span class="s1">c</span><span class="s2">, </span><span class="s1">u </span><span class="s2">in </span><span class="s1">CU:</span>
            <span class="s1">yc = dot(c</span><span class="s2">, </span><span class="s1">r)</span>
            <span class="s1">x = axpy(u</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">x.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">yc)</span>
            <span class="s1">r = axpy(c</span><span class="s2">, </span><span class="s1">r</span><span class="s2">, </span><span class="s1">r.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">-yc)</span>

    <span class="s0"># GCROT main iteration</span>
    <span class="s2">for </span><span class="s1">j_outer </span><span class="s2">in </span><span class="s1">range(maxiter):</span>
        <span class="s0"># -- callback</span>
        <span class="s2">if </span><span class="s1">callback </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">callback(x)</span>

        <span class="s1">beta = nrm2(r)</span>

        <span class="s0"># -- check stopping condition</span>
        <span class="s1">beta_tol = max(atol</span><span class="s2">, </span><span class="s1">tol * b_norm)</span>

        <span class="s2">if </span><span class="s1">beta &lt;= beta_tol </span><span class="s2">and </span><span class="s1">(j_outer &gt; </span><span class="s5">0 </span><span class="s2">or </span><span class="s1">CU):</span>
            <span class="s0"># recompute residual to avoid rounding error</span>
            <span class="s1">r = b - matvec(x)</span>
            <span class="s1">beta = nrm2(r)</span>

        <span class="s2">if </span><span class="s1">beta &lt;= beta_tol:</span>
            <span class="s1">j_outer = -</span><span class="s5">1</span>
            <span class="s2">break</span>

        <span class="s1">ml = m + max(k - len(CU)</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>

        <span class="s1">cs = [c </span><span class="s2">for </span><span class="s1">c</span><span class="s2">, </span><span class="s1">u </span><span class="s2">in </span><span class="s1">CU]</span>

        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">Q</span><span class="s2">, </span><span class="s1">R</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, </span><span class="s1">vs</span><span class="s2">, </span><span class="s1">zs</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">pres = _fgmres(matvec</span><span class="s2">,</span>
                                               <span class="s1">r/beta</span><span class="s2">,</span>
                                               <span class="s1">ml</span><span class="s2">,</span>
                                               <span class="s1">rpsolve=psolve</span><span class="s2">,</span>
                                               <span class="s1">atol=max(atol</span><span class="s2">, </span><span class="s1">tol*b_norm)/beta</span><span class="s2">,</span>
                                               <span class="s1">cs=cs)</span>
            <span class="s1">y *= beta</span>
        <span class="s2">except </span><span class="s1">LinAlgError:</span>
            <span class="s0"># Floating point over/underflow, non-finite result from</span>
            <span class="s0"># matmul etc. -- report failure.</span>
            <span class="s2">break</span>

        <span class="s0">#</span>
        <span class="s0"># At this point,</span>
        <span class="s0">#</span>
        <span class="s0">#     [A U, A Z] = [C, V] G;   G =  [ I  B ]</span>
        <span class="s0">#                                   [ 0  H ]</span>
        <span class="s0">#</span>
        <span class="s0"># where [C, V] has orthonormal columns, and r = beta v_0. Moreover,</span>
        <span class="s0">#</span>
        <span class="s0">#     || b - A (x + Z y + U q) ||_2 = || r - C B y - V H y - C q ||_2 = min!</span>
        <span class="s0">#</span>
        <span class="s0"># from which y = argmin_y || beta e_1 - H y ||_2, and q = -B y</span>
        <span class="s0">#</span>

        <span class="s0">#</span>
        <span class="s0"># GCROT(m,k) update</span>
        <span class="s0">#</span>

        <span class="s0"># Define new outer vectors</span>

        <span class="s0"># ux := (Z - U B) y</span>
        <span class="s1">ux = zs[</span><span class="s5">0</span><span class="s1">]*y[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s2">for </span><span class="s1">z</span><span class="s2">, </span><span class="s1">yc </span><span class="s2">in </span><span class="s1">zip(zs[</span><span class="s5">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">y[</span><span class="s5">1</span><span class="s1">:]):</span>
            <span class="s1">ux = axpy(z</span><span class="s2">, </span><span class="s1">ux</span><span class="s2">, </span><span class="s1">ux.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">yc)  </span><span class="s0"># ux += z*yc</span>
        <span class="s1">by = B.dot(y)</span>
        <span class="s2">for </span><span class="s1">cu</span><span class="s2">, </span><span class="s1">byc </span><span class="s2">in </span><span class="s1">zip(CU</span><span class="s2">, </span><span class="s1">by):</span>
            <span class="s1">c</span><span class="s2">, </span><span class="s1">u = cu</span>
            <span class="s1">ux = axpy(u</span><span class="s2">, </span><span class="s1">ux</span><span class="s2">, </span><span class="s1">ux.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">-byc)  </span><span class="s0"># ux -= u*byc</span>

        <span class="s0"># cx := V H y</span>
        <span class="s1">hy = Q.dot(R.dot(y))</span>
        <span class="s1">cx = vs[</span><span class="s5">0</span><span class="s1">] * hy[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s2">for </span><span class="s1">v</span><span class="s2">, </span><span class="s1">hyc </span><span class="s2">in </span><span class="s1">zip(vs[</span><span class="s5">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">hy[</span><span class="s5">1</span><span class="s1">:]):</span>
            <span class="s1">cx = axpy(v</span><span class="s2">, </span><span class="s1">cx</span><span class="s2">, </span><span class="s1">cx.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">hyc)  </span><span class="s0"># cx += v*hyc</span>

        <span class="s0"># Normalize cx, maintaining cx = A ux</span>
        <span class="s0"># This new cx is orthogonal to the previous C, by construction</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">alpha = </span><span class="s5">1</span><span class="s1">/nrm2(cx)</span>
            <span class="s2">if not </span><span class="s1">np.isfinite(alpha):</span>
                <span class="s2">raise </span><span class="s1">FloatingPointError()</span>
        <span class="s2">except </span><span class="s1">(FloatingPointError</span><span class="s2">, </span><span class="s1">ZeroDivisionError):</span>
            <span class="s0"># Cannot update, so skip it</span>
            <span class="s2">continue</span>

        <span class="s1">cx = scal(alpha</span><span class="s2">, </span><span class="s1">cx)</span>
        <span class="s1">ux = scal(alpha</span><span class="s2">, </span><span class="s1">ux)</span>

        <span class="s0"># Update residual and solution</span>
        <span class="s1">gamma = dot(cx</span><span class="s2">, </span><span class="s1">r)</span>
        <span class="s1">r = axpy(cx</span><span class="s2">, </span><span class="s1">r</span><span class="s2">, </span><span class="s1">r.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">-gamma)  </span><span class="s0"># r -= gamma*cx</span>
        <span class="s1">x = axpy(ux</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">x.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">gamma)  </span><span class="s0"># x += gamma*ux</span>

        <span class="s0"># Truncate CU</span>
        <span class="s2">if </span><span class="s1">truncate == </span><span class="s3">'oldest'</span><span class="s1">:</span>
            <span class="s2">while </span><span class="s1">len(CU) &gt;= k </span><span class="s2">and </span><span class="s1">CU:</span>
                <span class="s2">del </span><span class="s1">CU[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s2">elif </span><span class="s1">truncate == </span><span class="s3">'smallest'</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">len(CU) &gt;= k </span><span class="s2">and </span><span class="s1">CU:</span>
                <span class="s0"># cf. [1,2]</span>
                <span class="s1">D = solve(R[:-</span><span class="s5">1</span><span class="s2">,</span><span class="s1">:].T</span><span class="s2">, </span><span class="s1">B.T).T</span>
                <span class="s1">W</span><span class="s2">, </span><span class="s1">sigma</span><span class="s2">, </span><span class="s1">V = svd(D)</span>

                <span class="s0"># C := C W[:,:k-1],  U := U W[:,:k-1]</span>
                <span class="s1">new_CU = []</span>
                <span class="s2">for </span><span class="s1">j</span><span class="s2">, </span><span class="s1">w </span><span class="s2">in </span><span class="s1">enumerate(W[:</span><span class="s2">,</span><span class="s1">:k-</span><span class="s5">1</span><span class="s1">].T):</span>
                    <span class="s1">c</span><span class="s2">, </span><span class="s1">u = CU[</span><span class="s5">0</span><span class="s1">]</span>
                    <span class="s1">c = c * w[</span><span class="s5">0</span><span class="s1">]</span>
                    <span class="s1">u = u * w[</span><span class="s5">0</span><span class="s1">]</span>
                    <span class="s2">for </span><span class="s1">cup</span><span class="s2">, </span><span class="s1">wp </span><span class="s2">in </span><span class="s1">zip(CU[</span><span class="s5">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">w[</span><span class="s5">1</span><span class="s1">:]):</span>
                        <span class="s1">cp</span><span class="s2">, </span><span class="s1">up = cup</span>
                        <span class="s1">c = axpy(cp</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">c.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">wp)</span>
                        <span class="s1">u = axpy(up</span><span class="s2">, </span><span class="s1">u</span><span class="s2">, </span><span class="s1">u.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">wp)</span>

                    <span class="s0"># Reorthogonalize at the same time; not necessary</span>
                    <span class="s0"># in exact arithmetic, but floating point error</span>
                    <span class="s0"># tends to accumulate here</span>
                    <span class="s2">for </span><span class="s1">cp</span><span class="s2">, </span><span class="s1">up </span><span class="s2">in </span><span class="s1">new_CU:</span>
                        <span class="s1">alpha = dot(cp</span><span class="s2">, </span><span class="s1">c)</span>
                        <span class="s1">c = axpy(cp</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">c.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">-alpha)</span>
                        <span class="s1">u = axpy(up</span><span class="s2">, </span><span class="s1">u</span><span class="s2">, </span><span class="s1">u.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">-alpha)</span>
                    <span class="s1">alpha = nrm2(c)</span>
                    <span class="s1">c = scal(</span><span class="s5">1.0</span><span class="s1">/alpha</span><span class="s2">, </span><span class="s1">c)</span>
                    <span class="s1">u = scal(</span><span class="s5">1.0</span><span class="s1">/alpha</span><span class="s2">, </span><span class="s1">u)</span>

                    <span class="s1">new_CU.append((c</span><span class="s2">, </span><span class="s1">u))</span>
                <span class="s1">CU[:] = new_CU</span>

        <span class="s0"># Add new vector to CU</span>
        <span class="s1">CU.append((cx</span><span class="s2">, </span><span class="s1">ux))</span>

    <span class="s0"># Include the solution vector to the span</span>
    <span class="s1">CU.append((</span><span class="s2">None, </span><span class="s1">x.copy()))</span>
    <span class="s2">if </span><span class="s1">discard_C:</span>
        <span class="s1">CU[:] = [(</span><span class="s2">None, </span><span class="s1">uz) </span><span class="s2">for </span><span class="s1">cz</span><span class="s2">, </span><span class="s1">uz </span><span class="s2">in </span><span class="s1">CU]</span>

    <span class="s2">return </span><span class="s1">postprocess(x)</span><span class="s2">, </span><span class="s1">j_outer + </span><span class="s5">1</span>
</pre>
</body>
</html>