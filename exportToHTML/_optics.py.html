<html>
<head>
<title>_optics.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_optics.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Ordering Points To Identify the Clustering Structure (OPTICS) 
 
These routines execute the OPTICS algorithm, and implement various 
cluster extraction methods of the ordered list. 
 
Authors: Shane Grigsby &lt;refuge@rocktalus.com&gt; 
         Adrin Jalali &lt;adrinjalali@gmail.com&gt; 
         Erich Schubert &lt;erich@debian.org&gt; 
         Hanmin Qin &lt;qinhanmin2005@sina.com&gt; 
License: BSD 3 clause 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">from </span><span class="s1">numbers </span><span class="s2">import </span><span class="s1">Integral</span><span class="s2">, </span><span class="s1">Real</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">scipy.sparse </span><span class="s2">import </span><span class="s1">SparseEfficiencyWarning</span><span class="s2">, </span><span class="s1">issparse</span>

<span class="s2">from </span><span class="s1">..base </span><span class="s2">import </span><span class="s1">BaseEstimator</span><span class="s2">, </span><span class="s1">ClusterMixin</span><span class="s2">, </span><span class="s1">_fit_context</span>
<span class="s2">from </span><span class="s1">..exceptions </span><span class="s2">import </span><span class="s1">DataConversionWarning</span>
<span class="s2">from </span><span class="s1">..metrics </span><span class="s2">import </span><span class="s1">pairwise_distances</span>
<span class="s2">from </span><span class="s1">..metrics.pairwise </span><span class="s2">import </span><span class="s1">_VALID_METRICS</span><span class="s2">, </span><span class="s1">PAIRWISE_BOOLEAN_FUNCTIONS</span>
<span class="s2">from </span><span class="s1">..neighbors </span><span class="s2">import </span><span class="s1">NearestNeighbors</span>
<span class="s2">from </span><span class="s1">..utils </span><span class="s2">import </span><span class="s1">gen_batches</span><span class="s2">, </span><span class="s1">get_chunk_n_rows</span>
<span class="s2">from </span><span class="s1">..utils._param_validation </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">HasMethods</span><span class="s2">,</span>
    <span class="s1">Interval</span><span class="s2">,</span>
    <span class="s1">RealNotInt</span><span class="s2">,</span>
    <span class="s1">StrOptions</span><span class="s2">,</span>
    <span class="s1">validate_params</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">..utils.validation </span><span class="s2">import </span><span class="s1">check_memory</span>


<span class="s2">class </span><span class="s1">OPTICS(ClusterMixin</span><span class="s2">, </span><span class="s1">BaseEstimator):</span>
    <span class="s0">&quot;&quot;&quot;Estimate clustering structure from vector array. 
 
    OPTICS (Ordering Points To Identify the Clustering Structure), closely 
    related to DBSCAN, finds core sample of high density and expands clusters 
    from them [1]_. Unlike DBSCAN, keeps cluster hierarchy for a variable 
    neighborhood radius. Better suited for usage on large datasets than the 
    current sklearn implementation of DBSCAN. 
 
    Clusters are then extracted using a DBSCAN-like method 
    (cluster_method = 'dbscan') or an automatic 
    technique proposed in [1]_ (cluster_method = 'xi'). 
 
    This implementation deviates from the original OPTICS by first performing 
    k-nearest-neighborhood searches on all points to identify core sizes, then 
    computing only the distances to unprocessed points when constructing the 
    cluster order. Note that we do not employ a heap to manage the expansion 
    candidates, so the time complexity will be O(n^2). 
 
    Read more in the :ref:`User Guide &lt;optics&gt;`. 
 
    Parameters 
    ---------- 
    min_samples : int &gt; 1 or float between 0 and 1, default=5 
        The number of samples in a neighborhood for a point to be considered as 
        a core point. Also, up and down steep regions can't have more than 
        ``min_samples`` consecutive non-steep points. Expressed as an absolute 
        number or a fraction of the number of samples (rounded to be at least 
        2). 
 
    max_eps : float, default=np.inf 
        The maximum distance between two samples for one to be considered as 
        in the neighborhood of the other. Default value of ``np.inf`` will 
        identify clusters across all scales; reducing ``max_eps`` will result 
        in shorter run times. 
 
    metric : str or callable, default='minkowski' 
        Metric to use for distance computation. Any metric from scikit-learn 
        or scipy.spatial.distance can be used. 
 
        If metric is a callable function, it is called on each 
        pair of instances (rows) and the resulting value recorded. The callable 
        should take two arrays as input and return one value indicating the 
        distance between them. This works for Scipy's metrics, but is less 
        efficient than passing the metric name as a string. If metric is 
        &quot;precomputed&quot;, `X` is assumed to be a distance matrix and must be 
        square. 
 
        Valid values for metric are: 
 
        - from scikit-learn: ['cityblock', 'cosine', 'euclidean', 'l1', 'l2', 
          'manhattan'] 
 
        - from scipy.spatial.distance: ['braycurtis', 'canberra', 'chebyshev', 
          'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski', 
          'mahalanobis', 'minkowski', 'rogerstanimoto', 'russellrao', 
          'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean', 
          'yule'] 
 
        Sparse matrices are only supported by scikit-learn metrics. 
        See the documentation for scipy.spatial.distance for details on these 
        metrics. 
 
        .. note:: 
           `'kulsinski'` is deprecated from SciPy 1.9 and will removed in SciPy 1.11. 
 
    p : float, default=2 
        Parameter for the Minkowski metric from 
        :class:`~sklearn.metrics.pairwise_distances`. When p = 1, this is 
        equivalent to using manhattan_distance (l1), and euclidean_distance 
        (l2) for p = 2. For arbitrary p, minkowski_distance (l_p) is used. 
 
    metric_params : dict, default=None 
        Additional keyword arguments for the metric function. 
 
    cluster_method : str, default='xi' 
        The extraction method used to extract clusters using the calculated 
        reachability and ordering. Possible values are &quot;xi&quot; and &quot;dbscan&quot;. 
 
    eps : float, default=None 
        The maximum distance between two samples for one to be considered as 
        in the neighborhood of the other. By default it assumes the same value 
        as ``max_eps``. 
        Used only when ``cluster_method='dbscan'``. 
 
    xi : float between 0 and 1, default=0.05 
        Determines the minimum steepness on the reachability plot that 
        constitutes a cluster boundary. For example, an upwards point in the 
        reachability plot is defined by the ratio from one point to its 
        successor being at most 1-xi. 
        Used only when ``cluster_method='xi'``. 
 
    predecessor_correction : bool, default=True 
        Correct clusters according to the predecessors calculated by OPTICS 
        [2]_. This parameter has minimal effect on most datasets. 
        Used only when ``cluster_method='xi'``. 
 
    min_cluster_size : int &gt; 1 or float between 0 and 1, default=None 
        Minimum number of samples in an OPTICS cluster, expressed as an 
        absolute number or a fraction of the number of samples (rounded to be 
        at least 2). If ``None``, the value of ``min_samples`` is used instead. 
        Used only when ``cluster_method='xi'``. 
 
    algorithm : {'auto', 'ball_tree', 'kd_tree', 'brute'}, default='auto' 
        Algorithm used to compute the nearest neighbors: 
 
        - 'ball_tree' will use :class:`~sklearn.neighbors.BallTree`. 
        - 'kd_tree' will use :class:`~sklearn.neighbors.KDTree`. 
        - 'brute' will use a brute-force search. 
        - 'auto' (default) will attempt to decide the most appropriate 
          algorithm based on the values passed to :meth:`fit` method. 
 
        Note: fitting on sparse input will override the setting of 
        this parameter, using brute force. 
 
    leaf_size : int, default=30 
        Leaf size passed to :class:`~sklearn.neighbors.BallTree` or 
        :class:`~sklearn.neighbors.KDTree`. This can affect the speed of the 
        construction and query, as well as the memory required to store the 
        tree. The optimal value depends on the nature of the problem. 
 
    memory : str or object with the joblib.Memory interface, default=None 
        Used to cache the output of the computation of the tree. 
        By default, no caching is done. If a string is given, it is the 
        path to the caching directory. 
 
    n_jobs : int, default=None 
        The number of parallel jobs to run for neighbors search. 
        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context. 
        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;` 
        for more details. 
 
    Attributes 
    ---------- 
    labels_ : ndarray of shape (n_samples,) 
        Cluster labels for each point in the dataset given to fit(). 
        Noisy samples and points which are not included in a leaf cluster 
        of ``cluster_hierarchy_`` are labeled as -1. 
 
    reachability_ : ndarray of shape (n_samples,) 
        Reachability distances per sample, indexed by object order. Use 
        ``clust.reachability_[clust.ordering_]`` to access in cluster order. 
 
    ordering_ : ndarray of shape (n_samples,) 
        The cluster ordered list of sample indices. 
 
    core_distances_ : ndarray of shape (n_samples,) 
        Distance at which each sample becomes a core point, indexed by object 
        order. Points which will never be core have a distance of inf. Use 
        ``clust.core_distances_[clust.ordering_]`` to access in cluster order. 
 
    predecessor_ : ndarray of shape (n_samples,) 
        Point that a sample was reached from, indexed by object order. 
        Seed points have a predecessor of -1. 
 
    cluster_hierarchy_ : ndarray of shape (n_clusters, 2) 
        The list of clusters in the form of ``[start, end]`` in each row, with 
        all indices inclusive. The clusters are ordered according to 
        ``(end, -start)`` (ascending) so that larger clusters encompassing 
        smaller clusters come after those smaller ones. Since ``labels_`` does 
        not reflect the hierarchy, usually 
        ``len(cluster_hierarchy_) &gt; np.unique(optics.labels_)``. Please also 
        note that these indices are of the ``ordering_``, i.e. 
        ``X[ordering_][start:end + 1]`` form a cluster. 
        Only available when ``cluster_method='xi'``. 
 
    n_features_in_ : int 
        Number of features seen during :term:`fit`. 
 
        .. versionadded:: 0.24 
 
    feature_names_in_ : ndarray of shape (`n_features_in_`,) 
        Names of features seen during :term:`fit`. Defined only when `X` 
        has feature names that are all strings. 
 
        .. versionadded:: 1.0 
 
    See Also 
    -------- 
    DBSCAN : A similar clustering for a specified neighborhood radius (eps). 
        Our implementation is optimized for runtime. 
 
    References 
    ---------- 
    .. [1] Ankerst, Mihael, Markus M. Breunig, Hans-Peter Kriegel, 
       and Jörg Sander. &quot;OPTICS: ordering points to identify the clustering 
       structure.&quot; ACM SIGMOD Record 28, no. 2 (1999): 49-60. 
 
    .. [2] Schubert, Erich, Michael Gertz. 
       &quot;Improving the Cluster Structure Extracted from OPTICS Plots.&quot; Proc. of 
       the Conference &quot;Lernen, Wissen, Daten, Analysen&quot; (LWDA) (2018): 318-329. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.cluster import OPTICS 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; X = np.array([[1, 2], [2, 5], [3, 6], 
    ...               [8, 7], [8, 8], [7, 3]]) 
    &gt;&gt;&gt; clustering = OPTICS(min_samples=2).fit(X) 
    &gt;&gt;&gt; clustering.labels_ 
    array([0, 0, 0, 1, 1, 1]) 
 
    For a more detailed example see 
    :ref:`sphx_glr_auto_examples_cluster_plot_optics.py`. 
    &quot;&quot;&quot;</span>

    <span class="s1">_parameter_constraints: dict = {</span>
        <span class="s3">&quot;min_samples&quot;</span><span class="s1">: [</span>
            <span class="s1">Interval(Integral</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, None, </span><span class="s1">closed=</span><span class="s3">&quot;left&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">Interval(RealNotInt</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">closed=</span><span class="s3">&quot;both&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
        <span class="s3">&quot;max_eps&quot;</span><span class="s1">: [Interval(Real</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, None, </span><span class="s1">closed=</span><span class="s3">&quot;both&quot;</span><span class="s1">)]</span><span class="s2">,</span>
        <span class="s3">&quot;metric&quot;</span><span class="s1">: [StrOptions(set(_VALID_METRICS) | {</span><span class="s3">&quot;precomputed&quot;</span><span class="s1">})</span><span class="s2">, </span><span class="s1">callable]</span><span class="s2">,</span>
        <span class="s3">&quot;p&quot;</span><span class="s1">: [Interval(Real</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, None, </span><span class="s1">closed=</span><span class="s3">&quot;left&quot;</span><span class="s1">)]</span><span class="s2">,</span>
        <span class="s3">&quot;metric_params&quot;</span><span class="s1">: [dict</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s3">&quot;cluster_method&quot;</span><span class="s1">: [StrOptions({</span><span class="s3">&quot;dbscan&quot;</span><span class="s2">, </span><span class="s3">&quot;xi&quot;</span><span class="s1">})]</span><span class="s2">,</span>
        <span class="s3">&quot;eps&quot;</span><span class="s1">: [Interval(Real</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, None, </span><span class="s1">closed=</span><span class="s3">&quot;both&quot;</span><span class="s1">)</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s3">&quot;xi&quot;</span><span class="s1">: [Interval(Real</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">closed=</span><span class="s3">&quot;both&quot;</span><span class="s1">)]</span><span class="s2">,</span>
        <span class="s3">&quot;predecessor_correction&quot;</span><span class="s1">: [</span><span class="s3">&quot;boolean&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s3">&quot;min_cluster_size&quot;</span><span class="s1">: [</span>
            <span class="s1">Interval(Integral</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, None, </span><span class="s1">closed=</span><span class="s3">&quot;left&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">Interval(RealNotInt</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">closed=</span><span class="s3">&quot;right&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s2">None,</span>
        <span class="s1">]</span><span class="s2">,</span>
        <span class="s3">&quot;algorithm&quot;</span><span class="s1">: [StrOptions({</span><span class="s3">&quot;auto&quot;</span><span class="s2">, </span><span class="s3">&quot;brute&quot;</span><span class="s2">, </span><span class="s3">&quot;ball_tree&quot;</span><span class="s2">, </span><span class="s3">&quot;kd_tree&quot;</span><span class="s1">})]</span><span class="s2">,</span>
        <span class="s3">&quot;leaf_size&quot;</span><span class="s1">: [Interval(Integral</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, None, </span><span class="s1">closed=</span><span class="s3">&quot;left&quot;</span><span class="s1">)]</span><span class="s2">,</span>
        <span class="s3">&quot;memory&quot;</span><span class="s1">: [str</span><span class="s2">, </span><span class="s1">HasMethods(</span><span class="s3">&quot;cache&quot;</span><span class="s1">)</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s3">&quot;n_jobs&quot;</span><span class="s1">: [Integral</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">}</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">*</span><span class="s2">,</span>
        <span class="s1">min_samples=</span><span class="s4">5</span><span class="s2">,</span>
        <span class="s1">max_eps=np.inf</span><span class="s2">,</span>
        <span class="s1">metric=</span><span class="s3">&quot;minkowski&quot;</span><span class="s2">,</span>
        <span class="s1">p=</span><span class="s4">2</span><span class="s2">,</span>
        <span class="s1">metric_params=</span><span class="s2">None,</span>
        <span class="s1">cluster_method=</span><span class="s3">&quot;xi&quot;</span><span class="s2">,</span>
        <span class="s1">eps=</span><span class="s2">None,</span>
        <span class="s1">xi=</span><span class="s4">0.05</span><span class="s2">,</span>
        <span class="s1">predecessor_correction=</span><span class="s2">True,</span>
        <span class="s1">min_cluster_size=</span><span class="s2">None,</span>
        <span class="s1">algorithm=</span><span class="s3">&quot;auto&quot;</span><span class="s2">,</span>
        <span class="s1">leaf_size=</span><span class="s4">30</span><span class="s2">,</span>
        <span class="s1">memory=</span><span class="s2">None,</span>
        <span class="s1">n_jobs=</span><span class="s2">None,</span>
    <span class="s1">):</span>
        <span class="s1">self.max_eps = max_eps</span>
        <span class="s1">self.min_samples = min_samples</span>
        <span class="s1">self.min_cluster_size = min_cluster_size</span>
        <span class="s1">self.algorithm = algorithm</span>
        <span class="s1">self.metric = metric</span>
        <span class="s1">self.metric_params = metric_params</span>
        <span class="s1">self.p = p</span>
        <span class="s1">self.leaf_size = leaf_size</span>
        <span class="s1">self.cluster_method = cluster_method</span>
        <span class="s1">self.eps = eps</span>
        <span class="s1">self.xi = xi</span>
        <span class="s1">self.predecessor_correction = predecessor_correction</span>
        <span class="s1">self.memory = memory</span>
        <span class="s1">self.n_jobs = n_jobs</span>

    <span class="s1">@_fit_context(</span>
        <span class="s5"># Optics.metric is not validated yet</span>
        <span class="s1">prefer_skip_nested_validation=</span><span class="s2">False</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">fit(self</span><span class="s2">, </span><span class="s1">X</span><span class="s2">, </span><span class="s1">y=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Perform OPTICS clustering. 
 
        Extracts an ordered list of points and reachability distances, and 
        performs initial clustering using ``max_eps`` distance specified at 
        OPTICS object instantiation. 
 
        Parameters 
        ---------- 
        X : {ndarray, sparse matrix} of shape (n_samples, n_features), or \ 
                (n_samples, n_samples) if metric='precomputed' 
            A feature array, or array of distances between samples if 
            metric='precomputed'. If a sparse matrix is provided, it will be 
            converted into CSR format. 
 
        y : Ignored 
            Not used, present for API consistency by convention. 
 
        Returns 
        ------- 
        self : object 
            Returns a fitted instance of self. 
        &quot;&quot;&quot;</span>
        <span class="s1">dtype = bool </span><span class="s2">if </span><span class="s1">self.metric </span><span class="s2">in </span><span class="s1">PAIRWISE_BOOLEAN_FUNCTIONS </span><span class="s2">else </span><span class="s1">float</span>
        <span class="s2">if </span><span class="s1">dtype == bool </span><span class="s2">and </span><span class="s1">X.dtype != bool:</span>
            <span class="s1">msg = (</span>
                <span class="s3">&quot;Data will be converted to boolean for&quot;</span>
                <span class="s3">f&quot; metric </span><span class="s2">{</span><span class="s1">self.metric</span><span class="s2">}</span><span class="s3">, to avoid this warning,&quot;</span>
                <span class="s3">&quot; you may convert the data prior to calling fit.&quot;</span>
            <span class="s1">)</span>
            <span class="s1">warnings.warn(msg</span><span class="s2">, </span><span class="s1">DataConversionWarning)</span>

        <span class="s1">X = self._validate_data(X</span><span class="s2">, </span><span class="s1">dtype=dtype</span><span class="s2">, </span><span class="s1">accept_sparse=</span><span class="s3">&quot;csr&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.metric == </span><span class="s3">&quot;precomputed&quot; </span><span class="s2">and </span><span class="s1">issparse(X):</span>
            <span class="s2">with </span><span class="s1">warnings.catch_warnings():</span>
                <span class="s1">warnings.simplefilter(</span><span class="s3">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">SparseEfficiencyWarning)</span>
                <span class="s5"># Set each diagonal to an explicit value so each point is its</span>
                <span class="s5"># own neighbor</span>
                <span class="s1">X.setdiag(X.diagonal())</span>
        <span class="s1">memory = check_memory(self.memory)</span>

        <span class="s1">(</span>
            <span class="s1">self.ordering_</span><span class="s2">,</span>
            <span class="s1">self.core_distances_</span><span class="s2">,</span>
            <span class="s1">self.reachability_</span><span class="s2">,</span>
            <span class="s1">self.predecessor_</span><span class="s2">,</span>
        <span class="s1">) = memory.cache(compute_optics_graph)(</span>
            <span class="s1">X=X</span><span class="s2">,</span>
            <span class="s1">min_samples=self.min_samples</span><span class="s2">,</span>
            <span class="s1">algorithm=self.algorithm</span><span class="s2">,</span>
            <span class="s1">leaf_size=self.leaf_size</span><span class="s2">,</span>
            <span class="s1">metric=self.metric</span><span class="s2">,</span>
            <span class="s1">metric_params=self.metric_params</span><span class="s2">,</span>
            <span class="s1">p=self.p</span><span class="s2">,</span>
            <span class="s1">n_jobs=self.n_jobs</span><span class="s2">,</span>
            <span class="s1">max_eps=self.max_eps</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s5"># Extract clusters from the calculated orders and reachability</span>
        <span class="s2">if </span><span class="s1">self.cluster_method == </span><span class="s3">&quot;xi&quot;</span><span class="s1">:</span>
            <span class="s1">labels_</span><span class="s2">, </span><span class="s1">clusters_ = cluster_optics_xi(</span>
                <span class="s1">reachability=self.reachability_</span><span class="s2">,</span>
                <span class="s1">predecessor=self.predecessor_</span><span class="s2">,</span>
                <span class="s1">ordering=self.ordering_</span><span class="s2">,</span>
                <span class="s1">min_samples=self.min_samples</span><span class="s2">,</span>
                <span class="s1">min_cluster_size=self.min_cluster_size</span><span class="s2">,</span>
                <span class="s1">xi=self.xi</span><span class="s2">,</span>
                <span class="s1">predecessor_correction=self.predecessor_correction</span><span class="s2">,</span>
            <span class="s1">)</span>
            <span class="s1">self.cluster_hierarchy_ = clusters_</span>
        <span class="s2">elif </span><span class="s1">self.cluster_method == </span><span class="s3">&quot;dbscan&quot;</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.eps </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">eps = self.max_eps</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">eps = self.eps</span>

            <span class="s2">if </span><span class="s1">eps &gt; self.max_eps:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">&quot;Specify an epsilon smaller than %s. Got %s.&quot; </span><span class="s1">% (self.max_eps</span><span class="s2">, </span><span class="s1">eps)</span>
                <span class="s1">)</span>

            <span class="s1">labels_ = cluster_optics_dbscan(</span>
                <span class="s1">reachability=self.reachability_</span><span class="s2">,</span>
                <span class="s1">core_distances=self.core_distances_</span><span class="s2">,</span>
                <span class="s1">ordering=self.ordering_</span><span class="s2">,</span>
                <span class="s1">eps=eps</span><span class="s2">,</span>
            <span class="s1">)</span>

        <span class="s1">self.labels_ = labels_</span>
        <span class="s2">return </span><span class="s1">self</span>


<span class="s2">def </span><span class="s1">_validate_size(size</span><span class="s2">, </span><span class="s1">n_samples</span><span class="s2">, </span><span class="s1">param_name):</span>
    <span class="s2">if </span><span class="s1">size &gt; n_samples:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span>
            <span class="s3">&quot;%s must be no greater than the number of samples (%d). Got %d&quot;</span>
            <span class="s1">% (param_name</span><span class="s2">, </span><span class="s1">n_samples</span><span class="s2">, </span><span class="s1">size)</span>
        <span class="s1">)</span>


<span class="s5"># OPTICS helper functions</span>
<span class="s2">def </span><span class="s1">_compute_core_distances_(X</span><span class="s2">, </span><span class="s1">neighbors</span><span class="s2">, </span><span class="s1">min_samples</span><span class="s2">, </span><span class="s1">working_memory):</span>
    <span class="s0">&quot;&quot;&quot;Compute the k-th nearest neighbor of each sample. 
 
    Equivalent to neighbors.kneighbors(X, self.min_samples)[0][:, -1] 
    but with more memory efficiency. 
 
    Parameters 
    ---------- 
    X : array-like of shape (n_samples, n_features) 
        The data. 
    neighbors : NearestNeighbors instance 
        The fitted nearest neighbors estimator. 
    working_memory : int, default=None 
        The sought maximum memory for temporary distance matrix chunks. 
        When None (default), the value of 
        ``sklearn.get_config()['working_memory']`` is used. 
 
    Returns 
    ------- 
    core_distances : ndarray of shape (n_samples,) 
        Distance at which each sample becomes a core point. 
        Points which will never be core have a distance of inf. 
    &quot;&quot;&quot;</span>
    <span class="s1">n_samples = X.shape[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">core_distances = np.empty(n_samples)</span>
    <span class="s1">core_distances.fill(np.nan)</span>

    <span class="s1">chunk_n_rows = get_chunk_n_rows(</span>
        <span class="s1">row_bytes=</span><span class="s4">16 </span><span class="s1">* min_samples</span><span class="s2">, </span><span class="s1">max_n_rows=n_samples</span><span class="s2">, </span><span class="s1">working_memory=working_memory</span>
    <span class="s1">)</span>
    <span class="s1">slices = gen_batches(n_samples</span><span class="s2">, </span><span class="s1">chunk_n_rows)</span>
    <span class="s2">for </span><span class="s1">sl </span><span class="s2">in </span><span class="s1">slices:</span>
        <span class="s1">core_distances[sl] = neighbors.kneighbors(X[sl]</span><span class="s2">, </span><span class="s1">min_samples)[</span><span class="s4">0</span><span class="s1">][:</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s2">return </span><span class="s1">core_distances</span>


<span class="s1">@validate_params(</span>
    <span class="s1">{</span>
        <span class="s3">&quot;X&quot;</span><span class="s1">: [np.ndarray</span><span class="s2">, </span><span class="s3">&quot;sparse matrix&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s3">&quot;min_samples&quot;</span><span class="s1">: [</span>
            <span class="s1">Interval(Integral</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, None, </span><span class="s1">closed=</span><span class="s3">&quot;left&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">Interval(RealNotInt</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">closed=</span><span class="s3">&quot;both&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
        <span class="s3">&quot;max_eps&quot;</span><span class="s1">: [Interval(Real</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, None, </span><span class="s1">closed=</span><span class="s3">&quot;both&quot;</span><span class="s1">)]</span><span class="s2">,</span>
        <span class="s3">&quot;metric&quot;</span><span class="s1">: [StrOptions(set(_VALID_METRICS) | {</span><span class="s3">&quot;precomputed&quot;</span><span class="s1">})</span><span class="s2">, </span><span class="s1">callable]</span><span class="s2">,</span>
        <span class="s3">&quot;p&quot;</span><span class="s1">: [Interval(Real</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, None, </span><span class="s1">closed=</span><span class="s3">&quot;right&quot;</span><span class="s1">)</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s3">&quot;metric_params&quot;</span><span class="s1">: [dict</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s3">&quot;algorithm&quot;</span><span class="s1">: [StrOptions({</span><span class="s3">&quot;auto&quot;</span><span class="s2">, </span><span class="s3">&quot;brute&quot;</span><span class="s2">, </span><span class="s3">&quot;ball_tree&quot;</span><span class="s2">, </span><span class="s3">&quot;kd_tree&quot;</span><span class="s1">})]</span><span class="s2">,</span>
        <span class="s3">&quot;leaf_size&quot;</span><span class="s1">: [Interval(Integral</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, None, </span><span class="s1">closed=</span><span class="s3">&quot;left&quot;</span><span class="s1">)]</span><span class="s2">,</span>
        <span class="s3">&quot;n_jobs&quot;</span><span class="s1">: [Integral</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">prefer_skip_nested_validation=</span><span class="s2">False,  </span><span class="s5"># metric is not validated yet</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">compute_optics_graph(</span>
    <span class="s1">X</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">min_samples</span><span class="s2">, </span><span class="s1">max_eps</span><span class="s2">, </span><span class="s1">metric</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">metric_params</span><span class="s2">, </span><span class="s1">algorithm</span><span class="s2">, </span><span class="s1">leaf_size</span><span class="s2">, </span><span class="s1">n_jobs</span>
<span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Compute the OPTICS reachability graph. 
 
    Read more in the :ref:`User Guide &lt;optics&gt;`. 
 
    Parameters 
    ---------- 
    X : {ndarray, sparse matrix} of shape (n_samples, n_features), or \ 
            (n_samples, n_samples) if metric='precomputed' 
        A feature array, or array of distances between samples if 
        metric='precomputed'. 
 
    min_samples : int &gt; 1 or float between 0 and 1 
        The number of samples in a neighborhood for a point to be considered 
        as a core point. Expressed as an absolute number or a fraction of the 
        number of samples (rounded to be at least 2). 
 
    max_eps : float, default=np.inf 
        The maximum distance between two samples for one to be considered as 
        in the neighborhood of the other. Default value of ``np.inf`` will 
        identify clusters across all scales; reducing ``max_eps`` will result 
        in shorter run times. 
 
    metric : str or callable, default='minkowski' 
        Metric to use for distance computation. Any metric from scikit-learn 
        or scipy.spatial.distance can be used. 
 
        If metric is a callable function, it is called on each 
        pair of instances (rows) and the resulting value recorded. The callable 
        should take two arrays as input and return one value indicating the 
        distance between them. This works for Scipy's metrics, but is less 
        efficient than passing the metric name as a string. If metric is 
        &quot;precomputed&quot;, X is assumed to be a distance matrix and must be square. 
 
        Valid values for metric are: 
 
        - from scikit-learn: ['cityblock', 'cosine', 'euclidean', 'l1', 'l2', 
          'manhattan'] 
 
        - from scipy.spatial.distance: ['braycurtis', 'canberra', 'chebyshev', 
          'correlation', 'dice', 'hamming', 'jaccard', 'kulsinski', 
          'mahalanobis', 'minkowski', 'rogerstanimoto', 'russellrao', 
          'seuclidean', 'sokalmichener', 'sokalsneath', 'sqeuclidean', 
          'yule'] 
 
        See the documentation for scipy.spatial.distance for details on these 
        metrics. 
 
        .. note:: 
           `'kulsinski'` is deprecated from SciPy 1.9 and will be removed in SciPy 1.11. 
 
    p : float, default=2 
        Parameter for the Minkowski metric from 
        :class:`~sklearn.metrics.pairwise_distances`. When p = 1, this is 
        equivalent to using manhattan_distance (l1), and euclidean_distance 
        (l2) for p = 2. For arbitrary p, minkowski_distance (l_p) is used. 
 
    metric_params : dict, default=None 
        Additional keyword arguments for the metric function. 
 
    algorithm : {'auto', 'ball_tree', 'kd_tree', 'brute'}, default='auto' 
        Algorithm used to compute the nearest neighbors: 
 
        - 'ball_tree' will use :class:`~sklearn.neighbors.BallTree`. 
        - 'kd_tree' will use :class:`~sklearn.neighbors.KDTree`. 
        - 'brute' will use a brute-force search. 
        - 'auto' will attempt to decide the most appropriate algorithm 
          based on the values passed to `fit` method. (default) 
 
        Note: fitting on sparse input will override the setting of 
        this parameter, using brute force. 
 
    leaf_size : int, default=30 
        Leaf size passed to :class:`~sklearn.neighbors.BallTree` or 
        :class:`~sklearn.neighbors.KDTree`. This can affect the speed of the 
        construction and query, as well as the memory required to store the 
        tree. The optimal value depends on the nature of the problem. 
 
    n_jobs : int, default=None 
        The number of parallel jobs to run for neighbors search. 
        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context. 
        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;` 
        for more details. 
 
    Returns 
    ------- 
    ordering_ : array of shape (n_samples,) 
        The cluster ordered list of sample indices. 
 
    core_distances_ : array of shape (n_samples,) 
        Distance at which each sample becomes a core point, indexed by object 
        order. Points which will never be core have a distance of inf. Use 
        ``clust.core_distances_[clust.ordering_]`` to access in cluster order. 
 
    reachability_ : array of shape (n_samples,) 
        Reachability distances per sample, indexed by object order. Use 
        ``clust.reachability_[clust.ordering_]`` to access in cluster order. 
 
    predecessor_ : array of shape (n_samples,) 
        Point that a sample was reached from, indexed by object order. 
        Seed points have a predecessor of -1. 
 
    References 
    ---------- 
    .. [1] Ankerst, Mihael, Markus M. Breunig, Hans-Peter Kriegel, 
       and Jörg Sander. &quot;OPTICS: ordering points to identify the clustering 
       structure.&quot; ACM SIGMOD Record 28, no. 2 (1999): 49-60. 
    &quot;&quot;&quot;</span>
    <span class="s1">n_samples = X.shape[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">_validate_size(min_samples</span><span class="s2">, </span><span class="s1">n_samples</span><span class="s2">, </span><span class="s3">&quot;min_samples&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">min_samples &lt;= </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">min_samples = max(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">int(min_samples * n_samples))</span>

    <span class="s5"># Start all points as 'unprocessed' ##</span>
    <span class="s1">reachability_ = np.empty(n_samples)</span>
    <span class="s1">reachability_.fill(np.inf)</span>
    <span class="s1">predecessor_ = np.empty(n_samples</span><span class="s2">, </span><span class="s1">dtype=int)</span>
    <span class="s1">predecessor_.fill(-</span><span class="s4">1</span><span class="s1">)</span>

    <span class="s1">nbrs = NearestNeighbors(</span>
        <span class="s1">n_neighbors=min_samples</span><span class="s2">,</span>
        <span class="s1">algorithm=algorithm</span><span class="s2">,</span>
        <span class="s1">leaf_size=leaf_size</span><span class="s2">,</span>
        <span class="s1">metric=metric</span><span class="s2">,</span>
        <span class="s1">metric_params=metric_params</span><span class="s2">,</span>
        <span class="s1">p=p</span><span class="s2">,</span>
        <span class="s1">n_jobs=n_jobs</span><span class="s2">,</span>
    <span class="s1">)</span>

    <span class="s1">nbrs.fit(X)</span>
    <span class="s5"># Here we first do a kNN query for each point, this differs from</span>
    <span class="s5"># the original OPTICS that only used epsilon range queries.</span>
    <span class="s5"># TODO: handle working_memory somehow?</span>
    <span class="s1">core_distances_ = _compute_core_distances_(</span>
        <span class="s1">X=X</span><span class="s2">, </span><span class="s1">neighbors=nbrs</span><span class="s2">, </span><span class="s1">min_samples=min_samples</span><span class="s2">, </span><span class="s1">working_memory=</span><span class="s2">None</span>
    <span class="s1">)</span>
    <span class="s5"># OPTICS puts an upper limit on these, use inf for undefined.</span>
    <span class="s1">core_distances_[core_distances_ &gt; max_eps] = np.inf</span>
    <span class="s1">np.around(</span>
        <span class="s1">core_distances_</span><span class="s2">,</span>
        <span class="s1">decimals=np.finfo(core_distances_.dtype).precision</span><span class="s2">,</span>
        <span class="s1">out=core_distances_</span><span class="s2">,</span>
    <span class="s1">)</span>

    <span class="s5"># Main OPTICS loop. Not parallelizable. The order that entries are</span>
    <span class="s5"># written to the 'ordering_' list is important!</span>
    <span class="s5"># Note that this implementation is O(n^2) theoretically, but</span>
    <span class="s5"># supposedly with very low constant factors.</span>
    <span class="s1">processed = np.zeros(X.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=bool)</span>
    <span class="s1">ordering = np.zeros(X.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=int)</span>
    <span class="s2">for </span><span class="s1">ordering_idx </span><span class="s2">in </span><span class="s1">range(X.shape[</span><span class="s4">0</span><span class="s1">]):</span>
        <span class="s5"># Choose next based on smallest reachability distance</span>
        <span class="s5"># (And prefer smaller ids on ties, possibly np.inf!)</span>
        <span class="s1">index = np.where(processed == </span><span class="s4">0</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">point = index[np.argmin(reachability_[index])]</span>

        <span class="s1">processed[point] = </span><span class="s2">True</span>
        <span class="s1">ordering[ordering_idx] = point</span>
        <span class="s2">if </span><span class="s1">core_distances_[point] != np.inf:</span>
            <span class="s1">_set_reach_dist(</span>
                <span class="s1">core_distances_=core_distances_</span><span class="s2">,</span>
                <span class="s1">reachability_=reachability_</span><span class="s2">,</span>
                <span class="s1">predecessor_=predecessor_</span><span class="s2">,</span>
                <span class="s1">point_index=point</span><span class="s2">,</span>
                <span class="s1">processed=processed</span><span class="s2">,</span>
                <span class="s1">X=X</span><span class="s2">,</span>
                <span class="s1">nbrs=nbrs</span><span class="s2">,</span>
                <span class="s1">metric=metric</span><span class="s2">,</span>
                <span class="s1">metric_params=metric_params</span><span class="s2">,</span>
                <span class="s1">p=p</span><span class="s2">,</span>
                <span class="s1">max_eps=max_eps</span><span class="s2">,</span>
            <span class="s1">)</span>
    <span class="s2">if </span><span class="s1">np.all(np.isinf(reachability_)):</span>
        <span class="s1">warnings.warn(</span>
            <span class="s1">(</span>
                <span class="s3">&quot;All reachability values are inf. Set a larger&quot;</span>
                <span class="s3">&quot; max_eps or all data will be considered outliers.&quot;</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">UserWarning</span><span class="s2">,</span>
        <span class="s1">)</span>
    <span class="s2">return </span><span class="s1">ordering</span><span class="s2">, </span><span class="s1">core_distances_</span><span class="s2">, </span><span class="s1">reachability_</span><span class="s2">, </span><span class="s1">predecessor_</span>


<span class="s2">def </span><span class="s1">_set_reach_dist(</span>
    <span class="s1">core_distances_</span><span class="s2">,</span>
    <span class="s1">reachability_</span><span class="s2">,</span>
    <span class="s1">predecessor_</span><span class="s2">,</span>
    <span class="s1">point_index</span><span class="s2">,</span>
    <span class="s1">processed</span><span class="s2">,</span>
    <span class="s1">X</span><span class="s2">,</span>
    <span class="s1">nbrs</span><span class="s2">,</span>
    <span class="s1">metric</span><span class="s2">,</span>
    <span class="s1">metric_params</span><span class="s2">,</span>
    <span class="s1">p</span><span class="s2">,</span>
    <span class="s1">max_eps</span><span class="s2">,</span>
<span class="s1">):</span>
    <span class="s1">P = X[point_index : point_index + </span><span class="s4">1</span><span class="s1">]</span>
    <span class="s5"># Assume that radius_neighbors is faster without distances</span>
    <span class="s5"># and we don't need all distances, nevertheless, this means</span>
    <span class="s5"># we may be doing some work twice.</span>
    <span class="s1">indices = nbrs.radius_neighbors(P</span><span class="s2">, </span><span class="s1">radius=max_eps</span><span class="s2">, </span><span class="s1">return_distance=</span><span class="s2">False</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>

    <span class="s5"># Getting indices of neighbors that have not been processed</span>
    <span class="s1">unproc = np.compress(~np.take(processed</span><span class="s2">, </span><span class="s1">indices)</span><span class="s2">, </span><span class="s1">indices)</span>
    <span class="s5"># Neighbors of current point are already processed.</span>
    <span class="s2">if not </span><span class="s1">unproc.size:</span>
        <span class="s2">return</span>

    <span class="s5"># Only compute distances to unprocessed neighbors:</span>
    <span class="s2">if </span><span class="s1">metric == </span><span class="s3">&quot;precomputed&quot;</span><span class="s1">:</span>
        <span class="s1">dists = X[point_index</span><span class="s2">, </span><span class="s1">unproc]</span>
        <span class="s2">if </span><span class="s1">issparse(dists):</span>
            <span class="s1">dists.sort_indices()</span>
            <span class="s1">dists = dists.data</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">_params = dict() </span><span class="s2">if </span><span class="s1">metric_params </span><span class="s2">is None else </span><span class="s1">metric_params.copy()</span>
        <span class="s2">if </span><span class="s1">metric == </span><span class="s3">&quot;minkowski&quot; </span><span class="s2">and </span><span class="s3">&quot;p&quot; </span><span class="s2">not in </span><span class="s1">_params:</span>
            <span class="s5"># the same logic as neighbors, p is ignored if explicitly set</span>
            <span class="s5"># in the dict params</span>
            <span class="s1">_params[</span><span class="s3">&quot;p&quot;</span><span class="s1">] = p</span>
        <span class="s1">dists = pairwise_distances(P</span><span class="s2">, </span><span class="s1">X[unproc]</span><span class="s2">, </span><span class="s1">metric</span><span class="s2">, </span><span class="s1">n_jobs=</span><span class="s2">None, </span><span class="s1">**_params).ravel()</span>

    <span class="s1">rdists = np.maximum(dists</span><span class="s2">, </span><span class="s1">core_distances_[point_index])</span>
    <span class="s1">np.around(rdists</span><span class="s2">, </span><span class="s1">decimals=np.finfo(rdists.dtype).precision</span><span class="s2">, </span><span class="s1">out=rdists)</span>
    <span class="s1">improved = np.where(rdists &lt; np.take(reachability_</span><span class="s2">, </span><span class="s1">unproc))</span>
    <span class="s1">reachability_[unproc[improved]] = rdists[improved]</span>
    <span class="s1">predecessor_[unproc[improved]] = point_index</span>


<span class="s1">@validate_params(</span>
    <span class="s1">{</span>
        <span class="s3">&quot;reachability&quot;</span><span class="s1">: [np.ndarray]</span><span class="s2">,</span>
        <span class="s3">&quot;core_distances&quot;</span><span class="s1">: [np.ndarray]</span><span class="s2">,</span>
        <span class="s3">&quot;ordering&quot;</span><span class="s1">: [np.ndarray]</span><span class="s2">,</span>
        <span class="s3">&quot;eps&quot;</span><span class="s1">: [Interval(Real</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, None, </span><span class="s1">closed=</span><span class="s3">&quot;both&quot;</span><span class="s1">)]</span><span class="s2">,</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">prefer_skip_nested_validation=</span><span class="s2">True,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">cluster_optics_dbscan(*</span><span class="s2">, </span><span class="s1">reachability</span><span class="s2">, </span><span class="s1">core_distances</span><span class="s2">, </span><span class="s1">ordering</span><span class="s2">, </span><span class="s1">eps):</span>
    <span class="s0">&quot;&quot;&quot;Perform DBSCAN extraction for an arbitrary epsilon. 
 
    Extracting the clusters runs in linear time. Note that this results in 
    ``labels_`` which are close to a :class:`~sklearn.cluster.DBSCAN` with 
    similar settings and ``eps``, only if ``eps`` is close to ``max_eps``. 
 
    Parameters 
    ---------- 
    reachability : ndarray of shape (n_samples,) 
        Reachability distances calculated by OPTICS (``reachability_``). 
 
    core_distances : ndarray of shape (n_samples,) 
        Distances at which points become core (``core_distances_``). 
 
    ordering : ndarray of shape (n_samples,) 
        OPTICS ordered point indices (``ordering_``). 
 
    eps : float 
        DBSCAN ``eps`` parameter. Must be set to &lt; ``max_eps``. Results 
        will be close to DBSCAN algorithm if ``eps`` and ``max_eps`` are close 
        to one another. 
 
    Returns 
    ------- 
    labels_ : array of shape (n_samples,) 
        The estimated labels. 
    &quot;&quot;&quot;</span>
    <span class="s1">n_samples = len(core_distances)</span>
    <span class="s1">labels = np.zeros(n_samples</span><span class="s2">, </span><span class="s1">dtype=int)</span>

    <span class="s1">far_reach = reachability &gt; eps</span>
    <span class="s1">near_core = core_distances &lt;= eps</span>
    <span class="s1">labels[ordering] = np.cumsum(far_reach[ordering] &amp; near_core[ordering]) - </span><span class="s4">1</span>
    <span class="s1">labels[far_reach &amp; ~near_core] = -</span><span class="s4">1</span>
    <span class="s2">return </span><span class="s1">labels</span>


<span class="s1">@validate_params(</span>
    <span class="s1">{</span>
        <span class="s3">&quot;reachability&quot;</span><span class="s1">: [np.ndarray]</span><span class="s2">,</span>
        <span class="s3">&quot;predecessor&quot;</span><span class="s1">: [np.ndarray]</span><span class="s2">,</span>
        <span class="s3">&quot;ordering&quot;</span><span class="s1">: [np.ndarray]</span><span class="s2">,</span>
        <span class="s3">&quot;min_samples&quot;</span><span class="s1">: [</span>
            <span class="s1">Interval(Integral</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, None, </span><span class="s1">closed=</span><span class="s3">&quot;left&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">Interval(RealNotInt</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">closed=</span><span class="s3">&quot;both&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
        <span class="s3">&quot;min_cluster_size&quot;</span><span class="s1">: [</span>
            <span class="s1">Interval(Integral</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, None, </span><span class="s1">closed=</span><span class="s3">&quot;left&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">Interval(RealNotInt</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">closed=</span><span class="s3">&quot;both&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s2">None,</span>
        <span class="s1">]</span><span class="s2">,</span>
        <span class="s3">&quot;xi&quot;</span><span class="s1">: [Interval(Real</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">closed=</span><span class="s3">&quot;both&quot;</span><span class="s1">)]</span><span class="s2">,</span>
        <span class="s3">&quot;predecessor_correction&quot;</span><span class="s1">: [</span><span class="s3">&quot;boolean&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">prefer_skip_nested_validation=</span><span class="s2">True,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">cluster_optics_xi(</span>
    <span class="s1">*</span><span class="s2">,</span>
    <span class="s1">reachability</span><span class="s2">,</span>
    <span class="s1">predecessor</span><span class="s2">,</span>
    <span class="s1">ordering</span><span class="s2">,</span>
    <span class="s1">min_samples</span><span class="s2">,</span>
    <span class="s1">min_cluster_size=</span><span class="s2">None,</span>
    <span class="s1">xi=</span><span class="s4">0.05</span><span class="s2">,</span>
    <span class="s1">predecessor_correction=</span><span class="s2">True,</span>
<span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Automatically extract clusters according to the Xi-steep method. 
 
    Parameters 
    ---------- 
    reachability : ndarray of shape (n_samples,) 
        Reachability distances calculated by OPTICS (`reachability_`). 
 
    predecessor : ndarray of shape (n_samples,) 
        Predecessors calculated by OPTICS. 
 
    ordering : ndarray of shape (n_samples,) 
        OPTICS ordered point indices (`ordering_`). 
 
    min_samples : int &gt; 1 or float between 0 and 1 
        The same as the min_samples given to OPTICS. Up and down steep regions 
        can't have more then ``min_samples`` consecutive non-steep points. 
        Expressed as an absolute number or a fraction of the number of samples 
        (rounded to be at least 2). 
 
    min_cluster_size : int &gt; 1 or float between 0 and 1, default=None 
        Minimum number of samples in an OPTICS cluster, expressed as an 
        absolute number or a fraction of the number of samples (rounded to be 
        at least 2). If ``None``, the value of ``min_samples`` is used instead. 
 
    xi : float between 0 and 1, default=0.05 
        Determines the minimum steepness on the reachability plot that 
        constitutes a cluster boundary. For example, an upwards point in the 
        reachability plot is defined by the ratio from one point to its 
        successor being at most 1-xi. 
 
    predecessor_correction : bool, default=True 
        Correct clusters based on the calculated predecessors. 
 
    Returns 
    ------- 
    labels : ndarray of shape (n_samples,) 
        The labels assigned to samples. Points which are not included 
        in any cluster are labeled as -1. 
 
    clusters : ndarray of shape (n_clusters, 2) 
        The list of clusters in the form of ``[start, end]`` in each row, with 
        all indices inclusive. The clusters are ordered according to ``(end, 
        -start)`` (ascending) so that larger clusters encompassing smaller 
        clusters come after such nested smaller clusters. Since ``labels`` does 
        not reflect the hierarchy, usually ``len(clusters) &gt; 
        np.unique(labels)``. 
    &quot;&quot;&quot;</span>
    <span class="s1">n_samples = len(reachability)</span>
    <span class="s1">_validate_size(min_samples</span><span class="s2">, </span><span class="s1">n_samples</span><span class="s2">, </span><span class="s3">&quot;min_samples&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">min_samples &lt;= </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">min_samples = max(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">int(min_samples * n_samples))</span>
    <span class="s2">if </span><span class="s1">min_cluster_size </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">min_cluster_size = min_samples</span>
    <span class="s1">_validate_size(min_cluster_size</span><span class="s2">, </span><span class="s1">n_samples</span><span class="s2">, </span><span class="s3">&quot;min_cluster_size&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">min_cluster_size &lt;= </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">min_cluster_size = max(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">int(min_cluster_size * n_samples))</span>

    <span class="s1">clusters = _xi_cluster(</span>
        <span class="s1">reachability[ordering]</span><span class="s2">,</span>
        <span class="s1">predecessor[ordering]</span><span class="s2">,</span>
        <span class="s1">ordering</span><span class="s2">,</span>
        <span class="s1">xi</span><span class="s2">,</span>
        <span class="s1">min_samples</span><span class="s2">,</span>
        <span class="s1">min_cluster_size</span><span class="s2">,</span>
        <span class="s1">predecessor_correction</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">labels = _extract_xi_labels(ordering</span><span class="s2">, </span><span class="s1">clusters)</span>
    <span class="s2">return </span><span class="s1">labels</span><span class="s2">, </span><span class="s1">clusters</span>


<span class="s2">def </span><span class="s1">_extend_region(steep_point</span><span class="s2">, </span><span class="s1">xward_point</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">min_samples):</span>
    <span class="s0">&quot;&quot;&quot;Extend the area until it's maximal. 
 
    It's the same function for both upward and downward reagions, depending on 
    the given input parameters. Assuming: 
 
        - steep_{upward/downward}: bool array indicating whether a point is a 
          steep {upward/downward}; 
        - upward/downward: bool array indicating whether a point is 
          upward/downward; 
 
    To extend an upward reagion, ``steep_point=steep_upward`` and 
    ``xward_point=downward`` are expected, and to extend a downward region, 
    ``steep_point=steep_downward`` and ``xward_point=upward``. 
 
    Parameters 
    ---------- 
    steep_point : ndarray of shape (n_samples,), dtype=bool 
        True if the point is steep downward (upward). 
 
    xward_point : ndarray of shape (n_samples,), dtype=bool 
        True if the point is an upward (respectively downward) point. 
 
    start : int 
        The start of the xward region. 
 
    min_samples : int 
       The same as the min_samples given to OPTICS. Up and down steep 
       regions can't have more then ``min_samples`` consecutive non-steep 
       points. 
 
    Returns 
    ------- 
    index : int 
        The current index iterating over all the samples, i.e. where we are up 
        to in our search. 
 
    end : int 
        The end of the region, which can be behind the index. The region 
        includes the ``end`` index. 
    &quot;&quot;&quot;</span>
    <span class="s1">n_samples = len(steep_point)</span>
    <span class="s1">non_xward_points = </span><span class="s4">0</span>
    <span class="s1">index = start</span>
    <span class="s1">end = start</span>
    <span class="s5"># find a maximal area</span>
    <span class="s2">while </span><span class="s1">index &lt; n_samples:</span>
        <span class="s2">if </span><span class="s1">steep_point[index]:</span>
            <span class="s1">non_xward_points = </span><span class="s4">0</span>
            <span class="s1">end = index</span>
        <span class="s2">elif not </span><span class="s1">xward_point[index]:</span>
            <span class="s5"># it's not a steep point, but still goes up.</span>
            <span class="s1">non_xward_points += </span><span class="s4">1</span>
            <span class="s5"># region should include no more than min_samples consecutive</span>
            <span class="s5"># non steep xward points.</span>
            <span class="s2">if </span><span class="s1">non_xward_points &gt; min_samples:</span>
                <span class="s2">break</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">end</span>
        <span class="s1">index += </span><span class="s4">1</span>
    <span class="s2">return </span><span class="s1">end</span>


<span class="s2">def </span><span class="s1">_update_filter_sdas(sdas</span><span class="s2">, </span><span class="s1">mib</span><span class="s2">, </span><span class="s1">xi_complement</span><span class="s2">, </span><span class="s1">reachability_plot):</span>
    <span class="s0">&quot;&quot;&quot;Update steep down areas (SDAs) using the new maximum in between (mib) 
    value, and the given complement of xi, i.e. ``1 - xi``. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">np.isinf(mib):</span>
        <span class="s2">return </span><span class="s1">[]</span>
    <span class="s1">res = [</span>
        <span class="s1">sda </span><span class="s2">for </span><span class="s1">sda </span><span class="s2">in </span><span class="s1">sdas </span><span class="s2">if </span><span class="s1">mib &lt;= reachability_plot[sda[</span><span class="s3">&quot;start&quot;</span><span class="s1">]] * xi_complement</span>
    <span class="s1">]</span>
    <span class="s2">for </span><span class="s1">sda </span><span class="s2">in </span><span class="s1">res:</span>
        <span class="s1">sda[</span><span class="s3">&quot;mib&quot;</span><span class="s1">] = max(sda[</span><span class="s3">&quot;mib&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">mib)</span>
    <span class="s2">return </span><span class="s1">res</span>


<span class="s2">def </span><span class="s1">_correct_predecessor(reachability_plot</span><span class="s2">, </span><span class="s1">predecessor_plot</span><span class="s2">, </span><span class="s1">ordering</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">e):</span>
    <span class="s0">&quot;&quot;&quot;Correct for predecessors. 
 
    Applies Algorithm 2 of [1]_. 
 
    Input parameters are ordered by the computer OPTICS ordering. 
 
    .. [1] Schubert, Erich, Michael Gertz. 
       &quot;Improving the Cluster Structure Extracted from OPTICS Plots.&quot; Proc. of 
       the Conference &quot;Lernen, Wissen, Daten, Analysen&quot; (LWDA) (2018): 318-329. 
    &quot;&quot;&quot;</span>
    <span class="s2">while </span><span class="s1">s &lt; e:</span>
        <span class="s2">if </span><span class="s1">reachability_plot[s] &gt; reachability_plot[e]:</span>
            <span class="s2">return </span><span class="s1">s</span><span class="s2">, </span><span class="s1">e</span>
        <span class="s1">p_e = ordering[predecessor_plot[e]]</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(s</span><span class="s2">, </span><span class="s1">e):</span>
            <span class="s2">if </span><span class="s1">p_e == ordering[i]:</span>
                <span class="s2">return </span><span class="s1">s</span><span class="s2">, </span><span class="s1">e</span>
        <span class="s1">e -= </span><span class="s4">1</span>
    <span class="s2">return None, None</span>


<span class="s2">def </span><span class="s1">_xi_cluster(</span>
    <span class="s1">reachability_plot</span><span class="s2">,</span>
    <span class="s1">predecessor_plot</span><span class="s2">,</span>
    <span class="s1">ordering</span><span class="s2">,</span>
    <span class="s1">xi</span><span class="s2">,</span>
    <span class="s1">min_samples</span><span class="s2">,</span>
    <span class="s1">min_cluster_size</span><span class="s2">,</span>
    <span class="s1">predecessor_correction</span><span class="s2">,</span>
<span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Automatically extract clusters according to the Xi-steep method. 
 
    This is rouphly an implementation of Figure 19 of the OPTICS paper. 
 
    Parameters 
    ---------- 
    reachability_plot : array-like of shape (n_samples,) 
        The reachability plot, i.e. reachability ordered according to 
        the calculated ordering, all computed by OPTICS. 
 
    predecessor_plot : array-like of shape (n_samples,) 
        Predecessors ordered according to the calculated ordering. 
 
    xi : float, between 0 and 1 
        Determines the minimum steepness on the reachability plot that 
        constitutes a cluster boundary. For example, an upwards point in the 
        reachability plot is defined by the ratio from one point to its 
        successor being at most 1-xi. 
 
    min_samples : int &gt; 1 
        The same as the min_samples given to OPTICS. Up and down steep regions 
        can't have more then ``min_samples`` consecutive non-steep points. 
 
    min_cluster_size : int &gt; 1 
        Minimum number of samples in an OPTICS cluster. 
 
    predecessor_correction : bool 
        Correct clusters based on the calculated predecessors. 
 
    Returns 
    ------- 
    clusters : ndarray of shape (n_clusters, 2) 
        The list of clusters in the form of [start, end] in each row, with all 
        indices inclusive. The clusters are ordered in a way that larger 
        clusters encompassing smaller clusters come after those smaller 
        clusters. 
    &quot;&quot;&quot;</span>

    <span class="s5"># Our implementation adds an inf to the end of reachability plot</span>
    <span class="s5"># this helps to find potential clusters at the end of the</span>
    <span class="s5"># reachability plot even if there's no upward region at the end of it.</span>
    <span class="s1">reachability_plot = np.hstack((reachability_plot</span><span class="s2">, </span><span class="s1">np.inf))</span>

    <span class="s1">xi_complement = </span><span class="s4">1 </span><span class="s1">- xi</span>
    <span class="s1">sdas = []  </span><span class="s5"># steep down areas, introduced in section 4.3.2 of the paper</span>
    <span class="s1">clusters = []</span>
    <span class="s1">index = </span><span class="s4">0</span>
    <span class="s1">mib = </span><span class="s4">0.0  </span><span class="s5"># maximum in between, section 4.3.2</span>

    <span class="s5"># Our implementation corrects a mistake in the original</span>
    <span class="s5"># paper, i.e., in Definition 9 steep downward point,</span>
    <span class="s5"># r(p) * (1 - x1) &lt;= r(p + 1) should be</span>
    <span class="s5"># r(p) * (1 - x1) &gt;= r(p + 1)</span>
    <span class="s2">with </span><span class="s1">np.errstate(invalid=</span><span class="s3">&quot;ignore&quot;</span><span class="s1">):</span>
        <span class="s1">ratio = reachability_plot[:-</span><span class="s4">1</span><span class="s1">] / reachability_plot[</span><span class="s4">1</span><span class="s1">:]</span>
        <span class="s1">steep_upward = ratio &lt;= xi_complement</span>
        <span class="s1">steep_downward = ratio &gt;= </span><span class="s4">1 </span><span class="s1">/ xi_complement</span>
        <span class="s1">downward = ratio &gt; </span><span class="s4">1</span>
        <span class="s1">upward = ratio &lt; </span><span class="s4">1</span>

    <span class="s5"># the following loop is almost exactly as Figure 19 of the paper.</span>
    <span class="s5"># it jumps over the areas which are not either steep down or up areas</span>
    <span class="s2">for </span><span class="s1">steep_index </span><span class="s2">in </span><span class="s1">iter(np.flatnonzero(steep_upward | steep_downward)):</span>
        <span class="s5"># just continue if steep_index has been a part of a discovered xward</span>
        <span class="s5"># area.</span>
        <span class="s2">if </span><span class="s1">steep_index &lt; index:</span>
            <span class="s2">continue</span>

        <span class="s1">mib = max(mib</span><span class="s2">, </span><span class="s1">np.max(reachability_plot[index : steep_index + </span><span class="s4">1</span><span class="s1">]))</span>

        <span class="s5"># steep downward areas</span>
        <span class="s2">if </span><span class="s1">steep_downward[steep_index]:</span>
            <span class="s1">sdas = _update_filter_sdas(sdas</span><span class="s2">, </span><span class="s1">mib</span><span class="s2">, </span><span class="s1">xi_complement</span><span class="s2">, </span><span class="s1">reachability_plot)</span>
            <span class="s1">D_start = steep_index</span>
            <span class="s1">D_end = _extend_region(steep_downward</span><span class="s2">, </span><span class="s1">upward</span><span class="s2">, </span><span class="s1">D_start</span><span class="s2">, </span><span class="s1">min_samples)</span>
            <span class="s1">D = {</span><span class="s3">&quot;start&quot;</span><span class="s1">: D_start</span><span class="s2">, </span><span class="s3">&quot;end&quot;</span><span class="s1">: D_end</span><span class="s2">, </span><span class="s3">&quot;mib&quot;</span><span class="s1">: </span><span class="s4">0.0</span><span class="s1">}</span>
            <span class="s1">sdas.append(D)</span>
            <span class="s1">index = D_end + </span><span class="s4">1</span>
            <span class="s1">mib = reachability_plot[index]</span>

        <span class="s5"># steep upward areas</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">sdas = _update_filter_sdas(sdas</span><span class="s2">, </span><span class="s1">mib</span><span class="s2">, </span><span class="s1">xi_complement</span><span class="s2">, </span><span class="s1">reachability_plot)</span>
            <span class="s1">U_start = steep_index</span>
            <span class="s1">U_end = _extend_region(steep_upward</span><span class="s2">, </span><span class="s1">downward</span><span class="s2">, </span><span class="s1">U_start</span><span class="s2">, </span><span class="s1">min_samples)</span>
            <span class="s1">index = U_end + </span><span class="s4">1</span>
            <span class="s1">mib = reachability_plot[index]</span>

            <span class="s1">U_clusters = []</span>
            <span class="s2">for </span><span class="s1">D </span><span class="s2">in </span><span class="s1">sdas:</span>
                <span class="s1">c_start = D[</span><span class="s3">&quot;start&quot;</span><span class="s1">]</span>
                <span class="s1">c_end = U_end</span>

                <span class="s5"># line (**), sc2*</span>
                <span class="s2">if </span><span class="s1">reachability_plot[c_end + </span><span class="s4">1</span><span class="s1">] * xi_complement &lt; D[</span><span class="s3">&quot;mib&quot;</span><span class="s1">]:</span>
                    <span class="s2">continue</span>

                <span class="s5"># Definition 11: criterion 4</span>
                <span class="s1">D_max = reachability_plot[D[</span><span class="s3">&quot;start&quot;</span><span class="s1">]]</span>
                <span class="s2">if </span><span class="s1">D_max * xi_complement &gt;= reachability_plot[c_end + </span><span class="s4">1</span><span class="s1">]:</span>
                    <span class="s5"># Find the first index from the left side which is almost</span>
                    <span class="s5"># at the same level as the end of the detected cluster.</span>
                    <span class="s2">while </span><span class="s1">(</span>
                        <span class="s1">reachability_plot[c_start + </span><span class="s4">1</span><span class="s1">] &gt; reachability_plot[c_end + </span><span class="s4">1</span><span class="s1">]</span>
                        <span class="s2">and </span><span class="s1">c_start &lt; D[</span><span class="s3">&quot;end&quot;</span><span class="s1">]</span>
                    <span class="s1">):</span>
                        <span class="s1">c_start += </span><span class="s4">1</span>
                <span class="s2">elif </span><span class="s1">reachability_plot[c_end + </span><span class="s4">1</span><span class="s1">] * xi_complement &gt;= D_max:</span>
                    <span class="s5"># Find the first index from the right side which is almost</span>
                    <span class="s5"># at the same level as the beginning of the detected</span>
                    <span class="s5"># cluster.</span>
                    <span class="s5"># Our implementation corrects a mistake in the original</span>
                    <span class="s5"># paper, i.e., in Definition 11 4c, r(x) &lt; r(sD) should be</span>
                    <span class="s5"># r(x) &gt; r(sD).</span>
                    <span class="s2">while </span><span class="s1">reachability_plot[c_end - </span><span class="s4">1</span><span class="s1">] &gt; D_max </span><span class="s2">and </span><span class="s1">c_end &gt; U_start:</span>
                        <span class="s1">c_end -= </span><span class="s4">1</span>

                <span class="s5"># predecessor correction</span>
                <span class="s2">if </span><span class="s1">predecessor_correction:</span>
                    <span class="s1">c_start</span><span class="s2">, </span><span class="s1">c_end = _correct_predecessor(</span>
                        <span class="s1">reachability_plot</span><span class="s2">, </span><span class="s1">predecessor_plot</span><span class="s2">, </span><span class="s1">ordering</span><span class="s2">, </span><span class="s1">c_start</span><span class="s2">, </span><span class="s1">c_end</span>
                    <span class="s1">)</span>
                <span class="s2">if </span><span class="s1">c_start </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s2">continue</span>

                <span class="s5"># Definition 11: criterion 3.a</span>
                <span class="s2">if </span><span class="s1">c_end - c_start + </span><span class="s4">1 </span><span class="s1">&lt; min_cluster_size:</span>
                    <span class="s2">continue</span>

                <span class="s5"># Definition 11: criterion 1</span>
                <span class="s2">if </span><span class="s1">c_start &gt; D[</span><span class="s3">&quot;end&quot;</span><span class="s1">]:</span>
                    <span class="s2">continue</span>

                <span class="s5"># Definition 11: criterion 2</span>
                <span class="s2">if </span><span class="s1">c_end &lt; U_start:</span>
                    <span class="s2">continue</span>

                <span class="s1">U_clusters.append((c_start</span><span class="s2">, </span><span class="s1">c_end))</span>

            <span class="s5"># add smaller clusters first.</span>
            <span class="s1">U_clusters.reverse()</span>
            <span class="s1">clusters.extend(U_clusters)</span>

    <span class="s2">return </span><span class="s1">np.array(clusters)</span>


<span class="s2">def </span><span class="s1">_extract_xi_labels(ordering</span><span class="s2">, </span><span class="s1">clusters):</span>
    <span class="s0">&quot;&quot;&quot;Extracts the labels from the clusters returned by `_xi_cluster`. 
    We rely on the fact that clusters are stored 
    with the smaller clusters coming before the larger ones. 
 
    Parameters 
    ---------- 
    ordering : array-like of shape (n_samples,) 
        The ordering of points calculated by OPTICS 
 
    clusters : array-like of shape (n_clusters, 2) 
        List of clusters i.e. (start, end) tuples, 
        as returned by `_xi_cluster`. 
 
    Returns 
    ------- 
    labels : ndarray of shape (n_samples,) 
    &quot;&quot;&quot;</span>

    <span class="s1">labels = np.full(len(ordering)</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">dtype=int)</span>
    <span class="s1">label = </span><span class="s4">0</span>
    <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">clusters:</span>
        <span class="s2">if not </span><span class="s1">np.any(labels[c[</span><span class="s4">0</span><span class="s1">] : (c[</span><span class="s4">1</span><span class="s1">] + </span><span class="s4">1</span><span class="s1">)] != -</span><span class="s4">1</span><span class="s1">):</span>
            <span class="s1">labels[c[</span><span class="s4">0</span><span class="s1">] : (c[</span><span class="s4">1</span><span class="s1">] + </span><span class="s4">1</span><span class="s1">)] = label</span>
            <span class="s1">label += </span><span class="s4">1</span>
    <span class="s1">labels[ordering] = labels.copy()</span>
    <span class="s2">return </span><span class="s1">labels</span>
</pre>
</body>
</html>