<html>
<head>
<title>test_power.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_power.py</font>
</center></td></tr></table>
<pre><span class="s0"># -*- coding: utf-8 -*-</span>
<span class="s0"># pylint: disable=W0231, W0142</span>
<span class="s2">&quot;&quot;&quot;Tests for statistical power calculations 
 
Note: 
    tests for chisquare power are in test_gof.py 
 
Created on Sat Mar 09 08:44:49 2013 
 
Author: Josef Perktold 
&quot;&quot;&quot;</span>
<span class="s3">import </span><span class="s1">copy</span>
<span class="s3">import </span><span class="s1">warnings</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">from </span><span class="s1">numpy.testing </span><span class="s3">import </span><span class="s1">(assert_almost_equal</span><span class="s3">, </span><span class="s1">assert_allclose</span><span class="s3">, </span><span class="s1">assert_raises</span><span class="s3">,</span>
                           <span class="s1">assert_equal</span><span class="s3">, </span><span class="s1">assert_warns</span><span class="s3">, </span><span class="s1">assert_array_equal)</span>
<span class="s3">import </span><span class="s1">pytest</span>

<span class="s3">import </span><span class="s1">statsmodels.stats.power </span><span class="s3">as </span><span class="s1">smp</span>
<span class="s3">from </span><span class="s1">statsmodels.stats.tests.test_weightstats </span><span class="s3">import </span><span class="s1">Holder</span>
<span class="s3">from </span><span class="s1">statsmodels.tools.sm_exceptions </span><span class="s3">import </span><span class="s1">HypothesisTestWarning</span>

<span class="s3">try</span><span class="s1">:</span>
    <span class="s3">import </span><span class="s1">matplotlib.pyplot </span><span class="s3">as </span><span class="s1">plt  </span><span class="s0"># noqa:F401</span>
<span class="s3">except </span><span class="s1">ImportError:</span>
    <span class="s3">pass</span>


<span class="s3">class </span><span class="s1">CheckPowerMixin:</span>

    <span class="s3">def </span><span class="s1">test_power(self):</span>
        <span class="s0">#test against R results</span>
        <span class="s1">kwds = copy.copy(self.kwds)</span>
        <span class="s3">del </span><span class="s1">kwds[</span><span class="s4">'power'</span><span class="s1">]</span>
        <span class="s1">kwds.update(self.kwds_extra)</span>
        <span class="s3">if </span><span class="s1">hasattr(self</span><span class="s3">, </span><span class="s4">'decimal'</span><span class="s1">):</span>
            <span class="s1">decimal = self.decimal</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">decimal = </span><span class="s5">6</span>
        <span class="s1">res1 = self.cls()</span>
        <span class="s1">assert_almost_equal(res1.power(**kwds)</span><span class="s3">, </span><span class="s1">self.res2.power</span><span class="s3">, </span><span class="s1">decimal=decimal)</span>

    <span class="s0">#@pytest.mark.xfail(strict=True)</span>
    <span class="s3">def </span><span class="s1">test_positional(self):</span>

        <span class="s1">res1 = self.cls()</span>


        <span class="s1">kwds = copy.copy(self.kwds)</span>
        <span class="s3">del </span><span class="s1">kwds[</span><span class="s4">'power'</span><span class="s1">]</span>
        <span class="s1">kwds.update(self.kwds_extra)</span>

        <span class="s0"># positional args</span>
        <span class="s3">if </span><span class="s1">hasattr(self</span><span class="s3">, </span><span class="s4">'args_names'</span><span class="s1">):</span>
            <span class="s1">args_names = self.args_names</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">nobs_ = </span><span class="s4">'nobs' </span><span class="s3">if </span><span class="s4">'nobs' </span><span class="s3">in </span><span class="s1">kwds </span><span class="s3">else </span><span class="s4">'nobs1'</span>
            <span class="s1">args_names = [</span><span class="s4">'effect_size'</span><span class="s3">, </span><span class="s1">nobs_</span><span class="s3">, </span><span class="s4">'alpha'</span><span class="s1">]</span>

        <span class="s0"># pop positional args</span>
        <span class="s1">args = [kwds.pop(arg) </span><span class="s3">for </span><span class="s1">arg </span><span class="s3">in </span><span class="s1">args_names]</span>

        <span class="s3">if </span><span class="s1">hasattr(self</span><span class="s3">, </span><span class="s4">'decimal'</span><span class="s1">):</span>
            <span class="s1">decimal = self.decimal</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">decimal = </span><span class="s5">6</span>

        <span class="s1">res = res1.power(*args</span><span class="s3">, </span><span class="s1">**kwds)</span>
        <span class="s1">assert_almost_equal(res</span><span class="s3">, </span><span class="s1">self.res2.power</span><span class="s3">, </span><span class="s1">decimal=decimal)</span>

    <span class="s3">def </span><span class="s1">test_roots(self):</span>
        <span class="s1">kwds = copy.copy(self.kwds)</span>
        <span class="s1">kwds.update(self.kwds_extra)</span>

        <span class="s0"># kwds_extra are used as argument, but not as target for root</span>
        <span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">self.kwds:</span>
            <span class="s0"># keep print to check whether tests are really executed</span>
            <span class="s0">#print 'testing roots', key</span>
            <span class="s1">value = kwds[key]</span>
            <span class="s1">kwds[key] = </span><span class="s3">None</span>

            <span class="s1">result = self.cls().solve_power(**kwds)</span>
            <span class="s1">assert_allclose(result</span><span class="s3">, </span><span class="s1">value</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s5">0.001</span><span class="s3">, </span><span class="s1">err_msg=key+</span><span class="s4">' failed'</span><span class="s1">)</span>
            <span class="s0"># yield can be used to investigate specific errors</span>
            <span class="s0">#yield assert_allclose, result, value, 0.001, 0, key+' failed'</span>
            <span class="s1">kwds[key] = value  </span><span class="s0"># reset dict</span>

    <span class="s1">@pytest.mark.matplotlib</span>
    <span class="s3">def </span><span class="s1">test_power_plot(self</span><span class="s3">, </span><span class="s1">close_figures):</span>
        <span class="s3">if </span><span class="s1">self.cls </span><span class="s3">in </span><span class="s1">[smp.FTestPower</span><span class="s3">, </span><span class="s1">smp.FTestPowerF2]:</span>
            <span class="s1">pytest.skip(</span><span class="s4">'skip FTestPower plot_power'</span><span class="s1">)</span>
        <span class="s1">fig = plt.figure()</span>
        <span class="s1">ax = fig.add_subplot(</span><span class="s5">2</span><span class="s3">,</span><span class="s5">1</span><span class="s3">,</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">fig = self.cls().plot_power(dep_var=</span><span class="s4">'nobs'</span><span class="s3">,</span>
                                  <span class="s1">nobs= np.arange(</span><span class="s5">2</span><span class="s3">, </span><span class="s5">100</span><span class="s1">)</span><span class="s3">,</span>
                                  <span class="s1">effect_size=np.array([</span><span class="s5">0.1</span><span class="s3">, </span><span class="s5">0.2</span><span class="s3">, </span><span class="s5">0.3</span><span class="s3">, </span><span class="s5">0.5</span><span class="s3">, </span><span class="s5">1</span><span class="s1">])</span><span class="s3">,</span>
                                  <span class="s0">#alternative='larger',</span>
                                  <span class="s1">ax=ax</span><span class="s3">, </span><span class="s1">title=</span><span class="s4">'Power of t-Test'</span><span class="s3">,</span>
                                  <span class="s1">**self.kwds_extra)</span>
        <span class="s1">ax = fig.add_subplot(</span><span class="s5">2</span><span class="s3">,</span><span class="s5">1</span><span class="s3">,</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">self.cls().plot_power(dep_var=</span><span class="s4">'es'</span><span class="s3">,</span>
                              <span class="s1">nobs=np.array([</span><span class="s5">10</span><span class="s3">, </span><span class="s5">20</span><span class="s3">, </span><span class="s5">30</span><span class="s3">, </span><span class="s5">50</span><span class="s3">, </span><span class="s5">70</span><span class="s3">, </span><span class="s5">100</span><span class="s1">])</span><span class="s3">,</span>
                              <span class="s1">effect_size=np.linspace(</span><span class="s5">0.01</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">51</span><span class="s1">)</span><span class="s3">,</span>
                              <span class="s0">#alternative='larger',</span>
                              <span class="s1">ax=ax</span><span class="s3">, </span><span class="s1">title=</span><span class="s4">''</span><span class="s3">,</span>
                              <span class="s1">**self.kwds_extra)</span>

<span class="s0">#''' test cases</span>
<span class="s0">#one sample</span>
<span class="s0">#               two-sided one-sided</span>
<span class="s0">#large power     OneS1      OneS3</span>
<span class="s0">#small power     OneS2      OneS4</span>
<span class="s0">#</span>
<span class="s0">#two sample</span>
<span class="s0">#               two-sided one-sided</span>
<span class="s0">#large power     TwoS1       TwoS3</span>
<span class="s0">#small power     TwoS2       TwoS4</span>
<span class="s0">#small p, ratio  TwoS4       TwoS5</span>
<span class="s0">#'''</span>

<span class="s3">class </span><span class="s1">TestTTPowerOneS1(CheckPowerMixin):</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">setup_class(cls):</span>

        <span class="s0">#&gt; p = pwr.t.test(d=1,n=30,sig.level=0.05,type=&quot;two.sample&quot;,alternative=&quot;two.sided&quot;)</span>
        <span class="s0">#&gt; cat_items(p, prefix='tt_power2_1.')</span>
        <span class="s1">res2 = Holder()</span>
        <span class="s1">res2.n = </span><span class="s5">30</span>
        <span class="s1">res2.d = </span><span class="s5">1</span>
        <span class="s1">res2.sig_level = </span><span class="s5">0.05</span>
        <span class="s1">res2.power = </span><span class="s5">0.9995636009612725</span>
        <span class="s1">res2.alternative = </span><span class="s4">'two.sided'</span>
        <span class="s1">res2.note = </span><span class="s4">'NULL'</span>
        <span class="s1">res2.method = </span><span class="s4">'One-sample t test power calculation'</span>

        <span class="s1">cls.res2 = res2</span>
        <span class="s1">cls.kwds = {</span><span class="s4">'effect_size'</span><span class="s1">: res2.d</span><span class="s3">, </span><span class="s4">'nobs'</span><span class="s1">: res2.n</span><span class="s3">,</span>
                     <span class="s4">'alpha'</span><span class="s1">: res2.sig_level</span><span class="s3">, </span><span class="s4">'power'</span><span class="s1">:res2.power}</span>
        <span class="s1">cls.kwds_extra = {}</span>
        <span class="s1">cls.cls = smp.TTestPower</span>

<span class="s3">class </span><span class="s1">TestTTPowerOneS2(CheckPowerMixin):</span>
    <span class="s0"># case with small power</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">setup_class(cls):</span>

        <span class="s1">res2 = Holder()</span>
        <span class="s0">#&gt; p = pwr.t.test(d=0.2,n=20,sig.level=0.05,type=&quot;one.sample&quot;,alternative=&quot;two.sided&quot;)</span>
        <span class="s0">#&gt; cat_items(p, &quot;res2.&quot;)</span>
        <span class="s1">res2.n = </span><span class="s5">20</span>
        <span class="s1">res2.d = </span><span class="s5">0.2</span>
        <span class="s1">res2.sig_level = </span><span class="s5">0.05</span>
        <span class="s1">res2.power = </span><span class="s5">0.1359562887679666</span>
        <span class="s1">res2.alternative = </span><span class="s4">'two.sided'</span>
        <span class="s1">res2.note = </span><span class="s4">'''NULL'''</span>
        <span class="s1">res2.method = </span><span class="s4">'One-sample t test power calculation'</span>

        <span class="s1">cls.res2 = res2</span>
        <span class="s1">cls.kwds = {</span><span class="s4">'effect_size'</span><span class="s1">: res2.d</span><span class="s3">, </span><span class="s4">'nobs'</span><span class="s1">: res2.n</span><span class="s3">,</span>
                     <span class="s4">'alpha'</span><span class="s1">: res2.sig_level</span><span class="s3">, </span><span class="s4">'power'</span><span class="s1">:res2.power}</span>
        <span class="s1">cls.kwds_extra = {}</span>
        <span class="s1">cls.cls = smp.TTestPower</span>

<span class="s3">class </span><span class="s1">TestTTPowerOneS3(CheckPowerMixin):</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">setup_class(cls):</span>

        <span class="s1">res2 = Holder()</span>
        <span class="s0">#&gt; p = pwr.t.test(d=1,n=30,sig.level=0.05,type=&quot;one.sample&quot;,alternative=&quot;greater&quot;)</span>
        <span class="s0">#&gt; cat_items(p, prefix='tt_power1_1g.')</span>
        <span class="s1">res2.n = </span><span class="s5">30</span>
        <span class="s1">res2.d = </span><span class="s5">1</span>
        <span class="s1">res2.sig_level = </span><span class="s5">0.05</span>
        <span class="s1">res2.power = </span><span class="s5">0.999892010204909</span>
        <span class="s1">res2.alternative = </span><span class="s4">'greater'</span>
        <span class="s1">res2.note = </span><span class="s4">'NULL'</span>
        <span class="s1">res2.method = </span><span class="s4">'One-sample t test power calculation'</span>

        <span class="s1">cls.res2 = res2</span>
        <span class="s1">cls.kwds = {</span><span class="s4">'effect_size'</span><span class="s1">: res2.d</span><span class="s3">, </span><span class="s4">'nobs'</span><span class="s1">: res2.n</span><span class="s3">,</span>
                     <span class="s4">'alpha'</span><span class="s1">: res2.sig_level</span><span class="s3">, </span><span class="s4">'power'</span><span class="s1">: res2.power}</span>
        <span class="s1">cls.kwds_extra = {</span><span class="s4">'alternative'</span><span class="s1">: </span><span class="s4">'larger'</span><span class="s1">}</span>
        <span class="s1">cls.cls = smp.TTestPower</span>

<span class="s3">class </span><span class="s1">TestTTPowerOneS4(CheckPowerMixin):</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">setup_class(cls):</span>

        <span class="s1">res2 = Holder()</span>
        <span class="s0">#&gt; p = pwr.t.test(d=0.05,n=20,sig.level=0.05,type=&quot;one.sample&quot;,alternative=&quot;greater&quot;)</span>
        <span class="s0">#&gt; cat_items(p, &quot;res2.&quot;)</span>
        <span class="s1">res2.n = </span><span class="s5">20</span>
        <span class="s1">res2.d = </span><span class="s5">0.05</span>
        <span class="s1">res2.sig_level = </span><span class="s5">0.05</span>
        <span class="s1">res2.power = </span><span class="s5">0.0764888785042198</span>
        <span class="s1">res2.alternative = </span><span class="s4">'greater'</span>
        <span class="s1">res2.note = </span><span class="s4">'''NULL'''</span>
        <span class="s1">res2.method = </span><span class="s4">'One-sample t test power calculation'</span>

        <span class="s1">cls.res2 = res2</span>
        <span class="s1">cls.kwds = {</span><span class="s4">'effect_size'</span><span class="s1">: res2.d</span><span class="s3">, </span><span class="s4">'nobs'</span><span class="s1">: res2.n</span><span class="s3">,</span>
                     <span class="s4">'alpha'</span><span class="s1">: res2.sig_level</span><span class="s3">, </span><span class="s4">'power'</span><span class="s1">: res2.power}</span>
        <span class="s1">cls.kwds_extra = {</span><span class="s4">'alternative'</span><span class="s1">: </span><span class="s4">'larger'</span><span class="s1">}</span>
        <span class="s1">cls.cls = smp.TTestPower</span>

<span class="s3">class </span><span class="s1">TestTTPowerOneS5(CheckPowerMixin):</span>
    <span class="s0"># case one-sided less, not implemented yet</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">setup_class(cls):</span>

        <span class="s1">res2 = Holder()</span>
        <span class="s0">#&gt; p = pwr.t.test(d=0.2,n=20,sig.level=0.05,type=&quot;one.sample&quot;,alternative=&quot;less&quot;)</span>
        <span class="s0">#&gt; cat_items(p, &quot;res2.&quot;)</span>
        <span class="s1">res2.n = </span><span class="s5">20</span>
        <span class="s1">res2.d = </span><span class="s5">0.2</span>
        <span class="s1">res2.sig_level = </span><span class="s5">0.05</span>
        <span class="s1">res2.power = </span><span class="s5">0.006063932667926375</span>
        <span class="s1">res2.alternative = </span><span class="s4">'less'</span>
        <span class="s1">res2.note = </span><span class="s4">'''NULL'''</span>
        <span class="s1">res2.method = </span><span class="s4">'One-sample t test power calculation'</span>

        <span class="s1">cls.res2 = res2</span>
        <span class="s1">cls.kwds = {</span><span class="s4">'effect_size'</span><span class="s1">: res2.d</span><span class="s3">, </span><span class="s4">'nobs'</span><span class="s1">: res2.n</span><span class="s3">,</span>
                     <span class="s4">'alpha'</span><span class="s1">: res2.sig_level</span><span class="s3">, </span><span class="s4">'power'</span><span class="s1">: res2.power}</span>
        <span class="s1">cls.kwds_extra = {</span><span class="s4">'alternative'</span><span class="s1">: </span><span class="s4">'smaller'</span><span class="s1">}</span>
        <span class="s1">cls.cls = smp.TTestPower</span>

<span class="s3">class </span><span class="s1">TestTTPowerOneS6(CheckPowerMixin):</span>
    <span class="s0"># case one-sided less, negative effect size, not implemented yet</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">setup_class(cls):</span>

        <span class="s1">res2 = Holder()</span>
        <span class="s0">#&gt; p = pwr.t.test(d=-0.2,n=20,sig.level=0.05,type=&quot;one.sample&quot;,alternative=&quot;less&quot;)</span>
        <span class="s0">#&gt; cat_items(p, &quot;res2.&quot;)</span>
        <span class="s1">res2.n = </span><span class="s5">20</span>
        <span class="s1">res2.d = -</span><span class="s5">0.2</span>
        <span class="s1">res2.sig_level = </span><span class="s5">0.05</span>
        <span class="s1">res2.power = </span><span class="s5">0.21707518167191</span>
        <span class="s1">res2.alternative = </span><span class="s4">'less'</span>
        <span class="s1">res2.note = </span><span class="s4">'''NULL'''</span>
        <span class="s1">res2.method = </span><span class="s4">'One-sample t test power calculation'</span>

        <span class="s1">cls.res2 = res2</span>
        <span class="s1">cls.kwds = {</span><span class="s4">'effect_size'</span><span class="s1">: res2.d</span><span class="s3">, </span><span class="s4">'nobs'</span><span class="s1">: res2.n</span><span class="s3">,</span>
                     <span class="s4">'alpha'</span><span class="s1">: res2.sig_level</span><span class="s3">, </span><span class="s4">'power'</span><span class="s1">: res2.power}</span>
        <span class="s1">cls.kwds_extra = {</span><span class="s4">'alternative'</span><span class="s1">: </span><span class="s4">'smaller'</span><span class="s1">}</span>
        <span class="s1">cls.cls = smp.TTestPower</span>


<span class="s3">class </span><span class="s1">TestTTPowerTwoS1(CheckPowerMixin):</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">setup_class(cls):</span>

        <span class="s0">#&gt; p = pwr.t.test(d=1,n=30,sig.level=0.05,type=&quot;two.sample&quot;,alternative=&quot;two.sided&quot;)</span>
        <span class="s0">#&gt; cat_items(p, prefix='tt_power2_1.')</span>
        <span class="s1">res2 = Holder()</span>
        <span class="s1">res2.n = </span><span class="s5">30</span>
        <span class="s1">res2.d = </span><span class="s5">1</span>
        <span class="s1">res2.sig_level = </span><span class="s5">0.05</span>
        <span class="s1">res2.power = </span><span class="s5">0.967708258242517</span>
        <span class="s1">res2.alternative = </span><span class="s4">'two.sided'</span>
        <span class="s1">res2.note = </span><span class="s4">'n is number in *each* group'</span>
        <span class="s1">res2.method = </span><span class="s4">'Two-sample t test power calculation'</span>

        <span class="s1">cls.res2 = res2</span>
        <span class="s1">cls.kwds = {</span><span class="s4">'effect_size'</span><span class="s1">: res2.d</span><span class="s3">, </span><span class="s4">'nobs1'</span><span class="s1">: res2.n</span><span class="s3">,</span>
                     <span class="s4">'alpha'</span><span class="s1">: res2.sig_level</span><span class="s3">, </span><span class="s4">'power'</span><span class="s1">: res2.power</span><span class="s3">, </span><span class="s4">'ratio'</span><span class="s1">: </span><span class="s5">1</span><span class="s1">}</span>
        <span class="s1">cls.kwds_extra = {}</span>
        <span class="s1">cls.cls = smp.TTestIndPower</span>

<span class="s3">class </span><span class="s1">TestTTPowerTwoS2(CheckPowerMixin):</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">setup_class(cls):</span>

        <span class="s1">res2 = Holder()</span>
        <span class="s0">#&gt; p = pwr.t.test(d=0.1,n=20,sig.level=0.05,type=&quot;two.sample&quot;,alternative=&quot;two.sided&quot;)</span>
        <span class="s0">#&gt; cat_items(p, &quot;res2.&quot;)</span>
        <span class="s1">res2.n = </span><span class="s5">20</span>
        <span class="s1">res2.d = </span><span class="s5">0.1</span>
        <span class="s1">res2.sig_level = </span><span class="s5">0.05</span>
        <span class="s1">res2.power = </span><span class="s5">0.06095912465411235</span>
        <span class="s1">res2.alternative = </span><span class="s4">'two.sided'</span>
        <span class="s1">res2.note = </span><span class="s4">'n is number in *each* group'</span>
        <span class="s1">res2.method = </span><span class="s4">'Two-sample t test power calculation'</span>

        <span class="s1">cls.res2 = res2</span>
        <span class="s1">cls.kwds = {</span><span class="s4">'effect_size'</span><span class="s1">: res2.d</span><span class="s3">, </span><span class="s4">'nobs1'</span><span class="s1">: res2.n</span><span class="s3">,</span>
                     <span class="s4">'alpha'</span><span class="s1">: res2.sig_level</span><span class="s3">, </span><span class="s4">'power'</span><span class="s1">: res2.power</span><span class="s3">, </span><span class="s4">'ratio'</span><span class="s1">: </span><span class="s5">1</span><span class="s1">}</span>
        <span class="s1">cls.kwds_extra = {}</span>
        <span class="s1">cls.cls = smp.TTestIndPower</span>

<span class="s3">class </span><span class="s1">TestTTPowerTwoS3(CheckPowerMixin):</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">setup_class(cls):</span>

        <span class="s1">res2 = Holder()</span>
        <span class="s0">#&gt; p = pwr.t.test(d=1,n=30,sig.level=0.05,type=&quot;two.sample&quot;,alternative=&quot;greater&quot;)</span>
        <span class="s0">#&gt; cat_items(p, prefix='tt_power2_1g.')</span>
        <span class="s1">res2.n = </span><span class="s5">30</span>
        <span class="s1">res2.d = </span><span class="s5">1</span>
        <span class="s1">res2.sig_level = </span><span class="s5">0.05</span>
        <span class="s1">res2.power = </span><span class="s5">0.985459690251624</span>
        <span class="s1">res2.alternative = </span><span class="s4">'greater'</span>
        <span class="s1">res2.note = </span><span class="s4">'n is number in *each* group'</span>
        <span class="s1">res2.method = </span><span class="s4">'Two-sample t test power calculation'</span>

        <span class="s1">cls.res2 = res2</span>
        <span class="s1">cls.kwds = {</span><span class="s4">'effect_size'</span><span class="s1">: res2.d</span><span class="s3">, </span><span class="s4">'nobs1'</span><span class="s1">: res2.n</span><span class="s3">,</span>
                     <span class="s4">'alpha'</span><span class="s1">: res2.sig_level</span><span class="s3">, </span><span class="s4">'power'</span><span class="s1">:res2.power</span><span class="s3">, </span><span class="s4">'ratio'</span><span class="s1">: </span><span class="s5">1</span><span class="s1">}</span>
        <span class="s1">cls.kwds_extra = {</span><span class="s4">'alternative'</span><span class="s1">: </span><span class="s4">'larger'</span><span class="s1">}</span>
        <span class="s1">cls.cls = smp.TTestIndPower</span>

<span class="s3">class </span><span class="s1">TestTTPowerTwoS4(CheckPowerMixin):</span>
    <span class="s0"># case with small power</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">setup_class(cls):</span>

        <span class="s1">res2 = Holder()</span>
        <span class="s0">#&gt; p = pwr.t.test(d=0.01,n=30,sig.level=0.05,type=&quot;two.sample&quot;,alternative=&quot;greater&quot;)</span>
        <span class="s0">#&gt; cat_items(p, &quot;res2.&quot;)</span>
        <span class="s1">res2.n = </span><span class="s5">30</span>
        <span class="s1">res2.d = </span><span class="s5">0.01</span>
        <span class="s1">res2.sig_level = </span><span class="s5">0.05</span>
        <span class="s1">res2.power = </span><span class="s5">0.0540740302835667</span>
        <span class="s1">res2.alternative = </span><span class="s4">'greater'</span>
        <span class="s1">res2.note = </span><span class="s4">'n is number in *each* group'</span>
        <span class="s1">res2.method = </span><span class="s4">'Two-sample t test power calculation'</span>

        <span class="s1">cls.res2 = res2</span>
        <span class="s1">cls.kwds = {</span><span class="s4">'effect_size'</span><span class="s1">: res2.d</span><span class="s3">, </span><span class="s4">'nobs1'</span><span class="s1">: res2.n</span><span class="s3">,</span>
                     <span class="s4">'alpha'</span><span class="s1">: res2.sig_level</span><span class="s3">, </span><span class="s4">'power'</span><span class="s1">:res2.power}</span>
        <span class="s1">cls.kwds_extra = {</span><span class="s4">'alternative'</span><span class="s1">: </span><span class="s4">'larger'</span><span class="s1">}</span>
        <span class="s1">cls.cls = smp.TTestIndPower</span>

<span class="s3">class </span><span class="s1">TestTTPowerTwoS5(CheckPowerMixin):</span>
    <span class="s0"># case with unequal n, ratio&gt;1</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">setup_class(cls):</span>

        <span class="s1">res2 = Holder()</span>
        <span class="s0">#&gt; p = pwr.t2n.test(d=0.1,n1=20, n2=30,sig.level=0.05,alternative=&quot;two.sided&quot;)</span>
        <span class="s0">#&gt; cat_items(p, &quot;res2.&quot;)</span>
        <span class="s1">res2.n1 = </span><span class="s5">20</span>
        <span class="s1">res2.n2 = </span><span class="s5">30</span>
        <span class="s1">res2.d = </span><span class="s5">0.1</span>
        <span class="s1">res2.sig_level = </span><span class="s5">0.05</span>
        <span class="s1">res2.power = </span><span class="s5">0.0633081832564667</span>
        <span class="s1">res2.alternative = </span><span class="s4">'two.sided'</span>
        <span class="s1">res2.method = </span><span class="s4">'t test power calculation'</span>

        <span class="s1">cls.res2 = res2</span>
        <span class="s1">cls.kwds = {</span><span class="s4">'effect_size'</span><span class="s1">: res2.d</span><span class="s3">, </span><span class="s4">'nobs1'</span><span class="s1">: res2.n1</span><span class="s3">,</span>
                     <span class="s4">'alpha'</span><span class="s1">: res2.sig_level</span><span class="s3">, </span><span class="s4">'power'</span><span class="s1">:res2.power</span><span class="s3">, </span><span class="s4">'ratio'</span><span class="s1">: </span><span class="s5">1.5</span><span class="s1">}</span>
        <span class="s1">cls.kwds_extra = {</span><span class="s4">'alternative'</span><span class="s1">: </span><span class="s4">'two-sided'</span><span class="s1">}</span>
        <span class="s1">cls.cls = smp.TTestIndPower</span>

<span class="s3">class </span><span class="s1">TestTTPowerTwoS6(CheckPowerMixin):</span>
    <span class="s0"># case with unequal n, ratio&gt;1</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">setup_class(cls):</span>

        <span class="s1">res2 = Holder()</span>
        <span class="s0">#&gt; p = pwr.t2n.test(d=0.1,n1=20, n2=30,sig.level=0.05,alternative=&quot;greater&quot;)</span>
        <span class="s0">#&gt; cat_items(p, &quot;res2.&quot;)</span>
        <span class="s1">res2.n1 = </span><span class="s5">20</span>
        <span class="s1">res2.n2 = </span><span class="s5">30</span>
        <span class="s1">res2.d = </span><span class="s5">0.1</span>
        <span class="s1">res2.sig_level = </span><span class="s5">0.05</span>
        <span class="s1">res2.power = </span><span class="s5">0.09623589080917805</span>
        <span class="s1">res2.alternative = </span><span class="s4">'greater'</span>
        <span class="s1">res2.method = </span><span class="s4">'t test power calculation'</span>

        <span class="s1">cls.res2 = res2</span>
        <span class="s1">cls.kwds = {</span><span class="s4">'effect_size'</span><span class="s1">: res2.d</span><span class="s3">, </span><span class="s4">'nobs1'</span><span class="s1">: res2.n1</span><span class="s3">,</span>
                     <span class="s4">'alpha'</span><span class="s1">: res2.sig_level</span><span class="s3">, </span><span class="s4">'power'</span><span class="s1">:res2.power</span><span class="s3">, </span><span class="s4">'ratio'</span><span class="s1">: </span><span class="s5">1.5</span><span class="s1">}</span>
        <span class="s1">cls.kwds_extra = {</span><span class="s4">'alternative'</span><span class="s1">: </span><span class="s4">'larger'</span><span class="s1">}</span>
        <span class="s1">cls.cls = smp.TTestIndPower</span>



<span class="s3">def </span><span class="s1">test_normal_power_explicit():</span>
    <span class="s0"># a few initial test cases for NormalIndPower</span>
    <span class="s1">sigma = </span><span class="s5">1</span>
    <span class="s1">d = </span><span class="s5">0.3</span>
    <span class="s1">nobs = </span><span class="s5">80</span>
    <span class="s1">alpha = </span><span class="s5">0.05</span>
    <span class="s1">res1 = smp.normal_power(d</span><span class="s3">, </span><span class="s1">nobs/</span><span class="s5">2.</span><span class="s3">, </span><span class="s5">0.05</span><span class="s1">)</span>
    <span class="s1">res2 = smp.NormalIndPower().power(d</span><span class="s3">, </span><span class="s1">nobs</span><span class="s3">, </span><span class="s5">0.05</span><span class="s1">)</span>
    <span class="s1">res3 = smp.NormalIndPower().solve_power(effect_size=</span><span class="s5">0.3</span><span class="s3">, </span><span class="s1">nobs1=</span><span class="s5">80</span><span class="s3">, </span><span class="s1">alpha=</span><span class="s5">0.05</span><span class="s3">, </span><span class="s1">power=</span><span class="s3">None</span><span class="s1">)</span>
    <span class="s1">res_R = </span><span class="s5">0.475100870572638</span>
    <span class="s1">assert_almost_equal(res1</span><span class="s3">, </span><span class="s1">res_R</span><span class="s3">, </span><span class="s1">decimal=</span><span class="s5">13</span><span class="s1">)</span>
    <span class="s1">assert_almost_equal(res2</span><span class="s3">, </span><span class="s1">res_R</span><span class="s3">, </span><span class="s1">decimal=</span><span class="s5">13</span><span class="s1">)</span>
    <span class="s1">assert_almost_equal(res3</span><span class="s3">, </span><span class="s1">res_R</span><span class="s3">, </span><span class="s1">decimal=</span><span class="s5">13</span><span class="s1">)</span>


    <span class="s1">norm_pow = smp.normal_power(-</span><span class="s5">0.01</span><span class="s3">, </span><span class="s1">nobs/</span><span class="s5">2.</span><span class="s3">, </span><span class="s5">0.05</span><span class="s1">)</span>
    <span class="s1">norm_pow_R = </span><span class="s5">0.05045832927039234</span>
    <span class="s0">#value from R: &gt;pwr.2p.test(h=0.01,n=80,sig.level=0.05,alternative=&quot;two.sided&quot;)</span>
    <span class="s1">assert_almost_equal(norm_pow</span><span class="s3">, </span><span class="s1">norm_pow_R</span><span class="s3">, </span><span class="s1">decimal=</span><span class="s5">11</span><span class="s1">)</span>

    <span class="s1">norm_pow = smp.NormalIndPower().power(</span><span class="s5">0.01</span><span class="s3">, </span><span class="s1">nobs</span><span class="s3">, </span><span class="s5">0.05</span><span class="s3">,</span>
                                          <span class="s1">alternative=</span><span class="s4">&quot;larger&quot;</span><span class="s1">)</span>
    <span class="s1">norm_pow_R = </span><span class="s5">0.056869534873146124</span>
    <span class="s0">#value from R: &gt;pwr.2p.test(h=0.01,n=80,sig.level=0.05,alternative=&quot;greater&quot;)</span>
    <span class="s1">assert_almost_equal(norm_pow</span><span class="s3">, </span><span class="s1">norm_pow_R</span><span class="s3">, </span><span class="s1">decimal=</span><span class="s5">11</span><span class="s1">)</span>

    <span class="s0"># Note: negative effect size is same as switching one-sided alternative</span>
    <span class="s0"># TODO: should I switch to larger/smaller instead of &quot;one-sided&quot; options</span>
    <span class="s1">norm_pow = smp.NormalIndPower().power(-</span><span class="s5">0.01</span><span class="s3">, </span><span class="s1">nobs</span><span class="s3">, </span><span class="s5">0.05</span><span class="s3">,</span>
                                          <span class="s1">alternative=</span><span class="s4">&quot;larger&quot;</span><span class="s1">)</span>
    <span class="s1">norm_pow_R = </span><span class="s5">0.0438089705093578</span>
    <span class="s0">#value from R: &gt;pwr.2p.test(h=0.01,n=80,sig.level=0.05,alternative=&quot;less&quot;)</span>
    <span class="s1">assert_almost_equal(norm_pow</span><span class="s3">, </span><span class="s1">norm_pow_R</span><span class="s3">, </span><span class="s1">decimal=</span><span class="s5">11</span><span class="s1">)</span>

<span class="s3">class </span><span class="s1">TestNormalIndPower1(CheckPowerMixin):</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">setup_class(cls):</span>
        <span class="s0">#&gt; example from above</span>
        <span class="s0"># results copied not directly from R</span>
        <span class="s1">res2 = Holder()</span>
        <span class="s1">res2.n = </span><span class="s5">80</span>
        <span class="s1">res2.d = </span><span class="s5">0.3</span>
        <span class="s1">res2.sig_level = </span><span class="s5">0.05</span>
        <span class="s1">res2.power = </span><span class="s5">0.475100870572638</span>
        <span class="s1">res2.alternative = </span><span class="s4">'two.sided'</span>
        <span class="s1">res2.note = </span><span class="s4">'NULL'</span>
        <span class="s1">res2.method = </span><span class="s4">'two sample power calculation'</span>

        <span class="s1">cls.res2 = res2</span>
        <span class="s1">cls.kwds = {</span><span class="s4">'effect_size'</span><span class="s1">: res2.d</span><span class="s3">, </span><span class="s4">'nobs1'</span><span class="s1">: res2.n</span><span class="s3">,</span>
                     <span class="s4">'alpha'</span><span class="s1">: res2.sig_level</span><span class="s3">, </span><span class="s4">'power'</span><span class="s1">:res2.power</span><span class="s3">, </span><span class="s4">'ratio'</span><span class="s1">: </span><span class="s5">1</span><span class="s1">}</span>
        <span class="s1">cls.kwds_extra = {}</span>
        <span class="s1">cls.cls = smp.NormalIndPower</span>

<span class="s3">class </span><span class="s1">TestNormalIndPower2(CheckPowerMixin):</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">res2 = Holder()</span>
        <span class="s0">#&gt; np = pwr.2p.test(h=0.01,n=80,sig.level=0.05,alternative=&quot;less&quot;)</span>
        <span class="s0">#&gt; cat_items(np, &quot;res2.&quot;)</span>
        <span class="s1">res2.h = </span><span class="s5">0.01</span>
        <span class="s1">res2.n = </span><span class="s5">80</span>
        <span class="s1">res2.sig_level = </span><span class="s5">0.05</span>
        <span class="s1">res2.power = </span><span class="s5">0.0438089705093578</span>
        <span class="s1">res2.alternative = </span><span class="s4">'less'</span>
        <span class="s1">res2.method = (</span><span class="s4">'Difference of proportion power calculation for' </span><span class="s1">+</span>
                      <span class="s4">' binomial distribution (arcsine transformation)'</span><span class="s1">)</span>
        <span class="s1">res2.note = </span><span class="s4">'same sample sizes'</span>

        <span class="s1">cls.res2 = res2</span>
        <span class="s1">cls.kwds = {</span><span class="s4">'effect_size'</span><span class="s1">: res2.h</span><span class="s3">, </span><span class="s4">'nobs1'</span><span class="s1">: res2.n</span><span class="s3">,</span>
                     <span class="s4">'alpha'</span><span class="s1">: res2.sig_level</span><span class="s3">, </span><span class="s4">'power'</span><span class="s1">:res2.power</span><span class="s3">, </span><span class="s4">'ratio'</span><span class="s1">: </span><span class="s5">1</span><span class="s1">}</span>
        <span class="s1">cls.kwds_extra = {</span><span class="s4">'alternative'</span><span class="s1">:</span><span class="s4">'smaller'</span><span class="s1">}</span>
        <span class="s1">cls.cls = smp.NormalIndPower</span>


<span class="s3">class </span><span class="s1">TestNormalIndPower_onesamp1(CheckPowerMixin):</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">setup_class(cls):</span>
        <span class="s0"># forcing one-sample by using ratio=0</span>
        <span class="s0">#&gt; example from above</span>
        <span class="s0"># results copied not directly from R</span>
        <span class="s1">res2 = Holder()</span>
        <span class="s1">res2.n = </span><span class="s5">40</span>
        <span class="s1">res2.d = </span><span class="s5">0.3</span>
        <span class="s1">res2.sig_level = </span><span class="s5">0.05</span>
        <span class="s1">res2.power = </span><span class="s5">0.475100870572638</span>
        <span class="s1">res2.alternative = </span><span class="s4">'two.sided'</span>
        <span class="s1">res2.note = </span><span class="s4">'NULL'</span>
        <span class="s1">res2.method = </span><span class="s4">'two sample power calculation'</span>

        <span class="s1">cls.res2 = res2</span>
        <span class="s1">cls.kwds = {</span><span class="s4">'effect_size'</span><span class="s1">: res2.d</span><span class="s3">, </span><span class="s4">'nobs1'</span><span class="s1">: res2.n</span><span class="s3">,</span>
                     <span class="s4">'alpha'</span><span class="s1">: res2.sig_level</span><span class="s3">, </span><span class="s4">'power'</span><span class="s1">:res2.power}</span>
        <span class="s0"># keyword for which we do not look for root:</span>
        <span class="s1">cls.kwds_extra = {</span><span class="s4">'ratio'</span><span class="s1">: </span><span class="s5">0</span><span class="s1">}</span>

        <span class="s1">cls.cls = smp.NormalIndPower</span>

<span class="s3">class </span><span class="s1">TestNormalIndPower_onesamp2(CheckPowerMixin):</span>
    <span class="s0"># Note: same power as two sample case with twice as many observations</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">setup_class(cls):</span>
        <span class="s0"># forcing one-sample by using ratio=0</span>
        <span class="s1">res2 = Holder()</span>
        <span class="s0">#&gt; np = pwr.norm.test(d=0.01,n=40,sig.level=0.05,alternative=&quot;less&quot;)</span>
        <span class="s0">#&gt; cat_items(np, &quot;res2.&quot;)</span>
        <span class="s1">res2.d = </span><span class="s5">0.01</span>
        <span class="s1">res2.n = </span><span class="s5">40</span>
        <span class="s1">res2.sig_level = </span><span class="s5">0.05</span>
        <span class="s1">res2.power = </span><span class="s5">0.0438089705093578</span>
        <span class="s1">res2.alternative = </span><span class="s4">'less'</span>
        <span class="s1">res2.method = </span><span class="s4">'Mean power calculation for normal distribution with known variance'</span>

        <span class="s1">cls.res2 = res2</span>
        <span class="s1">cls.kwds = {</span><span class="s4">'effect_size'</span><span class="s1">: res2.d</span><span class="s3">, </span><span class="s4">'nobs1'</span><span class="s1">: res2.n</span><span class="s3">,</span>
                     <span class="s4">'alpha'</span><span class="s1">: res2.sig_level</span><span class="s3">, </span><span class="s4">'power'</span><span class="s1">:res2.power}</span>
        <span class="s0"># keyword for which we do not look for root:</span>
        <span class="s1">cls.kwds_extra = {</span><span class="s4">'ratio'</span><span class="s1">: </span><span class="s5">0</span><span class="s3">, </span><span class="s4">'alternative'</span><span class="s1">:</span><span class="s4">'smaller'</span><span class="s1">}</span>

        <span class="s1">cls.cls = smp.NormalIndPower</span>



<span class="s3">class </span><span class="s1">TestChisquarePower(CheckPowerMixin):</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">setup_class(cls):</span>
        <span class="s0"># one example from test_gof, results_power</span>
        <span class="s1">res2 = Holder()</span>
        <span class="s1">res2.w = </span><span class="s5">0.1</span>
        <span class="s1">res2.N = </span><span class="s5">5</span>
        <span class="s1">res2.df = </span><span class="s5">4</span>
        <span class="s1">res2.sig_level = </span><span class="s5">0.05</span>
        <span class="s1">res2.power = </span><span class="s5">0.05246644635810126</span>
        <span class="s1">res2.method = </span><span class="s4">'Chi squared power calculation'</span>
        <span class="s1">res2.note = </span><span class="s4">'N is the number of observations'</span>

        <span class="s1">cls.res2 = res2</span>
        <span class="s1">cls.kwds = {</span><span class="s4">'effect_size'</span><span class="s1">: res2.w</span><span class="s3">, </span><span class="s4">'nobs'</span><span class="s1">: res2.N</span><span class="s3">,</span>
                     <span class="s4">'alpha'</span><span class="s1">: res2.sig_level</span><span class="s3">, </span><span class="s4">'power'</span><span class="s1">:res2.power}</span>
        <span class="s0"># keyword for which we do not look for root:</span>
        <span class="s0"># solving for n_bins does not work, will not be used in regular usage</span>
        <span class="s1">cls.kwds_extra = {</span><span class="s4">'n_bins'</span><span class="s1">: res2.df + </span><span class="s5">1</span><span class="s1">}</span>

        <span class="s1">cls.cls = smp.GofChisquarePower</span>

    <span class="s3">def </span><span class="s1">test_positional(self):</span>

        <span class="s1">res1 = self.cls()</span>
        <span class="s1">args_names = [</span><span class="s4">'effect_size'</span><span class="s3">,</span><span class="s4">'nobs'</span><span class="s3">, </span><span class="s4">'alpha'</span><span class="s3">, </span><span class="s4">'n_bins'</span><span class="s1">]</span>
        <span class="s1">kwds = copy.copy(self.kwds)</span>
        <span class="s3">del </span><span class="s1">kwds[</span><span class="s4">'power'</span><span class="s1">]</span>
        <span class="s1">kwds.update(self.kwds_extra)</span>
        <span class="s1">args = [kwds[arg] </span><span class="s3">for </span><span class="s1">arg </span><span class="s3">in </span><span class="s1">args_names]</span>
        <span class="s3">if </span><span class="s1">hasattr(self</span><span class="s3">, </span><span class="s4">'decimal'</span><span class="s1">):</span>
            <span class="s1">decimal = self.decimal </span><span class="s0">#pylint: disable-msg=E1101</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">decimal = </span><span class="s5">6</span>
        <span class="s1">assert_almost_equal(res1.power(*args)</span><span class="s3">, </span><span class="s1">self.res2.power</span><span class="s3">, </span><span class="s1">decimal=decimal)</span>



<span class="s3">def </span><span class="s1">test_ftest_power():</span>
    <span class="s0">#equivalence ftest, ttest</span>

    <span class="s3">for </span><span class="s1">alpha </span><span class="s3">in </span><span class="s1">[</span><span class="s5">0.01</span><span class="s3">, </span><span class="s5">0.05</span><span class="s3">, </span><span class="s5">0.1</span><span class="s3">, </span><span class="s5">0.20</span><span class="s3">, </span><span class="s5">0.50</span><span class="s1">]:</span>
        <span class="s1">res0 = smp.ttest_power(</span><span class="s5">0.01</span><span class="s3">, </span><span class="s5">200</span><span class="s3">, </span><span class="s1">alpha)</span>
        <span class="s1">res1 = smp.ftest_power(</span><span class="s5">0.01</span><span class="s3">, </span><span class="s5">199</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s1">alpha=alpha</span><span class="s3">, </span><span class="s1">ncc=</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(res1</span><span class="s3">, </span><span class="s1">res0</span><span class="s3">, </span><span class="s1">decimal=</span><span class="s5">6</span><span class="s1">)</span>


    <span class="s0">#example from Gplus documentation F-test ANOVA</span>
    <span class="s0">#Total sample size:200</span>
    <span class="s0">#Effect size &quot;f&quot;:0.25</span>
    <span class="s0">#Beta/alpha ratio:1</span>
    <span class="s0">#Result:</span>
    <span class="s0">#Alpha:0.1592</span>
    <span class="s0">#Power (1-beta):0.8408</span>
    <span class="s0">#Critical F:1.4762</span>
    <span class="s0">#Lambda: 12.50000</span>
    <span class="s1">res1 = smp.ftest_anova_power(</span><span class="s5">0.25</span><span class="s3">, </span><span class="s5">200</span><span class="s3">, </span><span class="s5">0.1592</span><span class="s3">, </span><span class="s1">k_groups=</span><span class="s5">10</span><span class="s1">)</span>
    <span class="s1">res0 = </span><span class="s5">0.8408</span>
    <span class="s1">assert_almost_equal(res1</span><span class="s3">, </span><span class="s1">res0</span><span class="s3">, </span><span class="s1">decimal=</span><span class="s5">4</span><span class="s1">)</span>


    <span class="s0"># TODO: no class yet</span>
    <span class="s0"># examples against R::pwr</span>
    <span class="s1">res2 = Holder()</span>
    <span class="s0">#&gt; rf = pwr.f2.test(u=5, v=199, f2=0.1**2, sig.level=0.01)</span>
    <span class="s0">#&gt; cat_items(rf, &quot;res2.&quot;)</span>
    <span class="s1">res2.u = </span><span class="s5">5</span>
    <span class="s1">res2.v = </span><span class="s5">199</span>
    <span class="s1">res2.f2 = </span><span class="s5">0.01</span>
    <span class="s1">res2.sig_level = </span><span class="s5">0.01</span>
    <span class="s1">res2.power = </span><span class="s5">0.0494137732920332</span>
    <span class="s1">res2.method = </span><span class="s4">'Multiple regression power calculation'</span>

    <span class="s1">res1 = smp.ftest_power(np.sqrt(res2.f2)</span><span class="s3">, </span><span class="s1">res2.v</span><span class="s3">, </span><span class="s1">res2.u</span><span class="s3">,</span>
                           <span class="s1">alpha=res2.sig_level</span><span class="s3">, </span><span class="s1">ncc=</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">assert_almost_equal(res1</span><span class="s3">, </span><span class="s1">res2.power</span><span class="s3">, </span><span class="s1">decimal=</span><span class="s5">5</span><span class="s1">)</span>

    <span class="s1">res2 = Holder()</span>
    <span class="s0">#&gt; rf = pwr.f2.test(u=5, v=199, f2=0.3**2, sig.level=0.01)</span>
    <span class="s0">#&gt; cat_items(rf, &quot;res2.&quot;)</span>
    <span class="s1">res2.u = </span><span class="s5">5</span>
    <span class="s1">res2.v = </span><span class="s5">199</span>
    <span class="s1">res2.f2 = </span><span class="s5">0.09</span>
    <span class="s1">res2.sig_level = </span><span class="s5">0.01</span>
    <span class="s1">res2.power = </span><span class="s5">0.7967191006290872</span>
    <span class="s1">res2.method = </span><span class="s4">'Multiple regression power calculation'</span>

    <span class="s1">res1 = smp.ftest_power(np.sqrt(res2.f2)</span><span class="s3">, </span><span class="s1">res2.v</span><span class="s3">, </span><span class="s1">res2.u</span><span class="s3">,</span>
                           <span class="s1">alpha=res2.sig_level</span><span class="s3">, </span><span class="s1">ncc=</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">assert_almost_equal(res1</span><span class="s3">, </span><span class="s1">res2.power</span><span class="s3">, </span><span class="s1">decimal=</span><span class="s5">5</span><span class="s1">)</span>

    <span class="s1">res2 = Holder()</span>
    <span class="s0">#&gt; rf = pwr.f2.test(u=5, v=19, f2=0.3**2, sig.level=0.1)</span>
    <span class="s0">#&gt; cat_items(rf, &quot;res2.&quot;)</span>
    <span class="s1">res2.u = </span><span class="s5">5</span>
    <span class="s1">res2.v = </span><span class="s5">19</span>
    <span class="s1">res2.f2 = </span><span class="s5">0.09</span>
    <span class="s1">res2.sig_level = </span><span class="s5">0.1</span>
    <span class="s1">res2.power = </span><span class="s5">0.235454222377575</span>
    <span class="s1">res2.method = </span><span class="s4">'Multiple regression power calculation'</span>

    <span class="s1">res1 = smp.ftest_power(np.sqrt(res2.f2)</span><span class="s3">, </span><span class="s1">res2.v</span><span class="s3">, </span><span class="s1">res2.u</span><span class="s3">,</span>
                           <span class="s1">alpha=res2.sig_level</span><span class="s3">, </span><span class="s1">ncc=</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">assert_almost_equal(res1</span><span class="s3">, </span><span class="s1">res2.power</span><span class="s3">, </span><span class="s1">decimal=</span><span class="s5">5</span><span class="s1">)</span>

<span class="s0"># class based version of two above test for Ftest</span>
<span class="s3">class </span><span class="s1">TestFtestAnovaPower(CheckPowerMixin):</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">res2 = Holder()</span>
        <span class="s0">#example from Gplus documentation F-test ANOVA</span>
        <span class="s0">#Total sample size:200</span>
        <span class="s0">#Effect size &quot;f&quot;:0.25</span>
        <span class="s0">#Beta/alpha ratio:1</span>
        <span class="s0">#Result:</span>
        <span class="s0">#Alpha:0.1592</span>
        <span class="s0">#Power (1-beta):0.8408</span>
        <span class="s0">#Critical F:1.4762</span>
        <span class="s0">#Lambda: 12.50000</span>
        <span class="s0">#converted to res2 by hand</span>
        <span class="s1">res2.f = </span><span class="s5">0.25</span>
        <span class="s1">res2.n = </span><span class="s5">200</span>
        <span class="s1">res2.k = </span><span class="s5">10</span>
        <span class="s1">res2.alpha = </span><span class="s5">0.1592</span>
        <span class="s1">res2.power = </span><span class="s5">0.8408</span>
        <span class="s1">res2.method = </span><span class="s4">'Multiple regression power calculation'</span>

        <span class="s1">cls.res2 = res2</span>
        <span class="s1">cls.kwds = {</span><span class="s4">'effect_size'</span><span class="s1">: res2.f</span><span class="s3">, </span><span class="s4">'nobs'</span><span class="s1">: res2.n</span><span class="s3">,</span>
                     <span class="s4">'alpha'</span><span class="s1">: res2.alpha</span><span class="s3">, </span><span class="s4">'power'</span><span class="s1">: res2.power}</span>
        <span class="s0"># keyword for which we do not look for root:</span>
        <span class="s0"># solving for n_bins does not work, will not be used in regular usage</span>
        <span class="s1">cls.kwds_extra = {</span><span class="s4">'k_groups'</span><span class="s1">: res2.k} </span><span class="s0"># rootfinding does not work</span>
        <span class="s0">#cls.args_names = ['effect_size','nobs', 'alpha']#, 'k_groups']</span>
        <span class="s1">cls.cls = smp.FTestAnovaPower</span>
        <span class="s0"># precision for test_power</span>
        <span class="s1">cls.decimal = </span><span class="s5">4</span>



<span class="s3">class </span><span class="s1">TestFtestPower(CheckPowerMixin):</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">res2 = Holder()</span>
        <span class="s0">#&gt; rf = pwr.f2.test(u=5, v=19, f2=0.3**2, sig.level=0.1)</span>
        <span class="s0">#&gt; cat_items(rf, &quot;res2.&quot;)</span>
        <span class="s1">res2.u = </span><span class="s5">5</span>
        <span class="s1">res2.v = </span><span class="s5">19</span>
        <span class="s1">res2.f2 = </span><span class="s5">0.09</span>
        <span class="s1">res2.sig_level = </span><span class="s5">0.1</span>
        <span class="s1">res2.power = </span><span class="s5">0.235454222377575</span>
        <span class="s1">res2.method = </span><span class="s4">'Multiple regression power calculation'</span>

        <span class="s1">cls.res2 = res2</span>
        <span class="s1">cls.kwds = {</span><span class="s4">'effect_size'</span><span class="s1">: np.sqrt(res2.f2)</span><span class="s3">, </span><span class="s4">'df_num'</span><span class="s1">: res2.v</span><span class="s3">,</span>
                     <span class="s4">'df_denom'</span><span class="s1">: res2.u</span><span class="s3">, </span><span class="s4">'alpha'</span><span class="s1">: res2.sig_level</span><span class="s3">,</span>
                     <span class="s4">'power'</span><span class="s1">: res2.power}</span>
        <span class="s0"># keyword for which we do not look for root:</span>
        <span class="s0"># solving for n_bins does not work, will not be used in regular usage</span>
        <span class="s1">cls.kwds_extra = {}</span>
        <span class="s1">cls.args_names = [</span><span class="s4">'effect_size'</span><span class="s3">, </span><span class="s4">'df_num'</span><span class="s3">, </span><span class="s4">'df_denom'</span><span class="s3">, </span><span class="s4">'alpha'</span><span class="s1">]</span>
        <span class="s1">cls.cls = smp.FTestPower</span>
        <span class="s0"># precision for test_power</span>
        <span class="s1">cls.decimal = </span><span class="s5">5</span>

    <span class="s3">def </span><span class="s1">test_kwargs(self):</span>

        <span class="s3">with </span><span class="s1">pytest.warns(UserWarning):</span>
            <span class="s1">smp.FTestPower().solve_power(</span>
                <span class="s1">effect_size=</span><span class="s5">0.3</span><span class="s3">, </span><span class="s1">alpha=</span><span class="s5">0.1</span><span class="s3">, </span><span class="s1">power=</span><span class="s5">0.9</span><span class="s3">, </span><span class="s1">df_denom=</span><span class="s5">2</span><span class="s3">,</span>
                <span class="s1">nobs=</span><span class="s3">None</span><span class="s1">)</span>

        <span class="s3">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">smp.FTestPower().solve_power(</span>
                <span class="s1">effect_size=</span><span class="s5">0.3</span><span class="s3">, </span><span class="s1">alpha=</span><span class="s5">0.1</span><span class="s3">, </span><span class="s1">power=</span><span class="s5">0.9</span><span class="s3">, </span><span class="s1">df_denom=</span><span class="s5">2</span><span class="s3">,</span>
                <span class="s1">junk=</span><span class="s5">3</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">TestFtestPowerF2(CheckPowerMixin):</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">res2 = Holder()</span>
        <span class="s0">#&gt; rf = pwr.f2.test(u=5, v=19, f2=0.3**2, sig.level=0.1)</span>
        <span class="s0">#&gt; cat_items(rf, &quot;res2.&quot;)</span>
        <span class="s1">res2.u = </span><span class="s5">5</span>
        <span class="s1">res2.v = </span><span class="s5">19</span>
        <span class="s1">res2.f2 = </span><span class="s5">0.09</span>
        <span class="s1">res2.sig_level = </span><span class="s5">0.1</span>
        <span class="s1">res2.power = </span><span class="s5">0.235454222377575</span>
        <span class="s1">res2.method = </span><span class="s4">'Multiple regression power calculation'</span>

        <span class="s1">cls.res2 = res2</span>
        <span class="s1">cls.kwds = {</span><span class="s4">'effect_size'</span><span class="s1">: res2.f2</span><span class="s3">, </span><span class="s4">'df_num'</span><span class="s1">: res2.u</span><span class="s3">,</span>
                     <span class="s4">'df_denom'</span><span class="s1">: res2.v</span><span class="s3">, </span><span class="s4">'alpha'</span><span class="s1">: res2.sig_level</span><span class="s3">,</span>
                     <span class="s4">'power'</span><span class="s1">: res2.power}</span>
        <span class="s0"># keyword for which we do not look for root:</span>
        <span class="s0"># solving for n_bins does not work, will not be used in regular usage</span>
        <span class="s1">cls.kwds_extra = {}</span>
        <span class="s1">cls.args_names = [</span><span class="s4">'effect_size'</span><span class="s3">, </span><span class="s4">'df_num'</span><span class="s3">, </span><span class="s4">'df_denom'</span><span class="s3">, </span><span class="s4">'alpha'</span><span class="s1">]</span>
        <span class="s1">cls.cls = smp.FTestPowerF2</span>
        <span class="s0"># precision for test_power</span>
        <span class="s1">cls.decimal = </span><span class="s5">5</span>



<span class="s3">def </span><span class="s1">test_power_solver():</span>
    <span class="s0"># messing up the solver to trigger backup</span>

    <span class="s1">nip = smp.NormalIndPower()</span>

    <span class="s0"># check result</span>
    <span class="s1">es0 = </span><span class="s5">0.1</span>
    <span class="s1">pow_ = nip.solve_power(es0</span><span class="s3">, </span><span class="s1">nobs1=</span><span class="s5">1600</span><span class="s3">, </span><span class="s1">alpha=</span><span class="s5">0.01</span><span class="s3">, </span><span class="s1">power=</span><span class="s3">None, </span><span class="s1">ratio=</span><span class="s5">1</span><span class="s3">,</span>
                           <span class="s1">alternative=</span><span class="s4">'larger'</span><span class="s1">)</span>
    <span class="s0"># value is regression test</span>
    <span class="s1">assert_almost_equal(pow_</span><span class="s3">, </span><span class="s5">0.69219411243824214</span><span class="s3">, </span><span class="s1">decimal=</span><span class="s5">5</span><span class="s1">)</span>
    <span class="s1">es = nip.solve_power(</span><span class="s3">None, </span><span class="s1">nobs1=</span><span class="s5">1600</span><span class="s3">, </span><span class="s1">alpha=</span><span class="s5">0.01</span><span class="s3">, </span><span class="s1">power=pow_</span><span class="s3">, </span><span class="s1">ratio=</span><span class="s5">1</span><span class="s3">,</span>
                         <span class="s1">alternative=</span><span class="s4">'larger'</span><span class="s1">)</span>
    <span class="s1">assert_almost_equal(es</span><span class="s3">, </span><span class="s1">es0</span><span class="s3">, </span><span class="s1">decimal=</span><span class="s5">4</span><span class="s1">)</span>
    <span class="s1">assert_equal(nip.cache_fit_res[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(len(nip.cache_fit_res)</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span>

    <span class="s0"># cause first optimizer to fail</span>
    <span class="s1">nip.start_bqexp[</span><span class="s4">'effect_size'</span><span class="s1">] = {</span><span class="s4">'upp'</span><span class="s1">: -</span><span class="s5">10</span><span class="s3">, </span><span class="s4">'low'</span><span class="s1">: -</span><span class="s5">20</span><span class="s1">}</span>
    <span class="s1">nip.start_ttp[</span><span class="s4">'effect_size'</span><span class="s1">] = </span><span class="s5">0.14</span>
    <span class="s1">es = nip.solve_power(</span><span class="s3">None, </span><span class="s1">nobs1=</span><span class="s5">1600</span><span class="s3">, </span><span class="s1">alpha=</span><span class="s5">0.01</span><span class="s3">, </span><span class="s1">power=pow_</span><span class="s3">, </span><span class="s1">ratio=</span><span class="s5">1</span><span class="s3">,</span>
                         <span class="s1">alternative=</span><span class="s4">'larger'</span><span class="s1">)</span>
    <span class="s1">assert_almost_equal(es</span><span class="s3">, </span><span class="s1">es0</span><span class="s3">, </span><span class="s1">decimal=</span><span class="s5">4</span><span class="s1">)</span>
    <span class="s1">assert_equal(nip.cache_fit_res[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(len(nip.cache_fit_res)</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s1">err_msg=repr(nip.cache_fit_res))</span>

    <span class="s1">nip.start_ttp[</span><span class="s4">'effect_size'</span><span class="s1">] = np.nan</span>
    <span class="s1">es = nip.solve_power(</span><span class="s3">None, </span><span class="s1">nobs1=</span><span class="s5">1600</span><span class="s3">, </span><span class="s1">alpha=</span><span class="s5">0.01</span><span class="s3">, </span><span class="s1">power=pow_</span><span class="s3">, </span><span class="s1">ratio=</span><span class="s5">1</span><span class="s3">,</span>
                         <span class="s1">alternative=</span><span class="s4">'larger'</span><span class="s1">)</span>
    <span class="s1">assert_almost_equal(es</span><span class="s3">, </span><span class="s1">es0</span><span class="s3">, </span><span class="s1">decimal=</span><span class="s5">4</span><span class="s1">)</span>
    <span class="s1">assert_equal(nip.cache_fit_res[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(len(nip.cache_fit_res)</span><span class="s3">, </span><span class="s5">4</span><span class="s1">)</span>

    <span class="s0"># Test our edge-case where effect_size = 0</span>
    <span class="s1">es = nip.solve_power(nobs1=</span><span class="s5">1600</span><span class="s3">, </span><span class="s1">alpha=</span><span class="s5">0.01</span><span class="s3">, </span><span class="s1">effect_size=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">power=</span><span class="s3">None</span><span class="s1">)</span>
    <span class="s1">assert_almost_equal(es</span><span class="s3">, </span><span class="s5">0.01</span><span class="s1">)</span>

    <span class="s0"># I let this case fail, could be fixed for some statistical tests</span>
    <span class="s0"># (we should not get here in the first place)</span>
    <span class="s0"># effect size is negative, but last stage brentq uses [1e-8, 1-1e-8]</span>
    <span class="s1">assert_raises(ValueError</span><span class="s3">, </span><span class="s1">nip.solve_power</span><span class="s3">, None, </span><span class="s1">nobs1=</span><span class="s5">1600</span><span class="s3">, </span><span class="s1">alpha=</span><span class="s5">0.01</span><span class="s3">,</span>
                  <span class="s1">power=</span><span class="s5">0.005</span><span class="s3">, </span><span class="s1">ratio=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">alternative=</span><span class="s4">'larger'</span><span class="s1">)</span>

    <span class="s3">with </span><span class="s1">pytest.warns(HypothesisTestWarning):</span>
        <span class="s3">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">nip.solve_power(nobs1=</span><span class="s3">None, </span><span class="s1">effect_size=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">alpha=</span><span class="s5">0.01</span><span class="s3">,</span>
                            <span class="s1">power=</span><span class="s5">0.005</span><span class="s3">, </span><span class="s1">ratio=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">alternative=</span><span class="s4">'larger'</span><span class="s1">)</span>


<span class="s0"># TODO: can something useful be made from this?</span>
<span class="s1">@pytest.mark.xfail(reason=</span><span class="s4">'Known failure on modern SciPy &gt;= 0.10'</span><span class="s3">, </span><span class="s1">strict=</span><span class="s3">True</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">test_power_solver_warn():</span>
    <span class="s0"># messing up the solver to trigger warning</span>
    <span class="s0"># I wrote this with scipy 0.9,</span>
    <span class="s0"># convergence behavior of scipy 0.11 is different,</span>
    <span class="s0"># fails at a different case, but is successful where it failed before</span>

    <span class="s1">pow_ = </span><span class="s5">0.69219411243824214 </span><span class="s0"># from previous function</span>
    <span class="s1">nip = smp.NormalIndPower()</span>
    <span class="s0"># using nobs, has one backup (fsolve)</span>
    <span class="s1">nip.start_bqexp[</span><span class="s4">'nobs1'</span><span class="s1">] = {</span><span class="s4">'upp'</span><span class="s1">: </span><span class="s5">50</span><span class="s3">, </span><span class="s4">'low'</span><span class="s1">: -</span><span class="s5">20</span><span class="s1">}</span>
    <span class="s1">val = nip.solve_power(</span><span class="s5">0.1</span><span class="s3">, </span><span class="s1">nobs1=</span><span class="s3">None, </span><span class="s1">alpha=</span><span class="s5">0.01</span><span class="s3">, </span><span class="s1">power=pow_</span><span class="s3">, </span><span class="s1">ratio=</span><span class="s5">1</span><span class="s3">,</span>
                          <span class="s1">alternative=</span><span class="s4">'larger'</span><span class="s1">)</span>

    <span class="s1">assert_almost_equal(val</span><span class="s3">, </span><span class="s5">1600</span><span class="s3">, </span><span class="s1">decimal=</span><span class="s5">4</span><span class="s1">)</span>
    <span class="s1">assert_equal(nip.cache_fit_res[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(len(nip.cache_fit_res)</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span>

    <span class="s0"># case that has convergence failure, and should warn</span>
    <span class="s1">nip.start_ttp[</span><span class="s4">'nobs1'</span><span class="s1">] = np.nan</span>

    <span class="s3">from </span><span class="s1">statsmodels.tools.sm_exceptions </span><span class="s3">import </span><span class="s1">ConvergenceWarning</span>
    <span class="s1">assert_warns(ConvergenceWarning</span><span class="s3">, </span><span class="s1">nip.solve_power</span><span class="s3">, </span><span class="s5">0.1</span><span class="s3">, </span><span class="s1">nobs1=</span><span class="s3">None,</span>
                  <span class="s1">alpha=</span><span class="s5">0.01</span><span class="s3">, </span><span class="s1">power=pow_</span><span class="s3">, </span><span class="s1">ratio=</span><span class="s5">1</span><span class="s3">, </span><span class="s1">alternative=</span><span class="s4">'larger'</span><span class="s1">)</span>
    <span class="s0"># this converges with scipy 0.11  ???</span>
    <span class="s0"># nip.solve_power(0.1, nobs1=None, alpha=0.01, power=pow_, ratio=1, alternative='larger')</span>

    <span class="s3">with </span><span class="s1">warnings.catch_warnings():  </span><span class="s0"># python &gt;= 2.6</span>
        <span class="s1">warnings.simplefilter(</span><span class="s4">&quot;ignore&quot;</span><span class="s1">)</span>
        <span class="s1">val = nip.solve_power(</span><span class="s5">0.1</span><span class="s3">, </span><span class="s1">nobs1=</span><span class="s3">None, </span><span class="s1">alpha=</span><span class="s5">0.01</span><span class="s3">, </span><span class="s1">power=pow_</span><span class="s3">, </span><span class="s1">ratio=</span><span class="s5">1</span><span class="s3">,</span>
                              <span class="s1">alternative=</span><span class="s4">'larger'</span><span class="s1">)</span>
        <span class="s1">assert_equal(nip.cache_fit_res[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">assert_equal(len(nip.cache_fit_res)</span><span class="s3">, </span><span class="s5">3</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">test_normal_sample_size_one_tail():</span>
    <span class="s0"># Test that using default value of std_alternative does not raise an</span>
    <span class="s0"># exception. A power of 0.8 and alpha of 0.05 were chosen to reflect</span>
    <span class="s0"># commonly used values in hypothesis testing. Difference in means and</span>
    <span class="s0"># standard deviation of null population were chosen somewhat arbitrarily --</span>
    <span class="s0"># there's nothing special about those values. Return value doesn't matter</span>
    <span class="s0"># for this &quot;test&quot;, so long as an exception is not raised.</span>
    <span class="s1">smp.normal_sample_size_one_tail(</span><span class="s5">5</span><span class="s3">, </span><span class="s5">0.8</span><span class="s3">, </span><span class="s5">0.05</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s1">std_alternative=</span><span class="s3">None</span><span class="s1">)</span>

    <span class="s0"># Test that zero is returned in the correct elements if power is less</span>
    <span class="s0"># than alpha.</span>
    <span class="s1">alphas = np.asarray([</span><span class="s5">0.01</span><span class="s3">, </span><span class="s5">0.05</span><span class="s3">, </span><span class="s5">0.1</span><span class="s3">, </span><span class="s5">0.5</span><span class="s3">, </span><span class="s5">0.8</span><span class="s1">])</span>
    <span class="s1">powers = np.asarray([</span><span class="s5">0.99</span><span class="s3">, </span><span class="s5">0.95</span><span class="s3">, </span><span class="s5">0.9</span><span class="s3">, </span><span class="s5">0.5</span><span class="s3">, </span><span class="s5">0.2</span><span class="s1">])</span>
    <span class="s0"># zero_mask = np.where(alphas - powers &gt; 0, 0.0, alphas - powers)</span>
    <span class="s1">nobs_with_zeros = smp.normal_sample_size_one_tail(</span><span class="s5">5</span><span class="s3">, </span><span class="s1">powers</span><span class="s3">, </span><span class="s1">alphas</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span>
    <span class="s0"># check_nans = np.isnan(zero_mask) == np.isnan(nobs_with_nans)</span>
    <span class="s1">assert_array_equal(nobs_with_zeros[powers &lt;= alphas]</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>
</pre>
</body>
</html>