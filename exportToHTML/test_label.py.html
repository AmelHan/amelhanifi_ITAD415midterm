<html>
<head>
<title>test_label.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_label.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">pytest</span>
<span class="s0">from </span><span class="s1">scipy.sparse </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">coo_matrix</span><span class="s0">,</span>
    <span class="s1">csc_matrix</span><span class="s0">,</span>
    <span class="s1">csr_matrix</span><span class="s0">,</span>
    <span class="s1">dok_matrix</span><span class="s0">,</span>
    <span class="s1">issparse</span><span class="s0">,</span>
    <span class="s1">lil_matrix</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s0">from </span><span class="s1">sklearn </span><span class="s0">import </span><span class="s1">datasets</span>
<span class="s0">from </span><span class="s1">sklearn.preprocessing._label </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">LabelBinarizer</span><span class="s0">,</span>
    <span class="s1">LabelEncoder</span><span class="s0">,</span>
    <span class="s1">MultiLabelBinarizer</span><span class="s0">,</span>
    <span class="s1">_inverse_binarize_multiclass</span><span class="s0">,</span>
    <span class="s1">_inverse_binarize_thresholding</span><span class="s0">,</span>
    <span class="s1">label_binarize</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">sklearn.utils </span><span class="s0">import </span><span class="s1">_to_object_array</span>
<span class="s0">from </span><span class="s1">sklearn.utils._testing </span><span class="s0">import </span><span class="s1">assert_array_equal</span><span class="s0">, </span><span class="s1">ignore_warnings</span>
<span class="s0">from </span><span class="s1">sklearn.utils.multiclass </span><span class="s0">import </span><span class="s1">type_of_target</span>

<span class="s1">iris = datasets.load_iris()</span>


<span class="s0">def </span><span class="s1">toarray(a):</span>
    <span class="s0">if </span><span class="s1">hasattr(a</span><span class="s0">, </span><span class="s2">&quot;toarray&quot;</span><span class="s1">):</span>
        <span class="s1">a = a.toarray()</span>
    <span class="s0">return </span><span class="s1">a</span>


<span class="s0">def </span><span class="s1">test_label_binarizer():</span>
    <span class="s3"># one-class case defaults to negative label</span>
    <span class="s3"># For dense case:</span>
    <span class="s1">inp = [</span><span class="s2">&quot;pos&quot;</span><span class="s0">, </span><span class="s2">&quot;pos&quot;</span><span class="s0">, </span><span class="s2">&quot;pos&quot;</span><span class="s0">, </span><span class="s2">&quot;pos&quot;</span><span class="s1">]</span>
    <span class="s1">lb = LabelBinarizer(sparse_output=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">expected = np.array([[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]]).T</span>
    <span class="s1">got = lb.fit_transform(inp)</span>
    <span class="s1">assert_array_equal(lb.classes_</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;pos&quot;</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(expected</span><span class="s0">, </span><span class="s1">got)</span>
    <span class="s1">assert_array_equal(lb.inverse_transform(got)</span><span class="s0">, </span><span class="s1">inp)</span>

    <span class="s3"># For sparse case:</span>
    <span class="s1">lb = LabelBinarizer(sparse_output=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">got = lb.fit_transform(inp)</span>
    <span class="s0">assert </span><span class="s1">issparse(got)</span>
    <span class="s1">assert_array_equal(lb.classes_</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;pos&quot;</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(expected</span><span class="s0">, </span><span class="s1">got.toarray())</span>
    <span class="s1">assert_array_equal(lb.inverse_transform(got.toarray())</span><span class="s0">, </span><span class="s1">inp)</span>

    <span class="s1">lb = LabelBinarizer(sparse_output=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s3"># two-class case</span>
    <span class="s1">inp = [</span><span class="s2">&quot;neg&quot;</span><span class="s0">, </span><span class="s2">&quot;pos&quot;</span><span class="s0">, </span><span class="s2">&quot;pos&quot;</span><span class="s0">, </span><span class="s2">&quot;neg&quot;</span><span class="s1">]</span>
    <span class="s1">expected = np.array([[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]]).T</span>
    <span class="s1">got = lb.fit_transform(inp)</span>
    <span class="s1">assert_array_equal(lb.classes_</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;neg&quot;</span><span class="s0">, </span><span class="s2">&quot;pos&quot;</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(expected</span><span class="s0">, </span><span class="s1">got)</span>

    <span class="s1">to_invert = np.array([[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]])</span>
    <span class="s1">assert_array_equal(lb.inverse_transform(to_invert)</span><span class="s0">, </span><span class="s1">inp)</span>

    <span class="s3"># multi-class case</span>
    <span class="s1">inp = [</span><span class="s2">&quot;spam&quot;</span><span class="s0">, </span><span class="s2">&quot;ham&quot;</span><span class="s0">, </span><span class="s2">&quot;eggs&quot;</span><span class="s0">, </span><span class="s2">&quot;ham&quot;</span><span class="s0">, </span><span class="s2">&quot;0&quot;</span><span class="s1">]</span>
    <span class="s1">expected = np.array(</span>
        <span class="s1">[[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]]</span>
    <span class="s1">)</span>
    <span class="s1">got = lb.fit_transform(inp)</span>
    <span class="s1">assert_array_equal(lb.classes_</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;0&quot;</span><span class="s0">, </span><span class="s2">&quot;eggs&quot;</span><span class="s0">, </span><span class="s2">&quot;ham&quot;</span><span class="s0">, </span><span class="s2">&quot;spam&quot;</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(expected</span><span class="s0">, </span><span class="s1">got)</span>
    <span class="s1">assert_array_equal(lb.inverse_transform(got)</span><span class="s0">, </span><span class="s1">inp)</span>


<span class="s0">def </span><span class="s1">test_label_binarizer_unseen_labels():</span>
    <span class="s1">lb = LabelBinarizer()</span>

    <span class="s1">expected = np.array([[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]])</span>
    <span class="s1">got = lb.fit_transform([</span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s0">, </span><span class="s2">&quot;e&quot;</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(expected</span><span class="s0">, </span><span class="s1">got)</span>

    <span class="s1">expected = np.array(</span>
        <span class="s1">[[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]]</span>
    <span class="s1">)</span>
    <span class="s1">got = lb.transform([</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s0">, </span><span class="s2">&quot;e&quot;</span><span class="s0">, </span><span class="s2">&quot;f&quot;</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(expected</span><span class="s0">, </span><span class="s1">got)</span>


<span class="s0">def </span><span class="s1">test_label_binarizer_set_label_encoding():</span>
    <span class="s1">lb = LabelBinarizer(neg_label=-</span><span class="s4">2</span><span class="s0">, </span><span class="s1">pos_label=</span><span class="s4">0</span><span class="s1">)</span>

    <span class="s3"># two-class case with pos_label=0</span>
    <span class="s1">inp = np.array([</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">])</span>
    <span class="s1">expected = np.array([[-</span><span class="s4">2</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">-</span><span class="s4">2</span><span class="s1">]]).T</span>
    <span class="s1">got = lb.fit_transform(inp)</span>
    <span class="s1">assert_array_equal(expected</span><span class="s0">, </span><span class="s1">got)</span>
    <span class="s1">assert_array_equal(lb.inverse_transform(got)</span><span class="s0">, </span><span class="s1">inp)</span>

    <span class="s1">lb = LabelBinarizer(neg_label=-</span><span class="s4">2</span><span class="s0">, </span><span class="s1">pos_label=</span><span class="s4">2</span><span class="s1">)</span>

    <span class="s3"># multi-class case</span>
    <span class="s1">inp = np.array([</span><span class="s4">3</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">0</span><span class="s1">])</span>
    <span class="s1">expected = np.array(</span>
        <span class="s1">[</span>
            <span class="s1">[-</span><span class="s4">2</span><span class="s0">, </span><span class="s1">-</span><span class="s4">2</span><span class="s0">, </span><span class="s1">-</span><span class="s4">2</span><span class="s0">, </span><span class="s1">+</span><span class="s4">2</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[-</span><span class="s4">2</span><span class="s0">, </span><span class="s1">-</span><span class="s4">2</span><span class="s0">, </span><span class="s1">+</span><span class="s4">2</span><span class="s0">, </span><span class="s1">-</span><span class="s4">2</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[-</span><span class="s4">2</span><span class="s0">, </span><span class="s1">+</span><span class="s4">2</span><span class="s0">, </span><span class="s1">-</span><span class="s4">2</span><span class="s0">, </span><span class="s1">-</span><span class="s4">2</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[-</span><span class="s4">2</span><span class="s0">, </span><span class="s1">-</span><span class="s4">2</span><span class="s0">, </span><span class="s1">+</span><span class="s4">2</span><span class="s0">, </span><span class="s1">-</span><span class="s4">2</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[+</span><span class="s4">2</span><span class="s0">, </span><span class="s1">-</span><span class="s4">2</span><span class="s0">, </span><span class="s1">-</span><span class="s4">2</span><span class="s0">, </span><span class="s1">-</span><span class="s4">2</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s1">got = lb.fit_transform(inp)</span>
    <span class="s1">assert_array_equal(expected</span><span class="s0">, </span><span class="s1">got)</span>
    <span class="s1">assert_array_equal(lb.inverse_transform(got)</span><span class="s0">, </span><span class="s1">inp)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;Int64&quot;</span><span class="s0">, </span><span class="s2">&quot;Float64&quot;</span><span class="s0">, </span><span class="s2">&quot;boolean&quot;</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;unique_first&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_label_binarizer_pandas_nullable(dtype</span><span class="s0">, </span><span class="s1">unique_first):</span>
    <span class="s5">&quot;&quot;&quot;Checks that LabelBinarizer works with pandas nullable dtypes. 
 
    Non-regression test for gh-25637. 
    &quot;&quot;&quot;</span>
    <span class="s1">pd = pytest.importorskip(</span><span class="s2">&quot;pandas&quot;</span><span class="s1">)</span>

    <span class="s1">y_true = pd.Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
    <span class="s0">if </span><span class="s1">unique_first:</span>
        <span class="s3"># Calling unique creates a pandas array which has a different interface</span>
        <span class="s3"># compared to a pandas Series. Specifically, pandas arrays do not have &quot;iloc&quot;.</span>
        <span class="s1">y_true = y_true.unique()</span>
    <span class="s1">lb = LabelBinarizer().fit(y_true)</span>
    <span class="s1">y_out = lb.transform([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">])</span>

    <span class="s1">assert_array_equal(y_out</span><span class="s0">, </span><span class="s1">[[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s1">]])</span>


<span class="s1">@ignore_warnings</span>
<span class="s0">def </span><span class="s1">test_label_binarizer_errors():</span>
    <span class="s3"># Check that invalid arguments yield ValueError</span>
    <span class="s1">one_class = np.array([</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">])</span>
    <span class="s1">lb = LabelBinarizer().fit(one_class)</span>

    <span class="s1">multi_label = [(</span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)]</span>
    <span class="s1">err_msg = </span><span class="s2">&quot;You appear to be using a legacy multi-label data representation.&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=err_msg):</span>
        <span class="s1">lb.transform(multi_label)</span>

    <span class="s1">lb = LabelBinarizer()</span>
    <span class="s1">err_msg = </span><span class="s2">&quot;This LabelBinarizer instance is not fitted yet&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=err_msg):</span>
        <span class="s1">lb.transform([])</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=err_msg):</span>
        <span class="s1">lb.inverse_transform([])</span>

    <span class="s1">input_labels = [</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">err_msg = </span><span class="s2">&quot;neg_label=2 must be strictly less than pos_label=1.&quot;</span>
    <span class="s1">lb = LabelBinarizer(neg_label=</span><span class="s4">2</span><span class="s0">, </span><span class="s1">pos_label=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=err_msg):</span>
        <span class="s1">lb.fit(input_labels)</span>
    <span class="s1">err_msg = </span><span class="s2">&quot;neg_label=2 must be strictly less than pos_label=2.&quot;</span>
    <span class="s1">lb = LabelBinarizer(neg_label=</span><span class="s4">2</span><span class="s0">, </span><span class="s1">pos_label=</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=err_msg):</span>
        <span class="s1">lb.fit(input_labels)</span>
    <span class="s1">err_msg = (</span>
        <span class="s2">&quot;Sparse binarization is only supported with non zero pos_label and zero &quot;</span>
        <span class="s2">&quot;neg_label, got pos_label=2 and neg_label=1&quot;</span>
    <span class="s1">)</span>
    <span class="s1">lb = LabelBinarizer(neg_label=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">pos_label=</span><span class="s4">2</span><span class="s0">, </span><span class="s1">sparse_output=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=err_msg):</span>
        <span class="s1">lb.fit(input_labels)</span>

    <span class="s3"># Fail on y_type</span>
    <span class="s1">err_msg = </span><span class="s2">&quot;foo format is not supported&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=err_msg):</span>
        <span class="s1">_inverse_binarize_thresholding(</span>
            <span class="s1">y=csr_matrix([[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">2</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]])</span><span class="s0">,</span>
            <span class="s1">output_type=</span><span class="s2">&quot;foo&quot;</span><span class="s0">,</span>
            <span class="s1">classes=[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">threshold=</span><span class="s4">0</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s3"># Sequence of seq type should raise ValueError</span>
    <span class="s1">y_seq_of_seqs = [[]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">2</span><span class="s1">]]</span>
    <span class="s1">err_msg = </span><span class="s2">&quot;You appear to be using a legacy multi-label data representation&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=err_msg):</span>
        <span class="s1">LabelBinarizer().fit_transform(y_seq_of_seqs)</span>

    <span class="s3"># Fail on the number of classes</span>
    <span class="s1">err_msg = </span><span class="s2">&quot;The number of class is not equal to the number of dimension of y.&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=err_msg):</span>
        <span class="s1">_inverse_binarize_thresholding(</span>
            <span class="s1">y=csr_matrix([[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">2</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]])</span><span class="s0">,</span>
            <span class="s1">output_type=</span><span class="s2">&quot;foo&quot;</span><span class="s0">,</span>
            <span class="s1">classes=[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">threshold=</span><span class="s4">0</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s3"># Fail on the dimension of 'binary'</span>
    <span class="s1">err_msg = </span><span class="s2">&quot;output_type='binary', but y.shape&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=err_msg):</span>
        <span class="s1">_inverse_binarize_thresholding(</span>
            <span class="s1">y=np.array([[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">2</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]])</span><span class="s0">,</span>
            <span class="s1">output_type=</span><span class="s2">&quot;binary&quot;</span><span class="s0">,</span>
            <span class="s1">classes=[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">threshold=</span><span class="s4">0</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s3"># Fail on multioutput data</span>
    <span class="s1">err_msg = </span><span class="s2">&quot;Multioutput target data is not supported with label binarization&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=err_msg):</span>
        <span class="s1">LabelBinarizer().fit(np.array([[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">2</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]]))</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=err_msg):</span>
        <span class="s1">label_binarize(np.array([[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">2</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]])</span><span class="s0">, </span><span class="s1">classes=[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">])</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;values, classes, unknown&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span>
            <span class="s1">np.array([</span><span class="s4">2</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;int64&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">np.array([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;int64&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">np.array([</span><span class="s4">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;int64&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span>
            <span class="s1">np.array([</span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=object)</span><span class="s0">,</span>
            <span class="s1">np.array([</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=object)</span><span class="s0">,</span>
            <span class="s1">np.array([</span><span class="s2">&quot;d&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=object)</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span>
            <span class="s1">np.array([</span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">])</span><span class="s0">,</span>
            <span class="s1">np.array([</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">])</span><span class="s0">,</span>
            <span class="s1">np.array([</span><span class="s2">&quot;d&quot;</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">ids=[</span><span class="s2">&quot;int64&quot;</span><span class="s0">, </span><span class="s2">&quot;object&quot;</span><span class="s0">, </span><span class="s2">&quot;str&quot;</span><span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_label_encoder(values</span><span class="s0">, </span><span class="s1">classes</span><span class="s0">, </span><span class="s1">unknown):</span>
    <span class="s3"># Test LabelEncoder's transform, fit_transform and</span>
    <span class="s3"># inverse_transform methods</span>
    <span class="s1">le = LabelEncoder()</span>
    <span class="s1">le.fit(values)</span>
    <span class="s1">assert_array_equal(le.classes_</span><span class="s0">, </span><span class="s1">classes)</span>
    <span class="s1">assert_array_equal(le.transform(values)</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">2</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(le.inverse_transform([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">2</span><span class="s1">])</span><span class="s0">, </span><span class="s1">values)</span>
    <span class="s1">le = LabelEncoder()</span>
    <span class="s1">ret = le.fit_transform(values)</span>
    <span class="s1">assert_array_equal(ret</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">2</span><span class="s1">])</span>

    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;unseen labels&quot;</span><span class="s1">):</span>
        <span class="s1">le.transform(unknown)</span>


<span class="s0">def </span><span class="s1">test_label_encoder_negative_ints():</span>
    <span class="s1">le = LabelEncoder()</span>
    <span class="s1">le.fit([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">5</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(le.classes_</span><span class="s0">, </span><span class="s1">[-</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">5</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(le.transform([</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">5</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">])</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(</span>
        <span class="s1">le.inverse_transform([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">])</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">5</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">le.transform([</span><span class="s4">0</span><span class="s0">, </span><span class="s4">6</span><span class="s1">])</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;str&quot;</span><span class="s0">, </span><span class="s2">&quot;object&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_label_encoder_str_bad_shape(dtype):</span>
    <span class="s1">le = LabelEncoder()</span>
    <span class="s1">le.fit(np.array([</span><span class="s2">&quot;apple&quot;</span><span class="s0">, </span><span class="s2">&quot;orange&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=dtype))</span>
    <span class="s1">msg = </span><span class="s2">&quot;should be a 1d array&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">le.transform(</span><span class="s2">&quot;apple&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_label_encoder_errors():</span>
    <span class="s3"># Check that invalid arguments yield ValueError</span>
    <span class="s1">le = LabelEncoder()</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">le.transform([])</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">le.inverse_transform([])</span>

    <span class="s3"># Fail on unseen labels</span>
    <span class="s1">le = LabelEncoder()</span>
    <span class="s1">le.fit([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">msg = </span><span class="s2">&quot;contains previously unseen labels&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">le.inverse_transform([-</span><span class="s4">2</span><span class="s1">])</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">le.inverse_transform([-</span><span class="s4">2</span><span class="s0">, </span><span class="s1">-</span><span class="s4">3</span><span class="s0">, </span><span class="s1">-</span><span class="s4">4</span><span class="s1">])</span>

    <span class="s3"># Fail on inverse_transform(&quot;&quot;)</span>
    <span class="s1">msg = </span><span class="s2">r&quot;should be a 1d array.+shape \(\)&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">le.inverse_transform(</span><span class="s2">&quot;&quot;</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;values&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">np.array([</span><span class="s4">2</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;int64&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">np.array([</span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=object)</span><span class="s0">,</span>
        <span class="s1">np.array([</span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">])</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">ids=[</span><span class="s2">&quot;int64&quot;</span><span class="s0">, </span><span class="s2">&quot;object&quot;</span><span class="s0">, </span><span class="s2">&quot;str&quot;</span><span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_label_encoder_empty_array(values):</span>
    <span class="s1">le = LabelEncoder()</span>
    <span class="s1">le.fit(values)</span>
    <span class="s3"># test empty transform</span>
    <span class="s1">transformed = le.transform([])</span>
    <span class="s1">assert_array_equal(np.array([])</span><span class="s0">, </span><span class="s1">transformed)</span>
    <span class="s3"># test empty inverse transform</span>
    <span class="s1">inverse_transformed = le.inverse_transform([])</span>
    <span class="s1">assert_array_equal(np.array([])</span><span class="s0">, </span><span class="s1">inverse_transformed)</span>


<span class="s0">def </span><span class="s1">test_sparse_output_multilabel_binarizer():</span>
    <span class="s3"># test input as iterable of iterables</span>
    <span class="s1">inputs = [</span>
        <span class="s0">lambda</span><span class="s1">: [(</span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">1</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)]</span><span class="s0">,</span>
        <span class="s0">lambda</span><span class="s1">: ({</span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">}</span><span class="s0">, </span><span class="s1">{</span><span class="s4">1</span><span class="s1">}</span><span class="s0">, </span><span class="s1">{</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">})</span><span class="s0">,</span>
        <span class="s0">lambda</span><span class="s1">: iter([iter((</span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">))</span><span class="s0">, </span><span class="s1">iter((</span><span class="s4">1</span><span class="s0">,</span><span class="s1">))</span><span class="s0">, </span><span class="s1">{</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">}])</span><span class="s0">,</span>
    <span class="s1">]</span>
    <span class="s1">indicator_mat = np.array([[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]])</span>

    <span class="s1">inverse = inputs[</span><span class="s4">0</span><span class="s1">]()</span>
    <span class="s0">for </span><span class="s1">sparse_output </span><span class="s0">in </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">]:</span>
        <span class="s0">for </span><span class="s1">inp </span><span class="s0">in </span><span class="s1">inputs:</span>
            <span class="s3"># With fit_transform</span>
            <span class="s1">mlb = MultiLabelBinarizer(sparse_output=sparse_output)</span>
            <span class="s1">got = mlb.fit_transform(inp())</span>
            <span class="s0">assert </span><span class="s1">issparse(got) == sparse_output</span>
            <span class="s0">if </span><span class="s1">sparse_output:</span>
                <span class="s3"># verify CSR assumption that indices and indptr have same dtype</span>
                <span class="s0">assert </span><span class="s1">got.indices.dtype == got.indptr.dtype</span>
                <span class="s1">got = got.toarray()</span>
            <span class="s1">assert_array_equal(indicator_mat</span><span class="s0">, </span><span class="s1">got)</span>
            <span class="s1">assert_array_equal([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">mlb.classes_)</span>
            <span class="s0">assert </span><span class="s1">mlb.inverse_transform(got) == inverse</span>

            <span class="s3"># With fit</span>
            <span class="s1">mlb = MultiLabelBinarizer(sparse_output=sparse_output)</span>
            <span class="s1">got = mlb.fit(inp()).transform(inp())</span>
            <span class="s0">assert </span><span class="s1">issparse(got) == sparse_output</span>
            <span class="s0">if </span><span class="s1">sparse_output:</span>
                <span class="s3"># verify CSR assumption that indices and indptr have same dtype</span>
                <span class="s0">assert </span><span class="s1">got.indices.dtype == got.indptr.dtype</span>
                <span class="s1">got = got.toarray()</span>
            <span class="s1">assert_array_equal(indicator_mat</span><span class="s0">, </span><span class="s1">got)</span>
            <span class="s1">assert_array_equal([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">mlb.classes_)</span>
            <span class="s0">assert </span><span class="s1">mlb.inverse_transform(got) == inverse</span>

    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">mlb.inverse_transform(csr_matrix(np.array([[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">2</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]])))</span>


<span class="s0">def </span><span class="s1">test_multilabel_binarizer():</span>
    <span class="s3"># test input as iterable of iterables</span>
    <span class="s1">inputs = [</span>
        <span class="s0">lambda</span><span class="s1">: [(</span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">1</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)]</span><span class="s0">,</span>
        <span class="s0">lambda</span><span class="s1">: ({</span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">}</span><span class="s0">, </span><span class="s1">{</span><span class="s4">1</span><span class="s1">}</span><span class="s0">, </span><span class="s1">{</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">})</span><span class="s0">,</span>
        <span class="s0">lambda</span><span class="s1">: iter([iter((</span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">))</span><span class="s0">, </span><span class="s1">iter((</span><span class="s4">1</span><span class="s0">,</span><span class="s1">))</span><span class="s0">, </span><span class="s1">{</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">}])</span><span class="s0">,</span>
    <span class="s1">]</span>
    <span class="s1">indicator_mat = np.array([[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]])</span>
    <span class="s1">inverse = inputs[</span><span class="s4">0</span><span class="s1">]()</span>
    <span class="s0">for </span><span class="s1">inp </span><span class="s0">in </span><span class="s1">inputs:</span>
        <span class="s3"># With fit_transform</span>
        <span class="s1">mlb = MultiLabelBinarizer()</span>
        <span class="s1">got = mlb.fit_transform(inp())</span>
        <span class="s1">assert_array_equal(indicator_mat</span><span class="s0">, </span><span class="s1">got)</span>
        <span class="s1">assert_array_equal([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">mlb.classes_)</span>
        <span class="s0">assert </span><span class="s1">mlb.inverse_transform(got) == inverse</span>

        <span class="s3"># With fit</span>
        <span class="s1">mlb = MultiLabelBinarizer()</span>
        <span class="s1">got = mlb.fit(inp()).transform(inp())</span>
        <span class="s1">assert_array_equal(indicator_mat</span><span class="s0">, </span><span class="s1">got)</span>
        <span class="s1">assert_array_equal([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">mlb.classes_)</span>
        <span class="s0">assert </span><span class="s1">mlb.inverse_transform(got) == inverse</span>


<span class="s0">def </span><span class="s1">test_multilabel_binarizer_empty_sample():</span>
    <span class="s1">mlb = MultiLabelBinarizer()</span>
    <span class="s1">y = [[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[]]</span>
    <span class="s1">Y = np.array([[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]])</span>
    <span class="s1">assert_array_equal(mlb.fit_transform(y)</span><span class="s0">, </span><span class="s1">Y)</span>


<span class="s0">def </span><span class="s1">test_multilabel_binarizer_unknown_class():</span>
    <span class="s1">mlb = MultiLabelBinarizer()</span>
    <span class="s1">y = [[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]]</span>
    <span class="s1">Y = np.array([[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]])</span>
    <span class="s1">warning_message = </span><span class="s2">&quot;unknown class.* will be ignored&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.warns(UserWarning</span><span class="s0">, </span><span class="s1">match=warning_message):</span>
        <span class="s1">matrix = mlb.fit(y).transform([[</span><span class="s4">4</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">2</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]])</span>

    <span class="s1">Y = np.array([[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]])</span>
    <span class="s1">mlb = MultiLabelBinarizer(classes=[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">])</span>
    <span class="s0">with </span><span class="s1">pytest.warns(UserWarning</span><span class="s0">, </span><span class="s1">match=warning_message):</span>
        <span class="s1">matrix = mlb.fit(y).transform([[</span><span class="s4">4</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">2</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]])</span>
    <span class="s1">assert_array_equal(matrix</span><span class="s0">, </span><span class="s1">Y)</span>


<span class="s0">def </span><span class="s1">test_multilabel_binarizer_given_classes():</span>
    <span class="s1">inp = [(</span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">1</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)]</span>
    <span class="s1">indicator_mat = np.array([[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]])</span>
    <span class="s3"># fit_transform()</span>
    <span class="s1">mlb = MultiLabelBinarizer(classes=[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">2</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(mlb.fit_transform(inp)</span><span class="s0">, </span><span class="s1">indicator_mat)</span>
    <span class="s1">assert_array_equal(mlb.classes_</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">2</span><span class="s1">])</span>

    <span class="s3"># fit().transform()</span>
    <span class="s1">mlb = MultiLabelBinarizer(classes=[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">2</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(mlb.fit(inp).transform(inp)</span><span class="s0">, </span><span class="s1">indicator_mat)</span>
    <span class="s1">assert_array_equal(mlb.classes_</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">2</span><span class="s1">])</span>

    <span class="s3"># ensure works with extra class</span>
    <span class="s1">mlb = MultiLabelBinarizer(classes=[</span><span class="s4">4</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">2</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(</span>
        <span class="s1">mlb.fit_transform(inp)</span><span class="s0">, </span><span class="s1">np.hstack(([[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">indicator_mat))</span>
    <span class="s1">)</span>
    <span class="s1">assert_array_equal(mlb.classes_</span><span class="s0">, </span><span class="s1">[</span><span class="s4">4</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">2</span><span class="s1">])</span>

    <span class="s3"># ensure fit is no-op as iterable is not consumed</span>
    <span class="s1">inp = iter(inp)</span>
    <span class="s1">mlb = MultiLabelBinarizer(classes=[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">2</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(mlb.fit(inp).transform(inp)</span><span class="s0">, </span><span class="s1">indicator_mat)</span>

    <span class="s3"># ensure a ValueError is thrown if given duplicate classes</span>
    <span class="s1">err_msg = (</span>
        <span class="s2">&quot;The classes argument contains duplicate classes. Remove &quot;</span>
        <span class="s2">&quot;these duplicates before passing them to MultiLabelBinarizer.&quot;</span>
    <span class="s1">)</span>
    <span class="s1">mlb = MultiLabelBinarizer(classes=[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">])</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=err_msg):</span>
        <span class="s1">mlb.fit(inp)</span>


<span class="s0">def </span><span class="s1">test_multilabel_binarizer_multiple_calls():</span>
    <span class="s1">inp = [(</span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">1</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)]</span>
    <span class="s1">indicator_mat = np.array([[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]])</span>

    <span class="s1">indicator_mat2 = np.array([[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]])</span>

    <span class="s3"># first call</span>
    <span class="s1">mlb = MultiLabelBinarizer(classes=[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">2</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(mlb.fit_transform(inp)</span><span class="s0">, </span><span class="s1">indicator_mat)</span>
    <span class="s3"># second call change class</span>
    <span class="s1">mlb.classes = [</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span>
    <span class="s1">assert_array_equal(mlb.fit_transform(inp)</span><span class="s0">, </span><span class="s1">indicator_mat2)</span>


<span class="s0">def </span><span class="s1">test_multilabel_binarizer_same_length_sequence():</span>
    <span class="s3"># Ensure sequences of the same length are not interpreted as a 2-d array</span>
    <span class="s1">inp = [[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">2</span><span class="s1">]]</span>
    <span class="s1">indicator_mat = np.array([[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]])</span>
    <span class="s3"># fit_transform()</span>
    <span class="s1">mlb = MultiLabelBinarizer()</span>
    <span class="s1">assert_array_equal(mlb.fit_transform(inp)</span><span class="s0">, </span><span class="s1">indicator_mat)</span>
    <span class="s1">assert_array_equal(mlb.inverse_transform(indicator_mat)</span><span class="s0">, </span><span class="s1">inp)</span>

    <span class="s3"># fit().transform()</span>
    <span class="s1">mlb = MultiLabelBinarizer()</span>
    <span class="s1">assert_array_equal(mlb.fit(inp).transform(inp)</span><span class="s0">, </span><span class="s1">indicator_mat)</span>
    <span class="s1">assert_array_equal(mlb.inverse_transform(indicator_mat)</span><span class="s0">, </span><span class="s1">inp)</span>


<span class="s0">def </span><span class="s1">test_multilabel_binarizer_non_integer_labels():</span>
    <span class="s1">tuple_classes = _to_object_array([(</span><span class="s4">1</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">2</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">3</span><span class="s0">,</span><span class="s1">)])</span>
    <span class="s1">inputs = [</span>
        <span class="s1">([(</span><span class="s2">&quot;2&quot;</span><span class="s0">, </span><span class="s2">&quot;3&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;1&quot;</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;1&quot;</span><span class="s0">, </span><span class="s2">&quot;2&quot;</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;1&quot;</span><span class="s0">, </span><span class="s2">&quot;2&quot;</span><span class="s0">, </span><span class="s2">&quot;3&quot;</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">([(</span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;a&quot;</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">([((</span><span class="s4">2</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">3</span><span class="s0">,</span><span class="s1">))</span><span class="s0">, </span><span class="s1">((</span><span class="s4">1</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">((</span><span class="s4">1</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">2</span><span class="s0">,</span><span class="s1">))]</span><span class="s0">, </span><span class="s1">tuple_classes)</span><span class="s0">,</span>
    <span class="s1">]</span>
    <span class="s1">indicator_mat = np.array([[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]])</span>
    <span class="s0">for </span><span class="s1">inp</span><span class="s0">, </span><span class="s1">classes </span><span class="s0">in </span><span class="s1">inputs:</span>
        <span class="s3"># fit_transform()</span>
        <span class="s1">mlb = MultiLabelBinarizer()</span>
        <span class="s1">inp = np.array(inp</span><span class="s0">, </span><span class="s1">dtype=object)</span>
        <span class="s1">assert_array_equal(mlb.fit_transform(inp)</span><span class="s0">, </span><span class="s1">indicator_mat)</span>
        <span class="s1">assert_array_equal(mlb.classes_</span><span class="s0">, </span><span class="s1">classes)</span>
        <span class="s1">indicator_mat_inv = np.array(mlb.inverse_transform(indicator_mat)</span><span class="s0">, </span><span class="s1">dtype=object)</span>
        <span class="s1">assert_array_equal(indicator_mat_inv</span><span class="s0">, </span><span class="s1">inp)</span>

        <span class="s3"># fit().transform()</span>
        <span class="s1">mlb = MultiLabelBinarizer()</span>
        <span class="s1">assert_array_equal(mlb.fit(inp).transform(inp)</span><span class="s0">, </span><span class="s1">indicator_mat)</span>
        <span class="s1">assert_array_equal(mlb.classes_</span><span class="s0">, </span><span class="s1">classes)</span>
        <span class="s1">indicator_mat_inv = np.array(mlb.inverse_transform(indicator_mat)</span><span class="s0">, </span><span class="s1">dtype=object)</span>
        <span class="s1">assert_array_equal(indicator_mat_inv</span><span class="s0">, </span><span class="s1">inp)</span>

    <span class="s1">mlb = MultiLabelBinarizer()</span>
    <span class="s0">with </span><span class="s1">pytest.raises(TypeError):</span>
        <span class="s1">mlb.fit_transform([({})</span><span class="s0">, </span><span class="s1">({}</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;a&quot;</span><span class="s1">: </span><span class="s2">&quot;b&quot;</span><span class="s1">})])</span>


<span class="s0">def </span><span class="s1">test_multilabel_binarizer_non_unique():</span>
    <span class="s1">inp = [(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)]</span>
    <span class="s1">indicator_mat = np.array([[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]])</span>
    <span class="s1">mlb = MultiLabelBinarizer()</span>
    <span class="s1">assert_array_equal(mlb.fit_transform(inp)</span><span class="s0">, </span><span class="s1">indicator_mat)</span>


<span class="s0">def </span><span class="s1">test_multilabel_binarizer_inverse_validation():</span>
    <span class="s1">inp = [(</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)]</span>
    <span class="s1">mlb = MultiLabelBinarizer()</span>
    <span class="s1">mlb.fit_transform(inp)</span>
    <span class="s3"># Not binary</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">mlb.inverse_transform(np.array([[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]]))</span>
    <span class="s3"># The following binary cases are fine, however</span>
    <span class="s1">mlb.inverse_transform(np.array([[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]]))</span>
    <span class="s1">mlb.inverse_transform(np.array([[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]]))</span>
    <span class="s1">mlb.inverse_transform(np.array([[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]]))</span>

    <span class="s3"># Wrong shape</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">mlb.inverse_transform(np.array([[</span><span class="s4">1</span><span class="s1">]]))</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">mlb.inverse_transform(np.array([[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]]))</span>


<span class="s0">def </span><span class="s1">test_label_binarize_with_class_order():</span>
    <span class="s1">out = label_binarize([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">6</span><span class="s1">]</span><span class="s0">, </span><span class="s1">classes=[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">6</span><span class="s1">])</span>
    <span class="s1">expected = np.array([[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]])</span>
    <span class="s1">assert_array_equal(out</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s3"># Modified class order</span>
    <span class="s1">out = label_binarize([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">6</span><span class="s1">]</span><span class="s0">, </span><span class="s1">classes=[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">6</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">2</span><span class="s1">])</span>
    <span class="s1">expected = np.array([[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]])</span>
    <span class="s1">assert_array_equal(out</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">out = label_binarize([</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">classes=[</span><span class="s4">3</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">expected = np.array([[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]])</span>
    <span class="s1">assert_array_equal(out</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">check_binarized_results(y</span><span class="s0">, </span><span class="s1">classes</span><span class="s0">, </span><span class="s1">pos_label</span><span class="s0">, </span><span class="s1">neg_label</span><span class="s0">, </span><span class="s1">expected):</span>
    <span class="s0">for </span><span class="s1">sparse_output </span><span class="s0">in </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">]:</span>
        <span class="s0">if </span><span class="s1">(pos_label == </span><span class="s4">0 </span><span class="s0">or </span><span class="s1">neg_label != </span><span class="s4">0</span><span class="s1">) </span><span class="s0">and </span><span class="s1">sparse_output:</span>
            <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
                <span class="s1">label_binarize(</span>
                    <span class="s1">y</span><span class="s0">,</span>
                    <span class="s1">classes=classes</span><span class="s0">,</span>
                    <span class="s1">neg_label=neg_label</span><span class="s0">,</span>
                    <span class="s1">pos_label=pos_label</span><span class="s0">,</span>
                    <span class="s1">sparse_output=sparse_output</span><span class="s0">,</span>
                <span class="s1">)</span>
            <span class="s0">continue</span>

        <span class="s3"># check label_binarize</span>
        <span class="s1">binarized = label_binarize(</span>
            <span class="s1">y</span><span class="s0">,</span>
            <span class="s1">classes=classes</span><span class="s0">,</span>
            <span class="s1">neg_label=neg_label</span><span class="s0">,</span>
            <span class="s1">pos_label=pos_label</span><span class="s0">,</span>
            <span class="s1">sparse_output=sparse_output</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">assert_array_equal(toarray(binarized)</span><span class="s0">, </span><span class="s1">expected)</span>
        <span class="s0">assert </span><span class="s1">issparse(binarized) == sparse_output</span>

        <span class="s3"># check inverse</span>
        <span class="s1">y_type = type_of_target(y)</span>
        <span class="s0">if </span><span class="s1">y_type == </span><span class="s2">&quot;multiclass&quot;</span><span class="s1">:</span>
            <span class="s1">inversed = _inverse_binarize_multiclass(binarized</span><span class="s0">, </span><span class="s1">classes=classes)</span>

        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">inversed = _inverse_binarize_thresholding(</span>
                <span class="s1">binarized</span><span class="s0">,</span>
                <span class="s1">output_type=y_type</span><span class="s0">,</span>
                <span class="s1">classes=classes</span><span class="s0">,</span>
                <span class="s1">threshold=((neg_label + pos_label) / </span><span class="s4">2.0</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">)</span>

        <span class="s1">assert_array_equal(toarray(inversed)</span><span class="s0">, </span><span class="s1">toarray(y))</span>

        <span class="s3"># Check label binarizer</span>
        <span class="s1">lb = LabelBinarizer(</span>
            <span class="s1">neg_label=neg_label</span><span class="s0">, </span><span class="s1">pos_label=pos_label</span><span class="s0">, </span><span class="s1">sparse_output=sparse_output</span>
        <span class="s1">)</span>
        <span class="s1">binarized = lb.fit_transform(y)</span>
        <span class="s1">assert_array_equal(toarray(binarized)</span><span class="s0">, </span><span class="s1">expected)</span>
        <span class="s0">assert </span><span class="s1">issparse(binarized) == sparse_output</span>
        <span class="s1">inverse_output = lb.inverse_transform(binarized)</span>
        <span class="s1">assert_array_equal(toarray(inverse_output)</span><span class="s0">, </span><span class="s1">toarray(y))</span>
        <span class="s0">assert </span><span class="s1">issparse(inverse_output) == issparse(y)</span>


<span class="s0">def </span><span class="s1">test_label_binarize_binary():</span>
    <span class="s1">y = [</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">classes = [</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">pos_label = </span><span class="s4">2</span>
    <span class="s1">neg_label = -</span><span class="s4">1</span>
    <span class="s1">expected = np.array([[</span><span class="s4">2</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">2</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]])[:</span><span class="s0">, </span><span class="s4">1</span><span class="s1">].reshape((-</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">))</span>

    <span class="s1">check_binarized_results(y</span><span class="s0">, </span><span class="s1">classes</span><span class="s0">, </span><span class="s1">pos_label</span><span class="s0">, </span><span class="s1">neg_label</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s3"># Binary case where sparse_output = True will not result in a ValueError</span>
    <span class="s1">y = [</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">classes = [</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">pos_label = </span><span class="s4">3</span>
    <span class="s1">neg_label = </span><span class="s4">0</span>
    <span class="s1">expected = np.array([[</span><span class="s4">3</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">3</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]])[:</span><span class="s0">, </span><span class="s4">1</span><span class="s1">].reshape((-</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">))</span>

    <span class="s1">check_binarized_results(y</span><span class="s0">, </span><span class="s1">classes</span><span class="s0">, </span><span class="s1">pos_label</span><span class="s0">, </span><span class="s1">neg_label</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_label_binarize_multiclass():</span>
    <span class="s1">y = [</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span>
    <span class="s1">classes = [</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span>
    <span class="s1">pos_label = </span><span class="s4">2</span>
    <span class="s1">neg_label = </span><span class="s4">0</span>
    <span class="s1">expected = </span><span class="s4">2 </span><span class="s1">* np.eye(</span><span class="s4">3</span><span class="s1">)</span>

    <span class="s1">check_binarized_results(y</span><span class="s0">, </span><span class="s1">classes</span><span class="s0">, </span><span class="s1">pos_label</span><span class="s0">, </span><span class="s1">neg_label</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">label_binarize(</span>
            <span class="s1">y</span><span class="s0">, </span><span class="s1">classes=classes</span><span class="s0">, </span><span class="s1">neg_label=-</span><span class="s4">1</span><span class="s0">, </span><span class="s1">pos_label=pos_label</span><span class="s0">, </span><span class="s1">sparse_output=</span><span class="s0">True</span>
        <span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_label_binarize_multilabel():</span>
    <span class="s1">y_ind = np.array([[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]])</span>
    <span class="s1">classes = [</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span>
    <span class="s1">pos_label = </span><span class="s4">2</span>
    <span class="s1">neg_label = </span><span class="s4">0</span>
    <span class="s1">expected = pos_label * y_ind</span>
    <span class="s1">y_sparse = [</span>
        <span class="s1">sparse_matrix(y_ind)</span>
        <span class="s0">for </span><span class="s1">sparse_matrix </span><span class="s0">in </span><span class="s1">[</span>
            <span class="s1">coo_matrix</span><span class="s0">,</span>
            <span class="s1">csc_matrix</span><span class="s0">,</span>
            <span class="s1">csr_matrix</span><span class="s0">,</span>
            <span class="s1">dok_matrix</span><span class="s0">,</span>
            <span class="s1">lil_matrix</span><span class="s0">,</span>
        <span class="s1">]</span>
    <span class="s1">]</span>

    <span class="s0">for </span><span class="s1">y </span><span class="s0">in </span><span class="s1">[y_ind] + y_sparse:</span>
        <span class="s1">check_binarized_results(y</span><span class="s0">, </span><span class="s1">classes</span><span class="s0">, </span><span class="s1">pos_label</span><span class="s0">, </span><span class="s1">neg_label</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">label_binarize(</span>
            <span class="s1">y</span><span class="s0">, </span><span class="s1">classes=classes</span><span class="s0">, </span><span class="s1">neg_label=-</span><span class="s4">1</span><span class="s0">, </span><span class="s1">pos_label=pos_label</span><span class="s0">, </span><span class="s1">sparse_output=</span><span class="s0">True</span>
        <span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_invalid_input_label_binarize():</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">label_binarize([</span><span class="s4">0</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">classes=[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">pos_label=</span><span class="s4">0</span><span class="s0">, </span><span class="s1">neg_label=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;continuous target data is not &quot;</span><span class="s1">):</span>
        <span class="s1">label_binarize([</span><span class="s4">1.2</span><span class="s0">, </span><span class="s4">2.7</span><span class="s1">]</span><span class="s0">, </span><span class="s1">classes=[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">])</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;mismatch with the labels&quot;</span><span class="s1">):</span>
        <span class="s1">label_binarize([[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">classes=[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">])</span>


<span class="s0">def </span><span class="s1">test_inverse_binarize_multiclass():</span>
    <span class="s1">got = _inverse_binarize_multiclass(</span>
        <span class="s1">csr_matrix([[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]])</span><span class="s0">, </span><span class="s1">np.arange(</span><span class="s4">3</span><span class="s1">)</span>
    <span class="s1">)</span>
    <span class="s1">assert_array_equal(got</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">0</span><span class="s1">]))</span>


<span class="s0">def </span><span class="s1">test_nan_label_encoder():</span>
    <span class="s5">&quot;&quot;&quot;Check that label encoder encodes nans in transform. 
 
    Non-regression test for #22628. 
    &quot;&quot;&quot;</span>
    <span class="s1">le = LabelEncoder()</span>
    <span class="s1">le.fit([</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s1">np.nan])</span>

    <span class="s1">y_trans = le.transform([np.nan])</span>
    <span class="s1">assert_array_equal(y_trans</span><span class="s0">, </span><span class="s1">[</span><span class="s4">2</span><span class="s1">])</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;encoder&quot;</span><span class="s0">, </span><span class="s1">[LabelEncoder()</span><span class="s0">, </span><span class="s1">LabelBinarizer()</span><span class="s0">, </span><span class="s1">MultiLabelBinarizer()]</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_label_encoders_do_not_have_set_output(encoder):</span>
    <span class="s5">&quot;&quot;&quot;Check that label encoders do not define set_output and work with y as a kwarg. 
 
    Non-regression test for #26854. 
    &quot;&quot;&quot;</span>
    <span class="s0">assert not </span><span class="s1">hasattr(encoder</span><span class="s0">, </span><span class="s2">&quot;set_output&quot;</span><span class="s1">)</span>
    <span class="s1">y_encoded_with_kwarg = encoder.fit_transform(y=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">])</span>
    <span class="s1">y_encoded_positional = encoder.fit_transform([</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(y_encoded_with_kwarg</span><span class="s0">, </span><span class="s1">y_encoded_positional)</span>
</pre>
</body>
</html>