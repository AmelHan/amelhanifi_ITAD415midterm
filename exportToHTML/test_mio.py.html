<html>
<head>
<title>test_mio.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_mio.py</font>
</center></td></tr></table>
<pre><span class="s0">''' Nose test generators 
 
Need function load / save / roundtrip tests 
 
'''</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">OrderedDict</span>
<span class="s2">from </span><span class="s1">os.path </span><span class="s2">import </span><span class="s1">join </span><span class="s2">as </span><span class="s1">pjoin</span><span class="s2">, </span><span class="s1">dirname</span>
<span class="s2">from </span><span class="s1">glob </span><span class="s2">import </span><span class="s1">glob</span>
<span class="s2">from </span><span class="s1">io </span><span class="s2">import </span><span class="s1">BytesIO</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">from </span><span class="s1">tempfile </span><span class="s2">import </span><span class="s1">mkdtemp</span>

<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">import </span><span class="s1">shutil</span>
<span class="s2">import </span><span class="s1">gzip</span>

<span class="s2">from </span><span class="s1">numpy.testing </span><span class="s2">import </span><span class="s1">(assert_array_equal</span><span class="s2">, </span><span class="s1">assert_array_almost_equal</span><span class="s2">,</span>
                           <span class="s1">assert_equal</span><span class="s2">, </span><span class="s1">assert_</span><span class="s2">, </span><span class="s1">assert_warns</span><span class="s2">, </span><span class="s1">assert_allclose)</span>
<span class="s2">import </span><span class="s1">pytest</span>
<span class="s2">from </span><span class="s1">pytest </span><span class="s2">import </span><span class="s1">raises </span><span class="s2">as </span><span class="s1">assert_raises</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">numpy </span><span class="s2">import </span><span class="s1">array</span>
<span class="s2">import </span><span class="s1">scipy.sparse </span><span class="s2">as </span><span class="s1">SP</span>

<span class="s2">import </span><span class="s1">scipy.io</span>
<span class="s2">from </span><span class="s1">scipy.io.matlab </span><span class="s2">import </span><span class="s1">MatlabOpaque</span><span class="s2">, </span><span class="s1">MatlabFunction</span><span class="s2">, </span><span class="s1">MatlabObject</span>
<span class="s2">import </span><span class="s1">scipy.io.matlab._byteordercodes </span><span class="s2">as </span><span class="s1">boc</span>
<span class="s2">from </span><span class="s1">scipy.io.matlab._miobase </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">matdims</span><span class="s2">, </span><span class="s1">MatWriteError</span><span class="s2">, </span><span class="s1">MatReadError</span><span class="s2">, </span><span class="s1">matfile_version)</span>
<span class="s2">from </span><span class="s1">scipy.io.matlab._mio </span><span class="s2">import </span><span class="s1">mat_reader_factory</span><span class="s2">, </span><span class="s1">loadmat</span><span class="s2">, </span><span class="s1">savemat</span><span class="s2">, </span><span class="s1">whosmat</span>
<span class="s2">from </span><span class="s1">scipy.io.matlab._mio5 </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">MatFile5Writer</span><span class="s2">, </span><span class="s1">MatFile5Reader</span><span class="s2">, </span><span class="s1">varmats_from_mat</span><span class="s2">, </span><span class="s1">to_writeable</span><span class="s2">,</span>
    <span class="s1">EmptyStructMarker)</span>
<span class="s2">import </span><span class="s1">scipy.io.matlab._mio5_params </span><span class="s2">as </span><span class="s1">mio5p</span>

<span class="s1">test_data_path = pjoin(dirname(__file__)</span><span class="s2">, </span><span class="s3">'data'</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">mlarr(*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
    <span class="s0">&quot;&quot;&quot;Convenience function to return matlab-compatible 2-D array.&quot;&quot;&quot;</span>
    <span class="s1">arr = np.array(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
    <span class="s1">arr.shape = matdims(arr)</span>
    <span class="s2">return </span><span class="s1">arr</span>


<span class="s4"># Define cases to test</span>
<span class="s1">theta = np.pi/</span><span class="s5">4</span><span class="s1">*np.arange(</span><span class="s5">9</span><span class="s2">,</span><span class="s1">dtype=float).reshape(</span><span class="s5">1</span><span class="s2">,</span><span class="s5">9</span><span class="s1">)</span>
<span class="s1">case_table4 = [</span>
    <span class="s1">{</span><span class="s3">'name'</span><span class="s1">: </span><span class="s3">'double'</span><span class="s2">,</span>
     <span class="s3">'classes'</span><span class="s1">: {</span><span class="s3">'testdouble'</span><span class="s1">: </span><span class="s3">'double'</span><span class="s1">}</span><span class="s2">,</span>
     <span class="s3">'expected'</span><span class="s1">: {</span><span class="s3">'testdouble'</span><span class="s1">: theta}</span>
     <span class="s1">}]</span>
<span class="s1">case_table4.append(</span>
    <span class="s1">{</span><span class="s3">'name'</span><span class="s1">: </span><span class="s3">'string'</span><span class="s2">,</span>
     <span class="s3">'classes'</span><span class="s1">: {</span><span class="s3">'teststring'</span><span class="s1">: </span><span class="s3">'char'</span><span class="s1">}</span><span class="s2">,</span>
     <span class="s3">'expected'</span><span class="s1">: {</span><span class="s3">'teststring'</span><span class="s1">:</span>
                  <span class="s1">array([</span><span class="s3">'&quot;Do nine men interpret?&quot; &quot;Nine men,&quot; I nod.'</span><span class="s1">])}</span>
     <span class="s1">})</span>
<span class="s1">case_table4.append(</span>
    <span class="s1">{</span><span class="s3">'name'</span><span class="s1">: </span><span class="s3">'complex'</span><span class="s2">,</span>
     <span class="s3">'classes'</span><span class="s1">: {</span><span class="s3">'testcomplex'</span><span class="s1">: </span><span class="s3">'double'</span><span class="s1">}</span><span class="s2">,</span>
     <span class="s3">'expected'</span><span class="s1">: {</span><span class="s3">'testcomplex'</span><span class="s1">: np.cos(theta) + </span><span class="s5">1j</span><span class="s1">*np.sin(theta)}</span>
     <span class="s1">})</span>
<span class="s1">A = np.zeros((</span><span class="s5">3</span><span class="s2">,</span><span class="s5">5</span><span class="s1">))</span>
<span class="s1">A[</span><span class="s5">0</span><span class="s1">] = list(range(</span><span class="s5">1</span><span class="s2">,</span><span class="s5">6</span><span class="s1">))</span>
<span class="s1">A[:</span><span class="s2">,</span><span class="s5">0</span><span class="s1">] = list(range(</span><span class="s5">1</span><span class="s2">,</span><span class="s5">4</span><span class="s1">))</span>
<span class="s1">case_table4.append(</span>
    <span class="s1">{</span><span class="s3">'name'</span><span class="s1">: </span><span class="s3">'matrix'</span><span class="s2">,</span>
     <span class="s3">'classes'</span><span class="s1">: {</span><span class="s3">'testmatrix'</span><span class="s1">: </span><span class="s3">'double'</span><span class="s1">}</span><span class="s2">,</span>
     <span class="s3">'expected'</span><span class="s1">: {</span><span class="s3">'testmatrix'</span><span class="s1">: A}</span><span class="s2">,</span>
     <span class="s1">})</span>
<span class="s1">case_table4.append(</span>
    <span class="s1">{</span><span class="s3">'name'</span><span class="s1">: </span><span class="s3">'sparse'</span><span class="s2">,</span>
     <span class="s3">'classes'</span><span class="s1">: {</span><span class="s3">'testsparse'</span><span class="s1">: </span><span class="s3">'sparse'</span><span class="s1">}</span><span class="s2">,</span>
     <span class="s3">'expected'</span><span class="s1">: {</span><span class="s3">'testsparse'</span><span class="s1">: SP.coo_matrix(A)}</span><span class="s2">,</span>
     <span class="s1">})</span>
<span class="s1">B = A.astype(complex)</span>
<span class="s1">B[</span><span class="s5">0</span><span class="s2">,</span><span class="s5">0</span><span class="s1">] += </span><span class="s5">1j</span>
<span class="s1">case_table4.append(</span>
    <span class="s1">{</span><span class="s3">'name'</span><span class="s1">: </span><span class="s3">'sparsecomplex'</span><span class="s2">,</span>
     <span class="s3">'classes'</span><span class="s1">: {</span><span class="s3">'testsparsecomplex'</span><span class="s1">: </span><span class="s3">'sparse'</span><span class="s1">}</span><span class="s2">,</span>
     <span class="s3">'expected'</span><span class="s1">: {</span><span class="s3">'testsparsecomplex'</span><span class="s1">: SP.coo_matrix(B)}</span><span class="s2">,</span>
     <span class="s1">})</span>
<span class="s1">case_table4.append(</span>
    <span class="s1">{</span><span class="s3">'name'</span><span class="s1">: </span><span class="s3">'multi'</span><span class="s2">,</span>
     <span class="s3">'classes'</span><span class="s1">: {</span><span class="s3">'theta'</span><span class="s1">: </span><span class="s3">'double'</span><span class="s2">, </span><span class="s3">'a'</span><span class="s1">: </span><span class="s3">'double'</span><span class="s1">}</span><span class="s2">,</span>
     <span class="s3">'expected'</span><span class="s1">: {</span><span class="s3">'theta'</span><span class="s1">: theta</span><span class="s2">, </span><span class="s3">'a'</span><span class="s1">: A}</span><span class="s2">,</span>
     <span class="s1">})</span>
<span class="s1">case_table4.append(</span>
    <span class="s1">{</span><span class="s3">'name'</span><span class="s1">: </span><span class="s3">'minus'</span><span class="s2">,</span>
     <span class="s3">'classes'</span><span class="s1">: {</span><span class="s3">'testminus'</span><span class="s1">: </span><span class="s3">'double'</span><span class="s1">}</span><span class="s2">,</span>
     <span class="s3">'expected'</span><span class="s1">: {</span><span class="s3">'testminus'</span><span class="s1">: mlarr(-</span><span class="s5">1</span><span class="s1">)}</span><span class="s2">,</span>
     <span class="s1">})</span>
<span class="s1">case_table4.append(</span>
    <span class="s1">{</span><span class="s3">'name'</span><span class="s1">: </span><span class="s3">'onechar'</span><span class="s2">,</span>
     <span class="s3">'classes'</span><span class="s1">: {</span><span class="s3">'testonechar'</span><span class="s1">: </span><span class="s3">'char'</span><span class="s1">}</span><span class="s2">,</span>
     <span class="s3">'expected'</span><span class="s1">: {</span><span class="s3">'testonechar'</span><span class="s1">: array([</span><span class="s3">'r'</span><span class="s1">])}</span><span class="s2">,</span>
     <span class="s1">})</span>
<span class="s4"># Cell arrays stored as object arrays</span>
<span class="s1">CA = mlarr((  </span><span class="s4"># tuple for object array creation</span>
        <span class="s1">[]</span><span class="s2">,</span>
        <span class="s1">mlarr([</span><span class="s5">1</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">mlarr([[</span><span class="s5">1</span><span class="s2">,</span><span class="s5">2</span><span class="s1">]])</span><span class="s2">,</span>
        <span class="s1">mlarr([[</span><span class="s5">1</span><span class="s2">,</span><span class="s5">2</span><span class="s2">,</span><span class="s5">3</span><span class="s1">]]))</span><span class="s2">, </span><span class="s1">dtype=object).reshape(</span><span class="s5">1</span><span class="s2">,</span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span>
<span class="s1">CA[</span><span class="s5">0</span><span class="s2">,</span><span class="s5">0</span><span class="s1">] = array(</span>
    <span class="s1">[</span><span class="s3">'This cell contains this string and 3 arrays of increasing length'</span><span class="s1">])</span>
<span class="s1">case_table5 = [</span>
    <span class="s1">{</span><span class="s3">'name'</span><span class="s1">: </span><span class="s3">'cell'</span><span class="s2">,</span>
     <span class="s3">'classes'</span><span class="s1">: {</span><span class="s3">'testcell'</span><span class="s1">: </span><span class="s3">'cell'</span><span class="s1">}</span><span class="s2">,</span>
     <span class="s3">'expected'</span><span class="s1">: {</span><span class="s3">'testcell'</span><span class="s1">: CA}}]</span>
<span class="s1">CAE = mlarr((  </span><span class="s4"># tuple for object array creation</span>
    <span class="s1">mlarr(</span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">mlarr(</span><span class="s5">2</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">mlarr([])</span><span class="s2">,</span>
    <span class="s1">mlarr([])</span><span class="s2">,</span>
    <span class="s1">mlarr(</span><span class="s5">3</span><span class="s1">))</span><span class="s2">, </span><span class="s1">dtype=object).reshape(</span><span class="s5">1</span><span class="s2">,</span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span>
<span class="s1">objarr = np.empty((</span><span class="s5">1</span><span class="s2">,</span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span><span class="s1">dtype=object)</span>
<span class="s1">objarr[</span><span class="s5">0</span><span class="s2">,</span><span class="s5">0</span><span class="s1">] = mlarr(</span><span class="s5">1</span><span class="s1">)</span>
<span class="s1">case_table5.append(</span>
    <span class="s1">{</span><span class="s3">'name'</span><span class="s1">: </span><span class="s3">'scalarcell'</span><span class="s2">,</span>
     <span class="s3">'classes'</span><span class="s1">: {</span><span class="s3">'testscalarcell'</span><span class="s1">: </span><span class="s3">'cell'</span><span class="s1">}</span><span class="s2">,</span>
     <span class="s3">'expected'</span><span class="s1">: {</span><span class="s3">'testscalarcell'</span><span class="s1">: objarr}</span>
     <span class="s1">})</span>
<span class="s1">case_table5.append(</span>
    <span class="s1">{</span><span class="s3">'name'</span><span class="s1">: </span><span class="s3">'emptycell'</span><span class="s2">,</span>
     <span class="s3">'classes'</span><span class="s1">: {</span><span class="s3">'testemptycell'</span><span class="s1">: </span><span class="s3">'cell'</span><span class="s1">}</span><span class="s2">,</span>
     <span class="s3">'expected'</span><span class="s1">: {</span><span class="s3">'testemptycell'</span><span class="s1">: CAE}})</span>
<span class="s1">case_table5.append(</span>
    <span class="s1">{</span><span class="s3">'name'</span><span class="s1">: </span><span class="s3">'stringarray'</span><span class="s2">,</span>
     <span class="s3">'classes'</span><span class="s1">: {</span><span class="s3">'teststringarray'</span><span class="s1">: </span><span class="s3">'char'</span><span class="s1">}</span><span class="s2">,</span>
     <span class="s3">'expected'</span><span class="s1">: {</span><span class="s3">'teststringarray'</span><span class="s1">: array(</span>
    <span class="s1">[</span><span class="s3">'one  '</span><span class="s2">, </span><span class="s3">'two  '</span><span class="s2">, </span><span class="s3">'three'</span><span class="s1">])}</span><span class="s2">,</span>
     <span class="s1">})</span>
<span class="s1">case_table5.append(</span>
    <span class="s1">{</span><span class="s3">'name'</span><span class="s1">: </span><span class="s3">'3dmatrix'</span><span class="s2">,</span>
     <span class="s3">'classes'</span><span class="s1">: {</span><span class="s3">'test3dmatrix'</span><span class="s1">: </span><span class="s3">'double'</span><span class="s1">}</span><span class="s2">,</span>
     <span class="s3">'expected'</span><span class="s1">: {</span>
    <span class="s3">'test3dmatrix'</span><span class="s1">: np.transpose(np.reshape(list(range(</span><span class="s5">1</span><span class="s2">,</span><span class="s5">25</span><span class="s1">))</span><span class="s2">, </span><span class="s1">(</span><span class="s5">4</span><span class="s2">,</span><span class="s5">3</span><span class="s2">,</span><span class="s5">2</span><span class="s1">)))}</span>
     <span class="s1">})</span>
<span class="s1">st_sub_arr = array([np.sqrt(</span><span class="s5">2</span><span class="s1">)</span><span class="s2">,</span><span class="s1">np.exp(</span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span><span class="s1">np.pi]).reshape(</span><span class="s5">1</span><span class="s2">,</span><span class="s5">3</span><span class="s1">)</span>
<span class="s1">dtype = [(n</span><span class="s2">, </span><span class="s1">object) </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'stringfield'</span><span class="s2">, </span><span class="s3">'doublefield'</span><span class="s2">, </span><span class="s3">'complexfield'</span><span class="s1">]]</span>
<span class="s1">st1 = np.zeros((</span><span class="s5">1</span><span class="s2">,</span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype)</span>
<span class="s1">st1[</span><span class="s3">'stringfield'</span><span class="s1">][</span><span class="s5">0</span><span class="s2">,</span><span class="s5">0</span><span class="s1">] = array([</span><span class="s3">'Rats live on no evil star.'</span><span class="s1">])</span>
<span class="s1">st1[</span><span class="s3">'doublefield'</span><span class="s1">][</span><span class="s5">0</span><span class="s2">,</span><span class="s5">0</span><span class="s1">] = st_sub_arr</span>
<span class="s1">st1[</span><span class="s3">'complexfield'</span><span class="s1">][</span><span class="s5">0</span><span class="s2">,</span><span class="s5">0</span><span class="s1">] = st_sub_arr * (</span><span class="s5">1 </span><span class="s1">+ </span><span class="s5">1j</span><span class="s1">)</span>
<span class="s1">case_table5.append(</span>
    <span class="s1">{</span><span class="s3">'name'</span><span class="s1">: </span><span class="s3">'struct'</span><span class="s2">,</span>
     <span class="s3">'classes'</span><span class="s1">: {</span><span class="s3">'teststruct'</span><span class="s1">: </span><span class="s3">'struct'</span><span class="s1">}</span><span class="s2">,</span>
     <span class="s3">'expected'</span><span class="s1">: {</span><span class="s3">'teststruct'</span><span class="s1">: st1}</span>
     <span class="s1">})</span>
<span class="s1">CN = np.zeros((</span><span class="s5">1</span><span class="s2">,</span><span class="s5">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=object)</span>
<span class="s1">CN[</span><span class="s5">0</span><span class="s2">,</span><span class="s5">0</span><span class="s1">] = mlarr(</span><span class="s5">1</span><span class="s1">)</span>
<span class="s1">CN[</span><span class="s5">0</span><span class="s2">,</span><span class="s5">1</span><span class="s1">] = np.zeros((</span><span class="s5">1</span><span class="s2">,</span><span class="s5">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=object)</span>
<span class="s1">CN[</span><span class="s5">0</span><span class="s2">,</span><span class="s5">1</span><span class="s1">][</span><span class="s5">0</span><span class="s2">,</span><span class="s5">0</span><span class="s1">] = mlarr(</span><span class="s5">2</span><span class="s2">, </span><span class="s1">dtype=np.uint8)</span>
<span class="s1">CN[</span><span class="s5">0</span><span class="s2">,</span><span class="s5">1</span><span class="s1">][</span><span class="s5">0</span><span class="s2">,</span><span class="s5">1</span><span class="s1">] = mlarr([[</span><span class="s5">3</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=np.uint8)</span>
<span class="s1">CN[</span><span class="s5">0</span><span class="s2">,</span><span class="s5">1</span><span class="s1">][</span><span class="s5">0</span><span class="s2">,</span><span class="s5">2</span><span class="s1">] = np.zeros((</span><span class="s5">1</span><span class="s2">,</span><span class="s5">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=object)</span>
<span class="s1">CN[</span><span class="s5">0</span><span class="s2">,</span><span class="s5">1</span><span class="s1">][</span><span class="s5">0</span><span class="s2">,</span><span class="s5">2</span><span class="s1">][</span><span class="s5">0</span><span class="s2">,</span><span class="s5">0</span><span class="s1">] = mlarr(</span><span class="s5">4</span><span class="s2">, </span><span class="s1">dtype=np.uint8)</span>
<span class="s1">CN[</span><span class="s5">0</span><span class="s2">,</span><span class="s5">1</span><span class="s1">][</span><span class="s5">0</span><span class="s2">,</span><span class="s5">2</span><span class="s1">][</span><span class="s5">0</span><span class="s2">,</span><span class="s5">1</span><span class="s1">] = mlarr(</span><span class="s5">5</span><span class="s2">, </span><span class="s1">dtype=np.uint8)</span>
<span class="s1">case_table5.append(</span>
    <span class="s1">{</span><span class="s3">'name'</span><span class="s1">: </span><span class="s3">'cellnest'</span><span class="s2">,</span>
     <span class="s3">'classes'</span><span class="s1">: {</span><span class="s3">'testcellnest'</span><span class="s1">: </span><span class="s3">'cell'</span><span class="s1">}</span><span class="s2">,</span>
     <span class="s3">'expected'</span><span class="s1">: {</span><span class="s3">'testcellnest'</span><span class="s1">: CN}</span><span class="s2">,</span>
     <span class="s1">})</span>
<span class="s1">st2 = np.empty((</span><span class="s5">1</span><span class="s2">,</span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=[(n</span><span class="s2">, </span><span class="s1">object) </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'one'</span><span class="s2">, </span><span class="s3">'two'</span><span class="s1">]])</span>
<span class="s1">st2[</span><span class="s5">0</span><span class="s2">,</span><span class="s5">0</span><span class="s1">][</span><span class="s3">'one'</span><span class="s1">] = mlarr(</span><span class="s5">1</span><span class="s1">)</span>
<span class="s1">st2[</span><span class="s5">0</span><span class="s2">,</span><span class="s5">0</span><span class="s1">][</span><span class="s3">'two'</span><span class="s1">] = np.empty((</span><span class="s5">1</span><span class="s2">,</span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=[(</span><span class="s3">'three'</span><span class="s2">, </span><span class="s1">object)])</span>
<span class="s1">st2[</span><span class="s5">0</span><span class="s2">,</span><span class="s5">0</span><span class="s1">][</span><span class="s3">'two'</span><span class="s1">][</span><span class="s5">0</span><span class="s2">,</span><span class="s5">0</span><span class="s1">][</span><span class="s3">'three'</span><span class="s1">] = array([</span><span class="s3">'number 3'</span><span class="s1">])</span>
<span class="s1">case_table5.append(</span>
    <span class="s1">{</span><span class="s3">'name'</span><span class="s1">: </span><span class="s3">'structnest'</span><span class="s2">,</span>
     <span class="s3">'classes'</span><span class="s1">: {</span><span class="s3">'teststructnest'</span><span class="s1">: </span><span class="s3">'struct'</span><span class="s1">}</span><span class="s2">,</span>
     <span class="s3">'expected'</span><span class="s1">: {</span><span class="s3">'teststructnest'</span><span class="s1">: st2}</span>
     <span class="s1">})</span>
<span class="s1">a = np.empty((</span><span class="s5">1</span><span class="s2">,</span><span class="s5">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=[(n</span><span class="s2">, </span><span class="s1">object) </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'one'</span><span class="s2">, </span><span class="s3">'two'</span><span class="s1">]])</span>
<span class="s1">a[</span><span class="s5">0</span><span class="s2">,</span><span class="s5">0</span><span class="s1">][</span><span class="s3">'one'</span><span class="s1">] = mlarr(</span><span class="s5">1</span><span class="s1">)</span>
<span class="s1">a[</span><span class="s5">0</span><span class="s2">,</span><span class="s5">0</span><span class="s1">][</span><span class="s3">'two'</span><span class="s1">] = mlarr(</span><span class="s5">2</span><span class="s1">)</span>
<span class="s1">a[</span><span class="s5">0</span><span class="s2">,</span><span class="s5">1</span><span class="s1">][</span><span class="s3">'one'</span><span class="s1">] = array([</span><span class="s3">'number 1'</span><span class="s1">])</span>
<span class="s1">a[</span><span class="s5">0</span><span class="s2">,</span><span class="s5">1</span><span class="s1">][</span><span class="s3">'two'</span><span class="s1">] = array([</span><span class="s3">'number 2'</span><span class="s1">])</span>
<span class="s1">case_table5.append(</span>
    <span class="s1">{</span><span class="s3">'name'</span><span class="s1">: </span><span class="s3">'structarr'</span><span class="s2">,</span>
     <span class="s3">'classes'</span><span class="s1">: {</span><span class="s3">'teststructarr'</span><span class="s1">: </span><span class="s3">'struct'</span><span class="s1">}</span><span class="s2">,</span>
     <span class="s3">'expected'</span><span class="s1">: {</span><span class="s3">'teststructarr'</span><span class="s1">: a}</span>
     <span class="s1">})</span>
<span class="s1">ODT = np.dtype([(n</span><span class="s2">, </span><span class="s1">object) </span><span class="s2">for </span><span class="s1">n </span><span class="s2">in</span>
                 <span class="s1">[</span><span class="s3">'expr'</span><span class="s2">, </span><span class="s3">'inputExpr'</span><span class="s2">, </span><span class="s3">'args'</span><span class="s2">,</span>
                  <span class="s3">'isEmpty'</span><span class="s2">, </span><span class="s3">'numArgs'</span><span class="s2">, </span><span class="s3">'version'</span><span class="s1">]])</span>
<span class="s1">MO = MatlabObject(np.zeros((</span><span class="s5">1</span><span class="s2">,</span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=ODT)</span><span class="s2">, </span><span class="s3">'inline'</span><span class="s1">)</span>
<span class="s1">m0 = MO[</span><span class="s5">0</span><span class="s2">,</span><span class="s5">0</span><span class="s1">]</span>
<span class="s1">m0[</span><span class="s3">'expr'</span><span class="s1">] = array([</span><span class="s3">'x'</span><span class="s1">])</span>
<span class="s1">m0[</span><span class="s3">'inputExpr'</span><span class="s1">] = array([</span><span class="s3">' x = INLINE_INPUTS_{1};'</span><span class="s1">])</span>
<span class="s1">m0[</span><span class="s3">'args'</span><span class="s1">] = array([</span><span class="s3">'x'</span><span class="s1">])</span>
<span class="s1">m0[</span><span class="s3">'isEmpty'</span><span class="s1">] = mlarr(</span><span class="s5">0</span><span class="s1">)</span>
<span class="s1">m0[</span><span class="s3">'numArgs'</span><span class="s1">] = mlarr(</span><span class="s5">1</span><span class="s1">)</span>
<span class="s1">m0[</span><span class="s3">'version'</span><span class="s1">] = mlarr(</span><span class="s5">1</span><span class="s1">)</span>
<span class="s1">case_table5.append(</span>
    <span class="s1">{</span><span class="s3">'name'</span><span class="s1">: </span><span class="s3">'object'</span><span class="s2">,</span>
     <span class="s3">'classes'</span><span class="s1">: {</span><span class="s3">'testobject'</span><span class="s1">: </span><span class="s3">'object'</span><span class="s1">}</span><span class="s2">,</span>
     <span class="s3">'expected'</span><span class="s1">: {</span><span class="s3">'testobject'</span><span class="s1">: MO}</span>
     <span class="s1">})</span>
<span class="s1">fp_u_str = open(pjoin(test_data_path</span><span class="s2">, </span><span class="s3">'japanese_utf8.txt'</span><span class="s1">)</span><span class="s2">, </span><span class="s3">'rb'</span><span class="s1">)</span>
<span class="s1">u_str = fp_u_str.read().decode(</span><span class="s3">'utf-8'</span><span class="s1">)</span>
<span class="s1">fp_u_str.close()</span>
<span class="s1">case_table5.append(</span>
    <span class="s1">{</span><span class="s3">'name'</span><span class="s1">: </span><span class="s3">'unicode'</span><span class="s2">,</span>
     <span class="s3">'classes'</span><span class="s1">: {</span><span class="s3">'testunicode'</span><span class="s1">: </span><span class="s3">'char'</span><span class="s1">}</span><span class="s2">,</span>
    <span class="s3">'expected'</span><span class="s1">: {</span><span class="s3">'testunicode'</span><span class="s1">: array([u_str])}</span>
     <span class="s1">})</span>
<span class="s1">case_table5.append(</span>
    <span class="s1">{</span><span class="s3">'name'</span><span class="s1">: </span><span class="s3">'sparse'</span><span class="s2">,</span>
     <span class="s3">'classes'</span><span class="s1">: {</span><span class="s3">'testsparse'</span><span class="s1">: </span><span class="s3">'sparse'</span><span class="s1">}</span><span class="s2">,</span>
     <span class="s3">'expected'</span><span class="s1">: {</span><span class="s3">'testsparse'</span><span class="s1">: SP.coo_matrix(A)}</span><span class="s2">,</span>
     <span class="s1">})</span>
<span class="s1">case_table5.append(</span>
    <span class="s1">{</span><span class="s3">'name'</span><span class="s1">: </span><span class="s3">'sparsecomplex'</span><span class="s2">,</span>
     <span class="s3">'classes'</span><span class="s1">: {</span><span class="s3">'testsparsecomplex'</span><span class="s1">: </span><span class="s3">'sparse'</span><span class="s1">}</span><span class="s2">,</span>
     <span class="s3">'expected'</span><span class="s1">: {</span><span class="s3">'testsparsecomplex'</span><span class="s1">: SP.coo_matrix(B)}</span><span class="s2">,</span>
     <span class="s1">})</span>
<span class="s1">case_table5.append(</span>
    <span class="s1">{</span><span class="s3">'name'</span><span class="s1">: </span><span class="s3">'bool'</span><span class="s2">,</span>
     <span class="s3">'classes'</span><span class="s1">: {</span><span class="s3">'testbools'</span><span class="s1">: </span><span class="s3">'logical'</span><span class="s1">}</span><span class="s2">,</span>
     <span class="s3">'expected'</span><span class="s1">: {</span><span class="s3">'testbools'</span><span class="s1">:</span>
                  <span class="s1">array([[</span><span class="s2">True</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s2">False</span><span class="s1">]])}</span><span class="s2">,</span>
     <span class="s1">})</span>

<span class="s1">case_table5_rt = case_table5[:]</span>
<span class="s4"># Inline functions can't be concatenated in matlab, so RT only</span>
<span class="s1">case_table5_rt.append(</span>
    <span class="s1">{</span><span class="s3">'name'</span><span class="s1">: </span><span class="s3">'objectarray'</span><span class="s2">,</span>
     <span class="s3">'classes'</span><span class="s1">: {</span><span class="s3">'testobjectarray'</span><span class="s1">: </span><span class="s3">'object'</span><span class="s1">}</span><span class="s2">,</span>
     <span class="s3">'expected'</span><span class="s1">: {</span><span class="s3">'testobjectarray'</span><span class="s1">: np.repeat(MO</span><span class="s2">, </span><span class="s5">2</span><span class="s1">).reshape(</span><span class="s5">1</span><span class="s2">,</span><span class="s5">2</span><span class="s1">)}})</span>


<span class="s2">def </span><span class="s1">types_compatible(var1</span><span class="s2">, </span><span class="s1">var2):</span>
    <span class="s0">&quot;&quot;&quot;Check if types are same or compatible. 
 
    0-D numpy scalars are compatible with bare python scalars. 
    &quot;&quot;&quot;</span>
    <span class="s1">type1 = type(var1)</span>
    <span class="s1">type2 = type(var2)</span>
    <span class="s2">if </span><span class="s1">type1 </span><span class="s2">is </span><span class="s1">type2:</span>
        <span class="s2">return True</span>
    <span class="s2">if </span><span class="s1">type1 </span><span class="s2">is </span><span class="s1">np.ndarray </span><span class="s2">and </span><span class="s1">var1.shape == ():</span>
        <span class="s2">return </span><span class="s1">type(var1.item()) </span><span class="s2">is </span><span class="s1">type2</span>
    <span class="s2">if </span><span class="s1">type2 </span><span class="s2">is </span><span class="s1">np.ndarray </span><span class="s2">and </span><span class="s1">var2.shape == ():</span>
        <span class="s2">return </span><span class="s1">type(var2.item()) </span><span class="s2">is </span><span class="s1">type1</span>
    <span class="s2">return False</span>


<span class="s2">def </span><span class="s1">_check_level(label</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">actual):</span>
    <span class="s0">&quot;&quot;&quot; Check one level of a potentially nested array &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">SP.issparse(expected):  </span><span class="s4"># allow different types of sparse matrices</span>
        <span class="s1">assert_(SP.issparse(actual))</span>
        <span class="s1">assert_array_almost_equal(actual.toarray()</span><span class="s2">,</span>
                                  <span class="s1">expected.toarray()</span><span class="s2">,</span>
                                  <span class="s1">err_msg=label</span><span class="s2">,</span>
                                  <span class="s1">decimal=</span><span class="s5">5</span><span class="s1">)</span>
        <span class="s2">return</span>
    <span class="s4"># Check types are as expected</span>
    <span class="s1">assert_(types_compatible(expected</span><span class="s2">, </span><span class="s1">actual)</span><span class="s2">,</span>
            <span class="s3">&quot;Expected type %s, got %s at %s&quot; </span><span class="s1">%</span>
            <span class="s1">(type(expected)</span><span class="s2">, </span><span class="s1">type(actual)</span><span class="s2">, </span><span class="s1">label))</span>
    <span class="s4"># A field in a record array may not be an ndarray</span>
    <span class="s4"># A scalar from a record array will be type np.void</span>
    <span class="s2">if not </span><span class="s1">isinstance(expected</span><span class="s2">,</span>
                      <span class="s1">(np.void</span><span class="s2">, </span><span class="s1">np.ndarray</span><span class="s2">, </span><span class="s1">MatlabObject)):</span>
        <span class="s1">assert_equal(expected</span><span class="s2">, </span><span class="s1">actual)</span>
        <span class="s2">return</span>
    <span class="s4"># This is an ndarray-like thing</span>
    <span class="s1">assert_(expected.shape == actual.shape</span><span class="s2">,</span>
            <span class="s1">msg=</span><span class="s3">'Expected shape {}, got {} at {}'</span><span class="s1">.format(expected.shape</span><span class="s2">,</span>
                                                     <span class="s1">actual.shape</span><span class="s2">,</span>
                                                     <span class="s1">label))</span>
    <span class="s1">ex_dtype = expected.dtype</span>
    <span class="s2">if </span><span class="s1">ex_dtype.hasobject:  </span><span class="s4"># array of objects</span>
        <span class="s2">if </span><span class="s1">isinstance(expected</span><span class="s2">, </span><span class="s1">MatlabObject):</span>
            <span class="s1">assert_equal(expected.classname</span><span class="s2">, </span><span class="s1">actual.classname)</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">ev </span><span class="s2">in </span><span class="s1">enumerate(expected):</span>
            <span class="s1">level_label = </span><span class="s3">&quot;%s, [%d], &quot; </span><span class="s1">% (label</span><span class="s2">, </span><span class="s1">i)</span>
            <span class="s1">_check_level(level_label</span><span class="s2">, </span><span class="s1">ev</span><span class="s2">, </span><span class="s1">actual[i])</span>
        <span class="s2">return</span>
    <span class="s2">if </span><span class="s1">ex_dtype.fields:  </span><span class="s4"># probably recarray</span>
        <span class="s2">for </span><span class="s1">fn </span><span class="s2">in </span><span class="s1">ex_dtype.fields:</span>
            <span class="s1">level_label = </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">label</span><span class="s2">}</span><span class="s3">, field </span><span class="s2">{</span><span class="s1">fn</span><span class="s2">}</span><span class="s3">, &quot;</span>
            <span class="s1">_check_level(level_label</span><span class="s2">,</span>
                         <span class="s1">expected[fn]</span><span class="s2">, </span><span class="s1">actual[fn])</span>
        <span class="s2">return</span>
    <span class="s2">if </span><span class="s1">ex_dtype.type </span><span class="s2">in </span><span class="s1">(str</span><span class="s2">,  </span><span class="s4"># string or bool</span>
                         <span class="s1">np.unicode_</span><span class="s2">,</span>
                         <span class="s1">np.bool_):</span>
        <span class="s1">assert_equal(actual</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">err_msg=label)</span>
        <span class="s2">return</span>
    <span class="s4"># Something numeric</span>
    <span class="s1">assert_array_almost_equal(actual</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">err_msg=label</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s5">5</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_load_check_case(name</span><span class="s2">, </span><span class="s1">files</span><span class="s2">, </span><span class="s1">case):</span>
    <span class="s2">for </span><span class="s1">file_name </span><span class="s2">in </span><span class="s1">files:</span>
        <span class="s1">matdict = loadmat(file_name</span><span class="s2">, </span><span class="s1">struct_as_record=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">label = </span><span class="s3">f&quot;test </span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s3">; file </span><span class="s2">{</span><span class="s1">file_name</span><span class="s2">}</span><span class="s3">&quot;</span>
        <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">expected </span><span class="s2">in </span><span class="s1">case.items():</span>
            <span class="s1">k_label = </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">label</span><span class="s2">}</span><span class="s3">, variable </span><span class="s2">{</span><span class="s1">k</span><span class="s2">}</span><span class="s3">&quot;</span>
            <span class="s1">assert_(k </span><span class="s2">in </span><span class="s1">matdict</span><span class="s2">, </span><span class="s3">&quot;Missing key at %s&quot; </span><span class="s1">% k_label)</span>
            <span class="s1">_check_level(k_label</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">matdict[k])</span>


<span class="s2">def </span><span class="s1">_whos_check_case(name</span><span class="s2">, </span><span class="s1">files</span><span class="s2">, </span><span class="s1">case</span><span class="s2">, </span><span class="s1">classes):</span>
    <span class="s2">for </span><span class="s1">file_name </span><span class="s2">in </span><span class="s1">files:</span>
        <span class="s1">label = </span><span class="s3">f&quot;test </span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s3">; file </span><span class="s2">{</span><span class="s1">file_name</span><span class="s2">}</span><span class="s3">&quot;</span>

        <span class="s1">whos = whosmat(file_name)</span>

        <span class="s1">expected_whos = [</span>
            <span class="s1">(k</span><span class="s2">, </span><span class="s1">expected.shape</span><span class="s2">, </span><span class="s1">classes[k]) </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">expected </span><span class="s2">in </span><span class="s1">case.items()]</span>

        <span class="s1">whos.sort()</span>
        <span class="s1">expected_whos.sort()</span>
        <span class="s1">assert_equal(whos</span><span class="s2">, </span><span class="s1">expected_whos</span><span class="s2">,</span>
                     <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">label</span><span class="s2">}</span><span class="s3">: </span><span class="s2">{</span><span class="s1">whos</span><span class="s2">!r} </span><span class="s3">!= </span><span class="s2">{</span><span class="s1">expected_whos</span><span class="s2">!r}</span><span class="s3">&quot;</span>
                     <span class="s1">)</span>


<span class="s4"># Round trip tests</span>
<span class="s2">def </span><span class="s1">_rt_check_case(name</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">format):</span>
    <span class="s1">mat_stream = BytesIO()</span>
    <span class="s1">savemat(mat_stream</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">format=format)</span>
    <span class="s1">mat_stream.seek(</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">_load_check_case(name</span><span class="s2">, </span><span class="s1">[mat_stream]</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s4"># generator for tests</span>
<span class="s2">def </span><span class="s1">_cases(version</span><span class="s2">, </span><span class="s1">filt=</span><span class="s3">'test%(name)s_*.mat'</span><span class="s1">):</span>
    <span class="s2">if </span><span class="s1">version == </span><span class="s3">'4'</span><span class="s1">:</span>
        <span class="s1">cases = case_table4</span>
    <span class="s2">elif </span><span class="s1">version == </span><span class="s3">'5'</span><span class="s1">:</span>
        <span class="s1">cases = case_table5</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">assert </span><span class="s1">version == </span><span class="s3">'5_rt'</span>
        <span class="s1">cases = case_table5_rt</span>
    <span class="s2">for </span><span class="s1">case </span><span class="s2">in </span><span class="s1">cases:</span>
        <span class="s1">name = case[</span><span class="s3">'name'</span><span class="s1">]</span>
        <span class="s1">expected = case[</span><span class="s3">'expected'</span><span class="s1">]</span>
        <span class="s2">if </span><span class="s1">filt </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">files = </span><span class="s2">None</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">use_filt = pjoin(test_data_path</span><span class="s2">, </span><span class="s1">filt % dict(name=name))</span>
            <span class="s1">files = glob(use_filt)</span>
            <span class="s2">assert </span><span class="s1">len(files) &gt; </span><span class="s5">0</span><span class="s2">, </span><span class="s1">\</span>
                <span class="s3">f&quot;No files for test </span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s3">using filter </span><span class="s2">{</span><span class="s1">filt</span><span class="s2">}</span><span class="s3">&quot;</span>
        <span class="s1">classes = case[</span><span class="s3">'classes'</span><span class="s1">]</span>
        <span class="s2">yield </span><span class="s1">name</span><span class="s2">, </span><span class="s1">files</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">classes</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'version'</span><span class="s2">, </span><span class="s1">(</span><span class="s3">'4'</span><span class="s2">, </span><span class="s3">'5'</span><span class="s1">))</span>
<span class="s2">def </span><span class="s1">test_load(version):</span>
    <span class="s2">for </span><span class="s1">case </span><span class="s2">in </span><span class="s1">_cases(version):</span>
        <span class="s1">_load_check_case(*case[:</span><span class="s5">3</span><span class="s1">])</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'version'</span><span class="s2">, </span><span class="s1">(</span><span class="s3">'4'</span><span class="s2">, </span><span class="s3">'5'</span><span class="s1">))</span>
<span class="s2">def </span><span class="s1">test_whos(version):</span>
    <span class="s2">for </span><span class="s1">case </span><span class="s2">in </span><span class="s1">_cases(version):</span>
        <span class="s1">_whos_check_case(*case)</span>


<span class="s4"># generator for round trip tests</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'version, fmts'</span><span class="s2">, </span><span class="s1">[</span>
    <span class="s1">(</span><span class="s3">'4'</span><span class="s2">, </span><span class="s1">[</span><span class="s3">'4'</span><span class="s2">, </span><span class="s3">'5'</span><span class="s1">])</span><span class="s2">,</span>
    <span class="s1">(</span><span class="s3">'5_rt'</span><span class="s2">, </span><span class="s1">[</span><span class="s3">'5'</span><span class="s1">])</span><span class="s2">,</span>
<span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_round_trip(version</span><span class="s2">, </span><span class="s1">fmts):</span>
    <span class="s2">for </span><span class="s1">case </span><span class="s2">in </span><span class="s1">_cases(version</span><span class="s2">, </span><span class="s1">filt=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">for </span><span class="s1">fmt </span><span class="s2">in </span><span class="s1">fmts:</span>
            <span class="s1">_rt_check_case(case[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">case[</span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">fmt)</span>


<span class="s2">def </span><span class="s1">test_gzip_simple():</span>
    <span class="s1">xdense = np.zeros((</span><span class="s5">20</span><span class="s2">,</span><span class="s5">20</span><span class="s1">))</span>
    <span class="s1">xdense[</span><span class="s5">2</span><span class="s2">,</span><span class="s5">3</span><span class="s1">] = </span><span class="s5">2.3</span>
    <span class="s1">xdense[</span><span class="s5">4</span><span class="s2">,</span><span class="s5">5</span><span class="s1">] = </span><span class="s5">4.5</span>
    <span class="s1">x = SP.csc_matrix(xdense)</span>

    <span class="s1">name = </span><span class="s3">'gzip_test'</span>
    <span class="s1">expected = {</span><span class="s3">'x'</span><span class="s1">:x}</span>
    <span class="s1">format = </span><span class="s3">'4'</span>

    <span class="s1">tmpdir = mkdtemp()</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">fname = pjoin(tmpdir</span><span class="s2">,</span><span class="s1">name)</span>
        <span class="s1">mat_stream = gzip.open(fname</span><span class="s2">, </span><span class="s1">mode=</span><span class="s3">'wb'</span><span class="s1">)</span>
        <span class="s1">savemat(mat_stream</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">format=format)</span>
        <span class="s1">mat_stream.close()</span>

        <span class="s1">mat_stream = gzip.open(fname</span><span class="s2">, </span><span class="s1">mode=</span><span class="s3">'rb'</span><span class="s1">)</span>
        <span class="s1">actual = loadmat(mat_stream</span><span class="s2">, </span><span class="s1">struct_as_record=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">mat_stream.close()</span>
    <span class="s2">finally</span><span class="s1">:</span>
        <span class="s1">shutil.rmtree(tmpdir)</span>

    <span class="s1">assert_array_almost_equal(actual[</span><span class="s3">'x'</span><span class="s1">].toarray()</span><span class="s2">,</span>
                              <span class="s1">expected[</span><span class="s3">'x'</span><span class="s1">].toarray()</span><span class="s2">,</span>
                              <span class="s1">err_msg=repr(actual))</span>


<span class="s2">def </span><span class="s1">test_multiple_open():</span>
    <span class="s4"># Ticket #1039, on Windows: check that files are not left open</span>
    <span class="s1">tmpdir = mkdtemp()</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">x = dict(x=np.zeros((</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)))</span>

        <span class="s1">fname = pjoin(tmpdir</span><span class="s2">, </span><span class="s3">&quot;a.mat&quot;</span><span class="s1">)</span>

        <span class="s4"># Check that file is not left open</span>
        <span class="s1">savemat(fname</span><span class="s2">, </span><span class="s1">x)</span>
        <span class="s1">os.unlink(fname)</span>
        <span class="s1">savemat(fname</span><span class="s2">, </span><span class="s1">x)</span>
        <span class="s1">loadmat(fname)</span>
        <span class="s1">os.unlink(fname)</span>

        <span class="s4"># Check that stream is left open</span>
        <span class="s1">f = open(fname</span><span class="s2">, </span><span class="s3">'wb'</span><span class="s1">)</span>
        <span class="s1">savemat(f</span><span class="s2">, </span><span class="s1">x)</span>
        <span class="s1">f.seek(</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">f.close()</span>

        <span class="s1">f = open(fname</span><span class="s2">, </span><span class="s3">'rb'</span><span class="s1">)</span>
        <span class="s1">loadmat(f)</span>
        <span class="s1">f.seek(</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">f.close()</span>
    <span class="s2">finally</span><span class="s1">:</span>
        <span class="s1">shutil.rmtree(tmpdir)</span>


<span class="s2">def </span><span class="s1">test_mat73():</span>
    <span class="s4"># Check any hdf5 files raise an error</span>
    <span class="s1">filenames = glob(</span>
        <span class="s1">pjoin(test_data_path</span><span class="s2">, </span><span class="s3">'testhdf5*.mat'</span><span class="s1">))</span>
    <span class="s1">assert_(len(filenames) &gt; </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s2">for </span><span class="s1">filename </span><span class="s2">in </span><span class="s1">filenames:</span>
        <span class="s1">fp = open(filename</span><span class="s2">, </span><span class="s3">'rb'</span><span class="s1">)</span>
        <span class="s1">assert_raises(NotImplementedError</span><span class="s2">,</span>
                      <span class="s1">loadmat</span><span class="s2">,</span>
                      <span class="s1">fp</span><span class="s2">,</span>
                      <span class="s1">struct_as_record=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">fp.close()</span>


<span class="s2">def </span><span class="s1">test_warnings():</span>
    <span class="s4"># This test is an echo of the previous behavior, which was to raise a</span>
    <span class="s4"># warning if the user triggered a search for mat files on the Python system</span>
    <span class="s4"># path. We can remove the test in the next version after upcoming (0.13).</span>
    <span class="s1">fname = pjoin(test_data_path</span><span class="s2">, </span><span class="s3">'testdouble_7.1_GLNX86.mat'</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">warnings.catch_warnings():</span>
        <span class="s1">warnings.simplefilter(</span><span class="s3">'error'</span><span class="s1">)</span>
        <span class="s4"># This should not generate a warning</span>
        <span class="s1">loadmat(fname</span><span class="s2">, </span><span class="s1">struct_as_record=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s4"># This neither</span>
        <span class="s1">loadmat(fname</span><span class="s2">, </span><span class="s1">struct_as_record=</span><span class="s2">False</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_regression_653():</span>
    <span class="s4"># Saving a dictionary with only invalid keys used to raise an error. Now we</span>
    <span class="s4"># save this as an empty struct in matlab space.</span>
    <span class="s1">sio = BytesIO()</span>
    <span class="s1">savemat(sio</span><span class="s2">, </span><span class="s1">{</span><span class="s3">'d'</span><span class="s1">:{</span><span class="s5">1</span><span class="s1">:</span><span class="s5">2</span><span class="s1">}}</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">'5'</span><span class="s1">)</span>
    <span class="s1">back = loadmat(sio)[</span><span class="s3">'d'</span><span class="s1">]</span>
    <span class="s4"># Check we got an empty struct equivalent</span>
    <span class="s1">assert_equal(back.shape</span><span class="s2">, </span><span class="s1">(</span><span class="s5">1</span><span class="s2">,</span><span class="s5">1</span><span class="s1">))</span>
    <span class="s1">assert_equal(back.dtype</span><span class="s2">, </span><span class="s1">np.dtype(object))</span>
    <span class="s1">assert_(back[</span><span class="s5">0</span><span class="s2">,</span><span class="s5">0</span><span class="s1">] </span><span class="s2">is None</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_structname_len():</span>
    <span class="s4"># Test limit for length of field names in structs</span>
    <span class="s1">lim = </span><span class="s5">31</span>
    <span class="s1">fldname = </span><span class="s3">'a' </span><span class="s1">* lim</span>
    <span class="s1">st1 = np.zeros((</span><span class="s5">1</span><span class="s2">,</span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=[(fldname</span><span class="s2">, </span><span class="s1">object)])</span>
    <span class="s1">savemat(BytesIO()</span><span class="s2">, </span><span class="s1">{</span><span class="s3">'longstruct'</span><span class="s1">: st1}</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">'5'</span><span class="s1">)</span>
    <span class="s1">fldname = </span><span class="s3">'a' </span><span class="s1">* (lim+</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">st1 = np.zeros((</span><span class="s5">1</span><span class="s2">,</span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=[(fldname</span><span class="s2">, </span><span class="s1">object)])</span>
    <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">savemat</span><span class="s2">, </span><span class="s1">BytesIO()</span><span class="s2">,</span>
                  <span class="s1">{</span><span class="s3">'longstruct'</span><span class="s1">: st1}</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">'5'</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_4_and_long_field_names_incompatible():</span>
    <span class="s4"># Long field names option not supported in 4</span>
    <span class="s1">my_struct = np.zeros((</span><span class="s5">1</span><span class="s2">,</span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span><span class="s1">dtype=[(</span><span class="s3">'my_fieldname'</span><span class="s2">,</span><span class="s1">object)])</span>
    <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">savemat</span><span class="s2">, </span><span class="s1">BytesIO()</span><span class="s2">,</span>
                  <span class="s1">{</span><span class="s3">'my_struct'</span><span class="s1">:my_struct}</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">'4'</span><span class="s2">, </span><span class="s1">long_field_names=</span><span class="s2">True</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_long_field_names():</span>
    <span class="s4"># Test limit for length of field names in structs</span>
    <span class="s1">lim = </span><span class="s5">63</span>
    <span class="s1">fldname = </span><span class="s3">'a' </span><span class="s1">* lim</span>
    <span class="s1">st1 = np.zeros((</span><span class="s5">1</span><span class="s2">,</span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=[(fldname</span><span class="s2">, </span><span class="s1">object)])</span>
    <span class="s1">savemat(BytesIO()</span><span class="s2">, </span><span class="s1">{</span><span class="s3">'longstruct'</span><span class="s1">: st1}</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">'5'</span><span class="s2">,</span><span class="s1">long_field_names=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">fldname = </span><span class="s3">'a' </span><span class="s1">* (lim+</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">st1 = np.zeros((</span><span class="s5">1</span><span class="s2">,</span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=[(fldname</span><span class="s2">, </span><span class="s1">object)])</span>
    <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">savemat</span><span class="s2">, </span><span class="s1">BytesIO()</span><span class="s2">,</span>
                  <span class="s1">{</span><span class="s3">'longstruct'</span><span class="s1">: st1}</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">'5'</span><span class="s2">,</span><span class="s1">long_field_names=</span><span class="s2">True</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_long_field_names_in_struct():</span>
    <span class="s4"># Regression test - long_field_names was erased if you passed a struct</span>
    <span class="s4"># within a struct</span>
    <span class="s1">lim = </span><span class="s5">63</span>
    <span class="s1">fldname = </span><span class="s3">'a' </span><span class="s1">* lim</span>
    <span class="s1">cell = np.ndarray((</span><span class="s5">1</span><span class="s2">,</span><span class="s5">2</span><span class="s1">)</span><span class="s2">,</span><span class="s1">dtype=object)</span>
    <span class="s1">st1 = np.zeros((</span><span class="s5">1</span><span class="s2">,</span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=[(fldname</span><span class="s2">, </span><span class="s1">object)])</span>
    <span class="s1">cell[</span><span class="s5">0</span><span class="s2">,</span><span class="s5">0</span><span class="s1">] = st1</span>
    <span class="s1">cell[</span><span class="s5">0</span><span class="s2">,</span><span class="s5">1</span><span class="s1">] = st1</span>
    <span class="s1">savemat(BytesIO()</span><span class="s2">, </span><span class="s1">{</span><span class="s3">'longstruct'</span><span class="s1">: cell}</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">'5'</span><span class="s2">,</span><span class="s1">long_field_names=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s4">#</span>
    <span class="s4"># Check to make sure it fails with long field names off</span>
    <span class="s4">#</span>
    <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">savemat</span><span class="s2">, </span><span class="s1">BytesIO()</span><span class="s2">,</span>
                  <span class="s1">{</span><span class="s3">'longstruct'</span><span class="s1">: cell}</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">'5'</span><span class="s2">, </span><span class="s1">long_field_names=</span><span class="s2">False</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_cell_with_one_thing_in_it():</span>
    <span class="s4"># Regression test - make a cell array that's 1 x 2 and put two</span>
    <span class="s4"># strings in it. It works. Make a cell array that's 1 x 1 and put</span>
    <span class="s4"># a string in it. It should work but, in the old days, it didn't.</span>
    <span class="s1">cells = np.ndarray((</span><span class="s5">1</span><span class="s2">,</span><span class="s5">2</span><span class="s1">)</span><span class="s2">,</span><span class="s1">dtype=object)</span>
    <span class="s1">cells[</span><span class="s5">0</span><span class="s2">,</span><span class="s5">0</span><span class="s1">] = </span><span class="s3">'Hello'</span>
    <span class="s1">cells[</span><span class="s5">0</span><span class="s2">,</span><span class="s5">1</span><span class="s1">] = </span><span class="s3">'World'</span>
    <span class="s1">savemat(BytesIO()</span><span class="s2">, </span><span class="s1">{</span><span class="s3">'x'</span><span class="s1">: cells}</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">'5'</span><span class="s1">)</span>

    <span class="s1">cells = np.ndarray((</span><span class="s5">1</span><span class="s2">,</span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span><span class="s1">dtype=object)</span>
    <span class="s1">cells[</span><span class="s5">0</span><span class="s2">,</span><span class="s5">0</span><span class="s1">] = </span><span class="s3">'Hello, world'</span>
    <span class="s1">savemat(BytesIO()</span><span class="s2">, </span><span class="s1">{</span><span class="s3">'x'</span><span class="s1">: cells}</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">'5'</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_writer_properties():</span>
    <span class="s4"># Tests getting, setting of properties of matrix writer</span>
    <span class="s1">mfw = MatFile5Writer(BytesIO())</span>
    <span class="s1">assert_equal(mfw.global_vars</span><span class="s2">, </span><span class="s1">[])</span>
    <span class="s1">mfw.global_vars = [</span><span class="s3">'avar'</span><span class="s1">]</span>
    <span class="s1">assert_equal(mfw.global_vars</span><span class="s2">, </span><span class="s1">[</span><span class="s3">'avar'</span><span class="s1">])</span>
    <span class="s1">assert_equal(mfw.unicode_strings</span><span class="s2">, False</span><span class="s1">)</span>
    <span class="s1">mfw.unicode_strings = </span><span class="s2">True</span>
    <span class="s1">assert_equal(mfw.unicode_strings</span><span class="s2">, True</span><span class="s1">)</span>
    <span class="s1">assert_equal(mfw.long_field_names</span><span class="s2">, False</span><span class="s1">)</span>
    <span class="s1">mfw.long_field_names = </span><span class="s2">True</span>
    <span class="s1">assert_equal(mfw.long_field_names</span><span class="s2">, True</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_use_small_element():</span>
    <span class="s4"># Test whether we're using small data element or not</span>
    <span class="s1">sio = BytesIO()</span>
    <span class="s1">wtr = MatFile5Writer(sio)</span>
    <span class="s4"># First check size for no sde for name</span>
    <span class="s1">arr = np.zeros(</span><span class="s5">10</span><span class="s1">)</span>
    <span class="s1">wtr.put_variables({</span><span class="s3">'aaaaa'</span><span class="s1">: arr})</span>
    <span class="s1">w_sz = len(sio.getvalue())</span>
    <span class="s4"># Check small name results in largish difference in size</span>
    <span class="s1">sio.truncate(</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">sio.seek(</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">wtr.put_variables({</span><span class="s3">'aaaa'</span><span class="s1">: arr})</span>
    <span class="s1">assert_(w_sz - len(sio.getvalue()) &gt; </span><span class="s5">4</span><span class="s1">)</span>
    <span class="s4"># Whereas increasing name size makes less difference</span>
    <span class="s1">sio.truncate(</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">sio.seek(</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">wtr.put_variables({</span><span class="s3">'aaaaaa'</span><span class="s1">: arr})</span>
    <span class="s1">assert_(len(sio.getvalue()) - w_sz &lt; </span><span class="s5">4</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_save_dict():</span>
    <span class="s4"># Test that both dict and OrderedDict can be saved (as recarray),</span>
    <span class="s4"># loaded as matstruct, and preserve order</span>
    <span class="s1">ab_exp = np.array([[(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)]]</span><span class="s2">, </span><span class="s1">dtype=[(</span><span class="s3">'a'</span><span class="s2">, </span><span class="s1">object)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">'b'</span><span class="s2">, </span><span class="s1">object)])</span>
    <span class="s2">for </span><span class="s1">dict_type </span><span class="s2">in </span><span class="s1">(dict</span><span class="s2">, </span><span class="s1">OrderedDict):</span>
        <span class="s4"># Initialize with tuples to keep order</span>
        <span class="s1">d = dict_type([(</span><span class="s3">'a'</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">'b'</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)])</span>
        <span class="s1">stream = BytesIO()</span>
        <span class="s1">savemat(stream</span><span class="s2">, </span><span class="s1">{</span><span class="s3">'dict'</span><span class="s1">: d})</span>
        <span class="s1">stream.seek(</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">vals = loadmat(stream)[</span><span class="s3">'dict'</span><span class="s1">]</span>
        <span class="s1">assert_equal(vals.dtype.names</span><span class="s2">, </span><span class="s1">(</span><span class="s3">'a'</span><span class="s2">, </span><span class="s3">'b'</span><span class="s1">))</span>
        <span class="s1">assert_array_equal(vals</span><span class="s2">, </span><span class="s1">ab_exp)</span>


<span class="s2">def </span><span class="s1">test_1d_shape():</span>
    <span class="s4"># New 5 behavior is 1D -&gt; row vector</span>
    <span class="s1">arr = np.arange(</span><span class="s5">5</span><span class="s1">)</span>
    <span class="s2">for </span><span class="s1">format </span><span class="s2">in </span><span class="s1">(</span><span class="s3">'4'</span><span class="s2">, </span><span class="s3">'5'</span><span class="s1">):</span>
        <span class="s4"># Column is the default</span>
        <span class="s1">stream = BytesIO()</span>
        <span class="s1">savemat(stream</span><span class="s2">, </span><span class="s1">{</span><span class="s3">'oned'</span><span class="s1">: arr}</span><span class="s2">, </span><span class="s1">format=format)</span>
        <span class="s1">vals = loadmat(stream)</span>
        <span class="s1">assert_equal(vals[</span><span class="s3">'oned'</span><span class="s1">].shape</span><span class="s2">, </span><span class="s1">(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">5</span><span class="s1">))</span>
        <span class="s4"># can be explicitly 'column' for oned_as</span>
        <span class="s1">stream = BytesIO()</span>
        <span class="s1">savemat(stream</span><span class="s2">, </span><span class="s1">{</span><span class="s3">'oned'</span><span class="s1">:arr}</span><span class="s2">,</span>
                <span class="s1">format=format</span><span class="s2">,</span>
                <span class="s1">oned_as=</span><span class="s3">'column'</span><span class="s1">)</span>
        <span class="s1">vals = loadmat(stream)</span>
        <span class="s1">assert_equal(vals[</span><span class="s3">'oned'</span><span class="s1">].shape</span><span class="s2">, </span><span class="s1">(</span><span class="s5">5</span><span class="s2">,</span><span class="s5">1</span><span class="s1">))</span>
        <span class="s4"># but different from 'row'</span>
        <span class="s1">stream = BytesIO()</span>
        <span class="s1">savemat(stream</span><span class="s2">, </span><span class="s1">{</span><span class="s3">'oned'</span><span class="s1">:arr}</span><span class="s2">,</span>
                <span class="s1">format=format</span><span class="s2">,</span>
                <span class="s1">oned_as=</span><span class="s3">'row'</span><span class="s1">)</span>
        <span class="s1">vals = loadmat(stream)</span>
        <span class="s1">assert_equal(vals[</span><span class="s3">'oned'</span><span class="s1">].shape</span><span class="s2">, </span><span class="s1">(</span><span class="s5">1</span><span class="s2">,</span><span class="s5">5</span><span class="s1">))</span>


<span class="s2">def </span><span class="s1">test_compression():</span>
    <span class="s1">arr = np.zeros(</span><span class="s5">100</span><span class="s1">).reshape((</span><span class="s5">5</span><span class="s2">,</span><span class="s5">20</span><span class="s1">))</span>
    <span class="s1">arr[</span><span class="s5">2</span><span class="s2">,</span><span class="s5">10</span><span class="s1">] = </span><span class="s5">1</span>
    <span class="s1">stream = BytesIO()</span>
    <span class="s1">savemat(stream</span><span class="s2">, </span><span class="s1">{</span><span class="s3">'arr'</span><span class="s1">:arr})</span>
    <span class="s1">raw_len = len(stream.getvalue())</span>
    <span class="s1">vals = loadmat(stream)</span>
    <span class="s1">assert_array_equal(vals[</span><span class="s3">'arr'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">arr)</span>
    <span class="s1">stream = BytesIO()</span>
    <span class="s1">savemat(stream</span><span class="s2">, </span><span class="s1">{</span><span class="s3">'arr'</span><span class="s1">:arr}</span><span class="s2">, </span><span class="s1">do_compression=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">compressed_len = len(stream.getvalue())</span>
    <span class="s1">vals = loadmat(stream)</span>
    <span class="s1">assert_array_equal(vals[</span><span class="s3">'arr'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">arr)</span>
    <span class="s1">assert_(raw_len &gt; compressed_len)</span>
    <span class="s4"># Concatenate, test later</span>
    <span class="s1">arr2 = arr.copy()</span>
    <span class="s1">arr2[</span><span class="s5">0</span><span class="s2">,</span><span class="s5">0</span><span class="s1">] = </span><span class="s5">1</span>
    <span class="s1">stream = BytesIO()</span>
    <span class="s1">savemat(stream</span><span class="s2">, </span><span class="s1">{</span><span class="s3">'arr'</span><span class="s1">:arr</span><span class="s2">, </span><span class="s3">'arr2'</span><span class="s1">:arr2}</span><span class="s2">, </span><span class="s1">do_compression=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">vals = loadmat(stream)</span>
    <span class="s1">assert_array_equal(vals[</span><span class="s3">'arr2'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">arr2)</span>
    <span class="s1">stream = BytesIO()</span>
    <span class="s1">savemat(stream</span><span class="s2">, </span><span class="s1">{</span><span class="s3">'arr'</span><span class="s1">:arr</span><span class="s2">, </span><span class="s3">'arr2'</span><span class="s1">:arr2}</span><span class="s2">, </span><span class="s1">do_compression=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">vals = loadmat(stream)</span>
    <span class="s1">assert_array_equal(vals[</span><span class="s3">'arr2'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">arr2)</span>


<span class="s2">def </span><span class="s1">test_single_object():</span>
    <span class="s1">stream = BytesIO()</span>
    <span class="s1">savemat(stream</span><span class="s2">, </span><span class="s1">{</span><span class="s3">'A'</span><span class="s1">:np.array(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">dtype=object)})</span>


<span class="s2">def </span><span class="s1">test_skip_variable():</span>
    <span class="s4"># Test skipping over the first of two variables in a MAT file</span>
    <span class="s4"># using mat_reader_factory and put_variables to read them in.</span>
    <span class="s4">#</span>
    <span class="s4"># This is a regression test of a problem that's caused by</span>
    <span class="s4"># using the compressed file reader seek instead of the raw file</span>
    <span class="s4"># I/O seek when skipping over a compressed chunk.</span>
    <span class="s4">#</span>
    <span class="s4"># The problem arises when the chunk is large: this file has</span>
    <span class="s4"># a 256x256 array of random (uncompressible) doubles.</span>
    <span class="s4">#</span>
    <span class="s1">filename = pjoin(test_data_path</span><span class="s2">,</span><span class="s3">'test_skip_variable.mat'</span><span class="s1">)</span>
    <span class="s4">#</span>
    <span class="s4"># Prove that it loads with loadmat</span>
    <span class="s4">#</span>
    <span class="s1">d = loadmat(filename</span><span class="s2">, </span><span class="s1">struct_as_record=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">assert_(</span><span class="s3">'first' </span><span class="s2">in </span><span class="s1">d)</span>
    <span class="s1">assert_(</span><span class="s3">'second' </span><span class="s2">in </span><span class="s1">d)</span>
    <span class="s4">#</span>
    <span class="s4"># Make the factory</span>
    <span class="s4">#</span>
    <span class="s1">factory</span><span class="s2">, </span><span class="s1">file_opened = mat_reader_factory(filename</span><span class="s2">, </span><span class="s1">struct_as_record=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s4">#</span>
    <span class="s4"># This is where the factory breaks with an error in MatMatrixGetter.to_next</span>
    <span class="s4">#</span>
    <span class="s1">d = factory.get_variables(</span><span class="s3">'second'</span><span class="s1">)</span>
    <span class="s1">assert_(</span><span class="s3">'second' </span><span class="s2">in </span><span class="s1">d)</span>
    <span class="s1">factory.mat_stream.close()</span>


<span class="s2">def </span><span class="s1">test_empty_struct():</span>
    <span class="s4"># ticket 885</span>
    <span class="s1">filename = pjoin(test_data_path</span><span class="s2">,</span><span class="s3">'test_empty_struct.mat'</span><span class="s1">)</span>
    <span class="s4"># before ticket fix, this would crash with ValueError, empty data</span>
    <span class="s4"># type</span>
    <span class="s1">d = loadmat(filename</span><span class="s2">, </span><span class="s1">struct_as_record=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">a = d[</span><span class="s3">'a'</span><span class="s1">]</span>
    <span class="s1">assert_equal(a.shape</span><span class="s2">, </span><span class="s1">(</span><span class="s5">1</span><span class="s2">,</span><span class="s5">1</span><span class="s1">))</span>
    <span class="s1">assert_equal(a.dtype</span><span class="s2">, </span><span class="s1">np.dtype(object))</span>
    <span class="s1">assert_(a[</span><span class="s5">0</span><span class="s2">,</span><span class="s5">0</span><span class="s1">] </span><span class="s2">is None</span><span class="s1">)</span>
    <span class="s1">stream = BytesIO()</span>
    <span class="s1">arr = np.array(()</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">'U'</span><span class="s1">)</span>
    <span class="s4"># before ticket fix, this used to give data type not understood</span>
    <span class="s1">savemat(stream</span><span class="s2">, </span><span class="s1">{</span><span class="s3">'arr'</span><span class="s1">:arr})</span>
    <span class="s1">d = loadmat(stream)</span>
    <span class="s1">a2 = d[</span><span class="s3">'arr'</span><span class="s1">]</span>
    <span class="s1">assert_array_equal(a2</span><span class="s2">, </span><span class="s1">arr)</span>


<span class="s2">def </span><span class="s1">test_save_empty_dict():</span>
    <span class="s4"># saving empty dict also gives empty struct</span>
    <span class="s1">stream = BytesIO()</span>
    <span class="s1">savemat(stream</span><span class="s2">, </span><span class="s1">{</span><span class="s3">'arr'</span><span class="s1">: {}})</span>
    <span class="s1">d = loadmat(stream)</span>
    <span class="s1">a = d[</span><span class="s3">'arr'</span><span class="s1">]</span>
    <span class="s1">assert_equal(a.shape</span><span class="s2">, </span><span class="s1">(</span><span class="s5">1</span><span class="s2">,</span><span class="s5">1</span><span class="s1">))</span>
    <span class="s1">assert_equal(a.dtype</span><span class="s2">, </span><span class="s1">np.dtype(object))</span>
    <span class="s1">assert_(a[</span><span class="s5">0</span><span class="s2">,</span><span class="s5">0</span><span class="s1">] </span><span class="s2">is None</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">assert_any_equal(output</span><span class="s2">, </span><span class="s1">alternatives):</span>
    <span class="s0">&quot;&quot;&quot; Assert `output` is equal to at least one element in `alternatives` 
    &quot;&quot;&quot;</span>
    <span class="s1">one_equal = </span><span class="s2">False</span>
    <span class="s2">for </span><span class="s1">expected </span><span class="s2">in </span><span class="s1">alternatives:</span>
        <span class="s2">if </span><span class="s1">np.all(output == expected):</span>
            <span class="s1">one_equal = </span><span class="s2">True</span>
            <span class="s2">break</span>
    <span class="s1">assert_(one_equal)</span>


<span class="s2">def </span><span class="s1">test_to_writeable():</span>
    <span class="s4"># Test to_writeable function</span>
    <span class="s1">res = to_writeable(np.array([</span><span class="s5">1</span><span class="s1">]))  </span><span class="s4"># pass through ndarrays</span>
    <span class="s1">assert_equal(res.shape</span><span class="s2">, </span><span class="s1">(</span><span class="s5">1</span><span class="s2">,</span><span class="s1">))</span>
    <span class="s1">assert_array_equal(res</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s4"># Dict fields can be written in any order</span>
    <span class="s1">expected1 = np.array([(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">dtype=[(</span><span class="s3">'a'</span><span class="s2">, </span><span class="s3">'|O8'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">'b'</span><span class="s2">, </span><span class="s3">'|O8'</span><span class="s1">)])</span>
    <span class="s1">expected2 = np.array([(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">dtype=[(</span><span class="s3">'b'</span><span class="s2">, </span><span class="s3">'|O8'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">'a'</span><span class="s2">, </span><span class="s3">'|O8'</span><span class="s1">)])</span>
    <span class="s1">alternatives = (expected1</span><span class="s2">, </span><span class="s1">expected2)</span>
    <span class="s1">assert_any_equal(to_writeable({</span><span class="s3">'a'</span><span class="s1">:</span><span class="s5">1</span><span class="s2">,</span><span class="s3">'b'</span><span class="s1">:</span><span class="s5">2</span><span class="s1">})</span><span class="s2">, </span><span class="s1">alternatives)</span>
    <span class="s4"># Fields with underscores discarded</span>
    <span class="s1">assert_any_equal(to_writeable({</span><span class="s3">'a'</span><span class="s1">:</span><span class="s5">1</span><span class="s2">,</span><span class="s3">'b'</span><span class="s1">:</span><span class="s5">2</span><span class="s2">, </span><span class="s3">'_c'</span><span class="s1">:</span><span class="s5">3</span><span class="s1">})</span><span class="s2">, </span><span class="s1">alternatives)</span>
    <span class="s4"># Not-string fields discarded</span>
    <span class="s1">assert_any_equal(to_writeable({</span><span class="s3">'a'</span><span class="s1">:</span><span class="s5">1</span><span class="s2">,</span><span class="s3">'b'</span><span class="s1">:</span><span class="s5">2</span><span class="s2">, </span><span class="s5">100</span><span class="s1">:</span><span class="s5">3</span><span class="s1">})</span><span class="s2">, </span><span class="s1">alternatives)</span>
    <span class="s4"># String fields that are valid Python identifiers discarded</span>
    <span class="s1">assert_any_equal(to_writeable({</span><span class="s3">'a'</span><span class="s1">:</span><span class="s5">1</span><span class="s2">,</span><span class="s3">'b'</span><span class="s1">:</span><span class="s5">2</span><span class="s2">, </span><span class="s3">'99'</span><span class="s1">:</span><span class="s5">3</span><span class="s1">})</span><span class="s2">, </span><span class="s1">alternatives)</span>
    <span class="s4"># Object with field names is equivalent</span>

    <span class="s2">class </span><span class="s1">klass:</span>
        <span class="s2">pass</span>

    <span class="s1">c = klass</span>
    <span class="s1">c.a = </span><span class="s5">1</span>
    <span class="s1">c.b = </span><span class="s5">2</span>
    <span class="s1">assert_any_equal(to_writeable(c)</span><span class="s2">, </span><span class="s1">alternatives)</span>
    <span class="s4"># empty list and tuple go to empty array</span>
    <span class="s1">res = to_writeable([])</span>
    <span class="s1">assert_equal(res.shape</span><span class="s2">, </span><span class="s1">(</span><span class="s5">0</span><span class="s2">,</span><span class="s1">))</span>
    <span class="s1">assert_equal(res.dtype.type</span><span class="s2">, </span><span class="s1">np.float64)</span>
    <span class="s1">res = to_writeable(())</span>
    <span class="s1">assert_equal(res.shape</span><span class="s2">, </span><span class="s1">(</span><span class="s5">0</span><span class="s2">,</span><span class="s1">))</span>
    <span class="s1">assert_equal(res.dtype.type</span><span class="s2">, </span><span class="s1">np.float64)</span>
    <span class="s4"># None -&gt; None</span>
    <span class="s1">assert_(to_writeable(</span><span class="s2">None</span><span class="s1">) </span><span class="s2">is None</span><span class="s1">)</span>
    <span class="s4"># String to strings</span>
    <span class="s1">assert_equal(to_writeable(</span><span class="s3">'a string'</span><span class="s1">).dtype.type</span><span class="s2">, </span><span class="s1">np.str_)</span>
    <span class="s4"># Scalars to numpy to NumPy scalars</span>
    <span class="s1">res = to_writeable(</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(res.shape</span><span class="s2">, </span><span class="s1">())</span>
    <span class="s1">assert_equal(res.dtype.type</span><span class="s2">, </span><span class="s1">np.array(</span><span class="s5">1</span><span class="s1">).dtype.type)</span>
    <span class="s1">assert_array_equal(res</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s4"># Empty dict returns EmptyStructMarker</span>
    <span class="s1">assert_(to_writeable({}) </span><span class="s2">is </span><span class="s1">EmptyStructMarker)</span>
    <span class="s4"># Object does not have (even empty) __dict__</span>
    <span class="s1">assert_(to_writeable(object()) </span><span class="s2">is None</span><span class="s1">)</span>
    <span class="s4"># Custom object does have empty __dict__, returns EmptyStructMarker</span>

    <span class="s2">class </span><span class="s1">C:</span>
        <span class="s2">pass</span>

    <span class="s1">assert_(to_writeable(c()) </span><span class="s2">is </span><span class="s1">EmptyStructMarker)</span>
    <span class="s4"># dict keys with legal characters are convertible</span>
    <span class="s1">res = to_writeable({</span><span class="s3">'a'</span><span class="s1">: </span><span class="s5">1</span><span class="s1">})[</span><span class="s3">'a'</span><span class="s1">]</span>
    <span class="s1">assert_equal(res.shape</span><span class="s2">, </span><span class="s1">(</span><span class="s5">1</span><span class="s2">,</span><span class="s1">))</span>
    <span class="s1">assert_equal(res.dtype.type</span><span class="s2">, </span><span class="s1">np.object_)</span>
    <span class="s4"># Only fields with illegal characters, falls back to EmptyStruct</span>
    <span class="s1">assert_(to_writeable({</span><span class="s3">'1'</span><span class="s1">:</span><span class="s5">1</span><span class="s1">}) </span><span class="s2">is </span><span class="s1">EmptyStructMarker)</span>
    <span class="s1">assert_(to_writeable({</span><span class="s3">'_a'</span><span class="s1">:</span><span class="s5">1</span><span class="s1">}) </span><span class="s2">is </span><span class="s1">EmptyStructMarker)</span>
    <span class="s4"># Unless there are valid fields, in which case structured array</span>
    <span class="s1">assert_equal(to_writeable({</span><span class="s3">'1'</span><span class="s1">:</span><span class="s5">1</span><span class="s2">, </span><span class="s3">'f'</span><span class="s1">: </span><span class="s5">2</span><span class="s1">})</span><span class="s2">,</span>
                 <span class="s1">np.array([(</span><span class="s5">2</span><span class="s2">,</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">dtype=[(</span><span class="s3">'f'</span><span class="s2">, </span><span class="s3">'|O8'</span><span class="s1">)]))</span>


<span class="s2">def </span><span class="s1">test_recarray():</span>
    <span class="s4"># check roundtrip of structured array</span>
    <span class="s1">dt = [(</span><span class="s3">'f1'</span><span class="s2">, </span><span class="s3">'f8'</span><span class="s1">)</span><span class="s2">,</span>
          <span class="s1">(</span><span class="s3">'f2'</span><span class="s2">, </span><span class="s3">'S10'</span><span class="s1">)]</span>
    <span class="s1">arr = np.zeros((</span><span class="s5">2</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=dt)</span>
    <span class="s1">arr[</span><span class="s5">0</span><span class="s1">][</span><span class="s3">'f1'</span><span class="s1">] = </span><span class="s5">0.5</span>
    <span class="s1">arr[</span><span class="s5">0</span><span class="s1">][</span><span class="s3">'f2'</span><span class="s1">] = </span><span class="s3">'python'</span>
    <span class="s1">arr[</span><span class="s5">1</span><span class="s1">][</span><span class="s3">'f1'</span><span class="s1">] = </span><span class="s5">99</span>
    <span class="s1">arr[</span><span class="s5">1</span><span class="s1">][</span><span class="s3">'f2'</span><span class="s1">] = </span><span class="s3">'not perl'</span>
    <span class="s1">stream = BytesIO()</span>
    <span class="s1">savemat(stream</span><span class="s2">, </span><span class="s1">{</span><span class="s3">'arr'</span><span class="s1">: arr})</span>
    <span class="s1">d = loadmat(stream</span><span class="s2">, </span><span class="s1">struct_as_record=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">a20 = d[</span><span class="s3">'arr'</span><span class="s1">][</span><span class="s5">0</span><span class="s2">,</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">assert_equal(a20.f1</span><span class="s2">, </span><span class="s5">0.5</span><span class="s1">)</span>
    <span class="s1">assert_equal(a20.f2</span><span class="s2">, </span><span class="s3">'python'</span><span class="s1">)</span>
    <span class="s1">d = loadmat(stream</span><span class="s2">, </span><span class="s1">struct_as_record=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">a20 = d[</span><span class="s3">'arr'</span><span class="s1">][</span><span class="s5">0</span><span class="s2">,</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">assert_equal(a20[</span><span class="s3">'f1'</span><span class="s1">]</span><span class="s2">, </span><span class="s5">0.5</span><span class="s1">)</span>
    <span class="s1">assert_equal(a20[</span><span class="s3">'f2'</span><span class="s1">]</span><span class="s2">, </span><span class="s3">'python'</span><span class="s1">)</span>
    <span class="s4"># structs always come back as object types</span>
    <span class="s1">assert_equal(a20.dtype</span><span class="s2">, </span><span class="s1">np.dtype([(</span><span class="s3">'f1'</span><span class="s2">, </span><span class="s3">'O'</span><span class="s1">)</span><span class="s2">,</span>
                                      <span class="s1">(</span><span class="s3">'f2'</span><span class="s2">, </span><span class="s3">'O'</span><span class="s1">)]))</span>
    <span class="s1">a21 = d[</span><span class="s3">'arr'</span><span class="s1">].flat[</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">assert_equal(a21[</span><span class="s3">'f1'</span><span class="s1">]</span><span class="s2">, </span><span class="s5">99</span><span class="s1">)</span>
    <span class="s1">assert_equal(a21[</span><span class="s3">'f2'</span><span class="s1">]</span><span class="s2">, </span><span class="s3">'not perl'</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_save_object():</span>
    <span class="s2">class </span><span class="s1">C:</span>
        <span class="s2">pass</span>
    <span class="s1">c = C()</span>
    <span class="s1">c.field1 = </span><span class="s5">1</span>
    <span class="s1">c.field2 = </span><span class="s3">'a string'</span>
    <span class="s1">stream = BytesIO()</span>
    <span class="s1">savemat(stream</span><span class="s2">, </span><span class="s1">{</span><span class="s3">'c'</span><span class="s1">: c})</span>
    <span class="s1">d = loadmat(stream</span><span class="s2">, </span><span class="s1">struct_as_record=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">c2 = d[</span><span class="s3">'c'</span><span class="s1">][</span><span class="s5">0</span><span class="s2">,</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">assert_equal(c2.field1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(c2.field2</span><span class="s2">, </span><span class="s3">'a string'</span><span class="s1">)</span>
    <span class="s1">d = loadmat(stream</span><span class="s2">, </span><span class="s1">struct_as_record=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">c2 = d[</span><span class="s3">'c'</span><span class="s1">][</span><span class="s5">0</span><span class="s2">,</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">assert_equal(c2[</span><span class="s3">'field1'</span><span class="s1">]</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(c2[</span><span class="s3">'field2'</span><span class="s1">]</span><span class="s2">, </span><span class="s3">'a string'</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_read_opts():</span>
    <span class="s4"># tests if read is seeing option sets, at initialization and after</span>
    <span class="s4"># initialization</span>
    <span class="s1">arr = np.arange(</span><span class="s5">6</span><span class="s1">).reshape(</span><span class="s5">1</span><span class="s2">,</span><span class="s5">6</span><span class="s1">)</span>
    <span class="s1">stream = BytesIO()</span>
    <span class="s1">savemat(stream</span><span class="s2">, </span><span class="s1">{</span><span class="s3">'a'</span><span class="s1">: arr})</span>
    <span class="s1">rdr = MatFile5Reader(stream)</span>
    <span class="s1">back_dict = rdr.get_variables()</span>
    <span class="s1">rarr = back_dict[</span><span class="s3">'a'</span><span class="s1">]</span>
    <span class="s1">assert_array_equal(rarr</span><span class="s2">, </span><span class="s1">arr)</span>
    <span class="s1">rdr = MatFile5Reader(stream</span><span class="s2">, </span><span class="s1">squeeze_me=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">assert_array_equal(rdr.get_variables()[</span><span class="s3">'a'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">arr.reshape((</span><span class="s5">6</span><span class="s2">,</span><span class="s1">)))</span>
    <span class="s1">rdr.squeeze_me = </span><span class="s2">False</span>
    <span class="s1">assert_array_equal(rarr</span><span class="s2">, </span><span class="s1">arr)</span>
    <span class="s1">rdr = MatFile5Reader(stream</span><span class="s2">, </span><span class="s1">byte_order=boc.native_code)</span>
    <span class="s1">assert_array_equal(rdr.get_variables()[</span><span class="s3">'a'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">arr)</span>
    <span class="s4"># inverted byte code leads to error on read because of swapped</span>
    <span class="s4"># header etc.</span>
    <span class="s1">rdr = MatFile5Reader(stream</span><span class="s2">, </span><span class="s1">byte_order=boc.swapped_code)</span>
    <span class="s1">assert_raises(Exception</span><span class="s2">, </span><span class="s1">rdr.get_variables)</span>
    <span class="s1">rdr.byte_order = boc.native_code</span>
    <span class="s1">assert_array_equal(rdr.get_variables()[</span><span class="s3">'a'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">arr)</span>
    <span class="s1">arr = np.array([</span><span class="s3">'a string'</span><span class="s1">])</span>
    <span class="s1">stream.truncate(</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">stream.seek(</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">savemat(stream</span><span class="s2">, </span><span class="s1">{</span><span class="s3">'a'</span><span class="s1">: arr})</span>
    <span class="s1">rdr = MatFile5Reader(stream)</span>
    <span class="s1">assert_array_equal(rdr.get_variables()[</span><span class="s3">'a'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">arr)</span>
    <span class="s1">rdr = MatFile5Reader(stream</span><span class="s2">, </span><span class="s1">chars_as_strings=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">carr = np.atleast_2d(np.array(list(arr.item())</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">'U1'</span><span class="s1">))</span>
    <span class="s1">assert_array_equal(rdr.get_variables()[</span><span class="s3">'a'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">carr)</span>
    <span class="s1">rdr.chars_as_strings = </span><span class="s2">True</span>
    <span class="s1">assert_array_equal(rdr.get_variables()[</span><span class="s3">'a'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">arr)</span>


<span class="s2">def </span><span class="s1">test_empty_string():</span>
    <span class="s4"># make sure reading empty string does not raise error</span>
    <span class="s1">estring_fname = pjoin(test_data_path</span><span class="s2">, </span><span class="s3">'single_empty_string.mat'</span><span class="s1">)</span>
    <span class="s1">fp = open(estring_fname</span><span class="s2">, </span><span class="s3">'rb'</span><span class="s1">)</span>
    <span class="s1">rdr = MatFile5Reader(fp)</span>
    <span class="s1">d = rdr.get_variables()</span>
    <span class="s1">fp.close()</span>
    <span class="s1">assert_array_equal(d[</span><span class="s3">'a'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.array([]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">'U1'</span><span class="s1">))</span>
    <span class="s4"># Empty string round trip. Matlab cannot distinguish</span>
    <span class="s4"># between a string array that is empty, and a string array</span>
    <span class="s4"># containing a single empty string, because it stores strings as</span>
    <span class="s4"># arrays of char. There is no way of having an array of char that</span>
    <span class="s4"># is not empty, but contains an empty string.</span>
    <span class="s1">stream = BytesIO()</span>
    <span class="s1">savemat(stream</span><span class="s2">, </span><span class="s1">{</span><span class="s3">'a'</span><span class="s1">: np.array([</span><span class="s3">''</span><span class="s1">])})</span>
    <span class="s1">rdr = MatFile5Reader(stream)</span>
    <span class="s1">d = rdr.get_variables()</span>
    <span class="s1">assert_array_equal(d[</span><span class="s3">'a'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.array([]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">'U1'</span><span class="s1">))</span>
    <span class="s1">stream.truncate(</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">stream.seek(</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">savemat(stream</span><span class="s2">, </span><span class="s1">{</span><span class="s3">'a'</span><span class="s1">: np.array([]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">'U1'</span><span class="s1">)})</span>
    <span class="s1">rdr = MatFile5Reader(stream)</span>
    <span class="s1">d = rdr.get_variables()</span>
    <span class="s1">assert_array_equal(d[</span><span class="s3">'a'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.array([]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">'U1'</span><span class="s1">))</span>
    <span class="s1">stream.close()</span>


<span class="s2">def </span><span class="s1">test_corrupted_data():</span>
    <span class="s2">import </span><span class="s1">zlib</span>
    <span class="s2">for </span><span class="s1">exc</span><span class="s2">, </span><span class="s1">fname </span><span class="s2">in </span><span class="s1">[(ValueError</span><span class="s2">, </span><span class="s3">'corrupted_zlib_data.mat'</span><span class="s1">)</span><span class="s2">,</span>
                       <span class="s1">(zlib.error</span><span class="s2">, </span><span class="s3">'corrupted_zlib_checksum.mat'</span><span class="s1">)]:</span>
        <span class="s2">with </span><span class="s1">open(pjoin(test_data_path</span><span class="s2">, </span><span class="s1">fname)</span><span class="s2">, </span><span class="s3">'rb'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">fp:</span>
            <span class="s1">rdr = MatFile5Reader(fp)</span>
            <span class="s1">assert_raises(exc</span><span class="s2">, </span><span class="s1">rdr.get_variables)</span>


<span class="s2">def </span><span class="s1">test_corrupted_data_check_can_be_disabled():</span>
    <span class="s2">with </span><span class="s1">open(pjoin(test_data_path</span><span class="s2">, </span><span class="s3">'corrupted_zlib_data.mat'</span><span class="s1">)</span><span class="s2">, </span><span class="s3">'rb'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">fp:</span>
        <span class="s1">rdr = MatFile5Reader(fp</span><span class="s2">, </span><span class="s1">verify_compressed_data_integrity=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">rdr.get_variables()</span>


<span class="s2">def </span><span class="s1">test_read_both_endian():</span>
    <span class="s4"># make sure big- and little- endian data is read correctly</span>
    <span class="s2">for </span><span class="s1">fname </span><span class="s2">in </span><span class="s1">(</span><span class="s3">'big_endian.mat'</span><span class="s2">, </span><span class="s3">'little_endian.mat'</span><span class="s1">):</span>
        <span class="s1">fp = open(pjoin(test_data_path</span><span class="s2">, </span><span class="s1">fname)</span><span class="s2">, </span><span class="s3">'rb'</span><span class="s1">)</span>
        <span class="s1">rdr = MatFile5Reader(fp)</span>
        <span class="s1">d = rdr.get_variables()</span>
        <span class="s1">fp.close()</span>
        <span class="s1">assert_array_equal(d[</span><span class="s3">'strings'</span><span class="s1">]</span><span class="s2">,</span>
                           <span class="s1">np.array([[</span><span class="s3">'hello'</span><span class="s1">]</span><span class="s2">,</span>
                                     <span class="s1">[</span><span class="s3">'world'</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=object))</span>
        <span class="s1">assert_array_equal(d[</span><span class="s3">'floats'</span><span class="s1">]</span><span class="s2">,</span>
                           <span class="s1">np.array([[</span><span class="s5">2.</span><span class="s2">, </span><span class="s5">3.</span><span class="s1">]</span><span class="s2">,</span>
                                     <span class="s1">[</span><span class="s5">3.</span><span class="s2">, </span><span class="s5">4.</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=np.float32))</span>


<span class="s2">def </span><span class="s1">test_write_opposite_endian():</span>
    <span class="s4"># We don't support writing opposite endian .mat files, but we need to behave</span>
    <span class="s4"># correctly if the user supplies an other-endian NumPy array to write out.</span>
    <span class="s1">float_arr = np.array([[</span><span class="s5">2.</span><span class="s2">, </span><span class="s5">3.</span><span class="s1">]</span><span class="s2">,</span>
                          <span class="s1">[</span><span class="s5">3.</span><span class="s2">, </span><span class="s5">4.</span><span class="s1">]])</span>
    <span class="s1">int_arr = np.arange(</span><span class="s5">6</span><span class="s1">).reshape((</span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s1">))</span>
    <span class="s1">uni_arr = np.array([</span><span class="s3">'hello'</span><span class="s2">, </span><span class="s3">'world'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s3">'U'</span><span class="s1">)</span>
    <span class="s1">stream = BytesIO()</span>
    <span class="s1">savemat(stream</span><span class="s2">, </span><span class="s1">{</span><span class="s3">'floats'</span><span class="s1">: float_arr.byteswap().newbyteorder()</span><span class="s2">,</span>
                            <span class="s3">'ints'</span><span class="s1">: int_arr.byteswap().newbyteorder()</span><span class="s2">,</span>
                            <span class="s3">'uni_arr'</span><span class="s1">: uni_arr.byteswap().newbyteorder()})</span>
    <span class="s1">rdr = MatFile5Reader(stream)</span>
    <span class="s1">d = rdr.get_variables()</span>
    <span class="s1">assert_array_equal(d[</span><span class="s3">'floats'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">float_arr)</span>
    <span class="s1">assert_array_equal(d[</span><span class="s3">'ints'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">int_arr)</span>
    <span class="s1">assert_array_equal(d[</span><span class="s3">'uni_arr'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">uni_arr)</span>
    <span class="s1">stream.close()</span>


<span class="s2">def </span><span class="s1">test_logical_array():</span>
    <span class="s4"># The roundtrip test doesn't verify that we load the data up with the</span>
    <span class="s4"># correct (bool) dtype</span>
    <span class="s2">with </span><span class="s1">open(pjoin(test_data_path</span><span class="s2">, </span><span class="s3">'testbool_8_WIN64.mat'</span><span class="s1">)</span><span class="s2">, </span><span class="s3">'rb'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">fobj:</span>
        <span class="s1">rdr = MatFile5Reader(fobj</span><span class="s2">, </span><span class="s1">mat_dtype=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">d = rdr.get_variables()</span>
    <span class="s1">x = np.array([[</span><span class="s2">True</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s2">False</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=np.bool_)</span>
    <span class="s1">assert_array_equal(d[</span><span class="s3">'testbools'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">x)</span>
    <span class="s1">assert_equal(d[</span><span class="s3">'testbools'</span><span class="s1">].dtype</span><span class="s2">, </span><span class="s1">x.dtype)</span>


<span class="s2">def </span><span class="s1">test_logical_out_type():</span>
    <span class="s4"># Confirm that bool type written as uint8, uint8 class</span>
    <span class="s4"># See gh-4022</span>
    <span class="s1">stream = BytesIO()</span>
    <span class="s1">barr = np.array([</span><span class="s2">False, True, False</span><span class="s1">])</span>
    <span class="s1">savemat(stream</span><span class="s2">, </span><span class="s1">{</span><span class="s3">'barray'</span><span class="s1">: barr})</span>
    <span class="s1">stream.seek(</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">reader = MatFile5Reader(stream)</span>
    <span class="s1">reader.initialize_read()</span>
    <span class="s1">reader.read_file_header()</span>
    <span class="s1">hdr</span><span class="s2">, </span><span class="s1">_ = reader.read_var_header()</span>
    <span class="s1">assert_equal(hdr.mclass</span><span class="s2">, </span><span class="s1">mio5p.mxUINT8_CLASS)</span>
    <span class="s1">assert_equal(hdr.is_logical</span><span class="s2">, True</span><span class="s1">)</span>
    <span class="s1">var = reader.read_var_array(hdr</span><span class="s2">, False</span><span class="s1">)</span>
    <span class="s1">assert_equal(var.dtype.type</span><span class="s2">, </span><span class="s1">np.uint8)</span>


<span class="s2">def </span><span class="s1">test_roundtrip_zero_dimensions():</span>
    <span class="s1">stream = BytesIO()</span>
    <span class="s1">savemat(stream</span><span class="s2">, </span><span class="s1">{</span><span class="s3">'d'</span><span class="s1">:np.empty((</span><span class="s5">10</span><span class="s2">, </span><span class="s5">0</span><span class="s1">))})</span>
    <span class="s1">d = loadmat(stream)</span>
    <span class="s2">assert </span><span class="s1">d[</span><span class="s3">'d'</span><span class="s1">].shape == (</span><span class="s5">10</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_mat4_3d():</span>
    <span class="s4"># test behavior when writing 3-D arrays to matlab 4 files</span>
    <span class="s1">stream = BytesIO()</span>
    <span class="s1">arr = np.arange(</span><span class="s5">24</span><span class="s1">).reshape((</span><span class="s5">2</span><span class="s2">,</span><span class="s5">3</span><span class="s2">,</span><span class="s5">4</span><span class="s1">))</span>
    <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">savemat</span><span class="s2">, </span><span class="s1">stream</span><span class="s2">, </span><span class="s1">{</span><span class="s3">'a'</span><span class="s1">: arr}</span><span class="s2">, True, </span><span class="s3">'4'</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_func_read():</span>
    <span class="s1">func_eg = pjoin(test_data_path</span><span class="s2">, </span><span class="s3">'testfunc_7.4_GLNX86.mat'</span><span class="s1">)</span>
    <span class="s1">fp = open(func_eg</span><span class="s2">, </span><span class="s3">'rb'</span><span class="s1">)</span>
    <span class="s1">rdr = MatFile5Reader(fp)</span>
    <span class="s1">d = rdr.get_variables()</span>
    <span class="s1">fp.close()</span>
    <span class="s2">assert </span><span class="s1">isinstance(d[</span><span class="s3">'testfunc'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">MatlabFunction)</span>
    <span class="s1">stream = BytesIO()</span>
    <span class="s1">wtr = MatFile5Writer(stream)</span>
    <span class="s1">assert_raises(MatWriteError</span><span class="s2">, </span><span class="s1">wtr.put_variables</span><span class="s2">, </span><span class="s1">d)</span>


<span class="s2">def </span><span class="s1">test_mat_dtype():</span>
    <span class="s1">double_eg = pjoin(test_data_path</span><span class="s2">, </span><span class="s3">'testmatrix_6.1_SOL2.mat'</span><span class="s1">)</span>
    <span class="s1">fp = open(double_eg</span><span class="s2">, </span><span class="s3">'rb'</span><span class="s1">)</span>
    <span class="s1">rdr = MatFile5Reader(fp</span><span class="s2">, </span><span class="s1">mat_dtype=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">d = rdr.get_variables()</span>
    <span class="s1">fp.close()</span>
    <span class="s1">assert_equal(d[</span><span class="s3">'testmatrix'</span><span class="s1">].dtype.kind</span><span class="s2">, </span><span class="s3">'u'</span><span class="s1">)</span>

    <span class="s1">fp = open(double_eg</span><span class="s2">, </span><span class="s3">'rb'</span><span class="s1">)</span>
    <span class="s1">rdr = MatFile5Reader(fp</span><span class="s2">, </span><span class="s1">mat_dtype=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">d = rdr.get_variables()</span>
    <span class="s1">fp.close()</span>
    <span class="s1">assert_equal(d[</span><span class="s3">'testmatrix'</span><span class="s1">].dtype.kind</span><span class="s2">, </span><span class="s3">'f'</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_sparse_in_struct():</span>
    <span class="s4"># reproduces bug found by DC where Cython code was insisting on</span>
    <span class="s4"># ndarray return type, but getting sparse matrix</span>
    <span class="s1">st = {</span><span class="s3">'sparsefield'</span><span class="s1">: SP.coo_matrix(np.eye(</span><span class="s5">4</span><span class="s1">))}</span>
    <span class="s1">stream = BytesIO()</span>
    <span class="s1">savemat(stream</span><span class="s2">, </span><span class="s1">{</span><span class="s3">'a'</span><span class="s1">:st})</span>
    <span class="s1">d = loadmat(stream</span><span class="s2">, </span><span class="s1">struct_as_record=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">assert_array_equal(d[</span><span class="s3">'a'</span><span class="s1">][</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">][</span><span class="s3">'sparsefield'</span><span class="s1">].toarray()</span><span class="s2">, </span><span class="s1">np.eye(</span><span class="s5">4</span><span class="s1">))</span>


<span class="s2">def </span><span class="s1">test_mat_struct_squeeze():</span>
    <span class="s1">stream = BytesIO()</span>
    <span class="s1">in_d = {</span><span class="s3">'st'</span><span class="s1">:{</span><span class="s3">'one'</span><span class="s1">:</span><span class="s5">1</span><span class="s2">, </span><span class="s3">'two'</span><span class="s1">:</span><span class="s5">2</span><span class="s1">}}</span>
    <span class="s1">savemat(stream</span><span class="s2">, </span><span class="s1">in_d)</span>
    <span class="s4"># no error without squeeze</span>
    <span class="s1">loadmat(stream</span><span class="s2">, </span><span class="s1">struct_as_record=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s4"># previous error was with squeeze, with mat_struct</span>
    <span class="s1">loadmat(stream</span><span class="s2">, </span><span class="s1">struct_as_record=</span><span class="s2">False, </span><span class="s1">squeeze_me=</span><span class="s2">True</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_scalar_squeeze():</span>
    <span class="s1">stream = BytesIO()</span>
    <span class="s1">in_d = {</span><span class="s3">'scalar'</span><span class="s1">: [[</span><span class="s5">0.1</span><span class="s1">]]</span><span class="s2">, </span><span class="s3">'string'</span><span class="s1">: </span><span class="s3">'my name'</span><span class="s2">, </span><span class="s3">'st'</span><span class="s1">:{</span><span class="s3">'one'</span><span class="s1">:</span><span class="s5">1</span><span class="s2">, </span><span class="s3">'two'</span><span class="s1">:</span><span class="s5">2</span><span class="s1">}}</span>
    <span class="s1">savemat(stream</span><span class="s2">, </span><span class="s1">in_d)</span>
    <span class="s1">out_d = loadmat(stream</span><span class="s2">, </span><span class="s1">squeeze_me=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">assert_(isinstance(out_d[</span><span class="s3">'scalar'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">float))</span>
    <span class="s1">assert_(isinstance(out_d[</span><span class="s3">'string'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">str))</span>
    <span class="s1">assert_(isinstance(out_d[</span><span class="s3">'st'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.ndarray))</span>


<span class="s2">def </span><span class="s1">test_str_round():</span>
    <span class="s4"># from report by Angus McMorland on mailing list 3 May 2010</span>
    <span class="s1">stream = BytesIO()</span>
    <span class="s1">in_arr = np.array([</span><span class="s3">'Hello'</span><span class="s2">, </span><span class="s3">'Foob'</span><span class="s1">])</span>
    <span class="s1">out_arr = np.array([</span><span class="s3">'Hello'</span><span class="s2">, </span><span class="s3">'Foob '</span><span class="s1">])</span>
    <span class="s1">savemat(stream</span><span class="s2">, </span><span class="s1">dict(a=in_arr))</span>
    <span class="s1">res = loadmat(stream)</span>
    <span class="s4"># resulted in ['HloolFoa', 'elWrdobr']</span>
    <span class="s1">assert_array_equal(res[</span><span class="s3">'a'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">out_arr)</span>
    <span class="s1">stream.truncate(</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">stream.seek(</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s4"># Make Fortran ordered version of string</span>
    <span class="s1">in_str = in_arr.tobytes(order=</span><span class="s3">'F'</span><span class="s1">)</span>
    <span class="s1">in_from_str = np.ndarray(shape=a.shape</span><span class="s2">,</span>
                             <span class="s1">dtype=in_arr.dtype</span><span class="s2">,</span>
                             <span class="s1">order=</span><span class="s3">'F'</span><span class="s2">,</span>
                             <span class="s1">buffer=in_str)</span>
    <span class="s1">savemat(stream</span><span class="s2">, </span><span class="s1">dict(a=in_from_str))</span>
    <span class="s1">assert_array_equal(res[</span><span class="s3">'a'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">out_arr)</span>
    <span class="s4"># unicode save did lead to buffer too small error</span>
    <span class="s1">stream.truncate(</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">stream.seek(</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">in_arr_u = in_arr.astype(</span><span class="s3">'U'</span><span class="s1">)</span>
    <span class="s1">out_arr_u = out_arr.astype(</span><span class="s3">'U'</span><span class="s1">)</span>
    <span class="s1">savemat(stream</span><span class="s2">, </span><span class="s1">{</span><span class="s3">'a'</span><span class="s1">: in_arr_u})</span>
    <span class="s1">res = loadmat(stream)</span>
    <span class="s1">assert_array_equal(res[</span><span class="s3">'a'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">out_arr_u)</span>


<span class="s2">def </span><span class="s1">test_fieldnames():</span>
    <span class="s4"># Check that field names are as expected</span>
    <span class="s1">stream = BytesIO()</span>
    <span class="s1">savemat(stream</span><span class="s2">, </span><span class="s1">{</span><span class="s3">'a'</span><span class="s1">: {</span><span class="s3">'a'</span><span class="s1">:</span><span class="s5">1</span><span class="s2">, </span><span class="s3">'b'</span><span class="s1">:</span><span class="s5">2</span><span class="s1">}})</span>
    <span class="s1">res = loadmat(stream)</span>
    <span class="s1">field_names = res[</span><span class="s3">'a'</span><span class="s1">].dtype.names</span>
    <span class="s1">assert_equal(set(field_names)</span><span class="s2">, </span><span class="s1">{</span><span class="s3">'a'</span><span class="s2">, </span><span class="s3">'b'</span><span class="s1">})</span>


<span class="s2">def </span><span class="s1">test_loadmat_varnames():</span>
    <span class="s4"># Test that we can get just one variable from a mat file using loadmat</span>
    <span class="s1">mat5_sys_names = [</span><span class="s3">'__globals__'</span><span class="s2">,</span>
                      <span class="s3">'__header__'</span><span class="s2">,</span>
                      <span class="s3">'__version__'</span><span class="s1">]</span>
    <span class="s2">for </span><span class="s1">eg_file</span><span class="s2">, </span><span class="s1">sys_v_names </span><span class="s2">in </span><span class="s1">(</span>
        <span class="s1">(pjoin(test_data_path</span><span class="s2">, </span><span class="s3">'testmulti_4.2c_SOL2.mat'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">[])</span><span class="s2">, </span><span class="s1">(pjoin(</span>
            <span class="s1">test_data_path</span><span class="s2">, </span><span class="s3">'testmulti_7.4_GLNX86.mat'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">mat5_sys_names)):</span>
        <span class="s1">vars = loadmat(eg_file)</span>
        <span class="s1">assert_equal(set(vars.keys())</span><span class="s2">, </span><span class="s1">set([</span><span class="s3">'a'</span><span class="s2">, </span><span class="s3">'theta'</span><span class="s1">] + sys_v_names))</span>
        <span class="s1">vars = loadmat(eg_file</span><span class="s2">, </span><span class="s1">variable_names=</span><span class="s3">'a'</span><span class="s1">)</span>
        <span class="s1">assert_equal(set(vars.keys())</span><span class="s2">, </span><span class="s1">set([</span><span class="s3">'a'</span><span class="s1">] + sys_v_names))</span>
        <span class="s1">vars = loadmat(eg_file</span><span class="s2">, </span><span class="s1">variable_names=[</span><span class="s3">'a'</span><span class="s1">])</span>
        <span class="s1">assert_equal(set(vars.keys())</span><span class="s2">, </span><span class="s1">set([</span><span class="s3">'a'</span><span class="s1">] + sys_v_names))</span>
        <span class="s1">vars = loadmat(eg_file</span><span class="s2">, </span><span class="s1">variable_names=[</span><span class="s3">'theta'</span><span class="s1">])</span>
        <span class="s1">assert_equal(set(vars.keys())</span><span class="s2">, </span><span class="s1">set([</span><span class="s3">'theta'</span><span class="s1">] + sys_v_names))</span>
        <span class="s1">vars = loadmat(eg_file</span><span class="s2">, </span><span class="s1">variable_names=(</span><span class="s3">'theta'</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s1">assert_equal(set(vars.keys())</span><span class="s2">, </span><span class="s1">set([</span><span class="s3">'theta'</span><span class="s1">] + sys_v_names))</span>
        <span class="s1">vars = loadmat(eg_file</span><span class="s2">, </span><span class="s1">variable_names=[])</span>
        <span class="s1">assert_equal(set(vars.keys())</span><span class="s2">, </span><span class="s1">set(sys_v_names))</span>
        <span class="s1">vnames = [</span><span class="s3">'theta'</span><span class="s1">]</span>
        <span class="s1">vars = loadmat(eg_file</span><span class="s2">, </span><span class="s1">variable_names=vnames)</span>
        <span class="s1">assert_equal(vnames</span><span class="s2">, </span><span class="s1">[</span><span class="s3">'theta'</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">test_round_types():</span>
    <span class="s4"># Check that saving, loading preserves dtype in most cases</span>
    <span class="s1">arr = np.arange(</span><span class="s5">10</span><span class="s1">)</span>
    <span class="s1">stream = BytesIO()</span>
    <span class="s2">for </span><span class="s1">dts </span><span class="s2">in </span><span class="s1">(</span><span class="s3">'f8'</span><span class="s2">,</span><span class="s3">'f4'</span><span class="s2">,</span><span class="s3">'i8'</span><span class="s2">,</span><span class="s3">'i4'</span><span class="s2">,</span><span class="s3">'i2'</span><span class="s2">,</span><span class="s3">'i1'</span><span class="s2">,</span>
                <span class="s3">'u8'</span><span class="s2">,</span><span class="s3">'u4'</span><span class="s2">,</span><span class="s3">'u2'</span><span class="s2">,</span><span class="s3">'u1'</span><span class="s2">,</span><span class="s3">'c16'</span><span class="s2">,</span><span class="s3">'c8'</span><span class="s1">):</span>
        <span class="s1">stream.truncate(</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">stream.seek(</span><span class="s5">0</span><span class="s1">)  </span><span class="s4"># needed for BytesIO in Python 3</span>
        <span class="s1">savemat(stream</span><span class="s2">, </span><span class="s1">{</span><span class="s3">'arr'</span><span class="s1">: arr.astype(dts)})</span>
        <span class="s1">vars = loadmat(stream)</span>
        <span class="s1">assert_equal(np.dtype(dts)</span><span class="s2">, </span><span class="s1">vars[</span><span class="s3">'arr'</span><span class="s1">].dtype)</span>


<span class="s2">def </span><span class="s1">test_varmats_from_mat():</span>
    <span class="s4"># Make a mat file with several variables, write it, read it back</span>
    <span class="s1">names_vars = ((</span><span class="s3">'arr'</span><span class="s2">, </span><span class="s1">mlarr(np.arange(</span><span class="s5">10</span><span class="s1">)))</span><span class="s2">,</span>
                  <span class="s1">(</span><span class="s3">'mystr'</span><span class="s2">, </span><span class="s1">mlarr(</span><span class="s3">'a string'</span><span class="s1">))</span><span class="s2">,</span>
                  <span class="s1">(</span><span class="s3">'mynum'</span><span class="s2">, </span><span class="s1">mlarr(</span><span class="s5">10</span><span class="s1">)))</span>

    <span class="s4"># Dict like thing to give variables in defined order</span>
    <span class="s2">class </span><span class="s1">C:</span>
        <span class="s2">def </span><span class="s1">items(self):</span>
            <span class="s2">return </span><span class="s1">names_vars</span>
    <span class="s1">stream = BytesIO()</span>
    <span class="s1">savemat(stream</span><span class="s2">, </span><span class="s1">C())</span>
    <span class="s1">varmats = varmats_from_mat(stream)</span>
    <span class="s1">assert_equal(len(varmats)</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">3</span><span class="s1">):</span>
        <span class="s1">name</span><span class="s2">, </span><span class="s1">var_stream = varmats[i]</span>
        <span class="s1">exp_name</span><span class="s2">, </span><span class="s1">exp_res = names_vars[i]</span>
        <span class="s1">assert_equal(name</span><span class="s2">, </span><span class="s1">exp_name)</span>
        <span class="s1">res = loadmat(var_stream)</span>
        <span class="s1">assert_array_equal(res[name]</span><span class="s2">, </span><span class="s1">exp_res)</span>


<span class="s2">def </span><span class="s1">test_one_by_zero():</span>
    <span class="s4"># Test 1x0 chars get read correctly</span>
    <span class="s1">func_eg = pjoin(test_data_path</span><span class="s2">, </span><span class="s3">'one_by_zero_char.mat'</span><span class="s1">)</span>
    <span class="s1">fp = open(func_eg</span><span class="s2">, </span><span class="s3">'rb'</span><span class="s1">)</span>
    <span class="s1">rdr = MatFile5Reader(fp)</span>
    <span class="s1">d = rdr.get_variables()</span>
    <span class="s1">fp.close()</span>
    <span class="s1">assert_equal(d[</span><span class="s3">'var'</span><span class="s1">].shape</span><span class="s2">, </span><span class="s1">(</span><span class="s5">0</span><span class="s2">,</span><span class="s1">))</span>


<span class="s2">def </span><span class="s1">test_load_mat4_le():</span>
    <span class="s4"># We were getting byte order wrong when reading little-endian floa64 dense</span>
    <span class="s4"># matrices on big-endian platforms</span>
    <span class="s1">mat4_fname = pjoin(test_data_path</span><span class="s2">, </span><span class="s3">'test_mat4_le_floats.mat'</span><span class="s1">)</span>
    <span class="s1">vars = loadmat(mat4_fname)</span>
    <span class="s1">assert_array_equal(vars[</span><span class="s3">'a'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[[</span><span class="s5">0.1</span><span class="s2">, </span><span class="s5">1.2</span><span class="s1">]])</span>


<span class="s2">def </span><span class="s1">test_unicode_mat4():</span>
    <span class="s4"># Mat4 should save unicode as latin1</span>
    <span class="s1">bio = BytesIO()</span>
    <span class="s1">var = {</span><span class="s3">'second_cat'</span><span class="s1">: </span><span class="s3">'Schrödinger'</span><span class="s1">}</span>
    <span class="s1">savemat(bio</span><span class="s2">, </span><span class="s1">var</span><span class="s2">, </span><span class="s1">format=</span><span class="s3">'4'</span><span class="s1">)</span>
    <span class="s1">var_back = loadmat(bio)</span>
    <span class="s1">assert_equal(var_back[</span><span class="s3">'second_cat'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">var[</span><span class="s3">'second_cat'</span><span class="s1">])</span>


<span class="s2">def </span><span class="s1">test_logical_sparse():</span>
    <span class="s4"># Test we can read logical sparse stored in mat file as bytes.</span>
    <span class="s4"># See https://github.com/scipy/scipy/issues/3539.</span>
    <span class="s4"># In some files saved by MATLAB, the sparse data elements (Real Part</span>
    <span class="s4"># Subelement in MATLAB speak) are stored with apparent type double</span>
    <span class="s4"># (miDOUBLE) but are in fact single bytes.</span>
    <span class="s1">filename = pjoin(test_data_path</span><span class="s2">,</span><span class="s3">'logical_sparse.mat'</span><span class="s1">)</span>
    <span class="s4"># Before fix, this would crash with:</span>
    <span class="s4"># ValueError: indices and data should have the same size</span>
    <span class="s1">d = loadmat(filename</span><span class="s2">, </span><span class="s1">struct_as_record=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">log_sp = d[</span><span class="s3">'sp_log_5_4'</span><span class="s1">]</span>
    <span class="s1">assert_(isinstance(log_sp</span><span class="s2">, </span><span class="s1">SP.csc_matrix))</span>
    <span class="s1">assert_equal(log_sp.dtype.type</span><span class="s2">, </span><span class="s1">np.bool_)</span>
    <span class="s1">assert_array_equal(log_sp.toarray()</span><span class="s2">,</span>
                       <span class="s1">[[</span><span class="s2">True, True, True, False</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">[</span><span class="s2">False, False, True, False</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">[</span><span class="s2">False, False, True, False</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">[</span><span class="s2">False, False, False, False</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">[</span><span class="s2">False, False, False, False</span><span class="s1">]])</span>


<span class="s2">def </span><span class="s1">test_empty_sparse():</span>
    <span class="s4"># Can we read empty sparse matrices?</span>
    <span class="s1">sio = BytesIO()</span>
    <span class="s2">import </span><span class="s1">scipy.sparse</span>
    <span class="s1">empty_sparse = scipy.sparse.csr_matrix([[</span><span class="s5">0</span><span class="s2">,</span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span><span class="s1">[</span><span class="s5">0</span><span class="s2">,</span><span class="s5">0</span><span class="s1">]])</span>
    <span class="s1">savemat(sio</span><span class="s2">, </span><span class="s1">dict(x=empty_sparse))</span>
    <span class="s1">sio.seek(</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">res = loadmat(sio)</span>
    <span class="s1">assert_array_equal(res[</span><span class="s3">'x'</span><span class="s1">].shape</span><span class="s2">, </span><span class="s1">empty_sparse.shape)</span>
    <span class="s1">assert_array_equal(res[</span><span class="s3">'x'</span><span class="s1">].toarray()</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s4"># Do empty sparse matrices get written with max nnz 1?</span>
    <span class="s4"># See https://github.com/scipy/scipy/issues/4208</span>
    <span class="s1">sio.seek(</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">reader = MatFile5Reader(sio)</span>
    <span class="s1">reader.initialize_read()</span>
    <span class="s1">reader.read_file_header()</span>
    <span class="s1">hdr</span><span class="s2">, </span><span class="s1">_ = reader.read_var_header()</span>
    <span class="s1">assert_equal(hdr.nzmax</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_empty_mat_error():</span>
    <span class="s4"># Test we get a specific warning for an empty mat file</span>
    <span class="s1">sio = BytesIO()</span>
    <span class="s1">assert_raises(MatReadError</span><span class="s2">, </span><span class="s1">loadmat</span><span class="s2">, </span><span class="s1">sio)</span>


<span class="s2">def </span><span class="s1">test_miuint32_compromise():</span>
    <span class="s4"># Reader should accept miUINT32 for miINT32, but check signs</span>
    <span class="s4"># mat file with miUINT32 for miINT32, but OK values</span>
    <span class="s1">filename = pjoin(test_data_path</span><span class="s2">, </span><span class="s3">'miuint32_for_miint32.mat'</span><span class="s1">)</span>
    <span class="s1">res = loadmat(filename)</span>
    <span class="s1">assert_equal(res[</span><span class="s3">'an_array'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.arange(</span><span class="s5">10</span><span class="s1">)[</span><span class="s2">None, </span><span class="s1">:])</span>
    <span class="s4"># mat file with miUINT32 for miINT32, with negative value</span>
    <span class="s1">filename = pjoin(test_data_path</span><span class="s2">, </span><span class="s3">'bad_miuint32.mat'</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">assert_raises(ValueError):</span>
        <span class="s1">loadmat(filename)</span>


<span class="s2">def </span><span class="s1">test_miutf8_for_miint8_compromise():</span>
    <span class="s4"># Check reader accepts ascii as miUTF8 for array names</span>
    <span class="s1">filename = pjoin(test_data_path</span><span class="s2">, </span><span class="s3">'miutf8_array_name.mat'</span><span class="s1">)</span>
    <span class="s1">res = loadmat(filename)</span>
    <span class="s1">assert_equal(res[</span><span class="s3">'array_name'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[[</span><span class="s5">1</span><span class="s1">]])</span>
    <span class="s4"># mat file with non-ascii utf8 name raises error</span>
    <span class="s1">filename = pjoin(test_data_path</span><span class="s2">, </span><span class="s3">'bad_miutf8_array_name.mat'</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">assert_raises(ValueError):</span>
        <span class="s1">loadmat(filename)</span>


<span class="s2">def </span><span class="s1">test_bad_utf8():</span>
    <span class="s4"># Check that reader reads bad UTF with 'replace' option</span>
    <span class="s1">filename = pjoin(test_data_path</span><span class="s2">,</span><span class="s3">'broken_utf8.mat'</span><span class="s1">)</span>
    <span class="s1">res = loadmat(filename)</span>
    <span class="s1">assert_equal(res[</span><span class="s3">'bad_string'</span><span class="s1">]</span><span class="s2">,</span>
                 <span class="s6">b'</span><span class="s2">\x80 </span><span class="s6">am broken'</span><span class="s1">.decode(</span><span class="s3">'utf8'</span><span class="s2">, </span><span class="s3">'replace'</span><span class="s1">))</span>


<span class="s2">def </span><span class="s1">test_save_unicode_field(tmpdir):</span>
    <span class="s1">filename = os.path.join(str(tmpdir)</span><span class="s2">, </span><span class="s3">'test.mat'</span><span class="s1">)</span>
    <span class="s1">test_dict = {</span><span class="s3">'a'</span><span class="s1">:{</span><span class="s3">'b'</span><span class="s1">:</span><span class="s5">1</span><span class="s2">,</span><span class="s3">'c'</span><span class="s1">:</span><span class="s3">'test_str'</span><span class="s1">}}</span>
    <span class="s1">savemat(filename</span><span class="s2">, </span><span class="s1">test_dict)</span>


<span class="s2">def </span><span class="s1">test_save_custom_array_type(tmpdir):</span>
    <span class="s2">class </span><span class="s1">CustomArray:</span>
        <span class="s2">def </span><span class="s1">__array__(self):</span>
            <span class="s2">return </span><span class="s1">np.arange(</span><span class="s5">6.0</span><span class="s1">).reshape(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span>
    <span class="s1">a = CustomArray()</span>
    <span class="s1">filename = os.path.join(str(tmpdir)</span><span class="s2">, </span><span class="s3">'test.mat'</span><span class="s1">)</span>
    <span class="s1">savemat(filename</span><span class="s2">, </span><span class="s1">{</span><span class="s3">'a'</span><span class="s1">: a})</span>
    <span class="s1">out = loadmat(filename)</span>
    <span class="s1">assert_array_equal(out[</span><span class="s3">'a'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.array(a))</span>


<span class="s2">def </span><span class="s1">test_filenotfound():</span>
    <span class="s4"># Check the correct error is thrown</span>
    <span class="s1">assert_raises(OSError</span><span class="s2">, </span><span class="s1">loadmat</span><span class="s2">, </span><span class="s3">&quot;NotExistentFile00.mat&quot;</span><span class="s1">)</span>
    <span class="s1">assert_raises(OSError</span><span class="s2">, </span><span class="s1">loadmat</span><span class="s2">, </span><span class="s3">&quot;NotExistentFile00&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_simplify_cells():</span>
    <span class="s4"># Test output when simplify_cells=True</span>
    <span class="s1">filename = pjoin(test_data_path</span><span class="s2">, </span><span class="s3">'testsimplecell.mat'</span><span class="s1">)</span>
    <span class="s1">res1 = loadmat(filename</span><span class="s2">, </span><span class="s1">simplify_cells=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">res2 = loadmat(filename</span><span class="s2">, </span><span class="s1">simplify_cells=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">assert_(isinstance(res1[</span><span class="s3">&quot;s&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dict))</span>
    <span class="s1">assert_(isinstance(res2[</span><span class="s3">&quot;s&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.ndarray))</span>
    <span class="s1">assert_array_equal(res1[</span><span class="s3">&quot;s&quot;</span><span class="s1">][</span><span class="s3">&quot;mycell&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.array([</span><span class="s3">&quot;a&quot;</span><span class="s2">, </span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s3">&quot;c&quot;</span><span class="s1">]))</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'version, filt, regex'</span><span class="s2">, </span><span class="s1">[</span>
    <span class="s1">(</span><span class="s5">0</span><span class="s2">, </span><span class="s3">'_4*_*'</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">(</span><span class="s5">1</span><span class="s2">, </span><span class="s3">'_5*_*'</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">(</span><span class="s5">1</span><span class="s2">, </span><span class="s3">'_6*_*'</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">(</span><span class="s5">1</span><span class="s2">, </span><span class="s3">'_7*_*'</span><span class="s2">, </span><span class="s3">'^((?!hdf5).)*$'</span><span class="s1">)</span><span class="s2">,  </span><span class="s4"># not containing hdf5</span>
    <span class="s1">(</span><span class="s5">2</span><span class="s2">, </span><span class="s3">'_7*_*'</span><span class="s2">, </span><span class="s3">'.*hdf5.*'</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">(</span><span class="s5">1</span><span class="s2">, </span><span class="s3">'8*_*'</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">,</span>
<span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_matfile_version(version</span><span class="s2">, </span><span class="s1">filt</span><span class="s2">, </span><span class="s1">regex):</span>
    <span class="s1">use_filt = pjoin(test_data_path</span><span class="s2">, </span><span class="s3">'test*%s.mat' </span><span class="s1">% filt)</span>
    <span class="s1">files = glob(use_filt)</span>
    <span class="s2">if </span><span class="s1">regex </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">files = [file </span><span class="s2">for </span><span class="s1">file </span><span class="s2">in </span><span class="s1">files </span><span class="s2">if </span><span class="s1">re.match(regex</span><span class="s2">, </span><span class="s1">file) </span><span class="s2">is not None</span><span class="s1">]</span>
    <span class="s2">assert </span><span class="s1">len(files) &gt; </span><span class="s5">0</span><span class="s2">, </span><span class="s1">\</span>
        <span class="s3">f&quot;No files for version </span><span class="s2">{</span><span class="s1">version</span><span class="s2">} </span><span class="s3">using filter </span><span class="s2">{</span><span class="s1">filt</span><span class="s2">}</span><span class="s3">&quot;</span>
    <span class="s2">for </span><span class="s1">file </span><span class="s2">in </span><span class="s1">files:</span>
        <span class="s1">got_version = matfile_version(file)</span>
        <span class="s2">assert </span><span class="s1">got_version[</span><span class="s5">0</span><span class="s1">] == version</span>


<span class="s2">def </span><span class="s1">test_opaque():</span>
    <span class="s0">&quot;&quot;&quot;Test that we can read a MatlabOpaque object.&quot;&quot;&quot;</span>
    <span class="s1">data = loadmat(pjoin(test_data_path</span><span class="s2">, </span><span class="s3">'parabola.mat'</span><span class="s1">))</span>
    <span class="s2">assert </span><span class="s1">isinstance(data[</span><span class="s3">'parabola'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">MatlabFunction)</span>
    <span class="s2">assert </span><span class="s1">isinstance(data[</span><span class="s3">'parabola'</span><span class="s1">].item()[</span><span class="s5">3</span><span class="s1">].item()[</span><span class="s5">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">MatlabOpaque)</span>


<span class="s2">def </span><span class="s1">test_opaque_simplify():</span>
    <span class="s0">&quot;&quot;&quot;Test that we can read a MatlabOpaque object when simplify_cells=True.&quot;&quot;&quot;</span>
    <span class="s1">data = loadmat(pjoin(test_data_path</span><span class="s2">, </span><span class="s3">'parabola.mat'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">simplify_cells=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">isinstance(data[</span><span class="s3">'parabola'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">MatlabFunction)</span>


<span class="s2">def </span><span class="s1">test_deprecation():</span>
    <span class="s0">&quot;&quot;&quot;Test that access to previous attributes still works.&quot;&quot;&quot;</span>
    <span class="s4"># This should be accessible immediately from scipy.io import</span>
    <span class="s2">with </span><span class="s1">assert_warns(DeprecationWarning):</span>
        <span class="s1">scipy.io.matlab.mio5_params.MatlabOpaque  </span><span class="s4"># noqa</span>

    <span class="s4"># These should be importable but warn as well</span>
    <span class="s2">with </span><span class="s1">assert_warns(DeprecationWarning):</span>
        <span class="s2">from </span><span class="s1">scipy.io.matlab.miobase </span><span class="s2">import </span><span class="s1">MatReadError  </span><span class="s4"># noqa</span>


<span class="s2">def </span><span class="s1">test_gh_17992(tmp_path):</span>
    <span class="s1">rng = np.random.default_rng(</span><span class="s5">12345</span><span class="s1">)</span>
    <span class="s1">outfile = tmp_path / </span><span class="s3">&quot;lists.mat&quot;</span>
    <span class="s1">array_one = rng.random((</span><span class="s5">5</span><span class="s2">,</span><span class="s5">3</span><span class="s1">))</span>
    <span class="s1">array_two = rng.random((</span><span class="s5">6</span><span class="s2">,</span><span class="s5">3</span><span class="s1">))</span>
    <span class="s1">list_of_arrays = [array_one</span><span class="s2">, </span><span class="s1">array_two]</span>
    <span class="s4"># warning suppression only needed for NumPy &lt; 1.24.0</span>
    <span class="s2">with </span><span class="s1">np.testing.suppress_warnings() </span><span class="s2">as </span><span class="s1">sup:</span>
        <span class="s1">sup.filter(np.VisibleDeprecationWarning)</span>
        <span class="s1">savemat(outfile</span><span class="s2">,</span>
                <span class="s1">{</span><span class="s3">'data'</span><span class="s1">: list_of_arrays}</span><span class="s2">,</span>
                <span class="s1">long_field_names=</span><span class="s2">True,</span>
                <span class="s1">do_compression=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s4"># round trip check</span>
    <span class="s1">new_dict = {}</span>
    <span class="s1">loadmat(outfile</span><span class="s2">,</span>
            <span class="s1">new_dict)</span>
    <span class="s1">assert_allclose(new_dict[</span><span class="s3">&quot;data&quot;</span><span class="s1">][</span><span class="s5">0</span><span class="s1">][</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">array_one)</span>
    <span class="s1">assert_allclose(new_dict[</span><span class="s3">&quot;data&quot;</span><span class="s1">][</span><span class="s5">0</span><span class="s1">][</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">array_two)</span>
</pre>
</body>
</html>