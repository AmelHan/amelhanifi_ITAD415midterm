<html>
<head>
<title>test_varmax.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_varmax.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Tests for VARMAX models 
 
Author: Chad Fulton 
License: Simplified-BSD 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">numpy.testing </span><span class="s2">import </span><span class="s1">assert_equal</span><span class="s2">, </span><span class="s1">assert_allclose</span><span class="s2">, </span><span class="s1">assert_raises</span>
<span class="s2">import </span><span class="s1">pandas </span><span class="s2">as </span><span class="s1">pd</span>
<span class="s2">import </span><span class="s1">pytest</span>

<span class="s2">from </span><span class="s1">statsmodels.tsa.statespace </span><span class="s2">import </span><span class="s1">varmax</span><span class="s2">, </span><span class="s1">sarimax</span>
<span class="s2">from </span><span class="s1">statsmodels.iolib.summary </span><span class="s2">import </span><span class="s1">forg</span>

<span class="s2">from </span><span class="s1">.results </span><span class="s2">import </span><span class="s1">results_varmax</span>

<span class="s1">current_path = os.path.dirname(os.path.abspath(__file__))</span>

<span class="s1">var_path = os.path.join(</span><span class="s3">'results'</span><span class="s2">, </span><span class="s3">'results_var_stata.csv'</span><span class="s1">)</span>
<span class="s1">var_results = pd.read_csv(os.path.join(current_path</span><span class="s2">, </span><span class="s1">var_path))</span>

<span class="s1">varmax_path = os.path.join(</span><span class="s3">'results'</span><span class="s2">, </span><span class="s3">'results_varmax_stata.csv'</span><span class="s1">)</span>
<span class="s1">varmax_results = pd.read_csv(os.path.join(current_path</span><span class="s2">, </span><span class="s1">varmax_path))</span>


<span class="s2">class </span><span class="s1">CheckVARMAX:</span>
    <span class="s0">&quot;&quot;&quot; 
    Test Vector Autoregression against Stata's `dfactor` code (Stata's 
    `var` function uses OLS and not state space / MLE, so we cannot get 
    equivalent log-likelihoods) 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">test_mle(self):</span>
        <span class="s2">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s2">True</span><span class="s1">):</span>
            <span class="s1">warnings.simplefilter(</span><span class="s3">'always'</span><span class="s1">)</span>
            <span class="s4"># Fit with all transformations</span>
            <span class="s4"># results = self.model.fit(method='powell', disp=-1)</span>
            <span class="s1">results = self.model.fit(maxiter=</span><span class="s5">100</span><span class="s2">, </span><span class="s1">disp=</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s4"># Fit now without transformations</span>
            <span class="s1">self.model.enforce_stationarity = </span><span class="s2">False</span>
            <span class="s1">self.model.enforce_invertibility = </span><span class="s2">False</span>
            <span class="s1">results = self.model.fit(results.params</span><span class="s2">, </span><span class="s1">method=</span><span class="s3">'nm'</span><span class="s2">, </span><span class="s1">maxiter=</span><span class="s5">1000</span><span class="s2">,</span>
                                     <span class="s1">disp=</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s1">self.model.enforce_stationarity = </span><span class="s2">True</span>
            <span class="s1">self.model.enforce_invertibility = </span><span class="s2">True</span>
            <span class="s1">assert_allclose(results.llf</span><span class="s2">, </span><span class="s1">self.results.llf</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-5</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.smoke</span>
    <span class="s2">def </span><span class="s1">test_params(self):</span>
        <span class="s4"># Smoke test to make sure the start_params are well-defined and</span>
        <span class="s4"># lead to a well-defined model</span>
        <span class="s1">model = self.model</span>

        <span class="s1">model.filter(model.start_params)</span>
        <span class="s4"># Similarly a smoke test for param_names</span>
        <span class="s2">assert </span><span class="s1">len(model.start_params) == len(model.param_names)</span>

        <span class="s4"># Finally make sure the transform and untransform do their job</span>
        <span class="s1">actual = model.transform_params(</span>
            <span class="s1">model.untransform_params(model.start_params))</span>
        <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">model.start_params)</span>

        <span class="s4"># Also in the case of enforce invertibility and stationarity = False</span>
        <span class="s1">model.enforce_stationarity = </span><span class="s2">False</span>
        <span class="s1">model.enforce_invertibility = </span><span class="s2">False</span>
        <span class="s1">actual = model.transform_params(</span>
            <span class="s1">model.untransform_params(model.start_params))</span>

        <span class="s1">model.enforce_stationarity = </span><span class="s2">True</span>
        <span class="s1">model.enforce_invertibility = </span><span class="s2">True</span>
        <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">model.start_params)</span>

    <span class="s1">@pytest.mark.smoke</span>
    <span class="s2">def </span><span class="s1">test_results(self):</span>
        <span class="s4"># Smoke test for creating the summary</span>
        <span class="s1">self.results.summary()</span>

        <span class="s1">model = self.model</span>
        <span class="s4"># Test cofficient matrix creation</span>
        <span class="s4">#   (via a different, more direct, method)</span>
        <span class="s2">if </span><span class="s1">model.k_ar &gt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">params_ar = np.array(self.results.params[model._params_ar])</span>
            <span class="s1">coefficients = params_ar.reshape(model.k_endog</span><span class="s2">,</span>
                                             <span class="s1">model.k_endog * model.k_ar)</span>
            <span class="s1">coefficient_matrices = np.array([</span>
                <span class="s1">coefficients[:model.k_endog</span><span class="s2">,</span>
                             <span class="s1">i*model.k_endog:(i+</span><span class="s5">1</span><span class="s1">)*model.k_endog]</span>
                <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(model.k_ar)</span>
            <span class="s1">])</span>
            <span class="s1">assert_equal(self.results.coefficient_matrices_var</span><span class="s2">,</span>
                         <span class="s1">coefficient_matrices)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">assert_equal(self.results.coefficient_matrices_var</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">model.k_ma &gt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">params_ma = np.array(self.results.params[model._params_ma])</span>
            <span class="s1">coefficients = params_ma.reshape(model.k_endog</span><span class="s2">,</span>
                                             <span class="s1">model.k_endog * model.k_ma)</span>

            <span class="s1">coefficient_matrices = np.array([</span>
                <span class="s1">coefficients[:model.k_endog</span><span class="s2">,</span>
                             <span class="s1">i*model.k_endog:(i+</span><span class="s5">1</span><span class="s1">)*model.k_endog]</span>
                <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(model.k_ma)</span>
            <span class="s1">])</span>
            <span class="s1">assert_equal(self.results.coefficient_matrices_vma</span><span class="s2">,</span>
                         <span class="s1">coefficient_matrices)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">assert_equal(self.results.coefficient_matrices_vma</span><span class="s2">, None</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_loglike(self):</span>
        <span class="s1">assert_allclose(self.results.llf</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'loglike'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-6</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_aic(self):</span>
        <span class="s4"># We only get 3 digits from Stata</span>
        <span class="s1">assert_allclose(self.results.aic</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'aic'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">3</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bic(self):</span>
        <span class="s4"># We only get 3 digits from Stata</span>
        <span class="s1">assert_allclose(self.results.bic</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'bic'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">3</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_predict(self</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-6</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s4"># Tests predict + forecast</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.results.predict(end=end</span><span class="s2">, </span><span class="s1">**kwargs)</span><span class="s2">,</span>
            <span class="s1">self.true[</span><span class="s3">'predict'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">atol=atol)</span>

    <span class="s2">def </span><span class="s1">test_dynamic_predict(self</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">dynamic</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-6</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s4"># Tests predict + dynamic predict + forecast</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.results.predict(end=end</span><span class="s2">, </span><span class="s1">dynamic=dynamic</span><span class="s2">, </span><span class="s1">**kwargs)</span><span class="s2">,</span>
            <span class="s1">self.true[</span><span class="s3">'dynamic_predict'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">atol=atol)</span>

    <span class="s2">def </span><span class="s1">test_standardized_forecasts_error(self):</span>
        <span class="s1">cython_sfe = self.results.standardized_forecasts_error</span>
        <span class="s1">self.results._standardized_forecasts_error = </span><span class="s2">None</span>
        <span class="s1">python_sfe = self.results.standardized_forecasts_error</span>
        <span class="s1">assert_allclose(cython_sfe</span><span class="s2">, </span><span class="s1">python_sfe)</span>


<span class="s2">class </span><span class="s1">CheckLutkepohl(CheckVARMAX):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">true</span><span class="s2">, </span><span class="s1">order</span><span class="s2">, </span><span class="s1">trend</span><span class="s2">, </span><span class="s1">error_cov_type</span><span class="s2">, </span><span class="s1">cov_type=</span><span class="s3">'approx'</span><span class="s2">,</span>
                    <span class="s1">included_vars=[</span><span class="s3">'dln_inv'</span><span class="s2">, </span><span class="s3">'dln_inc'</span><span class="s2">, </span><span class="s3">'dln_consump'</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s1">**kwargs):</span>
        <span class="s1">cls.true = true</span>
        <span class="s4"># 1960:Q1 - 1982:Q4</span>
        <span class="s1">dta = pd.DataFrame(</span>
            <span class="s1">results_varmax.lutkepohl_data</span><span class="s2">, </span><span class="s1">columns=[</span><span class="s3">'inv'</span><span class="s2">, </span><span class="s3">'inc'</span><span class="s2">, </span><span class="s3">'consump'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">index=pd.date_range(</span><span class="s3">'1960-01-01'</span><span class="s2">, </span><span class="s3">'1982-10-01'</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">'QS'</span><span class="s1">))</span>

        <span class="s1">dta[</span><span class="s3">'dln_inv'</span><span class="s1">] = np.log(dta[</span><span class="s3">'inv'</span><span class="s1">]).diff()</span>
        <span class="s1">dta[</span><span class="s3">'dln_inc'</span><span class="s1">] = np.log(dta[</span><span class="s3">'inc'</span><span class="s1">]).diff()</span>
        <span class="s1">dta[</span><span class="s3">'dln_consump'</span><span class="s1">] = np.log(dta[</span><span class="s3">'consump'</span><span class="s1">]).diff()</span>

        <span class="s1">endog = dta.loc[</span><span class="s3">'1960-04-01'</span><span class="s1">:</span><span class="s3">'1978-10-01'</span><span class="s2">, </span><span class="s1">included_vars]</span>

        <span class="s1">cls.model = varmax.VARMAX(endog</span><span class="s2">, </span><span class="s1">order=order</span><span class="s2">, </span><span class="s1">trend=trend</span><span class="s2">,</span>
                                  <span class="s1">error_cov_type=error_cov_type</span><span class="s2">, </span><span class="s1">**kwargs)</span>

        <span class="s1">cls.results = cls.model.smooth(true[</span><span class="s3">'params'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">cov_type=cov_type)</span>

    <span class="s2">def </span><span class="s1">test_predict(self</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super(CheckLutkepohl</span><span class="s2">, </span><span class="s1">self).test_predict(end=</span><span class="s3">'1982-10-01'</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">test_dynamic_predict(self</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super(CheckLutkepohl</span><span class="s2">, </span><span class="s1">self).test_dynamic_predict(end=</span><span class="s3">'1982-10-01'</span><span class="s2">,</span>
                                                         <span class="s1">dynamic=</span><span class="s3">'1961-01-01'</span><span class="s2">,</span>
                                                         <span class="s1">**kwargs)</span>


<span class="s2">class </span><span class="s1">TestVAR(CheckLutkepohl):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">true = results_varmax.lutkepohl_var1.copy()</span>
        <span class="s1">true[</span><span class="s3">'predict'</span><span class="s1">] = var_results.iloc[</span><span class="s5">1</span><span class="s1">:][[</span><span class="s3">'predict_1'</span><span class="s2">,</span>
                                                <span class="s3">'predict_2'</span><span class="s2">,</span>
                                                <span class="s3">'predict_3'</span><span class="s1">]]</span>
        <span class="s1">true[</span><span class="s3">'dynamic_predict'</span><span class="s1">] = var_results.iloc[</span><span class="s5">1</span><span class="s1">:][[</span><span class="s3">'dyn_predict_1'</span><span class="s2">,</span>
                                                        <span class="s3">'dyn_predict_2'</span><span class="s2">,</span>
                                                        <span class="s3">'dyn_predict_3'</span><span class="s1">]]</span>
        <span class="s1">super(TestVAR</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">true</span><span class="s2">,  </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'n'</span><span class="s2">,</span>
            <span class="s1">error_cov_type=</span><span class="s3">&quot;unstructured&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bse_approx(self):</span>
        <span class="s1">bse = self.results._cov_params_approx().diagonal()**</span><span class="s5">0.5</span>
        <span class="s1">assert_allclose(bse**</span><span class="s5">2</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'var_oim'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-4</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bse_oim(self):</span>
        <span class="s1">bse = self.results._cov_params_oim().diagonal()**</span><span class="s5">0.5</span>
        <span class="s1">assert_allclose(bse**</span><span class="s5">2</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'var_oim'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_summary(self):</span>
        <span class="s1">summary = self.results.summary()</span>
        <span class="s1">tables = [str(table) </span><span class="s2">for </span><span class="s1">table </span><span class="s2">in </span><span class="s1">summary.tables]</span>
        <span class="s1">params = self.true[</span><span class="s3">'params'</span><span class="s1">]</span>

        <span class="s4"># Check the model overview table</span>
        <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">r'Model:.*VAR\(1\)'</span><span class="s2">, </span><span class="s1">tables[</span><span class="s5">0</span><span class="s1">])</span>

        <span class="s4"># For each endogenous variable, check the output</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(self.model.k_endog):</span>
            <span class="s1">offset = i * self.model.k_endog</span>
            <span class="s1">table = tables[i+</span><span class="s5">2</span><span class="s1">]</span>

            <span class="s4"># -&gt; Make sure we have the right table / table name</span>
            <span class="s1">name = self.model.endog_names[i]</span>
            <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">'Results for equation %s' </span><span class="s1">% name</span><span class="s2">, </span><span class="s1">table)</span>

            <span class="s4"># -&gt; Make sure it's the right size</span>
            <span class="s2">assert </span><span class="s1">len(table.split(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)) == </span><span class="s5">8</span>

            <span class="s4"># -&gt; Check that we have the right coefficients</span>
            <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">'L1.dln_inv +%.4f' </span><span class="s1">% params[offset + </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">table)</span>
            <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">'L1.dln_inc +%.4f' </span><span class="s1">% params[offset + </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">table)</span>
            <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">'L1.dln_consump +%.4f' </span><span class="s1">% params[offset + </span><span class="s5">2</span><span class="s1">]</span><span class="s2">,</span>
                             <span class="s1">table)</span>

        <span class="s4"># Test the error covariance matrix table</span>
        <span class="s1">table = tables[-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">'Error covariance matrix'</span><span class="s2">, </span><span class="s1">table)</span>
        <span class="s2">assert </span><span class="s1">len(table.split(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)) == </span><span class="s5">11</span>

        <span class="s1">params = params[self.model._params_state_cov]</span>
        <span class="s1">names = self.model.param_names[self.model._params_state_cov]</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(names)):</span>
            <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">'%s +%.4f' </span><span class="s1">% (names[i]</span><span class="s2">, </span><span class="s1">params[i])</span><span class="s2">, </span><span class="s1">table)</span>


<span class="s2">class </span><span class="s1">TestVAR_diagonal(CheckLutkepohl):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">true = results_varmax.lutkepohl_var1_diag.copy()</span>
        <span class="s1">true[</span><span class="s3">'predict'</span><span class="s1">] = var_results.iloc[</span><span class="s5">1</span><span class="s1">:][[</span><span class="s3">'predict_diag1'</span><span class="s2">,</span>
                                                <span class="s3">'predict_diag2'</span><span class="s2">,</span>
                                                <span class="s3">'predict_diag3'</span><span class="s1">]]</span>
        <span class="s1">true[</span><span class="s3">'dynamic_predict'</span><span class="s1">] = var_results.iloc[</span><span class="s5">1</span><span class="s1">:][[</span><span class="s3">'dyn_predict_diag1'</span><span class="s2">,</span>
                                                        <span class="s3">'dyn_predict_diag2'</span><span class="s2">,</span>
                                                        <span class="s3">'dyn_predict_diag3'</span><span class="s1">]]</span>
        <span class="s1">super(TestVAR_diagonal</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">true</span><span class="s2">,  </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'n'</span><span class="s2">,</span>
            <span class="s1">error_cov_type=</span><span class="s3">&quot;diagonal&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bse_approx(self):</span>
        <span class="s1">bse = self.results._cov_params_approx().diagonal()**</span><span class="s5">0.5</span>
        <span class="s1">assert_allclose(bse**</span><span class="s5">2</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'var_oim'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-5</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bse_oim(self):</span>
        <span class="s1">bse = self.results._cov_params_oim().diagonal()**</span><span class="s5">0.5</span>
        <span class="s1">assert_allclose(bse**</span><span class="s5">2</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'var_oim'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_summary(self):</span>
        <span class="s1">summary = self.results.summary()</span>
        <span class="s1">tables = [str(table) </span><span class="s2">for </span><span class="s1">table </span><span class="s2">in </span><span class="s1">summary.tables]</span>
        <span class="s1">params = self.true[</span><span class="s3">'params'</span><span class="s1">]</span>

        <span class="s4"># Check the model overview table</span>
        <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">r'Model:.*VAR\(1\)'</span><span class="s2">, </span><span class="s1">tables[</span><span class="s5">0</span><span class="s1">])</span>

        <span class="s4"># For each endogenous variable, check the output</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(self.model.k_endog):</span>
            <span class="s1">offset = i * self.model.k_endog</span>
            <span class="s1">table = tables[i+</span><span class="s5">2</span><span class="s1">]</span>

            <span class="s4"># -&gt; Make sure we have the right table / table name</span>
            <span class="s1">name = self.model.endog_names[i]</span>
            <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">'Results for equation %s' </span><span class="s1">% name</span><span class="s2">, </span><span class="s1">table)</span>

            <span class="s4"># -&gt; Make sure it's the right size</span>
            <span class="s2">assert </span><span class="s1">len(table.split(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)) == </span><span class="s5">8</span>

            <span class="s4"># -&gt; Check that we have the right coefficients</span>
            <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">'L1.dln_inv +%.4f' </span><span class="s1">% params[offset + </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">table)</span>
            <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">'L1.dln_inc +%.4f' </span><span class="s1">% params[offset + </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">table)</span>
            <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">'L1.dln_consump +%.4f' </span><span class="s1">% params[offset + </span><span class="s5">2</span><span class="s1">]</span><span class="s2">,</span>
                             <span class="s1">table)</span>

        <span class="s4"># Test the error covariance matrix table</span>
        <span class="s1">table = tables[-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">'Error covariance matrix'</span><span class="s2">, </span><span class="s1">table)</span>
        <span class="s2">assert </span><span class="s1">len(table.split(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)) == </span><span class="s5">8</span>

        <span class="s1">params = params[self.model._params_state_cov]</span>
        <span class="s1">names = self.model.param_names[self.model._params_state_cov]</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(names)):</span>
            <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">'%s +%.4f' </span><span class="s1">% (names[i]</span><span class="s2">, </span><span class="s1">params[i])</span><span class="s2">, </span><span class="s1">table)</span>


<span class="s2">class </span><span class="s1">TestVAR_measurement_error(CheckLutkepohl):</span>
    <span class="s0">&quot;&quot;&quot; 
    Notes 
    ----- 
    There does not appear to be a way to get Stata to estimate a VAR with 
    measurement errors. Thus this test is mostly a smoke test that measurement 
    errors are setup correctly: it uses the same params from TestVAR_diagonal 
    and sets the measurement errors variance params to zero to check that the 
    loglike and predict are the same. 
 
    It also checks that the state-space representation with positive 
    measurement errors is correct. 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">true = results_varmax.lutkepohl_var1_diag_meas.copy()</span>
        <span class="s1">true[</span><span class="s3">'predict'</span><span class="s1">] = var_results.iloc[</span><span class="s5">1</span><span class="s1">:][[</span><span class="s3">'predict_diag1'</span><span class="s2">,</span>
                                                <span class="s3">'predict_diag2'</span><span class="s2">,</span>
                                                <span class="s3">'predict_diag3'</span><span class="s1">]]</span>
        <span class="s1">true[</span><span class="s3">'dynamic_predict'</span><span class="s1">] = var_results.iloc[</span><span class="s5">1</span><span class="s1">:][[</span><span class="s3">'dyn_predict_diag1'</span><span class="s2">,</span>
                                                        <span class="s3">'dyn_predict_diag2'</span><span class="s2">,</span>
                                                        <span class="s3">'dyn_predict_diag3'</span><span class="s1">]]</span>
        <span class="s1">super(TestVAR_measurement_error</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">true</span><span class="s2">,  </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'n'</span><span class="s2">,</span>
            <span class="s1">error_cov_type=</span><span class="s3">&quot;diagonal&quot;</span><span class="s2">, </span><span class="s1">measurement_error=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s4"># Create another filter results with positive measurement errors</span>
        <span class="s1">cls.true_measurement_error_variances = [</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">2.</span><span class="s2">, </span><span class="s5">3.</span><span class="s1">]</span>
        <span class="s1">params = np.r_[true[</span><span class="s3">'params'</span><span class="s1">][:-</span><span class="s5">3</span><span class="s1">]</span><span class="s2">,</span>
                       <span class="s1">cls.true_measurement_error_variances]</span>
        <span class="s1">cls.results2 = cls.model.smooth(params)</span>

    <span class="s2">def </span><span class="s1">test_mle(self):</span>
        <span class="s4"># With the additional measurment error parameters, this would not be</span>
        <span class="s4"># a meaningful test</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">test_bse_approx(self):</span>
        <span class="s4"># This would just test the same thing</span>
        <span class="s4"># as TestVAR_diagonal.test_bse_approx</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">test_bse_oim(self):</span>
        <span class="s4"># This would just test the same thing as TestVAR_diagonal.test_bse_oim</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">test_aic(self):</span>
        <span class="s4"># Since the measurement error is added, the number</span>
        <span class="s4"># of parameters, and hence the aic and bic, will be off</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">test_bic(self):</span>
        <span class="s4"># Since the measurement error is added, the number</span>
        <span class="s4"># of parameters, and hence the aic and bic, will be off</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">test_representation(self):</span>
        <span class="s4"># Test that the state space representation in the measurement error</span>
        <span class="s4"># case is correct</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self.model.ssm.shapes.keys():</span>
            <span class="s2">if </span><span class="s1">name == </span><span class="s3">'obs'</span><span class="s1">:</span>
                <span class="s2">pass</span>
            <span class="s2">elif </span><span class="s1">name == </span><span class="s3">'obs_cov'</span><span class="s1">:</span>
                <span class="s1">actual = self.results2.filter_results.obs_cov</span>
                <span class="s1">desired = np.diag(</span>
                    <span class="s1">self.true_measurement_error_variances)[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">np.newaxis]</span>
                <span class="s1">assert_equal(actual</span><span class="s2">, </span><span class="s1">desired)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">assert_equal(getattr(self.results2.filter_results</span><span class="s2">, </span><span class="s1">name)</span><span class="s2">,</span>
                             <span class="s1">getattr(self.results.filter_results</span><span class="s2">, </span><span class="s1">name))</span>

    <span class="s2">def </span><span class="s1">test_summary(self):</span>
        <span class="s1">summary = self.results.summary()</span>
        <span class="s1">tables = [str(table) </span><span class="s2">for </span><span class="s1">table </span><span class="s2">in </span><span class="s1">summary.tables]</span>
        <span class="s1">params = self.true[</span><span class="s3">'params'</span><span class="s1">]</span>

        <span class="s4"># Check the model overview table</span>
        <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">r'Model:.*VAR\(1\)'</span><span class="s2">, </span><span class="s1">tables[</span><span class="s5">0</span><span class="s1">])</span>

        <span class="s4"># For each endogenous variable, check the output</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(self.model.k_endog):</span>
            <span class="s1">offset = i * self.model.k_endog</span>
            <span class="s1">table = tables[i+</span><span class="s5">2</span><span class="s1">]</span>

            <span class="s4"># -&gt; Make sure we have the right table / table name</span>
            <span class="s1">name = self.model.endog_names[i]</span>
            <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">'Results for equation %s' </span><span class="s1">% name</span><span class="s2">, </span><span class="s1">table)</span>

            <span class="s4"># -&gt; Make sure it's the right size</span>
            <span class="s2">assert </span><span class="s1">len(table.split(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)) == </span><span class="s5">9</span>

            <span class="s4"># -&gt; Check that we have the right coefficients</span>
            <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">'L1.dln_inv +%.4f' </span><span class="s1">% params[offset + </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">table)</span>
            <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">'L1.dln_inc +%.4f' </span><span class="s1">% params[offset + </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">table)</span>
            <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">'L1.dln_consump +%.4f' </span><span class="s1">% params[offset + </span><span class="s5">2</span><span class="s1">]</span><span class="s2">,</span>
                             <span class="s1">table)</span>
            <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">'measurement_variance +%.4g' </span><span class="s1">% params[-(i+</span><span class="s5">1</span><span class="s1">)]</span><span class="s2">,</span>
                             <span class="s1">table)</span>

        <span class="s4"># Test the error covariance matrix table</span>
        <span class="s1">table = tables[-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">'Error covariance matrix'</span><span class="s2">, </span><span class="s1">table)</span>
        <span class="s2">assert </span><span class="s1">len(table.split(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)) == </span><span class="s5">8</span>

        <span class="s1">params = params[self.model._params_state_cov]</span>
        <span class="s1">names = self.model.param_names[self.model._params_state_cov]</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(names)):</span>
            <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">'%s +%.4f' </span><span class="s1">% (names[i]</span><span class="s2">, </span><span class="s1">params[i])</span><span class="s2">, </span><span class="s1">table)</span>


<span class="s2">class </span><span class="s1">TestVAR_obs_intercept(CheckLutkepohl):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">true = results_varmax.lutkepohl_var1_obs_intercept.copy()</span>
        <span class="s1">true[</span><span class="s3">'predict'</span><span class="s1">] = var_results.iloc[</span><span class="s5">1</span><span class="s1">:][[</span><span class="s3">'predict_int1'</span><span class="s2">,</span>
                                                <span class="s3">'predict_int2'</span><span class="s2">,</span>
                                                <span class="s3">'predict_int3'</span><span class="s1">]]</span>
        <span class="s1">true[</span><span class="s3">'dynamic_predict'</span><span class="s1">] = var_results.iloc[</span><span class="s5">1</span><span class="s1">:][[</span><span class="s3">'dyn_predict_int1'</span><span class="s2">,</span>
                                                        <span class="s3">'dyn_predict_int2'</span><span class="s2">,</span>
                                                        <span class="s3">'dyn_predict_int3'</span><span class="s1">]]</span>
        <span class="s1">super(TestVAR_obs_intercept</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">true</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'n'</span><span class="s2">,</span>
            <span class="s1">error_cov_type=</span><span class="s3">&quot;diagonal&quot;</span><span class="s2">, </span><span class="s1">obs_intercept=true[</span><span class="s3">'obs_intercept'</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_bse_approx(self):</span>
        <span class="s1">bse = self.results._cov_params_approx().diagonal()**</span><span class="s5">0.5</span>
        <span class="s1">assert_allclose(bse**</span><span class="s5">2</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'var_oim'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-4</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bse_oim(self):</span>
        <span class="s1">bse = self.results._cov_params_oim().diagonal()**</span><span class="s5">0.5</span>
        <span class="s1">assert_allclose(bse**</span><span class="s5">2</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'var_oim'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_aic(self):</span>
        <span class="s4"># Since the obs_intercept is added in in an ad-hoc way here, the number</span>
        <span class="s4"># of parameters, and hence the aic and bic, will be off</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">test_bic(self):</span>
        <span class="s4"># Since the obs_intercept is added in in an ad-hoc way here, the number</span>
        <span class="s4"># of parameters, and hence the aic and bic, will be off</span>
        <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">TestVAR_exog(CheckLutkepohl):</span>
    <span class="s4"># Note: unlike the other tests in this file, this is against the Stata</span>
    <span class="s4"># var function rather than the Stata dfactor function</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">true = results_varmax.lutkepohl_var1_exog.copy()</span>
        <span class="s1">true[</span><span class="s3">'predict'</span><span class="s1">] = var_results.iloc[</span><span class="s5">1</span><span class="s1">:</span><span class="s5">76</span><span class="s1">][[</span><span class="s3">'predict_exog1_1'</span><span class="s2">,</span>
                                                  <span class="s3">'predict_exog1_2'</span><span class="s2">,</span>
                                                  <span class="s3">'predict_exog1_3'</span><span class="s1">]]</span>
        <span class="s1">true[</span><span class="s3">'predict'</span><span class="s1">].iloc[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">:] = </span><span class="s5">0</span>
        <span class="s1">true[</span><span class="s3">'fcast'</span><span class="s1">] = var_results.iloc[</span><span class="s5">76</span><span class="s1">:][[</span><span class="s3">'fcast_exog1_dln_inv'</span><span class="s2">,</span>
                                               <span class="s3">'fcast_exog1_dln_inc'</span><span class="s2">,</span>
                                               <span class="s3">'fcast_exog1_dln_consump'</span><span class="s1">]]</span>
        <span class="s1">exog = np.arange(</span><span class="s5">75</span><span class="s1">) + </span><span class="s5">2</span>
        <span class="s1">super(TestVAR_exog</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">true</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'n'</span><span class="s2">, </span><span class="s1">error_cov_type=</span><span class="s3">'unstructured'</span><span class="s2">,</span>
            <span class="s1">exog=exog</span><span class="s2">, </span><span class="s1">initialization=</span><span class="s3">'approximate_diffuse'</span><span class="s2">,</span>
            <span class="s1">loglikelihood_burn=</span><span class="s5">1</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_mle(self):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">test_aic(self):</span>
        <span class="s4"># Stata's var calculates AIC differently</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">test_bic(self):</span>
        <span class="s4"># Stata's var calculates BIC differently</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">test_bse_approx(self):</span>
        <span class="s4"># Exclude the covariance cholesky terms</span>
        <span class="s1">bse = self.results._cov_params_approx().diagonal()**</span><span class="s5">0.5</span>
        <span class="s1">assert_allclose(bse[:-</span><span class="s5">6</span><span class="s1">]**</span><span class="s5">2</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'var_oim'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-5</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bse_oim(self):</span>
        <span class="s4"># Exclude the covariance cholesky terms</span>
        <span class="s1">bse = self.results._cov_params_oim().diagonal()**</span><span class="s5">0.5</span>
        <span class="s1">assert_allclose(bse[:-</span><span class="s5">6</span><span class="s1">]**</span><span class="s5">2</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'var_oim'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-5</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_predict(self):</span>
        <span class="s1">super(CheckLutkepohl</span><span class="s2">, </span><span class="s1">self).test_predict(end=</span><span class="s3">'1978-10-01'</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-3</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_dynamic_predict(self):</span>
        <span class="s4"># Stata's var cannot subsequently use dynamic</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">test_forecast(self):</span>
        <span class="s4"># Tests forecast</span>
        <span class="s1">exog = (np.arange(</span><span class="s5">75</span><span class="s2">, </span><span class="s5">75</span><span class="s1">+</span><span class="s5">16</span><span class="s1">) + </span><span class="s5">2</span><span class="s1">)[:</span><span class="s2">, </span><span class="s1">np.newaxis]</span>

        <span class="s4"># Test it through the results class wrapper</span>
        <span class="s1">desired = self.results.forecast(steps=</span><span class="s5">16</span><span class="s2">, </span><span class="s1">exog=exog)</span>
        <span class="s1">assert_allclose(desired</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'fcast'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-6</span><span class="s1">)</span>

        <span class="s4"># Test it directly (i.e. without the wrapping done in</span>
        <span class="s4"># VARMAXResults.get_prediction which converts exog to state_intercept)</span>
        <span class="s4"># beta = self.results.params[-9:-6]</span>
        <span class="s4"># state_intercept = np.concatenate([</span>
        <span class="s4">#     exog*beta[0], exog*beta[1], exog*beta[2]], axis=1).T</span>
        <span class="s4"># desired = mlemodel.MLEResults.get_prediction(</span>
        <span class="s4">#     self.results._results, start=75, end=75+15,</span>
        <span class="s4">#     state_intercept=state_intercept).predicted_mean</span>
        <span class="s4"># assert_allclose(desired, self.true['fcast'], atol=1e-6)</span>

    <span class="s2">def </span><span class="s1">test_summary(self):</span>
        <span class="s1">summary = self.results.summary()</span>
        <span class="s1">tables = [str(table) </span><span class="s2">for </span><span class="s1">table </span><span class="s2">in </span><span class="s1">summary.tables]</span>
        <span class="s1">params = self.true[</span><span class="s3">'params'</span><span class="s1">]</span>

        <span class="s4"># Check the model overview table</span>
        <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">r'Model:.*VARX\(1\)'</span><span class="s2">, </span><span class="s1">tables[</span><span class="s5">0</span><span class="s1">])</span>

        <span class="s4"># For each endogenous variable, check the output</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(self.model.k_endog):</span>
            <span class="s1">offset = i * self.model.k_endog</span>
            <span class="s1">table = tables[i+</span><span class="s5">2</span><span class="s1">]</span>

            <span class="s4"># -&gt; Make sure we have the right table / table name</span>
            <span class="s1">name = self.model.endog_names[i]</span>
            <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">'Results for equation %s' </span><span class="s1">% name</span><span class="s2">, </span><span class="s1">table)</span>

            <span class="s4"># -&gt; Make sure it's the right size</span>
            <span class="s2">assert </span><span class="s1">len(table.split(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)) == </span><span class="s5">9</span>

            <span class="s4"># -&gt; Check that we have the right coefficients</span>
            <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">'L1.dln_inv +%.4f' </span><span class="s1">% params[offset + </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">table)</span>
            <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">'L1.dln_inc +%.4f' </span><span class="s1">% params[offset + </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">table)</span>
            <span class="s2">assert </span><span class="s1">re.search(</span>
                <span class="s3">'L1.dln_consump +%.4f' </span><span class="s1">% params[offset + </span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">table)</span>
            <span class="s2">assert </span><span class="s1">re.search(</span>
                <span class="s3">'beta.x1 +' </span><span class="s1">+ forg(params[self.model._params_regression][i]</span><span class="s2">,</span>
                                   <span class="s1">prec=</span><span class="s5">4</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">table)</span>

        <span class="s4"># Test the error covariance matrix table</span>
        <span class="s1">table = tables[-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">'Error covariance matrix'</span><span class="s2">, </span><span class="s1">table)</span>
        <span class="s2">assert </span><span class="s1">len(table.split(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)) == </span><span class="s5">11</span>

        <span class="s1">params = params[self.model._params_state_cov]</span>
        <span class="s1">names = self.model.param_names[self.model._params_state_cov]</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(names)):</span>
            <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">'%s +%.4f' </span><span class="s1">% (names[i]</span><span class="s2">, </span><span class="s1">params[i])</span><span class="s2">, </span><span class="s1">table)</span>


<span class="s2">class </span><span class="s1">TestVAR_exog2(CheckLutkepohl):</span>
    <span class="s4"># This is a regression test, to make sure that the setup with multiple exog</span>
    <span class="s4"># works correctly. The params are from Stata, but the loglike is from</span>
    <span class="s4"># this model. Likely the small discrepancy (see the results file) is from</span>
    <span class="s4"># the approximate diffuse initialization.</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">true = results_varmax.lutkepohl_var1_exog2.copy()</span>
        <span class="s1">true[</span><span class="s3">'predict'</span><span class="s1">] = var_results.iloc[</span><span class="s5">1</span><span class="s1">:</span><span class="s5">76</span><span class="s1">][[</span><span class="s3">'predict_exog2_1'</span><span class="s2">,</span>
                                                  <span class="s3">'predict_exog2_2'</span><span class="s2">,</span>
                                                  <span class="s3">'predict_exog2_3'</span><span class="s1">]]</span>
        <span class="s1">true[</span><span class="s3">'predict'</span><span class="s1">].iloc[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">:] = </span><span class="s5">0</span>
        <span class="s1">true[</span><span class="s3">'fcast'</span><span class="s1">] = var_results.iloc[</span><span class="s5">76</span><span class="s1">:][[</span><span class="s3">'fcast_exog2_dln_inv'</span><span class="s2">,</span>
                                               <span class="s3">'fcast_exog2_dln_inc'</span><span class="s2">,</span>
                                               <span class="s3">'fcast_exog2_dln_consump'</span><span class="s1">]]</span>
        <span class="s1">exog = np.c_[np.ones((</span><span class="s5">75</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span><span class="s2">, </span><span class="s1">(np.arange(</span><span class="s5">75</span><span class="s1">) + </span><span class="s5">2</span><span class="s1">)[:</span><span class="s2">, </span><span class="s1">np.newaxis]]</span>
        <span class="s1">super(TestVAR_exog2</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">true</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'n'</span><span class="s2">, </span><span class="s1">error_cov_type=</span><span class="s3">'unstructured'</span><span class="s2">,</span>
            <span class="s1">exog=exog</span><span class="s2">, </span><span class="s1">initialization=</span><span class="s3">'approximate_diffuse'</span><span class="s2">,</span>
            <span class="s1">loglikelihood_burn=</span><span class="s5">1</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_mle(self):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">test_aic(self):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">test_bic(self):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">test_bse_approx(self):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">test_bse_oim(self):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">test_predict(self):</span>
        <span class="s1">super(CheckLutkepohl</span><span class="s2">, </span><span class="s1">self).test_predict(end=</span><span class="s3">'1978-10-01'</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-3</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_dynamic_predict(self):</span>
        <span class="s4"># Stata's var cannot subsequently use dynamic</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">test_forecast(self):</span>
        <span class="s4"># Tests forecast</span>
        <span class="s1">exog = np.c_[np.ones((</span><span class="s5">16</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span><span class="s2">,</span>
                     <span class="s1">(np.arange(</span><span class="s5">75</span><span class="s2">, </span><span class="s5">75</span><span class="s1">+</span><span class="s5">16</span><span class="s1">) + </span><span class="s5">2</span><span class="s1">)[:</span><span class="s2">, </span><span class="s1">np.newaxis]]</span>

        <span class="s1">desired = self.results.forecast(steps=</span><span class="s5">16</span><span class="s2">, </span><span class="s1">exog=exog)</span>
        <span class="s1">assert_allclose(desired</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'fcast'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-6</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestVAR2(CheckLutkepohl):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">true = results_varmax.lutkepohl_var2.copy()</span>
        <span class="s1">true[</span><span class="s3">'predict'</span><span class="s1">] = var_results.iloc[</span><span class="s5">1</span><span class="s1">:][[</span><span class="s3">'predict_var2_1'</span><span class="s2">,</span>
                                                <span class="s3">'predict_var2_2'</span><span class="s1">]]</span>
        <span class="s1">true[</span><span class="s3">'dynamic_predict'</span><span class="s1">] = var_results.iloc[</span><span class="s5">1</span><span class="s1">:][[</span><span class="s3">'dyn_predict_var2_1'</span><span class="s2">,</span>
                                                        <span class="s3">'dyn_predict_var2_2'</span><span class="s1">]]</span>
        <span class="s1">super(TestVAR2</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">true</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'n'</span><span class="s2">, </span><span class="s1">error_cov_type=</span><span class="s3">'unstructured'</span><span class="s2">,</span>
            <span class="s1">included_vars=[</span><span class="s3">'dln_inv'</span><span class="s2">, </span><span class="s3">'dln_inc'</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_bse_approx(self):</span>
        <span class="s4"># Exclude the covariance cholesky terms</span>
        <span class="s1">bse = self.results._cov_params_approx().diagonal()**</span><span class="s5">0.5</span>
        <span class="s1">assert_allclose(bse[:-</span><span class="s5">3</span><span class="s1">]**</span><span class="s5">2</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'var_oim'</span><span class="s1">][:-</span><span class="s5">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-5</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bse_oim(self):</span>
        <span class="s4"># Exclude the covariance cholesky terms</span>
        <span class="s1">bse = self.results._cov_params_oim().diagonal()**</span><span class="s5">0.5</span>
        <span class="s1">assert_allclose(bse[:-</span><span class="s5">3</span><span class="s1">]**</span><span class="s5">2</span><span class="s2">, </span><span class="s1">self.true[</span><span class="s3">'var_oim'</span><span class="s1">][:-</span><span class="s5">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_summary(self):</span>
        <span class="s1">summary = self.results.summary()</span>
        <span class="s1">tables = [str(table) </span><span class="s2">for </span><span class="s1">table </span><span class="s2">in </span><span class="s1">summary.tables]</span>
        <span class="s1">params = self.true[</span><span class="s3">'params'</span><span class="s1">]</span>

        <span class="s4"># Check the model overview table</span>
        <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">r'Model:.*VAR\(2\)'</span><span class="s2">, </span><span class="s1">tables[</span><span class="s5">0</span><span class="s1">])</span>

        <span class="s4"># For each endogenous variable, check the output</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(self.model.k_endog):</span>
            <span class="s1">offset = i * self.model.k_endog * self.model.k_ar</span>
            <span class="s1">table = tables[i+</span><span class="s5">2</span><span class="s1">]</span>

            <span class="s4"># -&gt; Make sure we have the right table / table name</span>
            <span class="s1">name = self.model.endog_names[i]</span>
            <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">'Results for equation %s' </span><span class="s1">% name</span><span class="s2">, </span><span class="s1">table)</span>

            <span class="s4"># -&gt; Make sure it's the right size</span>
            <span class="s2">assert </span><span class="s1">len(table.split(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)) == </span><span class="s5">9</span>

            <span class="s4"># -&gt; Check that we have the right coefficients</span>
            <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">'L1.dln_inv +%.4f' </span><span class="s1">% params[offset + </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">table)</span>
            <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">'L1.dln_inc +%.4f' </span><span class="s1">% params[offset + </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">table)</span>
            <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">'L2.dln_inv +%.4f' </span><span class="s1">% params[offset + </span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">table)</span>
            <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">'L2.dln_inc +%.4f' </span><span class="s1">% params[offset + </span><span class="s5">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">table)</span>

        <span class="s4"># Test the error covariance matrix table</span>
        <span class="s1">table = tables[-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">'Error covariance matrix'</span><span class="s2">, </span><span class="s1">table)</span>
        <span class="s2">assert </span><span class="s1">len(table.split(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)) == </span><span class="s5">8</span>

        <span class="s1">params = params[self.model._params_state_cov]</span>
        <span class="s1">names = self.model.param_names[self.model._params_state_cov]</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(names)):</span>
            <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">'%s +%.4f' </span><span class="s1">% (names[i]</span><span class="s2">, </span><span class="s1">params[i])</span><span class="s2">, </span><span class="s1">table)</span>


<span class="s2">class </span><span class="s1">CheckFREDManufacturing(CheckVARMAX):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">true</span><span class="s2">, </span><span class="s1">order</span><span class="s2">, </span><span class="s1">trend</span><span class="s2">, </span><span class="s1">error_cov_type</span><span class="s2">, </span><span class="s1">cov_type=</span><span class="s3">'approx'</span><span class="s2">,</span>
                    <span class="s1">**kwargs):</span>
        <span class="s1">cls.true = true</span>
        <span class="s4"># 1960:Q1 - 1982:Q4</span>
        <span class="s1">path = os.path.join(current_path</span><span class="s2">, </span><span class="s3">'results'</span><span class="s2">, </span><span class="s3">'manufac.dta'</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">open(path</span><span class="s2">, </span><span class="s3">'rb'</span><span class="s1">) </span><span class="s2">as </span><span class="s1">test_data:</span>
            <span class="s1">dta = pd.read_stata(test_data)</span>
        <span class="s1">dta.index = pd.DatetimeIndex(dta.month</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">'MS'</span><span class="s1">)</span>
        <span class="s1">dta[</span><span class="s3">'dlncaputil'</span><span class="s1">] = dta[</span><span class="s3">'lncaputil'</span><span class="s1">].diff()</span>
        <span class="s1">dta[</span><span class="s3">'dlnhours'</span><span class="s1">] = dta[</span><span class="s3">'lnhours'</span><span class="s1">].diff()</span>

        <span class="s1">endog = dta.loc[</span><span class="s3">'1972-02-01'</span><span class="s1">:</span><span class="s2">, </span><span class="s1">[</span><span class="s3">'dlncaputil'</span><span class="s2">, </span><span class="s3">'dlnhours'</span><span class="s1">]]</span>

        <span class="s2">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s2">True</span><span class="s1">):</span>
            <span class="s1">warnings.simplefilter(</span><span class="s3">'always'</span><span class="s1">)</span>
            <span class="s1">cls.model = varmax.VARMAX(endog</span><span class="s2">, </span><span class="s1">order=order</span><span class="s2">, </span><span class="s1">trend=trend</span><span class="s2">,</span>
                                      <span class="s1">error_cov_type=error_cov_type</span><span class="s2">, </span><span class="s1">**kwargs)</span>

        <span class="s1">cls.results = cls.model.smooth(true[</span><span class="s3">'params'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">cov_type=cov_type)</span>


<span class="s2">class </span><span class="s1">TestVARMA(CheckFREDManufacturing):</span>
    <span class="s0">&quot;&quot;&quot; 
    Test against the sspace VARMA example with some params set to zeros. 
    &quot;&quot;&quot;</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">true = results_varmax.fred_varma11.copy()</span>
        <span class="s1">true[</span><span class="s3">'predict'</span><span class="s1">] = varmax_results.iloc[</span><span class="s5">1</span><span class="s1">:][[</span><span class="s3">'predict_varma11_1'</span><span class="s2">,</span>
                                                   <span class="s3">'predict_varma11_2'</span><span class="s1">]]</span>
        <span class="s1">true[</span><span class="s3">'dynamic_predict'</span><span class="s1">] = varmax_results.iloc[</span><span class="s5">1</span><span class="s1">:][[</span>
            <span class="s3">'dyn_predict_varma11_1'</span><span class="s2">, </span><span class="s3">'dyn_predict_varma11_2'</span><span class="s1">]]</span>

        <span class="s1">super(TestVARMA</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
              <span class="s1">true</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'n'</span><span class="s2">, </span><span class="s1">error_cov_type=</span><span class="s3">'diagonal'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_mle(self):</span>
        <span class="s4"># Since the VARMA model here is generic (we're just forcing zeros</span>
        <span class="s4"># in some params) whereas Stata's is restricted, the MLE test is not</span>
        <span class="s4"># meaninful</span>
        <span class="s2">pass</span>

    <span class="s1">@pytest.mark.skip(</span><span class="s3">'Known failure: standard errors do not match.'</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_bse_approx(self):</span>
        <span class="s4"># Standard errors do not match Stata's</span>
        <span class="s2">pass</span>

    <span class="s1">@pytest.mark.skip(</span><span class="s3">'Known failure: standard errors do not match.'</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_bse_oim(self):</span>
        <span class="s4"># Standard errors do not match Stata's</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">test_aic(self):</span>
        <span class="s4"># Since the VARMA model here is generic (we're just putting in zeros</span>
        <span class="s4"># for some params), Stata assumes a different estimated number of</span>
        <span class="s4"># parameters; hence the aic and bic, will be off</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">test_bic(self):</span>
        <span class="s4"># Since the VARMA model here is generic (we're just putting in zeros</span>
        <span class="s4"># for some params), Stata assumes a different estimated number of</span>
        <span class="s4"># parameters; hence the aic and bic, will be off</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">test_predict(self):</span>
        <span class="s1">super(TestVARMA</span><span class="s2">, </span><span class="s1">self).test_predict(end=</span><span class="s3">'2009-05-01'</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-4</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_dynamic_predict(self):</span>
        <span class="s1">super(TestVARMA</span><span class="s2">, </span><span class="s1">self).test_dynamic_predict(end=</span><span class="s3">'2009-05-01'</span><span class="s2">,</span>
                                                    <span class="s1">dynamic=</span><span class="s3">'2000-01-01'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_summary(self):</span>
        <span class="s1">summary = self.results.summary()</span>
        <span class="s1">tables = [str(table) </span><span class="s2">for </span><span class="s1">table </span><span class="s2">in </span><span class="s1">summary.tables]</span>
        <span class="s1">params = self.true[</span><span class="s3">'params'</span><span class="s1">]</span>

        <span class="s4"># Check the model overview table</span>
        <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">r'Model:.*VARMA\(1,1\)'</span><span class="s2">, </span><span class="s1">tables[</span><span class="s5">0</span><span class="s1">])</span>

        <span class="s4"># For each endogenous variable, check the output</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(self.model.k_endog):</span>
            <span class="s1">offset_ar = i * self.model.k_endog</span>
            <span class="s1">offset_ma = (self.model.k_endog**</span><span class="s5">2 </span><span class="s1">* self.model.k_ar +</span>
                         <span class="s1">i * self.model.k_endog)</span>
            <span class="s1">table = tables[i+</span><span class="s5">2</span><span class="s1">]</span>

            <span class="s4"># -&gt; Make sure we have the right table / table name</span>
            <span class="s1">name = self.model.endog_names[i]</span>
            <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">'Results for equation %s' </span><span class="s1">% name</span><span class="s2">, </span><span class="s1">table)</span>

            <span class="s4"># -&gt; Make sure it's the right size</span>
            <span class="s2">assert </span><span class="s1">len(table.split(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)) == </span><span class="s5">9</span>

            <span class="s4"># -&gt; Check that we have the right coefficients</span>
            <span class="s2">assert </span><span class="s1">re.search(</span>
                <span class="s3">'L1.dlncaputil +' </span><span class="s1">+ forg(params[offset_ar + </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">prec=</span><span class="s5">4</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">table)</span>
            <span class="s2">assert </span><span class="s1">re.search(</span>
                <span class="s3">'L1.dlnhours +' </span><span class="s1">+ forg(params[offset_ar + </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">prec=</span><span class="s5">4</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">table)</span>
            <span class="s2">assert </span><span class="s1">re.search(</span>
                <span class="s3">r'L1.e\(dlncaputil\) +' </span><span class="s1">+ forg(params[offset_ma + </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">prec=</span><span class="s5">4</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">table)</span>
            <span class="s2">assert </span><span class="s1">re.search(</span>
                <span class="s3">r'L1.e\(dlnhours\) +' </span><span class="s1">+ forg(params[offset_ma + </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">prec=</span><span class="s5">4</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">table)</span>

        <span class="s4"># Test the error covariance matrix table</span>
        <span class="s1">table = tables[-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">'Error covariance matrix'</span><span class="s2">, </span><span class="s1">table)</span>
        <span class="s2">assert </span><span class="s1">len(table.split(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)) == </span><span class="s5">7</span>

        <span class="s1">params = params[self.model._params_state_cov]</span>
        <span class="s1">names = self.model.param_names[self.model._params_state_cov]</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(names)):</span>
            <span class="s2">assert </span><span class="s1">re.search(</span><span class="s3">'%s +%s' </span><span class="s1">% (names[i]</span><span class="s2">, </span><span class="s1">forg(params[i]</span><span class="s2">, </span><span class="s1">prec=</span><span class="s5">4</span><span class="s1">))</span><span class="s2">,</span>
                             <span class="s1">table)</span>


<span class="s2">class </span><span class="s1">TestVMA1(CheckFREDManufacturing):</span>
    <span class="s0">&quot;&quot;&quot; 
    Test against the sspace VARMA example with some params set to zeros. 
    &quot;&quot;&quot;</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">true = results_varmax.fred_vma1.copy()</span>
        <span class="s1">true[</span><span class="s3">'predict'</span><span class="s1">] = varmax_results.iloc[</span><span class="s5">1</span><span class="s1">:][[</span><span class="s3">'predict_vma1_1'</span><span class="s2">,</span>
                                                   <span class="s3">'predict_vma1_2'</span><span class="s1">]]</span>
        <span class="s1">true[</span><span class="s3">'dynamic_predict'</span><span class="s1">] = varmax_results.iloc[</span><span class="s5">1</span><span class="s1">:][[</span>
            <span class="s3">'dyn_predict_vma1_1'</span><span class="s2">, </span><span class="s3">'dyn_predict_vma1_2'</span><span class="s1">]]</span>

        <span class="s1">super(TestVMA1</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
              <span class="s1">true</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'n'</span><span class="s2">, </span><span class="s1">error_cov_type=</span><span class="s3">'diagonal'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_mle(self):</span>
        <span class="s4"># Since the VARMA model here is generic (we're just forcing zeros</span>
        <span class="s4"># in some params) whereas Stata's is restricted, the MLE test is not</span>
        <span class="s4"># meaninful</span>
        <span class="s2">pass</span>

    <span class="s1">@pytest.mark.skip(</span><span class="s3">'Known failure: standard errors do not match.'</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_bse_approx(self):</span>
        <span class="s4"># Standard errors do not match Stata's</span>
        <span class="s2">pass</span>

    <span class="s1">@pytest.mark.skip(</span><span class="s3">'Known failure: standard errors do not match.'</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_bse_oim(self):</span>
        <span class="s4"># Standard errors do not match Stata's</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">test_aic(self):</span>
        <span class="s4"># Since the VARMA model here is generic (we're just putting in zeros</span>
        <span class="s4"># for some params), Stata assumes a different estimated number of</span>
        <span class="s4"># parameters; hence the aic and bic, will be off</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">test_bic(self):</span>
        <span class="s4"># Since the VARMA model here is generic (we're just putting in zeros</span>
        <span class="s4"># for some params), Stata assumes a different estimated number of</span>
        <span class="s4"># parameters; hence the aic and bic, will be off</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">test_predict(self):</span>
        <span class="s1">super(TestVMA1</span><span class="s2">, </span><span class="s1">self).test_predict(end=</span><span class="s3">'2009-05-01'</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-4</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_dynamic_predict(self):</span>
        <span class="s1">super(TestVMA1</span><span class="s2">, </span><span class="s1">self).test_dynamic_predict(end=</span><span class="s3">'2009-05-01'</span><span class="s2">,</span>
                                                   <span class="s1">dynamic=</span><span class="s3">'2000-01-01'</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_specifications():</span>
    <span class="s4"># Tests for model specification and state space creation</span>
    <span class="s1">endog = np.arange(</span><span class="s5">20</span><span class="s1">).reshape(</span><span class="s5">10</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>
    <span class="s1">exog = np.arange(</span><span class="s5">10</span><span class="s1">)</span>
    <span class="s1">exog2 = pd.Series(exog</span><span class="s2">, </span><span class="s1">index=pd.date_range(</span><span class="s3">'2000-01-01'</span><span class="s2">, </span><span class="s3">'2009-01-01'</span><span class="s2">,</span>
                                                <span class="s1">freq=</span><span class="s3">'AS'</span><span class="s1">))</span>

    <span class="s4"># Test successful model creation</span>
    <span class="s1">varmax.VARMAX(endog</span><span class="s2">, </span><span class="s1">exog=exog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">))</span>

    <span class="s4"># Test successful model creation with pandas exog</span>
    <span class="s1">varmax.VARMAX(endog</span><span class="s2">, </span><span class="s1">exog=exog2</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">))</span>


<span class="s2">def </span><span class="s1">test_misspecifications():</span>
    <span class="s1">varmax.__warningregistry__ = {}</span>

    <span class="s4"># Tests for model specification and misspecification exceptions</span>
    <span class="s1">endog = np.arange(</span><span class="s5">20</span><span class="s1">).reshape(</span><span class="s5">10</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>

    <span class="s4"># Bad trend specification</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">varmax.VARMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">''</span><span class="s1">)</span>

    <span class="s4"># Bad error_cov_type specification</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">varmax.VARMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">error_cov_type=</span><span class="s3">''</span><span class="s1">)</span>

    <span class="s4"># Bad order specification</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">varmax.VARMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">))</span>

    <span class="s2">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s2">True</span><span class="s1">) </span><span class="s2">as </span><span class="s1">w:</span>
        <span class="s1">warnings.simplefilter(</span><span class="s3">'always'</span><span class="s1">)</span>
        <span class="s1">varmax.VARMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span>

    <span class="s4"># Warning with VARMA specification</span>
    <span class="s2">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s2">True</span><span class="s1">) </span><span class="s2">as </span><span class="s1">w:</span>
        <span class="s1">warnings.simplefilter(</span><span class="s3">'always'</span><span class="s1">)</span>

        <span class="s1">varmax.VARMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span>

        <span class="s1">message = (</span><span class="s3">'Estimation of VARMA(p,q) models is not generically robust,'</span>
                   <span class="s3">' due especially to identification issues.'</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">str(w[</span><span class="s5">0</span><span class="s1">].message) == message</span>

    <span class="s1">warnings.resetwarnings()</span>


<span class="s2">def </span><span class="s1">test_misc_exog():</span>
    <span class="s4"># Tests for missing data</span>
    <span class="s1">nobs = </span><span class="s5">20</span>
    <span class="s1">k_endog = </span><span class="s5">2</span>
    <span class="s1">np.random.seed(</span><span class="s5">1208</span><span class="s1">)</span>
    <span class="s1">endog = np.random.normal(size=(nobs</span><span class="s2">, </span><span class="s1">k_endog))</span>
    <span class="s1">endog[:</span><span class="s5">4</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] = np.nan</span>
    <span class="s1">endog[</span><span class="s5">2</span><span class="s1">:</span><span class="s5">6</span><span class="s2">, </span><span class="s5">1</span><span class="s1">] = np.nan</span>
    <span class="s1">exog1 = np.random.normal(size=(nobs</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span>
    <span class="s1">exog2 = np.random.normal(size=(nobs</span><span class="s2">, </span><span class="s5">2</span><span class="s1">))</span>

    <span class="s1">index = pd.date_range(</span><span class="s3">'1970-01-01'</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">'QS'</span><span class="s2">, </span><span class="s1">periods=nobs)</span>
    <span class="s1">endog_pd = pd.DataFrame(endog</span><span class="s2">, </span><span class="s1">index=index)</span>
    <span class="s1">exog1_pd = pd.Series(exog1.squeeze()</span><span class="s2">, </span><span class="s1">index=index)</span>
    <span class="s1">exog2_pd = pd.DataFrame(exog2</span><span class="s2">, </span><span class="s1">index=index)</span>

    <span class="s1">models = [</span>
        <span class="s1">varmax.VARMAX(endog</span><span class="s2">, </span><span class="s1">exog=exog1</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">))</span><span class="s2">,</span>
        <span class="s1">varmax.VARMAX(endog</span><span class="s2">, </span><span class="s1">exog=exog2</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">))</span><span class="s2">,</span>
        <span class="s1">varmax.VARMAX(endog_pd</span><span class="s2">, </span><span class="s1">exog=exog1_pd</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">))</span><span class="s2">,</span>
        <span class="s1">varmax.VARMAX(endog_pd</span><span class="s2">, </span><span class="s1">exog=exog2_pd</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">))</span><span class="s2">,</span>
    <span class="s1">]</span>

    <span class="s2">for </span><span class="s1">mod </span><span class="s2">in </span><span class="s1">models:</span>
        <span class="s4"># Smoke tests</span>
        <span class="s1">mod.start_params</span>
        <span class="s1">res = mod.fit(disp=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">res.summary()</span>
        <span class="s1">res.predict()</span>
        <span class="s1">res.predict(dynamic=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">res.get_prediction()</span>

        <span class="s1">oos_exog = np.random.normal(size=(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">mod.k_exog))</span>
        <span class="s1">res.forecast(steps=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">exog=oos_exog)</span>
        <span class="s1">res.get_forecast(steps=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">exog=oos_exog)</span>

        <span class="s4"># Smoke tests for invalid exog</span>
        <span class="s1">oos_exog = np.random.normal(size=(</span><span class="s5">2</span><span class="s2">, </span><span class="s1">mod.k_exog))</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">res.forecast(steps=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">exog=oos_exog)</span>

        <span class="s1">oos_exog = np.random.normal(size=(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">mod.k_exog + </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">res.forecast(steps=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">exog=oos_exog)</span>

    <span class="s4"># Test invalid model specifications</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">varmax.VARMAX(endog</span><span class="s2">, </span><span class="s1">exog=np.zeros((</span><span class="s5">10</span><span class="s2">, </span><span class="s5">4</span><span class="s1">))</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">))</span>


<span class="s2">def </span><span class="s1">test_predict_custom_index():</span>
    <span class="s1">np.random.seed(</span><span class="s5">328423</span><span class="s1">)</span>
    <span class="s1">endog = pd.DataFrame(np.random.normal(size=(</span><span class="s5">50</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)))</span>
    <span class="s1">mod = varmax.VARMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">))</span>
    <span class="s1">res = mod.smooth(mod.start_params)</span>
    <span class="s1">out = res.predict(start=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">end=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">index=[</span><span class="s3">'a'</span><span class="s1">])</span>
    <span class="s2">assert </span><span class="s1">out.index.equals(pd.Index([</span><span class="s3">'a'</span><span class="s1">]))</span>


<span class="s2">def </span><span class="s1">test_forecast_exog():</span>
    <span class="s4"># Test forecasting with various shapes of `exog`</span>
    <span class="s1">nobs = </span><span class="s5">100</span>
    <span class="s1">endog = np.ones((nobs</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)) * </span><span class="s5">2.0</span>
    <span class="s1">exog = np.ones(nobs)</span>

    <span class="s1">mod = varmax.VARMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">exog=exog</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'n'</span><span class="s1">)</span>
    <span class="s1">res = mod.smooth(np.r_[[</span><span class="s5">0</span><span class="s1">] * </span><span class="s5">4</span><span class="s2">, </span><span class="s5">2.0</span><span class="s2">, </span><span class="s5">2.0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">])</span>

    <span class="s4"># 1-step-ahead, valid</span>
    <span class="s1">exog_fcast_scalar = </span><span class="s5">1.</span>
    <span class="s1">exog_fcast_1dim = np.ones(</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">exog_fcast_2dim = np.ones((</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span>

    <span class="s1">assert_allclose(res.forecast(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">exog=exog_fcast_scalar)</span><span class="s2">, </span><span class="s5">2.</span><span class="s1">)</span>
    <span class="s1">assert_allclose(res.forecast(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">exog=exog_fcast_1dim)</span><span class="s2">, </span><span class="s5">2.</span><span class="s1">)</span>
    <span class="s1">assert_allclose(res.forecast(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">exog=exog_fcast_2dim)</span><span class="s2">, </span><span class="s5">2.</span><span class="s1">)</span>

    <span class="s4"># h-steps-ahead, valid</span>
    <span class="s1">h = </span><span class="s5">10</span>
    <span class="s1">exog_fcast_1dim = np.ones(h)</span>
    <span class="s1">exog_fcast_2dim = np.ones((h</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span>

    <span class="s1">assert_allclose(res.forecast(h</span><span class="s2">, </span><span class="s1">exog=exog_fcast_1dim)</span><span class="s2">, </span><span class="s5">2.</span><span class="s1">)</span>
    <span class="s1">assert_allclose(res.forecast(h</span><span class="s2">, </span><span class="s1">exog=exog_fcast_2dim)</span><span class="s2">, </span><span class="s5">2.</span><span class="s1">)</span>

    <span class="s4"># h-steps-ahead, invalid</span>
    <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">res.forecast</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">exog=</span><span class="s5">1.</span><span class="s1">)</span>
    <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">res.forecast</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">exog=[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">])</span>
    <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">res.forecast</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">exog=np.ones((h</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)))</span>


<span class="s2">def </span><span class="s1">check_equivalent_models(mod</span><span class="s2">, </span><span class="s1">mod2):</span>
    <span class="s1">attrs = [</span>
        <span class="s3">'order'</span><span class="s2">, </span><span class="s3">'trend'</span><span class="s2">, </span><span class="s3">'error_cov_type'</span><span class="s2">, </span><span class="s3">'measurement_error'</span><span class="s2">,</span>
        <span class="s3">'enforce_stationarity'</span><span class="s2">, </span><span class="s3">'enforce_invertibility'</span><span class="s2">, </span><span class="s3">'k_params'</span><span class="s1">]</span>

    <span class="s1">ssm_attrs = [</span>
        <span class="s3">'nobs'</span><span class="s2">, </span><span class="s3">'k_endog'</span><span class="s2">, </span><span class="s3">'k_states'</span><span class="s2">, </span><span class="s3">'k_posdef'</span><span class="s2">, </span><span class="s3">'obs_intercept'</span><span class="s2">, </span><span class="s3">'design'</span><span class="s2">,</span>
        <span class="s3">'obs_cov'</span><span class="s2">, </span><span class="s3">'state_intercept'</span><span class="s2">, </span><span class="s3">'transition'</span><span class="s2">, </span><span class="s3">'selection'</span><span class="s2">, </span><span class="s3">'state_cov'</span><span class="s1">]</span>

    <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">attrs:</span>
        <span class="s1">assert_equal(getattr(mod2</span><span class="s2">, </span><span class="s1">attr)</span><span class="s2">, </span><span class="s1">getattr(mod</span><span class="s2">, </span><span class="s1">attr))</span>

    <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">ssm_attrs:</span>
        <span class="s1">assert_equal(getattr(mod2.ssm</span><span class="s2">, </span><span class="s1">attr)</span><span class="s2">, </span><span class="s1">getattr(mod.ssm</span><span class="s2">, </span><span class="s1">attr))</span>

    <span class="s1">assert_equal(mod2._get_init_kwds()</span><span class="s2">, </span><span class="s1">mod._get_init_kwds())</span>


<span class="s2">def </span><span class="s1">test_recreate_model():</span>
    <span class="s1">nobs = </span><span class="s5">100</span>
    <span class="s1">endog = np.ones((nobs</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)) * </span><span class="s5">2.0</span>
    <span class="s1">exog = np.ones(nobs)</span>

    <span class="s1">orders = [(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)]</span>
    <span class="s1">trends = [</span><span class="s3">'t'</span><span class="s2">, </span><span class="s3">'n'</span><span class="s1">]</span>
    <span class="s1">error_cov_types = [</span><span class="s3">'diagonal'</span><span class="s2">, </span><span class="s3">'unstructured'</span><span class="s1">]</span>
    <span class="s1">measurement_errors = [</span><span class="s2">False, True</span><span class="s1">]</span>
    <span class="s1">enforce_stationarities = [</span><span class="s2">False, True</span><span class="s1">]</span>
    <span class="s1">enforce_invertibilities = [</span><span class="s2">False, True</span><span class="s1">]</span>

    <span class="s2">import </span><span class="s1">itertools</span>
    <span class="s1">names = [</span><span class="s3">'order'</span><span class="s2">, </span><span class="s3">'trend'</span><span class="s2">, </span><span class="s3">'error_cov_type'</span><span class="s2">, </span><span class="s3">'measurement_error'</span><span class="s2">,</span>
             <span class="s3">'enforce_stationarity'</span><span class="s2">, </span><span class="s3">'enforce_invertibility'</span><span class="s1">]</span>
    <span class="s2">for </span><span class="s1">element </span><span class="s2">in </span><span class="s1">itertools.product(orders</span><span class="s2">, </span><span class="s1">trends</span><span class="s2">, </span><span class="s1">error_cov_types</span><span class="s2">,</span>
                                     <span class="s1">measurement_errors</span><span class="s2">,</span>
                                     <span class="s1">enforce_stationarities</span><span class="s2">,</span>
                                     <span class="s1">enforce_invertibilities):</span>
        <span class="s1">kwargs = dict(zip(names</span><span class="s2">, </span><span class="s1">element))</span>

        <span class="s2">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s2">False</span><span class="s1">):</span>
            <span class="s1">warnings.simplefilter(</span><span class="s3">'ignore'</span><span class="s1">)</span>
            <span class="s1">mod = varmax.VARMAX(endog</span><span class="s2">, </span><span class="s1">exog=exog</span><span class="s2">, </span><span class="s1">**kwargs)</span>
            <span class="s1">mod2 = varmax.VARMAX(endog</span><span class="s2">, </span><span class="s1">exog=exog</span><span class="s2">, </span><span class="s1">**mod._get_init_kwds())</span>
        <span class="s1">check_equivalent_models(mod</span><span class="s2">, </span><span class="s1">mod2)</span>


<span class="s2">def </span><span class="s1">test_append_results():</span>
    <span class="s1">endog = np.arange(</span><span class="s5">200</span><span class="s1">).reshape(</span><span class="s5">100</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>
    <span class="s1">exog = np.ones(</span><span class="s5">100</span><span class="s1">)</span>
    <span class="s1">params = [</span><span class="s5">0.1</span><span class="s2">, </span><span class="s5">0.2</span><span class="s2">,</span>
              <span class="s5">0.5</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.1</span><span class="s2">, </span><span class="s5">0.0</span><span class="s2">, </span><span class="s5">0.2</span><span class="s2">,</span>
              <span class="s5">1.</span><span class="s2">, </span><span class="s5">2.</span><span class="s2">,</span>
              <span class="s5">1.</span><span class="s2">, </span><span class="s5">0.</span><span class="s2">, </span><span class="s5">1.</span><span class="s1">]</span>

    <span class="s1">mod1 = varmax.VARMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'t'</span><span class="s2">, </span><span class="s1">exog=exog)</span>
    <span class="s1">res1 = mod1.smooth(params)</span>

    <span class="s1">mod2 = varmax.VARMAX(endog[:</span><span class="s5">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'t'</span><span class="s2">, </span><span class="s1">exog=exog[:</span><span class="s5">50</span><span class="s1">])</span>
    <span class="s1">res2 = mod2.smooth(params)</span>
    <span class="s1">res3 = res2.append(endog[</span><span class="s5">50</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">exog=exog[</span><span class="s5">50</span><span class="s1">:])</span>

    <span class="s1">assert_equal(res1.specification</span><span class="s2">, </span><span class="s1">res3.specification)</span>

    <span class="s1">assert_allclose(res3.cov_params_default</span><span class="s2">, </span><span class="s1">res2.cov_params_default)</span>
    <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'nobs'</span><span class="s2">, </span><span class="s3">'llf'</span><span class="s2">, </span><span class="s3">'llf_obs'</span><span class="s2">, </span><span class="s3">'loglikelihood_burn'</span><span class="s1">]:</span>
        <span class="s1">assert_equal(getattr(res3</span><span class="s2">, </span><span class="s1">attr)</span><span class="s2">, </span><span class="s1">getattr(res1</span><span class="s2">, </span><span class="s1">attr))</span>

    <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">[</span>
            <span class="s3">'filtered_state'</span><span class="s2">, </span><span class="s3">'filtered_state_cov'</span><span class="s2">, </span><span class="s3">'predicted_state'</span><span class="s2">,</span>
            <span class="s3">'predicted_state_cov'</span><span class="s2">, </span><span class="s3">'forecasts'</span><span class="s2">, </span><span class="s3">'forecasts_error'</span><span class="s2">,</span>
            <span class="s3">'forecasts_error_cov'</span><span class="s2">, </span><span class="s3">'standardized_forecasts_error'</span><span class="s2">,</span>
            <span class="s3">'forecasts_error_diffuse_cov'</span><span class="s2">, </span><span class="s3">'predicted_diffuse_state_cov'</span><span class="s2">,</span>
            <span class="s3">'scaled_smoothed_estimator'</span><span class="s2">,</span>
            <span class="s3">'scaled_smoothed_estimator_cov'</span><span class="s2">, </span><span class="s3">'smoothing_error'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state_cov'</span><span class="s2">, </span><span class="s3">'smoothed_state_autocov'</span><span class="s2">,</span>
            <span class="s3">'smoothed_measurement_disturbance'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state_disturbance'</span><span class="s2">,</span>
            <span class="s3">'smoothed_measurement_disturbance_cov'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state_disturbance_cov'</span><span class="s1">]:</span>
        <span class="s1">assert_equal(getattr(res3</span><span class="s2">, </span><span class="s1">attr)</span><span class="s2">, </span><span class="s1">getattr(res1</span><span class="s2">, </span><span class="s1">attr))</span>

    <span class="s1">assert_allclose(res3.forecast(</span><span class="s5">10</span><span class="s2">, </span><span class="s1">exog=np.ones(</span><span class="s5">10</span><span class="s1">))</span><span class="s2">,</span>
                    <span class="s1">res1.forecast(</span><span class="s5">10</span><span class="s2">, </span><span class="s1">exog=np.ones(</span><span class="s5">10</span><span class="s1">)))</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'trend'</span><span class="s2">, </span><span class="s1">[</span><span class="s3">'n'</span><span class="s2">, </span><span class="s3">'c'</span><span class="s2">, </span><span class="s3">'ct'</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'forecast'</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_extend_results(trend</span><span class="s2">, </span><span class="s1">forecast):</span>
    <span class="s1">endog = np.arange(</span><span class="s5">200</span><span class="s1">).reshape(</span><span class="s5">100</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>
    <span class="s1">trend_params = []</span>
    <span class="s2">if </span><span class="s1">trend == </span><span class="s3">'c'</span><span class="s1">:</span>
        <span class="s1">trend_params = [</span><span class="s5">0.1</span><span class="s2">, </span><span class="s5">0.2</span><span class="s1">]</span>
    <span class="s2">if </span><span class="s1">trend == </span><span class="s3">'ct'</span><span class="s1">:</span>
        <span class="s1">trend_params = [</span><span class="s5">0.1</span><span class="s2">, </span><span class="s5">0.2</span><span class="s2">, </span><span class="s5">1.</span><span class="s2">, </span><span class="s5">2.</span><span class="s1">]</span>
    <span class="s1">params = np.r_[trend_params</span><span class="s2">,</span>
                   <span class="s5">0.5</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.1</span><span class="s2">, </span><span class="s5">0.0</span><span class="s2">, </span><span class="s5">0.2</span><span class="s2">,</span>
                   <span class="s5">1.</span><span class="s2">, </span><span class="s5">0.</span><span class="s2">, </span><span class="s5">1.</span><span class="s1">]</span>

    <span class="s1">mod1 = varmax.VARMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=trend)</span>
    <span class="s1">res1 = mod1.smooth(params)</span>
    <span class="s2">if </span><span class="s1">forecast:</span>
        <span class="s4"># Call `forecast` to trigger the _set_final_exog and</span>
        <span class="s4"># _set_final_predicted_state context managers</span>
        <span class="s1">res1.forecast()</span>

    <span class="s1">mod2 = mod1.clone(endog[:</span><span class="s5">50</span><span class="s1">])</span>
    <span class="s1">res2 = mod2.smooth(params)</span>
    <span class="s2">if </span><span class="s1">forecast:</span>
        <span class="s4"># Call `forecast` to trigger the _set_final_exog and</span>
        <span class="s4"># _set_final_predicted_state context managers</span>
        <span class="s1">res2.forecast()</span>
    <span class="s1">res3 = res2.extend(endog[</span><span class="s5">50</span><span class="s1">:])</span>

    <span class="s1">assert_allclose(res3.llf_obs</span><span class="s2">, </span><span class="s1">res1.llf_obs[</span><span class="s5">50</span><span class="s1">:])</span>

    <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">[</span>
            <span class="s3">'filtered_state'</span><span class="s2">, </span><span class="s3">'filtered_state_cov'</span><span class="s2">, </span><span class="s3">'predicted_state'</span><span class="s2">,</span>
            <span class="s3">'predicted_state_cov'</span><span class="s2">, </span><span class="s3">'forecasts'</span><span class="s2">, </span><span class="s3">'forecasts_error'</span><span class="s2">,</span>
            <span class="s3">'forecasts_error_cov'</span><span class="s2">, </span><span class="s3">'standardized_forecasts_error'</span><span class="s2">,</span>
            <span class="s3">'scaled_smoothed_estimator'</span><span class="s2">,</span>
            <span class="s3">'scaled_smoothed_estimator_cov'</span><span class="s2">, </span><span class="s3">'smoothing_error'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state_cov'</span><span class="s2">, </span><span class="s3">'smoothed_state_autocov'</span><span class="s2">,</span>
            <span class="s3">'smoothed_measurement_disturbance'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state_disturbance'</span><span class="s2">,</span>
            <span class="s3">'smoothed_measurement_disturbance_cov'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state_disturbance_cov'</span><span class="s1">]:</span>
        <span class="s1">desired = getattr(res1</span><span class="s2">, </span><span class="s1">attr)</span>
        <span class="s2">if </span><span class="s1">desired </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">desired = desired[...</span><span class="s2">, </span><span class="s5">50</span><span class="s1">:]</span>
        <span class="s1">assert_allclose(getattr(res3</span><span class="s2">, </span><span class="s1">attr)</span><span class="s2">, </span><span class="s1">desired</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-12</span><span class="s1">)</span>

    <span class="s1">assert_allclose(res3.forecast(</span><span class="s5">10</span><span class="s1">)</span><span class="s2">, </span><span class="s1">res1.forecast(</span><span class="s5">10</span><span class="s1">))</span>


<span class="s2">def </span><span class="s1">test_extend_results_exog():</span>
    <span class="s1">endog = np.arange(</span><span class="s5">200</span><span class="s1">).reshape(</span><span class="s5">100</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>
    <span class="s1">exog = np.ones(</span><span class="s5">100</span><span class="s1">)</span>
    <span class="s1">params = [</span><span class="s5">0.1</span><span class="s2">, </span><span class="s5">0.2</span><span class="s2">,</span>
              <span class="s5">0.5</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.1</span><span class="s2">, </span><span class="s5">0.0</span><span class="s2">, </span><span class="s5">0.2</span><span class="s2">,</span>
              <span class="s5">1.</span><span class="s2">, </span><span class="s5">2.</span><span class="s2">,</span>
              <span class="s5">1.</span><span class="s2">, </span><span class="s5">0.</span><span class="s2">, </span><span class="s5">1.</span><span class="s1">]</span>

    <span class="s1">mod1 = varmax.VARMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'t'</span><span class="s2">, </span><span class="s1">exog=exog)</span>
    <span class="s1">res1 = mod1.smooth(params)</span>

    <span class="s1">mod2 = varmax.VARMAX(endog[:</span><span class="s5">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'t'</span><span class="s2">, </span><span class="s1">exog=exog[:</span><span class="s5">50</span><span class="s1">])</span>
    <span class="s1">res2 = mod2.smooth(params)</span>
    <span class="s1">res3 = res2.extend(endog[</span><span class="s5">50</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">exog=exog[</span><span class="s5">50</span><span class="s1">:])</span>

    <span class="s1">assert_allclose(res3.llf_obs</span><span class="s2">, </span><span class="s1">res1.llf_obs[</span><span class="s5">50</span><span class="s1">:])</span>

    <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">[</span>
            <span class="s3">'filtered_state'</span><span class="s2">, </span><span class="s3">'filtered_state_cov'</span><span class="s2">, </span><span class="s3">'predicted_state'</span><span class="s2">,</span>
            <span class="s3">'predicted_state_cov'</span><span class="s2">, </span><span class="s3">'forecasts'</span><span class="s2">, </span><span class="s3">'forecasts_error'</span><span class="s2">,</span>
            <span class="s3">'forecasts_error_cov'</span><span class="s2">, </span><span class="s3">'standardized_forecasts_error'</span><span class="s2">,</span>
            <span class="s3">'forecasts_error_diffuse_cov'</span><span class="s2">, </span><span class="s3">'predicted_diffuse_state_cov'</span><span class="s2">,</span>
            <span class="s3">'scaled_smoothed_estimator'</span><span class="s2">,</span>
            <span class="s3">'scaled_smoothed_estimator_cov'</span><span class="s2">, </span><span class="s3">'smoothing_error'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state_cov'</span><span class="s2">, </span><span class="s3">'smoothed_state_autocov'</span><span class="s2">,</span>
            <span class="s3">'smoothed_measurement_disturbance'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state_disturbance'</span><span class="s2">,</span>
            <span class="s3">'smoothed_measurement_disturbance_cov'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state_disturbance_cov'</span><span class="s1">]:</span>
        <span class="s1">desired = getattr(res1</span><span class="s2">, </span><span class="s1">attr)</span>
        <span class="s2">if </span><span class="s1">desired </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">desired = desired[...</span><span class="s2">, </span><span class="s5">50</span><span class="s1">:]</span>
        <span class="s1">assert_equal(getattr(res3</span><span class="s2">, </span><span class="s1">attr)</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s1">assert_allclose(res3.forecast(</span><span class="s5">10</span><span class="s2">, </span><span class="s1">exog=np.ones(</span><span class="s5">10</span><span class="s1">))</span><span class="s2">,</span>
                    <span class="s1">res1.forecast(</span><span class="s5">10</span><span class="s2">, </span><span class="s1">exog=np.ones(</span><span class="s5">10</span><span class="s1">)))</span>


<span class="s2">def </span><span class="s1">test_apply_results():</span>
    <span class="s1">endog = np.arange(</span><span class="s5">200</span><span class="s1">).reshape(</span><span class="s5">100</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>
    <span class="s1">exog = np.ones(</span><span class="s5">100</span><span class="s1">)</span>
    <span class="s1">params = [</span><span class="s5">0.1</span><span class="s2">, </span><span class="s5">0.2</span><span class="s2">,</span>
              <span class="s5">0.5</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.1</span><span class="s2">, </span><span class="s5">0.0</span><span class="s2">, </span><span class="s5">0.2</span><span class="s2">,</span>
              <span class="s5">1.</span><span class="s2">, </span><span class="s5">2.</span><span class="s2">,</span>
              <span class="s5">1.</span><span class="s2">, </span><span class="s5">0.</span><span class="s2">, </span><span class="s5">1.</span><span class="s1">]</span>

    <span class="s1">mod1 = varmax.VARMAX(endog[:</span><span class="s5">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'t'</span><span class="s2">, </span><span class="s1">exog=exog[:</span><span class="s5">50</span><span class="s1">])</span>
    <span class="s1">res1 = mod1.smooth(params)</span>

    <span class="s1">mod2 = varmax.VARMAX(endog[</span><span class="s5">50</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'t'</span><span class="s2">, </span><span class="s1">exog=exog[</span><span class="s5">50</span><span class="s1">:])</span>
    <span class="s1">res2 = mod2.smooth(params)</span>

    <span class="s1">res3 = res2.apply(endog[:</span><span class="s5">50</span><span class="s1">]</span><span class="s2">, </span><span class="s1">exog=exog[:</span><span class="s5">50</span><span class="s1">])</span>

    <span class="s1">assert_equal(res1.specification</span><span class="s2">, </span><span class="s1">res3.specification)</span>

    <span class="s1">assert_allclose(res3.cov_params_default</span><span class="s2">, </span><span class="s1">res2.cov_params_default)</span>
    <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'nobs'</span><span class="s2">, </span><span class="s3">'llf'</span><span class="s2">, </span><span class="s3">'llf_obs'</span><span class="s2">, </span><span class="s3">'loglikelihood_burn'</span><span class="s1">]:</span>
        <span class="s1">assert_equal(getattr(res3</span><span class="s2">, </span><span class="s1">attr)</span><span class="s2">, </span><span class="s1">getattr(res1</span><span class="s2">, </span><span class="s1">attr))</span>

    <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">[</span>
            <span class="s3">'filtered_state'</span><span class="s2">, </span><span class="s3">'filtered_state_cov'</span><span class="s2">, </span><span class="s3">'predicted_state'</span><span class="s2">,</span>
            <span class="s3">'predicted_state_cov'</span><span class="s2">, </span><span class="s3">'forecasts'</span><span class="s2">, </span><span class="s3">'forecasts_error'</span><span class="s2">,</span>
            <span class="s3">'forecasts_error_cov'</span><span class="s2">, </span><span class="s3">'standardized_forecasts_error'</span><span class="s2">,</span>
            <span class="s3">'forecasts_error_diffuse_cov'</span><span class="s2">, </span><span class="s3">'predicted_diffuse_state_cov'</span><span class="s2">,</span>
            <span class="s3">'scaled_smoothed_estimator'</span><span class="s2">,</span>
            <span class="s3">'scaled_smoothed_estimator_cov'</span><span class="s2">, </span><span class="s3">'smoothing_error'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state_cov'</span><span class="s2">, </span><span class="s3">'smoothed_state_autocov'</span><span class="s2">,</span>
            <span class="s3">'smoothed_measurement_disturbance'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state_disturbance'</span><span class="s2">,</span>
            <span class="s3">'smoothed_measurement_disturbance_cov'</span><span class="s2">,</span>
            <span class="s3">'smoothed_state_disturbance_cov'</span><span class="s1">]:</span>
        <span class="s1">assert_equal(getattr(res3</span><span class="s2">, </span><span class="s1">attr)</span><span class="s2">, </span><span class="s1">getattr(res1</span><span class="s2">, </span><span class="s1">attr))</span>

    <span class="s1">assert_allclose(res3.forecast(</span><span class="s5">10</span><span class="s2">, </span><span class="s1">exog=np.ones(</span><span class="s5">10</span><span class="s1">))</span><span class="s2">,</span>
                    <span class="s1">res1.forecast(</span><span class="s5">10</span><span class="s2">, </span><span class="s1">exog=np.ones(</span><span class="s5">10</span><span class="s1">)))</span>


<span class="s2">def </span><span class="s1">test_vma1_exog():</span>
    <span class="s4"># Test the VMAX(1) case against univariate MAX(1) models</span>
    <span class="s1">dta = pd.DataFrame(</span>
        <span class="s1">results_varmax.lutkepohl_data</span><span class="s2">, </span><span class="s1">columns=[</span><span class="s3">'inv'</span><span class="s2">, </span><span class="s3">'inc'</span><span class="s2">, </span><span class="s3">'consump'</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">index=pd.date_range(</span><span class="s3">'1960-01-01'</span><span class="s2">, </span><span class="s3">'1982-10-01'</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">'QS'</span><span class="s1">))</span>
    <span class="s1">dta = np.log(dta).diff().iloc[</span><span class="s5">1</span><span class="s1">:]</span>

    <span class="s1">endog = dta.iloc[:</span><span class="s2">, </span><span class="s1">:</span><span class="s5">2</span><span class="s1">]</span>
    <span class="s1">exog = dta.iloc[:</span><span class="s2">, </span><span class="s5">2</span><span class="s1">]</span>

    <span class="s1">ma_params1 = [-</span><span class="s5">0.01</span><span class="s2">, </span><span class="s5">1.4</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.3</span><span class="s2">, </span><span class="s5">0.002</span><span class="s1">]</span>
    <span class="s1">ma_params2 = [</span><span class="s5">0.004</span><span class="s2">, </span><span class="s5">0.8</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">0.0001</span><span class="s1">]</span>

    <span class="s1">vma_params = [ma_params1[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">ma_params2[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                  <span class="s1">ma_params1[</span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s5">0</span><span class="s2">,</span>
                  <span class="s5">0</span><span class="s2">, </span><span class="s1">ma_params2[</span><span class="s5">2</span><span class="s1">]</span><span class="s2">,</span>
                  <span class="s1">ma_params1[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">ma_params2[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">,</span>
                  <span class="s1">ma_params1[</span><span class="s5">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">ma_params2[</span><span class="s5">3</span><span class="s1">]]</span>

    <span class="s4"># Joint VMA model</span>
    <span class="s1">mod_vma = varmax.VARMAX(endog</span><span class="s2">, </span><span class="s1">exog=exog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
                            <span class="s1">error_cov_type=</span><span class="s3">'diagonal'</span><span class="s1">)</span>
    <span class="s1">mod_vma.ssm.initialize_diffuse()</span>
    <span class="s1">res_mva = mod_vma.smooth(vma_params)</span>

    <span class="s4"># Smoke test that start_params does not raise an error</span>
    <span class="s1">sp = mod_vma.start_params</span>
    <span class="s1">assert_equal(len(sp)</span><span class="s2">, </span><span class="s1">len(mod_vma.param_names))</span>

    <span class="s4"># Univariate MA models</span>
    <span class="s1">mod_ma1 = sarimax.SARIMAX(endog.iloc[:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">exog=exog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">trend=</span><span class="s3">'c'</span><span class="s1">)</span>
    <span class="s1">mod_ma1.ssm.initialize_diffuse()</span>
    <span class="s1">mod_ma2 = sarimax.SARIMAX(endog.iloc[:</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">exog=exog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">trend=</span><span class="s3">'c'</span><span class="s1">)</span>
    <span class="s1">mod_ma2.ssm.initialize_diffuse()</span>
    <span class="s1">res_ma1 = mod_ma1.smooth(ma_params1)</span>
    <span class="s1">res_ma2 = mod_ma2.smooth(ma_params2)</span>

    <span class="s4"># Have to ignore first 2 observations due to differences in initialization</span>
    <span class="s1">assert_allclose(res_mva.llf_obs[</span><span class="s5">2</span><span class="s1">:]</span><span class="s2">,</span>
                    <span class="s1">(res_ma1.llf_obs + res_ma2.llf_obs)[</span><span class="s5">2</span><span class="s1">:])</span>


<span class="s2">def </span><span class="s1">test_param_names_trend():</span>
    <span class="s1">endog = np.zeros((</span><span class="s5">3</span><span class="s2">, </span><span class="s5">2</span><span class="s1">))</span>
    <span class="s1">base_names = [</span><span class="s3">'L1.y1.y1'</span><span class="s2">, </span><span class="s3">'L1.y2.y1'</span><span class="s2">, </span><span class="s3">'L1.y1.y2'</span><span class="s2">, </span><span class="s3">'L1.y2.y2'</span><span class="s2">,</span>
                  <span class="s3">'sqrt.var.y1'</span><span class="s2">, </span><span class="s3">'sqrt.cov.y1.y2'</span><span class="s2">, </span><span class="s3">'sqrt.var.y2'</span><span class="s1">]</span>
    <span class="s1">base_params = [</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0.4</span><span class="s2">, </span><span class="s5">1.0</span><span class="s2">, </span><span class="s5">0.0</span><span class="s2">, </span><span class="s5">1.0</span><span class="s1">]</span>

    <span class="s4"># No trend</span>
    <span class="s1">mod = varmax.VARMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'n'</span><span class="s1">)</span>
    <span class="s1">desired = base_names</span>
    <span class="s1">assert_equal(mod.param_names</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s4"># Intercept</span>
    <span class="s1">mod = varmax.VARMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=[</span><span class="s5">1</span><span class="s1">])</span>
    <span class="s1">desired = [</span><span class="s3">'intercept.y1'</span><span class="s2">, </span><span class="s3">'intercept.y2'</span><span class="s1">] + base_names</span>
    <span class="s1">assert_equal(mod.param_names</span><span class="s2">, </span><span class="s1">desired)</span>
    <span class="s1">mod.update([</span><span class="s5">1.2</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.5</span><span class="s1">] + base_params)</span>
    <span class="s1">assert_allclose(mod[</span><span class="s3">'state_intercept'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1.2</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.5</span><span class="s1">])</span>

    <span class="s4"># Intercept + drift</span>
    <span class="s1">mod = varmax.VARMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">])</span>
    <span class="s1">desired = ([</span><span class="s3">'intercept.y1'</span><span class="s2">, </span><span class="s3">'drift.y1'</span><span class="s2">,</span>
                <span class="s3">'intercept.y2'</span><span class="s2">, </span><span class="s3">'drift.y2'</span><span class="s1">] + base_names)</span>
    <span class="s1">assert_equal(mod.param_names</span><span class="s2">, </span><span class="s1">desired)</span>
    <span class="s1">mod.update([</span><span class="s5">1.2</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] + base_params)</span>
    <span class="s1">assert_allclose(mod[</span><span class="s3">'state_intercept'</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">1.2</span><span class="s1">)</span>
    <span class="s1">assert_allclose(mod[</span><span class="s3">'state_intercept'</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.5</span><span class="s1">)</span>
    <span class="s1">mod.update([</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1.1</span><span class="s1">] + base_params)</span>
    <span class="s1">assert_allclose(mod[</span><span class="s3">'state_intercept'</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.arange(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">5</span><span class="s1">))</span>
    <span class="s1">assert_allclose(mod[</span><span class="s3">'state_intercept'</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s5">1.1 </span><span class="s1">* np.arange(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">5</span><span class="s1">))</span>
    <span class="s1">mod.update([</span><span class="s5">1.2</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">1.1</span><span class="s1">] + base_params)</span>
    <span class="s1">assert_allclose(mod[</span><span class="s3">'state_intercept'</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">1.2 </span><span class="s1">+ np.arange(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">5</span><span class="s1">))</span>
    <span class="s1">assert_allclose(mod[</span><span class="s3">'state_intercept'</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.5 </span><span class="s1">+ </span><span class="s5">1.1 </span><span class="s1">* np.arange(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">5</span><span class="s1">))</span>

    <span class="s4"># Drift only</span>
    <span class="s1">mod = varmax.VARMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">])</span>
    <span class="s1">desired = [</span><span class="s3">'drift.y1'</span><span class="s2">, </span><span class="s3">'drift.y2'</span><span class="s1">] + base_names</span>
    <span class="s1">assert_equal(mod.param_names</span><span class="s2">, </span><span class="s1">desired)</span>
    <span class="s1">mod.update([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1.1</span><span class="s1">] + base_params)</span>
    <span class="s1">assert_allclose(mod[</span><span class="s3">'state_intercept'</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.arange(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">5</span><span class="s1">))</span>
    <span class="s1">assert_allclose(mod[</span><span class="s3">'state_intercept'</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s5">1.1 </span><span class="s1">* np.arange(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">5</span><span class="s1">))</span>

    <span class="s4"># Intercept + third order</span>
    <span class="s1">mod = varmax.VARMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">])</span>
    <span class="s1">desired = ([</span><span class="s3">'intercept.y1'</span><span class="s2">, </span><span class="s3">'trend.2.y1'</span><span class="s2">,</span>
                <span class="s3">'intercept.y2'</span><span class="s2">, </span><span class="s3">'trend.2.y2'</span><span class="s1">] + base_names)</span>
    <span class="s1">assert_equal(mod.param_names</span><span class="s2">, </span><span class="s1">desired)</span>
    <span class="s1">mod.update([</span><span class="s5">1.2</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] + base_params)</span>
    <span class="s1">assert_allclose(mod[</span><span class="s3">'state_intercept'</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">1.2</span><span class="s1">)</span>
    <span class="s1">assert_allclose(mod[</span><span class="s3">'state_intercept'</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.5</span><span class="s1">)</span>
    <span class="s1">mod.update([</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1.1</span><span class="s1">] + base_params)</span>
    <span class="s1">assert_allclose(mod[</span><span class="s3">'state_intercept'</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.arange(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">5</span><span class="s1">)**</span><span class="s5">2</span><span class="s1">)</span>
    <span class="s1">assert_allclose(mod[</span><span class="s3">'state_intercept'</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s5">1.1 </span><span class="s1">* np.arange(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">5</span><span class="s1">)**</span><span class="s5">2</span><span class="s1">)</span>
    <span class="s1">mod.update([</span><span class="s5">1.2</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">1.1</span><span class="s1">] + base_params)</span>
    <span class="s1">assert_allclose(mod[</span><span class="s3">'state_intercept'</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">1.2 </span><span class="s1">+ np.arange(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">5</span><span class="s1">)**</span><span class="s5">2</span><span class="s1">)</span>
    <span class="s1">assert_allclose(mod[</span><span class="s3">'state_intercept'</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.5 </span><span class="s1">+ </span><span class="s5">1.1 </span><span class="s1">* np.arange(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">5</span><span class="s1">)**</span><span class="s5">2</span><span class="s1">)</span>
</pre>
</body>
</html>