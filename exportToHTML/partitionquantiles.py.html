<html>
<head>
<title>partitionquantiles.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
partitionquantiles.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Determine new partition divisions using approximate percentiles. 
 
We use a custom algorithm to calculate approximate, evenly-distributed 
percentiles of arbitrarily-ordered data for any dtype in a distributed 
fashion with one pass over the data.  This is used to determine new 
partition divisions when changing the index of a dask.dataframe.  We claim 
no statistical guarantees, but we use a variety of heuristics to try to 
provide reliable, robust results that are &quot;good enough&quot; and can scale to 
large number of partitions. 
 
Our approach is similar to standard approaches such as t- and q-digest, 
GK, and sampling-based algorithms, which consist of three parts: 
 
1. **Summarize:** create summaries of subsets of data 
2. **Merge:** combine summaries to make a new summary 
3. **Compress:** periodically compress a summary into a smaller summary 
 
We summarize the data in each partition by calculating several percentiles. 
The value at each percentile is given a weight proportional to the length 
of the partition and the differences between the current percentile and 
the adjacent percentiles.  Merging summaries is simply a ``merge_sorted`` 
of the values and their weights, which we do with a reduction tree. 
 
Percentiles is a good choice for our case, because we are given a numpy 
array of the partition's data, and percentiles is a relatively cheap 
operation.  Moreover, percentiles are, by definition, much less 
susceptible to the underlying distribution of the data, so the weights 
given to each value--even across partitions--should be comparable. 
 
Let us describe this to a child of five.  We are given many small cubes 
(of equal size) with numbers on them.  Split these into many piles.  This 
is like the original data.  Let's sort and stack the cubes from one of the 
piles.  Next, we are given a bunch of unlabeled blocks of different sizes, 
and most are much larger than the the original cubes.  Stack these blocks 
until they're the same height as our first stack.  Let's write a number on 
each block of the new stack.  To do this, choose the number of the cube in 
the first stack that is located in the middle of an unlabeled block.  We 
are finished with this stack once all blocks have a number written on them. 
Repeat this for all the piles of cubes.  Finished already?  Great!  Now 
take all the stacks of the larger blocks you wrote on and throw them into 
a single pile.  We'll be sorting these blocks next, which may be easier if 
you carefully move the blocks over and organize... ah, nevermind--too late. 
Okay, sort and stack all the blocks from that amazing, disorganized pile 
you just made.  This will be very tall, so we had better stack it sideways 
on the floor like so.  This will also make it easier for us to split the 
stack into groups of approximately equal size, which is our final task... 
 
This, in a nutshell, is the algorithm we deploy.  The main difference 
is that we don't always assign a block the number at its median (ours 
fluctuates around the median).  The numbers at the edges of the final 
groups is what we use as divisions for repartitioning.  We also need 
the overall min and max, so we take the 0th and 100th percentile of 
each partition, and another sample near each edge so we don't give 
disproportionate weights to extreme values. 
 
Choosing appropriate percentiles to take in each partition is where things 
get interesting.  The data is arbitrarily ordered, which means it may be 
sorted, random, or follow some pathological distribution--who knows.  We 
hope all partitions are of similar length, but we ought to expect some 
variation in lengths.  The number of partitions may also be changing 
significantly, which could affect the optimal choice of percentiles.  For 
improved robustness, we use both evenly-distributed and random percentiles. 
If the number of partitions isn't changing, then the total number of 
percentiles across all partitions scales as ``npartitions**1.5``.  Although 
we only have a simple compression operation (step 3 above) that combines 
weights of equal values, a more sophisticated one could be added if needed, 
such as for extremely large ``npartitions`` or if we find we need to 
increase the sample size for each partition. 
 
&quot;&quot;&quot;</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">import </span><span class="s1">math</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pandas </span><span class="s2">as </span><span class="s1">pd</span>
<span class="s2">from </span><span class="s1">pandas.api.types </span><span class="s2">import </span><span class="s1">is_datetime64_dtype</span><span class="s2">, </span><span class="s1">is_integer_dtype</span>
<span class="s2">from </span><span class="s1">tlz </span><span class="s2">import </span><span class="s1">merge</span><span class="s2">, </span><span class="s1">merge_sorted</span><span class="s2">, </span><span class="s1">take</span>

<span class="s2">from </span><span class="s1">dask.base </span><span class="s2">import </span><span class="s1">tokenize</span>
<span class="s2">from </span><span class="s1">dask.dataframe.core </span><span class="s2">import </span><span class="s1">Series</span>
<span class="s2">from </span><span class="s1">dask.dataframe.dispatch </span><span class="s2">import </span><span class="s1">tolist_dispatch</span>
<span class="s2">from </span><span class="s1">dask.utils </span><span class="s2">import </span><span class="s1">is_cupy_type</span><span class="s2">, </span><span class="s1">random_state_data</span>


<span class="s2">def </span><span class="s1">sample_percentiles(num_old</span><span class="s2">, </span><span class="s1">num_new</span><span class="s2">, </span><span class="s1">chunk_length</span><span class="s2">, </span><span class="s1">upsample=</span><span class="s3">1.0</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Construct percentiles for a chunk for repartitioning. 
 
    Adapt the number of total percentiles calculated based on the number 
    of current and new partitions.  Returned percentiles include equally 
    spaced percentiles between [0, 100], and random percentiles.  See 
    detailed discussion below. 
 
    Parameters 
    ---------- 
    num_old: int 
        Number of partitions of the current object 
    num_new: int 
        Number of partitions of the new object 
    chunk_length: int 
        Number of rows of the partition 
    upsample : float 
        Multiplicative factor to increase the number of samples 
 
    Returns 
    ------- 
    qs : numpy.ndarray of sorted percentiles between 0, 100 
 
    Constructing ordered (i.e., not hashed) partitions is hard.  Calculating 
    approximate percentiles for generic objects in an out-of-core fashion is 
    also hard.  Fortunately, partition boundaries don't need to be perfect 
    in order for partitioning to be effective, so we strive for a &quot;good enough&quot; 
    method that can scale to many partitions and is reasonably well-behaved for 
    a wide variety of scenarios. 
 
    Two similar approaches come to mind: (1) take a subsample of every 
    partition, then find the best new partitions for the combined subsamples; 
    and (2) calculate equally-spaced percentiles on every partition (a 
    relatively cheap operation), then merge the results.  We do both, but 
    instead of random samples, we use random percentiles. 
 
    If the number of partitions isn't changing, then the ratio of fixed 
    percentiles to random percentiles is 2 to 1.  If repartitioning goes from 
    a very high number of partitions to a very low number of partitions, then 
    we use more random percentiles, because a stochastic approach will be more 
    stable to potential correlations in the data that may cause a few equally- 
    spaced partitions to under-sample the data. 
 
    The more partitions there are, then the more total percentiles will get 
    calculated across all partitions.  Squaring the number of partitions 
    approximately doubles the number of total percentiles calculated, so 
    num_total_percentiles ~ sqrt(num_partitions).  We assume each partition 
    is approximately the same length.  This should provide adequate resolution 
    and allow the number of partitions to scale. 
 
    For numeric data, one could instead use T-Digest for floats and Q-Digest 
    for ints to calculate approximate percentiles.  Our current method works 
    for any dtype. 
    &quot;&quot;&quot;</span>
    <span class="s4"># *waves hands*</span>
    <span class="s1">random_percentage = </span><span class="s3">1 </span><span class="s1">/ (</span><span class="s3">1 </span><span class="s1">+ (</span><span class="s3">4 </span><span class="s1">* num_new / num_old) ** </span><span class="s3">0.5</span><span class="s1">)</span>
    <span class="s1">num_percentiles = upsample * num_new * (num_old + </span><span class="s3">22</span><span class="s1">) ** </span><span class="s3">0.55 </span><span class="s1">/ num_old</span>
    <span class="s1">num_fixed = int(num_percentiles * (</span><span class="s3">1 </span><span class="s1">- random_percentage)) + </span><span class="s3">2</span>
    <span class="s1">num_random = int(num_percentiles * random_percentage) + </span><span class="s3">2</span>

    <span class="s2">if </span><span class="s1">num_fixed + num_random + </span><span class="s3">5 </span><span class="s1">&gt;= chunk_length:</span>
        <span class="s2">return </span><span class="s1">np.linspace(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">100</span><span class="s2">, </span><span class="s1">chunk_length + </span><span class="s3">1</span><span class="s1">)</span>

    <span class="s2">if not </span><span class="s1">isinstance(random_state</span><span class="s2">, </span><span class="s1">np.random.RandomState):</span>
        <span class="s1">random_state = np.random.RandomState(random_state)</span>

    <span class="s1">q_fixed = np.linspace(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">100</span><span class="s2">, </span><span class="s1">num_fixed)</span>
    <span class="s1">q_random = random_state.rand(num_random) * </span><span class="s3">100</span>
    <span class="s1">q_edges = [</span><span class="s3">60 </span><span class="s1">/ (num_fixed - </span><span class="s3">1</span><span class="s1">)</span><span class="s2">, </span><span class="s3">100 </span><span class="s1">- </span><span class="s3">60 </span><span class="s1">/ (num_fixed - </span><span class="s3">1</span><span class="s1">)]</span>
    <span class="s1">qs = np.concatenate([q_fixed</span><span class="s2">, </span><span class="s1">q_random</span><span class="s2">, </span><span class="s1">q_edges</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">100</span><span class="s1">]])</span>
    <span class="s1">qs.sort()</span>
    <span class="s4"># Make the divisions between percentiles a little more even</span>
    <span class="s1">qs = </span><span class="s3">0.5 </span><span class="s1">* (qs[:-</span><span class="s3">1</span><span class="s1">] + qs[</span><span class="s3">1</span><span class="s1">:])</span>
    <span class="s2">return </span><span class="s1">qs</span>


<span class="s2">def </span><span class="s1">tree_width(N</span><span class="s2">, </span><span class="s1">to_binary=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Generate tree width suitable for ``merge_sorted`` given N inputs 
 
    The larger N is, the more tasks are reduced in a single task. 
 
    In theory, this is designed so all tasks are of comparable effort. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">N &lt; </span><span class="s3">32</span><span class="s1">:</span>
        <span class="s1">group_size = </span><span class="s3">2</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">group_size = int(math.log(N))</span>
    <span class="s1">num_groups = N // group_size</span>
    <span class="s2">if </span><span class="s1">to_binary </span><span class="s2">or </span><span class="s1">num_groups &lt; </span><span class="s3">16</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s3">2 </span><span class="s1">** int(math.log(N / group_size</span><span class="s2">, </span><span class="s3">2</span><span class="s1">))</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">num_groups</span>


<span class="s2">def </span><span class="s1">tree_groups(N</span><span class="s2">, </span><span class="s1">num_groups):</span>
    <span class="s0">&quot;&quot;&quot;Split an integer N into evenly sized and spaced groups. 
 
    &gt;&gt;&gt; tree_groups(16, 6) 
    [3, 2, 3, 3, 2, 3] 
    &quot;&quot;&quot;</span>
    <span class="s4"># Bresenham, you so smooth!</span>
    <span class="s1">group_size = N // num_groups</span>
    <span class="s1">dx = num_groups</span>
    <span class="s1">dy = N - group_size * num_groups</span>
    <span class="s1">D = </span><span class="s3">2 </span><span class="s1">* dy - dx</span>
    <span class="s1">rv = []</span>
    <span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range(num_groups):</span>
        <span class="s2">if </span><span class="s1">D &lt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">rv.append(group_size)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">rv.append(group_size + </span><span class="s3">1</span><span class="s1">)</span>
            <span class="s1">D -= </span><span class="s3">2 </span><span class="s1">* dx</span>
        <span class="s1">D += </span><span class="s3">2 </span><span class="s1">* dy</span>
    <span class="s2">return </span><span class="s1">rv</span>


<span class="s2">def </span><span class="s1">create_merge_tree(func</span><span class="s2">, </span><span class="s1">keys</span><span class="s2">, </span><span class="s1">token</span><span class="s2">, </span><span class="s1">level=</span><span class="s3">0</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Create a task tree that merges all the keys with a reduction function. 
 
    Parameters 
    ---------- 
    func: callable 
        Reduction function that accepts a single list of values to reduce. 
    keys: iterable 
        Keys to reduce from the source dask graph. 
    token: object 
        Included in each key of the returned dict. 
    level: int, default 0 
        The token-level to begin with. 
 
    This creates a k-ary tree where k depends on the current level and is 
    greater the further away a node is from the root node.  This reduces the 
    total number of nodes (thereby reducing scheduler overhead), but still 
    has beneficial properties of trees. 
 
    For reasonable numbers of keys, N &lt; 1e5, the total number of nodes in the 
    tree is roughly ``N**0.78``.  For 1e5 &lt; N &lt; 2e5, is it roughly ``N**0.8``. 
    &quot;&quot;&quot;</span>
    <span class="s1">prev_width = len(keys)</span>
    <span class="s1">prev_keys = iter(keys)</span>
    <span class="s1">rv = {}</span>
    <span class="s2">while </span><span class="s1">prev_width &gt; </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s1">width = tree_width(prev_width)</span>
        <span class="s1">groups = tree_groups(prev_width</span><span class="s2">, </span><span class="s1">width)</span>
        <span class="s1">keys = [(token</span><span class="s2">, </span><span class="s1">level</span><span class="s2">, </span><span class="s1">i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(width)]</span>

        <span class="s2">for </span><span class="s1">num</span><span class="s2">, </span><span class="s1">key </span><span class="s2">in </span><span class="s1">zip(groups</span><span class="s2">, </span><span class="s1">keys):</span>
            <span class="s1">rv[key] = (func</span><span class="s2">, </span><span class="s1">list(take(num</span><span class="s2">, </span><span class="s1">prev_keys)))</span>

        <span class="s1">prev_width = width</span>
        <span class="s1">prev_keys = iter(keys)</span>
        <span class="s1">level += </span><span class="s3">1</span>
    <span class="s2">return </span><span class="s1">rv</span>


<span class="s2">def </span><span class="s1">percentiles_to_weights(qs</span><span class="s2">, </span><span class="s1">vals</span><span class="s2">, </span><span class="s1">length):</span>
    <span class="s0">&quot;&quot;&quot;Weigh percentile values by length and the difference between percentiles 
 
    &gt;&gt;&gt; percentiles = np.array([0., 25., 50., 90., 100.]) 
    &gt;&gt;&gt; values = np.array([2, 3, 5, 8, 13]) 
    &gt;&gt;&gt; length = 10 
    &gt;&gt;&gt; percentiles_to_weights(percentiles, values, length) 
    ([2, 3, 5, 8, 13], [125.0, 250.0, 325.0, 250.0, 50.0]) 
 
    The weight of the first element, ``2``, is determined by the difference 
    between the first and second percentiles, and then scaled by length: 
 
    &gt;&gt;&gt; 0.5 * length * (percentiles[1] - percentiles[0]) 
    125.0 
 
    The second weight uses the difference of percentiles on both sides, so 
    it will be twice the first weight if the percentiles are equally spaced: 
 
    &gt;&gt;&gt; 0.5 * length * (percentiles[2] - percentiles[0]) 
    250.0 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">length == </span><span class="s3">0</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">()</span>
    <span class="s1">diff = np.ediff1d(qs</span><span class="s2">, </span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s1">)</span>
    <span class="s1">weights = </span><span class="s3">0.5 </span><span class="s1">* length * (diff[</span><span class="s3">1</span><span class="s1">:] + diff[:-</span><span class="s3">1</span><span class="s1">])</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s4"># Try using tolist_dispatch first</span>
        <span class="s2">return </span><span class="s1">tolist_dispatch(vals)</span><span class="s2">, </span><span class="s1">weights.tolist()</span>
    <span class="s2">except </span><span class="s1">TypeError:</span>
        <span class="s2">return </span><span class="s1">vals.tolist()</span><span class="s2">, </span><span class="s1">weights.tolist()</span>


<span class="s2">def </span><span class="s1">merge_and_compress_summaries(vals_and_weights):</span>
    <span class="s0">&quot;&quot;&quot;Merge and sort percentile summaries that are already sorted. 
 
    Each item is a tuple like ``(vals, weights)`` where vals and weights 
    are lists.  We sort both by vals. 
 
    Equal values will be combined, their weights summed together. 
    &quot;&quot;&quot;</span>
    <span class="s1">vals_and_weights = [x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">vals_and_weights </span><span class="s2">if </span><span class="s1">x]</span>
    <span class="s2">if not </span><span class="s1">vals_and_weights:</span>
        <span class="s2">return </span><span class="s1">()</span>
    <span class="s1">it = merge_sorted(*[zip(x</span><span class="s2">, </span><span class="s1">y) </span><span class="s2">for </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y </span><span class="s2">in </span><span class="s1">vals_and_weights])</span>
    <span class="s1">vals = []</span>
    <span class="s1">weights = []</span>
    <span class="s1">vals_append = vals.append</span>
    <span class="s1">weights_append = weights.append</span>
    <span class="s1">val</span><span class="s2">, </span><span class="s1">weight = prev_val</span><span class="s2">, </span><span class="s1">prev_weight = next(it)</span>
    <span class="s2">for </span><span class="s1">val</span><span class="s2">, </span><span class="s1">weight </span><span class="s2">in </span><span class="s1">it:</span>
        <span class="s2">if </span><span class="s1">val == prev_val:</span>
            <span class="s1">prev_weight += weight</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">vals_append(prev_val)</span>
            <span class="s1">weights_append(prev_weight)</span>
            <span class="s1">prev_val</span><span class="s2">, </span><span class="s1">prev_weight = val</span><span class="s2">, </span><span class="s1">weight</span>
    <span class="s2">if </span><span class="s1">val == prev_val:</span>
        <span class="s1">vals_append(prev_val)</span>
        <span class="s1">weights_append(prev_weight)</span>
    <span class="s2">return </span><span class="s1">vals</span><span class="s2">, </span><span class="s1">weights</span>


<span class="s2">def </span><span class="s1">process_val_weights(vals_and_weights</span><span class="s2">, </span><span class="s1">npartitions</span><span class="s2">, </span><span class="s1">dtype_info):</span>
    <span class="s0">&quot;&quot;&quot;Calculate final approximate percentiles given weighted vals 
 
    ``vals_and_weights`` is assumed to be sorted.  We take a cumulative 
    sum of the weights, which makes them percentile-like (their scale is 
    [0, N] instead of [0, 100]).  Next we find the divisions to create 
    partitions of approximately equal size. 
 
    It is possible for adjacent values of the result to be the same.  Since 
    these determine the divisions of the new partitions, some partitions 
    may be empty.  This can happen if we under-sample the data, or if there 
    aren't enough unique values in the column.  Increasing ``upsample`` 
    keyword argument in ``df.set_index`` may help. 
    &quot;&quot;&quot;</span>
    <span class="s1">dtype</span><span class="s2">, </span><span class="s1">info = dtype_info</span>

    <span class="s2">if not </span><span class="s1">vals_and_weights:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">np.array(</span><span class="s2">None, </span><span class="s1">dtype=dtype)</span>
        <span class="s2">except </span><span class="s1">Exception:</span>
            <span class="s4"># dtype does not support None value so allow it to change</span>
            <span class="s2">return </span><span class="s1">np.array(</span><span class="s2">None, </span><span class="s1">dtype=np.float64)</span>

    <span class="s1">vals</span><span class="s2">, </span><span class="s1">weights = vals_and_weights</span>
    <span class="s1">vals = np.array(vals)</span>
    <span class="s1">weights = np.array(weights)</span>

    <span class="s4"># We want to create exactly `npartition` number of groups of `vals` that</span>
    <span class="s4"># are approximately the same weight and non-empty if possible.  We use a</span>
    <span class="s4"># simple approach (more accurate algorithms exist):</span>
    <span class="s4"># 1. Remove all the values with weights larger than the relative</span>
    <span class="s4">#    percentile width from consideration (these are `jumbo`s)</span>
    <span class="s4"># 2. Calculate percentiles with &quot;interpolation=left&quot; of percentile-like</span>
    <span class="s4">#    weights of the remaining values.  These are guaranteed to be unique.</span>
    <span class="s4"># 3. Concatenate the values from (1) and (2), sort, and return.</span>
    <span class="s4">#</span>
    <span class="s4"># We assume that all values are unique, which happens in the previous</span>
    <span class="s4"># step `merge_and_compress_summaries`.</span>

    <span class="s2">if </span><span class="s1">len(vals) == npartitions + </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s1">rv = vals</span>
    <span class="s2">elif </span><span class="s1">len(vals) &lt; npartitions + </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s4"># The data is under-sampled</span>
        <span class="s2">if </span><span class="s1">np.issubdtype(vals.dtype</span><span class="s2">, </span><span class="s1">np.number) </span><span class="s2">and not </span><span class="s1">isinstance(</span>
            <span class="s1">dtype</span><span class="s2">, </span><span class="s1">pd.CategoricalDtype</span>
        <span class="s1">):</span>
            <span class="s4"># Interpolate extra divisions</span>
            <span class="s1">q_weights = np.cumsum(weights)</span>
            <span class="s1">q_target = np.linspace(q_weights[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">q_weights[-</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">npartitions + </span><span class="s3">1</span><span class="s1">)</span>
            <span class="s1">rv = np.interp(q_target</span><span class="s2">, </span><span class="s1">q_weights</span><span class="s2">, </span><span class="s1">vals)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s4"># Distribute the empty partitions</span>
            <span class="s1">duplicated_index = np.linspace(</span>
                <span class="s3">0</span><span class="s2">, </span><span class="s1">len(vals) - </span><span class="s3">1</span><span class="s2">, </span><span class="s1">npartitions - len(vals) + </span><span class="s3">1</span><span class="s2">, </span><span class="s1">dtype=int</span>
            <span class="s1">)</span>
            <span class="s1">duplicated_vals = vals[duplicated_index]</span>
            <span class="s1">rv = np.concatenate([vals</span><span class="s2">, </span><span class="s1">duplicated_vals])</span>
            <span class="s1">rv.sort()</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">target_weight = weights.sum() / npartitions</span>
        <span class="s1">jumbo_mask = weights &gt;= target_weight</span>
        <span class="s1">jumbo_vals = vals[jumbo_mask]</span>

        <span class="s1">trimmed_vals = vals[~jumbo_mask]</span>
        <span class="s1">trimmed_weights = weights[~jumbo_mask]</span>
        <span class="s1">trimmed_npartitions = npartitions - len(jumbo_vals)</span>

        <span class="s4"># percentile-like, but scaled by weights</span>
        <span class="s1">q_weights = np.cumsum(trimmed_weights)</span>
        <span class="s1">q_target = np.linspace(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">q_weights[-</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">trimmed_npartitions + </span><span class="s3">1</span><span class="s1">)</span>

        <span class="s1">left = np.searchsorted(q_weights</span><span class="s2">, </span><span class="s1">q_target</span><span class="s2">, </span><span class="s1">side=</span><span class="s5">&quot;left&quot;</span><span class="s1">)</span>
        <span class="s1">right = np.searchsorted(q_weights</span><span class="s2">, </span><span class="s1">q_target</span><span class="s2">, </span><span class="s1">side=</span><span class="s5">&quot;right&quot;</span><span class="s1">) - </span><span class="s3">1</span>
        <span class="s4"># stay inbounds</span>
        <span class="s1">np.maximum(right</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s1">right)</span>
        <span class="s1">lower = np.minimum(left</span><span class="s2">, </span><span class="s1">right)</span>
        <span class="s1">trimmed = trimmed_vals[lower]</span>

        <span class="s1">rv = np.concatenate([trimmed</span><span class="s2">, </span><span class="s1">jumbo_vals])</span>
        <span class="s1">rv.sort()</span>

    <span class="s2">if </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">pd.CategoricalDtype):</span>
        <span class="s1">rv = pd.Categorical.from_codes(rv</span><span class="s2">, </span><span class="s1">info[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">info[</span><span class="s3">1</span><span class="s1">])</span>
    <span class="s2">elif </span><span class="s1">isinstance(dtype</span><span class="s2">, </span><span class="s1">pd.DatetimeTZDtype):</span>
        <span class="s1">rv = pd.DatetimeIndex(rv).tz_localize(dtype.tz)</span>
    <span class="s2">elif </span><span class="s5">&quot;datetime64&quot; </span><span class="s2">in </span><span class="s1">str(dtype):</span>
        <span class="s1">rv = pd.DatetimeIndex(rv</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s2">elif </span><span class="s1">rv.dtype != dtype:</span>
        <span class="s2">if </span><span class="s1">is_integer_dtype(dtype) </span><span class="s2">and </span><span class="s1">pd.api.types.is_float_dtype(rv.dtype):</span>
            <span class="s4"># pandas EA raises instead of truncating</span>
            <span class="s1">rv = np.floor(rv)</span>
        <span class="s1">rv = pd.array(rv</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s2">return </span><span class="s1">rv</span>


<span class="s2">def </span><span class="s1">percentiles_summary(df</span><span class="s2">, </span><span class="s1">num_old</span><span class="s2">, </span><span class="s1">num_new</span><span class="s2">, </span><span class="s1">upsample</span><span class="s2">, </span><span class="s1">state):</span>
    <span class="s0">&quot;&quot;&quot;Summarize data using percentiles and derived weights. 
 
    These summaries can be merged, compressed, and converted back into 
    approximate percentiles. 
 
    Parameters 
    ---------- 
    df: pandas.Series 
        Data to summarize 
    num_old: int 
        Number of partitions of the current object 
    num_new: int 
        Number of partitions of the new object 
    upsample: float 
        Scale factor to increase the number of percentiles calculated in 
        each partition.  Use to improve accuracy. 
    &quot;&quot;&quot;</span>
    <span class="s2">from </span><span class="s1">dask.array.dispatch </span><span class="s2">import </span><span class="s1">percentile_lookup </span><span class="s2">as </span><span class="s1">_percentile</span>
    <span class="s2">from </span><span class="s1">dask.array.utils </span><span class="s2">import </span><span class="s1">array_safe</span>

    <span class="s1">length = len(df)</span>
    <span class="s2">if </span><span class="s1">length == </span><span class="s3">0</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">()</span>
    <span class="s1">random_state = np.random.RandomState(state)</span>
    <span class="s1">qs = sample_percentiles(num_old</span><span class="s2">, </span><span class="s1">num_new</span><span class="s2">, </span><span class="s1">length</span><span class="s2">, </span><span class="s1">upsample</span><span class="s2">, </span><span class="s1">random_state)</span>
    <span class="s1">data = df</span>
    <span class="s1">interpolation = </span><span class="s5">&quot;linear&quot;</span>

    <span class="s2">if </span><span class="s1">isinstance(data.dtype</span><span class="s2">, </span><span class="s1">pd.CategoricalDtype):</span>
        <span class="s1">data = data.cat.codes</span>
        <span class="s1">interpolation = </span><span class="s5">&quot;nearest&quot;</span>
    <span class="s2">elif </span><span class="s1">is_datetime64_dtype(data.dtype) </span><span class="s2">or </span><span class="s1">is_integer_dtype(data.dtype):</span>
        <span class="s1">interpolation = </span><span class="s5">&quot;nearest&quot;</span>

    <span class="s4"># FIXME: pandas quantile doesn't work with some data types (e.g. strings).</span>
    <span class="s4"># We fall back to an ndarray as a workaround.</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">vals = data.quantile(q=qs / </span><span class="s3">100</span><span class="s2">, </span><span class="s1">interpolation=interpolation).values</span>
    <span class="s2">except </span><span class="s1">(TypeError</span><span class="s2">, </span><span class="s1">NotImplementedError):</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">vals</span><span class="s2">, </span><span class="s1">_ = _percentile(array_safe(data</span><span class="s2">, </span><span class="s1">like=data.values)</span><span class="s2">, </span><span class="s1">qs</span><span class="s2">, </span><span class="s1">interpolation)</span>
        <span class="s2">except </span><span class="s1">(TypeError</span><span class="s2">, </span><span class="s1">NotImplementedError):</span>
            <span class="s4"># `data.values` doesn't work for cudf, so we need to</span>
            <span class="s4"># use `quantile(..., method=&quot;table&quot;)` as a fallback</span>
            <span class="s1">interpolation = </span><span class="s5">&quot;nearest&quot;</span>
            <span class="s1">vals = (</span>
                <span class="s1">data.to_frame()</span>
                <span class="s1">.quantile(</span>
                    <span class="s1">q=qs / </span><span class="s3">100</span><span class="s2">,</span>
                    <span class="s1">interpolation=interpolation</span><span class="s2">,</span>
                    <span class="s1">numeric_only=</span><span class="s2">False,</span>
                    <span class="s1">method=</span><span class="s5">&quot;table&quot;</span><span class="s2">,</span>
                <span class="s1">)</span>
                <span class="s1">.iloc[:</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span>
            <span class="s1">)</span>

    <span class="s2">if </span><span class="s1">(</span>
        <span class="s1">is_cupy_type(data)</span>
        <span class="s2">and </span><span class="s1">interpolation == </span><span class="s5">&quot;linear&quot;</span>
        <span class="s2">and </span><span class="s1">np.issubdtype(data.dtype</span><span class="s2">, </span><span class="s1">np.integer)</span>
    <span class="s1">):</span>
        <span class="s1">vals = np.round(vals).astype(data.dtype)</span>
        <span class="s2">if </span><span class="s1">qs[</span><span class="s3">0</span><span class="s1">] == </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s4"># Ensure the 0th quantile is the minimum value of the data</span>
            <span class="s1">vals[</span><span class="s3">0</span><span class="s1">] = data.min()</span>
    <span class="s1">vals_and_weights = percentiles_to_weights(qs</span><span class="s2">, </span><span class="s1">vals</span><span class="s2">, </span><span class="s1">length)</span>
    <span class="s2">return </span><span class="s1">vals_and_weights</span>


<span class="s2">def </span><span class="s1">dtype_info(df):</span>
    <span class="s1">info = </span><span class="s2">None</span>
    <span class="s2">if </span><span class="s1">isinstance(df.dtype</span><span class="s2">, </span><span class="s1">pd.CategoricalDtype):</span>
        <span class="s1">data = df.values</span>
        <span class="s1">info = (data.categories</span><span class="s2">, </span><span class="s1">data.ordered)</span>
    <span class="s2">return </span><span class="s1">df.dtype</span><span class="s2">, </span><span class="s1">info</span>


<span class="s2">def </span><span class="s1">partition_quantiles(df</span><span class="s2">, </span><span class="s1">npartitions</span><span class="s2">, </span><span class="s1">upsample=</span><span class="s3">1.0</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Approximate quantiles of Series used for repartitioning&quot;&quot;&quot;</span>
    <span class="s2">assert </span><span class="s1">isinstance(df</span><span class="s2">, </span><span class="s1">Series)</span>
    <span class="s4"># currently, only Series has quantile method</span>
    <span class="s4"># Index.quantile(list-like) must be pd.Series, not pd.Index</span>
    <span class="s1">return_type = Series</span>

    <span class="s1">qs = np.linspace(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s1">npartitions + </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">token = tokenize(df</span><span class="s2">, </span><span class="s1">qs</span><span class="s2">, </span><span class="s1">upsample)</span>
    <span class="s2">if </span><span class="s1">random_state </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">random_state = int(token</span><span class="s2">, </span><span class="s3">16</span><span class="s1">) % np.iinfo(np.int32).max</span>
    <span class="s1">state_data = random_state_data(df.npartitions</span><span class="s2">, </span><span class="s1">random_state)</span>

    <span class="s1">df_keys = df.__dask_keys__()</span>

    <span class="s1">name0 = </span><span class="s5">&quot;re-quantiles-0-&quot; </span><span class="s1">+ token</span>
    <span class="s1">dtype_dsk = {(name0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">): (dtype_info</span><span class="s2">, </span><span class="s1">df_keys[</span><span class="s3">0</span><span class="s1">])}</span>

    <span class="s1">name1 = </span><span class="s5">&quot;re-quantiles-1-&quot; </span><span class="s1">+ token</span>
    <span class="s1">val_dsk = {</span>
        <span class="s1">(name1</span><span class="s2">, </span><span class="s1">i): (</span>
            <span class="s1">percentiles_summary</span><span class="s2">,</span>
            <span class="s1">key</span><span class="s2">,</span>
            <span class="s1">df.npartitions</span><span class="s2">,</span>
            <span class="s1">npartitions</span><span class="s2">,</span>
            <span class="s1">upsample</span><span class="s2">,</span>
            <span class="s1">state</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">(state</span><span class="s2">, </span><span class="s1">key) </span><span class="s2">in </span><span class="s1">enumerate(zip(state_data</span><span class="s2">, </span><span class="s1">df_keys))</span>
    <span class="s1">}</span>

    <span class="s1">name2 = </span><span class="s5">&quot;re-quantiles-2-&quot; </span><span class="s1">+ token</span>
    <span class="s1">merge_dsk = create_merge_tree(merge_and_compress_summaries</span><span class="s2">, </span><span class="s1">sorted(val_dsk)</span><span class="s2">, </span><span class="s1">name2)</span>
    <span class="s2">if not </span><span class="s1">merge_dsk:</span>
        <span class="s4"># Compress the data even if we only have one partition</span>
        <span class="s1">merge_dsk = {(name2</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">): (merge_and_compress_summaries</span><span class="s2">, </span><span class="s1">[list(val_dsk)[</span><span class="s3">0</span><span class="s1">]])}</span>

    <span class="s1">merged_key = max(merge_dsk)</span>

    <span class="s1">name3 = </span><span class="s5">&quot;re-quantiles-3-&quot; </span><span class="s1">+ token</span>
    <span class="s1">last_dsk = {</span>
        <span class="s1">(name3</span><span class="s2">, </span><span class="s3">0</span><span class="s1">): (</span>
            <span class="s1">pd.Series</span><span class="s2">,  </span><span class="s4"># TODO: Use `type(df._meta)` when cudf adds `tolist()`</span>
            <span class="s1">(process_val_weights</span><span class="s2">, </span><span class="s1">merged_key</span><span class="s2">, </span><span class="s1">npartitions</span><span class="s2">, </span><span class="s1">(name0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">qs</span><span class="s2">,</span>
            <span class="s2">None,</span>
            <span class="s1">df.name</span><span class="s2">,</span>
        <span class="s1">)</span>
    <span class="s1">}</span>

    <span class="s1">dsk = merge(df.dask</span><span class="s2">, </span><span class="s1">dtype_dsk</span><span class="s2">, </span><span class="s1">val_dsk</span><span class="s2">, </span><span class="s1">merge_dsk</span><span class="s2">, </span><span class="s1">last_dsk)</span>
    <span class="s1">new_divisions = [</span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">1.0</span><span class="s1">]</span>
    <span class="s2">return </span><span class="s1">return_type(dsk</span><span class="s2">, </span><span class="s1">name3</span><span class="s2">, </span><span class="s1">df._meta</span><span class="s2">, </span><span class="s1">new_divisions)</span>
</pre>
</body>
</html>