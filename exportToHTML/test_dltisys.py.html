<html>
<head>
<title>test_dltisys.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #6a8759;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_dltisys.py</font>
</center></td></tr></table>
<pre><span class="s0"># Author: Jeffrey Armstrong &lt;jeff@approximatrix.com&gt;</span>
<span class="s0"># April 4, 2011</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">numpy.testing </span><span class="s2">import </span><span class="s1">(assert_equal</span><span class="s2">,</span>
                           <span class="s1">assert_array_almost_equal</span><span class="s2">, </span><span class="s1">assert_array_equal</span><span class="s2">,</span>
                           <span class="s1">assert_allclose</span><span class="s2">, </span><span class="s1">assert_</span><span class="s2">, </span><span class="s1">assert_almost_equal</span><span class="s2">,</span>
                           <span class="s1">suppress_warnings)</span>
<span class="s2">from </span><span class="s1">pytest </span><span class="s2">import </span><span class="s1">raises </span><span class="s2">as </span><span class="s1">assert_raises</span>
<span class="s2">from </span><span class="s1">scipy.signal </span><span class="s2">import </span><span class="s1">(dlsim</span><span class="s2">, </span><span class="s1">dstep</span><span class="s2">, </span><span class="s1">dimpulse</span><span class="s2">, </span><span class="s1">tf2zpk</span><span class="s2">, </span><span class="s1">lti</span><span class="s2">, </span><span class="s1">dlti</span><span class="s2">,</span>
                          <span class="s1">StateSpace</span><span class="s2">, </span><span class="s1">TransferFunction</span><span class="s2">, </span><span class="s1">ZerosPolesGain</span><span class="s2">,</span>
                          <span class="s1">dfreqresp</span><span class="s2">, </span><span class="s1">dbode</span><span class="s2">, </span><span class="s1">BadCoefficients)</span>


<span class="s2">class </span><span class="s1">TestDLTI:</span>

    <span class="s2">def </span><span class="s1">test_dlsim(self):</span>

        <span class="s1">a = np.asarray([[</span><span class="s3">0.9</span><span class="s2">, </span><span class="s3">0.1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[-</span><span class="s3">0.2</span><span class="s2">, </span><span class="s3">0.9</span><span class="s1">]])</span>
        <span class="s1">b = np.asarray([[</span><span class="s3">0.4</span><span class="s2">, </span><span class="s3">0.1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.05</span><span class="s2">, </span><span class="s3">0.0</span><span class="s1">]])</span>
        <span class="s1">c = np.asarray([[</span><span class="s3">0.1</span><span class="s2">, </span><span class="s3">0.3</span><span class="s1">]])</span>
        <span class="s1">d = np.asarray([[</span><span class="s3">0.0</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.1</span><span class="s2">, </span><span class="s3">0.0</span><span class="s1">]])</span>
        <span class="s1">dt = </span><span class="s3">0.5</span>

        <span class="s0"># Create an input matrix with inputs down the columns (3 cols) and its</span>
        <span class="s0"># respective time input vector</span>
        <span class="s1">u = np.hstack((np.linspace(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">4.0</span><span class="s2">, </span><span class="s1">num=</span><span class="s3">5</span><span class="s1">)[:</span><span class="s2">, </span><span class="s1">np.newaxis]</span><span class="s2">,</span>
                       <span class="s1">np.full((</span><span class="s3">5</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span><span class="s2">, </span><span class="s3">0.01</span><span class="s1">)</span><span class="s2">,</span>
                       <span class="s1">np.full((</span><span class="s3">5</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.002</span><span class="s1">)))</span>
        <span class="s1">t_in = np.linspace(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">2.0</span><span class="s2">, </span><span class="s1">num=</span><span class="s3">5</span><span class="s1">)</span>

        <span class="s0"># Define the known result</span>
        <span class="s1">yout_truth = np.array([[-</span><span class="s3">0.001</span><span class="s2">,</span>
                                <span class="s1">-</span><span class="s3">0.00073</span><span class="s2">,</span>
                                <span class="s3">0.039446</span><span class="s2">,</span>
                                <span class="s3">0.0915387</span><span class="s2">,</span>
                                <span class="s3">0.13195948</span><span class="s1">]]).T</span>
        <span class="s1">xout_truth = np.asarray([[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">,</span>
                                 <span class="s1">[</span><span class="s3">0.0012</span><span class="s2">, </span><span class="s3">0.0005</span><span class="s1">]</span><span class="s2">,</span>
                                 <span class="s1">[</span><span class="s3">0.40233</span><span class="s2">, </span><span class="s3">0.00071</span><span class="s1">]</span><span class="s2">,</span>
                                 <span class="s1">[</span><span class="s3">1.163368</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.079327</span><span class="s1">]</span><span class="s2">,</span>
                                 <span class="s1">[</span><span class="s3">2.2402985</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.3035679</span><span class="s1">]])</span>

        <span class="s1">tout</span><span class="s2">, </span><span class="s1">yout</span><span class="s2">, </span><span class="s1">xout = dlsim((a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">dt)</span><span class="s2">, </span><span class="s1">u</span><span class="s2">, </span><span class="s1">t_in)</span>

        <span class="s1">assert_array_almost_equal(yout_truth</span><span class="s2">, </span><span class="s1">yout)</span>
        <span class="s1">assert_array_almost_equal(xout_truth</span><span class="s2">, </span><span class="s1">xout)</span>
        <span class="s1">assert_array_almost_equal(t_in</span><span class="s2">, </span><span class="s1">tout)</span>

        <span class="s0"># Make sure input with single-dimension doesn't raise error</span>
        <span class="s1">dlsim((</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s1">)</span><span class="s2">, </span><span class="s3">4</span><span class="s1">)</span>

        <span class="s0"># Interpolated control - inputs should have different time steps</span>
        <span class="s0"># than the discrete model uses internally</span>
        <span class="s1">u_sparse = u[[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">:]</span>
        <span class="s1">t_sparse = np.asarray([</span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">2.0</span><span class="s1">])</span>

        <span class="s1">tout</span><span class="s2">, </span><span class="s1">yout</span><span class="s2">, </span><span class="s1">xout = dlsim((a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">dt)</span><span class="s2">, </span><span class="s1">u_sparse</span><span class="s2">, </span><span class="s1">t_sparse)</span>

        <span class="s1">assert_array_almost_equal(yout_truth</span><span class="s2">, </span><span class="s1">yout)</span>
        <span class="s1">assert_array_almost_equal(xout_truth</span><span class="s2">, </span><span class="s1">xout)</span>
        <span class="s1">assert_equal(len(tout)</span><span class="s2">, </span><span class="s1">yout.shape[</span><span class="s3">0</span><span class="s1">])</span>

        <span class="s0"># Transfer functions (assume dt = 0.5)</span>
        <span class="s1">num = np.asarray([</span><span class="s3">1.0</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.1</span><span class="s1">])</span>
        <span class="s1">den = np.asarray([</span><span class="s3">0.3</span><span class="s2">, </span><span class="s3">1.0</span><span class="s2">, </span><span class="s3">0.2</span><span class="s1">])</span>
        <span class="s1">yout_truth = np.array([[</span><span class="s3">0.0</span><span class="s2">,</span>
                                <span class="s3">0.0</span><span class="s2">,</span>
                                <span class="s3">3.33333333333333</span><span class="s2">,</span>
                                <span class="s1">-</span><span class="s3">4.77777777777778</span><span class="s2">,</span>
                                <span class="s3">23.0370370370370</span><span class="s1">]]).T</span>

        <span class="s0"># Assume use of the first column of the control input built earlier</span>
        <span class="s1">tout</span><span class="s2">, </span><span class="s1">yout = dlsim((num</span><span class="s2">, </span><span class="s1">den</span><span class="s2">, </span><span class="s3">0.5</span><span class="s1">)</span><span class="s2">, </span><span class="s1">u[:</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">t_in)</span>

        <span class="s1">assert_array_almost_equal(yout</span><span class="s2">, </span><span class="s1">yout_truth)</span>
        <span class="s1">assert_array_almost_equal(t_in</span><span class="s2">, </span><span class="s1">tout)</span>

        <span class="s0"># Retest the same with a 1-D input vector</span>
        <span class="s1">uflat = np.asarray(u[:</span><span class="s2">, </span><span class="s3">0</span><span class="s1">])</span>
        <span class="s1">uflat = uflat.reshape((</span><span class="s3">5</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s1">tout</span><span class="s2">, </span><span class="s1">yout = dlsim((num</span><span class="s2">, </span><span class="s1">den</span><span class="s2">, </span><span class="s3">0.5</span><span class="s1">)</span><span class="s2">, </span><span class="s1">uflat</span><span class="s2">, </span><span class="s1">t_in)</span>

        <span class="s1">assert_array_almost_equal(yout</span><span class="s2">, </span><span class="s1">yout_truth)</span>
        <span class="s1">assert_array_almost_equal(t_in</span><span class="s2">, </span><span class="s1">tout)</span>

        <span class="s0"># zeros-poles-gain representation</span>
        <span class="s1">zd = np.array([</span><span class="s3">0.5</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.5</span><span class="s1">])</span>
        <span class="s1">pd = np.array([</span><span class="s3">1.j </span><span class="s1">/ np.sqrt(</span><span class="s3">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1.j </span><span class="s1">/ np.sqrt(</span><span class="s3">2</span><span class="s1">)])</span>
        <span class="s1">k = </span><span class="s3">1.0</span>
        <span class="s1">yout_truth = np.array([[</span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">1.0</span><span class="s2">, </span><span class="s3">2.0</span><span class="s2">, </span><span class="s3">2.25</span><span class="s2">, </span><span class="s3">2.5</span><span class="s1">]]).T</span>

        <span class="s1">tout</span><span class="s2">, </span><span class="s1">yout = dlsim((zd</span><span class="s2">, </span><span class="s1">pd</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s3">0.5</span><span class="s1">)</span><span class="s2">, </span><span class="s1">u[:</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">t_in)</span>

        <span class="s1">assert_array_almost_equal(yout</span><span class="s2">, </span><span class="s1">yout_truth)</span>
        <span class="s1">assert_array_almost_equal(t_in</span><span class="s2">, </span><span class="s1">tout)</span>

        <span class="s0"># Raise an error for continuous-time systems</span>
        <span class="s1">system = lti([</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">assert_raises(AttributeError</span><span class="s2">, </span><span class="s1">dlsim</span><span class="s2">, </span><span class="s1">system</span><span class="s2">, </span><span class="s1">u)</span>

    <span class="s2">def </span><span class="s1">test_dstep(self):</span>

        <span class="s1">a = np.asarray([[</span><span class="s3">0.9</span><span class="s2">, </span><span class="s3">0.1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[-</span><span class="s3">0.2</span><span class="s2">, </span><span class="s3">0.9</span><span class="s1">]])</span>
        <span class="s1">b = np.asarray([[</span><span class="s3">0.4</span><span class="s2">, </span><span class="s3">0.1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.05</span><span class="s2">, </span><span class="s3">0.0</span><span class="s1">]])</span>
        <span class="s1">c = np.asarray([[</span><span class="s3">0.1</span><span class="s2">, </span><span class="s3">0.3</span><span class="s1">]])</span>
        <span class="s1">d = np.asarray([[</span><span class="s3">0.0</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.1</span><span class="s2">, </span><span class="s3">0.0</span><span class="s1">]])</span>
        <span class="s1">dt = </span><span class="s3">0.5</span>

        <span class="s0"># Because b.shape[1] == 3, dstep should result in a tuple of three</span>
        <span class="s0"># result vectors</span>
        <span class="s1">yout_step_truth = (np.asarray([</span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.04</span><span class="s2">, </span><span class="s3">0.052</span><span class="s2">, </span><span class="s3">0.0404</span><span class="s2">, </span><span class="s3">0.00956</span><span class="s2">,</span>
                                       <span class="s1">-</span><span class="s3">0.036324</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.093318</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.15782348</span><span class="s2">,</span>
                                       <span class="s1">-</span><span class="s3">0.226628324</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.2969374948</span><span class="s1">])</span><span class="s2">,</span>
                           <span class="s1">np.asarray([-</span><span class="s3">0.1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.075</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.058</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.04815</span><span class="s2">,</span>
                                       <span class="s1">-</span><span class="s3">0.04453</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.0461895</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.0521812</span><span class="s2">,</span>
                                       <span class="s1">-</span><span class="s3">0.061588875</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.073549579</span><span class="s2">,</span>
                                       <span class="s1">-</span><span class="s3">0.08727047595</span><span class="s1">])</span><span class="s2">,</span>
                           <span class="s1">np.asarray([</span><span class="s3">0.0</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.01</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.013</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.0101</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.00239</span><span class="s2">,</span>
                                       <span class="s3">0.009081</span><span class="s2">, </span><span class="s3">0.0233295</span><span class="s2">, </span><span class="s3">0.03945587</span><span class="s2">,</span>
                                       <span class="s3">0.056657081</span><span class="s2">, </span><span class="s3">0.0742343737</span><span class="s1">]))</span>

        <span class="s1">tout</span><span class="s2">, </span><span class="s1">yout = dstep((a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">dt)</span><span class="s2">, </span><span class="s1">n=</span><span class="s3">10</span><span class="s1">)</span>

        <span class="s1">assert_equal(len(yout)</span><span class="s2">, </span><span class="s3">3</span><span class="s1">)</span>

        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">len(yout)):</span>
            <span class="s1">assert_equal(yout[i].shape[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s3">10</span><span class="s1">)</span>
            <span class="s1">assert_array_almost_equal(yout[i].flatten()</span><span class="s2">, </span><span class="s1">yout_step_truth[i])</span>

        <span class="s0"># Check that the other two inputs (tf, zpk) will work as well</span>
        <span class="s1">tfin = ([</span><span class="s3">1.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1.0</span><span class="s2">, </span><span class="s3">1.0</span><span class="s1">]</span><span class="s2">, </span><span class="s3">0.5</span><span class="s1">)</span>
        <span class="s1">yout_tfstep = np.asarray([</span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">1.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s1">])</span>
        <span class="s1">tout</span><span class="s2">, </span><span class="s1">yout = dstep(tfin</span><span class="s2">, </span><span class="s1">n=</span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">assert_equal(len(yout)</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(yout[</span><span class="s3">0</span><span class="s1">].flatten()</span><span class="s2">, </span><span class="s1">yout_tfstep)</span>

        <span class="s1">zpkin = tf2zpk(tfin[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">tfin[</span><span class="s3">1</span><span class="s1">]) + (</span><span class="s3">0.5</span><span class="s2">,</span><span class="s1">)</span>
        <span class="s1">tout</span><span class="s2">, </span><span class="s1">yout = dstep(zpkin</span><span class="s2">, </span><span class="s1">n=</span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">assert_equal(len(yout)</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(yout[</span><span class="s3">0</span><span class="s1">].flatten()</span><span class="s2">, </span><span class="s1">yout_tfstep)</span>

        <span class="s0"># Raise an error for continuous-time systems</span>
        <span class="s1">system = lti([</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">assert_raises(AttributeError</span><span class="s2">, </span><span class="s1">dstep</span><span class="s2">, </span><span class="s1">system)</span>

    <span class="s2">def </span><span class="s1">test_dimpulse(self):</span>

        <span class="s1">a = np.asarray([[</span><span class="s3">0.9</span><span class="s2">, </span><span class="s3">0.1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[-</span><span class="s3">0.2</span><span class="s2">, </span><span class="s3">0.9</span><span class="s1">]])</span>
        <span class="s1">b = np.asarray([[</span><span class="s3">0.4</span><span class="s2">, </span><span class="s3">0.1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.05</span><span class="s2">, </span><span class="s3">0.0</span><span class="s1">]])</span>
        <span class="s1">c = np.asarray([[</span><span class="s3">0.1</span><span class="s2">, </span><span class="s3">0.3</span><span class="s1">]])</span>
        <span class="s1">d = np.asarray([[</span><span class="s3">0.0</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.1</span><span class="s2">, </span><span class="s3">0.0</span><span class="s1">]])</span>
        <span class="s1">dt = </span><span class="s3">0.5</span>

        <span class="s0"># Because b.shape[1] == 3, dimpulse should result in a tuple of three</span>
        <span class="s0"># result vectors</span>
        <span class="s1">yout_imp_truth = (np.asarray([</span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.04</span><span class="s2">, </span><span class="s3">0.012</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.0116</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.03084</span><span class="s2">,</span>
                                      <span class="s1">-</span><span class="s3">0.045884</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.056994</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.06450548</span><span class="s2">,</span>
                                      <span class="s1">-</span><span class="s3">0.068804844</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.0703091708</span><span class="s1">])</span><span class="s2">,</span>
                          <span class="s1">np.asarray([-</span><span class="s3">0.1</span><span class="s2">, </span><span class="s3">0.025</span><span class="s2">, </span><span class="s3">0.017</span><span class="s2">, </span><span class="s3">0.00985</span><span class="s2">, </span><span class="s3">0.00362</span><span class="s2">,</span>
                                      <span class="s1">-</span><span class="s3">0.0016595</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.0059917</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.009407675</span><span class="s2">,</span>
                                      <span class="s1">-</span><span class="s3">0.011960704</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.01372089695</span><span class="s1">])</span><span class="s2">,</span>
                          <span class="s1">np.asarray([</span><span class="s3">0.0</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.01</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.003</span><span class="s2">, </span><span class="s3">0.0029</span><span class="s2">, </span><span class="s3">0.00771</span><span class="s2">,</span>
                                      <span class="s3">0.011471</span><span class="s2">, </span><span class="s3">0.0142485</span><span class="s2">, </span><span class="s3">0.01612637</span><span class="s2">,</span>
                                      <span class="s3">0.017201211</span><span class="s2">, </span><span class="s3">0.0175772927</span><span class="s1">]))</span>

        <span class="s1">tout</span><span class="s2">, </span><span class="s1">yout = dimpulse((a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">dt)</span><span class="s2">, </span><span class="s1">n=</span><span class="s3">10</span><span class="s1">)</span>

        <span class="s1">assert_equal(len(yout)</span><span class="s2">, </span><span class="s3">3</span><span class="s1">)</span>

        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">len(yout)):</span>
            <span class="s1">assert_equal(yout[i].shape[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s3">10</span><span class="s1">)</span>
            <span class="s1">assert_array_almost_equal(yout[i].flatten()</span><span class="s2">, </span><span class="s1">yout_imp_truth[i])</span>

        <span class="s0"># Check that the other two inputs (tf, zpk) will work as well</span>
        <span class="s1">tfin = ([</span><span class="s3">1.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1.0</span><span class="s2">, </span><span class="s3">1.0</span><span class="s1">]</span><span class="s2">, </span><span class="s3">0.5</span><span class="s1">)</span>
        <span class="s1">yout_tfimpulse = np.asarray([</span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">1.0</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1.0</span><span class="s1">])</span>
        <span class="s1">tout</span><span class="s2">, </span><span class="s1">yout = dimpulse(tfin</span><span class="s2">, </span><span class="s1">n=</span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">assert_equal(len(yout)</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(yout[</span><span class="s3">0</span><span class="s1">].flatten()</span><span class="s2">, </span><span class="s1">yout_tfimpulse)</span>

        <span class="s1">zpkin = tf2zpk(tfin[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">tfin[</span><span class="s3">1</span><span class="s1">]) + (</span><span class="s3">0.5</span><span class="s2">,</span><span class="s1">)</span>
        <span class="s1">tout</span><span class="s2">, </span><span class="s1">yout = dimpulse(zpkin</span><span class="s2">, </span><span class="s1">n=</span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">assert_equal(len(yout)</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(yout[</span><span class="s3">0</span><span class="s1">].flatten()</span><span class="s2">, </span><span class="s1">yout_tfimpulse)</span>

        <span class="s0"># Raise an error for continuous-time systems</span>
        <span class="s1">system = lti([</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">assert_raises(AttributeError</span><span class="s2">, </span><span class="s1">dimpulse</span><span class="s2">, </span><span class="s1">system)</span>

    <span class="s2">def </span><span class="s1">test_dlsim_trivial(self):</span>
        <span class="s1">a = np.array([[</span><span class="s3">0.0</span><span class="s1">]])</span>
        <span class="s1">b = np.array([[</span><span class="s3">0.0</span><span class="s1">]])</span>
        <span class="s1">c = np.array([[</span><span class="s3">0.0</span><span class="s1">]])</span>
        <span class="s1">d = np.array([[</span><span class="s3">0.0</span><span class="s1">]])</span>
        <span class="s1">n = </span><span class="s3">5</span>
        <span class="s1">u = np.zeros(n).reshape(-</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">tout</span><span class="s2">, </span><span class="s1">yout</span><span class="s2">, </span><span class="s1">xout = dlsim((a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">u)</span>
        <span class="s1">assert_array_equal(tout</span><span class="s2">, </span><span class="s1">np.arange(float(n)))</span>
        <span class="s1">assert_array_equal(yout</span><span class="s2">, </span><span class="s1">np.zeros((n</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)))</span>
        <span class="s1">assert_array_equal(xout</span><span class="s2">, </span><span class="s1">np.zeros((n</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)))</span>

    <span class="s2">def </span><span class="s1">test_dlsim_simple1d(self):</span>
        <span class="s1">a = np.array([[</span><span class="s3">0.5</span><span class="s1">]])</span>
        <span class="s1">b = np.array([[</span><span class="s3">0.0</span><span class="s1">]])</span>
        <span class="s1">c = np.array([[</span><span class="s3">1.0</span><span class="s1">]])</span>
        <span class="s1">d = np.array([[</span><span class="s3">0.0</span><span class="s1">]])</span>
        <span class="s1">n = </span><span class="s3">5</span>
        <span class="s1">u = np.zeros(n).reshape(-</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">tout</span><span class="s2">, </span><span class="s1">yout</span><span class="s2">, </span><span class="s1">xout = dlsim((a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">u</span><span class="s2">, </span><span class="s1">x0=</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(tout</span><span class="s2">, </span><span class="s1">np.arange(float(n)))</span>
        <span class="s1">expected = (</span><span class="s3">0.5 </span><span class="s1">** np.arange(float(n))).reshape(-</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(yout</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">assert_array_equal(xout</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_dlsim_simple2d(self):</span>
        <span class="s1">lambda1 = </span><span class="s3">0.5</span>
        <span class="s1">lambda2 = </span><span class="s3">0.25</span>
        <span class="s1">a = np.array([[lambda1</span><span class="s2">, </span><span class="s3">0.0</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s3">0.0</span><span class="s2">, </span><span class="s1">lambda2]])</span>
        <span class="s1">b = np.array([[</span><span class="s3">0.0</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s3">0.0</span><span class="s1">]])</span>
        <span class="s1">c = np.array([[</span><span class="s3">1.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">1.0</span><span class="s1">]])</span>
        <span class="s1">d = np.array([[</span><span class="s3">0.0</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s3">0.0</span><span class="s1">]])</span>
        <span class="s1">n = </span><span class="s3">5</span>
        <span class="s1">u = np.zeros(n).reshape(-</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">tout</span><span class="s2">, </span><span class="s1">yout</span><span class="s2">, </span><span class="s1">xout = dlsim((a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">u</span><span class="s2">, </span><span class="s1">x0=</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(tout</span><span class="s2">, </span><span class="s1">np.arange(float(n)))</span>
        <span class="s0"># The analytical solution:</span>
        <span class="s1">expected = (np.array([lambda1</span><span class="s2">, </span><span class="s1">lambda2]) **</span>
                                <span class="s1">np.arange(float(n)).reshape(-</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">assert_array_equal(yout</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">assert_array_equal(xout</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_more_step_and_impulse(self):</span>
        <span class="s1">lambda1 = </span><span class="s3">0.5</span>
        <span class="s1">lambda2 = </span><span class="s3">0.75</span>
        <span class="s1">a = np.array([[lambda1</span><span class="s2">, </span><span class="s3">0.0</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s3">0.0</span><span class="s2">, </span><span class="s1">lambda2]])</span>
        <span class="s1">b = np.array([[</span><span class="s3">1.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">1.0</span><span class="s1">]])</span>
        <span class="s1">c = np.array([[</span><span class="s3">1.0</span><span class="s2">, </span><span class="s3">1.0</span><span class="s1">]])</span>
        <span class="s1">d = np.array([[</span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s1">]])</span>

        <span class="s1">n = </span><span class="s3">10</span>

        <span class="s0"># Check a step response.</span>
        <span class="s1">ts</span><span class="s2">, </span><span class="s1">ys = dstep((a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">n=n)</span>

        <span class="s0"># Create the exact step response.</span>
        <span class="s1">stp0 = (</span><span class="s3">1.0 </span><span class="s1">/ (</span><span class="s3">1 </span><span class="s1">- lambda1)) * (</span><span class="s3">1.0 </span><span class="s1">- lambda1 ** np.arange(n))</span>
        <span class="s1">stp1 = (</span><span class="s3">1.0 </span><span class="s1">/ (</span><span class="s3">1 </span><span class="s1">- lambda2)) * (</span><span class="s3">1.0 </span><span class="s1">- lambda2 ** np.arange(n))</span>

        <span class="s1">assert_allclose(ys[</span><span class="s3">0</span><span class="s1">][:</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">stp0)</span>
        <span class="s1">assert_allclose(ys[</span><span class="s3">1</span><span class="s1">][:</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">stp1)</span>

        <span class="s0"># Check an impulse response with an initial condition.</span>
        <span class="s1">x0 = np.array([</span><span class="s3">1.0</span><span class="s2">, </span><span class="s3">1.0</span><span class="s1">])</span>
        <span class="s1">ti</span><span class="s2">, </span><span class="s1">yi = dimpulse((a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">n=n</span><span class="s2">, </span><span class="s1">x0=x0)</span>

        <span class="s0"># Create the exact impulse response.</span>
        <span class="s1">imp = (np.array([lambda1</span><span class="s2">, </span><span class="s1">lambda2]) **</span>
                            <span class="s1">np.arange(-</span><span class="s3">1</span><span class="s2">, </span><span class="s1">n + </span><span class="s3">1</span><span class="s1">).reshape(-</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">imp[</span><span class="s3">0</span><span class="s2">, </span><span class="s1">:] = </span><span class="s3">0.0</span>
        <span class="s0"># Analytical solution to impulse response</span>
        <span class="s1">y0 = imp[:n</span><span class="s2">, </span><span class="s3">0</span><span class="s1">] + np.dot(imp[</span><span class="s3">1</span><span class="s1">:n + </span><span class="s3">1</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">, </span><span class="s1">x0)</span>
        <span class="s1">y1 = imp[:n</span><span class="s2">, </span><span class="s3">1</span><span class="s1">] + np.dot(imp[</span><span class="s3">1</span><span class="s1">:n + </span><span class="s3">1</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">, </span><span class="s1">x0)</span>

        <span class="s1">assert_allclose(yi[</span><span class="s3">0</span><span class="s1">][:</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">y0)</span>
        <span class="s1">assert_allclose(yi[</span><span class="s3">1</span><span class="s1">][:</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">y1)</span>

        <span class="s0"># Check that dt=0.1, n=3 gives 3 time values.</span>
        <span class="s1">system = ([</span><span class="s3">1.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1.0</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.5</span><span class="s1">]</span><span class="s2">, </span><span class="s3">0.1</span><span class="s1">)</span>
        <span class="s1">t</span><span class="s2">, </span><span class="s1">(y</span><span class="s2">,</span><span class="s1">) = dstep(system</span><span class="s2">, </span><span class="s1">n=</span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">assert_allclose(t</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0.1</span><span class="s2">, </span><span class="s3">0.2</span><span class="s1">])</span>
        <span class="s1">assert_array_equal(y.T</span><span class="s2">, </span><span class="s1">[[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1.0</span><span class="s2">, </span><span class="s3">1.5</span><span class="s1">]])</span>
        <span class="s1">t</span><span class="s2">, </span><span class="s1">(y</span><span class="s2">,</span><span class="s1">) = dimpulse(system</span><span class="s2">, </span><span class="s1">n=</span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">assert_allclose(t</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0.1</span><span class="s2">, </span><span class="s3">0.2</span><span class="s1">])</span>
        <span class="s1">assert_array_equal(y.T</span><span class="s2">, </span><span class="s1">[[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">0.5</span><span class="s1">]])</span>


<span class="s2">class </span><span class="s1">TestDlti:</span>
    <span class="s2">def </span><span class="s1">test_dlti_instantiation(self):</span>
        <span class="s0"># Test that lti can be instantiated.</span>

        <span class="s1">dt = </span><span class="s3">0.05</span>
        <span class="s0"># TransferFunction</span>
        <span class="s1">s = dlti([</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[-</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dt=dt)</span>
        <span class="s1">assert_(isinstance(s</span><span class="s2">, </span><span class="s1">TransferFunction))</span>
        <span class="s1">assert_(isinstance(s</span><span class="s2">, </span><span class="s1">dlti))</span>
        <span class="s1">assert_(</span><span class="s2">not </span><span class="s1">isinstance(s</span><span class="s2">, </span><span class="s1">lti))</span>
        <span class="s1">assert_equal(s.dt</span><span class="s2">, </span><span class="s1">dt)</span>

        <span class="s0"># ZerosPolesGain</span>
        <span class="s1">s = dlti(np.array([])</span><span class="s2">, </span><span class="s1">np.array([-</span><span class="s3">1</span><span class="s1">])</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s1">dt=dt)</span>
        <span class="s1">assert_(isinstance(s</span><span class="s2">, </span><span class="s1">ZerosPolesGain))</span>
        <span class="s1">assert_(isinstance(s</span><span class="s2">, </span><span class="s1">dlti))</span>
        <span class="s1">assert_(</span><span class="s2">not </span><span class="s1">isinstance(s</span><span class="s2">, </span><span class="s1">lti))</span>
        <span class="s1">assert_equal(s.dt</span><span class="s2">, </span><span class="s1">dt)</span>

        <span class="s0"># StateSpace</span>
        <span class="s1">s = dlti([</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[-</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s1">dt=dt)</span>
        <span class="s1">assert_(isinstance(s</span><span class="s2">, </span><span class="s1">StateSpace))</span>
        <span class="s1">assert_(isinstance(s</span><span class="s2">, </span><span class="s1">dlti))</span>
        <span class="s1">assert_(</span><span class="s2">not </span><span class="s1">isinstance(s</span><span class="s2">, </span><span class="s1">lti))</span>
        <span class="s1">assert_equal(s.dt</span><span class="s2">, </span><span class="s1">dt)</span>

        <span class="s0"># Number of inputs</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">dlti</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">dlti</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestStateSpaceDisc:</span>
    <span class="s2">def </span><span class="s1">test_initialization(self):</span>
        <span class="s0"># Check that all initializations work</span>
        <span class="s1">dt = </span><span class="s3">0.05</span>
        <span class="s1">StateSpace(</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s1">dt=dt)</span>
        <span class="s1">StateSpace([</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dt=dt)</span>
        <span class="s1">StateSpace(np.array([[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">3</span><span class="s2">, </span><span class="s3">4</span><span class="s1">]])</span><span class="s2">, </span><span class="s1">np.array([[</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">2</span><span class="s1">]])</span><span class="s2">,</span>
                   <span class="s1">np.array([[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]])</span><span class="s2">, </span><span class="s1">np.array([[</span><span class="s3">0</span><span class="s1">]])</span><span class="s2">, </span><span class="s1">dt=dt)</span>
        <span class="s1">StateSpace(</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s1">dt=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_conversion(self):</span>
        <span class="s0"># Check the conversion functions</span>
        <span class="s1">s = StateSpace(</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">4</span><span class="s2">, </span><span class="s1">dt=</span><span class="s3">0.05</span><span class="s1">)</span>
        <span class="s1">assert_(isinstance(s.to_ss()</span><span class="s2">, </span><span class="s1">StateSpace))</span>
        <span class="s1">assert_(isinstance(s.to_tf()</span><span class="s2">, </span><span class="s1">TransferFunction))</span>
        <span class="s1">assert_(isinstance(s.to_zpk()</span><span class="s2">, </span><span class="s1">ZerosPolesGain))</span>

        <span class="s0"># Make sure copies work</span>
        <span class="s1">assert_(StateSpace(s) </span><span class="s2">is not </span><span class="s1">s)</span>
        <span class="s1">assert_(s.to_ss() </span><span class="s2">is not </span><span class="s1">s)</span>

    <span class="s2">def </span><span class="s1">test_properties(self):</span>
        <span class="s0"># Test setters/getters for cross class properties.</span>
        <span class="s0"># This implicitly tests to_tf() and to_zpk()</span>

        <span class="s0"># Getters</span>
        <span class="s1">s = StateSpace(</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s1">dt=</span><span class="s3">0.05</span><span class="s1">)</span>
        <span class="s1">assert_equal(s.poles</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">assert_equal(s.zeros</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s1">])</span>


<span class="s2">class </span><span class="s1">TestTransferFunction:</span>
    <span class="s2">def </span><span class="s1">test_initialization(self):</span>
        <span class="s0"># Check that all initializations work</span>
        <span class="s1">dt = </span><span class="s3">0.05</span>
        <span class="s1">TransferFunction(</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s1">dt=dt)</span>
        <span class="s1">TransferFunction([</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dt=dt)</span>
        <span class="s1">TransferFunction(np.array([</span><span class="s3">1</span><span class="s1">])</span><span class="s2">, </span><span class="s1">np.array([</span><span class="s3">2</span><span class="s1">])</span><span class="s2">, </span><span class="s1">dt=dt)</span>
        <span class="s1">TransferFunction(</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s1">dt=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_conversion(self):</span>
        <span class="s0"># Check the conversion functions</span>
        <span class="s1">s = TransferFunction([</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dt=</span><span class="s3">0.05</span><span class="s1">)</span>
        <span class="s1">assert_(isinstance(s.to_ss()</span><span class="s2">, </span><span class="s1">StateSpace))</span>
        <span class="s1">assert_(isinstance(s.to_tf()</span><span class="s2">, </span><span class="s1">TransferFunction))</span>
        <span class="s1">assert_(isinstance(s.to_zpk()</span><span class="s2">, </span><span class="s1">ZerosPolesGain))</span>

        <span class="s0"># Make sure copies work</span>
        <span class="s1">assert_(TransferFunction(s) </span><span class="s2">is not </span><span class="s1">s)</span>
        <span class="s1">assert_(s.to_tf() </span><span class="s2">is not </span><span class="s1">s)</span>

    <span class="s2">def </span><span class="s1">test_properties(self):</span>
        <span class="s0"># Test setters/getters for cross class properties.</span>
        <span class="s0"># This implicitly tests to_ss() and to_zpk()</span>

        <span class="s0"># Getters</span>
        <span class="s1">s = TransferFunction([</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dt=</span><span class="s3">0.05</span><span class="s1">)</span>
        <span class="s1">assert_equal(s.poles</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">assert_equal(s.zeros</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s1">])</span>


<span class="s2">class </span><span class="s1">TestZerosPolesGain:</span>
    <span class="s2">def </span><span class="s1">test_initialization(self):</span>
        <span class="s0"># Check that all initializations work</span>
        <span class="s1">dt = </span><span class="s3">0.05</span>
        <span class="s1">ZerosPolesGain(</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s1">dt=dt)</span>
        <span class="s1">ZerosPolesGain([</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">2</span><span class="s1">]</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s1">dt=dt)</span>
        <span class="s1">ZerosPolesGain(np.array([</span><span class="s3">1</span><span class="s1">])</span><span class="s2">, </span><span class="s1">np.array([</span><span class="s3">2</span><span class="s1">])</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s1">dt=dt)</span>
        <span class="s1">ZerosPolesGain(</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s1">dt=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_conversion(self):</span>
        <span class="s0"># Check the conversion functions</span>
        <span class="s1">s = ZerosPolesGain(</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s1">dt=</span><span class="s3">0.05</span><span class="s1">)</span>
        <span class="s1">assert_(isinstance(s.to_ss()</span><span class="s2">, </span><span class="s1">StateSpace))</span>
        <span class="s1">assert_(isinstance(s.to_tf()</span><span class="s2">, </span><span class="s1">TransferFunction))</span>
        <span class="s1">assert_(isinstance(s.to_zpk()</span><span class="s2">, </span><span class="s1">ZerosPolesGain))</span>

        <span class="s0"># Make sure copies work</span>
        <span class="s1">assert_(ZerosPolesGain(s) </span><span class="s2">is not </span><span class="s1">s)</span>
        <span class="s1">assert_(s.to_zpk() </span><span class="s2">is not </span><span class="s1">s)</span>


<span class="s2">class </span><span class="s1">Test_dfreqresp:</span>

    <span class="s2">def </span><span class="s1">test_manual(self):</span>
        <span class="s0"># Test dfreqresp() real part calculation (manual sanity check).</span>
        <span class="s0"># 1st order low-pass filter: H(z) = 1 / (z - 0.2),</span>
        <span class="s1">system = TransferFunction(</span><span class="s3">1</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dt=</span><span class="s3">0.1</span><span class="s1">)</span>
        <span class="s1">w = [</span><span class="s3">0.1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">10</span><span class="s1">]</span>
        <span class="s1">w</span><span class="s2">, </span><span class="s1">H = dfreqresp(system</span><span class="s2">, </span><span class="s1">w=w)</span>

        <span class="s0"># test real</span>
        <span class="s1">expected_re = [</span><span class="s3">1.2383</span><span class="s2">, </span><span class="s3">0.4130</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.7553</span><span class="s1">]</span>
        <span class="s1">assert_almost_equal(H.real</span><span class="s2">, </span><span class="s1">expected_re</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s3">4</span><span class="s1">)</span>

        <span class="s0"># test imag</span>
        <span class="s1">expected_im = [-</span><span class="s3">0.1555</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1.0214</span><span class="s2">, </span><span class="s3">0.3955</span><span class="s1">]</span>
        <span class="s1">assert_almost_equal(H.imag</span><span class="s2">, </span><span class="s1">expected_im</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s3">4</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_auto(self):</span>
        <span class="s0"># Test dfreqresp() real part calculation.</span>
        <span class="s0"># 1st order low-pass filter: H(z) = 1 / (z - 0.2),</span>
        <span class="s1">system = TransferFunction(</span><span class="s3">1</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dt=</span><span class="s3">0.1</span><span class="s1">)</span>
        <span class="s1">w = [</span><span class="s3">0.1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">10</span><span class="s2">, </span><span class="s3">100</span><span class="s1">]</span>
        <span class="s1">w</span><span class="s2">, </span><span class="s1">H = dfreqresp(system</span><span class="s2">, </span><span class="s1">w=w)</span>
        <span class="s1">jw = np.exp(w * </span><span class="s3">1j</span><span class="s1">)</span>
        <span class="s1">y = np.polyval(system.num</span><span class="s2">, </span><span class="s1">jw) / np.polyval(system.den</span><span class="s2">, </span><span class="s1">jw)</span>

        <span class="s0"># test real</span>
        <span class="s1">expected_re = y.real</span>
        <span class="s1">assert_almost_equal(H.real</span><span class="s2">, </span><span class="s1">expected_re)</span>

        <span class="s0"># test imag</span>
        <span class="s1">expected_im = y.imag</span>
        <span class="s1">assert_almost_equal(H.imag</span><span class="s2">, </span><span class="s1">expected_im)</span>

    <span class="s2">def </span><span class="s1">test_freq_range(self):</span>
        <span class="s0"># Test that freqresp() finds a reasonable frequency range.</span>
        <span class="s0"># 1st order low-pass filter: H(z) = 1 / (z - 0.2),</span>
        <span class="s0"># Expected range is from 0.01 to 10.</span>
        <span class="s1">system = TransferFunction(</span><span class="s3">1</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dt=</span><span class="s3">0.1</span><span class="s1">)</span>
        <span class="s1">n = </span><span class="s3">10</span>
        <span class="s1">expected_w = np.linspace(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">np.pi</span><span class="s2">, </span><span class="s3">10</span><span class="s2">, </span><span class="s1">endpoint=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">w</span><span class="s2">, </span><span class="s1">H = dfreqresp(system</span><span class="s2">, </span><span class="s1">n=n)</span>
        <span class="s1">assert_almost_equal(w</span><span class="s2">, </span><span class="s1">expected_w)</span>

    <span class="s2">def </span><span class="s1">test_pole_one(self):</span>
        <span class="s0"># Test that freqresp() doesn't fail on a system with a pole at 0.</span>
        <span class="s0"># integrator, pole at zero: H(s) = 1 / s</span>
        <span class="s1">system = TransferFunction([</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dt=</span><span class="s3">0.1</span><span class="s1">)</span>

        <span class="s2">with </span><span class="s1">suppress_warnings() </span><span class="s2">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(RuntimeWarning</span><span class="s2">, </span><span class="s1">message=</span><span class="s4">&quot;divide by zero&quot;</span><span class="s1">)</span>
            <span class="s1">sup.filter(RuntimeWarning</span><span class="s2">, </span><span class="s1">message=</span><span class="s4">&quot;invalid value encountered&quot;</span><span class="s1">)</span>
            <span class="s1">w</span><span class="s2">, </span><span class="s1">H = dfreqresp(system</span><span class="s2">, </span><span class="s1">n=</span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">assert_equal(w[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s3">0.</span><span class="s1">)  </span><span class="s0"># a fail would give not-a-number</span>

    <span class="s2">def </span><span class="s1">test_error(self):</span>
        <span class="s0"># Raise an error for continuous-time systems</span>
        <span class="s1">system = lti([</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">assert_raises(AttributeError</span><span class="s2">, </span><span class="s1">dfreqresp</span><span class="s2">, </span><span class="s1">system)</span>

    <span class="s2">def </span><span class="s1">test_from_state_space(self):</span>
        <span class="s0"># H(z) = 2 / z^3 - 0.5 * z^2</span>

        <span class="s1">system_TF = dlti([</span><span class="s3">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.5</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">])</span>

        <span class="s1">A = np.array([[</span><span class="s3">0.5</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]])</span>
        <span class="s1">B = np.array([[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]]).T</span>
        <span class="s1">C = np.array([[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">2</span><span class="s1">]])</span>
        <span class="s1">D = </span><span class="s3">0</span>

        <span class="s1">system_SS = dlti(A</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, </span><span class="s1">C</span><span class="s2">, </span><span class="s1">D)</span>
        <span class="s1">w = </span><span class="s3">10.0</span><span class="s1">**np.arange(-</span><span class="s3">3</span><span class="s2">,</span><span class="s3">0</span><span class="s2">,</span><span class="s3">.5</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">suppress_warnings() </span><span class="s2">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(BadCoefficients)</span>
            <span class="s1">w1</span><span class="s2">, </span><span class="s1">H1 = dfreqresp(system_TF</span><span class="s2">, </span><span class="s1">w=w)</span>
            <span class="s1">w2</span><span class="s2">, </span><span class="s1">H2 = dfreqresp(system_SS</span><span class="s2">, </span><span class="s1">w=w)</span>

        <span class="s1">assert_almost_equal(H1</span><span class="s2">, </span><span class="s1">H2)</span>

    <span class="s2">def </span><span class="s1">test_from_zpk(self):</span>
        <span class="s0"># 1st order low-pass filter: H(s) = 0.3 / (z - 0.2),</span>
        <span class="s1">system_ZPK = dlti([]</span><span class="s2">,</span><span class="s1">[</span><span class="s3">0.2</span><span class="s1">]</span><span class="s2">,</span><span class="s3">0.3</span><span class="s1">)</span>
        <span class="s1">system_TF = dlti(</span><span class="s3">0.3</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.2</span><span class="s1">])</span>
        <span class="s1">w = [</span><span class="s3">0.1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">10</span><span class="s2">, </span><span class="s3">100</span><span class="s1">]</span>
        <span class="s1">w1</span><span class="s2">, </span><span class="s1">H1 = dfreqresp(system_ZPK</span><span class="s2">, </span><span class="s1">w=w)</span>
        <span class="s1">w2</span><span class="s2">, </span><span class="s1">H2 = dfreqresp(system_TF</span><span class="s2">, </span><span class="s1">w=w)</span>
        <span class="s1">assert_almost_equal(H1</span><span class="s2">, </span><span class="s1">H2)</span>


<span class="s2">class </span><span class="s1">Test_bode:</span>

    <span class="s2">def </span><span class="s1">test_manual(self):</span>
        <span class="s0"># Test bode() magnitude calculation (manual sanity check).</span>
        <span class="s0"># 1st order low-pass filter: H(s) = 0.3 / (z - 0.2),</span>
        <span class="s1">dt = </span><span class="s3">0.1</span>
        <span class="s1">system = TransferFunction(</span><span class="s3">0.3</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dt=dt)</span>
        <span class="s1">w = [</span><span class="s3">0.1</span><span class="s2">, </span><span class="s3">0.5</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s1">np.pi]</span>
        <span class="s1">w2</span><span class="s2">, </span><span class="s1">mag</span><span class="s2">, </span><span class="s1">phase = dbode(system</span><span class="s2">, </span><span class="s1">w=w)</span>

        <span class="s0"># Test mag</span>
        <span class="s1">expected_mag = [-</span><span class="s3">8.5329</span><span class="s2">, </span><span class="s1">-</span><span class="s3">8.8396</span><span class="s2">, </span><span class="s1">-</span><span class="s3">9.6162</span><span class="s2">, </span><span class="s1">-</span><span class="s3">12.0412</span><span class="s1">]</span>
        <span class="s1">assert_almost_equal(mag</span><span class="s2">, </span><span class="s1">expected_mag</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s3">4</span><span class="s1">)</span>

        <span class="s0"># Test phase</span>
        <span class="s1">expected_phase = [-</span><span class="s3">7.1575</span><span class="s2">, </span><span class="s1">-</span><span class="s3">35.2814</span><span class="s2">, </span><span class="s1">-</span><span class="s3">67.9809</span><span class="s2">, </span><span class="s1">-</span><span class="s3">180.0000</span><span class="s1">]</span>
        <span class="s1">assert_almost_equal(phase</span><span class="s2">, </span><span class="s1">expected_phase</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s3">4</span><span class="s1">)</span>

        <span class="s0"># Test frequency</span>
        <span class="s1">assert_equal(np.array(w) / dt</span><span class="s2">, </span><span class="s1">w2)</span>

    <span class="s2">def </span><span class="s1">test_auto(self):</span>
        <span class="s0"># Test bode() magnitude calculation.</span>
        <span class="s0"># 1st order low-pass filter: H(s) = 0.3 / (z - 0.2),</span>
        <span class="s1">system = TransferFunction(</span><span class="s3">0.3</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dt=</span><span class="s3">0.1</span><span class="s1">)</span>
        <span class="s1">w = np.array([</span><span class="s3">0.1</span><span class="s2">, </span><span class="s3">0.5</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s1">np.pi])</span>
        <span class="s1">w2</span><span class="s2">, </span><span class="s1">mag</span><span class="s2">, </span><span class="s1">phase = dbode(system</span><span class="s2">, </span><span class="s1">w=w)</span>
        <span class="s1">jw = np.exp(w * </span><span class="s3">1j</span><span class="s1">)</span>
        <span class="s1">y = np.polyval(system.num</span><span class="s2">, </span><span class="s1">jw) / np.polyval(system.den</span><span class="s2">, </span><span class="s1">jw)</span>

        <span class="s0"># Test mag</span>
        <span class="s1">expected_mag = </span><span class="s3">20.0 </span><span class="s1">* np.log10(abs(y))</span>
        <span class="s1">assert_almost_equal(mag</span><span class="s2">, </span><span class="s1">expected_mag)</span>

        <span class="s0"># Test phase</span>
        <span class="s1">expected_phase = np.rad2deg(np.angle(y))</span>
        <span class="s1">assert_almost_equal(phase</span><span class="s2">, </span><span class="s1">expected_phase)</span>

    <span class="s2">def </span><span class="s1">test_range(self):</span>
        <span class="s0"># Test that bode() finds a reasonable frequency range.</span>
        <span class="s0"># 1st order low-pass filter: H(s) = 0.3 / (z - 0.2),</span>
        <span class="s1">dt = </span><span class="s3">0.1</span>
        <span class="s1">system = TransferFunction(</span><span class="s3">0.3</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dt=</span><span class="s3">0.1</span><span class="s1">)</span>
        <span class="s1">n = </span><span class="s3">10</span>
        <span class="s0"># Expected range is from 0.01 to 10.</span>
        <span class="s1">expected_w = np.linspace(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">np.pi</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">endpoint=</span><span class="s2">False</span><span class="s1">) / dt</span>
        <span class="s1">w</span><span class="s2">, </span><span class="s1">mag</span><span class="s2">, </span><span class="s1">phase = dbode(system</span><span class="s2">, </span><span class="s1">n=n)</span>
        <span class="s1">assert_almost_equal(w</span><span class="s2">, </span><span class="s1">expected_w)</span>

    <span class="s2">def </span><span class="s1">test_pole_one(self):</span>
        <span class="s0"># Test that freqresp() doesn't fail on a system with a pole at 0.</span>
        <span class="s0"># integrator, pole at zero: H(s) = 1 / s</span>
        <span class="s1">system = TransferFunction([</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dt=</span><span class="s3">0.1</span><span class="s1">)</span>

        <span class="s2">with </span><span class="s1">suppress_warnings() </span><span class="s2">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(RuntimeWarning</span><span class="s2">, </span><span class="s1">message=</span><span class="s4">&quot;divide by zero&quot;</span><span class="s1">)</span>
            <span class="s1">sup.filter(RuntimeWarning</span><span class="s2">, </span><span class="s1">message=</span><span class="s4">&quot;invalid value encountered&quot;</span><span class="s1">)</span>
            <span class="s1">w</span><span class="s2">, </span><span class="s1">mag</span><span class="s2">, </span><span class="s1">phase = dbode(system</span><span class="s2">, </span><span class="s1">n=</span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">assert_equal(w[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s3">0.</span><span class="s1">)  </span><span class="s0"># a fail would give not-a-number</span>

    <span class="s2">def </span><span class="s1">test_imaginary(self):</span>
        <span class="s0"># bode() should not fail on a system with pure imaginary poles.</span>
        <span class="s0"># The test passes if bode doesn't raise an exception.</span>
        <span class="s1">system = TransferFunction([</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">100</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dt=</span><span class="s3">0.1</span><span class="s1">)</span>
        <span class="s1">dbode(system</span><span class="s2">, </span><span class="s1">n=</span><span class="s3">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_error(self):</span>
        <span class="s0"># Raise an error for continuous-time systems</span>
        <span class="s1">system = lti([</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">assert_raises(AttributeError</span><span class="s2">, </span><span class="s1">dbode</span><span class="s2">, </span><span class="s1">system)</span>


<span class="s2">class </span><span class="s1">TestTransferFunctionZConversion:</span>
    <span class="s5">&quot;&quot;&quot;Test private conversions between 'z' and 'z**-1' polynomials.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">test_full(self):</span>
        <span class="s0"># Numerator and denominator same order</span>
        <span class="s1">num = [</span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">4</span><span class="s1">]</span>
        <span class="s1">den = [</span><span class="s3">5</span><span class="s2">, </span><span class="s3">6</span><span class="s2">, </span><span class="s3">7</span><span class="s1">]</span>
        <span class="s1">num2</span><span class="s2">, </span><span class="s1">den2 = TransferFunction._z_to_zinv(num</span><span class="s2">, </span><span class="s1">den)</span>
        <span class="s1">assert_equal(num</span><span class="s2">, </span><span class="s1">num2)</span>
        <span class="s1">assert_equal(den</span><span class="s2">, </span><span class="s1">den2)</span>

        <span class="s1">num2</span><span class="s2">, </span><span class="s1">den2 = TransferFunction._zinv_to_z(num</span><span class="s2">, </span><span class="s1">den)</span>
        <span class="s1">assert_equal(num</span><span class="s2">, </span><span class="s1">num2)</span>
        <span class="s1">assert_equal(den</span><span class="s2">, </span><span class="s1">den2)</span>

    <span class="s2">def </span><span class="s1">test_numerator(self):</span>
        <span class="s0"># Numerator lower order than denominator</span>
        <span class="s1">num = [</span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s1">]</span>
        <span class="s1">den = [</span><span class="s3">5</span><span class="s2">, </span><span class="s3">6</span><span class="s2">, </span><span class="s3">7</span><span class="s1">]</span>
        <span class="s1">num2</span><span class="s2">, </span><span class="s1">den2 = TransferFunction._z_to_zinv(num</span><span class="s2">, </span><span class="s1">den)</span>
        <span class="s1">assert_equal([</span><span class="s3">0</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">num2)</span>
        <span class="s1">assert_equal(den</span><span class="s2">, </span><span class="s1">den2)</span>

        <span class="s1">num2</span><span class="s2">, </span><span class="s1">den2 = TransferFunction._zinv_to_z(num</span><span class="s2">, </span><span class="s1">den)</span>
        <span class="s1">assert_equal([</span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">num2)</span>
        <span class="s1">assert_equal(den</span><span class="s2">, </span><span class="s1">den2)</span>

    <span class="s2">def </span><span class="s1">test_denominator(self):</span>
        <span class="s0"># Numerator higher order than denominator</span>
        <span class="s1">num = [</span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">4</span><span class="s1">]</span>
        <span class="s1">den = [</span><span class="s3">5</span><span class="s2">, </span><span class="s3">6</span><span class="s1">]</span>
        <span class="s1">num2</span><span class="s2">, </span><span class="s1">den2 = TransferFunction._z_to_zinv(num</span><span class="s2">, </span><span class="s1">den)</span>
        <span class="s1">assert_equal(num</span><span class="s2">, </span><span class="s1">num2)</span>
        <span class="s1">assert_equal([</span><span class="s3">0</span><span class="s2">, </span><span class="s3">5</span><span class="s2">, </span><span class="s3">6</span><span class="s1">]</span><span class="s2">, </span><span class="s1">den2)</span>

        <span class="s1">num2</span><span class="s2">, </span><span class="s1">den2 = TransferFunction._zinv_to_z(num</span><span class="s2">, </span><span class="s1">den)</span>
        <span class="s1">assert_equal(num</span><span class="s2">, </span><span class="s1">num2)</span>
        <span class="s1">assert_equal([</span><span class="s3">5</span><span class="s2">, </span><span class="s3">6</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">den2)</span>

</pre>
</body>
</html>