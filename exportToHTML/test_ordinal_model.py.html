<html>
<head>
<title>test_ordinal_model.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_ordinal_model.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Test  for ordinal models 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">numpy.testing </span><span class="s2">import </span><span class="s1">assert_allclose</span><span class="s2">, </span><span class="s1">assert_equal</span>
<span class="s2">import </span><span class="s1">pandas </span><span class="s2">as </span><span class="s1">pd</span>
<span class="s2">import </span><span class="s1">pytest</span>
<span class="s2">import </span><span class="s1">scipy.stats </span><span class="s2">as </span><span class="s1">stats</span>

<span class="s2">from </span><span class="s1">statsmodels.discrete.discrete_model </span><span class="s2">import </span><span class="s1">Logit</span>
<span class="s2">from </span><span class="s1">statsmodels.miscmodels.ordinal_model </span><span class="s2">import </span><span class="s1">OrderedModel</span>
<span class="s2">from </span><span class="s1">statsmodels.tools.sm_exceptions </span><span class="s2">import </span><span class="s1">HessianInversionWarning</span>
<span class="s2">from </span><span class="s1">statsmodels.tools.tools </span><span class="s2">import </span><span class="s1">add_constant</span>

<span class="s2">from </span><span class="s1">.results.results_ordinal_model </span><span class="s2">import </span><span class="s1">data_store </span><span class="s2">as </span><span class="s1">ds</span>


<span class="s2">class </span><span class="s1">CheckOrdinalModelMixin:</span>

    <span class="s2">def </span><span class="s1">test_basic(self):</span>
        <span class="s3"># checks basic results againt R MASS package</span>
        <span class="s1">n_cat = ds.n_ordinal_cat</span>
        <span class="s1">res1 = self.res1</span>
        <span class="s1">res2 = self.res2</span>
        <span class="s3"># coefficients values, standard errors, t &amp; p values</span>
        <span class="s1">assert_allclose(res1.params[:-n_cat + </span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">res2.coefficients_val</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">2e-4</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res1.bse[:-n_cat + </span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">res2.coefficients_stdE</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.003</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-5</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res1.tvalues[:-n_cat + </span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">res2.coefficients_tval</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.003</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">7e-4</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res1.pvalues[:-n_cat + </span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">res2.coefficients_pval</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.009</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-5</span><span class="s1">)</span>
        <span class="s3"># thresholds are given with exponentiated increments</span>
        <span class="s3"># from the first threshold</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">res1.model.transform_threshold_params(res1.params)[</span><span class="s4">1</span><span class="s1">:-</span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">res2.thresholds</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">4e-4</span><span class="s1">)</span>

        <span class="s3"># probabilities</span>
        <span class="s1">assert_allclose(res1.predict()[:</span><span class="s4">7</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">,</span>
                        <span class="s1">res2.prob_pred</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">5e-5</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_pandas(self):</span>
        <span class="s3"># makes sure that the Pandas ecosystem is supported</span>
        <span class="s1">res1 = self.res1</span>
        <span class="s1">resp = self.resp</span>
        <span class="s3"># converges slightly differently why?</span>
        <span class="s1">assert_allclose(res1.params</span><span class="s2">, </span><span class="s1">resp.params</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-10</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res1.bse</span><span class="s2">, </span><span class="s1">resp.bse</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-10</span><span class="s1">)</span>

        <span class="s1">assert_allclose(res1.model.endog</span><span class="s2">, </span><span class="s1">resp.model.endog</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-10</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res1.model.exog</span><span class="s2">, </span><span class="s1">resp.model.exog</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-10</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_formula(self):</span>
        <span class="s3"># makes sure the &quot;R-way&quot; of writing models is supported</span>
        <span class="s1">res1 = self.res1</span>
        <span class="s1">resf = self.resf</span>
        <span class="s3"># converges slightly differently why? yet e-5 is ok</span>
        <span class="s1">assert_allclose(res1.params</span><span class="s2">, </span><span class="s1">resf.params</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">5e-5</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res1.bse</span><span class="s2">, </span><span class="s1">resf.bse</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">5e-5</span><span class="s1">)</span>

        <span class="s1">assert_allclose(res1.model.endog</span><span class="s2">, </span><span class="s1">resf.model.endog</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-10</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res1.model.exog</span><span class="s2">, </span><span class="s1">resf.model.exog</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-10</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_unordered(self):</span>
        <span class="s3"># makes sure that ordered = True is optional for the endog Serie</span>
        <span class="s3"># et categories have to be set in the right order</span>
        <span class="s1">res1 = self.res1</span>
        <span class="s1">resf = self.resu</span>
        <span class="s3"># converges slightly differently why?</span>
        <span class="s1">assert_allclose(res1.params</span><span class="s2">, </span><span class="s1">resf.params</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-10</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res1.bse</span><span class="s2">, </span><span class="s1">resf.bse</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-10</span><span class="s1">)</span>

        <span class="s1">assert_allclose(res1.model.endog</span><span class="s2">, </span><span class="s1">resf.model.endog</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-10</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res1.model.exog</span><span class="s2">, </span><span class="s1">resf.model.exog</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-10</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_results_other(self):</span>

        <span class="s1">res1 = self.res1  </span><span class="s3"># numpy</span>
        <span class="s1">resp = self.resp  </span><span class="s3"># pandas</span>

        <span class="s1">param_names_np = [</span><span class="s5">'x1'</span><span class="s2">, </span><span class="s5">'x2'</span><span class="s2">, </span><span class="s5">'x3'</span><span class="s2">, </span><span class="s5">'0/1'</span><span class="s2">, </span><span class="s5">'1/2'</span><span class="s1">]</span>
        <span class="s1">param_names_pd = [</span><span class="s5">'pared'</span><span class="s2">, </span><span class="s5">'public'</span><span class="s2">, </span><span class="s5">'gpa'</span><span class="s2">, </span><span class="s5">'unlikely/somewhat likely'</span><span class="s2">,</span>
                          <span class="s5">'somewhat likely/very likely'</span><span class="s1">]</span>

        <span class="s2">assert </span><span class="s1">res1.model.data.param_names == param_names_np</span>
        <span class="s2">assert </span><span class="s1">self.resp.model.data.param_names == param_names_pd</span>
        <span class="s2">assert </span><span class="s1">self.resp.model.endog_names == </span><span class="s5">&quot;apply&quot;</span>

        <span class="s3"># results</span>
        <span class="s2">if </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s5">&quot;pred_table&quot;</span><span class="s1">):</span>
            <span class="s1">table = res1.pred_table()</span>
            <span class="s1">assert_equal(table.values</span><span class="s2">, </span><span class="s1">self.pred_table)</span>

        <span class="s3"># smoke test</span>
        <span class="s1">res1.summary()</span>

        <span class="s3"># inherited</span>
        <span class="s1">tt = res1.t_test(np.eye(len(res1.params)))</span>
        <span class="s1">assert_allclose(tt.pvalue</span><span class="s2">, </span><span class="s1">res1.pvalues</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-13</span><span class="s1">)</span>

        <span class="s1">tt = resp.t_test([</span><span class="s5">'pared'</span><span class="s2">, </span><span class="s5">'public'</span><span class="s2">, </span><span class="s5">'gpa'</span><span class="s1">])  </span><span class="s3"># pandas names</span>
        <span class="s1">assert_allclose(tt.pvalue</span><span class="s2">, </span><span class="s1">res1.pvalues[:</span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-13</span><span class="s1">)</span>

        <span class="s1">pred = res1.predict(exog=res1.model.exog[-</span><span class="s4">5</span><span class="s1">:])</span>
        <span class="s1">fitted = res1.predict()</span>
        <span class="s1">assert_allclose(pred</span><span class="s2">, </span><span class="s1">fitted[-</span><span class="s4">5</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-13</span><span class="s1">)</span>

        <span class="s1">pred = resp.predict(exog=resp.model.data.orig_exog.iloc[-</span><span class="s4">5</span><span class="s1">:])</span>
        <span class="s1">fitted = resp.predict()</span>
        <span class="s1">assert_allclose(pred</span><span class="s2">, </span><span class="s1">fitted[-</span><span class="s4">5</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-13</span><span class="s1">)</span>

        <span class="s1">dataf = self.resf.model.data.frame  </span><span class="s3"># is a dict</span>
        <span class="s1">dataf_df = pd.DataFrame.from_dict(dataf)</span>
        <span class="s1">pred = self.resf.predict(exog=dataf_df.iloc[-</span><span class="s4">5</span><span class="s1">:])</span>
        <span class="s1">fitted = self.resf.predict()</span>
        <span class="s1">assert_allclose(pred</span><span class="s2">, </span><span class="s1">fitted[-</span><span class="s4">5</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-13</span><span class="s1">)</span>

        <span class="s1">n</span><span class="s2">, </span><span class="s1">k = res1.model.exog.shape</span>
        <span class="s1">assert_equal(self.resf.df_resid</span><span class="s2">, </span><span class="s1">n - (k + </span><span class="s4">2</span><span class="s1">))</span>

        <span class="s3"># check wrapper</span>
        <span class="s2">assert </span><span class="s1">resp.params.index.tolist() == resp.model.exog_names</span>
        <span class="s2">assert </span><span class="s1">resp.bse.index.tolist() == resp.model.exog_names</span>


<span class="s2">class </span><span class="s1">TestLogitModel(CheckOrdinalModelMixin):</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">data = ds.df</span>
        <span class="s1">data_unordered = ds.df_unordered</span>

        <span class="s3"># standard fit</span>
        <span class="s1">mod = OrderedModel(data[</span><span class="s5">'apply'</span><span class="s1">].values.codes</span><span class="s2">,</span>
                           <span class="s1">np.asarray(data[[</span><span class="s5">'pared'</span><span class="s2">, </span><span class="s5">'public'</span><span class="s2">, </span><span class="s5">'gpa'</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">float)</span><span class="s2">,</span>
                           <span class="s1">distr=</span><span class="s5">'logit'</span><span class="s1">)</span>
        <span class="s1">res = mod.fit(method=</span><span class="s5">'bfgs'</span><span class="s2">, </span><span class="s1">disp=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s3"># standard fit with pandas input</span>
        <span class="s1">modp = OrderedModel(data[</span><span class="s5">'apply'</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">data[[</span><span class="s5">'pared'</span><span class="s2">, </span><span class="s5">'public'</span><span class="s2">, </span><span class="s5">'gpa'</span><span class="s1">]]</span><span class="s2">,</span>
                            <span class="s1">distr=</span><span class="s5">'logit'</span><span class="s1">)</span>
        <span class="s1">resp = modp.fit(method=</span><span class="s5">'bfgs'</span><span class="s2">, </span><span class="s1">disp=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s3"># fit with formula</span>
        <span class="s1">modf = OrderedModel.from_formula(</span>
            <span class="s5">&quot;apply ~ pared + public + gpa - 1&quot;</span><span class="s2">,</span>
            <span class="s1">data={</span><span class="s5">&quot;apply&quot;</span><span class="s1">: data[</span><span class="s5">'apply'</span><span class="s1">].values.codes</span><span class="s2">,</span>
                  <span class="s5">&quot;pared&quot;</span><span class="s1">: data[</span><span class="s5">'pared'</span><span class="s1">]</span><span class="s2">,</span>
                  <span class="s5">&quot;public&quot;</span><span class="s1">: data[</span><span class="s5">'public'</span><span class="s1">]</span><span class="s2">,</span>
                  <span class="s5">&quot;gpa&quot;</span><span class="s1">: data[</span><span class="s5">'gpa'</span><span class="s1">]}</span><span class="s2">,</span>
            <span class="s1">distr=</span><span class="s5">'logit'</span><span class="s1">)</span>
        <span class="s1">resf = modf.fit(method=</span><span class="s5">'bfgs'</span><span class="s2">, </span><span class="s1">disp=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s3"># fit on data with ordered=False</span>
        <span class="s1">modu = OrderedModel(</span>
            <span class="s1">data_unordered[</span><span class="s5">'apply'</span><span class="s1">].values.codes</span><span class="s2">,</span>
            <span class="s1">np.asarray(data_unordered[[</span><span class="s5">'pared'</span><span class="s2">, </span><span class="s5">'public'</span><span class="s2">, </span><span class="s5">'gpa'</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">float)</span><span class="s2">,</span>
            <span class="s1">distr=</span><span class="s5">'logit'</span><span class="s1">)</span>
        <span class="s1">resu = modu.fit(method=</span><span class="s5">'bfgs'</span><span class="s2">, </span><span class="s1">disp=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s2">from </span><span class="s1">.results.results_ordinal_model </span><span class="s2">import </span><span class="s1">res_ord_logit </span><span class="s2">as </span><span class="s1">res2</span>
        <span class="s1">cls.res2 = res2</span>
        <span class="s1">cls.res1 = res</span>
        <span class="s1">cls.resp = resp</span>
        <span class="s1">cls.resf = resf</span>
        <span class="s1">cls.resu = resu</span>

    <span class="s2">def </span><span class="s1">test_postestimation(self):</span>
        <span class="s1">res1 = self.res1</span>
        <span class="s1">res2 = self.res2</span>
        <span class="s1">resid_prob = res1.resid_prob</span>

        <span class="s1">assert_allclose(resid_prob[:len(res2.resid_prob)]</span><span class="s2">, </span><span class="s1">res2.resid_prob</span><span class="s2">,</span>
                        <span class="s1">atol=</span><span class="s4">1e-4</span><span class="s1">)</span>
        <span class="s1">stats_prob = [resid_prob.mean()</span><span class="s2">, </span><span class="s1">resid_prob.min()</span><span class="s2">, </span><span class="s1">resid_prob.max()</span><span class="s2">,</span>
                      <span class="s1">resid_prob.var(ddof=</span><span class="s4">1</span><span class="s1">)]</span>
        <span class="s1">assert_allclose(stats_prob</span><span class="s2">, </span><span class="s1">res2.resid_prob_stats</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-5</span><span class="s1">)</span>

        <span class="s3"># from R generalhoslem</span>
        <span class="s3"># &gt; logitgof(ologit_ucla$apply2, fitted(r_logit), g = 10, ord = TRUE)</span>
        <span class="s1">chi2 = </span><span class="s4">20.958760713111</span>
        <span class="s1">df = </span><span class="s4">17</span>
        <span class="s1">p_value = </span><span class="s4">0.2281403796588</span>
        <span class="s3"># values in Stata using ologitgof are a bit different,</span>
        <span class="s3"># I guess different sort algorithm and because of ties, see #7095</span>

        <span class="s2">import </span><span class="s1">statsmodels.stats.diagnostic_gen </span><span class="s2">as </span><span class="s1">dia</span>

        <span class="s3"># TODO: add more properties or methods to Results class</span>
        <span class="s1">fitted = res1.predict()</span>
        <span class="s1">y_dummy = (res1.model.endog[:</span><span class="s2">, None</span><span class="s1">] == np.arange(</span><span class="s4">3</span><span class="s1">)).astype(int)</span>
        <span class="s1">sv = (fitted * np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s1">+</span><span class="s4">1</span><span class="s1">)).sum(</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">dt = dia.test_chisquare_binning(</span>
            <span class="s1">y_dummy</span><span class="s2">, </span><span class="s1">fitted</span><span class="s2">, </span><span class="s1">sort_var=sv</span><span class="s2">, </span><span class="s1">bins=</span><span class="s4">10</span><span class="s2">, </span><span class="s1">df=</span><span class="s2">None, </span><span class="s1">ordered=</span><span class="s2">True,</span>
            <span class="s1">sort_method=</span><span class="s5">&quot;stable&quot;</span><span class="s1">)</span>
        <span class="s1">assert_allclose(dt.statistic</span><span class="s2">, </span><span class="s1">chi2</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">5e-5</span><span class="s1">)</span>
        <span class="s1">assert_allclose(dt.pvalue</span><span class="s2">, </span><span class="s1">p_value</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-4</span><span class="s1">)</span>
        <span class="s1">assert_equal(dt.df</span><span class="s2">, </span><span class="s1">df)</span>


<span class="s2">class </span><span class="s1">TestProbitModel(CheckOrdinalModelMixin):</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">data = ds.df</span>
        <span class="s1">data_unordered = ds.df_unordered</span>

        <span class="s1">mod = OrderedModel(data[</span><span class="s5">'apply'</span><span class="s1">].values.codes</span><span class="s2">,</span>
                           <span class="s1">np.asarray(data[[</span><span class="s5">'pared'</span><span class="s2">, </span><span class="s5">'public'</span><span class="s2">, </span><span class="s5">'gpa'</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">float)</span><span class="s2">,</span>
                           <span class="s1">distr=</span><span class="s5">'probit'</span><span class="s1">)</span>
        <span class="s1">res = mod.fit(method=</span><span class="s5">'bfgs'</span><span class="s2">, </span><span class="s1">disp=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s1">modp = OrderedModel(data[</span><span class="s5">'apply'</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">data[[</span><span class="s5">'pared'</span><span class="s2">, </span><span class="s5">'public'</span><span class="s2">, </span><span class="s5">'gpa'</span><span class="s1">]]</span><span class="s2">,</span>
                            <span class="s1">distr=</span><span class="s5">'probit'</span><span class="s1">)</span>
        <span class="s1">resp = modp.fit(method=</span><span class="s5">'bfgs'</span><span class="s2">, </span><span class="s1">disp=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s1">modf = OrderedModel.from_formula(</span>
            <span class="s5">&quot;apply ~ pared + public + gpa - 1&quot;</span><span class="s2">,</span>
            <span class="s1">data={</span><span class="s5">&quot;apply&quot;</span><span class="s1">: data[</span><span class="s5">'apply'</span><span class="s1">].values.codes</span><span class="s2">,</span>
                  <span class="s5">&quot;pared&quot;</span><span class="s1">: data[</span><span class="s5">'pared'</span><span class="s1">]</span><span class="s2">,</span>
                  <span class="s5">&quot;public&quot;</span><span class="s1">: data[</span><span class="s5">'public'</span><span class="s1">]</span><span class="s2">,</span>
                  <span class="s5">&quot;gpa&quot;</span><span class="s1">: data[</span><span class="s5">'gpa'</span><span class="s1">]}</span><span class="s2">,</span>
            <span class="s1">distr=</span><span class="s5">'probit'</span><span class="s1">)</span>
        <span class="s1">resf = modf.fit(method=</span><span class="s5">'bfgs'</span><span class="s2">, </span><span class="s1">disp=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s1">modu = OrderedModel(</span>
            <span class="s1">data_unordered[</span><span class="s5">'apply'</span><span class="s1">].values.codes</span><span class="s2">,</span>
            <span class="s1">np.asarray(data_unordered[[</span><span class="s5">'pared'</span><span class="s2">, </span><span class="s5">'public'</span><span class="s2">, </span><span class="s5">'gpa'</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">float)</span><span class="s2">,</span>
            <span class="s1">distr=</span><span class="s5">'probit'</span><span class="s1">)</span>
        <span class="s1">resu = modu.fit(method=</span><span class="s5">'bfgs'</span><span class="s2">, </span><span class="s1">disp=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s2">from </span><span class="s1">.results.results_ordinal_model </span><span class="s2">import </span><span class="s1">res_ord_probit </span><span class="s2">as </span><span class="s1">res2</span>
        <span class="s1">cls.res2 = res2</span>
        <span class="s1">cls.res1 = res</span>
        <span class="s1">cls.resp = resp</span>
        <span class="s1">cls.resf = resf</span>
        <span class="s1">cls.resu = resu</span>

        <span class="s3"># regression numbers</span>
        <span class="s1">cls.pred_table = np.array([[</span><span class="s4">202</span><span class="s2">,  </span><span class="s4">18</span><span class="s2">,   </span><span class="s4">0</span><span class="s2">, </span><span class="s4">220</span><span class="s1">]</span><span class="s2">,</span>
                                   <span class="s1">[</span><span class="s4">112</span><span class="s2">,  </span><span class="s4">28</span><span class="s2">,   </span><span class="s4">0</span><span class="s2">, </span><span class="s4">140</span><span class="s1">]</span><span class="s2">,</span>
                                   <span class="s1">[ </span><span class="s4">27</span><span class="s2">,  </span><span class="s4">13</span><span class="s2">,   </span><span class="s4">0</span><span class="s2">,  </span><span class="s4">40</span><span class="s1">]</span><span class="s2">,  </span><span class="s3"># noqa</span>
                                   <span class="s1">[</span><span class="s4">341</span><span class="s2">,  </span><span class="s4">59</span><span class="s2">,   </span><span class="s4">0</span><span class="s2">, </span><span class="s4">400</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">dtype=np.int64)</span>

    <span class="s2">def </span><span class="s1">test_loglikerelated(self):</span>

        <span class="s1">res1 = self.res1</span>
        <span class="s3"># res2 = self.res2</span>

        <span class="s1">mod = res1.model</span>
        <span class="s1">fact = </span><span class="s4">1.1  </span><span class="s3"># evaluate away from optimum</span>
        <span class="s1">score1 = mod.score(res1.params * fact)</span>
        <span class="s1">score_obs_numdiff = mod.score_obs(res1.params * fact)</span>
        <span class="s1">score_obs_exog = mod.score_obs_(res1.params * fact)</span>
        <span class="s3"># Relax atol due to small failures on OSX</span>
        <span class="s1">assert_allclose(score_obs_numdiff.sum(</span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">score1</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-6</span><span class="s1">)</span>
        <span class="s1">assert_allclose(score_obs_exog.sum(</span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">score1[:mod.k_vars]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-6</span><span class="s1">)</span>

        <span class="s3"># null model</span>
        <span class="s1">mod_null = OrderedModel(mod.endog</span><span class="s2">, None,</span>
                                <span class="s1">offset=np.zeros(mod.nobs)</span><span class="s2">,</span>
                                <span class="s1">distr=mod.distr)</span>
        <span class="s1">null_params = mod.start_params</span>
        <span class="s1">res_null = mod_null.fit(method=</span><span class="s5">'bfgs'</span><span class="s2">, </span><span class="s1">disp=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res_null.params</span><span class="s2">, </span><span class="s1">null_params[mod.k_vars:]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-8</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res1.llnull</span><span class="s2">, </span><span class="s1">res_null.llf</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-8</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_formula_categorical(self):</span>

        <span class="s1">resp = self.resp</span>
        <span class="s1">data = ds.df</span>

        <span class="s1">formula = </span><span class="s5">&quot;apply ~ pared + public + gpa - 1&quot;</span>
        <span class="s1">modf2 = OrderedModel.from_formula(formula</span><span class="s2">,</span>
                                          <span class="s1">data</span><span class="s2">, </span><span class="s1">distr=</span><span class="s5">'probit'</span><span class="s1">)</span>
        <span class="s1">resf2 = modf2.fit(method=</span><span class="s5">'bfgs'</span><span class="s2">, </span><span class="s1">disp=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">assert_allclose(resf2.params</span><span class="s2">, </span><span class="s1">resp.params</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-8</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">modf2.exog_names == resp.model.exog_names</span>
        <span class="s2">assert </span><span class="s1">modf2.data.ynames == resp.model.data.ynames</span>
        <span class="s2">assert </span><span class="s1">hasattr(modf2.data</span><span class="s2">, </span><span class="s5">&quot;frame&quot;</span><span class="s1">)</span>
        <span class="s2">assert not </span><span class="s1">hasattr(modf2</span><span class="s2">, </span><span class="s5">&quot;frame&quot;</span><span class="s1">)</span>

        <span class="s1">msg = </span><span class="s5">&quot;Only ordered pandas Categorical&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s3"># only ordered categorical or numerical endog are allowed</span>
            <span class="s3"># string endog raises ValueError</span>
            <span class="s1">OrderedModel.from_formula(</span>
                <span class="s5">&quot;apply ~ pared + public + gpa - 1&quot;</span><span class="s2">,</span>
                <span class="s1">data={</span><span class="s5">&quot;apply&quot;</span><span class="s1">: np.asarray(data[</span><span class="s5">'apply'</span><span class="s1">])</span><span class="s2">,</span>
                      <span class="s5">&quot;pared&quot;</span><span class="s1">: data[</span><span class="s5">'pared'</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s5">&quot;public&quot;</span><span class="s1">: data[</span><span class="s5">'public'</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s5">&quot;gpa&quot;</span><span class="s1">: data[</span><span class="s5">'gpa'</span><span class="s1">]}</span><span class="s2">,</span>
                <span class="s1">distr=</span><span class="s5">'probit'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_offset(self):</span>

        <span class="s1">resp = self.resp</span>
        <span class="s1">data = ds.df</span>
        <span class="s1">offset = np.ones(len(data))</span>

        <span class="s1">formula = </span><span class="s5">&quot;apply ~ pared + public + gpa - 1&quot;</span>
        <span class="s1">modf2 = OrderedModel.from_formula(formula</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">offset=offset</span><span class="s2">,</span>
                                          <span class="s1">distr=</span><span class="s5">'probit'</span><span class="s1">)</span>
        <span class="s1">resf2 = modf2.fit(method=</span><span class="s5">'bfgs'</span><span class="s2">, </span><span class="s1">disp=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s1">assert_allclose(resf2.params[:</span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">resp.params[:</span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">2e-4</span><span class="s1">)</span>
        <span class="s1">assert_allclose(resf2.params[</span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">resp.params[</span><span class="s4">3</span><span class="s1">] + </span><span class="s4">1</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">2e-4</span><span class="s1">)</span>

        <span class="s1">fitted = resp.predict()</span>
        <span class="s1">fitted2 = resf2.predict()</span>
        <span class="s1">assert_allclose(fitted2</span><span class="s2">, </span><span class="s1">fitted</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">2e-4</span><span class="s1">)</span>

        <span class="s1">pred_ones = resf2.predict(data[:</span><span class="s4">6</span><span class="s1">]</span><span class="s2">, </span><span class="s1">offset=np.ones(</span><span class="s4">6</span><span class="s1">))</span>
        <span class="s1">assert_allclose(pred_ones</span><span class="s2">, </span><span class="s1">fitted[:</span><span class="s4">6</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">2e-4</span><span class="s1">)</span>

        <span class="s3"># check default is 0. if exog provided</span>
        <span class="s1">pred_zero1 = resf2.predict(data[:</span><span class="s4">6</span><span class="s1">])</span>
        <span class="s1">pred_zero2 = resf2.predict(data[:</span><span class="s4">6</span><span class="s1">]</span><span class="s2">, </span><span class="s1">offset=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(pred_zero1</span><span class="s2">, </span><span class="s1">pred_zero2</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">2e-4</span><span class="s1">)</span>

        <span class="s3"># compare with equivalent results frp, no-offset model</span>
        <span class="s1">pred_zero = resp.predict(data[[</span><span class="s5">'pared'</span><span class="s2">, </span><span class="s5">'public'</span><span class="s2">, </span><span class="s5">'gpa'</span><span class="s1">]].iloc[:</span><span class="s4">6</span><span class="s1">]</span><span class="s2">,</span>
                                 <span class="s1">offset=-np.ones(</span><span class="s4">6</span><span class="s1">))</span>
        <span class="s1">assert_allclose(pred_zero1</span><span class="s2">, </span><span class="s1">pred_zero</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">2e-4</span><span class="s1">)</span>

        <span class="s1">params_adj = resp.params.copy()</span>
        <span class="s1">params_adj[</span><span class="s4">3</span><span class="s1">] += </span><span class="s4">1</span>
        <span class="s1">fitted_zero = resp.model.predict(params_adj)</span>
        <span class="s1">assert_allclose(pred_zero1</span><span class="s2">, </span><span class="s1">fitted_zero[:</span><span class="s4">6</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">2e-4</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestLogitModelFormula():</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">data = ds.df</span>
        <span class="s1">nobs = len(data)</span>
        <span class="s1">data[</span><span class="s5">&quot;dummy&quot;</span><span class="s1">] = (np.arange(nobs) &lt; (nobs / </span><span class="s4">2</span><span class="s1">)).astype(float)</span>
        <span class="s3"># alias to correspond to patsy name</span>
        <span class="s1">data[</span><span class="s5">&quot;C(dummy)[T.1.0]&quot;</span><span class="s1">] = data[</span><span class="s5">&quot;dummy&quot;</span><span class="s1">]</span>
        <span class="s1">cls.data = data</span>

        <span class="s1">columns = [</span><span class="s5">'C(dummy)[T.1.0]'</span><span class="s2">, </span><span class="s5">'pared'</span><span class="s2">, </span><span class="s5">'public'</span><span class="s2">, </span><span class="s5">'gpa'</span><span class="s1">]</span>
        <span class="s3"># standard fit</span>
        <span class="s1">mod = OrderedModel(data[</span><span class="s5">'apply'</span><span class="s1">].values.codes</span><span class="s2">,</span>
                           <span class="s1">np.asarray(data[columns]</span><span class="s2">, </span><span class="s1">float)</span><span class="s2">,</span>
                           <span class="s1">distr=</span><span class="s5">'logit'</span><span class="s1">)</span>
        <span class="s1">cls.res = mod.fit(method=</span><span class="s5">'bfgs'</span><span class="s2">, </span><span class="s1">disp=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s3"># standard fit with pandas input</span>
        <span class="s1">modp = OrderedModel(data[</span><span class="s5">'apply'</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">data[columns]</span><span class="s2">,</span>
                            <span class="s1">distr=</span><span class="s5">'logit'</span><span class="s1">)</span>
        <span class="s1">cls.resp = modp.fit(method=</span><span class="s5">'bfgs'</span><span class="s2">, </span><span class="s1">disp=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_setup(self):</span>
        <span class="s1">data = self.data</span>
        <span class="s1">resp = self.resp</span>
        <span class="s1">fittedvalues = resp.predict()</span>

        <span class="s1">formulas = [</span><span class="s5">&quot;apply ~ 1 + pared + public + gpa + C(dummy)&quot;</span><span class="s2">,</span>
                    <span class="s5">&quot;apply ~ pared + public + gpa + C(dummy)&quot;</span><span class="s1">]</span>
        <span class="s2">for </span><span class="s1">formula </span><span class="s2">in </span><span class="s1">formulas:</span>
            <span class="s1">modf1 = OrderedModel.from_formula(formula</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">distr=</span><span class="s5">'logit'</span><span class="s1">)</span>
            <span class="s1">resf1 = modf1.fit(method=</span><span class="s5">'bfgs'</span><span class="s1">)</span>
            <span class="s1">summf1 = resf1.summary()</span>
            <span class="s1">summf1_str = str(summf1)</span>
            <span class="s2">assert </span><span class="s1">resf1.model.exog_names == resp.model.exog_names</span>
            <span class="s2">assert </span><span class="s1">resf1.model.data.param_names == resp.model.exog_names</span>
            <span class="s2">assert </span><span class="s1">all(name </span><span class="s2">in </span><span class="s1">summf1_str </span><span class="s2">for </span><span class="s1">name </span><span class="s2">in</span>
                       <span class="s1">resp.model.data.param_names)</span>
            <span class="s1">assert_allclose(resf1.predict(data[:</span><span class="s4">5</span><span class="s1">])</span><span class="s2">, </span><span class="s1">fittedvalues[:</span><span class="s4">5</span><span class="s1">])</span>

        <span class="s3"># test over parameterized model with implicit constant</span>
        <span class="s1">formula = </span><span class="s5">&quot;apply ~ 0 + pared + public + gpa + C(dummy)&quot;</span>

        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s5">&quot;not be a constant&quot;</span><span class="s1">):</span>
            <span class="s1">OrderedModel.from_formula(formula</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">distr=</span><span class="s5">'logit'</span><span class="s1">)</span>

        <span class="s3"># ignore constant, so we get results without exception</span>
        <span class="s1">modf2 = OrderedModel.from_formula(formula</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">distr=</span><span class="s5">'logit'</span><span class="s2">,</span>
                                          <span class="s1">hasconst=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s3"># we get a warning in some environments</span>
        <span class="s2">with </span><span class="s1">warnings.catch_warnings():</span>
            <span class="s1">warnings.simplefilter(</span><span class="s5">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">HessianInversionWarning)</span>
            <span class="s1">resf2 = modf2.fit(method=</span><span class="s5">'bfgs'</span><span class="s1">)</span>

        <span class="s1">assert_allclose(resf2.predict(data[:</span><span class="s4">5</span><span class="s1">])</span><span class="s2">, </span><span class="s1">fittedvalues[:</span><span class="s4">5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-4</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestCLogLogModel(CheckOrdinalModelMixin):</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">data = ds.df</span>
        <span class="s1">data_unordered = ds.df_unordered</span>

        <span class="s3"># a Scipy distribution defined minimally</span>
        <span class="s2">class </span><span class="s1">CLogLog(stats.rv_continuous):</span>
            <span class="s2">def </span><span class="s1">_ppf(self</span><span class="s2">, </span><span class="s1">q):</span>
                <span class="s2">return </span><span class="s1">np.log(-np.log(</span><span class="s4">1 </span><span class="s1">- q))</span>

            <span class="s2">def </span><span class="s1">_cdf(self</span><span class="s2">, </span><span class="s1">x):</span>
                <span class="s2">return </span><span class="s4">1 </span><span class="s1">- np.exp(-np.exp(x))</span>

        <span class="s1">cloglog = CLogLog()</span>

        <span class="s1">mod = OrderedModel(data[</span><span class="s5">'apply'</span><span class="s1">].values.codes</span><span class="s2">,</span>
                           <span class="s1">np.asarray(data[[</span><span class="s5">'pared'</span><span class="s2">, </span><span class="s5">'public'</span><span class="s2">, </span><span class="s5">'gpa'</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">float)</span><span class="s2">,</span>
                           <span class="s1">distr=cloglog)</span>
        <span class="s1">res = mod.fit(method=</span><span class="s5">'bfgs'</span><span class="s2">, </span><span class="s1">disp=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s1">modp = OrderedModel(data[</span><span class="s5">'apply'</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">data[[</span><span class="s5">'pared'</span><span class="s2">, </span><span class="s5">'public'</span><span class="s2">, </span><span class="s5">'gpa'</span><span class="s1">]]</span><span class="s2">,</span>
                            <span class="s1">distr=cloglog)</span>
        <span class="s1">resp = modp.fit(method=</span><span class="s5">'bfgs'</span><span class="s2">, </span><span class="s1">disp=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s3"># with pytest.warns(UserWarning):</span>
        <span class="s1">modf = OrderedModel.from_formula(</span>
            <span class="s5">&quot;apply ~ pared + public + gpa - 1&quot;</span><span class="s2">,</span>
            <span class="s1">data={</span><span class="s5">&quot;apply&quot;</span><span class="s1">: data[</span><span class="s5">'apply'</span><span class="s1">].values.codes</span><span class="s2">,</span>
                  <span class="s5">&quot;pared&quot;</span><span class="s1">: data[</span><span class="s5">'pared'</span><span class="s1">]</span><span class="s2">,</span>
                  <span class="s5">&quot;public&quot;</span><span class="s1">: data[</span><span class="s5">'public'</span><span class="s1">]</span><span class="s2">,</span>
                  <span class="s5">&quot;gpa&quot;</span><span class="s1">: data[</span><span class="s5">'gpa'</span><span class="s1">]}</span><span class="s2">,</span>
            <span class="s1">distr=cloglog)</span>
        <span class="s1">resf = modf.fit(method=</span><span class="s5">'bfgs'</span><span class="s2">, </span><span class="s1">disp=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s1">modu = OrderedModel(</span>
            <span class="s1">data_unordered[</span><span class="s5">'apply'</span><span class="s1">].values.codes</span><span class="s2">,</span>
            <span class="s1">np.asarray(data_unordered[[</span><span class="s5">'pared'</span><span class="s2">, </span><span class="s5">'public'</span><span class="s2">, </span><span class="s5">'gpa'</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">float)</span><span class="s2">,</span>
            <span class="s1">distr=cloglog)</span>
        <span class="s1">resu = modu.fit(method=</span><span class="s5">'bfgs'</span><span class="s2">, </span><span class="s1">disp=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s2">from </span><span class="s1">.results.results_ordinal_model </span><span class="s2">import </span><span class="s1">res_ord_cloglog </span><span class="s2">as </span><span class="s1">res2</span>
        <span class="s1">cls.res2 = res2</span>
        <span class="s1">cls.res1 = res</span>
        <span class="s1">cls.resp = resp</span>
        <span class="s1">cls.resf = resf</span>
        <span class="s1">cls.resu = resu</span>


<span class="s2">class </span><span class="s1">TestLogitBinary():</span>
    <span class="s3"># compare OrderedModel with discrete Logit for binary case</span>
    <span class="s2">def </span><span class="s1">test_attributes(self):</span>
        <span class="s1">data = ds.df</span>

        <span class="s1">mask_drop = data[</span><span class="s5">'apply'</span><span class="s1">] == </span><span class="s5">&quot;somewhat likely&quot;</span>
        <span class="s1">data2 = data.loc[~mask_drop</span><span class="s2">, </span><span class="s1">:].copy()</span>
        <span class="s3"># we need to remove the category also from the Categorical Index</span>
        <span class="s1">data2[</span><span class="s5">'apply'</span><span class="s1">] = data2[</span><span class="s5">'apply'</span><span class="s1">].cat.remove_categories(</span><span class="s5">&quot;somewhat likely&quot;</span><span class="s1">)</span>

        <span class="s3"># standard fit with pandas input</span>
        <span class="s1">modp = OrderedModel(data2[</span><span class="s5">'apply'</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">data2[[</span><span class="s5">'pared'</span><span class="s2">, </span><span class="s5">'public'</span><span class="s2">, </span><span class="s5">'gpa'</span><span class="s1">]]</span><span class="s2">,</span>
                            <span class="s1">distr=</span><span class="s5">'logit'</span><span class="s1">)</span>
        <span class="s1">resp = modp.fit(method=</span><span class="s5">'bfgs'</span><span class="s2">, </span><span class="s1">disp=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s1">exog = add_constant(data2[[</span><span class="s5">'pared'</span><span class="s2">, </span><span class="s5">'public'</span><span class="s2">, </span><span class="s5">'gpa'</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">prepend=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">mod_logit = Logit(data2[</span><span class="s5">'apply'</span><span class="s1">].cat.codes</span><span class="s2">, </span><span class="s1">exog)</span>
        <span class="s1">res_logit = mod_logit.fit()</span>

        <span class="s1">attributes = </span><span class="s5">&quot;bse df_resid llf aic bic llnull&quot;</span><span class="s1">.split()</span>
        <span class="s1">attributes += </span><span class="s5">&quot;llnull llr llr_pvalue prsquared&quot;</span><span class="s1">.split()</span>
        <span class="s1">assert_allclose(resp.params[:</span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">res_logit.params[:</span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-5</span><span class="s1">)</span>
        <span class="s1">assert_allclose(resp.params[</span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">-res_logit.params[</span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-5</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">attributes:</span>
            <span class="s1">assert_allclose(getattr(resp</span><span class="s2">, </span><span class="s1">attr)</span><span class="s2">, </span><span class="s1">getattr(res_logit</span><span class="s2">, </span><span class="s1">attr)</span><span class="s2">,</span>
                            <span class="s1">rtol=</span><span class="s4">1e-4</span><span class="s1">)</span>

        <span class="s1">resp = modp.fit(method=</span><span class="s5">'bfgs'</span><span class="s2">, </span><span class="s1">disp=</span><span class="s2">False,</span>
                        <span class="s1">cov_type=</span><span class="s5">&quot;hac&quot;</span><span class="s2">, </span><span class="s1">cov_kwds={</span><span class="s5">&quot;maxlags&quot;</span><span class="s1">: </span><span class="s4">2</span><span class="s1">})</span>
        <span class="s1">res_logit = mod_logit.fit(method=</span><span class="s5">'bfgs'</span><span class="s2">, </span><span class="s1">disp=</span><span class="s2">False,</span>
                                  <span class="s1">cov_type=</span><span class="s5">&quot;hac&quot;</span><span class="s2">, </span><span class="s1">cov_kwds={</span><span class="s5">&quot;maxlags&quot;</span><span class="s1">: </span><span class="s4">2</span><span class="s1">})</span>
        <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">attributes:</span>
            <span class="s1">assert_allclose(getattr(resp</span><span class="s2">, </span><span class="s1">attr)</span><span class="s2">, </span><span class="s1">getattr(res_logit</span><span class="s2">, </span><span class="s1">attr)</span><span class="s2">,</span>
                            <span class="s1">rtol=</span><span class="s4">1e-4</span><span class="s1">)</span>

        <span class="s1">resp = modp.fit(method=</span><span class="s5">'bfgs'</span><span class="s2">, </span><span class="s1">disp=</span><span class="s2">False, </span><span class="s1">cov_type=</span><span class="s5">&quot;hc1&quot;</span><span class="s1">)</span>
        <span class="s1">res_logit = mod_logit.fit(method=</span><span class="s5">'bfgs'</span><span class="s2">, </span><span class="s1">disp=</span><span class="s2">False,</span>
                                  <span class="s1">cov_type=</span><span class="s5">&quot;hc1&quot;</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">attributes:</span>
            <span class="s1">assert_allclose(getattr(resp</span><span class="s2">, </span><span class="s1">attr)</span><span class="s2">, </span><span class="s1">getattr(res_logit</span><span class="s2">, </span><span class="s1">attr)</span><span class="s2">,</span>
                            <span class="s1">rtol=</span><span class="s4">1e-4</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_nan_endog_exceptions():</span>
    <span class="s1">nobs = </span><span class="s4">15</span>
    <span class="s1">y = np.repeat(np.arange(</span><span class="s4">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">nobs // </span><span class="s4">3</span><span class="s1">)</span>
    <span class="s1">x = np.column_stack((np.ones(nobs)</span><span class="s2">, </span><span class="s1">np.arange(nobs)))</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s5">&quot;not be a constant&quot;</span><span class="s1">):</span>
        <span class="s1">OrderedModel(y</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">distr=</span><span class="s5">'logit'</span><span class="s1">)</span>

    <span class="s1">y_nan = y.astype(float)</span>
    <span class="s1">y_nan[</span><span class="s4">0</span><span class="s1">] = np.nan</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s5">&quot;NaN in dependent variable&quot;</span><span class="s1">):</span>
        <span class="s1">OrderedModel(y_nan</span><span class="s2">, </span><span class="s1">x[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">distr=</span><span class="s5">'logit'</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">hasattr(pd</span><span class="s2">, </span><span class="s5">&quot;CategoricalDtype&quot;</span><span class="s1">):</span>
        <span class="s1">df = pd.DataFrame({</span>
            <span class="s5">&quot;endog&quot;</span><span class="s1">: pd.Series(</span>
                <span class="s1">y</span><span class="s2">, </span><span class="s1">dtype=pd.CategoricalDtype([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">ordered=</span><span class="s2">True</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s5">&quot;exog&quot;</span><span class="s1">: x[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span>
            <span class="s1">})</span>

        <span class="s1">msg = </span><span class="s5">&quot;missing values in categorical endog&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">OrderedModel(df[</span><span class="s5">&quot;endog&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">df[[</span><span class="s5">&quot;exog&quot;</span><span class="s1">]])</span>
</pre>
</body>
</html>