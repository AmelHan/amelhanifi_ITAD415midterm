<html>
<head>
<title>regressionplots.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
regressionplots.py</font>
</center></td></tr></table>
<pre><span class="s0">'''Partial Regression plot and residual plots to find misspecification 
 
 
Author: Josef Perktold 
License: BSD-3 
Created: 2011-01-23 
 
update 
2011-06-05 : start to convert example to usable functions 
2011-10-27 : docstrings 
 
'''</span>
<span class="s2">from </span><span class="s1">statsmodels.compat.pandas </span><span class="s2">import </span><span class="s1">Appender</span>
<span class="s2">from </span><span class="s1">statsmodels.compat.python </span><span class="s2">import </span><span class="s1">lrange</span><span class="s2">, </span><span class="s1">lzip</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pandas </span><span class="s2">as </span><span class="s1">pd</span>
<span class="s2">from </span><span class="s1">patsy </span><span class="s2">import </span><span class="s1">dmatrix</span>

<span class="s2">from </span><span class="s1">statsmodels.genmod.generalized_estimating_equations </span><span class="s2">import </span><span class="s1">GEE</span>
<span class="s2">from </span><span class="s1">statsmodels.genmod.generalized_linear_model </span><span class="s2">import </span><span class="s1">GLM</span>
<span class="s2">from </span><span class="s1">statsmodels.graphics </span><span class="s2">import </span><span class="s1">utils</span>
<span class="s2">from </span><span class="s1">statsmodels.nonparametric.smoothers_lowess </span><span class="s2">import </span><span class="s1">lowess</span>
<span class="s2">from </span><span class="s1">statsmodels.regression.linear_model </span><span class="s2">import </span><span class="s1">GLS</span><span class="s2">, </span><span class="s1">OLS</span><span class="s2">, </span><span class="s1">WLS</span>
<span class="s2">from </span><span class="s1">statsmodels.sandbox.regression.predstd </span><span class="s2">import </span><span class="s1">wls_prediction_std</span>
<span class="s2">from </span><span class="s1">statsmodels.tools.tools </span><span class="s2">import </span><span class="s1">maybe_unwrap_results</span>

<span class="s2">from </span><span class="s1">._regressionplots_doc </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">_plot_added_variable_doc</span><span class="s2">,</span>
    <span class="s1">_plot_ceres_residuals_doc</span><span class="s2">,</span>
    <span class="s1">_plot_influence_doc</span><span class="s2">,</span>
    <span class="s1">_plot_leverage_resid2_doc</span><span class="s2">,</span>
    <span class="s1">_plot_partial_residuals_doc</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s1">__all__ = [</span><span class="s3">'plot_fit'</span><span class="s2">, </span><span class="s3">'plot_regress_exog'</span><span class="s2">, </span><span class="s3">'plot_partregress'</span><span class="s2">, </span><span class="s3">'plot_ccpr'</span><span class="s2">,</span>
           <span class="s3">'plot_regress_exog'</span><span class="s2">, </span><span class="s3">'plot_partregress_grid'</span><span class="s2">, </span><span class="s3">'plot_ccpr_grid'</span><span class="s2">,</span>
           <span class="s3">'add_lowess'</span><span class="s2">, </span><span class="s3">'abline_plot'</span><span class="s2">, </span><span class="s3">'influence_plot'</span><span class="s2">,</span>
           <span class="s3">'plot_leverage_resid2'</span><span class="s2">, </span><span class="s3">'added_variable_resids'</span><span class="s2">,</span>
           <span class="s3">'partial_resids'</span><span class="s2">, </span><span class="s3">'ceres_resids'</span><span class="s2">, </span><span class="s3">'plot_added_variable'</span><span class="s2">,</span>
           <span class="s3">'plot_partial_residuals'</span><span class="s2">, </span><span class="s3">'plot_ceres_residuals'</span><span class="s1">]</span>

<span class="s4">#TODO: consider moving to influence module</span>
<span class="s2">def </span><span class="s1">_high_leverage(results):</span>
    <span class="s4">#TODO: replace 1 with k_constant</span>
    <span class="s2">return </span><span class="s5">2. </span><span class="s1">* (results.df_model + </span><span class="s5">1</span><span class="s1">)/results.nobs</span>


<span class="s2">def </span><span class="s1">add_lowess(ax</span><span class="s2">, </span><span class="s1">lines_idx=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">frac=</span><span class="s5">.2</span><span class="s2">, </span><span class="s1">**lowess_kwargs):</span>
    <span class="s0">&quot;&quot;&quot; 
    Add Lowess line to a plot. 
 
    Parameters 
    ---------- 
    ax : AxesSubplot 
        The Axes to which to add the plot 
    lines_idx : int 
        This is the line on the existing plot to which you want to add 
        a smoothed lowess line. 
    frac : float 
        The fraction of the points to use when doing the lowess fit. 
    lowess_kwargs 
        Additional keyword arguments are passes to lowess. 
 
    Returns 
    ------- 
    Figure 
        The figure that holds the instance. 
    &quot;&quot;&quot;</span>
    <span class="s1">y0 = ax.get_lines()[lines_idx]._y</span>
    <span class="s1">x0 = ax.get_lines()[lines_idx]._x</span>
    <span class="s1">lres = lowess(y0</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">frac=frac</span><span class="s2">, </span><span class="s1">**lowess_kwargs)</span>
    <span class="s1">ax.plot(lres[:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">lres[:</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s3">'r'</span><span class="s2">, </span><span class="s1">lw=</span><span class="s5">1.5</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">ax.figure</span>


<span class="s2">def </span><span class="s1">plot_fit(results</span><span class="s2">, </span><span class="s1">exog_idx</span><span class="s2">, </span><span class="s1">y_true=</span><span class="s2">None, </span><span class="s1">ax=</span><span class="s2">None, </span><span class="s1">vlines=</span><span class="s2">True, </span><span class="s1">**kwargs):</span>
    <span class="s0">&quot;&quot;&quot; 
    Plot fit against one regressor. 
 
    This creates one graph with the scatterplot of observed values 
    compared to fitted values. 
 
    Parameters 
    ---------- 
    results : Results 
        A result instance with resid, model.endog and model.exog as 
        attributes. 
    exog_idx : {int, str} 
        Name or index of regressor in exog matrix. 
    y_true : array_like. optional 
        If this is not None, then the array is added to the plot. 
    ax : AxesSubplot, optional 
        If given, this subplot is used to plot in instead of a new figure being 
        created. 
    vlines : bool, optional 
        If this not True, then the uncertainty (pointwise prediction intervals) of the fit is not 
        plotted. 
    **kwargs 
        The keyword arguments are passed to the plot command for the fitted 
        values points. 
 
    Returns 
    ------- 
    Figure 
        If `ax` is None, the created figure.  Otherwise the figure to which 
        `ax` is connected. 
 
    Examples 
    -------- 
    Load the Statewide Crime data set and perform linear regression with 
    `poverty` and `hs_grad` as variables and `murder` as the response 
 
    &gt;&gt;&gt; import statsmodels.api as sm 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    &gt;&gt;&gt; data = sm.datasets.statecrime.load_pandas().data 
    &gt;&gt;&gt; murder = data['murder'] 
    &gt;&gt;&gt; X = data[['poverty', 'hs_grad']] 
 
    &gt;&gt;&gt; X[&quot;constant&quot;] = 1 
    &gt;&gt;&gt; y = murder 
    &gt;&gt;&gt; model = sm.OLS(y, X) 
    &gt;&gt;&gt; results = model.fit() 
 
    Create a plot just for the variable 'Poverty.' 
    Note that vertical bars representing uncertainty are plotted since vlines is true 
 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; fig = sm.graphics.plot_fit(results, 0, ax=ax) 
    &gt;&gt;&gt; ax.set_ylabel(&quot;Murder Rate&quot;) 
    &gt;&gt;&gt; ax.set_xlabel(&quot;Poverty Level&quot;) 
    &gt;&gt;&gt; ax.set_title(&quot;Linear Regression&quot;) 
 
    &gt;&gt;&gt; plt.show() 
 
    .. plot:: plots/graphics_plot_fit_ex.py 
    &quot;&quot;&quot;</span>

    <span class="s1">fig</span><span class="s2">, </span><span class="s1">ax = utils.create_mpl_ax(ax)</span>

    <span class="s1">exog_name</span><span class="s2">, </span><span class="s1">exog_idx = utils.maybe_name_or_idx(exog_idx</span><span class="s2">, </span><span class="s1">results.model)</span>
    <span class="s1">results = maybe_unwrap_results(results)</span>

    <span class="s4">#maybe add option for wendog, wexog</span>
    <span class="s1">y = results.model.endog</span>
    <span class="s1">x1 = results.model.exog[:</span><span class="s2">, </span><span class="s1">exog_idx]</span>
    <span class="s1">x1_argsort = np.argsort(x1)</span>
    <span class="s1">y = y[x1_argsort]</span>
    <span class="s1">x1 = x1[x1_argsort]</span>

    <span class="s1">ax.plot(x1</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s3">'bo'</span><span class="s2">, </span><span class="s1">label=results.model.endog_names)</span>
    <span class="s2">if </span><span class="s1">y_true </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">ax.plot(x1</span><span class="s2">, </span><span class="s1">y_true[x1_argsort]</span><span class="s2">, </span><span class="s3">'b-'</span><span class="s2">, </span><span class="s1">label=</span><span class="s3">'True values'</span><span class="s1">)</span>
    <span class="s1">title = </span><span class="s3">'Fitted values versus %s' </span><span class="s1">% exog_name</span>

    <span class="s1">ax.plot(x1</span><span class="s2">, </span><span class="s1">results.fittedvalues[x1_argsort]</span><span class="s2">, </span><span class="s3">'D'</span><span class="s2">, </span><span class="s1">color=</span><span class="s3">'r'</span><span class="s2">,</span>
            <span class="s1">label=</span><span class="s3">'fitted'</span><span class="s2">, </span><span class="s1">**kwargs)</span>
    <span class="s2">if </span><span class="s1">vlines </span><span class="s2">is True</span><span class="s1">:</span>
        <span class="s1">_</span><span class="s2">, </span><span class="s1">iv_l</span><span class="s2">, </span><span class="s1">iv_u = wls_prediction_std(results)</span>
        <span class="s1">ax.vlines(x1</span><span class="s2">, </span><span class="s1">iv_l[x1_argsort]</span><span class="s2">, </span><span class="s1">iv_u[x1_argsort]</span><span class="s2">, </span><span class="s1">linewidth=</span><span class="s5">1</span><span class="s2">,</span>
                  <span class="s1">color=</span><span class="s3">'k'</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s5">.7</span><span class="s1">)</span>
    <span class="s4">#ax.fill_between(x1, iv_l[x1_argsort], iv_u[x1_argsort], alpha=0.1,</span>
    <span class="s4">#                    color='k')</span>
    <span class="s1">ax.set_title(title)</span>
    <span class="s1">ax.set_xlabel(exog_name)</span>
    <span class="s1">ax.set_ylabel(results.model.endog_names)</span>
    <span class="s1">ax.legend(loc=</span><span class="s3">'best'</span><span class="s2">, </span><span class="s1">numpoints=</span><span class="s5">1</span><span class="s1">)</span>

    <span class="s2">return </span><span class="s1">fig</span>


<span class="s2">def </span><span class="s1">plot_regress_exog(results</span><span class="s2">, </span><span class="s1">exog_idx</span><span class="s2">, </span><span class="s1">fig=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Plot regression results against one regressor. 
 
    This plots four graphs in a 2 by 2 figure: 'endog versus exog', 
    'residuals versus exog', 'fitted versus exog' and 
    'fitted plus residual versus exog' 
 
    Parameters 
    ---------- 
    results : result instance 
        A result instance with resid, model.endog and model.exog as attributes. 
    exog_idx : int or str 
        Name or index of regressor in exog matrix. 
    fig : Figure, optional 
        If given, this figure is simply returned.  Otherwise a new figure is 
        created. 
 
    Returns 
    ------- 
    Figure 
        The value of `fig` if provided. Otherwise a new instance. 
 
    Examples 
    -------- 
    Load the Statewide Crime data set and build a model with regressors 
    including the rate of high school graduation (hs_grad), population in urban 
    areas (urban), households below poverty line (poverty), and single person 
    households (single).  Outcome variable is the murder rate (murder). 
 
    Build a 2 by 2 figure based on poverty showing fitted versus actual murder 
    rate, residuals versus the poverty rate, partial regression plot of poverty, 
    and CCPR plot for poverty rate. 
 
    &gt;&gt;&gt; import statsmodels.api as sm 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; import statsmodels.formula.api as smf 
 
    &gt;&gt;&gt; fig = plt.figure(figsize=(8, 6)) 
    &gt;&gt;&gt; crime_data = sm.datasets.statecrime.load_pandas() 
    &gt;&gt;&gt; results = smf.ols('murder ~ hs_grad + urban + poverty + single', 
    ...                   data=crime_data.data).fit() 
    &gt;&gt;&gt; sm.graphics.plot_regress_exog(results, 'poverty', fig=fig) 
    &gt;&gt;&gt; plt.show() 
 
    .. plot:: plots/graphics_regression_regress_exog.py 
    &quot;&quot;&quot;</span>

    <span class="s1">fig = utils.create_mpl_fig(fig)</span>

    <span class="s1">exog_name</span><span class="s2">, </span><span class="s1">exog_idx = utils.maybe_name_or_idx(exog_idx</span><span class="s2">, </span><span class="s1">results.model)</span>
    <span class="s1">results = maybe_unwrap_results(results)</span>

    <span class="s4">#maybe add option for wendog, wexog</span>
    <span class="s1">y_name = results.model.endog_names</span>
    <span class="s1">x1 = results.model.exog[:</span><span class="s2">, </span><span class="s1">exog_idx]</span>
    <span class="s1">prstd</span><span class="s2">, </span><span class="s1">iv_l</span><span class="s2">, </span><span class="s1">iv_u = wls_prediction_std(results)</span>

    <span class="s1">ax = fig.add_subplot(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">ax.plot(x1</span><span class="s2">, </span><span class="s1">results.model.endog</span><span class="s2">, </span><span class="s3">'o'</span><span class="s2">, </span><span class="s1">color=</span><span class="s3">'b'</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s5">0.9</span><span class="s2">, </span><span class="s1">label=y_name)</span>
    <span class="s1">ax.plot(x1</span><span class="s2">, </span><span class="s1">results.fittedvalues</span><span class="s2">, </span><span class="s3">'D'</span><span class="s2">, </span><span class="s1">color=</span><span class="s3">'r'</span><span class="s2">, </span><span class="s1">label=</span><span class="s3">'fitted'</span><span class="s2">,</span>
            <span class="s1">alpha=</span><span class="s5">.5</span><span class="s1">)</span>
    <span class="s1">ax.vlines(x1</span><span class="s2">, </span><span class="s1">iv_l</span><span class="s2">, </span><span class="s1">iv_u</span><span class="s2">, </span><span class="s1">linewidth=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">color=</span><span class="s3">'k'</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s5">.7</span><span class="s1">)</span>
    <span class="s1">ax.set_title(</span><span class="s3">'Y and Fitted vs. X'</span><span class="s2">, </span><span class="s1">fontsize=</span><span class="s3">'large'</span><span class="s1">)</span>
    <span class="s1">ax.set_xlabel(exog_name)</span>
    <span class="s1">ax.set_ylabel(y_name)</span>
    <span class="s1">ax.legend(loc=</span><span class="s3">'best'</span><span class="s1">)</span>

    <span class="s1">ax = fig.add_subplot(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>
    <span class="s1">ax.plot(x1</span><span class="s2">, </span><span class="s1">results.resid</span><span class="s2">, </span><span class="s3">'o'</span><span class="s1">)</span>
    <span class="s1">ax.axhline(y=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">color=</span><span class="s3">'black'</span><span class="s1">)</span>
    <span class="s1">ax.set_title(</span><span class="s3">'Residuals versus %s' </span><span class="s1">% exog_name</span><span class="s2">, </span><span class="s1">fontsize=</span><span class="s3">'large'</span><span class="s1">)</span>
    <span class="s1">ax.set_xlabel(exog_name)</span>
    <span class="s1">ax.set_ylabel(</span><span class="s3">&quot;resid&quot;</span><span class="s1">)</span>

    <span class="s1">ax = fig.add_subplot(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)</span>
    <span class="s1">exog_noti = np.ones(results.model.exog.shape[</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">bool)</span>
    <span class="s1">exog_noti[exog_idx] = </span><span class="s2">False</span>
    <span class="s1">exog_others = results.model.exog[:</span><span class="s2">, </span><span class="s1">exog_noti]</span>
    <span class="s2">from </span><span class="s1">pandas </span><span class="s2">import </span><span class="s1">Series</span>
    <span class="s1">fig = plot_partregress(results.model.data.orig_endog</span><span class="s2">,</span>
                           <span class="s1">Series(x1</span><span class="s2">, </span><span class="s1">name=exog_name</span><span class="s2">,</span>
                                  <span class="s1">index=results.model.data.row_labels)</span><span class="s2">,</span>
                           <span class="s1">exog_others</span><span class="s2">, </span><span class="s1">obs_labels=</span><span class="s2">False, </span><span class="s1">ax=ax)</span>
    <span class="s1">ax.set_title(</span><span class="s3">'Partial regression plot'</span><span class="s2">, </span><span class="s1">fontsize=</span><span class="s3">'large'</span><span class="s1">)</span>
    <span class="s4">#ax.set_ylabel(&quot;Fitted values&quot;)</span>
    <span class="s4">#ax.set_xlabel(exog_name)</span>

    <span class="s1">ax = fig.add_subplot(</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)</span>
    <span class="s1">fig = plot_ccpr(results</span><span class="s2">, </span><span class="s1">exog_idx</span><span class="s2">, </span><span class="s1">ax=ax)</span>
    <span class="s1">ax.set_title(</span><span class="s3">'CCPR Plot'</span><span class="s2">, </span><span class="s1">fontsize=</span><span class="s3">'large'</span><span class="s1">)</span>
    <span class="s4">#ax.set_xlabel(exog_name)</span>
    <span class="s4">#ax.set_ylabel(&quot;Fitted values + resids&quot;)</span>

    <span class="s1">fig.suptitle(</span><span class="s3">'Regression Plots for %s' </span><span class="s1">% exog_name</span><span class="s2">, </span><span class="s1">fontsize=</span><span class="s3">&quot;large&quot;</span><span class="s1">)</span>

    <span class="s1">fig.tight_layout()</span>

    <span class="s1">fig.subplots_adjust(top=</span><span class="s5">.90</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">fig</span>


<span class="s2">def </span><span class="s1">_partial_regression(endog</span><span class="s2">, </span><span class="s1">exog_i</span><span class="s2">, </span><span class="s1">exog_others):</span>
    <span class="s0">&quot;&quot;&quot;Partial regression. 
 
    regress endog on exog_i conditional on exog_others 
 
    uses OLS 
 
    Parameters 
    ---------- 
    endog : array_like 
    exog : array_like 
    exog_others : array_like 
 
    Returns 
    ------- 
    res1c : OLS results instance 
 
    (res1a, res1b) : tuple of OLS results instances 
         results from regression of endog on exog_others and of exog_i on 
         exog_others 
    &quot;&quot;&quot;</span>
    <span class="s4">#FIXME: This function does not appear to be used.</span>
    <span class="s1">res1a = OLS(endog</span><span class="s2">, </span><span class="s1">exog_others).fit()</span>
    <span class="s1">res1b = OLS(exog_i</span><span class="s2">, </span><span class="s1">exog_others).fit()</span>
    <span class="s1">res1c = OLS(res1a.resid</span><span class="s2">, </span><span class="s1">res1b.resid).fit()</span>

    <span class="s2">return </span><span class="s1">res1c</span><span class="s2">, </span><span class="s1">(res1a</span><span class="s2">, </span><span class="s1">res1b)</span>


<span class="s2">def </span><span class="s1">plot_partregress(endog</span><span class="s2">, </span><span class="s1">exog_i</span><span class="s2">, </span><span class="s1">exog_others</span><span class="s2">, </span><span class="s1">data=</span><span class="s2">None,</span>
                     <span class="s1">title_kwargs={}</span><span class="s2">, </span><span class="s1">obs_labels=</span><span class="s2">True, </span><span class="s1">label_kwargs={}</span><span class="s2">,</span>
                     <span class="s1">ax=</span><span class="s2">None, </span><span class="s1">ret_coords=</span><span class="s2">False, </span><span class="s1">eval_env=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">**kwargs):</span>
    <span class="s0">&quot;&quot;&quot;Plot partial regression for a single regressor. 
 
    Parameters 
    ---------- 
    endog : {ndarray, str} 
       The endogenous or response variable. If string is given, you can use a 
       arbitrary translations as with a formula. 
    exog_i : {ndarray, str} 
        The exogenous, explanatory variable. If string is given, you can use a 
        arbitrary translations as with a formula. 
    exog_others : {ndarray, list[str]} 
        Any other exogenous, explanatory variables. If a list of strings is 
        given, each item is a term in formula. You can use a arbitrary 
        translations as with a formula. The effect of these variables will be 
        removed by OLS regression. 
    data : {DataFrame, dict} 
        Some kind of data structure with names if the other variables are 
        given as strings. 
    title_kwargs : dict 
        Keyword arguments to pass on for the title. The key to control the 
        fonts is fontdict. 
    obs_labels : {bool, array_like} 
        Whether or not to annotate the plot points with their observation 
        labels. If obs_labels is a boolean, the point labels will try to do 
        the right thing. First it will try to use the index of data, then 
        fall back to the index of exog_i. Alternatively, you may give an 
        array-like object corresponding to the observation numbers. 
    label_kwargs : dict 
        Keyword arguments that control annotate for the observation labels. 
    ax : AxesSubplot, optional 
        If given, this subplot is used to plot in instead of a new figure being 
        created. 
    ret_coords : bool 
        If True will return the coordinates of the points in the plot. You 
        can use this to add your own annotations. 
    eval_env : int 
        Patsy eval environment if user functions and formulas are used in 
        defining endog or exog. 
    **kwargs 
        The keyword arguments passed to plot for the points. 
 
    Returns 
    ------- 
    fig : Figure 
        If `ax` is None, the created figure.  Otherwise the figure to which 
        `ax` is connected. 
    coords : list, optional 
        If ret_coords is True, return a tuple of arrays (x_coords, y_coords). 
 
    See Also 
    -------- 
    plot_partregress_grid : Plot partial regression for a set of regressors. 
 
    Notes 
    ----- 
    The slope of the fitted line is the that of `exog_i` in the full 
    multiple regression. The individual points can be used to assess the 
    influence of points on the estimated coefficient. 
 
    Examples 
    -------- 
    Load the Statewide Crime data set and plot partial regression of the rate 
    of high school graduation (hs_grad) on the murder rate(murder). 
 
    The effects of the percent of the population living in urban areas (urban), 
    below the poverty line (poverty) , and in a single person household (single) 
    are removed by OLS regression. 
 
    &gt;&gt;&gt; import statsmodels.api as sm 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    &gt;&gt;&gt; crime_data = sm.datasets.statecrime.load_pandas() 
    &gt;&gt;&gt; sm.graphics.plot_partregress(endog='murder', exog_i='hs_grad', 
    ...                              exog_others=['urban', 'poverty', 'single'], 
    ...                              data=crime_data.data, obs_labels=False) 
    &gt;&gt;&gt; plt.show() 
 
    .. plot:: plots/graphics_regression_partregress.py 
 
    More detailed examples can be found in the Regression Plots notebook 
    on the examples page. 
    &quot;&quot;&quot;</span>
    <span class="s4">#NOTE: there is no interaction between possible missing data and</span>
    <span class="s4">#obs_labels yet, so this will need to be tweaked a bit for this case</span>
    <span class="s1">fig</span><span class="s2">, </span><span class="s1">ax = utils.create_mpl_ax(ax)</span>

    <span class="s4"># strings, use patsy to transform to data</span>
    <span class="s2">if </span><span class="s1">isinstance(endog</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s1">endog = dmatrix(endog + </span><span class="s3">&quot;-1&quot;</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">eval_env=eval_env)</span>

    <span class="s2">if </span><span class="s1">isinstance(exog_others</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s1">RHS = dmatrix(exog_others</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">eval_env=eval_env)</span>
    <span class="s2">elif </span><span class="s1">isinstance(exog_others</span><span class="s2">, </span><span class="s1">list):</span>
        <span class="s1">RHS = </span><span class="s3">&quot;+&quot;</span><span class="s1">.join(exog_others)</span>
        <span class="s1">RHS = dmatrix(RHS</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">eval_env=eval_env)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">RHS = exog_others</span>
    <span class="s1">RHS_isemtpy = </span><span class="s2">False</span>
    <span class="s2">if </span><span class="s1">isinstance(RHS</span><span class="s2">, </span><span class="s1">np.ndarray) </span><span class="s2">and </span><span class="s1">RHS.size==</span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">RHS_isemtpy = </span><span class="s2">True</span>
    <span class="s2">elif </span><span class="s1">isinstance(RHS</span><span class="s2">, </span><span class="s1">pd.DataFrame) </span><span class="s2">and </span><span class="s1">RHS.empty:</span>
        <span class="s1">RHS_isemtpy = </span><span class="s2">True</span>
    <span class="s2">if </span><span class="s1">isinstance(exog_i</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s1">exog_i = dmatrix(exog_i + </span><span class="s3">&quot;-1&quot;</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">eval_env=eval_env)</span>

    <span class="s4"># all arrays or pandas-like</span>

    <span class="s2">if </span><span class="s1">RHS_isemtpy:</span>
        <span class="s1">endog = np.asarray(endog)</span>
        <span class="s1">exog_i = np.asarray(exog_i)</span>
        <span class="s1">ax.plot(endog</span><span class="s2">, </span><span class="s1">exog_i</span><span class="s2">, </span><span class="s3">'o'</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">fitted_line = OLS(endog</span><span class="s2">, </span><span class="s1">exog_i).fit()</span>
        <span class="s1">x_axis_endog_name = </span><span class="s3">'x' </span><span class="s2">if </span><span class="s1">isinstance(exog_i</span><span class="s2">, </span><span class="s1">np.ndarray) </span><span class="s2">else </span><span class="s1">exog_i.name</span>
        <span class="s1">y_axis_endog_name = </span><span class="s3">'y' </span><span class="s2">if </span><span class="s1">isinstance(endog</span><span class="s2">, </span><span class="s1">np.ndarray) </span><span class="s2">else </span><span class="s1">endog.design_info.column_names[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">res_yaxis = OLS(endog</span><span class="s2">, </span><span class="s1">RHS).fit()</span>
        <span class="s1">res_xaxis = OLS(exog_i</span><span class="s2">, </span><span class="s1">RHS).fit()</span>
        <span class="s1">xaxis_resid = res_xaxis.resid</span>
        <span class="s1">yaxis_resid = res_yaxis.resid</span>
        <span class="s1">x_axis_endog_name = res_xaxis.model.endog_names</span>
        <span class="s1">y_axis_endog_name = res_yaxis.model.endog_names</span>
        <span class="s1">ax.plot(xaxis_resid</span><span class="s2">, </span><span class="s1">yaxis_resid</span><span class="s2">, </span><span class="s3">'o'</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">fitted_line = OLS(yaxis_resid</span><span class="s2">, </span><span class="s1">xaxis_resid).fit()</span>

    <span class="s1">fig = abline_plot(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">fitted_line.params[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">color=</span><span class="s3">'k'</span><span class="s2">, </span><span class="s1">ax=ax)</span>

    <span class="s2">if </span><span class="s1">x_axis_endog_name == </span><span class="s3">'y'</span><span class="s1">:  </span><span class="s4"># for no names regression will just get a y</span>
        <span class="s1">x_axis_endog_name = </span><span class="s3">'x'  </span><span class="s4"># this is misleading, so use x</span>
    <span class="s1">ax.set_xlabel(</span><span class="s3">&quot;e(%s | X)&quot; </span><span class="s1">% x_axis_endog_name)</span>
    <span class="s1">ax.set_ylabel(</span><span class="s3">&quot;e(%s | X)&quot; </span><span class="s1">% y_axis_endog_name)</span>
    <span class="s1">ax.set_title(</span><span class="s3">'Partial Regression Plot'</span><span class="s2">, </span><span class="s1">**title_kwargs)</span>

    <span class="s4"># NOTE: if we want to get super fancy, we could annotate if a point is</span>
    <span class="s4"># clicked using this widget</span>
    <span class="s4"># http://stackoverflow.com/questions/4652439/</span>
    <span class="s4"># is-there-a-matplotlib-equivalent-of-matlabs-datacursormode/</span>
    <span class="s4"># 4674445#4674445</span>
    <span class="s2">if </span><span class="s1">obs_labels </span><span class="s2">is True</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">data </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">obs_labels = data.index</span>
        <span class="s2">elif </span><span class="s1">hasattr(exog_i</span><span class="s2">, </span><span class="s3">&quot;index&quot;</span><span class="s1">):</span>
            <span class="s1">obs_labels = exog_i.index</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">obs_labels = res_xaxis.model.data.row_labels</span>
        <span class="s4">#NOTE: row_labels can be None.</span>
        <span class="s4">#Maybe we should fix this to never be the case.</span>
        <span class="s2">if </span><span class="s1">obs_labels </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">obs_labels = lrange(len(exog_i))</span>

    <span class="s2">if </span><span class="s1">obs_labels </span><span class="s2">is not False</span><span class="s1">:  </span><span class="s4"># could be array_like</span>
        <span class="s2">if </span><span class="s1">len(obs_labels) != len(exog_i):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;obs_labels does not match length of exog_i&quot;</span><span class="s1">)</span>
        <span class="s1">label_kwargs.update(dict(ha=</span><span class="s3">&quot;center&quot;</span><span class="s2">, </span><span class="s1">va=</span><span class="s3">&quot;bottom&quot;</span><span class="s1">))</span>
        <span class="s1">ax = utils.annotate_axes(lrange(len(obs_labels))</span><span class="s2">, </span><span class="s1">obs_labels</span><span class="s2">,</span>
                                 <span class="s1">lzip(res_xaxis.resid</span><span class="s2">, </span><span class="s1">res_yaxis.resid)</span><span class="s2">,</span>
                                 <span class="s1">[(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">5</span><span class="s1">)] * len(obs_labels)</span><span class="s2">, </span><span class="s3">&quot;x-large&quot;</span><span class="s2">, </span><span class="s1">ax=ax</span><span class="s2">,</span>
                                 <span class="s1">**label_kwargs)</span>

    <span class="s2">if </span><span class="s1">ret_coords:</span>
        <span class="s2">return </span><span class="s1">fig</span><span class="s2">, </span><span class="s1">(res_xaxis.resid</span><span class="s2">, </span><span class="s1">res_yaxis.resid)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">fig</span>


<span class="s2">def </span><span class="s1">plot_partregress_grid(results</span><span class="s2">, </span><span class="s1">exog_idx=</span><span class="s2">None, </span><span class="s1">grid=</span><span class="s2">None, </span><span class="s1">fig=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Plot partial regression for a set of regressors. 
 
    Parameters 
    ---------- 
    results : Results instance 
        A regression model results instance. 
    exog_idx : {None, list[int], list[str]} 
        The indices  or column names of the exog used in the plot, default is 
        all. 
    grid : {None, tuple[int]} 
        If grid is given, then it is used for the arrangement of the subplots. 
        The format of grid is  (nrows, ncols). If grid is None, then ncol is 
        one, if there are only 2 subplots, and the number of columns is two 
        otherwise. 
    fig : Figure, optional 
        If given, this figure is simply returned.  Otherwise a new figure is 
        created. 
 
    Returns 
    ------- 
    Figure 
        If `fig` is None, the created figure.  Otherwise `fig` itself. 
 
    See Also 
    -------- 
    plot_partregress : Plot partial regression for a single regressor. 
    plot_ccpr : Plot CCPR against one regressor 
 
    Notes 
    ----- 
    A subplot is created for each explanatory variable given by exog_idx. 
    The partial regression plot shows the relationship between the response 
    and the given explanatory variable after removing the effect of all other 
    explanatory variables in exog. 
 
    References 
    ---------- 
    See http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/partregr.htm 
 
    Examples 
    -------- 
    Using the state crime dataset separately plot the effect of the each 
    variable on the on the outcome, murder rate while accounting for the effect 
    of all other variables in the model visualized with a grid of partial 
    regression plots. 
 
    &gt;&gt;&gt; from statsmodels.graphics.regressionplots import plot_partregress_grid 
    &gt;&gt;&gt; import statsmodels.api as sm 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; import statsmodels.formula.api as smf 
 
    &gt;&gt;&gt; fig = plt.figure(figsize=(8, 6)) 
    &gt;&gt;&gt; crime_data = sm.datasets.statecrime.load_pandas() 
    &gt;&gt;&gt; results = smf.ols('murder ~ hs_grad + urban + poverty + single', 
    ...                   data=crime_data.data).fit() 
    &gt;&gt;&gt; plot_partregress_grid(results, fig=fig) 
    &gt;&gt;&gt; plt.show() 
 
    .. plot:: plots/graphics_regression_partregress_grid.py 
    &quot;&quot;&quot;</span>
    <span class="s2">import </span><span class="s1">pandas</span>
    <span class="s1">fig = utils.create_mpl_fig(fig)</span>

    <span class="s1">exog_name</span><span class="s2">, </span><span class="s1">exog_idx = utils.maybe_name_or_idx(exog_idx</span><span class="s2">, </span><span class="s1">results.model)</span>

    <span class="s4"># TODO: maybe add option for using wendog, wexog instead</span>
    <span class="s1">y = pandas.Series(results.model.endog</span><span class="s2">, </span><span class="s1">name=results.model.endog_names)</span>
    <span class="s1">exog = results.model.exog</span>

    <span class="s1">k_vars = exog.shape[</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s4"># this function does not make sense if k_vars=1</span>

    <span class="s1">nrows = (len(exog_idx) + </span><span class="s5">1</span><span class="s1">) // </span><span class="s5">2</span>
    <span class="s1">ncols = </span><span class="s5">1 </span><span class="s2">if </span><span class="s1">nrows == len(exog_idx) </span><span class="s2">else </span><span class="s5">2</span>
    <span class="s2">if </span><span class="s1">grid </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">nrows</span><span class="s2">, </span><span class="s1">ncols = grid</span>
    <span class="s2">if </span><span class="s1">ncols &gt; </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">title_kwargs = {</span><span class="s3">&quot;fontdict&quot;</span><span class="s1">: {</span><span class="s3">&quot;fontsize&quot;</span><span class="s1">: </span><span class="s3">'small'</span><span class="s1">}}</span>

    <span class="s4"># for indexing purposes</span>
    <span class="s1">other_names = np.array(results.model.exog_names)</span>
    <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">idx </span><span class="s2">in </span><span class="s1">enumerate(exog_idx):</span>
        <span class="s1">others = lrange(k_vars)</span>
        <span class="s1">others.pop(idx)</span>
        <span class="s1">exog_others = pandas.DataFrame(exog[:</span><span class="s2">, </span><span class="s1">others]</span><span class="s2">,</span>
                                       <span class="s1">columns=other_names[others])</span>
        <span class="s1">ax = fig.add_subplot(nrows</span><span class="s2">, </span><span class="s1">ncols</span><span class="s2">, </span><span class="s1">i + </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">plot_partregress(y</span><span class="s2">, </span><span class="s1">pandas.Series(exog[:</span><span class="s2">, </span><span class="s1">idx]</span><span class="s2">,</span>
                                          <span class="s1">name=other_names[idx])</span><span class="s2">,</span>
                         <span class="s1">exog_others</span><span class="s2">, </span><span class="s1">ax=ax</span><span class="s2">, </span><span class="s1">title_kwargs=title_kwargs</span><span class="s2">,</span>
                         <span class="s1">obs_labels=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">ax.set_title(</span><span class="s3">&quot;&quot;</span><span class="s1">)</span>

    <span class="s1">fig.suptitle(</span><span class="s3">&quot;Partial Regression Plot&quot;</span><span class="s2">, </span><span class="s1">fontsize=</span><span class="s3">&quot;large&quot;</span><span class="s1">)</span>
    <span class="s1">fig.tight_layout()</span>
    <span class="s1">fig.subplots_adjust(top=</span><span class="s5">.95</span><span class="s1">)</span>

    <span class="s2">return </span><span class="s1">fig</span>


<span class="s2">def </span><span class="s1">plot_ccpr(results</span><span class="s2">, </span><span class="s1">exog_idx</span><span class="s2">, </span><span class="s1">ax=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Plot CCPR against one regressor. 
 
    Generates a component and component-plus-residual (CCPR) plot. 
 
    Parameters 
    ---------- 
    results : result instance 
        A regression results instance. 
    exog_idx : {int, str} 
        Exogenous, explanatory variable. If string is given, it should 
        be the variable name that you want to use, and you can use arbitrary 
        translations as with a formula. 
    ax : AxesSubplot, optional 
        If given, it is used to plot in instead of a new figure being 
        created. 
 
    Returns 
    ------- 
    Figure 
        If `ax` is None, the created figure.  Otherwise the figure to which 
        `ax` is connected. 
 
    See Also 
    -------- 
    plot_ccpr_grid : Creates CCPR plot for multiple regressors in a plot grid. 
 
    Notes 
    ----- 
    The CCPR plot provides a way to judge the effect of one regressor on the 
    response variable by taking into account the effects of the other 
    independent variables. The partial residuals plot is defined as 
    Residuals + B_i*X_i versus X_i. The component adds the B_i*X_i versus 
    X_i to show where the fitted line would lie. Care should be taken if X_i 
    is highly correlated with any of the other independent variables. If this 
    is the case, the variance evident in the plot will be an underestimate of 
    the true variance. 
 
    References 
    ---------- 
    http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/ccpr.htm 
 
    Examples 
    -------- 
    Using the state crime dataset plot the effect of the rate of single 
    households ('single') on the murder rate while accounting for high school 
    graduation rate ('hs_grad'), percentage of people in an urban area, and rate 
    of poverty ('poverty'). 
 
    &gt;&gt;&gt; import statsmodels.api as sm 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; import statsmodels.formula.api as smf 
 
    &gt;&gt;&gt; crime_data = sm.datasets.statecrime.load_pandas() 
    &gt;&gt;&gt; results = smf.ols('murder ~ hs_grad + urban + poverty + single', 
    ...                   data=crime_data.data).fit() 
    &gt;&gt;&gt; sm.graphics.plot_ccpr(results, 'single') 
    &gt;&gt;&gt; plt.show() 
 
    .. plot:: plots/graphics_regression_ccpr.py 
    &quot;&quot;&quot;</span>
    <span class="s1">fig</span><span class="s2">, </span><span class="s1">ax = utils.create_mpl_ax(ax)</span>

    <span class="s1">exog_name</span><span class="s2">, </span><span class="s1">exog_idx = utils.maybe_name_or_idx(exog_idx</span><span class="s2">, </span><span class="s1">results.model)</span>
    <span class="s1">results = maybe_unwrap_results(results)</span>

    <span class="s1">x1 = results.model.exog[:</span><span class="s2">, </span><span class="s1">exog_idx]</span>
    <span class="s4">#namestr = ' for %s' % self.name if self.name else ''</span>
    <span class="s1">x1beta = x1*results.params[exog_idx]</span>
    <span class="s1">ax.plot(x1</span><span class="s2">, </span><span class="s1">x1beta + results.resid</span><span class="s2">, </span><span class="s3">'o'</span><span class="s1">)</span>
    <span class="s2">from </span><span class="s1">statsmodels.tools.tools </span><span class="s2">import </span><span class="s1">add_constant</span>
    <span class="s1">mod = OLS(x1beta</span><span class="s2">, </span><span class="s1">add_constant(x1)).fit()</span>
    <span class="s1">params = mod.params</span>
    <span class="s1">fig = abline_plot(*params</span><span class="s2">, </span><span class="s1">**dict(ax=ax))</span>
    <span class="s4">#ax.plot(x1, x1beta, '-')</span>
    <span class="s1">ax.set_title(</span><span class="s3">'Component and component plus residual plot'</span><span class="s1">)</span>
    <span class="s1">ax.set_ylabel(</span><span class="s3">&quot;Residual + %s*beta_%d&quot; </span><span class="s1">% (exog_name</span><span class="s2">, </span><span class="s1">exog_idx))</span>
    <span class="s1">ax.set_xlabel(</span><span class="s3">&quot;%s&quot; </span><span class="s1">% exog_name)</span>

    <span class="s2">return </span><span class="s1">fig</span>


<span class="s2">def </span><span class="s1">plot_ccpr_grid(results</span><span class="s2">, </span><span class="s1">exog_idx=</span><span class="s2">None, </span><span class="s1">grid=</span><span class="s2">None, </span><span class="s1">fig=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Generate CCPR plots against a set of regressors, plot in a grid. 
 
    Generates a grid of component and component-plus-residual (CCPR) plots. 
 
    Parameters 
    ---------- 
    results : result instance 
        A results instance with exog and params. 
    exog_idx : None or list of int 
        The indices or column names of the exog used in the plot. 
    grid : None or tuple of int (nrows, ncols) 
        If grid is given, then it is used for the arrangement of the subplots. 
        If grid is None, then ncol is one, if there are only 2 subplots, and 
        the number of columns is two otherwise. 
    fig : Figure, optional 
        If given, this figure is simply returned.  Otherwise a new figure is 
        created. 
 
    Returns 
    ------- 
    Figure 
        If `ax` is None, the created figure.  Otherwise the figure to which 
        `ax` is connected. 
 
    See Also 
    -------- 
    plot_ccpr : Creates CCPR plot for a single regressor. 
 
    Notes 
    ----- 
    Partial residual plots are formed as:: 
 
        Res + Betahat(i)*Xi versus Xi 
 
    and CCPR adds:: 
 
        Betahat(i)*Xi versus Xi 
 
    References 
    ---------- 
    See http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/ccpr.htm 
 
    Examples 
    -------- 
    Using the state crime dataset separately plot the effect of the each 
    variable on the on the outcome, murder rate while accounting for the effect 
    of all other variables in the model. 
 
    &gt;&gt;&gt; import statsmodels.api as sm 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; import statsmodels.formula.api as smf 
 
    &gt;&gt;&gt; fig = plt.figure(figsize=(8, 8)) 
    &gt;&gt;&gt; crime_data = sm.datasets.statecrime.load_pandas() 
    &gt;&gt;&gt; results = smf.ols('murder ~ hs_grad + urban + poverty + single', 
    ...                   data=crime_data.data).fit() 
    &gt;&gt;&gt; sm.graphics.plot_ccpr_grid(results, fig=fig) 
    &gt;&gt;&gt; plt.show() 
 
    .. plot:: plots/graphics_regression_ccpr_grid.py 
    &quot;&quot;&quot;</span>
    <span class="s1">fig = utils.create_mpl_fig(fig)</span>

    <span class="s1">exog_name</span><span class="s2">, </span><span class="s1">exog_idx = utils.maybe_name_or_idx(exog_idx</span><span class="s2">, </span><span class="s1">results.model)</span>

    <span class="s2">if </span><span class="s1">grid </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">nrows</span><span class="s2">, </span><span class="s1">ncols = grid</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">len(exog_idx) &gt; </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">nrows = int(np.ceil(len(exog_idx)/</span><span class="s5">2.</span><span class="s1">))</span>
            <span class="s1">ncols = </span><span class="s5">2</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">nrows = len(exog_idx)</span>
            <span class="s1">ncols = </span><span class="s5">1</span>

    <span class="s1">seen_constant = </span><span class="s5">0</span>
    <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">idx </span><span class="s2">in </span><span class="s1">enumerate(exog_idx):</span>
        <span class="s2">if </span><span class="s1">results.model.exog[:</span><span class="s2">, </span><span class="s1">idx].var() == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">seen_constant = </span><span class="s5">1</span>
            <span class="s2">continue</span>

        <span class="s1">ax = fig.add_subplot(nrows</span><span class="s2">, </span><span class="s1">ncols</span><span class="s2">, </span><span class="s1">i+</span><span class="s5">1</span><span class="s1">-seen_constant)</span>
        <span class="s1">fig = plot_ccpr(results</span><span class="s2">, </span><span class="s1">exog_idx=idx</span><span class="s2">, </span><span class="s1">ax=ax)</span>
        <span class="s1">ax.set_title(</span><span class="s3">&quot;&quot;</span><span class="s1">)</span>

    <span class="s1">fig.suptitle(</span><span class="s3">&quot;Component-Component Plus Residual Plot&quot;</span><span class="s2">, </span><span class="s1">fontsize=</span><span class="s3">&quot;large&quot;</span><span class="s1">)</span>

    <span class="s1">fig.tight_layout()</span>

    <span class="s1">fig.subplots_adjust(top=</span><span class="s5">.95</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">fig</span>


<span class="s2">def </span><span class="s1">abline_plot(intercept=</span><span class="s2">None, </span><span class="s1">slope=</span><span class="s2">None, </span><span class="s1">horiz=</span><span class="s2">None, </span><span class="s1">vert=</span><span class="s2">None,</span>
                <span class="s1">model_results=</span><span class="s2">None, </span><span class="s1">ax=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
    <span class="s0">&quot;&quot;&quot; 
    Plot a line given an intercept and slope. 
 
    Parameters 
    ---------- 
    intercept : float 
        The intercept of the line. 
    slope : float 
        The slope of the line. 
    horiz : float or array_like 
        Data for horizontal lines on the y-axis. 
    vert : array_like 
        Data for verterical lines on the x-axis. 
    model_results : statsmodels results instance 
        Any object that has a two-value `params` attribute. Assumed that it 
        is (intercept, slope). 
    ax : axes, optional 
        Matplotlib axes instance. 
    **kwargs 
        Options passed to matplotlib.pyplot.plt. 
 
    Returns 
    ------- 
    Figure 
        The figure given by `ax.figure` or a new instance. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import statsmodels.api as sm 
 
    &gt;&gt;&gt; np.random.seed(12345) 
    &gt;&gt;&gt; X = sm.add_constant(np.random.normal(0, 20, size=30)) 
    &gt;&gt;&gt; y = np.dot(X, [25, 3.5]) + np.random.normal(0, 30, size=30) 
    &gt;&gt;&gt; mod = sm.OLS(y,X).fit() 
    &gt;&gt;&gt; fig = sm.graphics.abline_plot(model_results=mod) 
    &gt;&gt;&gt; ax = fig.axes[0] 
    &gt;&gt;&gt; ax.scatter(X[:,1], y) 
    &gt;&gt;&gt; ax.margins(.1) 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; plt.show() 
 
    .. plot:: plots/graphics_regression_abline.py 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">ax </span><span class="s2">is not None</span><span class="s1">:  </span><span class="s4"># get axis limits first thing, do not change these</span>
        <span class="s1">x = ax.get_xlim()</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">x = </span><span class="s2">None</span>

    <span class="s1">fig</span><span class="s2">, </span><span class="s1">ax = utils.create_mpl_ax(ax)</span>

    <span class="s2">if </span><span class="s1">model_results:</span>
        <span class="s1">intercept</span><span class="s2">, </span><span class="s1">slope = model_results.params</span>
        <span class="s2">if </span><span class="s1">x </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">x = [model_results.model.exog[:</span><span class="s2">, </span><span class="s5">1</span><span class="s1">].min()</span><span class="s2">,</span>
                 <span class="s1">model_results.model.exog[:</span><span class="s2">, </span><span class="s5">1</span><span class="s1">].max()]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">if not </span><span class="s1">(intercept </span><span class="s2">is not None and </span><span class="s1">slope </span><span class="s2">is not None</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;specify slope and intercepty or model_results&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">x </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">x = ax.get_xlim()</span>

    <span class="s1">data_y = [x[</span><span class="s5">0</span><span class="s1">]*slope+intercept</span><span class="s2">, </span><span class="s1">x[</span><span class="s5">1</span><span class="s1">]*slope+intercept]</span>
    <span class="s1">ax.set_xlim(x)</span>
    <span class="s4">#ax.set_ylim(y)</span>

    <span class="s2">from </span><span class="s1">matplotlib.lines </span><span class="s2">import </span><span class="s1">Line2D</span>

    <span class="s2">class </span><span class="s1">ABLine2D(Line2D):</span>
        <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
            <span class="s1">super(ABLine2D</span><span class="s2">, </span><span class="s1">self).__init__(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
            <span class="s1">self.id_xlim_callback = </span><span class="s2">None</span>
            <span class="s1">self.id_ylim_callback = </span><span class="s2">None</span>

        <span class="s2">def </span><span class="s1">remove(self):</span>
            <span class="s1">ax = self.axes</span>
            <span class="s2">if </span><span class="s1">self.id_xlim_callback:</span>
                <span class="s1">ax.callbacks.disconnect(self.id_xlim_callback)</span>
            <span class="s2">if </span><span class="s1">self.id_ylim_callback:</span>
                <span class="s1">ax.callbacks.disconnect(self.id_ylim_callback)</span>
            <span class="s1">super(ABLine2D</span><span class="s2">, </span><span class="s1">self).remove()</span>

        <span class="s2">def </span><span class="s1">update_datalim(self</span><span class="s2">, </span><span class="s1">ax):</span>
            <span class="s1">ax.set_autoscale_on(</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s1">children = ax.get_children()</span>
            <span class="s1">ablines = [child </span><span class="s2">for </span><span class="s1">child </span><span class="s2">in </span><span class="s1">children </span><span class="s2">if </span><span class="s1">child </span><span class="s2">is </span><span class="s1">self]</span>
            <span class="s1">abline = ablines[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">x = ax.get_xlim()</span>
            <span class="s1">y = [x[</span><span class="s5">0</span><span class="s1">] * slope + intercept</span><span class="s2">, </span><span class="s1">x[</span><span class="s5">1</span><span class="s1">] * slope + intercept]</span>
            <span class="s1">abline.set_data(x</span><span class="s2">, </span><span class="s1">y)</span>
            <span class="s1">ax.figure.canvas.draw()</span>

    <span class="s4"># TODO: how to intercept something like a margins call and adjust?</span>
    <span class="s1">line = ABLine2D(x</span><span class="s2">, </span><span class="s1">data_y</span><span class="s2">, </span><span class="s1">**kwargs)</span>
    <span class="s1">ax.add_line(line)</span>
    <span class="s1">line.id_xlim_callback = ax.callbacks.connect(</span><span class="s3">'xlim_changed'</span><span class="s2">, </span><span class="s1">line.update_datalim)</span>
    <span class="s1">line.id_ylim_callback = ax.callbacks.connect(</span><span class="s3">'ylim_changed'</span><span class="s2">, </span><span class="s1">line.update_datalim)</span>

    <span class="s2">if </span><span class="s1">horiz:</span>
        <span class="s1">ax.hline(horiz)</span>
    <span class="s2">if </span><span class="s1">vert:</span>
        <span class="s1">ax.vline(vert)</span>
    <span class="s2">return </span><span class="s1">fig</span>


<span class="s1">@Appender(_plot_influence_doc.format(**{</span>
    <span class="s3">'extra_params_doc'</span><span class="s1">: </span><span class="s3">&quot;results: object</span><span class="s2">\n</span><span class="s3">&quot;</span>
                        <span class="s3">&quot;        Results for a fitted regression model.</span><span class="s2">\n</span><span class="s3">&quot;</span>
                        <span class="s3">&quot;    influence: instance</span><span class="s2">\n</span><span class="s3">&quot;</span>
                        <span class="s3">&quot;        The instance of Influence for model.&quot;</span><span class="s1">}))</span>
<span class="s2">def </span><span class="s1">_influence_plot(results</span><span class="s2">, </span><span class="s1">influence</span><span class="s2">, </span><span class="s1">external=</span><span class="s2">True, </span><span class="s1">alpha=</span><span class="s5">.05</span><span class="s2">,</span>
                    <span class="s1">criterion=</span><span class="s3">&quot;cooks&quot;</span><span class="s2">, </span><span class="s1">size=</span><span class="s5">48</span><span class="s2">, </span><span class="s1">plot_alpha=</span><span class="s5">.75</span><span class="s2">, </span><span class="s1">ax=</span><span class="s2">None,</span>
                    <span class="s1">leverage=</span><span class="s2">None, </span><span class="s1">resid=</span><span class="s2">None,</span>
                    <span class="s1">**kwargs):</span>
    <span class="s4"># leverage and resid kwds are used only internally for MLEInfluence</span>
    <span class="s1">infl = influence</span>
    <span class="s1">fig</span><span class="s2">, </span><span class="s1">ax = utils.create_mpl_ax(ax)</span>

    <span class="s2">if </span><span class="s1">criterion.lower().startswith(</span><span class="s3">'coo'</span><span class="s1">):</span>
        <span class="s1">psize = infl.cooks_distance[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s2">elif </span><span class="s1">criterion.lower().startswith(</span><span class="s3">'dff'</span><span class="s1">):</span>
        <span class="s1">psize = np.abs(infl.dffits[</span><span class="s5">0</span><span class="s1">])</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Criterion %s not understood&quot; </span><span class="s1">% criterion)</span>

    <span class="s4"># scale the variables</span>
    <span class="s4">#TODO: what is the correct scaling and the assumption here?</span>
    <span class="s4">#we want plots to be comparable across different plots</span>
    <span class="s4">#so we would need to use the expected distribution of criterion probably</span>
    <span class="s1">old_range = np.ptp(psize)</span>
    <span class="s1">new_range = size**</span><span class="s5">2 </span><span class="s1">- </span><span class="s5">8</span><span class="s1">**</span><span class="s5">2</span>

    <span class="s1">psize = (psize - psize.min()) * new_range/old_range + </span><span class="s5">8</span><span class="s1">**</span><span class="s5">2</span>

    <span class="s2">if </span><span class="s1">leverage </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">leverage = infl.hat_matrix_diag</span>
    <span class="s2">if </span><span class="s1">resid </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">ylabel = </span><span class="s3">&quot;Studentized Residuals&quot;</span>
        <span class="s2">if </span><span class="s1">external:</span>
            <span class="s1">resid = infl.resid_studentized_external</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">resid = infl.resid_studentized</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">resid = np.asarray(resid)</span>
        <span class="s1">ylabel = </span><span class="s3">&quot;Residuals&quot;</span>

    <span class="s2">from </span><span class="s1">scipy </span><span class="s2">import </span><span class="s1">stats</span>

    <span class="s1">cutoff = stats.t.ppf(</span><span class="s5">1.</span><span class="s1">-alpha/</span><span class="s5">2</span><span class="s2">, </span><span class="s1">results.df_resid)</span>
    <span class="s1">large_resid = np.abs(resid) &gt; cutoff</span>
    <span class="s1">large_leverage = leverage &gt; _high_leverage(results)</span>
    <span class="s1">large_points = np.logical_or(large_resid</span><span class="s2">, </span><span class="s1">large_leverage)</span>

    <span class="s1">ax.scatter(leverage</span><span class="s2">, </span><span class="s1">resid</span><span class="s2">, </span><span class="s1">s=psize</span><span class="s2">, </span><span class="s1">alpha=plot_alpha)</span>

    <span class="s4"># add point labels</span>
    <span class="s1">labels = results.model.data.row_labels</span>
    <span class="s2">if </span><span class="s1">labels </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">labels = lrange(len(resid))</span>
    <span class="s1">ax = utils.annotate_axes(np.where(large_points)[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">labels</span><span class="s2">,</span>
                             <span class="s1">lzip(leverage</span><span class="s2">, </span><span class="s1">resid)</span><span class="s2">,</span>
                             <span class="s1">lzip(-(psize/</span><span class="s5">2</span><span class="s1">)**</span><span class="s5">.5</span><span class="s2">, </span><span class="s1">(psize/</span><span class="s5">2</span><span class="s1">)**</span><span class="s5">.5</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;x-large&quot;</span><span class="s2">,</span>
                             <span class="s1">ax)</span>

    <span class="s4"># TODO: make configurable or let people do it ex-post?</span>
    <span class="s1">font = {</span><span class="s3">&quot;fontsize&quot;</span><span class="s1">: </span><span class="s5">16</span><span class="s2">, </span><span class="s3">&quot;color&quot;</span><span class="s1">: </span><span class="s3">&quot;black&quot;</span><span class="s1">}</span>
    <span class="s1">ax.set_ylabel(ylabel</span><span class="s2">, </span><span class="s1">**font)</span>
    <span class="s1">ax.set_xlabel(</span><span class="s3">&quot;Leverage&quot;</span><span class="s2">, </span><span class="s1">**font)</span>
    <span class="s1">ax.set_title(</span><span class="s3">&quot;Influence Plot&quot;</span><span class="s2">, </span><span class="s1">**font)</span>
    <span class="s2">return </span><span class="s1">fig</span>


<span class="s1">@Appender(_plot_influence_doc.format(**{</span>
    <span class="s3">'extra_params_doc'</span><span class="s1">: </span><span class="s3">&quot;results : Results</span><span class="s2">\n</span><span class="s3">&quot;</span>
                        <span class="s3">&quot;        Results for a fitted regression model.&quot;</span><span class="s1">}))</span>
<span class="s2">def </span><span class="s1">influence_plot(results</span><span class="s2">, </span><span class="s1">external=</span><span class="s2">True, </span><span class="s1">alpha=</span><span class="s5">.05</span><span class="s2">, </span><span class="s1">criterion=</span><span class="s3">&quot;cooks&quot;</span><span class="s2">,</span>
                   <span class="s1">size=</span><span class="s5">48</span><span class="s2">, </span><span class="s1">plot_alpha=</span><span class="s5">.75</span><span class="s2">, </span><span class="s1">ax=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>

    <span class="s1">infl = results.get_influence()</span>
    <span class="s1">res = _influence_plot(results</span><span class="s2">, </span><span class="s1">infl</span><span class="s2">, </span><span class="s1">external=external</span><span class="s2">, </span><span class="s1">alpha=alpha</span><span class="s2">,</span>
                          <span class="s1">criterion=criterion</span><span class="s2">, </span><span class="s1">size=size</span><span class="s2">,</span>
                          <span class="s1">plot_alpha=plot_alpha</span><span class="s2">, </span><span class="s1">ax=ax</span><span class="s2">, </span><span class="s1">**kwargs)</span>
    <span class="s2">return </span><span class="s1">res</span>


<span class="s1">@Appender(_plot_leverage_resid2_doc.format({</span>
    <span class="s3">'extra_params_doc'</span><span class="s1">: </span><span class="s3">&quot;results: object</span><span class="s2">\n</span><span class="s3">&quot;</span>
                        <span class="s3">&quot;    Results for a fitted regression model</span><span class="s2">\n</span><span class="s3">&quot;</span>
                        <span class="s3">&quot;influence: instance</span><span class="s2">\n</span><span class="s3">&quot;</span>
                        <span class="s3">&quot;    instance of Influence for model&quot;</span><span class="s1">}))</span>
<span class="s2">def </span><span class="s1">_plot_leverage_resid2(results</span><span class="s2">, </span><span class="s1">influence</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s5">.05</span><span class="s2">, </span><span class="s1">ax=</span><span class="s2">None,</span>
                         <span class="s1">**kwargs):</span>

    <span class="s2">from </span><span class="s1">scipy.stats </span><span class="s2">import </span><span class="s1">norm</span><span class="s2">, </span><span class="s1">zscore</span>
    <span class="s1">fig</span><span class="s2">, </span><span class="s1">ax = utils.create_mpl_ax(ax)</span>

    <span class="s1">infl = influence</span>
    <span class="s1">leverage = infl.hat_matrix_diag</span>
    <span class="s1">resid = zscore(infl.resid)</span>
    <span class="s1">ax.plot(resid**</span><span class="s5">2</span><span class="s2">, </span><span class="s1">leverage</span><span class="s2">, </span><span class="s3">'o'</span><span class="s2">, </span><span class="s1">**kwargs)</span>
    <span class="s1">ax.set_xlabel(</span><span class="s3">&quot;Normalized residuals**2&quot;</span><span class="s1">)</span>
    <span class="s1">ax.set_ylabel(</span><span class="s3">&quot;Leverage&quot;</span><span class="s1">)</span>
    <span class="s1">ax.set_title(</span><span class="s3">&quot;Leverage vs. Normalized residuals squared&quot;</span><span class="s1">)</span>

    <span class="s1">large_leverage = leverage &gt; _high_leverage(results)</span>
    <span class="s4">#norm or t here if standardized?</span>
    <span class="s1">cutoff = norm.ppf(</span><span class="s5">1.</span><span class="s1">-alpha/</span><span class="s5">2</span><span class="s1">)</span>
    <span class="s1">large_resid = np.abs(resid) &gt; cutoff</span>
    <span class="s1">labels = results.model.data.row_labels</span>
    <span class="s2">if </span><span class="s1">labels </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">labels = lrange(int(results.nobs))</span>
    <span class="s1">index = np.where(np.logical_or(large_leverage</span><span class="s2">, </span><span class="s1">large_resid))[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">ax = utils.annotate_axes(index</span><span class="s2">, </span><span class="s1">labels</span><span class="s2">, </span><span class="s1">lzip(resid**</span><span class="s5">2</span><span class="s2">, </span><span class="s1">leverage)</span><span class="s2">,</span>
                             <span class="s1">[(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">5</span><span class="s1">)]*int(results.nobs)</span><span class="s2">, </span><span class="s3">&quot;large&quot;</span><span class="s2">,</span>
                             <span class="s1">ax=ax</span><span class="s2">, </span><span class="s1">ha=</span><span class="s3">&quot;center&quot;</span><span class="s2">, </span><span class="s1">va=</span><span class="s3">&quot;bottom&quot;</span><span class="s1">)</span>
    <span class="s1">ax.margins(</span><span class="s5">.075</span><span class="s2">, </span><span class="s5">.075</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">fig</span>


<span class="s1">@Appender(_plot_leverage_resid2_doc.format({</span>
    <span class="s3">'extra_params_doc'</span><span class="s1">: </span><span class="s3">&quot;results : object</span><span class="s2">\n</span><span class="s3">&quot;</span>
                        <span class="s3">&quot;    Results for a fitted regression model&quot;</span><span class="s1">}))</span>
<span class="s2">def </span><span class="s1">plot_leverage_resid2(results</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s5">.05</span><span class="s2">, </span><span class="s1">ax=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>

    <span class="s1">infl = results.get_influence()</span>
    <span class="s2">return </span><span class="s1">_plot_leverage_resid2(results</span><span class="s2">, </span><span class="s1">infl</span><span class="s2">, </span><span class="s1">alpha=alpha</span><span class="s2">, </span><span class="s1">ax=ax</span><span class="s2">, </span><span class="s1">**kwargs)</span>



<span class="s1">@Appender(_plot_added_variable_doc % {</span>
    <span class="s3">'extra_params_doc'</span><span class="s1">: </span><span class="s3">&quot;results : object</span><span class="s2">\n</span><span class="s3">&quot;</span>
                        <span class="s3">&quot;    Results for a fitted regression model&quot;</span><span class="s1">})</span>
<span class="s2">def </span><span class="s1">plot_added_variable(results</span><span class="s2">, </span><span class="s1">focus_exog</span><span class="s2">, </span><span class="s1">resid_type=</span><span class="s2">None,</span>
                        <span class="s1">use_glm_weights=</span><span class="s2">True, </span><span class="s1">fit_kwargs=</span><span class="s2">None, </span><span class="s1">ax=</span><span class="s2">None</span><span class="s1">):</span>

    <span class="s1">model = results.model</span>

    <span class="s1">fig</span><span class="s2">, </span><span class="s1">ax = utils.create_mpl_ax(ax)</span>

    <span class="s1">endog_resid</span><span class="s2">, </span><span class="s1">focus_exog_resid =\</span>
                 <span class="s1">added_variable_resids(results</span><span class="s2">, </span><span class="s1">focus_exog</span><span class="s2">,</span>
                                       <span class="s1">resid_type=resid_type</span><span class="s2">,</span>
                                       <span class="s1">use_glm_weights=use_glm_weights</span><span class="s2">,</span>
                                       <span class="s1">fit_kwargs=fit_kwargs)</span>

    <span class="s1">ax.plot(focus_exog_resid</span><span class="s2">, </span><span class="s1">endog_resid</span><span class="s2">, </span><span class="s3">'o'</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s5">0.6</span><span class="s1">)</span>

    <span class="s1">ax.set_title(</span><span class="s3">'Added variable plot'</span><span class="s2">, </span><span class="s1">fontsize=</span><span class="s3">'large'</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">isinstance(focus_exog</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s1">xname = focus_exog</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">xname = model.exog_names[focus_exog]</span>
    <span class="s1">ax.set_xlabel(xname</span><span class="s2">, </span><span class="s1">size=</span><span class="s5">15</span><span class="s1">)</span>
    <span class="s1">ax.set_ylabel(model.endog_names + </span><span class="s3">&quot; residuals&quot;</span><span class="s2">, </span><span class="s1">size=</span><span class="s5">15</span><span class="s1">)</span>

    <span class="s2">return </span><span class="s1">fig</span>


<span class="s1">@Appender(_plot_partial_residuals_doc % {</span>
    <span class="s3">'extra_params_doc'</span><span class="s1">: </span><span class="s3">&quot;results : object</span><span class="s2">\n</span><span class="s3">&quot;</span>
                        <span class="s3">&quot;    Results for a fitted regression model&quot;</span><span class="s1">})</span>
<span class="s2">def </span><span class="s1">plot_partial_residuals(results</span><span class="s2">, </span><span class="s1">focus_exog</span><span class="s2">, </span><span class="s1">ax=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s4"># Docstring attached below</span>

    <span class="s1">model = results.model</span>

    <span class="s1">focus_exog</span><span class="s2">, </span><span class="s1">focus_col = utils.maybe_name_or_idx(focus_exog</span><span class="s2">, </span><span class="s1">model)</span>

    <span class="s1">pr = partial_resids(results</span><span class="s2">, </span><span class="s1">focus_exog)</span>
    <span class="s1">focus_exog_vals = results.model.exog[:</span><span class="s2">, </span><span class="s1">focus_col]</span>

    <span class="s1">fig</span><span class="s2">, </span><span class="s1">ax = utils.create_mpl_ax(ax)</span>
    <span class="s1">ax.plot(focus_exog_vals</span><span class="s2">, </span><span class="s1">pr</span><span class="s2">, </span><span class="s3">'o'</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s5">0.6</span><span class="s1">)</span>

    <span class="s1">ax.set_title(</span><span class="s3">'Partial residuals plot'</span><span class="s2">, </span><span class="s1">fontsize=</span><span class="s3">'large'</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">isinstance(focus_exog</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s1">xname = focus_exog</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">xname = model.exog_names[focus_exog]</span>
    <span class="s1">ax.set_xlabel(xname</span><span class="s2">, </span><span class="s1">size=</span><span class="s5">15</span><span class="s1">)</span>
    <span class="s1">ax.set_ylabel(</span><span class="s3">&quot;Component plus residual&quot;</span><span class="s2">, </span><span class="s1">size=</span><span class="s5">15</span><span class="s1">)</span>

    <span class="s2">return </span><span class="s1">fig</span>


<span class="s1">@Appender(_plot_ceres_residuals_doc % {</span>
    <span class="s3">'extra_params_doc'</span><span class="s1">: </span><span class="s3">&quot;results : Results</span><span class="s2">\n</span><span class="s3">&quot;</span>
                        <span class="s3">&quot;        Results instance of a fitted regression &quot;</span>
                        <span class="s3">&quot;model.&quot;</span><span class="s1">})</span>
<span class="s2">def </span><span class="s1">plot_ceres_residuals(results</span><span class="s2">, </span><span class="s1">focus_exog</span><span class="s2">, </span><span class="s1">frac=</span><span class="s5">0.66</span><span class="s2">, </span><span class="s1">cond_means=</span><span class="s2">None,</span>
                         <span class="s1">ax=</span><span class="s2">None</span><span class="s1">):</span>

    <span class="s1">model = results.model</span>

    <span class="s1">focus_exog</span><span class="s2">, </span><span class="s1">focus_col = utils.maybe_name_or_idx(focus_exog</span><span class="s2">, </span><span class="s1">model)</span>

    <span class="s1">presid = ceres_resids(results</span><span class="s2">, </span><span class="s1">focus_exog</span><span class="s2">, </span><span class="s1">frac=frac</span><span class="s2">,</span>
                          <span class="s1">cond_means=cond_means)</span>

    <span class="s1">focus_exog_vals = model.exog[:</span><span class="s2">, </span><span class="s1">focus_col]</span>

    <span class="s1">fig</span><span class="s2">, </span><span class="s1">ax = utils.create_mpl_ax(ax)</span>
    <span class="s1">ax.plot(focus_exog_vals</span><span class="s2">, </span><span class="s1">presid</span><span class="s2">, </span><span class="s3">'o'</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s5">0.6</span><span class="s1">)</span>

    <span class="s1">ax.set_title(</span><span class="s3">'CERES residuals plot'</span><span class="s2">, </span><span class="s1">fontsize=</span><span class="s3">'large'</span><span class="s1">)</span>

    <span class="s1">ax.set_xlabel(focus_exog</span><span class="s2">, </span><span class="s1">size=</span><span class="s5">15</span><span class="s1">)</span>
    <span class="s1">ax.set_ylabel(</span><span class="s3">&quot;Component plus residual&quot;</span><span class="s2">, </span><span class="s1">size=</span><span class="s5">15</span><span class="s1">)</span>

    <span class="s2">return </span><span class="s1">fig</span>


<span class="s2">def </span><span class="s1">ceres_resids(results</span><span class="s2">, </span><span class="s1">focus_exog</span><span class="s2">, </span><span class="s1">frac=</span><span class="s5">0.66</span><span class="s2">, </span><span class="s1">cond_means=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Calculate the CERES residuals (Conditional Expectation Partial 
    Residuals) for a fitted model. 
 
    Parameters 
    ---------- 
    results : model results instance 
        The fitted model for which the CERES residuals are calculated. 
    focus_exog : int 
        The column of results.model.exog used as the 'focus variable'. 
    frac : float, optional 
        Lowess smoothing parameter for estimating the conditional 
        means.  Not used if `cond_means` is provided. 
    cond_means : array_like, optional 
        If provided, the columns of this array are the conditional 
        means E[exog | focus exog], where exog ranges over some 
        or all of the columns of exog other than focus exog.  If 
        this is an empty nx0 array, the conditional means are 
        treated as being zero.  If None, the conditional means are 
        estimated. 
 
    Returns 
    ------- 
    An array containing the CERES residuals. 
 
    Notes 
    ----- 
    If `cond_means` is not provided, it is obtained by smoothing each 
    column of exog (except the focus column) against the focus column. 
 
    Currently only supports GLM, GEE, and OLS models. 
    &quot;&quot;&quot;</span>

    <span class="s1">model = results.model</span>

    <span class="s2">if not </span><span class="s1">isinstance(model</span><span class="s2">, </span><span class="s1">(GLM</span><span class="s2">, </span><span class="s1">GEE</span><span class="s2">, </span><span class="s1">OLS)):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;ceres residuals not available for %s&quot; </span><span class="s1">%</span>
                         <span class="s1">model.__class__.__name__)</span>

    <span class="s1">focus_exog</span><span class="s2">, </span><span class="s1">focus_col = utils.maybe_name_or_idx(focus_exog</span><span class="s2">, </span><span class="s1">model)</span>

    <span class="s4"># Indices of non-focus columns</span>
    <span class="s1">ix_nf = range(len(results.params))</span>
    <span class="s1">ix_nf = list(ix_nf)</span>
    <span class="s1">ix_nf.pop(focus_col)</span>
    <span class="s1">nnf = len(ix_nf)</span>

    <span class="s4"># Estimate the conditional means if not provided.</span>
    <span class="s2">if </span><span class="s1">cond_means </span><span class="s2">is None</span><span class="s1">:</span>

        <span class="s4"># Below we calculate E[x | focus] where x is each column other</span>
        <span class="s4"># than the focus column.  We do not want the intercept when we do</span>
        <span class="s4"># this so we remove it here.</span>
        <span class="s1">pexog = model.exog[:</span><span class="s2">, </span><span class="s1">ix_nf]</span>
        <span class="s1">pexog -= pexog.mean(</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">u</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">vt = np.linalg.svd(pexog</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">ii = np.flatnonzero(s &gt; </span><span class="s5">1e-6</span><span class="s1">)</span>
        <span class="s1">pexog = u[:</span><span class="s2">, </span><span class="s1">ii]</span>

        <span class="s1">fcol = model.exog[:</span><span class="s2">, </span><span class="s1">focus_col]</span>
        <span class="s1">cond_means = np.empty((len(fcol)</span><span class="s2">, </span><span class="s1">pexog.shape[</span><span class="s5">1</span><span class="s1">]))</span>
        <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(pexog.shape[</span><span class="s5">1</span><span class="s1">]):</span>

            <span class="s4"># Get the fitted values for column i given the other</span>
            <span class="s4"># columns (skip the intercept).</span>
            <span class="s1">y0 = pexog[:</span><span class="s2">, </span><span class="s1">j]</span>

            <span class="s1">cf = lowess(y0</span><span class="s2">, </span><span class="s1">fcol</span><span class="s2">, </span><span class="s1">frac=frac</span><span class="s2">, </span><span class="s1">return_sorted=</span><span class="s2">False</span><span class="s1">)</span>

            <span class="s1">cond_means[:</span><span class="s2">, </span><span class="s1">j] = cf</span>

    <span class="s1">new_exog = np.concatenate((model.exog[:</span><span class="s2">, </span><span class="s1">ix_nf]</span><span class="s2">, </span><span class="s1">cond_means)</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">1</span><span class="s1">)</span>

    <span class="s4"># Refit the model using the adjusted exog values</span>
    <span class="s1">klass = model.__class__</span>
    <span class="s1">init_kwargs = model._get_init_kwds()</span>
    <span class="s1">new_model = klass(model.endog</span><span class="s2">, </span><span class="s1">new_exog</span><span class="s2">, </span><span class="s1">**init_kwargs)</span>
    <span class="s1">new_result = new_model.fit()</span>

    <span class="s4"># The partial residual, with respect to l(x2) (notation of Cook 1998)</span>
    <span class="s1">presid = model.endog - new_result.fittedvalues</span>
    <span class="s2">if </span><span class="s1">isinstance(model</span><span class="s2">, </span><span class="s1">(GLM</span><span class="s2">, </span><span class="s1">GEE)):</span>
        <span class="s1">presid *= model.family.link.deriv(new_result.fittedvalues)</span>
    <span class="s2">if </span><span class="s1">new_exog.shape[</span><span class="s5">1</span><span class="s1">] &gt; nnf:</span>
        <span class="s1">presid += np.dot(new_exog[:</span><span class="s2">, </span><span class="s1">nnf:]</span><span class="s2">, </span><span class="s1">new_result.params[nnf:])</span>

    <span class="s2">return </span><span class="s1">presid</span>

<span class="s2">def </span><span class="s1">partial_resids(results</span><span class="s2">, </span><span class="s1">focus_exog):</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns partial residuals for a fitted model with respect to a 
    'focus predictor'. 
 
    Parameters 
    ---------- 
    results : results instance 
        A fitted regression model. 
    focus col : int 
        The column index of model.exog with respect to which the 
        partial residuals are calculated. 
 
    Returns 
    ------- 
    An array of partial residuals. 
 
    References 
    ---------- 
    RD Cook and R Croos-Dabrera (1998).  Partial residual plots in 
    generalized linear models.  Journal of the American Statistical 
    Association, 93:442. 
    &quot;&quot;&quot;</span>

    <span class="s4"># TODO: could be a method of results</span>
    <span class="s4"># TODO: see Cook et al (1998) for a more general definition</span>

    <span class="s4"># The calculation follows equation (8) from Cook's paper.</span>
    <span class="s1">model = results.model</span>
    <span class="s1">resid = model.endog - results.predict()</span>

    <span class="s2">if </span><span class="s1">isinstance(model</span><span class="s2">, </span><span class="s1">(GLM</span><span class="s2">, </span><span class="s1">GEE)):</span>
        <span class="s1">resid *= model.family.link.deriv(results.fittedvalues)</span>
    <span class="s2">elif </span><span class="s1">isinstance(model</span><span class="s2">, </span><span class="s1">(OLS</span><span class="s2">, </span><span class="s1">GLS</span><span class="s2">, </span><span class="s1">WLS)):</span>
        <span class="s2">pass </span><span class="s4"># No need to do anything</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Partial residuals for '%s' not implemented.&quot;</span>
                         <span class="s1">% type(model))</span>

    <span class="s2">if </span><span class="s1">type(focus_exog) </span><span class="s2">is </span><span class="s1">str:</span>
        <span class="s1">focus_col = model.exog_names.index(focus_exog)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">focus_col = focus_exog</span>

    <span class="s1">focus_val = results.params[focus_col] * model.exog[:</span><span class="s2">, </span><span class="s1">focus_col]</span>

    <span class="s2">return </span><span class="s1">focus_val + resid</span>

<span class="s2">def </span><span class="s1">added_variable_resids(results</span><span class="s2">, </span><span class="s1">focus_exog</span><span class="s2">, </span><span class="s1">resid_type=</span><span class="s2">None,</span>
                          <span class="s1">use_glm_weights=</span><span class="s2">True, </span><span class="s1">fit_kwargs=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Residualize the endog variable and a 'focus' exog variable in a 
    regression model with respect to the other exog variables. 
 
    Parameters 
    ---------- 
    results : regression results instance 
        A fitted model including the focus exog and all other 
        predictors of interest. 
    focus_exog : {int, str} 
        The column of results.model.exog or a variable name that is 
        to be residualized against the other predictors. 
    resid_type : str 
        The type of residuals to use for the dependent variable.  If 
        None, uses `resid_deviance` for GLM/GEE and `resid` otherwise. 
    use_glm_weights : bool 
        Only used if the model is a GLM or GEE.  If True, the 
        residuals for the focus predictor are computed using WLS, with 
        the weights obtained from the IRLS calculations for fitting 
        the GLM.  If False, unweighted regression is used. 
    fit_kwargs : dict, optional 
        Keyword arguments to be passed to fit when refitting the 
        model. 
 
    Returns 
    ------- 
    endog_resid : array_like 
        The residuals for the original exog 
    focus_exog_resid : array_like 
        The residuals for the focus predictor 
 
    Notes 
    ----- 
    The 'focus variable' residuals are always obtained using linear 
    regression. 
 
    Currently only GLM, GEE, and OLS models are supported. 
    &quot;&quot;&quot;</span>

    <span class="s1">model = results.model</span>
    <span class="s2">if not </span><span class="s1">isinstance(model</span><span class="s2">, </span><span class="s1">(GEE</span><span class="s2">, </span><span class="s1">GLM</span><span class="s2">, </span><span class="s1">OLS)):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;model type %s not supported for added variable residuals&quot; </span><span class="s1">%</span>
                         <span class="s1">model.__class__.__name__)</span>

    <span class="s1">exog = model.exog</span>
    <span class="s1">endog = model.endog</span>

    <span class="s1">focus_exog</span><span class="s2">, </span><span class="s1">focus_col = utils.maybe_name_or_idx(focus_exog</span><span class="s2">, </span><span class="s1">model)</span>

    <span class="s1">focus_exog_vals = exog[:</span><span class="s2">, </span><span class="s1">focus_col]</span>

    <span class="s4"># Default residuals</span>
    <span class="s2">if </span><span class="s1">resid_type </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">isinstance(model</span><span class="s2">, </span><span class="s1">(GEE</span><span class="s2">, </span><span class="s1">GLM)):</span>
            <span class="s1">resid_type = </span><span class="s3">&quot;resid_deviance&quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">resid_type = </span><span class="s3">&quot;resid&quot;</span>

    <span class="s1">ii = range(exog.shape[</span><span class="s5">1</span><span class="s1">])</span>
    <span class="s1">ii = list(ii)</span>
    <span class="s1">ii.pop(focus_col)</span>
    <span class="s1">reduced_exog = exog[:</span><span class="s2">, </span><span class="s1">ii]</span>
    <span class="s1">start_params = results.params[ii]</span>

    <span class="s1">klass = model.__class__</span>

    <span class="s1">kwargs = model._get_init_kwds()</span>
    <span class="s1">new_model = klass(endog</span><span class="s2">, </span><span class="s1">reduced_exog</span><span class="s2">, </span><span class="s1">**kwargs)</span>
    <span class="s1">args = {</span><span class="s3">&quot;start_params&quot;</span><span class="s1">: start_params}</span>
    <span class="s2">if </span><span class="s1">fit_kwargs </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">args.update(fit_kwargs)</span>
    <span class="s1">new_result = new_model.fit(**args)</span>
    <span class="s2">if not </span><span class="s1">getattr(new_result</span><span class="s2">, </span><span class="s3">&quot;converged&quot;</span><span class="s2">, True</span><span class="s1">):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;fit did not converge when calculating added variable residuals&quot;</span><span class="s1">)</span>

    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">endog_resid = getattr(new_result</span><span class="s2">, </span><span class="s1">resid_type)</span>
    <span class="s2">except </span><span class="s1">AttributeError:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;'%s' residual type not available&quot; </span><span class="s1">% resid_type)</span>

    <span class="s2">import </span><span class="s1">statsmodels.regression.linear_model </span><span class="s2">as </span><span class="s1">lm</span>

    <span class="s2">if </span><span class="s1">isinstance(model</span><span class="s2">, </span><span class="s1">(GLM</span><span class="s2">, </span><span class="s1">GEE)) </span><span class="s2">and </span><span class="s1">use_glm_weights:</span>
        <span class="s1">weights = model.family.weights(results.fittedvalues)</span>
        <span class="s2">if </span><span class="s1">hasattr(model</span><span class="s2">, </span><span class="s3">&quot;data_weights&quot;</span><span class="s1">):</span>
            <span class="s1">weights = weights * model.data_weights</span>
        <span class="s1">lm_results = lm.WLS(focus_exog_vals</span><span class="s2">, </span><span class="s1">reduced_exog</span><span class="s2">, </span><span class="s1">weights).fit()</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">lm_results = lm.OLS(focus_exog_vals</span><span class="s2">, </span><span class="s1">reduced_exog).fit()</span>
    <span class="s1">focus_exog_resid = lm_results.resid</span>

    <span class="s2">return </span><span class="s1">endog_resid</span><span class="s2">, </span><span class="s1">focus_exog_resid</span>
</pre>
</body>
</html>