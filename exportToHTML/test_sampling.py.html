<html>
<head>
<title>test_sampling.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6897bb;}
.s4 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_sampling.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">threading</span>
<span class="s0">import </span><span class="s1">pickle</span>
<span class="s0">import </span><span class="s1">pytest</span>
<span class="s0">from </span><span class="s1">copy </span><span class="s0">import </span><span class="s1">deepcopy</span>
<span class="s0">import </span><span class="s1">platform</span>
<span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">math</span>
<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">numpy.testing </span><span class="s0">import </span><span class="s1">assert_allclose</span><span class="s0">, </span><span class="s1">assert_equal</span><span class="s0">, </span><span class="s1">suppress_warnings</span>
<span class="s0">from </span><span class="s1">scipy.stats.sampling </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">TransformedDensityRejection</span><span class="s0">,</span>
    <span class="s1">DiscreteAliasUrn</span><span class="s0">,</span>
    <span class="s1">DiscreteGuideTable</span><span class="s0">,</span>
    <span class="s1">NumericalInversePolynomial</span><span class="s0">,</span>
    <span class="s1">NumericalInverseHermite</span><span class="s0">,</span>
    <span class="s1">SimpleRatioUniforms</span><span class="s0">,</span>
    <span class="s1">UNURANError</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">scipy </span><span class="s0">import </span><span class="s1">stats</span>
<span class="s0">from </span><span class="s1">scipy </span><span class="s0">import </span><span class="s1">special</span>
<span class="s0">from </span><span class="s1">scipy.stats </span><span class="s0">import </span><span class="s1">chisquare</span><span class="s0">, </span><span class="s1">cramervonmises</span>
<span class="s0">from </span><span class="s1">scipy.stats._distr_params </span><span class="s0">import </span><span class="s1">distdiscrete</span><span class="s0">, </span><span class="s1">distcont</span>
<span class="s0">from </span><span class="s1">scipy._lib._util </span><span class="s0">import </span><span class="s1">check_random_state</span>


<span class="s2"># common test data: this data can be shared between all the tests.</span>


<span class="s2"># Normal distribution shared between all the continuous methods</span>
<span class="s0">class </span><span class="s1">StandardNormal:</span>
    <span class="s0">def </span><span class="s1">pdf(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s2"># normalization constant needed for NumericalInverseHermite</span>
        <span class="s0">return </span><span class="s3">1.</span><span class="s1">/np.sqrt(</span><span class="s3">2.</span><span class="s1">*np.pi) * np.exp(-</span><span class="s3">0.5 </span><span class="s1">* x*x)</span>

    <span class="s0">def </span><span class="s1">dpdf(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s0">return </span><span class="s3">1.</span><span class="s1">/np.sqrt(</span><span class="s3">2.</span><span class="s1">*np.pi) * -x * np.exp(-</span><span class="s3">0.5 </span><span class="s1">* x*x)</span>

    <span class="s0">def </span><span class="s1">cdf(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s0">return </span><span class="s1">special.ndtr(x)</span>


<span class="s1">all_methods = [</span>
    <span class="s1">(</span><span class="s4">&quot;TransformedDensityRejection&quot;</span><span class="s0">, </span><span class="s1">{</span><span class="s4">&quot;dist&quot;</span><span class="s1">: StandardNormal()})</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s4">&quot;DiscreteAliasUrn&quot;</span><span class="s0">, </span><span class="s1">{</span><span class="s4">&quot;dist&quot;</span><span class="s1">: [</span><span class="s3">0.02</span><span class="s0">, </span><span class="s3">0.18</span><span class="s0">, </span><span class="s3">0.8</span><span class="s1">]})</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s4">&quot;DiscreteGuideTable&quot;</span><span class="s0">, </span><span class="s1">{</span><span class="s4">&quot;dist&quot;</span><span class="s1">: [</span><span class="s3">0.02</span><span class="s0">, </span><span class="s3">0.18</span><span class="s0">, </span><span class="s3">0.8</span><span class="s1">]})</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s4">&quot;NumericalInversePolynomial&quot;</span><span class="s0">, </span><span class="s1">{</span><span class="s4">&quot;dist&quot;</span><span class="s1">: StandardNormal()})</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s4">&quot;NumericalInverseHermite&quot;</span><span class="s0">, </span><span class="s1">{</span><span class="s4">&quot;dist&quot;</span><span class="s1">: StandardNormal()})</span><span class="s0">,</span>
    <span class="s1">(</span><span class="s4">&quot;SimpleRatioUniforms&quot;</span><span class="s0">, </span><span class="s1">{</span><span class="s4">&quot;dist&quot;</span><span class="s1">: StandardNormal()</span><span class="s0">, </span><span class="s4">&quot;mode&quot;</span><span class="s1">: </span><span class="s3">0</span><span class="s1">})</span>
<span class="s1">]</span>

<span class="s0">if </span><span class="s1">(sys.implementation.name == </span><span class="s4">'pypy'</span>
        <span class="s0">and </span><span class="s1">sys.implementation.version &lt; (</span><span class="s3">7</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)):</span>
    <span class="s2"># changed in PyPy for v7.3.10</span>
    <span class="s1">floaterr = </span><span class="s4">r&quot;unsupported operand type for float\(\): 'list'&quot;</span>
<span class="s0">else</span><span class="s1">:</span>
    <span class="s1">floaterr = </span><span class="s4">r&quot;must be real number, not list&quot;</span>
<span class="s2"># Make sure an internal error occurs in UNU.RAN when invalid callbacks are</span>
<span class="s2"># passed. Moreover, different generators throw different error messages.</span>
<span class="s2"># So, in case of an `UNURANError`, we do not validate the error message.</span>
<span class="s1">bad_pdfs_common = [</span>
    <span class="s2"># Negative PDF</span>
    <span class="s1">(</span><span class="s0">lambda </span><span class="s1">x: -x</span><span class="s0">, </span><span class="s1">UNURANError</span><span class="s0">, </span><span class="s4">r&quot;...&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s2"># Returning wrong type</span>
    <span class="s1">(</span><span class="s0">lambda </span><span class="s1">x: []</span><span class="s0">, </span><span class="s1">TypeError</span><span class="s0">, </span><span class="s1">floaterr)</span><span class="s0">,</span>
    <span class="s2"># Undefined name inside the function</span>
    <span class="s1">(</span><span class="s0">lambda </span><span class="s1">x: foo</span><span class="s0">, </span><span class="s1">NameError</span><span class="s0">, </span><span class="s4">r&quot;name 'foo' is not defined&quot;</span><span class="s1">)</span><span class="s0">,  </span><span class="s2"># type: ignore[name-defined]  # noqa</span>
    <span class="s2"># Infinite value returned =&gt; Overflow error.</span>
    <span class="s1">(</span><span class="s0">lambda </span><span class="s1">x: np.inf</span><span class="s0">, </span><span class="s1">UNURANError</span><span class="s0">, </span><span class="s4">r&quot;...&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s2"># NaN value =&gt; internal error in UNU.RAN</span>
    <span class="s1">(</span><span class="s0">lambda </span><span class="s1">x: np.nan</span><span class="s0">, </span><span class="s1">UNURANError</span><span class="s0">, </span><span class="s4">r&quot;...&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s2"># signature of PDF wrong</span>
    <span class="s1">(</span><span class="s0">lambda</span><span class="s1">: </span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">TypeError</span><span class="s0">, </span><span class="s4">r&quot;takes 0 positional arguments but 1 was given&quot;</span><span class="s1">)</span>
<span class="s1">]</span>


<span class="s2"># same approach for dpdf</span>
<span class="s1">bad_dpdf_common = [</span>
    <span class="s2"># Infinite value returned.</span>
    <span class="s1">(</span><span class="s0">lambda </span><span class="s1">x: np.inf</span><span class="s0">, </span><span class="s1">UNURANError</span><span class="s0">, </span><span class="s4">r&quot;...&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s2"># NaN value =&gt; internal error in UNU.RAN</span>
    <span class="s1">(</span><span class="s0">lambda </span><span class="s1">x: np.nan</span><span class="s0">, </span><span class="s1">UNURANError</span><span class="s0">, </span><span class="s4">r&quot;...&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s2"># Returning wrong type</span>
    <span class="s1">(</span><span class="s0">lambda </span><span class="s1">x: []</span><span class="s0">, </span><span class="s1">TypeError</span><span class="s0">, </span><span class="s1">floaterr)</span><span class="s0">,</span>
    <span class="s2"># Undefined name inside the function</span>
    <span class="s1">(</span><span class="s0">lambda </span><span class="s1">x: foo</span><span class="s0">, </span><span class="s1">NameError</span><span class="s0">, </span><span class="s4">r&quot;name 'foo' is not defined&quot;</span><span class="s1">)</span><span class="s0">,  </span><span class="s2"># type: ignore[name-defined]  # noqa</span>
    <span class="s2"># signature of dPDF wrong</span>
    <span class="s1">(</span><span class="s0">lambda</span><span class="s1">: </span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">TypeError</span><span class="s0">, </span><span class="s4">r&quot;takes 0 positional arguments but 1 was given&quot;</span><span class="s1">)</span>
<span class="s1">]</span>


<span class="s2"># same approach for logpdf</span>
<span class="s1">bad_logpdfs_common = [</span>
    <span class="s2"># Returning wrong type</span>
    <span class="s1">(</span><span class="s0">lambda </span><span class="s1">x: []</span><span class="s0">, </span><span class="s1">TypeError</span><span class="s0">, </span><span class="s1">floaterr)</span><span class="s0">,</span>
    <span class="s2"># Undefined name inside the function</span>
    <span class="s1">(</span><span class="s0">lambda </span><span class="s1">x: foo</span><span class="s0">, </span><span class="s1">NameError</span><span class="s0">, </span><span class="s4">r&quot;name 'foo' is not defined&quot;</span><span class="s1">)</span><span class="s0">,  </span><span class="s2"># type: ignore[name-defined]  # noqa</span>
    <span class="s2"># Infinite value returned =&gt; Overflow error.</span>
    <span class="s1">(</span><span class="s0">lambda </span><span class="s1">x: np.inf</span><span class="s0">, </span><span class="s1">UNURANError</span><span class="s0">, </span><span class="s4">r&quot;...&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s2"># NaN value =&gt; internal error in UNU.RAN</span>
    <span class="s1">(</span><span class="s0">lambda </span><span class="s1">x: np.nan</span><span class="s0">, </span><span class="s1">UNURANError</span><span class="s0">, </span><span class="s4">r&quot;...&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s2"># signature of logpdf wrong</span>
    <span class="s1">(</span><span class="s0">lambda</span><span class="s1">: </span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">TypeError</span><span class="s0">, </span><span class="s4">r&quot;takes 0 positional arguments but 1 was given&quot;</span><span class="s1">)</span>
<span class="s1">]</span>


<span class="s1">bad_pv_common = [</span>
    <span class="s1">([]</span><span class="s0">, </span><span class="s4">r&quot;must contain at least one element&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">([[</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">0.0</span><span class="s1">]]</span><span class="s0">, </span><span class="s4">r&quot;wrong number of dimensions \(expected 1, got 2\)&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">([</span><span class="s3">0.2</span><span class="s0">, </span><span class="s3">0.4</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s3">0.8</span><span class="s1">]</span><span class="s0">, </span><span class="s4">r&quot;must contain only finite / non-nan values&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">([</span><span class="s3">0.2</span><span class="s0">, </span><span class="s3">0.4</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s3">0.8</span><span class="s1">]</span><span class="s0">, </span><span class="s4">r&quot;must contain only finite / non-nan values&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">([</span><span class="s3">0.0</span><span class="s0">, </span><span class="s3">0.0</span><span class="s1">]</span><span class="s0">, </span><span class="s4">r&quot;must contain at least one non-zero value&quot;</span><span class="s1">)</span><span class="s0">,</span>
<span class="s1">]</span>


<span class="s2"># size of the domains is incorrect</span>
<span class="s1">bad_sized_domains = [</span>
    <span class="s2"># &gt; 2 elements in the domain</span>
    <span class="s1">((</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">ValueError</span><span class="s0">, </span><span class="s4">r&quot;must be a length 2 tuple&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s2"># empty domain</span>
    <span class="s1">(()</span><span class="s0">, </span><span class="s1">ValueError</span><span class="s0">, </span><span class="s4">r&quot;must be a length 2 tuple&quot;</span><span class="s1">)</span>
<span class="s1">]</span>

<span class="s2"># domain values are incorrect</span>
<span class="s1">bad_domains = [</span>
    <span class="s1">((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">UNURANError</span><span class="s0">, </span><span class="s4">r&quot;left &gt;= right&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">((</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">UNURANError</span><span class="s0">, </span><span class="s4">r&quot;left &gt;= right&quot;</span><span class="s1">)</span><span class="s0">,</span>
<span class="s1">]</span>

<span class="s2"># infinite and nan values present in domain.</span>
<span class="s1">inf_nan_domains = [</span>
    <span class="s2"># left &gt;= right</span>
    <span class="s1">((</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">UNURANError</span><span class="s0">, </span><span class="s4">r&quot;left &gt;= right&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">((np.inf</span><span class="s0">, </span><span class="s1">np.inf)</span><span class="s0">, </span><span class="s1">UNURANError</span><span class="s0">, </span><span class="s4">r&quot;left &gt;= right&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">((-np.inf</span><span class="s0">, </span><span class="s1">-np.inf)</span><span class="s0">, </span><span class="s1">UNURANError</span><span class="s0">, </span><span class="s4">r&quot;left &gt;= right&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">((np.inf</span><span class="s0">, </span><span class="s1">-np.inf)</span><span class="s0">, </span><span class="s1">UNURANError</span><span class="s0">, </span><span class="s4">r&quot;left &gt;= right&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s2"># Also include nans in some of the domains.</span>
    <span class="s1">((-np.inf</span><span class="s0">, </span><span class="s1">np.nan)</span><span class="s0">, </span><span class="s1">ValueError</span><span class="s0">, </span><span class="s4">r&quot;only non-nan values&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">((np.nan</span><span class="s0">, </span><span class="s1">np.inf)</span><span class="s0">, </span><span class="s1">ValueError</span><span class="s0">, </span><span class="s4">r&quot;only non-nan values&quot;</span><span class="s1">)</span>
<span class="s1">]</span>

<span class="s2"># `nan` values present in domain. Some distributions don't support</span>
<span class="s2"># infinite tails, so don't mix the nan values with infinities.</span>
<span class="s1">nan_domains = [</span>
    <span class="s1">((</span><span class="s3">0</span><span class="s0">, </span><span class="s1">np.nan)</span><span class="s0">, </span><span class="s1">ValueError</span><span class="s0">, </span><span class="s4">r&quot;only non-nan values&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">((np.nan</span><span class="s0">, </span><span class="s1">np.nan)</span><span class="s0">, </span><span class="s1">ValueError</span><span class="s0">, </span><span class="s4">r&quot;only non-nan values&quot;</span><span class="s1">)</span>
<span class="s1">]</span>


<span class="s2"># all the methods should throw errors for nan, bad sized, and bad valued</span>
<span class="s2"># domains.</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;domain, err, msg&quot;</span><span class="s0">,</span>
                         <span class="s1">bad_domains + bad_sized_domains +</span>
                         <span class="s1">nan_domains)  </span><span class="s2"># type: ignore[operator]</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;method, kwargs&quot;</span><span class="s0">, </span><span class="s1">all_methods)</span>
<span class="s0">def </span><span class="s1">test_bad_domain(domain</span><span class="s0">, </span><span class="s1">err</span><span class="s0">, </span><span class="s1">msg</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">kwargs):</span>
    <span class="s1">Method = getattr(stats.sampling</span><span class="s0">, </span><span class="s1">method)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(err</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">Method(**kwargs</span><span class="s0">, </span><span class="s1">domain=domain)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;method, kwargs&quot;</span><span class="s0">, </span><span class="s1">all_methods)</span>
<span class="s0">def </span><span class="s1">test_random_state(method</span><span class="s0">, </span><span class="s1">kwargs):</span>
    <span class="s1">Method = getattr(stats.sampling</span><span class="s0">, </span><span class="s1">method)</span>

    <span class="s2"># simple seed that works for any version of NumPy</span>
    <span class="s1">seed = </span><span class="s3">123</span>
    <span class="s1">rng1 = Method(**kwargs</span><span class="s0">, </span><span class="s1">random_state=seed)</span>
    <span class="s1">rng2 = Method(**kwargs</span><span class="s0">, </span><span class="s1">random_state=seed)</span>
    <span class="s1">assert_equal(rng1.rvs(</span><span class="s3">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">rng2.rvs(</span><span class="s3">100</span><span class="s1">))</span>

    <span class="s2"># global seed</span>
    <span class="s1">np.random.seed(</span><span class="s3">123</span><span class="s1">)</span>
    <span class="s1">rng1 = Method(**kwargs)</span>
    <span class="s1">rvs1 = rng1.rvs(</span><span class="s3">100</span><span class="s1">)</span>
    <span class="s1">np.random.seed(</span><span class="s0">None</span><span class="s1">)</span>
    <span class="s1">rng2 = Method(**kwargs</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s3">123</span><span class="s1">)</span>
    <span class="s1">rvs2 = rng2.rvs(</span><span class="s3">100</span><span class="s1">)</span>
    <span class="s1">assert_equal(rvs1</span><span class="s0">, </span><span class="s1">rvs2)</span>

    <span class="s2"># Generator seed for new NumPy</span>
    <span class="s2"># when a RandomState is given, it should take the bitgen_t</span>
    <span class="s2"># member of the class and create a Generator instance.</span>
    <span class="s1">seed1 = np.random.RandomState(np.random.MT19937(</span><span class="s3">123</span><span class="s1">))</span>
    <span class="s1">seed2 = np.random.Generator(np.random.MT19937(</span><span class="s3">123</span><span class="s1">))</span>
    <span class="s1">rng1 = Method(**kwargs</span><span class="s0">, </span><span class="s1">random_state=seed1)</span>
    <span class="s1">rng2 = Method(**kwargs</span><span class="s0">, </span><span class="s1">random_state=seed2)</span>
    <span class="s1">assert_equal(rng1.rvs(</span><span class="s3">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">rng2.rvs(</span><span class="s3">100</span><span class="s1">))</span>


<span class="s0">def </span><span class="s1">test_set_random_state():</span>
    <span class="s1">rng1 = TransformedDensityRejection(StandardNormal()</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s3">123</span><span class="s1">)</span>
    <span class="s1">rng2 = TransformedDensityRejection(StandardNormal())</span>
    <span class="s1">rng2.set_random_state(</span><span class="s3">123</span><span class="s1">)</span>
    <span class="s1">assert_equal(rng1.rvs(</span><span class="s3">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">rng2.rvs(</span><span class="s3">100</span><span class="s1">))</span>
    <span class="s1">rng = TransformedDensityRejection(StandardNormal()</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s3">123</span><span class="s1">)</span>
    <span class="s1">rvs1 = rng.rvs(</span><span class="s3">100</span><span class="s1">)</span>
    <span class="s1">rng.set_random_state(</span><span class="s3">123</span><span class="s1">)</span>
    <span class="s1">rvs2 = rng.rvs(</span><span class="s3">100</span><span class="s1">)</span>
    <span class="s1">assert_equal(rvs1</span><span class="s0">, </span><span class="s1">rvs2)</span>


<span class="s0">def </span><span class="s1">test_threading_behaviour():</span>
    <span class="s2"># Test if the API is thread-safe.</span>
    <span class="s2"># This verifies if the lock mechanism and the use of `PyErr_Occurred`</span>
    <span class="s2"># is correct.</span>
    <span class="s1">errors = {</span><span class="s4">&quot;err1&quot;</span><span class="s1">: </span><span class="s0">None, </span><span class="s4">&quot;err2&quot;</span><span class="s1">: </span><span class="s0">None</span><span class="s1">}</span>

    <span class="s0">class </span><span class="s1">Distribution:</span>
        <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">pdf_msg):</span>
            <span class="s1">self.pdf_msg = pdf_msg</span>

        <span class="s0">def </span><span class="s1">pdf(self</span><span class="s0">, </span><span class="s1">x):</span>
            <span class="s0">if </span><span class="s3">49.9 </span><span class="s1">&lt; x &lt; </span><span class="s3">50.0</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">ValueError(self.pdf_msg)</span>
            <span class="s0">return </span><span class="s1">x</span>

        <span class="s0">def </span><span class="s1">dpdf(self</span><span class="s0">, </span><span class="s1">x):</span>
            <span class="s0">return </span><span class="s3">1</span>

    <span class="s0">def </span><span class="s1">func1():</span>
        <span class="s1">dist = Distribution(</span><span class="s4">'foo'</span><span class="s1">)</span>
        <span class="s1">rng = TransformedDensityRejection(dist</span><span class="s0">, </span><span class="s1">domain=(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">100</span><span class="s1">)</span><span class="s0">,</span>
                                          <span class="s1">random_state=</span><span class="s3">12</span><span class="s1">)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">rng.rvs(</span><span class="s3">100000</span><span class="s1">)</span>
        <span class="s0">except </span><span class="s1">ValueError </span><span class="s0">as </span><span class="s1">e:</span>
            <span class="s1">errors[</span><span class="s4">'err1'</span><span class="s1">] = e.args[</span><span class="s3">0</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">func2():</span>
        <span class="s1">dist = Distribution(</span><span class="s4">'bar'</span><span class="s1">)</span>
        <span class="s1">rng = TransformedDensityRejection(dist</span><span class="s0">, </span><span class="s1">domain=(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">100</span><span class="s1">)</span><span class="s0">,</span>
                                          <span class="s1">random_state=</span><span class="s3">2</span><span class="s1">)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">rng.rvs(</span><span class="s3">100000</span><span class="s1">)</span>
        <span class="s0">except </span><span class="s1">ValueError </span><span class="s0">as </span><span class="s1">e:</span>
            <span class="s1">errors[</span><span class="s4">'err2'</span><span class="s1">] = e.args[</span><span class="s3">0</span><span class="s1">]</span>

    <span class="s1">t1 = threading.Thread(target=func1)</span>
    <span class="s1">t2 = threading.Thread(target=func2)</span>

    <span class="s1">t1.start()</span>
    <span class="s1">t2.start()</span>

    <span class="s1">t1.join()</span>
    <span class="s1">t2.join()</span>

    <span class="s0">assert </span><span class="s1">errors[</span><span class="s4">'err1'</span><span class="s1">] == </span><span class="s4">'foo'</span>
    <span class="s0">assert </span><span class="s1">errors[</span><span class="s4">'err2'</span><span class="s1">] == </span><span class="s4">'bar'</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;method, kwargs&quot;</span><span class="s0">, </span><span class="s1">all_methods)</span>
<span class="s0">def </span><span class="s1">test_pickle(method</span><span class="s0">, </span><span class="s1">kwargs):</span>
    <span class="s1">Method = getattr(stats.sampling</span><span class="s0">, </span><span class="s1">method)</span>
    <span class="s1">rng1 = Method(**kwargs</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s3">123</span><span class="s1">)</span>
    <span class="s1">obj = pickle.dumps(rng1)</span>
    <span class="s1">rng2 = pickle.loads(obj)</span>
    <span class="s1">assert_equal(rng1.rvs(</span><span class="s3">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">rng2.rvs(</span><span class="s3">100</span><span class="s1">))</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;size&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">None, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">)</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span><span class="s0">,</span>
                                  <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)])</span>
<span class="s0">def </span><span class="s1">test_rvs_size(size):</span>
    <span class="s2"># As the `rvs` method is present in the base class and shared between</span>
    <span class="s2"># all the classes, we can just test with one of the methods.</span>
    <span class="s1">rng = TransformedDensityRejection(StandardNormal())</span>
    <span class="s0">if </span><span class="s1">size </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">assert </span><span class="s1">np.isscalar(rng.rvs(size))</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">np.isscalar(size):</span>
            <span class="s1">size = (size</span><span class="s0">, </span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">rng.rvs(size).shape == size</span>


<span class="s0">def </span><span class="s1">test_with_scipy_distribution():</span>
    <span class="s2"># test if the setup works with SciPy's rv_frozen distributions</span>
    <span class="s1">dist = stats.norm()</span>
    <span class="s1">urng = np.random.default_rng(</span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">rng = NumericalInverseHermite(dist</span><span class="s0">, </span><span class="s1">random_state=urng)</span>
    <span class="s1">u = np.linspace(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">num=</span><span class="s3">100</span><span class="s1">)</span>
    <span class="s1">check_cont_samples(rng</span><span class="s0">, </span><span class="s1">dist</span><span class="s0">, </span><span class="s1">dist.stats())</span>
    <span class="s1">assert_allclose(dist.ppf(u)</span><span class="s0">, </span><span class="s1">rng.ppf(u))</span>
    <span class="s2"># test if it works with `loc` and `scale`</span>
    <span class="s1">dist = stats.norm(loc=</span><span class="s3">10.</span><span class="s0">, </span><span class="s1">scale=</span><span class="s3">5.</span><span class="s1">)</span>
    <span class="s1">rng = NumericalInverseHermite(dist</span><span class="s0">, </span><span class="s1">random_state=urng)</span>
    <span class="s1">check_cont_samples(rng</span><span class="s0">, </span><span class="s1">dist</span><span class="s0">, </span><span class="s1">dist.stats())</span>
    <span class="s1">assert_allclose(dist.ppf(u)</span><span class="s0">, </span><span class="s1">rng.ppf(u))</span>
    <span class="s2"># check for discrete distributions</span>
    <span class="s1">dist = stats.binom(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">0.2</span><span class="s1">)</span>
    <span class="s1">rng = DiscreteAliasUrn(dist</span><span class="s0">, </span><span class="s1">random_state=urng)</span>
    <span class="s1">domain = dist.support()</span>
    <span class="s1">pv = dist.pmf(np.arange(domain[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">domain[</span><span class="s3">1</span><span class="s1">]+</span><span class="s3">1</span><span class="s1">))</span>
    <span class="s1">check_discr_samples(rng</span><span class="s0">, </span><span class="s1">pv</span><span class="s0">, </span><span class="s1">dist.stats())</span>


<span class="s0">def </span><span class="s1">check_cont_samples(rng</span><span class="s0">, </span><span class="s1">dist</span><span class="s0">, </span><span class="s1">mv_ex):</span>
    <span class="s1">rvs = rng.rvs(</span><span class="s3">100000</span><span class="s1">)</span>
    <span class="s1">mv = rvs.mean()</span><span class="s0">, </span><span class="s1">rvs.var()</span>
    <span class="s2"># test the moments only if the variance is finite</span>
    <span class="s0">if </span><span class="s1">np.isfinite(mv_ex[</span><span class="s3">1</span><span class="s1">]):</span>
        <span class="s1">assert_allclose(mv</span><span class="s0">, </span><span class="s1">mv_ex</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-7</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-1</span><span class="s1">)</span>
    <span class="s2"># Cramer Von Mises test for goodness-of-fit</span>
    <span class="s1">rvs = rng.rvs(</span><span class="s3">500</span><span class="s1">)</span>
    <span class="s1">dist.cdf = np.vectorize(dist.cdf)</span>
    <span class="s1">pval = cramervonmises(rvs</span><span class="s0">, </span><span class="s1">dist.cdf).pvalue</span>
    <span class="s0">assert </span><span class="s1">pval &gt; </span><span class="s3">0.1</span>


<span class="s0">def </span><span class="s1">check_discr_samples(rng</span><span class="s0">, </span><span class="s1">pv</span><span class="s0">, </span><span class="s1">mv_ex):</span>
    <span class="s1">rvs = rng.rvs(</span><span class="s3">100000</span><span class="s1">)</span>
    <span class="s2"># test if the first few moments match</span>
    <span class="s1">mv = rvs.mean()</span><span class="s0">, </span><span class="s1">rvs.var()</span>
    <span class="s1">assert_allclose(mv</span><span class="s0">, </span><span class="s1">mv_ex</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-3</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-1</span><span class="s1">)</span>
    <span class="s2"># normalize</span>
    <span class="s1">pv = pv / pv.sum()</span>
    <span class="s2"># chi-squared test for goodness-of-fit</span>
    <span class="s1">obs_freqs = np.zeros_like(pv)</span>
    <span class="s1">_</span><span class="s0">, </span><span class="s1">freqs = np.unique(rvs</span><span class="s0">, </span><span class="s1">return_counts=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">freqs = freqs / freqs.sum()</span>
    <span class="s1">obs_freqs[:freqs.size] = freqs</span>
    <span class="s1">pval = chisquare(obs_freqs</span><span class="s0">, </span><span class="s1">pv).pvalue</span>
    <span class="s0">assert </span><span class="s1">pval &gt; </span><span class="s3">0.1</span>


<span class="s0">def </span><span class="s1">test_warning_center_not_in_domain():</span>
    <span class="s2"># UNURAN will warn if the center provided or the one computed w/o the</span>
    <span class="s2"># domain is outside of the domain</span>
    <span class="s1">msg = </span><span class="s4">&quot;102 : center moved into domain of distribution&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.warns(RuntimeWarning</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">NumericalInversePolynomial(StandardNormal()</span><span class="s0">, </span><span class="s1">center=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">domain=(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">5</span><span class="s1">))</span>
    <span class="s0">with </span><span class="s1">pytest.warns(RuntimeWarning</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">NumericalInversePolynomial(StandardNormal()</span><span class="s0">, </span><span class="s1">domain=(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">5</span><span class="s1">))</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">'method'</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;SimpleRatioUniforms&quot;</span><span class="s0">,</span>
                                    <span class="s4">&quot;NumericalInversePolynomial&quot;</span><span class="s0">,</span>
                                    <span class="s4">&quot;TransformedDensityRejection&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_error_mode_not_in_domain(method):</span>
    <span class="s2"># UNURAN raises an error if the mode is not in the domain</span>
    <span class="s2"># the behavior is different compared to the case that center is not in the</span>
    <span class="s2"># domain. mode is supposed to be the exact value, center can be an</span>
    <span class="s2"># approximate value</span>
    <span class="s1">Method = getattr(stats.sampling</span><span class="s0">, </span><span class="s1">method)</span>
    <span class="s1">msg = </span><span class="s4">&quot;17 : mode not in domain&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.raises(UNURANError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">Method(StandardNormal()</span><span class="s0">, </span><span class="s1">mode=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">domain=(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">5</span><span class="s1">))</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">'method'</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;NumericalInverseHermite&quot;</span><span class="s0">,</span>
                                    <span class="s4">&quot;NumericalInversePolynomial&quot;</span><span class="s1">])</span>
<span class="s0">class </span><span class="s1">TestQRVS:</span>
    <span class="s0">def </span><span class="s1">test_input_validation(self</span><span class="s0">, </span><span class="s1">method):</span>
        <span class="s1">match = </span><span class="s4">&quot;`qmc_engine` must be an instance of...&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=match):</span>
            <span class="s1">Method = getattr(stats.sampling</span><span class="s0">, </span><span class="s1">method)</span>
            <span class="s1">gen = Method(StandardNormal())</span>
            <span class="s1">gen.qrvs(qmc_engine=</span><span class="s3">0</span><span class="s1">)</span>

        <span class="s2"># issues with QMCEngines and old NumPy</span>
        <span class="s1">Method = getattr(stats.sampling</span><span class="s0">, </span><span class="s1">method)</span>
        <span class="s1">gen = Method(StandardNormal())</span>

        <span class="s1">match = </span><span class="s4">&quot;`d` must be consistent with dimension of `qmc_engine`.&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=match):</span>
            <span class="s1">gen.qrvs(d=</span><span class="s3">3</span><span class="s0">, </span><span class="s1">qmc_engine=stats.qmc.Halton(</span><span class="s3">2</span><span class="s1">))</span>

    <span class="s1">qrngs = [</span><span class="s0">None, </span><span class="s1">stats.qmc.Sobol(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">seed=</span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">stats.qmc.Halton(</span><span class="s3">3</span><span class="s0">, </span><span class="s1">seed=</span><span class="s3">0</span><span class="s1">)]</span>
    <span class="s2"># `size=None` should not add anything to the shape, `size=1` should</span>
    <span class="s1">sizes = [(</span><span class="s0">None, </span><span class="s1">tuple())</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">,</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(</span><span class="s3">4</span><span class="s0">, </span><span class="s1">(</span><span class="s3">4</span><span class="s0">,</span><span class="s1">))</span><span class="s0">,</span>
             <span class="s1">((</span><span class="s3">4</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">4</span><span class="s0">,</span><span class="s1">))</span><span class="s0">, </span><span class="s1">((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">2</span><span class="s0">, </span><span class="s3">4</span><span class="s1">))]  </span><span class="s2"># type: ignore</span>
    <span class="s2"># Neither `d=None` nor `d=1` should add anything to the shape</span>
    <span class="s1">ds = [(</span><span class="s0">None, </span><span class="s1">tuple())</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">tuple())</span><span class="s0">, </span><span class="s1">(</span><span class="s3">3</span><span class="s0">, </span><span class="s1">(</span><span class="s3">3</span><span class="s0">,</span><span class="s1">))]</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">'qrng'</span><span class="s0">, </span><span class="s1">qrngs)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">'size_in, size_out'</span><span class="s0">, </span><span class="s1">sizes)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">'d_in, d_out'</span><span class="s0">, </span><span class="s1">ds)</span>
    <span class="s0">def </span><span class="s1">test_QRVS_shape_consistency(self</span><span class="s0">, </span><span class="s1">qrng</span><span class="s0">, </span><span class="s1">size_in</span><span class="s0">, </span><span class="s1">size_out</span><span class="s0">,</span>
                                    <span class="s1">d_in</span><span class="s0">, </span><span class="s1">d_out</span><span class="s0">, </span><span class="s1">method):</span>
        <span class="s1">w32 = sys.platform == </span><span class="s4">&quot;win32&quot; </span><span class="s0">and </span><span class="s1">platform.architecture()[</span><span class="s3">0</span><span class="s1">] == </span><span class="s4">&quot;32bit&quot;</span>
        <span class="s0">if </span><span class="s1">w32 </span><span class="s0">and </span><span class="s1">method == </span><span class="s4">&quot;NumericalInversePolynomial&quot;</span><span class="s1">:</span>
            <span class="s1">pytest.xfail(</span><span class="s4">&quot;NumericalInversePolynomial.qrvs fails for Win &quot;</span>
                         <span class="s4">&quot;32-bit&quot;</span><span class="s1">)</span>

        <span class="s1">dist = StandardNormal()</span>
        <span class="s1">Method = getattr(stats.sampling</span><span class="s0">, </span><span class="s1">method)</span>
        <span class="s1">gen = Method(dist)</span>

        <span class="s2"># If d and qrng.d are inconsistent, an error is raised</span>
        <span class="s0">if </span><span class="s1">d_in </span><span class="s0">is not None and </span><span class="s1">qrng </span><span class="s0">is not None and </span><span class="s1">qrng.d != d_in:</span>
            <span class="s1">match = </span><span class="s4">&quot;`d` must be consistent with dimension of `qmc_engine`.&quot;</span>
            <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=match):</span>
                <span class="s1">gen.qrvs(size_in</span><span class="s0">, </span><span class="s1">d=d_in</span><span class="s0">, </span><span class="s1">qmc_engine=qrng)</span>
            <span class="s0">return</span>

        <span class="s2"># Sometimes d is really determined by qrng</span>
        <span class="s0">if </span><span class="s1">d_in </span><span class="s0">is None and </span><span class="s1">qrng </span><span class="s0">is not None and </span><span class="s1">qrng.d != </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s1">d_out = (qrng.d</span><span class="s0">,</span><span class="s1">)</span>

        <span class="s1">shape_expected = size_out + d_out</span>

        <span class="s1">qrng2 = deepcopy(qrng)</span>
        <span class="s1">qrvs = gen.qrvs(size=size_in</span><span class="s0">, </span><span class="s1">d=d_in</span><span class="s0">, </span><span class="s1">qmc_engine=qrng)</span>
        <span class="s0">if </span><span class="s1">size_in </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">assert </span><span class="s1">qrvs.shape == shape_expected</span>

        <span class="s0">if </span><span class="s1">qrng2 </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">uniform = qrng2.random(np.prod(size_in) </span><span class="s0">or </span><span class="s3">1</span><span class="s1">)</span>
            <span class="s1">qrvs2 = stats.norm.ppf(uniform).reshape(shape_expected)</span>
            <span class="s1">assert_allclose(qrvs</span><span class="s0">, </span><span class="s1">qrvs2</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-12</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_QRVS_size_tuple(self</span><span class="s0">, </span><span class="s1">method):</span>
        <span class="s2"># QMCEngine samples are always of shape (n, d). When `size` is a tuple,</span>
        <span class="s2"># we set `n = prod(size)` in the call to qmc_engine.random, transform</span>
        <span class="s2"># the sample, and reshape it to the final dimensions. When we reshape,</span>
        <span class="s2"># we need to be careful, because the _columns_ of the sample returned</span>
        <span class="s2"># by a QMCEngine are &quot;independent&quot;-ish, but the elements within the</span>
        <span class="s2"># columns are not. We need to make sure that this doesn't get mixed up</span>
        <span class="s2"># by reshaping: qrvs[..., i] should remain &quot;independent&quot;-ish of</span>
        <span class="s2"># qrvs[..., i+1], but the elements within qrvs[..., i] should be</span>
        <span class="s2"># transformed from the same low-discrepancy sequence.</span>

        <span class="s1">dist = StandardNormal()</span>
        <span class="s1">Method = getattr(stats.sampling</span><span class="s0">, </span><span class="s1">method)</span>
        <span class="s1">gen = Method(dist)</span>

        <span class="s1">size = (</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span>
        <span class="s1">d = </span><span class="s3">5</span>
        <span class="s1">qrng = stats.qmc.Halton(d</span><span class="s0">, </span><span class="s1">seed=</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">qrng2 = stats.qmc.Halton(d</span><span class="s0">, </span><span class="s1">seed=</span><span class="s3">0</span><span class="s1">)</span>

        <span class="s1">uniform = qrng2.random(np.prod(size))</span>

        <span class="s1">qrvs = gen.qrvs(size=size</span><span class="s0">, </span><span class="s1">d=d</span><span class="s0">, </span><span class="s1">qmc_engine=qrng)</span>
        <span class="s1">qrvs2 = stats.norm.ppf(uniform)</span>

        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(d):</span>
            <span class="s1">sample = qrvs[...</span><span class="s0">, </span><span class="s1">i]</span>
            <span class="s1">sample2 = qrvs2[:</span><span class="s0">, </span><span class="s1">i].reshape(size)</span>
            <span class="s1">assert_allclose(sample</span><span class="s0">, </span><span class="s1">sample2</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-12</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestTransformedDensityRejection:</span>
    <span class="s2"># Simple Custom Distribution</span>
    <span class="s0">class </span><span class="s1">dist0:</span>
        <span class="s0">def </span><span class="s1">pdf(self</span><span class="s0">, </span><span class="s1">x):</span>
            <span class="s0">return </span><span class="s3">3</span><span class="s1">/</span><span class="s3">4 </span><span class="s1">* (</span><span class="s3">1</span><span class="s1">-x*x)</span>

        <span class="s0">def </span><span class="s1">dpdf(self</span><span class="s0">, </span><span class="s1">x):</span>
            <span class="s0">return </span><span class="s3">3</span><span class="s1">/</span><span class="s3">4 </span><span class="s1">* (-</span><span class="s3">2</span><span class="s1">*x)</span>

        <span class="s0">def </span><span class="s1">cdf(self</span><span class="s0">, </span><span class="s1">x):</span>
            <span class="s0">return </span><span class="s3">3</span><span class="s1">/</span><span class="s3">4 </span><span class="s1">* (x - x**</span><span class="s3">3</span><span class="s1">/</span><span class="s3">3 </span><span class="s1">+ </span><span class="s3">2</span><span class="s1">/</span><span class="s3">3</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">support(self):</span>
            <span class="s0">return </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span>

    <span class="s2"># Standard Normal Distribution</span>
    <span class="s0">class </span><span class="s1">dist1:</span>
        <span class="s0">def </span><span class="s1">pdf(self</span><span class="s0">, </span><span class="s1">x):</span>
            <span class="s0">return </span><span class="s1">stats.norm._pdf(x / </span><span class="s3">0.1</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">dpdf(self</span><span class="s0">, </span><span class="s1">x):</span>
            <span class="s0">return </span><span class="s1">-x / </span><span class="s3">0.01 </span><span class="s1">* stats.norm._pdf(x / </span><span class="s3">0.1</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">cdf(self</span><span class="s0">, </span><span class="s1">x):</span>
            <span class="s0">return </span><span class="s1">stats.norm._cdf(x / </span><span class="s3">0.1</span><span class="s1">)</span>

    <span class="s2"># pdf with piecewise linear function as transformed density</span>
    <span class="s2"># with T = -1/sqrt with shift. Taken from UNU.RAN test suite</span>
    <span class="s2"># (from file t_tdr_ps.c)</span>
    <span class="s0">class </span><span class="s1">dist2:</span>
        <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">shift):</span>
            <span class="s1">self.shift = shift</span>

        <span class="s0">def </span><span class="s1">pdf(self</span><span class="s0">, </span><span class="s1">x):</span>
            <span class="s1">x -= self.shift</span>
            <span class="s1">y = </span><span class="s3">1. </span><span class="s1">/ (abs(x) + </span><span class="s3">1.</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s3">0.5 </span><span class="s1">* y * y</span>

        <span class="s0">def </span><span class="s1">dpdf(self</span><span class="s0">, </span><span class="s1">x):</span>
            <span class="s1">x -= self.shift</span>
            <span class="s1">y = </span><span class="s3">1. </span><span class="s1">/ (abs(x) + </span><span class="s3">1.</span><span class="s1">)</span>
            <span class="s1">y = y * y * y</span>
            <span class="s0">return </span><span class="s1">y </span><span class="s0">if </span><span class="s1">(x &lt; </span><span class="s3">0.</span><span class="s1">) </span><span class="s0">else </span><span class="s1">-y</span>

        <span class="s0">def </span><span class="s1">cdf(self</span><span class="s0">, </span><span class="s1">x):</span>
            <span class="s1">x -= self.shift</span>
            <span class="s0">if </span><span class="s1">x &lt;= </span><span class="s3">0.</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s3">0.5 </span><span class="s1">/ (</span><span class="s3">1. </span><span class="s1">- x)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s3">1. </span><span class="s1">- </span><span class="s3">0.5 </span><span class="s1">/ (</span><span class="s3">1. </span><span class="s1">+ x)</span>

    <span class="s1">dists = [dist0()</span><span class="s0">, </span><span class="s1">dist1()</span><span class="s0">, </span><span class="s1">dist2(</span><span class="s3">0.</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dist2(</span><span class="s3">10000.</span><span class="s1">)]</span>

    <span class="s2"># exact mean and variance of the distributions in the list dists</span>
    <span class="s1">mv0 = [</span><span class="s3">0.</span><span class="s0">, </span><span class="s3">4.</span><span class="s1">/</span><span class="s3">15.</span><span class="s1">]</span>
    <span class="s1">mv1 = [</span><span class="s3">0.</span><span class="s0">, </span><span class="s3">0.01</span><span class="s1">]</span>
    <span class="s1">mv2 = [</span><span class="s3">0.</span><span class="s0">, </span><span class="s1">np.inf]</span>
    <span class="s1">mv3 = [</span><span class="s3">10000.</span><span class="s0">, </span><span class="s1">np.inf]</span>
    <span class="s1">mvs = [mv0</span><span class="s0">, </span><span class="s1">mv1</span><span class="s0">, </span><span class="s1">mv2</span><span class="s0">, </span><span class="s1">mv3]</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;dist, mv_ex&quot;</span><span class="s0">,</span>
                             <span class="s1">zip(dists</span><span class="s0">, </span><span class="s1">mvs))</span>
    <span class="s0">def </span><span class="s1">test_basic(self</span><span class="s0">, </span><span class="s1">dist</span><span class="s0">, </span><span class="s1">mv_ex):</span>
        <span class="s0">with </span><span class="s1">suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
            <span class="s2"># filter the warnings thrown by UNU.RAN</span>
            <span class="s1">sup.filter(RuntimeWarning)</span>
            <span class="s1">rng = TransformedDensityRejection(dist</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s3">42</span><span class="s1">)</span>
        <span class="s1">check_cont_samples(rng</span><span class="s0">, </span><span class="s1">dist</span><span class="s0">, </span><span class="s1">mv_ex)</span>

    <span class="s2"># PDF 0 everywhere =&gt; bad construction points</span>
    <span class="s1">bad_pdfs = [(</span><span class="s0">lambda </span><span class="s1">x: </span><span class="s3">0</span><span class="s0">, </span><span class="s1">UNURANError</span><span class="s0">, </span><span class="s4">r&quot;50 : bad construction points.&quot;</span><span class="s1">)]</span>
    <span class="s1">bad_pdfs += bad_pdfs_common  </span><span class="s2"># type: ignore[arg-type]</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;pdf, err, msg&quot;</span><span class="s0">, </span><span class="s1">bad_pdfs)</span>
    <span class="s0">def </span><span class="s1">test_bad_pdf(self</span><span class="s0">, </span><span class="s1">pdf</span><span class="s0">, </span><span class="s1">err</span><span class="s0">, </span><span class="s1">msg):</span>
        <span class="s0">class </span><span class="s1">dist:</span>
            <span class="s0">pass</span>
        <span class="s1">dist.pdf = pdf</span>
        <span class="s1">dist.dpdf = </span><span class="s0">lambda </span><span class="s1">x: </span><span class="s3">1  </span><span class="s2"># an arbitrary dPDF</span>
        <span class="s0">with </span><span class="s1">pytest.raises(err</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">TransformedDensityRejection(dist)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;dpdf, err, msg&quot;</span><span class="s0">, </span><span class="s1">bad_dpdf_common)</span>
    <span class="s0">def </span><span class="s1">test_bad_dpdf(self</span><span class="s0">, </span><span class="s1">dpdf</span><span class="s0">, </span><span class="s1">err</span><span class="s0">, </span><span class="s1">msg):</span>
        <span class="s0">class </span><span class="s1">dist:</span>
            <span class="s0">pass</span>
        <span class="s1">dist.pdf = </span><span class="s0">lambda </span><span class="s1">x: x</span>
        <span class="s1">dist.dpdf = dpdf</span>
        <span class="s0">with </span><span class="s1">pytest.raises(err</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">TransformedDensityRejection(dist</span><span class="s0">, </span><span class="s1">domain=(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">10</span><span class="s1">))</span>

    <span class="s2"># test domains with inf + nan in them. need to write a custom test for</span>
    <span class="s2"># this because not all methods support infinite tails.</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;domain, err, msg&quot;</span><span class="s0">, </span><span class="s1">inf_nan_domains)</span>
    <span class="s0">def </span><span class="s1">test_inf_nan_domains(self</span><span class="s0">, </span><span class="s1">domain</span><span class="s0">, </span><span class="s1">err</span><span class="s0">, </span><span class="s1">msg):</span>
        <span class="s0">with </span><span class="s1">pytest.raises(err</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">TransformedDensityRejection(StandardNormal()</span><span class="s0">, </span><span class="s1">domain=domain)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;construction_points&quot;</span><span class="s0">, </span><span class="s1">[-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0.1</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_bad_construction_points_scalar(self</span><span class="s0">, </span><span class="s1">construction_points):</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">r&quot;`construction_points` must be &quot;</span>
                                             <span class="s4">r&quot;a positive integer.&quot;</span><span class="s1">):</span>
            <span class="s1">TransformedDensityRejection(</span>
                <span class="s1">StandardNormal()</span><span class="s0">, </span><span class="s1">construction_points=construction_points</span>
            <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_bad_construction_points_array(self):</span>
        <span class="s2"># empty array</span>
        <span class="s1">construction_points = []</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">r&quot;`construction_points` must &quot;</span>
                                             <span class="s4">r&quot;either be a &quot;</span>
                                             <span class="s4">r&quot;scalar or a non-empty array.&quot;</span><span class="s1">):</span>
            <span class="s1">TransformedDensityRejection(</span>
                <span class="s1">StandardNormal()</span><span class="s0">, </span><span class="s1">construction_points=construction_points</span>
            <span class="s1">)</span>

        <span class="s2"># construction_points not monotonically increasing</span>
        <span class="s1">construction_points = [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span>
        <span class="s0">with </span><span class="s1">pytest.warns(RuntimeWarning</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">r&quot;33 : starting points not &quot;</span>
                                                <span class="s4">r&quot;strictly monotonically &quot;</span>
                                                <span class="s4">r&quot;increasing&quot;</span><span class="s1">):</span>
            <span class="s1">TransformedDensityRejection(</span>
                <span class="s1">StandardNormal()</span><span class="s0">, </span><span class="s1">construction_points=construction_points</span>
            <span class="s1">)</span>

        <span class="s2"># construction_points containing nans</span>
        <span class="s1">construction_points = [np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan]</span>
        <span class="s0">with </span><span class="s1">pytest.raises(UNURANError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">r&quot;50 : bad construction &quot;</span>
                                              <span class="s4">r&quot;points.&quot;</span><span class="s1">):</span>
            <span class="s1">TransformedDensityRejection(</span>
                <span class="s1">StandardNormal()</span><span class="s0">, </span><span class="s1">construction_points=construction_points</span>
            <span class="s1">)</span>

        <span class="s2"># construction_points out of domain</span>
        <span class="s1">construction_points = [-</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s1">]</span>
        <span class="s0">with </span><span class="s1">pytest.warns(RuntimeWarning</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">r&quot;50 : starting point out of &quot;</span>
                                                <span class="s4">r&quot;domain&quot;</span><span class="s1">):</span>
            <span class="s1">TransformedDensityRejection(</span>
                <span class="s1">StandardNormal()</span><span class="s0">, </span><span class="s1">domain=(-</span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">construction_points=construction_points</span>
            <span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;c&quot;</span><span class="s0">, </span><span class="s1">[-</span><span class="s3">1.</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s3">0.1</span><span class="s0">, </span><span class="s3">1.</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_bad_c(self</span><span class="s0">, </span><span class="s1">c):</span>
        <span class="s1">msg = </span><span class="s4">r&quot;`c` must either be -0.5 or 0.&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">TransformedDensityRejection(StandardNormal()</span><span class="s0">, </span><span class="s1">c=-</span><span class="s3">1.</span><span class="s1">)</span>

    <span class="s1">u = [np.linspace(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">num=</span><span class="s3">1000</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[]</span><span class="s0">, </span><span class="s1">[[]]</span><span class="s0">, </span><span class="s1">[np.nan]</span><span class="s0">,</span>
         <span class="s1">[-np.inf</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.inf]</span><span class="s0">, </span><span class="s3">0</span><span class="s0">,</span>
         <span class="s1">[[np.nan</span><span class="s0">, </span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">0.1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0.2</span><span class="s0">, </span><span class="s3">0.4</span><span class="s0">, </span><span class="s1">np.inf]</span><span class="s0">, </span><span class="s1">[-</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">]]]</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;u&quot;</span><span class="s0">, </span><span class="s1">u)</span>
    <span class="s0">def </span><span class="s1">test_ppf_hat(self</span><span class="s0">, </span><span class="s1">u):</span>
        <span class="s2"># Increase the `max_squeeze_hat_ratio` so the ppf_hat is more</span>
        <span class="s2"># accurate.</span>
        <span class="s1">rng = TransformedDensityRejection(StandardNormal()</span><span class="s0">,</span>
                                          <span class="s1">max_squeeze_hat_ratio=</span><span class="s3">0.9999</span><span class="s1">)</span>
        <span class="s2"># Older versions of NumPy throw RuntimeWarnings for comparisons</span>
        <span class="s2"># with nan.</span>
        <span class="s0">with </span><span class="s1">suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(RuntimeWarning</span><span class="s0">, </span><span class="s4">&quot;invalid value encountered in greater&quot;</span><span class="s1">)</span>
            <span class="s1">sup.filter(RuntimeWarning</span><span class="s0">, </span><span class="s4">&quot;invalid value encountered in &quot;</span>
                                       <span class="s4">&quot;greater_equal&quot;</span><span class="s1">)</span>
            <span class="s1">sup.filter(RuntimeWarning</span><span class="s0">, </span><span class="s4">&quot;invalid value encountered in less&quot;</span><span class="s1">)</span>
            <span class="s1">sup.filter(RuntimeWarning</span><span class="s0">, </span><span class="s4">&quot;invalid value encountered in &quot;</span>
                                       <span class="s4">&quot;less_equal&quot;</span><span class="s1">)</span>
            <span class="s1">res = rng.ppf_hat(u)</span>
            <span class="s1">expected = stats.norm.ppf(u)</span>
        <span class="s1">assert_allclose(res</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-3</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-5</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">res.shape == expected.shape</span>

    <span class="s0">def </span><span class="s1">test_bad_dist(self):</span>
        <span class="s2"># Empty distribution</span>
        <span class="s0">class </span><span class="s1">dist:</span>
            <span class="s1">...</span>

        <span class="s1">msg = </span><span class="s4">r&quot;`pdf` required but not found.&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">TransformedDensityRejection(dist)</span>

        <span class="s2"># dPDF not present in dist</span>
        <span class="s0">class </span><span class="s1">dist:</span>
            <span class="s1">pdf = </span><span class="s0">lambda </span><span class="s1">x: </span><span class="s3">1</span><span class="s1">-x*x  </span><span class="s2"># noqa: E731</span>

        <span class="s1">msg = </span><span class="s4">r&quot;`dpdf` required but not found.&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">TransformedDensityRejection(dist)</span>


<span class="s0">class </span><span class="s1">TestDiscreteAliasUrn:</span>
    <span class="s2"># DAU fails on these probably because of large domains and small</span>
    <span class="s2"># computation errors in PMF. Mean/SD match but chi-squared test fails.</span>
    <span class="s1">basic_fail_dists = {</span>
        <span class="s4">'nchypergeom_fisher'</span><span class="s0">,  </span><span class="s2"># numerical erros on tails</span>
        <span class="s4">'nchypergeom_wallenius'</span><span class="s0">,  </span><span class="s2"># numerical erros on tails</span>
        <span class="s4">'randint'  </span><span class="s2"># fails on 32-bit ubuntu</span>
    <span class="s1">}</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;distname, params&quot;</span><span class="s0">, </span><span class="s1">distdiscrete)</span>
    <span class="s0">def </span><span class="s1">test_basic(self</span><span class="s0">, </span><span class="s1">distname</span><span class="s0">, </span><span class="s1">params):</span>
        <span class="s0">if </span><span class="s1">distname </span><span class="s0">in </span><span class="s1">self.basic_fail_dists:</span>
            <span class="s1">msg = (</span><span class="s4">&quot;DAU fails on these probably because of large domains &quot;</span>
                   <span class="s4">&quot;and small computation errors in PMF.&quot;</span><span class="s1">)</span>
            <span class="s1">pytest.skip(msg)</span>
        <span class="s0">if not </span><span class="s1">isinstance(distname</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s1">dist = distname</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">dist = getattr(stats</span><span class="s0">, </span><span class="s1">distname)</span>
        <span class="s1">dist = dist(*params)</span>
        <span class="s1">domain = dist.support()</span>
        <span class="s0">if not </span><span class="s1">np.isfinite(domain[</span><span class="s3">1</span><span class="s1">] - domain[</span><span class="s3">0</span><span class="s1">]):</span>
            <span class="s2"># DAU only works with finite domain. So, skip the distributions</span>
            <span class="s2"># with infinite tails.</span>
            <span class="s1">pytest.skip(</span><span class="s4">&quot;DAU only works with a finite domain.&quot;</span><span class="s1">)</span>
        <span class="s1">k = np.arange(domain[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">domain[</span><span class="s3">1</span><span class="s1">]+</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">pv = dist.pmf(k)</span>
        <span class="s1">mv_ex = dist.stats(</span><span class="s4">'mv'</span><span class="s1">)</span>
        <span class="s1">rng = DiscreteAliasUrn(dist</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s3">42</span><span class="s1">)</span>
        <span class="s1">check_discr_samples(rng</span><span class="s0">, </span><span class="s1">pv</span><span class="s0">, </span><span class="s1">mv_ex)</span>

    <span class="s2"># Can't use bad_pmf_common here as we evaluate PMF early on to avoid</span>
    <span class="s2"># unhelpful errors from UNU.RAN.</span>
    <span class="s1">bad_pmf = [</span>
        <span class="s2"># inf returned</span>
        <span class="s1">(</span><span class="s0">lambda </span><span class="s1">x: np.inf</span><span class="s0">, </span><span class="s1">ValueError</span><span class="s0">,</span>
         <span class="s4">r&quot;must contain only finite / non-nan values&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s2"># nan returned</span>
        <span class="s1">(</span><span class="s0">lambda </span><span class="s1">x: np.nan</span><span class="s0">, </span><span class="s1">ValueError</span><span class="s0">,</span>
         <span class="s4">r&quot;must contain only finite / non-nan values&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s2"># all zeros</span>
        <span class="s1">(</span><span class="s0">lambda </span><span class="s1">x: </span><span class="s3">0.0</span><span class="s0">, </span><span class="s1">ValueError</span><span class="s0">,</span>
         <span class="s4">r&quot;must contain at least one non-zero value&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s2"># Undefined name inside the function</span>
        <span class="s1">(</span><span class="s0">lambda </span><span class="s1">x: foo</span><span class="s0">, </span><span class="s1">NameError</span><span class="s0">,  </span><span class="s2"># type: ignore[name-defined]  # noqa</span>
         <span class="s4">r&quot;name 'foo' is not defined&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s2"># Returning wrong type.</span>
        <span class="s1">(</span><span class="s0">lambda </span><span class="s1">x: []</span><span class="s0">, </span><span class="s1">ValueError</span><span class="s0">,</span>
         <span class="s4">r&quot;setting an array element with a sequence.&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s2"># probabilities &lt; 0</span>
        <span class="s1">(</span><span class="s0">lambda </span><span class="s1">x: -x</span><span class="s0">, </span><span class="s1">UNURANError</span><span class="s0">,</span>
         <span class="s4">r&quot;50 : probability &lt; 0&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s2"># signature of PMF wrong</span>
        <span class="s1">(</span><span class="s0">lambda</span><span class="s1">: </span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">TypeError</span><span class="s0">,</span>
         <span class="s4">r&quot;takes 0 positional arguments but 1 was given&quot;</span><span class="s1">)</span>
    <span class="s1">]</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;pmf, err, msg&quot;</span><span class="s0">, </span><span class="s1">bad_pmf)</span>
    <span class="s0">def </span><span class="s1">test_bad_pmf(self</span><span class="s0">, </span><span class="s1">pmf</span><span class="s0">, </span><span class="s1">err</span><span class="s0">, </span><span class="s1">msg):</span>
        <span class="s0">class </span><span class="s1">dist:</span>
            <span class="s0">pass</span>
        <span class="s1">dist.pmf = pmf</span>
        <span class="s0">with </span><span class="s1">pytest.raises(err</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">DiscreteAliasUrn(dist</span><span class="s0">, </span><span class="s1">domain=(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">10</span><span class="s1">))</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;pv&quot;</span><span class="s0">, </span><span class="s1">[[</span><span class="s3">0.18</span><span class="s0">, </span><span class="s3">0.02</span><span class="s0">, </span><span class="s3">0.8</span><span class="s1">]</span><span class="s0">,</span>
                                    <span class="s1">[</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">2.0</span><span class="s0">, </span><span class="s3">3.0</span><span class="s0">, </span><span class="s3">4.0</span><span class="s0">, </span><span class="s3">5.0</span><span class="s0">, </span><span class="s3">6.0</span><span class="s1">]])</span>
    <span class="s0">def </span><span class="s1">test_sampling_with_pv(self</span><span class="s0">, </span><span class="s1">pv):</span>
        <span class="s1">pv = np.asarray(pv</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s1">rng = DiscreteAliasUrn(pv</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s3">123</span><span class="s1">)</span>
        <span class="s1">rng.rvs(</span><span class="s3">100_000</span><span class="s1">)</span>
        <span class="s1">pv = pv / pv.sum()</span>
        <span class="s1">variates = np.arange(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">len(pv))</span>
        <span class="s2"># test if the first few moments match</span>
        <span class="s1">m_expected = np.average(variates</span><span class="s0">, </span><span class="s1">weights=pv)</span>
        <span class="s1">v_expected = np.average((variates - m_expected) ** </span><span class="s3">2</span><span class="s0">, </span><span class="s1">weights=pv)</span>
        <span class="s1">mv_expected = m_expected</span><span class="s0">, </span><span class="s1">v_expected</span>
        <span class="s1">check_discr_samples(rng</span><span class="s0">, </span><span class="s1">pv</span><span class="s0">, </span><span class="s1">mv_expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;pv, msg&quot;</span><span class="s0">, </span><span class="s1">bad_pv_common)</span>
    <span class="s0">def </span><span class="s1">test_bad_pv(self</span><span class="s0">, </span><span class="s1">pv</span><span class="s0">, </span><span class="s1">msg):</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">DiscreteAliasUrn(pv)</span>

    <span class="s2"># DAU doesn't support infinite tails. So, it should throw an error when</span>
    <span class="s2"># inf is present in the domain.</span>
    <span class="s1">inf_domain = [(-np.inf</span><span class="s0">, </span><span class="s1">np.inf)</span><span class="s0">, </span><span class="s1">(np.inf</span><span class="s0">, </span><span class="s1">np.inf)</span><span class="s0">, </span><span class="s1">(-np.inf</span><span class="s0">, </span><span class="s1">-np.inf)</span><span class="s0">,</span>
                  <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">np.inf)</span><span class="s0">, </span><span class="s1">(-np.inf</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)]</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;domain&quot;</span><span class="s0">, </span><span class="s1">inf_domain)</span>
    <span class="s0">def </span><span class="s1">test_inf_domain(self</span><span class="s0">, </span><span class="s1">domain):</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">r&quot;must be finite&quot;</span><span class="s1">):</span>
            <span class="s1">DiscreteAliasUrn(stats.binom(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">0.2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">domain=domain)</span>

    <span class="s0">def </span><span class="s1">test_bad_urn_factor(self):</span>
        <span class="s0">with </span><span class="s1">pytest.warns(RuntimeWarning</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">r&quot;relative urn size &lt; 1.&quot;</span><span class="s1">):</span>
            <span class="s1">DiscreteAliasUrn([</span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">0.5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">urn_factor=-</span><span class="s3">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_bad_args(self):</span>
        <span class="s1">msg = (</span><span class="s4">r&quot;`domain` must be provided when the &quot;</span>
               <span class="s4">r&quot;probability vector is not available.&quot;</span><span class="s1">)</span>

        <span class="s0">class </span><span class="s1">dist:</span>
            <span class="s0">def </span><span class="s1">pmf(self</span><span class="s0">, </span><span class="s1">x):</span>
                <span class="s0">return </span><span class="s1">x</span>

        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">DiscreteAliasUrn(dist)</span>


<span class="s0">class </span><span class="s1">TestNumericalInversePolynomial:</span>
    <span class="s2"># Simple Custom Distribution</span>
    <span class="s0">class </span><span class="s1">dist0:</span>
        <span class="s0">def </span><span class="s1">pdf(self</span><span class="s0">, </span><span class="s1">x):</span>
            <span class="s0">return </span><span class="s3">3</span><span class="s1">/</span><span class="s3">4 </span><span class="s1">* (</span><span class="s3">1</span><span class="s1">-x*x)</span>

        <span class="s0">def </span><span class="s1">cdf(self</span><span class="s0">, </span><span class="s1">x):</span>
            <span class="s0">return </span><span class="s3">3</span><span class="s1">/</span><span class="s3">4 </span><span class="s1">* (x - x**</span><span class="s3">3</span><span class="s1">/</span><span class="s3">3 </span><span class="s1">+ </span><span class="s3">2</span><span class="s1">/</span><span class="s3">3</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">support(self):</span>
            <span class="s0">return </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span>

    <span class="s2"># Standard Normal Distribution</span>
    <span class="s0">class </span><span class="s1">dist1:</span>
        <span class="s0">def </span><span class="s1">pdf(self</span><span class="s0">, </span><span class="s1">x):</span>
            <span class="s0">return </span><span class="s1">stats.norm._pdf(x / </span><span class="s3">0.1</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">cdf(self</span><span class="s0">, </span><span class="s1">x):</span>
            <span class="s0">return </span><span class="s1">stats.norm._cdf(x / </span><span class="s3">0.1</span><span class="s1">)</span>

    <span class="s2"># Sin 2 distribution</span>
    <span class="s2">#          /  0.05 + 0.45*(1 +sin(2 Pi x))  if |x| &lt;= 1</span>
    <span class="s2">#  f(x) = &lt;</span>
    <span class="s2">#          \  0        otherwise</span>
    <span class="s2"># Taken from UNU.RAN test suite (from file t_pinv.c)</span>
    <span class="s0">class </span><span class="s1">dist2:</span>
        <span class="s0">def </span><span class="s1">pdf(self</span><span class="s0">, </span><span class="s1">x):</span>
            <span class="s0">return </span><span class="s3">0.05 </span><span class="s1">+ </span><span class="s3">0.45 </span><span class="s1">* (</span><span class="s3">1 </span><span class="s1">+ np.sin(</span><span class="s3">2</span><span class="s1">*np.pi*x))</span>

        <span class="s0">def </span><span class="s1">cdf(self</span><span class="s0">, </span><span class="s1">x):</span>
            <span class="s0">return </span><span class="s1">(</span><span class="s3">0.05</span><span class="s1">*(x + </span><span class="s3">1</span><span class="s1">) +</span>
                    <span class="s3">0.9</span><span class="s1">*(</span><span class="s3">1. </span><span class="s1">+ </span><span class="s3">2.</span><span class="s1">*np.pi*(</span><span class="s3">1 </span><span class="s1">+ x) - np.cos(</span><span class="s3">2.</span><span class="s1">*np.pi*x)) /</span>
                    <span class="s1">(</span><span class="s3">4.</span><span class="s1">*np.pi))</span>

        <span class="s0">def </span><span class="s1">support(self):</span>
            <span class="s0">return </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span>

    <span class="s2"># Sin 10 distribution</span>
    <span class="s2">#          /  0.05 + 0.45*(1 +sin(2 Pi x))  if |x| &lt;= 5</span>
    <span class="s2">#  f(x) = &lt;</span>
    <span class="s2">#          \  0        otherwise</span>
    <span class="s2"># Taken from UNU.RAN test suite (from file t_pinv.c)</span>
    <span class="s0">class </span><span class="s1">dist3:</span>
        <span class="s0">def </span><span class="s1">pdf(self</span><span class="s0">, </span><span class="s1">x):</span>
            <span class="s0">return </span><span class="s3">0.2 </span><span class="s1">* (</span><span class="s3">0.05 </span><span class="s1">+ </span><span class="s3">0.45 </span><span class="s1">* (</span><span class="s3">1 </span><span class="s1">+ np.sin(</span><span class="s3">2</span><span class="s1">*np.pi*x)))</span>

        <span class="s0">def </span><span class="s1">cdf(self</span><span class="s0">, </span><span class="s1">x):</span>
            <span class="s0">return </span><span class="s1">x/</span><span class="s3">10. </span><span class="s1">+ </span><span class="s3">0.5 </span><span class="s1">+ </span><span class="s3">0.09</span><span class="s1">/(</span><span class="s3">2</span><span class="s1">*np.pi) * (np.cos(</span><span class="s3">10</span><span class="s1">*np.pi) -</span>
                                                   <span class="s1">np.cos(</span><span class="s3">2</span><span class="s1">*np.pi*x))</span>

        <span class="s0">def </span><span class="s1">support(self):</span>
            <span class="s0">return </span><span class="s1">-</span><span class="s3">5</span><span class="s0">, </span><span class="s3">5</span>

    <span class="s1">dists = [dist0()</span><span class="s0">, </span><span class="s1">dist1()</span><span class="s0">, </span><span class="s1">dist2()</span><span class="s0">, </span><span class="s1">dist3()]</span>

    <span class="s2"># exact mean and variance of the distributions in the list dists</span>
    <span class="s1">mv0 = [</span><span class="s3">0.</span><span class="s0">, </span><span class="s3">4.</span><span class="s1">/</span><span class="s3">15.</span><span class="s1">]</span>
    <span class="s1">mv1 = [</span><span class="s3">0.</span><span class="s0">, </span><span class="s3">0.01</span><span class="s1">]</span>
    <span class="s1">mv2 = [-</span><span class="s3">0.45</span><span class="s1">/np.pi</span><span class="s0">, </span><span class="s3">2</span><span class="s1">/</span><span class="s3">3</span><span class="s1">*</span><span class="s3">0.5 </span><span class="s1">- </span><span class="s3">0.45</span><span class="s1">**</span><span class="s3">2</span><span class="s1">/np.pi**</span><span class="s3">2</span><span class="s1">]</span>
    <span class="s1">mv3 = [-</span><span class="s3">0.45</span><span class="s1">/np.pi</span><span class="s0">, </span><span class="s3">0.2 </span><span class="s1">* </span><span class="s3">250</span><span class="s1">/</span><span class="s3">3 </span><span class="s1">* </span><span class="s3">0.5 </span><span class="s1">- </span><span class="s3">0.45</span><span class="s1">**</span><span class="s3">2</span><span class="s1">/np.pi**</span><span class="s3">2</span><span class="s1">]</span>
    <span class="s1">mvs = [mv0</span><span class="s0">, </span><span class="s1">mv1</span><span class="s0">, </span><span class="s1">mv2</span><span class="s0">, </span><span class="s1">mv3]</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;dist, mv_ex&quot;</span><span class="s0">,</span>
                             <span class="s1">zip(dists</span><span class="s0">, </span><span class="s1">mvs))</span>
    <span class="s0">def </span><span class="s1">test_basic(self</span><span class="s0">, </span><span class="s1">dist</span><span class="s0">, </span><span class="s1">mv_ex):</span>
        <span class="s1">rng = NumericalInversePolynomial(dist</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s3">42</span><span class="s1">)</span>
        <span class="s1">check_cont_samples(rng</span><span class="s0">, </span><span class="s1">dist</span><span class="s0">, </span><span class="s1">mv_ex)</span>

    <span class="s1">@pytest.mark.xslow</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;distname, params&quot;</span><span class="s0">, </span><span class="s1">distcont)</span>
    <span class="s0">def </span><span class="s1">test_basic_all_scipy_dists(self</span><span class="s0">, </span><span class="s1">distname</span><span class="s0">, </span><span class="s1">params):</span>

        <span class="s1">very_slow_dists = [</span><span class="s4">'anglit'</span><span class="s0">, </span><span class="s4">'gausshyper'</span><span class="s0">, </span><span class="s4">'kappa4'</span><span class="s0">,</span>
                           <span class="s4">'ksone'</span><span class="s0">, </span><span class="s4">'kstwo'</span><span class="s0">, </span><span class="s4">'levy_l'</span><span class="s0">,</span>
                           <span class="s4">'levy_stable'</span><span class="s0">, </span><span class="s4">'studentized_range'</span><span class="s0">,</span>
                           <span class="s4">'trapezoid'</span><span class="s0">, </span><span class="s4">'triang'</span><span class="s0">, </span><span class="s4">'vonmises'</span><span class="s1">]</span>
        <span class="s2"># for these distributions, some assertions fail due to minor</span>
        <span class="s2"># numerical differences. They can be avoided either by changing</span>
        <span class="s2"># the seed or by increasing the u_resolution.</span>
        <span class="s1">fail_dists = [</span><span class="s4">'chi2'</span><span class="s0">, </span><span class="s4">'fatiguelife'</span><span class="s0">, </span><span class="s4">'gibrat'</span><span class="s0">,</span>
                      <span class="s4">'halfgennorm'</span><span class="s0">, </span><span class="s4">'lognorm'</span><span class="s0">, </span><span class="s4">'ncf'</span><span class="s0">,</span>
                      <span class="s4">'ncx2'</span><span class="s0">, </span><span class="s4">'pareto'</span><span class="s0">, </span><span class="s4">'t'</span><span class="s1">]</span>
        <span class="s2"># for these distributions, skip the check for agreement between sample</span>
        <span class="s2"># moments and true moments. We cannot expect them to pass due to the</span>
        <span class="s2"># high variance of sample moments.</span>
        <span class="s1">skip_sample_moment_check = [</span><span class="s4">'rel_breitwigner'</span><span class="s1">]</span>

        <span class="s0">if </span><span class="s1">distname </span><span class="s0">in </span><span class="s1">very_slow_dists:</span>
            <span class="s1">pytest.skip(</span><span class="s4">f&quot;PINV too slow for </span><span class="s0">{</span><span class="s1">distname</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">distname </span><span class="s0">in </span><span class="s1">fail_dists:</span>
            <span class="s1">pytest.skip(</span><span class="s4">f&quot;PINV fails for </span><span class="s0">{</span><span class="s1">distname</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s1">dist = (getattr(stats</span><span class="s0">, </span><span class="s1">distname)</span>
                <span class="s0">if </span><span class="s1">isinstance(distname</span><span class="s0">, </span><span class="s1">str)</span>
                <span class="s0">else </span><span class="s1">distname)</span>
        <span class="s1">dist = dist(*params)</span>
        <span class="s0">with </span><span class="s1">suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(RuntimeWarning)</span>
            <span class="s1">rng = NumericalInversePolynomial(dist</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s3">42</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">distname </span><span class="s0">in </span><span class="s1">skip_sample_moment_check:</span>
            <span class="s0">return</span>
        <span class="s1">check_cont_samples(rng</span><span class="s0">, </span><span class="s1">dist</span><span class="s0">, </span><span class="s1">[dist.mean()</span><span class="s0">, </span><span class="s1">dist.var()])</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;pdf, err, msg&quot;</span><span class="s0">, </span><span class="s1">bad_pdfs_common)</span>
    <span class="s0">def </span><span class="s1">test_bad_pdf(self</span><span class="s0">, </span><span class="s1">pdf</span><span class="s0">, </span><span class="s1">err</span><span class="s0">, </span><span class="s1">msg):</span>
        <span class="s0">class </span><span class="s1">dist:</span>
            <span class="s0">pass</span>
        <span class="s1">dist.pdf = pdf</span>
        <span class="s0">with </span><span class="s1">pytest.raises(err</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">NumericalInversePolynomial(dist</span><span class="s0">, </span><span class="s1">domain=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">5</span><span class="s1">])</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;logpdf, err, msg&quot;</span><span class="s0">, </span><span class="s1">bad_logpdfs_common)</span>
    <span class="s0">def </span><span class="s1">test_bad_logpdf(self</span><span class="s0">, </span><span class="s1">logpdf</span><span class="s0">, </span><span class="s1">err</span><span class="s0">, </span><span class="s1">msg):</span>
        <span class="s0">class </span><span class="s1">dist:</span>
            <span class="s0">pass</span>
        <span class="s1">dist.logpdf = logpdf</span>
        <span class="s0">with </span><span class="s1">pytest.raises(err</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">NumericalInversePolynomial(dist</span><span class="s0">, </span><span class="s1">domain=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">5</span><span class="s1">])</span>

    <span class="s2"># test domains with inf + nan in them. need to write a custom test for</span>
    <span class="s2"># this because not all methods support infinite tails.</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;domain, err, msg&quot;</span><span class="s0">, </span><span class="s1">inf_nan_domains)</span>
    <span class="s0">def </span><span class="s1">test_inf_nan_domains(self</span><span class="s0">, </span><span class="s1">domain</span><span class="s0">, </span><span class="s1">err</span><span class="s0">, </span><span class="s1">msg):</span>
        <span class="s0">with </span><span class="s1">pytest.raises(err</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">NumericalInversePolynomial(StandardNormal()</span><span class="s0">, </span><span class="s1">domain=domain)</span>

    <span class="s1">u = [</span>
        <span class="s2"># test if quantile 0 and 1 return -inf and inf respectively and check</span>
        <span class="s2"># the correctness of the PPF for equidistant points between 0 and 1.</span>
        <span class="s1">np.linspace(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">num=</span><span class="s3">10000</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s2"># test the PPF method for empty arrays</span>
        <span class="s1">[]</span><span class="s0">, </span><span class="s1">[[]]</span><span class="s0">,</span>
        <span class="s2"># test if nans and infs return nan result.</span>
        <span class="s1">[np.nan]</span><span class="s0">, </span><span class="s1">[-np.inf</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.inf]</span><span class="s0">,</span>
        <span class="s2"># test if a scalar is returned for a scalar input.</span>
        <span class="s3">0</span><span class="s0">,</span>
        <span class="s2"># test for arrays with nans, values greater than 1 and less than 0,</span>
        <span class="s2"># and some valid values.</span>
        <span class="s1">[[np.nan</span><span class="s0">, </span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">0.1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0.2</span><span class="s0">, </span><span class="s3">0.4</span><span class="s0">, </span><span class="s1">np.inf]</span><span class="s0">, </span><span class="s1">[-</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">]]</span>
    <span class="s1">]</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;u&quot;</span><span class="s0">, </span><span class="s1">u)</span>
    <span class="s0">def </span><span class="s1">test_ppf(self</span><span class="s0">, </span><span class="s1">u):</span>
        <span class="s1">dist = StandardNormal()</span>
        <span class="s1">rng = NumericalInversePolynomial(dist</span><span class="s0">, </span><span class="s1">u_resolution=</span><span class="s3">1e-14</span><span class="s1">)</span>
        <span class="s2"># Older versions of NumPy throw RuntimeWarnings for comparisons</span>
        <span class="s2"># with nan.</span>
        <span class="s0">with </span><span class="s1">suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(RuntimeWarning</span><span class="s0">, </span><span class="s4">&quot;invalid value encountered in greater&quot;</span><span class="s1">)</span>
            <span class="s1">sup.filter(RuntimeWarning</span><span class="s0">, </span><span class="s4">&quot;invalid value encountered in &quot;</span>
                                       <span class="s4">&quot;greater_equal&quot;</span><span class="s1">)</span>
            <span class="s1">sup.filter(RuntimeWarning</span><span class="s0">, </span><span class="s4">&quot;invalid value encountered in less&quot;</span><span class="s1">)</span>
            <span class="s1">sup.filter(RuntimeWarning</span><span class="s0">, </span><span class="s4">&quot;invalid value encountered in &quot;</span>
                                       <span class="s4">&quot;less_equal&quot;</span><span class="s1">)</span>
            <span class="s1">res = rng.ppf(u)</span>
            <span class="s1">expected = stats.norm.ppf(u)</span>
        <span class="s1">assert_allclose(res</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-11</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-11</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">res.shape == expected.shape</span>

    <span class="s1">x = [np.linspace(-</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s1">num=</span><span class="s3">10000</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[]</span><span class="s0">, </span><span class="s1">[[]]</span><span class="s0">, </span><span class="s1">[np.nan]</span><span class="s0">,</span>
         <span class="s1">[-np.inf</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.inf]</span><span class="s0">, </span><span class="s3">0</span><span class="s0">,</span>
         <span class="s1">[[np.nan</span><span class="s0">, </span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">0.1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0.2</span><span class="s0">, </span><span class="s3">0.4</span><span class="s0">, </span><span class="s1">np.inf]</span><span class="s0">, </span><span class="s1">[-np.inf</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">]]]</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;x&quot;</span><span class="s0">, </span><span class="s1">x)</span>
    <span class="s0">def </span><span class="s1">test_cdf(self</span><span class="s0">, </span><span class="s1">x):</span>
        <span class="s1">dist = StandardNormal()</span>
        <span class="s1">rng = NumericalInversePolynomial(dist</span><span class="s0">, </span><span class="s1">u_resolution=</span><span class="s3">1e-14</span><span class="s1">)</span>
        <span class="s2"># Older versions of NumPy throw RuntimeWarnings for comparisons</span>
        <span class="s2"># with nan.</span>
        <span class="s0">with </span><span class="s1">suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(RuntimeWarning</span><span class="s0">, </span><span class="s4">&quot;invalid value encountered in greater&quot;</span><span class="s1">)</span>
            <span class="s1">sup.filter(RuntimeWarning</span><span class="s0">, </span><span class="s4">&quot;invalid value encountered in &quot;</span>
                                       <span class="s4">&quot;greater_equal&quot;</span><span class="s1">)</span>
            <span class="s1">sup.filter(RuntimeWarning</span><span class="s0">, </span><span class="s4">&quot;invalid value encountered in less&quot;</span><span class="s1">)</span>
            <span class="s1">sup.filter(RuntimeWarning</span><span class="s0">, </span><span class="s4">&quot;invalid value encountered in &quot;</span>
                                       <span class="s4">&quot;less_equal&quot;</span><span class="s1">)</span>
            <span class="s1">res = rng.cdf(x)</span>
            <span class="s1">expected = stats.norm.cdf(x)</span>
        <span class="s1">assert_allclose(res</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-11</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-11</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">res.shape == expected.shape</span>

    <span class="s0">def </span><span class="s1">test_u_error(self):</span>
        <span class="s1">dist = StandardNormal()</span>
        <span class="s1">rng = NumericalInversePolynomial(dist</span><span class="s0">, </span><span class="s1">u_resolution=</span><span class="s3">1e-10</span><span class="s1">)</span>
        <span class="s1">max_error</span><span class="s0">, </span><span class="s1">mae = rng.u_error()</span>
        <span class="s0">assert </span><span class="s1">max_error &lt; </span><span class="s3">1e-10</span>
        <span class="s0">assert </span><span class="s1">mae &lt;= max_error</span>
        <span class="s1">rng = NumericalInversePolynomial(dist</span><span class="s0">, </span><span class="s1">u_resolution=</span><span class="s3">1e-14</span><span class="s1">)</span>
        <span class="s1">max_error</span><span class="s0">, </span><span class="s1">mae = rng.u_error()</span>
        <span class="s0">assert </span><span class="s1">max_error &lt; </span><span class="s3">1e-14</span>
        <span class="s0">assert </span><span class="s1">mae &lt;= max_error</span>

    <span class="s1">bad_orders = [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">4.5</span><span class="s0">, </span><span class="s3">20</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">np.nan]</span>
    <span class="s1">bad_u_resolution = [</span><span class="s3">1e-20</span><span class="s0">, </span><span class="s3">1e-1</span><span class="s0">, </span><span class="s1">np.inf</span><span class="s0">, </span><span class="s1">np.nan]</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;order&quot;</span><span class="s0">, </span><span class="s1">bad_orders)</span>
    <span class="s0">def </span><span class="s1">test_bad_orders(self</span><span class="s0">, </span><span class="s1">order):</span>
        <span class="s1">dist = StandardNormal()</span>

        <span class="s1">msg = </span><span class="s4">r&quot;`order` must be an integer in the range \[3, 17\].&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">NumericalInversePolynomial(dist</span><span class="s0">, </span><span class="s1">order=order)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;u_resolution&quot;</span><span class="s0">, </span><span class="s1">bad_u_resolution)</span>
    <span class="s0">def </span><span class="s1">test_bad_u_resolution(self</span><span class="s0">, </span><span class="s1">u_resolution):</span>
        <span class="s1">msg = </span><span class="s4">r&quot;`u_resolution` must be between 1e-15 and 1e-5.&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">NumericalInversePolynomial(StandardNormal()</span><span class="s0">,</span>
                                       <span class="s1">u_resolution=u_resolution)</span>

    <span class="s0">def </span><span class="s1">test_bad_args(self):</span>

        <span class="s0">class </span><span class="s1">BadDist:</span>
            <span class="s0">def </span><span class="s1">cdf(self</span><span class="s0">, </span><span class="s1">x):</span>
                <span class="s0">return </span><span class="s1">stats.norm._cdf(x)</span>

        <span class="s1">dist = BadDist()</span>
        <span class="s1">msg = </span><span class="s4">r&quot;Either of the methods `pdf` or `logpdf` must be specified&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">rng = NumericalInversePolynomial(dist)</span>

        <span class="s1">dist = StandardNormal()</span>
        <span class="s1">rng = NumericalInversePolynomial(dist)</span>
        <span class="s1">msg = </span><span class="s4">r&quot;`sample_size` must be greater than or equal to 1000.&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">rng.u_error(</span><span class="s3">10</span><span class="s1">)</span>

        <span class="s0">class </span><span class="s1">Distribution:</span>
            <span class="s0">def </span><span class="s1">pdf(self</span><span class="s0">, </span><span class="s1">x):</span>
                <span class="s0">return </span><span class="s1">np.exp(-</span><span class="s3">0.5 </span><span class="s1">* x*x)</span>

        <span class="s1">dist = Distribution()</span>
        <span class="s1">rng = NumericalInversePolynomial(dist)</span>
        <span class="s1">msg = </span><span class="s4">r&quot;Exact CDF required but not found.&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">rng.u_error()</span>

    <span class="s0">def </span><span class="s1">test_logpdf_pdf_consistency(self):</span>
        <span class="s2"># 1. check that PINV works with pdf and logpdf only</span>
        <span class="s2"># 2. check that generated ppf is the same (up to a small tolerance)</span>

        <span class="s0">class </span><span class="s1">MyDist:</span>
            <span class="s0">pass</span>

        <span class="s2"># create genrator from dist with only pdf</span>
        <span class="s1">dist_pdf = MyDist()</span>
        <span class="s1">dist_pdf.pdf = </span><span class="s0">lambda </span><span class="s1">x: math.exp(-x*x/</span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">rng1 = NumericalInversePolynomial(dist_pdf)</span>

        <span class="s2"># create dist with only logpdf</span>
        <span class="s1">dist_logpdf = MyDist()</span>
        <span class="s1">dist_logpdf.logpdf = </span><span class="s0">lambda </span><span class="s1">x: -x*x/</span><span class="s3">2</span>
        <span class="s1">rng2 = NumericalInversePolynomial(dist_logpdf)</span>

        <span class="s1">q = np.linspace(</span><span class="s3">1e-5</span><span class="s0">, </span><span class="s3">1</span><span class="s1">-</span><span class="s3">1e-5</span><span class="s0">, </span><span class="s1">num=</span><span class="s3">100</span><span class="s1">)</span>
        <span class="s1">assert_allclose(rng1.ppf(q)</span><span class="s0">, </span><span class="s1">rng2.ppf(q))</span>


<span class="s0">class </span><span class="s1">TestNumericalInverseHermite:</span>
    <span class="s2">#         /  (1 +sin(2 Pi x))/2  if |x| &lt;= 1</span>
    <span class="s2"># f(x) = &lt;</span>
    <span class="s2">#         \  0        otherwise</span>
    <span class="s2"># Taken from UNU.RAN test suite (from file t_hinv.c)</span>
    <span class="s0">class </span><span class="s1">dist0:</span>
        <span class="s0">def </span><span class="s1">pdf(self</span><span class="s0">, </span><span class="s1">x):</span>
            <span class="s0">return </span><span class="s3">0.5</span><span class="s1">*(</span><span class="s3">1. </span><span class="s1">+ np.sin(</span><span class="s3">2.</span><span class="s1">*np.pi*x))</span>

        <span class="s0">def </span><span class="s1">dpdf(self</span><span class="s0">, </span><span class="s1">x):</span>
            <span class="s0">return </span><span class="s1">np.pi*np.cos(</span><span class="s3">2.</span><span class="s1">*np.pi*x)</span>

        <span class="s0">def </span><span class="s1">cdf(self</span><span class="s0">, </span><span class="s1">x):</span>
            <span class="s0">return </span><span class="s1">(</span><span class="s3">1. </span><span class="s1">+ </span><span class="s3">2.</span><span class="s1">*np.pi*(</span><span class="s3">1 </span><span class="s1">+ x) - np.cos(</span><span class="s3">2.</span><span class="s1">*np.pi*x)) / (</span><span class="s3">4.</span><span class="s1">*np.pi)</span>

        <span class="s0">def </span><span class="s1">support(self):</span>
            <span class="s0">return </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span>

    <span class="s2">#         /  Max(sin(2 Pi x)),0)Pi/2  if -1 &lt; x &lt;0.5</span>
    <span class="s2"># f(x) = &lt;</span>
    <span class="s2">#         \  0        otherwise</span>
    <span class="s2"># Taken from UNU.RAN test suite (from file t_hinv.c)</span>
    <span class="s0">class </span><span class="s1">dist1:</span>
        <span class="s0">def </span><span class="s1">pdf(self</span><span class="s0">, </span><span class="s1">x):</span>
            <span class="s0">if </span><span class="s1">(x &lt;= -</span><span class="s3">0.5</span><span class="s1">):</span>
                <span class="s0">return </span><span class="s1">np.sin((</span><span class="s3">2. </span><span class="s1">* np.pi) * x) * </span><span class="s3">0.5 </span><span class="s1">* np.pi</span>
            <span class="s0">if </span><span class="s1">(x &lt; </span><span class="s3">0.</span><span class="s1">):</span>
                <span class="s0">return </span><span class="s3">0.</span>
            <span class="s0">if </span><span class="s1">(x &lt;= </span><span class="s3">0.5</span><span class="s1">):</span>
                <span class="s0">return </span><span class="s1">np.sin((</span><span class="s3">2. </span><span class="s1">* np.pi) * x) * </span><span class="s3">0.5 </span><span class="s1">* np.pi</span>

        <span class="s0">def </span><span class="s1">dpdf(self</span><span class="s0">, </span><span class="s1">x):</span>
            <span class="s0">if </span><span class="s1">(x &lt;= -</span><span class="s3">0.5</span><span class="s1">):</span>
                <span class="s0">return </span><span class="s1">np.cos((</span><span class="s3">2. </span><span class="s1">* np.pi) * x) * np.pi * np.pi</span>
            <span class="s0">if </span><span class="s1">(x &lt; </span><span class="s3">0.</span><span class="s1">):</span>
                <span class="s0">return </span><span class="s3">0.</span>
            <span class="s0">if </span><span class="s1">(x &lt;= </span><span class="s3">0.5</span><span class="s1">):</span>
                <span class="s0">return </span><span class="s1">np.cos((</span><span class="s3">2. </span><span class="s1">* np.pi) * x) * np.pi * np.pi</span>

        <span class="s0">def </span><span class="s1">cdf(self</span><span class="s0">, </span><span class="s1">x):</span>
            <span class="s0">if </span><span class="s1">(x &lt;= -</span><span class="s3">0.5</span><span class="s1">):</span>
                <span class="s0">return </span><span class="s3">0.25 </span><span class="s1">* (</span><span class="s3">1 </span><span class="s1">- np.cos((</span><span class="s3">2. </span><span class="s1">* np.pi) * x))</span>
            <span class="s0">if </span><span class="s1">(x &lt; </span><span class="s3">0.</span><span class="s1">):</span>
                <span class="s0">return </span><span class="s3">0.5</span>
            <span class="s0">if </span><span class="s1">(x &lt;= </span><span class="s3">0.5</span><span class="s1">):</span>
                <span class="s0">return </span><span class="s3">0.75 </span><span class="s1">- </span><span class="s3">0.25 </span><span class="s1">* np.cos((</span><span class="s3">2. </span><span class="s1">* np.pi) * x)</span>

        <span class="s0">def </span><span class="s1">support(self):</span>
            <span class="s0">return </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0.5</span>

    <span class="s1">dists = [dist0()</span><span class="s0">, </span><span class="s1">dist1()]</span>

    <span class="s2"># exact mean and variance of the distributions in the list dists</span>
    <span class="s1">mv0 = [-</span><span class="s3">1</span><span class="s1">/(</span><span class="s3">2</span><span class="s1">*np.pi)</span><span class="s0">, </span><span class="s3">1</span><span class="s1">/</span><span class="s3">3 </span><span class="s1">- </span><span class="s3">1</span><span class="s1">/(</span><span class="s3">4</span><span class="s1">*np.pi*np.pi)]</span>
    <span class="s1">mv1 = [-</span><span class="s3">1</span><span class="s1">/</span><span class="s3">4</span><span class="s0">, </span><span class="s3">3</span><span class="s1">/</span><span class="s3">8</span><span class="s1">-</span><span class="s3">1</span><span class="s1">/(</span><span class="s3">2</span><span class="s1">*np.pi*np.pi) - </span><span class="s3">1</span><span class="s1">/</span><span class="s3">16</span><span class="s1">]</span>
    <span class="s1">mvs = [mv0</span><span class="s0">, </span><span class="s1">mv1]</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;dist, mv_ex&quot;</span><span class="s0">,</span>
                             <span class="s1">zip(dists</span><span class="s0">, </span><span class="s1">mvs))</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;order&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">3</span><span class="s0">, </span><span class="s3">5</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_basic(self</span><span class="s0">, </span><span class="s1">dist</span><span class="s0">, </span><span class="s1">mv_ex</span><span class="s0">, </span><span class="s1">order):</span>
        <span class="s1">rng = NumericalInverseHermite(dist</span><span class="s0">, </span><span class="s1">order=order</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s3">42</span><span class="s1">)</span>
        <span class="s1">check_cont_samples(rng</span><span class="s0">, </span><span class="s1">dist</span><span class="s0">, </span><span class="s1">mv_ex)</span>

    <span class="s2"># test domains with inf + nan in them. need to write a custom test for</span>
    <span class="s2"># this because not all methods support infinite tails.</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;domain, err, msg&quot;</span><span class="s0">, </span><span class="s1">inf_nan_domains)</span>
    <span class="s0">def </span><span class="s1">test_inf_nan_domains(self</span><span class="s0">, </span><span class="s1">domain</span><span class="s0">, </span><span class="s1">err</span><span class="s0">, </span><span class="s1">msg):</span>
        <span class="s0">with </span><span class="s1">pytest.raises(err</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">NumericalInverseHermite(StandardNormal()</span><span class="s0">, </span><span class="s1">domain=domain)</span>

    <span class="s0">def </span><span class="s1">basic_test_all_scipy_dists(self</span><span class="s0">, </span><span class="s1">distname</span><span class="s0">, </span><span class="s1">shapes):</span>
        <span class="s1">slow_dists = {</span><span class="s4">'ksone'</span><span class="s0">, </span><span class="s4">'kstwo'</span><span class="s0">, </span><span class="s4">'levy_stable'</span><span class="s0">, </span><span class="s4">'skewnorm'</span><span class="s1">}</span>
        <span class="s1">fail_dists = {</span><span class="s4">'beta'</span><span class="s0">, </span><span class="s4">'gausshyper'</span><span class="s0">, </span><span class="s4">'geninvgauss'</span><span class="s0">, </span><span class="s4">'ncf'</span><span class="s0">, </span><span class="s4">'nct'</span><span class="s0">,</span>
                      <span class="s4">'norminvgauss'</span><span class="s0">, </span><span class="s4">'genhyperbolic'</span><span class="s0">, </span><span class="s4">'studentized_range'</span><span class="s0">,</span>
                      <span class="s4">'vonmises'</span><span class="s0">, </span><span class="s4">'kappa4'</span><span class="s0">, </span><span class="s4">'invgauss'</span><span class="s0">, </span><span class="s4">'wald'</span><span class="s1">}</span>

        <span class="s0">if </span><span class="s1">distname </span><span class="s0">in </span><span class="s1">slow_dists:</span>
            <span class="s1">pytest.skip(</span><span class="s4">&quot;Distribution is too slow&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">distname </span><span class="s0">in </span><span class="s1">fail_dists:</span>
            <span class="s2"># specific reasons documented in gh-13319</span>
            <span class="s2"># https://github.com/scipy/scipy/pull/13319#discussion_r626188955</span>
            <span class="s1">pytest.xfail(</span><span class="s4">&quot;Fails - usually due to inaccurate CDF/PDF&quot;</span><span class="s1">)</span>

        <span class="s1">np.random.seed(</span><span class="s3">0</span><span class="s1">)</span>

        <span class="s1">dist = getattr(stats</span><span class="s0">, </span><span class="s1">distname)(*shapes)</span>
        <span class="s1">fni = NumericalInverseHermite(dist)</span>

        <span class="s1">x = np.random.rand(</span><span class="s3">10</span><span class="s1">)</span>
        <span class="s1">p_tol = np.max(np.abs(dist.ppf(x)-fni.ppf(x))/np.abs(dist.ppf(x)))</span>
        <span class="s1">u_tol = np.max(np.abs(dist.cdf(fni.ppf(x)) - x))</span>

        <span class="s0">assert </span><span class="s1">p_tol &lt; </span><span class="s3">1e-8</span>
        <span class="s0">assert </span><span class="s1">u_tol &lt; </span><span class="s3">1e-12</span>

    <span class="s1">@pytest.mark.filterwarnings(</span><span class="s4">'ignore::RuntimeWarning'</span><span class="s1">)</span>
    <span class="s1">@pytest.mark.xslow</span>
    <span class="s1">@pytest.mark.parametrize((</span><span class="s4">&quot;distname&quot;</span><span class="s0">, </span><span class="s4">&quot;shapes&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">distcont)</span>
    <span class="s0">def </span><span class="s1">test_basic_all_scipy_dists(self</span><span class="s0">, </span><span class="s1">distname</span><span class="s0">, </span><span class="s1">shapes):</span>
        <span class="s2"># if distname == &quot;truncnorm&quot;:</span>
        <span class="s2">#     pytest.skip(&quot;Tested separately&quot;)</span>
        <span class="s1">self.basic_test_all_scipy_dists(distname</span><span class="s0">, </span><span class="s1">shapes)</span>

    <span class="s1">@pytest.mark.filterwarnings(</span><span class="s4">'ignore::RuntimeWarning'</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_basic_truncnorm_gh17155(self):</span>
        <span class="s1">self.basic_test_all_scipy_dists(</span><span class="s4">&quot;truncnorm&quot;</span><span class="s0">, </span><span class="s1">(</span><span class="s3">0.1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_input_validation(self):</span>
        <span class="s1">match = </span><span class="s4">r&quot;`order` must be either 1, 3, or 5.&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=match):</span>
            <span class="s1">NumericalInverseHermite(StandardNormal()</span><span class="s0">, </span><span class="s1">order=</span><span class="s3">2</span><span class="s1">)</span>

        <span class="s1">match = </span><span class="s4">&quot;`cdf` required but not found&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=match):</span>
            <span class="s1">NumericalInverseHermite(</span><span class="s4">&quot;norm&quot;</span><span class="s1">)</span>

        <span class="s1">match = </span><span class="s4">&quot;could not convert string to float&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=match):</span>
            <span class="s1">NumericalInverseHermite(StandardNormal()</span><span class="s0">,</span>
                                    <span class="s1">u_resolution=</span><span class="s4">'ekki'</span><span class="s1">)</span>

    <span class="s1">rngs = [</span><span class="s0">None, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">np.random.RandomState(</span><span class="s3">0</span><span class="s1">)]</span>
    <span class="s1">rngs.append(np.random.default_rng(</span><span class="s3">0</span><span class="s1">))  </span><span class="s2"># type: ignore</span>
    <span class="s1">sizes = [(</span><span class="s0">None, </span><span class="s1">tuple())</span><span class="s0">, </span><span class="s1">(</span><span class="s3">8</span><span class="s0">, </span><span class="s1">(</span><span class="s3">8</span><span class="s0">,</span><span class="s1">))</span><span class="s0">, </span><span class="s1">((</span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s1">))]</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">'rng'</span><span class="s0">, </span><span class="s1">rngs)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">'size_in, size_out'</span><span class="s0">, </span><span class="s1">sizes)</span>
    <span class="s0">def </span><span class="s1">test_RVS(self</span><span class="s0">, </span><span class="s1">rng</span><span class="s0">, </span><span class="s1">size_in</span><span class="s0">, </span><span class="s1">size_out):</span>
        <span class="s1">dist = StandardNormal()</span>
        <span class="s1">fni = NumericalInverseHermite(dist)</span>

        <span class="s1">rng2 = deepcopy(rng)</span>
        <span class="s1">rvs = fni.rvs(size=size_in</span><span class="s0">, </span><span class="s1">random_state=rng)</span>
        <span class="s0">if </span><span class="s1">size_in </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">assert </span><span class="s1">rvs.shape == size_out</span>

        <span class="s0">if </span><span class="s1">rng2 </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">rng2 = check_random_state(rng2)</span>
            <span class="s1">uniform = rng2.uniform(size=size_in)</span>
            <span class="s1">rvs2 = stats.norm.ppf(uniform)</span>
            <span class="s1">assert_allclose(rvs</span><span class="s0">, </span><span class="s1">rvs2)</span>

    <span class="s0">def </span><span class="s1">test_inaccurate_CDF(self):</span>
        <span class="s2"># CDF function with inaccurate tail cannot be inverted; see gh-13319</span>
        <span class="s2"># https://github.com/scipy/scipy/pull/13319#discussion_r626188955</span>
        <span class="s1">shapes = (</span><span class="s3">2.3098496451481823</span><span class="s0">, </span><span class="s3">0.6268795430096368</span><span class="s1">)</span>
        <span class="s1">match = (</span><span class="s4">&quot;98 : one or more intervals very short; possibly due to &quot;</span>
                 <span class="s4">&quot;numerical problems with a pole or very flat tail&quot;</span><span class="s1">)</span>

        <span class="s2"># fails with default tol</span>
        <span class="s0">with </span><span class="s1">pytest.warns(RuntimeWarning</span><span class="s0">, </span><span class="s1">match=match):</span>
            <span class="s1">NumericalInverseHermite(stats.beta(*shapes))</span>

        <span class="s2"># no error with coarser tol</span>
        <span class="s1">NumericalInverseHermite(stats.beta(*shapes)</span><span class="s0">, </span><span class="s1">u_resolution=</span><span class="s3">1e-8</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_custom_distribution(self):</span>
        <span class="s1">dist1 = StandardNormal()</span>
        <span class="s1">fni1 = NumericalInverseHermite(dist1)</span>

        <span class="s1">dist2 = stats.norm()</span>
        <span class="s1">fni2 = NumericalInverseHermite(dist2)</span>

        <span class="s1">assert_allclose(fni1.rvs(random_state=</span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">fni2.rvs(random_state=</span><span class="s3">0</span><span class="s1">))</span>

    <span class="s1">u = [</span>
        <span class="s2"># check the correctness of the PPF for equidistant points between</span>
        <span class="s2"># 0.02 and 0.98.</span>
        <span class="s1">np.linspace(</span><span class="s3">0.</span><span class="s0">, </span><span class="s3">1.</span><span class="s0">, </span><span class="s1">num=</span><span class="s3">10000</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s2"># test the PPF method for empty arrays</span>
        <span class="s1">[]</span><span class="s0">, </span><span class="s1">[[]]</span><span class="s0">,</span>
        <span class="s2"># test if nans and infs return nan result.</span>
        <span class="s1">[np.nan]</span><span class="s0">, </span><span class="s1">[-np.inf</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.inf]</span><span class="s0">,</span>
        <span class="s2"># test if a scalar is returned for a scalar input.</span>
        <span class="s3">0</span><span class="s0">,</span>
        <span class="s2"># test for arrays with nans, values greater than 1 and less than 0,</span>
        <span class="s2"># and some valid values.</span>
        <span class="s1">[[np.nan</span><span class="s0">, </span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">0.1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0.2</span><span class="s0">, </span><span class="s3">0.4</span><span class="s0">, </span><span class="s1">np.inf]</span><span class="s0">, </span><span class="s1">[-</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">]]</span>
    <span class="s1">]</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;u&quot;</span><span class="s0">, </span><span class="s1">u)</span>
    <span class="s0">def </span><span class="s1">test_ppf(self</span><span class="s0">, </span><span class="s1">u):</span>
        <span class="s1">dist = StandardNormal()</span>
        <span class="s1">rng = NumericalInverseHermite(dist</span><span class="s0">, </span><span class="s1">u_resolution=</span><span class="s3">1e-12</span><span class="s1">)</span>
        <span class="s2"># Older versions of NumPy throw RuntimeWarnings for comparisons</span>
        <span class="s2"># with nan.</span>
        <span class="s0">with </span><span class="s1">suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(RuntimeWarning</span><span class="s0">, </span><span class="s4">&quot;invalid value encountered in greater&quot;</span><span class="s1">)</span>
            <span class="s1">sup.filter(RuntimeWarning</span><span class="s0">, </span><span class="s4">&quot;invalid value encountered in &quot;</span>
                                       <span class="s4">&quot;greater_equal&quot;</span><span class="s1">)</span>
            <span class="s1">sup.filter(RuntimeWarning</span><span class="s0">, </span><span class="s4">&quot;invalid value encountered in less&quot;</span><span class="s1">)</span>
            <span class="s1">sup.filter(RuntimeWarning</span><span class="s0">, </span><span class="s4">&quot;invalid value encountered in &quot;</span>
                                       <span class="s4">&quot;less_equal&quot;</span><span class="s1">)</span>
            <span class="s1">res = rng.ppf(u)</span>
            <span class="s1">expected = stats.norm.ppf(u)</span>
        <span class="s1">assert_allclose(res</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-9</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">3e-10</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">res.shape == expected.shape</span>

    <span class="s0">def </span><span class="s1">test_u_error(self):</span>
        <span class="s1">dist = StandardNormal()</span>
        <span class="s1">rng = NumericalInverseHermite(dist</span><span class="s0">, </span><span class="s1">u_resolution=</span><span class="s3">1e-10</span><span class="s1">)</span>
        <span class="s1">max_error</span><span class="s0">, </span><span class="s1">mae = rng.u_error()</span>
        <span class="s0">assert </span><span class="s1">max_error &lt; </span><span class="s3">1e-10</span>
        <span class="s0">assert </span><span class="s1">mae &lt;= max_error</span>
        <span class="s0">with </span><span class="s1">suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
            <span class="s2"># ignore warning about u-resolution being too small.</span>
            <span class="s1">sup.filter(RuntimeWarning)</span>
            <span class="s1">rng = NumericalInverseHermite(dist</span><span class="s0">, </span><span class="s1">u_resolution=</span><span class="s3">1e-14</span><span class="s1">)</span>
        <span class="s1">max_error</span><span class="s0">, </span><span class="s1">mae = rng.u_error()</span>
        <span class="s0">assert </span><span class="s1">max_error &lt; </span><span class="s3">1e-14</span>
        <span class="s0">assert </span><span class="s1">mae &lt;= max_error</span>


<span class="s0">class </span><span class="s1">TestDiscreteGuideTable:</span>
    <span class="s1">basic_fail_dists = {</span>
        <span class="s4">'nchypergeom_fisher'</span><span class="s0">,  </span><span class="s2"># numerical errors on tails</span>
        <span class="s4">'nchypergeom_wallenius'</span><span class="s0">,  </span><span class="s2"># numerical errors on tails</span>
        <span class="s4">'randint'  </span><span class="s2"># fails on 32-bit ubuntu</span>
    <span class="s1">}</span>

    <span class="s0">def </span><span class="s1">test_guide_factor_gt3_raises_warning(self):</span>
        <span class="s1">pv = [</span><span class="s3">0.1</span><span class="s0">, </span><span class="s3">0.3</span><span class="s0">, </span><span class="s3">0.6</span><span class="s1">]</span>
        <span class="s1">urng = np.random.default_rng()</span>
        <span class="s0">with </span><span class="s1">pytest.warns(RuntimeWarning):</span>
            <span class="s1">DiscreteGuideTable(pv</span><span class="s0">, </span><span class="s1">random_state=urng</span><span class="s0">, </span><span class="s1">guide_factor=</span><span class="s3">7</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_guide_factor_zero_raises_warning(self):</span>
        <span class="s1">pv = [</span><span class="s3">0.1</span><span class="s0">, </span><span class="s3">0.3</span><span class="s0">, </span><span class="s3">0.6</span><span class="s1">]</span>
        <span class="s1">urng = np.random.default_rng()</span>
        <span class="s0">with </span><span class="s1">pytest.warns(RuntimeWarning):</span>
            <span class="s1">DiscreteGuideTable(pv</span><span class="s0">, </span><span class="s1">random_state=urng</span><span class="s0">, </span><span class="s1">guide_factor=</span><span class="s3">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_negative_guide_factor_raises_warning(self):</span>
        <span class="s2"># This occurs from the UNU.RAN wrapper automatically.</span>
        <span class="s2"># however it already gives a useful warning</span>
        <span class="s2"># Here we just test that a warning is raised.</span>
        <span class="s1">pv = [</span><span class="s3">0.1</span><span class="s0">, </span><span class="s3">0.3</span><span class="s0">, </span><span class="s3">0.6</span><span class="s1">]</span>
        <span class="s1">urng = np.random.default_rng()</span>
        <span class="s0">with </span><span class="s1">pytest.warns(RuntimeWarning):</span>
            <span class="s1">DiscreteGuideTable(pv</span><span class="s0">, </span><span class="s1">random_state=urng</span><span class="s0">, </span><span class="s1">guide_factor=-</span><span class="s3">1</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;distname, params&quot;</span><span class="s0">, </span><span class="s1">distdiscrete)</span>
    <span class="s0">def </span><span class="s1">test_basic(self</span><span class="s0">, </span><span class="s1">distname</span><span class="s0">, </span><span class="s1">params):</span>
        <span class="s0">if </span><span class="s1">distname </span><span class="s0">in </span><span class="s1">self.basic_fail_dists:</span>
            <span class="s1">msg = (</span><span class="s4">&quot;DGT fails on these probably because of large domains &quot;</span>
                   <span class="s4">&quot;and small computation errors in PMF.&quot;</span><span class="s1">)</span>
            <span class="s1">pytest.skip(msg)</span>

        <span class="s0">if not </span><span class="s1">isinstance(distname</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s1">dist = distname</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">dist = getattr(stats</span><span class="s0">, </span><span class="s1">distname)</span>

        <span class="s1">dist = dist(*params)</span>
        <span class="s1">domain = dist.support()</span>

        <span class="s0">if not </span><span class="s1">np.isfinite(domain[</span><span class="s3">1</span><span class="s1">] - domain[</span><span class="s3">0</span><span class="s1">]):</span>
            <span class="s2"># DGT only works with finite domain. So, skip the distributions</span>
            <span class="s2"># with infinite tails.</span>
            <span class="s1">pytest.skip(</span><span class="s4">&quot;DGT only works with a finite domain.&quot;</span><span class="s1">)</span>

        <span class="s1">k = np.arange(domain[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">domain[</span><span class="s3">1</span><span class="s1">]+</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">pv = dist.pmf(k)</span>
        <span class="s1">mv_ex = dist.stats(</span><span class="s4">'mv'</span><span class="s1">)</span>
        <span class="s1">rng = DiscreteGuideTable(dist</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s3">42</span><span class="s1">)</span>
        <span class="s1">check_discr_samples(rng</span><span class="s0">, </span><span class="s1">pv</span><span class="s0">, </span><span class="s1">mv_ex)</span>

    <span class="s1">u = [</span>
        <span class="s2"># the correctness of the PPF for equidistant points between 0 and 1.</span>
        <span class="s1">np.linspace(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">num=</span><span class="s3">10000</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s2"># test the PPF method for empty arrays</span>
        <span class="s1">[]</span><span class="s0">, </span><span class="s1">[[]]</span><span class="s0">,</span>
        <span class="s2"># test if nans and infs return nan result.</span>
        <span class="s1">[np.nan]</span><span class="s0">, </span><span class="s1">[-np.inf</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.inf]</span><span class="s0">,</span>
        <span class="s2"># test if a scalar is returned for a scalar input.</span>
        <span class="s3">0</span><span class="s0">,</span>
        <span class="s2"># test for arrays with nans, values greater than 1 and less than 0,</span>
        <span class="s2"># and some valid values.</span>
        <span class="s1">[[np.nan</span><span class="s0">, </span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">0.1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0.2</span><span class="s0">, </span><span class="s3">0.4</span><span class="s0">, </span><span class="s1">np.inf]</span><span class="s0">, </span><span class="s1">[-</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">]]</span>
    <span class="s1">]</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">'u'</span><span class="s0">, </span><span class="s1">u)</span>
    <span class="s0">def </span><span class="s1">test_ppf(self</span><span class="s0">, </span><span class="s1">u):</span>
        <span class="s1">n</span><span class="s0">, </span><span class="s1">p = </span><span class="s3">4</span><span class="s0">, </span><span class="s3">0.1</span>
        <span class="s1">dist = stats.binom(n</span><span class="s0">, </span><span class="s1">p)</span>
        <span class="s1">rng = DiscreteGuideTable(dist</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s3">42</span><span class="s1">)</span>

        <span class="s2"># Older versions of NumPy throw RuntimeWarnings for comparisons</span>
        <span class="s2"># with nan.</span>
        <span class="s0">with </span><span class="s1">suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(RuntimeWarning</span><span class="s0">, </span><span class="s4">&quot;invalid value encountered in greater&quot;</span><span class="s1">)</span>
            <span class="s1">sup.filter(RuntimeWarning</span><span class="s0">, </span><span class="s4">&quot;invalid value encountered in &quot;</span>
                                       <span class="s4">&quot;greater_equal&quot;</span><span class="s1">)</span>
            <span class="s1">sup.filter(RuntimeWarning</span><span class="s0">, </span><span class="s4">&quot;invalid value encountered in less&quot;</span><span class="s1">)</span>
            <span class="s1">sup.filter(RuntimeWarning</span><span class="s0">, </span><span class="s4">&quot;invalid value encountered in &quot;</span>
                                       <span class="s4">&quot;less_equal&quot;</span><span class="s1">)</span>

            <span class="s1">res = rng.ppf(u)</span>
            <span class="s1">expected = stats.binom.ppf(u</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">p)</span>
        <span class="s1">assert_equal(res.shape</span><span class="s0">, </span><span class="s1">expected.shape)</span>
        <span class="s1">assert_equal(res</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;pv, msg&quot;</span><span class="s0">, </span><span class="s1">bad_pv_common)</span>
    <span class="s0">def </span><span class="s1">test_bad_pv(self</span><span class="s0">, </span><span class="s1">pv</span><span class="s0">, </span><span class="s1">msg):</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">DiscreteGuideTable(pv)</span>

    <span class="s2"># DGT doesn't support infinite tails. So, it should throw an error when</span>
    <span class="s2"># inf is present in the domain.</span>
    <span class="s1">inf_domain = [(-np.inf</span><span class="s0">, </span><span class="s1">np.inf)</span><span class="s0">, </span><span class="s1">(np.inf</span><span class="s0">, </span><span class="s1">np.inf)</span><span class="s0">, </span><span class="s1">(-np.inf</span><span class="s0">, </span><span class="s1">-np.inf)</span><span class="s0">,</span>
                  <span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">np.inf)</span><span class="s0">, </span><span class="s1">(-np.inf</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)]</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;domain&quot;</span><span class="s0">, </span><span class="s1">inf_domain)</span>
    <span class="s0">def </span><span class="s1">test_inf_domain(self</span><span class="s0">, </span><span class="s1">domain):</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">r&quot;must be finite&quot;</span><span class="s1">):</span>
            <span class="s1">DiscreteGuideTable(stats.binom(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">0.2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">domain=domain)</span>


<span class="s0">class </span><span class="s1">TestSimpleRatioUniforms:</span>
    <span class="s2"># pdf with piecewise linear function as transformed density</span>
    <span class="s2"># with T = -1/sqrt with shift. Taken from UNU.RAN test suite</span>
    <span class="s2"># (from file t_srou.c)</span>
    <span class="s0">class </span><span class="s1">dist:</span>
        <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">shift):</span>
            <span class="s1">self.shift = shift</span>
            <span class="s1">self.mode = shift</span>

        <span class="s0">def </span><span class="s1">pdf(self</span><span class="s0">, </span><span class="s1">x):</span>
            <span class="s1">x -= self.shift</span>
            <span class="s1">y = </span><span class="s3">1. </span><span class="s1">/ (abs(x) + </span><span class="s3">1.</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s3">0.5 </span><span class="s1">* y * y</span>

        <span class="s0">def </span><span class="s1">cdf(self</span><span class="s0">, </span><span class="s1">x):</span>
            <span class="s1">x -= self.shift</span>
            <span class="s0">if </span><span class="s1">x &lt;= </span><span class="s3">0.</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s3">0.5 </span><span class="s1">/ (</span><span class="s3">1. </span><span class="s1">- x)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s3">1. </span><span class="s1">- </span><span class="s3">0.5 </span><span class="s1">/ (</span><span class="s3">1. </span><span class="s1">+ x)</span>

    <span class="s1">dists = [dist(</span><span class="s3">0.</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dist(</span><span class="s3">10000.</span><span class="s1">)]</span>

    <span class="s2"># exact mean and variance of the distributions in the list dists</span>
    <span class="s1">mv1 = [</span><span class="s3">0.</span><span class="s0">, </span><span class="s1">np.inf]</span>
    <span class="s1">mv2 = [</span><span class="s3">10000.</span><span class="s0">, </span><span class="s1">np.inf]</span>
    <span class="s1">mvs = [mv1</span><span class="s0">, </span><span class="s1">mv2]</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;dist, mv_ex&quot;</span><span class="s0">,</span>
                             <span class="s1">zip(dists</span><span class="s0">, </span><span class="s1">mvs))</span>
    <span class="s0">def </span><span class="s1">test_basic(self</span><span class="s0">, </span><span class="s1">dist</span><span class="s0">, </span><span class="s1">mv_ex):</span>
        <span class="s1">rng = SimpleRatioUniforms(dist</span><span class="s0">, </span><span class="s1">mode=dist.mode</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s3">42</span><span class="s1">)</span>
        <span class="s1">check_cont_samples(rng</span><span class="s0">, </span><span class="s1">dist</span><span class="s0">, </span><span class="s1">mv_ex)</span>
        <span class="s1">rng = SimpleRatioUniforms(dist</span><span class="s0">, </span><span class="s1">mode=dist.mode</span><span class="s0">,</span>
                                  <span class="s1">cdf_at_mode=dist.cdf(dist.mode)</span><span class="s0">,</span>
                                  <span class="s1">random_state=</span><span class="s3">42</span><span class="s1">)</span>
        <span class="s1">check_cont_samples(rng</span><span class="s0">, </span><span class="s1">dist</span><span class="s0">, </span><span class="s1">mv_ex)</span>

    <span class="s2"># test domains with inf + nan in them. need to write a custom test for</span>
    <span class="s2"># this because not all methods support infinite tails.</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;domain, err, msg&quot;</span><span class="s0">, </span><span class="s1">inf_nan_domains)</span>
    <span class="s0">def </span><span class="s1">test_inf_nan_domains(self</span><span class="s0">, </span><span class="s1">domain</span><span class="s0">, </span><span class="s1">err</span><span class="s0">, </span><span class="s1">msg):</span>
        <span class="s0">with </span><span class="s1">pytest.raises(err</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">SimpleRatioUniforms(StandardNormal()</span><span class="s0">, </span><span class="s1">domain=domain)</span>

    <span class="s0">def </span><span class="s1">test_bad_args(self):</span>
        <span class="s2"># pdf_area &lt; 0</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">r&quot;`pdf_area` must be &gt; 0&quot;</span><span class="s1">):</span>
            <span class="s1">SimpleRatioUniforms(StandardNormal()</span><span class="s0">, </span><span class="s1">mode=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">pdf_area=-</span><span class="s3">1</span><span class="s1">)</span>
</pre>
</body>
</html>