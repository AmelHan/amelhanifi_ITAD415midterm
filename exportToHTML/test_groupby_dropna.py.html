<html>
<head>
<title>test_groupby_dropna.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_groupby_dropna.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">pytest</span>

<span class="s0">from </span><span class="s1">pandas.compat.pyarrow </span><span class="s0">import </span><span class="s1">pa_version_under7p0</span>

<span class="s0">from </span><span class="s1">pandas.core.dtypes.missing </span><span class="s0">import </span><span class="s1">na_value_for_dtype</span>

<span class="s0">import </span><span class="s1">pandas </span><span class="s0">as </span><span class="s1">pd</span>
<span class="s0">import </span><span class="s1">pandas._testing </span><span class="s0">as </span><span class="s1">tm</span>
<span class="s0">from </span><span class="s1">pandas.tests.groupby </span><span class="s0">import </span><span class="s1">get_groupby_method_args</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;dropna, tuples, outputs&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span>
            <span class="s0">True,</span>
            <span class="s1">[[</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s1">]]</span><span class="s0">,</span>
            <span class="s1">{</span><span class="s2">&quot;c&quot;</span><span class="s1">: [</span><span class="s3">13.0</span><span class="s0">, </span><span class="s3">123.23</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s1">: [</span><span class="s3">13.0</span><span class="s0">, </span><span class="s3">123.0</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;e&quot;</span><span class="s1">: [</span><span class="s3">13.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">]}</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span>
            <span class="s0">False,</span>
            <span class="s1">[[</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s1">]]</span><span class="s0">,</span>
            <span class="s1">{</span>
                <span class="s2">&quot;c&quot;</span><span class="s1">: [</span><span class="s3">13.0</span><span class="s0">, </span><span class="s3">12.3</span><span class="s0">, </span><span class="s3">123.23</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;d&quot;</span><span class="s1">: [</span><span class="s3">13.0</span><span class="s0">, </span><span class="s3">233.0</span><span class="s0">, </span><span class="s3">123.0</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;e&quot;</span><span class="s1">: [</span><span class="s3">13.0</span><span class="s0">, </span><span class="s3">12.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_groupby_dropna_multi_index_dataframe_nan_in_one_group(</span>
    <span class="s1">dropna</span><span class="s0">, </span><span class="s1">tuples</span><span class="s0">, </span><span class="s1">outputs</span><span class="s0">, </span><span class="s1">nulls_fixture</span>
<span class="s1">):</span>
    <span class="s4"># GH 3729 this is to test that NA is in one group</span>
    <span class="s1">df_list = [</span>
        <span class="s1">[</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s3">12</span><span class="s0">, </span><span class="s3">12</span><span class="s0">, </span><span class="s3">12</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s1">nulls_fixture</span><span class="s0">, </span><span class="s3">12.3</span><span class="s0">, </span><span class="s3">233.0</span><span class="s0">, </span><span class="s3">12</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s3">123.23</span><span class="s0">, </span><span class="s3">123</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">]</span>
    <span class="s1">df = pd.DataFrame(df_list</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s0">, </span><span class="s2">&quot;e&quot;</span><span class="s1">])</span>
    <span class="s1">grouped = df.groupby([</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dropna=dropna).sum()</span>

    <span class="s1">mi = pd.MultiIndex.from_tuples(tuples</span><span class="s0">, </span><span class="s1">names=list(</span><span class="s2">&quot;ab&quot;</span><span class="s1">))</span>

    <span class="s4"># Since right now, by default MI will drop NA from levels when we create MI</span>
    <span class="s4"># via `from_*`, so we need to add NA for level manually afterwards.</span>
    <span class="s0">if not </span><span class="s1">dropna:</span>
        <span class="s1">mi = mi.set_levels([</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">level=</span><span class="s2">&quot;b&quot;</span><span class="s1">)</span>
    <span class="s1">expected = pd.DataFrame(outputs</span><span class="s0">, </span><span class="s1">index=mi)</span>

    <span class="s1">tm.assert_frame_equal(grouped</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;dropna, tuples, outputs&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span>
            <span class="s0">True,</span>
            <span class="s1">[[</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s1">]]</span><span class="s0">,</span>
            <span class="s1">{</span><span class="s2">&quot;c&quot;</span><span class="s1">: [</span><span class="s3">12.0</span><span class="s0">, </span><span class="s3">123.23</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s1">: [</span><span class="s3">12.0</span><span class="s0">, </span><span class="s3">123.0</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;e&quot;</span><span class="s1">: [</span><span class="s3">12.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">]}</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span>
            <span class="s0">False,</span>
            <span class="s1">[[</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[np.nan</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">]]</span><span class="s0">,</span>
            <span class="s1">{</span>
                <span class="s2">&quot;c&quot;</span><span class="s1">: [</span><span class="s3">12.0</span><span class="s0">, </span><span class="s3">13.3</span><span class="s0">, </span><span class="s3">123.23</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;d&quot;</span><span class="s1">: [</span><span class="s3">12.0</span><span class="s0">, </span><span class="s3">234.0</span><span class="s0">, </span><span class="s3">123.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;e&quot;</span><span class="s1">: [</span><span class="s3">12.0</span><span class="s0">, </span><span class="s3">13.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_groupby_dropna_multi_index_dataframe_nan_in_two_groups(</span>
    <span class="s1">dropna</span><span class="s0">, </span><span class="s1">tuples</span><span class="s0">, </span><span class="s1">outputs</span><span class="s0">, </span><span class="s1">nulls_fixture</span><span class="s0">, </span><span class="s1">nulls_fixture2</span>
<span class="s1">):</span>
    <span class="s4"># GH 3729 this is to test that NA in different groups with different representations</span>
    <span class="s1">df_list = [</span>
        <span class="s1">[</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s3">12</span><span class="s0">, </span><span class="s3">12</span><span class="s0">, </span><span class="s3">12</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s1">nulls_fixture</span><span class="s0">, </span><span class="s3">12.3</span><span class="s0">, </span><span class="s3">233.0</span><span class="s0">, </span><span class="s3">12</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s3">123.23</span><span class="s0">, </span><span class="s3">123</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[nulls_fixture2</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s1">nulls_fixture2</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">]</span>
    <span class="s1">df = pd.DataFrame(df_list</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s0">, </span><span class="s2">&quot;e&quot;</span><span class="s1">])</span>
    <span class="s1">grouped = df.groupby([</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dropna=dropna).sum()</span>

    <span class="s1">mi = pd.MultiIndex.from_tuples(tuples</span><span class="s0">, </span><span class="s1">names=list(</span><span class="s2">&quot;ab&quot;</span><span class="s1">))</span>

    <span class="s4"># Since right now, by default MI will drop NA from levels when we create MI</span>
    <span class="s4"># via `from_*`, so we need to add NA for level manually afterwards.</span>
    <span class="s0">if not </span><span class="s1">dropna:</span>
        <span class="s1">mi = mi.set_levels([[</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s1">np.nan]])</span>
    <span class="s1">expected = pd.DataFrame(outputs</span><span class="s0">, </span><span class="s1">index=mi)</span>

    <span class="s1">tm.assert_frame_equal(grouped</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;dropna, idx, outputs&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span><span class="s0">True, </span><span class="s1">[</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;b&quot;</span><span class="s1">: [</span><span class="s3">123.23</span><span class="s0">, </span><span class="s3">13.0</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">: [</span><span class="s3">123.0</span><span class="s0">, </span><span class="s3">13.0</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s1">: [</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">13.0</span><span class="s1">]})</span><span class="s0">,</span>
        <span class="s1">(</span>
            <span class="s0">False,</span>
            <span class="s1">[</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">,</span>
            <span class="s1">{</span>
                <span class="s2">&quot;b&quot;</span><span class="s1">: [</span><span class="s3">123.23</span><span class="s0">, </span><span class="s3">13.0</span><span class="s0">, </span><span class="s3">12.3</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;c&quot;</span><span class="s1">: [</span><span class="s3">123.0</span><span class="s0">, </span><span class="s3">13.0</span><span class="s0">, </span><span class="s3">233.0</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;d&quot;</span><span class="s1">: [</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">13.0</span><span class="s0">, </span><span class="s3">12.0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_groupby_dropna_normal_index_dataframe(dropna</span><span class="s0">, </span><span class="s1">idx</span><span class="s0">, </span><span class="s1">outputs):</span>
    <span class="s4"># GH 3729</span>
    <span class="s1">df_list = [</span>
        <span class="s1">[</span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s3">12</span><span class="s0">, </span><span class="s3">12</span><span class="s0">, </span><span class="s3">12</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s0">None, </span><span class="s3">12.3</span><span class="s0">, </span><span class="s3">233.0</span><span class="s0">, </span><span class="s3">12</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s3">123.23</span><span class="s0">, </span><span class="s3">123</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">]</span>
    <span class="s1">df = pd.DataFrame(df_list</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s1">])</span>
    <span class="s1">grouped = df.groupby(</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s1">dropna=dropna).sum()</span>

    <span class="s1">expected = pd.DataFrame(outputs</span><span class="s0">, </span><span class="s1">index=pd.Index(idx</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;object&quot;</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;a&quot;</span><span class="s1">))</span>

    <span class="s1">tm.assert_frame_equal(grouped</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;dropna, idx, expected&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span><span class="s0">True, </span><span class="s1">[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">pd.Series([</span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">]))</span><span class="s0">,</span>
        <span class="s1">(</span>
            <span class="s0">False,</span>
            <span class="s1">[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">,</span>
            <span class="s1">pd.Series([</span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s1">np.nan])</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_groupby_dropna_series_level(dropna</span><span class="s0">, </span><span class="s1">idx</span><span class="s0">, </span><span class="s1">expected):</span>
    <span class="s1">ser = pd.Series([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=idx)</span>

    <span class="s1">result = ser.groupby(level=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">dropna=dropna).sum()</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;dropna, expected&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span><span class="s0">True, </span><span class="s1">pd.Series([</span><span class="s3">210.0</span><span class="s0">, </span><span class="s3">350.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;Max Speed&quot;</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">(</span>
            <span class="s0">False,</span>
            <span class="s1">pd.Series([</span><span class="s3">210.0</span><span class="s0">, </span><span class="s3">350.0</span><span class="s0">, </span><span class="s3">20.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;Max Speed&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_groupby_dropna_series_by(dropna</span><span class="s0">, </span><span class="s1">expected):</span>
    <span class="s1">ser = pd.Series(</span>
        <span class="s1">[</span><span class="s3">390.0</span><span class="s0">, </span><span class="s3">350.0</span><span class="s0">, </span><span class="s3">30.0</span><span class="s0">, </span><span class="s3">20.0</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">index=[</span><span class="s2">&quot;Falcon&quot;</span><span class="s0">, </span><span class="s2">&quot;Falcon&quot;</span><span class="s0">, </span><span class="s2">&quot;Parrot&quot;</span><span class="s0">, </span><span class="s2">&quot;Parrot&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">name=</span><span class="s2">&quot;Max Speed&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s1">result = ser.groupby([</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">dropna=dropna).mean()</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;dropna&quot;</span><span class="s0">, </span><span class="s1">(</span><span class="s0">False, True</span><span class="s1">))</span>
<span class="s0">def </span><span class="s1">test_grouper_dropna_propagation(dropna):</span>
    <span class="s4"># GH 36604</span>
    <span class="s1">df = pd.DataFrame({</span><span class="s2">&quot;A&quot;</span><span class="s1">: [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, None</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, None</span><span class="s1">]})</span>
    <span class="s1">gb = df.groupby(</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s1">dropna=dropna)</span>
    <span class="s0">assert </span><span class="s1">gb.grouper.dropna == dropna</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;index&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">pd.RangeIndex(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">list(</span><span class="s2">&quot;abcd&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">pd.MultiIndex.from_product([(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;R&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">names=[</span><span class="s2">&quot;num&quot;</span><span class="s0">, </span><span class="s2">&quot;col&quot;</span><span class="s1">])</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_groupby_dataframe_slice_then_transform(dropna</span><span class="s0">, </span><span class="s1">index):</span>
    <span class="s4"># GH35014 &amp; GH35612</span>
    <span class="s1">expected_data = {</span><span class="s2">&quot;B&quot;</span><span class="s1">: [</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">np.nan </span><span class="s0">if </span><span class="s1">dropna </span><span class="s0">else </span><span class="s3">1</span><span class="s1">]}</span>

    <span class="s1">df = pd.DataFrame({</span><span class="s2">&quot;A&quot;</span><span class="s1">: [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, None</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, None</span><span class="s1">]}</span><span class="s0">, </span><span class="s1">index=index)</span>
    <span class="s1">gb = df.groupby(</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s1">dropna=dropna)</span>

    <span class="s1">result = gb.transform(len)</span>
    <span class="s1">expected = pd.DataFrame(expected_data</span><span class="s0">, </span><span class="s1">index=index)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">result = gb[[</span><span class="s2">&quot;B&quot;</span><span class="s1">]].transform(len)</span>
    <span class="s1">expected = pd.DataFrame(expected_data</span><span class="s0">, </span><span class="s1">index=index)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">result = gb[</span><span class="s2">&quot;B&quot;</span><span class="s1">].transform(len)</span>
    <span class="s1">expected = pd.Series(expected_data[</span><span class="s2">&quot;B&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=index</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;B&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;dropna, tuples, outputs&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span>
            <span class="s0">True,</span>
            <span class="s1">[[</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s1">]]</span><span class="s0">,</span>
            <span class="s1">{</span><span class="s2">&quot;c&quot;</span><span class="s1">: [</span><span class="s3">13.0</span><span class="s0">, </span><span class="s3">123.23</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s1">: [</span><span class="s3">12.0</span><span class="s0">, </span><span class="s3">123.0</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;e&quot;</span><span class="s1">: [</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">]}</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span>
            <span class="s0">False,</span>
            <span class="s1">[[</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s1">]]</span><span class="s0">,</span>
            <span class="s1">{</span>
                <span class="s2">&quot;c&quot;</span><span class="s1">: [</span><span class="s3">13.0</span><span class="s0">, </span><span class="s3">12.3</span><span class="s0">, </span><span class="s3">123.23</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;d&quot;</span><span class="s1">: [</span><span class="s3">12.0</span><span class="s0">, </span><span class="s3">233.0</span><span class="s0">, </span><span class="s3">123.0</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s2">&quot;e&quot;</span><span class="s1">: [</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">12.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_groupby_dropna_multi_index_dataframe_agg(dropna</span><span class="s0">, </span><span class="s1">tuples</span><span class="s0">, </span><span class="s1">outputs):</span>
    <span class="s4"># GH 3729</span>
    <span class="s1">df_list = [</span>
        <span class="s1">[</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s3">12</span><span class="s0">, </span><span class="s3">12</span><span class="s0">, </span><span class="s3">12</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">&quot;A&quot;</span><span class="s0">, None, </span><span class="s3">12.3</span><span class="s0">, </span><span class="s3">233.0</span><span class="s0">, </span><span class="s3">12</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s3">123.23</span><span class="s0">, </span><span class="s3">123</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">]</span>
    <span class="s1">df = pd.DataFrame(df_list</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s0">, </span><span class="s2">&quot;e&quot;</span><span class="s1">])</span>
    <span class="s1">agg_dict = {</span><span class="s2">&quot;c&quot;</span><span class="s1">: </span><span class="s2">&quot;sum&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s1">: </span><span class="s2">&quot;max&quot;</span><span class="s0">, </span><span class="s2">&quot;e&quot;</span><span class="s1">: </span><span class="s2">&quot;min&quot;</span><span class="s1">}</span>
    <span class="s1">grouped = df.groupby([</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dropna=dropna).agg(agg_dict)</span>

    <span class="s1">mi = pd.MultiIndex.from_tuples(tuples</span><span class="s0">, </span><span class="s1">names=list(</span><span class="s2">&quot;ab&quot;</span><span class="s1">))</span>

    <span class="s4"># Since right now, by default MI will drop NA from levels when we create MI</span>
    <span class="s4"># via `from_*`, so we need to add NA for level manually afterwards.</span>
    <span class="s0">if not </span><span class="s1">dropna:</span>
        <span class="s1">mi = mi.set_levels([</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">level=</span><span class="s2">&quot;b&quot;</span><span class="s1">)</span>
    <span class="s1">expected = pd.DataFrame(outputs</span><span class="s0">, </span><span class="s1">index=mi)</span>

    <span class="s1">tm.assert_frame_equal(grouped</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.arm_slow</span>
<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;datetime1, datetime2&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(pd.Timestamp(</span><span class="s2">&quot;2020-01-01&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pd.Timestamp(</span><span class="s2">&quot;2020-02-01&quot;</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">(pd.Timedelta(</span><span class="s2">&quot;-2 days&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pd.Timedelta(</span><span class="s2">&quot;-1 days&quot;</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">(pd.Period(</span><span class="s2">&quot;2020-01-01&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pd.Period(</span><span class="s2">&quot;2020-02-01&quot;</span><span class="s1">))</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;dropna, values&quot;</span><span class="s0">, </span><span class="s1">[(</span><span class="s0">True, </span><span class="s1">[</span><span class="s3">12</span><span class="s0">, </span><span class="s3">3</span><span class="s1">])</span><span class="s0">, </span><span class="s1">(</span><span class="s0">False, </span><span class="s1">[</span><span class="s3">12</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">6</span><span class="s1">])])</span>
<span class="s0">def </span><span class="s1">test_groupby_dropna_datetime_like_data(</span>
    <span class="s1">dropna</span><span class="s0">, </span><span class="s1">values</span><span class="s0">, </span><span class="s1">datetime1</span><span class="s0">, </span><span class="s1">datetime2</span><span class="s0">, </span><span class="s1">unique_nulls_fixture</span><span class="s0">, </span><span class="s1">unique_nulls_fixture2</span>
<span class="s1">):</span>
    <span class="s4"># 3729</span>
    <span class="s1">df = pd.DataFrame(</span>
        <span class="s1">{</span>
            <span class="s2">&quot;values&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s2">&quot;dt&quot;</span><span class="s1">: [</span>
                <span class="s1">datetime1</span><span class="s0">,</span>
                <span class="s1">unique_nulls_fixture</span><span class="s0">,</span>
                <span class="s1">datetime2</span><span class="s0">,</span>
                <span class="s1">unique_nulls_fixture2</span><span class="s0">,</span>
                <span class="s1">datetime1</span><span class="s0">,</span>
                <span class="s1">datetime1</span><span class="s0">,</span>
            <span class="s1">]</span><span class="s0">,</span>
        <span class="s1">}</span>
    <span class="s1">)</span>

    <span class="s0">if </span><span class="s1">dropna:</span>
        <span class="s1">indexes = [datetime1</span><span class="s0">, </span><span class="s1">datetime2]</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">indexes = [datetime1</span><span class="s0">, </span><span class="s1">datetime2</span><span class="s0">, </span><span class="s1">np.nan]</span>

    <span class="s1">grouped = df.groupby(</span><span class="s2">&quot;dt&quot;</span><span class="s0">, </span><span class="s1">dropna=dropna).agg({</span><span class="s2">&quot;values&quot;</span><span class="s1">: </span><span class="s2">&quot;sum&quot;</span><span class="s1">})</span>
    <span class="s1">expected = pd.DataFrame({</span><span class="s2">&quot;values&quot;</span><span class="s1">: values}</span><span class="s0">, </span><span class="s1">index=pd.Index(indexes</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;dt&quot;</span><span class="s1">))</span>

    <span class="s1">tm.assert_frame_equal(grouped</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;dropna, data, selected_data, levels&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">pytest.param(</span>
            <span class="s0">False,</span>
            <span class="s1">{</span><span class="s2">&quot;groups&quot;</span><span class="s1">: [</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s2">&quot;values&quot;</span><span class="s1">: [</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s3">20</span><span class="s0">, </span><span class="s3">30</span><span class="s1">]}</span><span class="s0">,</span>
            <span class="s1">{</span><span class="s2">&quot;values&quot;</span><span class="s1">: [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]}</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">,</span>
            <span class="s1">id=</span><span class="s2">&quot;dropna_false_has_nan&quot;</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">pytest.param(</span>
            <span class="s0">True,</span>
            <span class="s1">{</span><span class="s2">&quot;groups&quot;</span><span class="s1">: [</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s2">&quot;values&quot;</span><span class="s1">: [</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s3">20</span><span class="s0">, </span><span class="s3">30</span><span class="s1">]}</span><span class="s0">,</span>
            <span class="s1">{</span><span class="s2">&quot;values&quot;</span><span class="s1">: [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]}</span><span class="s0">,</span>
            <span class="s0">None,</span>
            <span class="s1">id=</span><span class="s2">&quot;dropna_true_has_nan&quot;</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">pytest.param(</span>
            <span class="s4"># no nan in &quot;groups&quot;; dropna=True|False should be same.</span>
            <span class="s0">False,</span>
            <span class="s1">{</span><span class="s2">&quot;groups&quot;</span><span class="s1">: [</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;values&quot;</span><span class="s1">: [</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s3">20</span><span class="s0">, </span><span class="s3">30</span><span class="s1">]}</span><span class="s0">,</span>
            <span class="s1">{</span><span class="s2">&quot;values&quot;</span><span class="s1">: [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]}</span><span class="s0">,</span>
            <span class="s0">None,</span>
            <span class="s1">id=</span><span class="s2">&quot;dropna_false_no_nan&quot;</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">pytest.param(</span>
            <span class="s4"># no nan in &quot;groups&quot;; dropna=True|False should be same.</span>
            <span class="s0">True,</span>
            <span class="s1">{</span><span class="s2">&quot;groups&quot;</span><span class="s1">: [</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;values&quot;</span><span class="s1">: [</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s3">20</span><span class="s0">, </span><span class="s3">30</span><span class="s1">]}</span><span class="s0">,</span>
            <span class="s1">{</span><span class="s2">&quot;values&quot;</span><span class="s1">: [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]}</span><span class="s0">,</span>
            <span class="s0">None,</span>
            <span class="s1">id=</span><span class="s2">&quot;dropna_true_no_nan&quot;</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_groupby_apply_with_dropna_for_multi_index(dropna</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">selected_data</span><span class="s0">, </span><span class="s1">levels):</span>
    <span class="s4"># GH 35889</span>

    <span class="s1">df = pd.DataFrame(data)</span>
    <span class="s1">gb = df.groupby(</span><span class="s2">&quot;groups&quot;</span><span class="s0">, </span><span class="s1">dropna=dropna)</span>
    <span class="s1">result = gb.apply(</span><span class="s0">lambda </span><span class="s1">grp: pd.DataFrame({</span><span class="s2">&quot;values&quot;</span><span class="s1">: range(len(grp))}))</span>

    <span class="s1">mi_tuples = tuple(zip(data[</span><span class="s2">&quot;groups&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">selected_data[</span><span class="s2">&quot;values&quot;</span><span class="s1">]))</span>
    <span class="s1">mi = pd.MultiIndex.from_tuples(mi_tuples</span><span class="s0">, </span><span class="s1">names=[</span><span class="s2">&quot;groups&quot;</span><span class="s0">, None</span><span class="s1">])</span>
    <span class="s4"># Since right now, by default MI will drop NA from levels when we create MI</span>
    <span class="s4"># via `from_*`, so we need to add NA for level manually afterwards.</span>
    <span class="s0">if not </span><span class="s1">dropna </span><span class="s0">and </span><span class="s1">levels:</span>
        <span class="s1">mi = mi.set_levels(levels</span><span class="s0">, </span><span class="s1">level=</span><span class="s2">&quot;groups&quot;</span><span class="s1">)</span>

    <span class="s1">expected = pd.DataFrame(selected_data</span><span class="s0">, </span><span class="s1">index=mi)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;input_index&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">None, </span><span class="s1">[</span><span class="s2">&quot;a&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">]])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;keys&quot;</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">&quot;a&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">]])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;series&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_groupby_dropna_with_multiindex_input(input_index</span><span class="s0">, </span><span class="s1">keys</span><span class="s0">, </span><span class="s1">series):</span>
    <span class="s4"># GH#46783</span>
    <span class="s1">obj = pd.DataFrame(</span>
        <span class="s1">{</span>
            <span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">,</span>
            <span class="s2">&quot;b&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s2">&quot;c&quot;</span><span class="s1">: [</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">}</span>
    <span class="s1">)</span>

    <span class="s1">expected = obj.set_index(keys)</span>
    <span class="s0">if </span><span class="s1">series:</span>
        <span class="s1">expected = expected[</span><span class="s2">&quot;c&quot;</span><span class="s1">]</span>
    <span class="s0">elif </span><span class="s1">input_index == [</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">] </span><span class="s0">and </span><span class="s1">keys == [</span><span class="s2">&quot;a&quot;</span><span class="s1">]:</span>
        <span class="s4"># Column b should not be aggregated</span>
        <span class="s1">expected = expected[[</span><span class="s2">&quot;c&quot;</span><span class="s1">]]</span>

    <span class="s0">if </span><span class="s1">input_index </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">obj = obj.set_index(input_index)</span>
    <span class="s1">gb = obj.groupby(keys</span><span class="s0">, </span><span class="s1">dropna=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">series:</span>
        <span class="s1">gb = gb[</span><span class="s2">&quot;c&quot;</span><span class="s1">]</span>
    <span class="s1">result = gb.sum()</span>

    <span class="s1">tm.assert_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_groupby_nan_included():</span>
    <span class="s4"># GH 35646</span>
    <span class="s1">data = {</span><span class="s2">&quot;group&quot;</span><span class="s1">: [</span><span class="s2">&quot;g1&quot;</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s2">&quot;g1&quot;</span><span class="s0">, </span><span class="s2">&quot;g2&quot;</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">: [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">]}</span>
    <span class="s1">df = pd.DataFrame(data)</span>
    <span class="s1">grouped = df.groupby(</span><span class="s2">&quot;group&quot;</span><span class="s0">, </span><span class="s1">dropna=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">result = grouped.indices</span>
    <span class="s1">dtype = np.intp</span>
    <span class="s1">expected = {</span>
        <span class="s2">&quot;g1&quot;</span><span class="s1">: np.array([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=dtype)</span><span class="s0">,</span>
        <span class="s2">&quot;g2&quot;</span><span class="s1">: np.array([</span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=dtype)</span><span class="s0">,</span>
        <span class="s1">np.nan: np.array([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=dtype)</span><span class="s0">,</span>
    <span class="s1">}</span>
    <span class="s0">for </span><span class="s1">result_values</span><span class="s0">, </span><span class="s1">expected_values </span><span class="s0">in </span><span class="s1">zip(result.values()</span><span class="s0">, </span><span class="s1">expected.values()):</span>
        <span class="s1">tm.assert_numpy_array_equal(result_values</span><span class="s0">, </span><span class="s1">expected_values)</span>
    <span class="s0">assert </span><span class="s1">np.isnan(list(result.keys())[</span><span class="s3">2</span><span class="s1">])</span>
    <span class="s0">assert </span><span class="s1">list(result.keys())[</span><span class="s3">0</span><span class="s1">:</span><span class="s3">2</span><span class="s1">] == [</span><span class="s2">&quot;g1&quot;</span><span class="s0">, </span><span class="s2">&quot;g2&quot;</span><span class="s1">]</span>


<span class="s0">def </span><span class="s1">test_groupby_drop_nan_with_multi_index():</span>
    <span class="s4"># GH 39895</span>
    <span class="s1">df = pd.DataFrame([[np.nan</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">])</span>
    <span class="s1">df = df.set_index([</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">])</span>
    <span class="s1">result = df.groupby([</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dropna=</span><span class="s0">False</span><span class="s1">).first()</span>
    <span class="s1">expected = df</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s4"># sequence_index enumerates all strings made up of x, y, z of length 4</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;sequence_index&quot;</span><span class="s0">, </span><span class="s1">range(</span><span class="s3">3</span><span class="s1">**</span><span class="s3">4</span><span class="s1">))</span>
<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;dtype&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s0">None,</span>
        <span class="s2">&quot;UInt8&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;Int8&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;UInt16&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;Int16&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;UInt32&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;Int32&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;UInt64&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;Int64&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;Float32&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;Int64&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;Float64&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;category&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;string&quot;</span><span class="s0">,</span>
        <span class="s1">pytest.param(</span>
            <span class="s2">&quot;string[pyarrow]&quot;</span><span class="s0">,</span>
            <span class="s1">marks=pytest.mark.skipif(</span>
                <span class="s1">pa_version_under7p0</span><span class="s0">, </span><span class="s1">reason=</span><span class="s2">&quot;pyarrow is not installed&quot;</span>
            <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s2">&quot;datetime64[ns]&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;period[d]&quot;</span><span class="s0">,</span>
        <span class="s2">&quot;Sparse[float]&quot;</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;test_series&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_no_sort_keep_na(sequence_index</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">test_series</span><span class="s0">, </span><span class="s1">as_index):</span>
    <span class="s4"># GH#46584, GH#48794</span>

    <span class="s4"># Convert sequence_index into a string sequence, e.g. 5 becomes &quot;xxyz&quot;</span>
    <span class="s4"># This sequence is used for the grouper.</span>
    <span class="s1">sequence = </span><span class="s2">&quot;&quot;</span><span class="s1">.join(</span>
        <span class="s1">[{</span><span class="s3">0</span><span class="s1">: </span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s1">: </span><span class="s2">&quot;y&quot;</span><span class="s0">, </span><span class="s3">2</span><span class="s1">: </span><span class="s2">&quot;z&quot;</span><span class="s1">}[sequence_index // (</span><span class="s3">3</span><span class="s1">**k) % </span><span class="s3">3</span><span class="s1">] </span><span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">4</span><span class="s1">)]</span>
    <span class="s1">)</span>

    <span class="s4"># Unique values to use for grouper, depends on dtype</span>
    <span class="s0">if </span><span class="s1">dtype </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;string&quot;</span><span class="s0">, </span><span class="s2">&quot;string[pyarrow]&quot;</span><span class="s1">):</span>
        <span class="s1">uniques = {</span><span class="s2">&quot;x&quot;</span><span class="s1">: </span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: </span><span class="s2">&quot;y&quot;</span><span class="s0">, </span><span class="s2">&quot;z&quot;</span><span class="s1">: pd.NA}</span>
    <span class="s0">elif </span><span class="s1">dtype </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;datetime64[ns]&quot;</span><span class="s0">, </span><span class="s2">&quot;period[d]&quot;</span><span class="s1">):</span>
        <span class="s1">uniques = {</span><span class="s2">&quot;x&quot;</span><span class="s1">: </span><span class="s2">&quot;2016-01-01&quot;</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: </span><span class="s2">&quot;2017-01-01&quot;</span><span class="s0">, </span><span class="s2">&quot;z&quot;</span><span class="s1">: pd.NA}</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">uniques = {</span><span class="s2">&quot;x&quot;</span><span class="s1">: </span><span class="s3">1</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: </span><span class="s3">2</span><span class="s0">, </span><span class="s2">&quot;z&quot;</span><span class="s1">: np.nan}</span>

    <span class="s1">df = pd.DataFrame(</span>
        <span class="s1">{</span>
            <span class="s2">&quot;key&quot;</span><span class="s1">: pd.Series([uniques[label] </span><span class="s0">for </span><span class="s1">label </span><span class="s0">in </span><span class="s1">sequence]</span><span class="s0">, </span><span class="s1">dtype=dtype)</span><span class="s0">,</span>
            <span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">}</span>
    <span class="s1">)</span>
    <span class="s1">gb = df.groupby(</span><span class="s2">&quot;key&quot;</span><span class="s0">, </span><span class="s1">dropna=</span><span class="s0">False, </span><span class="s1">sort=</span><span class="s0">False, </span><span class="s1">as_index=as_index</span><span class="s0">, </span><span class="s1">observed=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">test_series:</span>
        <span class="s1">gb = gb[</span><span class="s2">&quot;a&quot;</span><span class="s1">]</span>
    <span class="s1">result = gb.sum()</span>

    <span class="s4"># Manually compute the groupby sum, use the labels &quot;x&quot;, &quot;y&quot;, and &quot;z&quot; to avoid</span>
    <span class="s4"># issues with hashing np.nan</span>
    <span class="s1">summed = {}</span>
    <span class="s0">for </span><span class="s1">idx</span><span class="s0">, </span><span class="s1">label </span><span class="s0">in </span><span class="s1">enumerate(sequence):</span>
        <span class="s1">summed[label] = summed.get(label</span><span class="s0">, </span><span class="s3">0</span><span class="s1">) + idx</span>
    <span class="s0">if </span><span class="s1">dtype == </span><span class="s2">&quot;category&quot;</span><span class="s1">:</span>
        <span class="s1">index = pd.CategoricalIndex(</span>
            <span class="s1">[uniques[e] </span><span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">summed]</span><span class="s0">,</span>
            <span class="s1">df[</span><span class="s2">&quot;key&quot;</span><span class="s1">].cat.categories</span><span class="s0">,</span>
            <span class="s1">name=</span><span class="s2">&quot;key&quot;</span><span class="s0">,</span>
        <span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">isinstance(dtype</span><span class="s0">, </span><span class="s1">str) </span><span class="s0">and </span><span class="s1">dtype.startswith(</span><span class="s2">&quot;Sparse&quot;</span><span class="s1">):</span>
        <span class="s1">index = pd.Index(</span>
            <span class="s1">pd.array([uniques[label] </span><span class="s0">for </span><span class="s1">label </span><span class="s0">in </span><span class="s1">summed]</span><span class="s0">, </span><span class="s1">dtype=dtype)</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;key&quot;</span>
        <span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">index = pd.Index([uniques[label] </span><span class="s0">for </span><span class="s1">label </span><span class="s0">in </span><span class="s1">summed]</span><span class="s0">, </span><span class="s1">dtype=dtype</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;key&quot;</span><span class="s1">)</span>
    <span class="s1">expected = pd.Series(summed.values()</span><span class="s0">, </span><span class="s1">index=index</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s0">None</span><span class="s1">)</span>
    <span class="s0">if not </span><span class="s1">test_series:</span>
        <span class="s1">expected = expected.to_frame()</span>
    <span class="s0">if not </span><span class="s1">as_index:</span>
        <span class="s1">expected = expected.reset_index()</span>
        <span class="s0">if </span><span class="s1">dtype </span><span class="s0">is not None and </span><span class="s1">dtype.startswith(</span><span class="s2">&quot;Sparse&quot;</span><span class="s1">):</span>
            <span class="s1">expected[</span><span class="s2">&quot;key&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;key&quot;</span><span class="s1">].astype(dtype)</span>

    <span class="s1">tm.assert_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;test_series&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">[object</span><span class="s0">, None</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_null_is_null_for_dtype(</span>
    <span class="s1">sort</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">nulls_fixture</span><span class="s0">, </span><span class="s1">nulls_fixture2</span><span class="s0">, </span><span class="s1">test_series</span>
<span class="s1">):</span>
    <span class="s4"># GH#48506 - groups should always result in using the null for the dtype</span>
    <span class="s1">df = pd.DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]})</span>
    <span class="s1">groups = pd.Series([nulls_fixture</span><span class="s0">, </span><span class="s1">nulls_fixture2]</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">obj = df[</span><span class="s2">&quot;a&quot;</span><span class="s1">] </span><span class="s0">if </span><span class="s1">test_series </span><span class="s0">else </span><span class="s1">df</span>
    <span class="s1">gb = obj.groupby(groups</span><span class="s0">, </span><span class="s1">dropna=</span><span class="s0">False, </span><span class="s1">sort=sort)</span>
    <span class="s1">result = gb.sum()</span>
    <span class="s1">index = pd.Index([na_value_for_dtype(groups.dtype)])</span>
    <span class="s1">expected = pd.DataFrame({</span><span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s3">3</span><span class="s1">]}</span><span class="s0">, </span><span class="s1">index=index)</span>
    <span class="s0">if </span><span class="s1">test_series:</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected[</span><span class="s2">&quot;a&quot;</span><span class="s1">])</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;index_kind&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;range&quot;</span><span class="s0">, </span><span class="s2">&quot;single&quot;</span><span class="s0">, </span><span class="s2">&quot;multi&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_categorical_reducers(</span>
    <span class="s1">request</span><span class="s0">, </span><span class="s1">reduction_func</span><span class="s0">, </span><span class="s1">observed</span><span class="s0">, </span><span class="s1">sort</span><span class="s0">, </span><span class="s1">as_index</span><span class="s0">, </span><span class="s1">index_kind</span>
<span class="s1">):</span>
    <span class="s4"># GH#36327</span>
    <span class="s0">if </span><span class="s1">(</span>
        <span class="s1">reduction_func </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;idxmin&quot;</span><span class="s0">, </span><span class="s2">&quot;idxmax&quot;</span><span class="s1">)</span>
        <span class="s0">and not </span><span class="s1">observed</span>
        <span class="s0">and </span><span class="s1">index_kind != </span><span class="s2">&quot;multi&quot;</span>
    <span class="s1">):</span>
        <span class="s1">msg = </span><span class="s2">&quot;GH#10694 - idxmin/max broken for categorical with observed=False&quot;</span>
        <span class="s1">request.node.add_marker(pytest.mark.xfail(reason=msg))</span>

    <span class="s4"># Ensure there is at least one null value by appending to the end</span>
    <span class="s1">values = np.append(np.random.default_rng(</span><span class="s3">2</span><span class="s1">).choice([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, None</span><span class="s1">]</span><span class="s0">, </span><span class="s1">size=</span><span class="s3">19</span><span class="s1">)</span><span class="s0">, None</span><span class="s1">)</span>
    <span class="s1">df = pd.DataFrame(</span>
        <span class="s1">{</span><span class="s2">&quot;x&quot;</span><span class="s1">: pd.Categorical(values</span><span class="s0">, </span><span class="s1">categories=[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">])</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: range(</span><span class="s3">20</span><span class="s1">)}</span>
    <span class="s1">)</span>

    <span class="s4"># Strategy: Compare to dropna=True by filling null values with a new code</span>
    <span class="s1">df_filled = df.copy()</span>
    <span class="s1">df_filled[</span><span class="s2">&quot;x&quot;</span><span class="s1">] = pd.Categorical(values</span><span class="s0">, </span><span class="s1">categories=[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">]).fillna(</span><span class="s3">4</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">index_kind == </span><span class="s2">&quot;range&quot;</span><span class="s1">:</span>
        <span class="s1">keys = [</span><span class="s2">&quot;x&quot;</span><span class="s1">]</span>
    <span class="s0">elif </span><span class="s1">index_kind == </span><span class="s2">&quot;single&quot;</span><span class="s1">:</span>
        <span class="s1">keys = [</span><span class="s2">&quot;x&quot;</span><span class="s1">]</span>
        <span class="s1">df = df.set_index(</span><span class="s2">&quot;x&quot;</span><span class="s1">)</span>
        <span class="s1">df_filled = df_filled.set_index(</span><span class="s2">&quot;x&quot;</span><span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">keys = [</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s2">&quot;x2&quot;</span><span class="s1">]</span>
        <span class="s1">df[</span><span class="s2">&quot;x2&quot;</span><span class="s1">] = df[</span><span class="s2">&quot;x&quot;</span><span class="s1">]</span>
        <span class="s1">df = df.set_index([</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s2">&quot;x2&quot;</span><span class="s1">])</span>
        <span class="s1">df_filled[</span><span class="s2">&quot;x2&quot;</span><span class="s1">] = df_filled[</span><span class="s2">&quot;x&quot;</span><span class="s1">]</span>
        <span class="s1">df_filled = df_filled.set_index([</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s2">&quot;x2&quot;</span><span class="s1">])</span>
    <span class="s1">args = get_groupby_method_args(reduction_func</span><span class="s0">, </span><span class="s1">df)</span>
    <span class="s1">args_filled = get_groupby_method_args(reduction_func</span><span class="s0">, </span><span class="s1">df_filled)</span>
    <span class="s0">if </span><span class="s1">reduction_func == </span><span class="s2">&quot;corrwith&quot; </span><span class="s0">and </span><span class="s1">index_kind == </span><span class="s2">&quot;range&quot;</span><span class="s1">:</span>
        <span class="s4"># Don't include the grouping columns so we can call reset_index</span>
        <span class="s1">args = (args[</span><span class="s3">0</span><span class="s1">].drop(columns=keys)</span><span class="s0">,</span><span class="s1">)</span>
        <span class="s1">args_filled = (args_filled[</span><span class="s3">0</span><span class="s1">].drop(columns=keys)</span><span class="s0">,</span><span class="s1">)</span>

    <span class="s1">gb_filled = df_filled.groupby(keys</span><span class="s0">, </span><span class="s1">observed=observed</span><span class="s0">, </span><span class="s1">sort=sort</span><span class="s0">, </span><span class="s1">as_index=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">expected = getattr(gb_filled</span><span class="s0">, </span><span class="s1">reduction_func)(*args_filled).reset_index()</span>
    <span class="s1">expected[</span><span class="s2">&quot;x&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;x&quot;</span><span class="s1">].replace(</span><span class="s3">4</span><span class="s0">, None</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">index_kind == </span><span class="s2">&quot;multi&quot;</span><span class="s1">:</span>
        <span class="s1">expected[</span><span class="s2">&quot;x2&quot;</span><span class="s1">] = expected[</span><span class="s2">&quot;x2&quot;</span><span class="s1">].replace(</span><span class="s3">4</span><span class="s0">, None</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">as_index:</span>
        <span class="s0">if </span><span class="s1">index_kind == </span><span class="s2">&quot;multi&quot;</span><span class="s1">:</span>
            <span class="s1">expected = expected.set_index([</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s2">&quot;x2&quot;</span><span class="s1">])</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">expected = expected.set_index(</span><span class="s2">&quot;x&quot;</span><span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">index_kind != </span><span class="s2">&quot;range&quot; </span><span class="s0">and </span><span class="s1">reduction_func != </span><span class="s2">&quot;size&quot;</span><span class="s1">:</span>
        <span class="s4"># size, unlike other methods, has the desired behavior in GH#49519</span>
        <span class="s1">expected = expected.drop(columns=</span><span class="s2">&quot;x&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">index_kind == </span><span class="s2">&quot;multi&quot;</span><span class="s1">:</span>
            <span class="s1">expected = expected.drop(columns=</span><span class="s2">&quot;x2&quot;</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">reduction_func </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;idxmax&quot;</span><span class="s0">, </span><span class="s2">&quot;idxmin&quot;</span><span class="s1">) </span><span class="s0">and </span><span class="s1">index_kind != </span><span class="s2">&quot;range&quot;</span><span class="s1">:</span>
        <span class="s4"># expected was computed with a RangeIndex; need to translate to index values</span>
        <span class="s1">values = expected[</span><span class="s2">&quot;y&quot;</span><span class="s1">].values.tolist()</span>
        <span class="s0">if </span><span class="s1">index_kind == </span><span class="s2">&quot;single&quot;</span><span class="s1">:</span>
            <span class="s1">values = [np.nan </span><span class="s0">if </span><span class="s1">e == </span><span class="s3">4 </span><span class="s0">else </span><span class="s1">e </span><span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">values]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">values = [(np.nan</span><span class="s0">, </span><span class="s1">np.nan) </span><span class="s0">if </span><span class="s1">e == (</span><span class="s3">4</span><span class="s0">, </span><span class="s3">4</span><span class="s1">) </span><span class="s0">else </span><span class="s1">e </span><span class="s0">for </span><span class="s1">e </span><span class="s0">in </span><span class="s1">values]</span>
        <span class="s1">expected[</span><span class="s2">&quot;y&quot;</span><span class="s1">] = values</span>
    <span class="s0">if </span><span class="s1">reduction_func == </span><span class="s2">&quot;size&quot;</span><span class="s1">:</span>
        <span class="s4"># size, unlike other methods, has the desired behavior in GH#49519</span>
        <span class="s1">expected = expected.rename(columns={</span><span class="s3">0</span><span class="s1">: </span><span class="s2">&quot;size&quot;</span><span class="s1">})</span>
        <span class="s0">if </span><span class="s1">as_index:</span>
            <span class="s1">expected = expected[</span><span class="s2">&quot;size&quot;</span><span class="s1">].rename(</span><span class="s0">None</span><span class="s1">)</span>

    <span class="s1">gb_keepna = df.groupby(</span>
        <span class="s1">keys</span><span class="s0">, </span><span class="s1">dropna=</span><span class="s0">False, </span><span class="s1">observed=observed</span><span class="s0">, </span><span class="s1">sort=sort</span><span class="s0">, </span><span class="s1">as_index=as_index</span>
    <span class="s1">)</span>
    <span class="s0">if </span><span class="s1">as_index </span><span class="s0">or </span><span class="s1">index_kind == </span><span class="s2">&quot;range&quot; </span><span class="s0">or </span><span class="s1">reduction_func == </span><span class="s2">&quot;size&quot;</span><span class="s1">:</span>
        <span class="s1">warn = </span><span class="s0">None</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">warn = FutureWarning</span>
    <span class="s1">msg = </span><span class="s2">&quot;A grouping .* was excluded from the result&quot;</span>
    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(warn</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">result = getattr(gb_keepna</span><span class="s0">, </span><span class="s1">reduction_func)(*args)</span>

    <span class="s4"># size will return a Series, others are DataFrame</span>
    <span class="s1">tm.assert_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_categorical_transformers(</span>
    <span class="s1">request</span><span class="s0">, </span><span class="s1">transformation_func</span><span class="s0">, </span><span class="s1">observed</span><span class="s0">, </span><span class="s1">sort</span><span class="s0">, </span><span class="s1">as_index</span>
<span class="s1">):</span>
    <span class="s4"># GH#36327</span>
    <span class="s0">if </span><span class="s1">transformation_func == </span><span class="s2">&quot;fillna&quot;</span><span class="s1">:</span>
        <span class="s1">msg = </span><span class="s2">&quot;GH#49651 fillna may incorrectly reorders results when dropna=False&quot;</span>
        <span class="s1">request.node.add_marker(pytest.mark.xfail(reason=msg</span><span class="s0">, </span><span class="s1">strict=</span><span class="s0">False</span><span class="s1">))</span>

    <span class="s1">values = np.append(np.random.default_rng(</span><span class="s3">2</span><span class="s1">).choice([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, None</span><span class="s1">]</span><span class="s0">, </span><span class="s1">size=</span><span class="s3">19</span><span class="s1">)</span><span class="s0">, None</span><span class="s1">)</span>
    <span class="s1">df = pd.DataFrame(</span>
        <span class="s1">{</span><span class="s2">&quot;x&quot;</span><span class="s1">: pd.Categorical(values</span><span class="s0">, </span><span class="s1">categories=[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">])</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: range(</span><span class="s3">20</span><span class="s1">)}</span>
    <span class="s1">)</span>
    <span class="s1">args = get_groupby_method_args(transformation_func</span><span class="s0">, </span><span class="s1">df)</span>

    <span class="s4"># Compute result for null group</span>
    <span class="s1">null_group_values = df[df[</span><span class="s2">&quot;x&quot;</span><span class="s1">].isnull()][</span><span class="s2">&quot;y&quot;</span><span class="s1">]</span>
    <span class="s0">if </span><span class="s1">transformation_func == </span><span class="s2">&quot;cumcount&quot;</span><span class="s1">:</span>
        <span class="s1">null_group_data = list(range(len(null_group_values)))</span>
    <span class="s0">elif </span><span class="s1">transformation_func == </span><span class="s2">&quot;ngroup&quot;</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">sort:</span>
            <span class="s0">if </span><span class="s1">observed:</span>
                <span class="s1">na_group = df[</span><span class="s2">&quot;x&quot;</span><span class="s1">].nunique(dropna=</span><span class="s0">False</span><span class="s1">) - </span><span class="s3">1</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s4"># TODO: Should this be 3?</span>
                <span class="s1">na_group = df[</span><span class="s2">&quot;x&quot;</span><span class="s1">].nunique(dropna=</span><span class="s0">False</span><span class="s1">) - </span><span class="s3">1</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">na_group = df.iloc[: null_group_values.index[</span><span class="s3">0</span><span class="s1">]][</span><span class="s2">&quot;x&quot;</span><span class="s1">].nunique()</span>
        <span class="s1">null_group_data = len(null_group_values) * [na_group]</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">null_group_data = getattr(null_group_values</span><span class="s0">, </span><span class="s1">transformation_func)(*args)</span>
    <span class="s1">null_group_result = pd.DataFrame({</span><span class="s2">&quot;y&quot;</span><span class="s1">: null_group_data})</span>

    <span class="s1">gb_keepna = df.groupby(</span>
        <span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">dropna=</span><span class="s0">False, </span><span class="s1">observed=observed</span><span class="s0">, </span><span class="s1">sort=sort</span><span class="s0">, </span><span class="s1">as_index=as_index</span>
    <span class="s1">)</span>
    <span class="s1">gb_dropna = df.groupby(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">dropna=</span><span class="s0">True, </span><span class="s1">observed=observed</span><span class="s0">, </span><span class="s1">sort=sort)</span>

    <span class="s1">msg = </span><span class="s2">&quot;The default fill_method='ffill' in DataFrameGroupBy.pct_change is deprecated&quot;</span>
    <span class="s0">if </span><span class="s1">transformation_func == </span><span class="s2">&quot;pct_change&quot;</span><span class="s1">:</span>
        <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">result = getattr(gb_keepna</span><span class="s0">, </span><span class="s2">&quot;pct_change&quot;</span><span class="s1">)(*args)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">result = getattr(gb_keepna</span><span class="s0">, </span><span class="s1">transformation_func)(*args)</span>
    <span class="s1">expected = getattr(gb_dropna</span><span class="s0">, </span><span class="s1">transformation_func)(*args)</span>

    <span class="s0">for </span><span class="s1">iloc</span><span class="s0">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">zip(</span>
        <span class="s1">df[df[</span><span class="s2">&quot;x&quot;</span><span class="s1">].isnull()].index.tolist()</span><span class="s0">, </span><span class="s1">null_group_result.values.ravel()</span>
    <span class="s1">):</span>
        <span class="s0">if </span><span class="s1">expected.ndim == </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s1">expected.iloc[iloc] = value</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">expected.iloc[iloc</span><span class="s0">, </span><span class="s3">0</span><span class="s1">] = value</span>
    <span class="s0">if </span><span class="s1">transformation_func == </span><span class="s2">&quot;ngroup&quot;</span><span class="s1">:</span>
        <span class="s1">expected[df[</span><span class="s2">&quot;x&quot;</span><span class="s1">].notnull() &amp; expected.ge(na_group)] += </span><span class="s3">1</span>
    <span class="s0">if </span><span class="s1">transformation_func </span><span class="s0">not in </span><span class="s1">(</span><span class="s2">&quot;rank&quot;</span><span class="s0">, </span><span class="s2">&quot;diff&quot;</span><span class="s0">, </span><span class="s2">&quot;pct_change&quot;</span><span class="s0">, </span><span class="s2">&quot;shift&quot;</span><span class="s1">):</span>
        <span class="s1">expected = expected.astype(</span><span class="s2">&quot;int64&quot;</span><span class="s1">)</span>

    <span class="s1">tm.assert_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;method&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;head&quot;</span><span class="s0">, </span><span class="s2">&quot;tail&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_categorical_head_tail(method</span><span class="s0">, </span><span class="s1">observed</span><span class="s0">, </span><span class="s1">sort</span><span class="s0">, </span><span class="s1">as_index):</span>
    <span class="s4"># GH#36327</span>
    <span class="s1">values = np.random.default_rng(</span><span class="s3">2</span><span class="s1">).choice([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, None</span><span class="s1">]</span><span class="s0">, </span><span class="s3">30</span><span class="s1">)</span>
    <span class="s1">df = pd.DataFrame(</span>
        <span class="s1">{</span><span class="s2">&quot;x&quot;</span><span class="s1">: pd.Categorical(values</span><span class="s0">, </span><span class="s1">categories=[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">])</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: range(len(values))}</span>
    <span class="s1">)</span>
    <span class="s1">gb = df.groupby(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">dropna=</span><span class="s0">False, </span><span class="s1">observed=observed</span><span class="s0">, </span><span class="s1">sort=sort</span><span class="s0">, </span><span class="s1">as_index=as_index)</span>
    <span class="s1">result = getattr(gb</span><span class="s0">, </span><span class="s1">method)()</span>

    <span class="s0">if </span><span class="s1">method == </span><span class="s2">&quot;tail&quot;</span><span class="s1">:</span>
        <span class="s1">values = values[::-</span><span class="s3">1</span><span class="s1">]</span>
    <span class="s4"># Take the top 5 values from each group</span>
    <span class="s1">mask = (</span>
        <span class="s1">((values == </span><span class="s3">1</span><span class="s1">) &amp; ((values == </span><span class="s3">1</span><span class="s1">).cumsum() &lt;= </span><span class="s3">5</span><span class="s1">))</span>
        <span class="s1">| ((values == </span><span class="s3">2</span><span class="s1">) &amp; ((values == </span><span class="s3">2</span><span class="s1">).cumsum() &lt;= </span><span class="s3">5</span><span class="s1">))</span>
        <span class="s4"># flake8 doesn't like the vectorized check for None, thinks we should use `is`</span>
        <span class="s1">| ((values == </span><span class="s0">None</span><span class="s1">) &amp; ((values == </span><span class="s0">None</span><span class="s1">).cumsum() &lt;= </span><span class="s3">5</span><span class="s1">))  </span><span class="s4"># noqa: E711</span>
    <span class="s1">)</span>
    <span class="s0">if </span><span class="s1">method == </span><span class="s2">&quot;tail&quot;</span><span class="s1">:</span>
        <span class="s1">mask = mask[::-</span><span class="s3">1</span><span class="s1">]</span>
    <span class="s1">expected = df[mask]</span>

    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_categorical_agg():</span>
    <span class="s4"># GH#36327</span>
    <span class="s1">values = np.random.default_rng(</span><span class="s3">2</span><span class="s1">).choice([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, None</span><span class="s1">]</span><span class="s0">, </span><span class="s3">30</span><span class="s1">)</span>
    <span class="s1">df = pd.DataFrame(</span>
        <span class="s1">{</span><span class="s2">&quot;x&quot;</span><span class="s1">: pd.Categorical(values</span><span class="s0">, </span><span class="s1">categories=[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">])</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: range(len(values))}</span>
    <span class="s1">)</span>
    <span class="s1">gb = df.groupby(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">dropna=</span><span class="s0">False, </span><span class="s1">observed=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">result = gb.agg(</span><span class="s0">lambda </span><span class="s1">x: x.sum())</span>
    <span class="s1">expected = gb.sum()</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_categorical_transform():</span>
    <span class="s4"># GH#36327</span>
    <span class="s1">values = np.random.default_rng(</span><span class="s3">2</span><span class="s1">).choice([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, None</span><span class="s1">]</span><span class="s0">, </span><span class="s3">30</span><span class="s1">)</span>
    <span class="s1">df = pd.DataFrame(</span>
        <span class="s1">{</span><span class="s2">&quot;x&quot;</span><span class="s1">: pd.Categorical(values</span><span class="s0">, </span><span class="s1">categories=[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">])</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: range(len(values))}</span>
    <span class="s1">)</span>
    <span class="s1">gb = df.groupby(</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s1">dropna=</span><span class="s0">False, </span><span class="s1">observed=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">result = gb.transform(</span><span class="s0">lambda </span><span class="s1">x: x.sum())</span>
    <span class="s1">expected = gb.transform(</span><span class="s2">&quot;sum&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>
</pre>
</body>
</html>