<html>
<head>
<title>test_neighbors.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6897bb;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_neighbors.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">re</span>
<span class="s0">import </span><span class="s1">warnings</span>
<span class="s0">from </span><span class="s1">itertools </span><span class="s0">import </span><span class="s1">product</span>

<span class="s0">import </span><span class="s1">joblib</span>
<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">pytest</span>
<span class="s0">from </span><span class="s1">scipy.sparse </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">bsr_matrix</span><span class="s0">,</span>
    <span class="s1">coo_matrix</span><span class="s0">,</span>
    <span class="s1">csc_matrix</span><span class="s0">,</span>
    <span class="s1">csr_matrix</span><span class="s0">,</span>
    <span class="s1">dia_matrix</span><span class="s0">,</span>
    <span class="s1">dok_matrix</span><span class="s0">,</span>
    <span class="s1">issparse</span><span class="s0">,</span>
    <span class="s1">lil_matrix</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s0">from </span><span class="s1">sklearn </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">config_context</span><span class="s0">,</span>
    <span class="s1">datasets</span><span class="s0">,</span>
    <span class="s1">metrics</span><span class="s0">,</span>
    <span class="s1">neighbors</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">sklearn.base </span><span class="s0">import </span><span class="s1">clone</span>
<span class="s0">from </span><span class="s1">sklearn.exceptions </span><span class="s0">import </span><span class="s1">DataConversionWarning</span><span class="s0">, </span><span class="s1">EfficiencyWarning</span><span class="s0">, </span><span class="s1">NotFittedError</span>
<span class="s0">from </span><span class="s1">sklearn.metrics.pairwise </span><span class="s0">import </span><span class="s1">pairwise_distances</span>
<span class="s0">from </span><span class="s1">sklearn.metrics.tests.test_dist_metrics </span><span class="s0">import </span><span class="s1">BOOL_METRICS</span>
<span class="s0">from </span><span class="s1">sklearn.metrics.tests.test_pairwise_distances_reduction </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">assert_radius_neighbors_results_equality</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">sklearn.model_selection </span><span class="s0">import </span><span class="s1">cross_val_score</span><span class="s0">, </span><span class="s1">train_test_split</span>
<span class="s0">from </span><span class="s1">sklearn.neighbors </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">VALID_METRICS_SPARSE</span><span class="s0">,</span>
    <span class="s1">KNeighborsRegressor</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">sklearn.neighbors._base </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">KNeighborsMixin</span><span class="s0">,</span>
    <span class="s1">_check_precomputed</span><span class="s0">,</span>
    <span class="s1">_is_sorted_by_data</span><span class="s0">,</span>
    <span class="s1">sort_graph_by_row_values</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">sklearn.pipeline </span><span class="s0">import </span><span class="s1">make_pipeline</span>
<span class="s0">from </span><span class="s1">sklearn.utils._testing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">assert_allclose</span><span class="s0">,</span>
    <span class="s1">assert_array_equal</span><span class="s0">,</span>
    <span class="s1">ignore_warnings</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">sklearn.utils.fixes </span><span class="s0">import </span><span class="s1">parse_version</span><span class="s0">, </span><span class="s1">sp_version</span>
<span class="s0">from </span><span class="s1">sklearn.utils.validation </span><span class="s0">import </span><span class="s1">check_random_state</span>

<span class="s1">rng = np.random.RandomState(</span><span class="s2">0</span><span class="s1">)</span>
<span class="s3"># load and shuffle iris dataset</span>
<span class="s1">iris = datasets.load_iris()</span>
<span class="s1">perm = rng.permutation(iris.target.size)</span>
<span class="s1">iris.data = iris.data[perm]</span>
<span class="s1">iris.target = iris.target[perm]</span>

<span class="s3"># load and shuffle digits</span>
<span class="s1">digits = datasets.load_digits()</span>
<span class="s1">perm = rng.permutation(digits.target.size)</span>
<span class="s1">digits.data = digits.data[perm]</span>
<span class="s1">digits.target = digits.target[perm]</span>

<span class="s1">SPARSE_TYPES = (bsr_matrix</span><span class="s0">, </span><span class="s1">coo_matrix</span><span class="s0">, </span><span class="s1">csc_matrix</span><span class="s0">, </span><span class="s1">csr_matrix</span><span class="s0">, </span><span class="s1">dok_matrix</span><span class="s0">, </span><span class="s1">lil_matrix)</span>
<span class="s1">SPARSE_OR_DENSE = SPARSE_TYPES + (np.asarray</span><span class="s0">,</span><span class="s1">)</span>

<span class="s1">ALGORITHMS = (</span><span class="s4">&quot;ball_tree&quot;</span><span class="s0">, </span><span class="s4">&quot;brute&quot;</span><span class="s0">, </span><span class="s4">&quot;kd_tree&quot;</span><span class="s0">, </span><span class="s4">&quot;auto&quot;</span><span class="s1">)</span>
<span class="s1">COMMON_VALID_METRICS = sorted(</span>
    <span class="s1">set.intersection(*map(set</span><span class="s0">, </span><span class="s1">neighbors.VALID_METRICS.values()))</span>
<span class="s1">)  </span><span class="s3"># type: ignore</span>
<span class="s1">P = (</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s1">np.inf)</span>

<span class="s3"># Filter deprecation warnings.</span>
<span class="s1">neighbors.kneighbors_graph = ignore_warnings(neighbors.kneighbors_graph)</span>
<span class="s1">neighbors.radius_neighbors_graph = ignore_warnings(neighbors.radius_neighbors_graph)</span>


<span class="s0">def </span><span class="s1">_generate_test_params_for(metric: str</span><span class="s0">, </span><span class="s1">n_features: int):</span>
    <span class="s5">&quot;&quot;&quot;Return list of DistanceMetric kwargs for tests.&quot;&quot;&quot;</span>

    <span class="s3"># Distinguishing on cases not to compute unneeded datastructures.</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s2">1</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">metric == </span><span class="s4">&quot;minkowski&quot;</span><span class="s1">:</span>
        <span class="s1">minkowski_kwargs = [dict(p=</span><span class="s2">1.5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dict(p=</span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dict(p=</span><span class="s2">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dict(p=np.inf)]</span>
        <span class="s0">if </span><span class="s1">sp_version &gt;= parse_version(</span><span class="s4">&quot;1.8.0.dev0&quot;</span><span class="s1">):</span>
            <span class="s3"># TODO: remove the test once we no longer support scipy &lt; 1.8.0.</span>
            <span class="s3"># Recent scipy versions accept weights in the Minkowski metric directly:</span>
            <span class="s3"># type: ignore</span>
            <span class="s1">minkowski_kwargs.append(dict(p=</span><span class="s2">3</span><span class="s0">, </span><span class="s1">w=rng.rand(n_features)))</span>
        <span class="s0">return </span><span class="s1">minkowski_kwargs</span>

    <span class="s0">if </span><span class="s1">metric == </span><span class="s4">&quot;seuclidean&quot;</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">[dict(V=rng.rand(n_features))]</span>

    <span class="s0">if </span><span class="s1">metric == </span><span class="s4">&quot;mahalanobis&quot;</span><span class="s1">:</span>
        <span class="s1">A = rng.rand(n_features</span><span class="s0">, </span><span class="s1">n_features)</span>
        <span class="s3"># Make the matrix symmetric positive definite</span>
        <span class="s1">VI = A + A.T + </span><span class="s2">3 </span><span class="s1">* np.eye(n_features)</span>
        <span class="s0">return </span><span class="s1">[dict(VI=VI)]</span>

    <span class="s3"># Case of: &quot;euclidean&quot;, &quot;manhattan&quot;, &quot;chebyshev&quot;, &quot;haversine&quot; or any other metric.</span>
    <span class="s3"># In those cases, no kwargs are needed.</span>
    <span class="s0">return </span><span class="s1">[{}]</span>


<span class="s0">def </span><span class="s1">_weight_func(dist):</span>
    <span class="s5">&quot;&quot;&quot;Weight function to replace lambda d: d ** -2. 
    The lambda function is not valid because: 
    if d==0 then 0^-2 is not valid.&quot;&quot;&quot;</span>

    <span class="s3"># Dist could be multidimensional, flatten it so all values</span>
    <span class="s3"># can be looped</span>
    <span class="s0">with </span><span class="s1">np.errstate(divide=</span><span class="s4">&quot;ignore&quot;</span><span class="s1">):</span>
        <span class="s1">retval = </span><span class="s2">1.0 </span><span class="s1">/ dist</span>
    <span class="s0">return </span><span class="s1">retval**</span><span class="s2">2</span>


<span class="s1">WEIGHTS = [</span><span class="s4">&quot;uniform&quot;</span><span class="s0">, </span><span class="s4">&quot;distance&quot;</span><span class="s0">, </span><span class="s1">_weight_func]</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s4">&quot;n_samples, n_features, n_query_pts, n_neighbors&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span><span class="s2">100</span><span class="s0">, </span><span class="s2">100</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">100</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">1000</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">100</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;query_is_train&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">False, True</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;metric&quot;</span><span class="s0">, </span><span class="s1">COMMON_VALID_METRICS)</span>
<span class="s0">def </span><span class="s1">test_unsupervised_kneighbors(</span>
    <span class="s1">global_dtype</span><span class="s0">,</span>
    <span class="s1">n_samples</span><span class="s0">,</span>
    <span class="s1">n_features</span><span class="s0">,</span>
    <span class="s1">n_query_pts</span><span class="s0">,</span>
    <span class="s1">n_neighbors</span><span class="s0">,</span>
    <span class="s1">query_is_train</span><span class="s0">,</span>
    <span class="s1">metric</span><span class="s0">,</span>
<span class="s1">):</span>
    <span class="s3"># The different algorithms must return identical results</span>
    <span class="s3"># on their common metrics, with and without returning</span>
    <span class="s3"># distances</span>

    <span class="s3"># Redefining the rng locally to use the same generated X</span>
    <span class="s1">local_rng = np.random.RandomState(</span><span class="s2">0</span><span class="s1">)</span>
    <span class="s1">X = local_rng.rand(n_samples</span><span class="s0">, </span><span class="s1">n_features).astype(global_dtype</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s1">query = (</span>
        <span class="s1">X</span>
        <span class="s0">if </span><span class="s1">query_is_train</span>
        <span class="s0">else </span><span class="s1">local_rng.rand(n_query_pts</span><span class="s0">, </span><span class="s1">n_features).astype(global_dtype</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">)</span>

    <span class="s1">results_nodist = []</span>
    <span class="s1">results = []</span>

    <span class="s0">for </span><span class="s1">algorithm </span><span class="s0">in </span><span class="s1">ALGORITHMS:</span>
        <span class="s1">neigh = neighbors.NearestNeighbors(</span>
            <span class="s1">n_neighbors=n_neighbors</span><span class="s0">, </span><span class="s1">algorithm=algorithm</span><span class="s0">, </span><span class="s1">metric=metric</span>
        <span class="s1">)</span>
        <span class="s1">neigh.fit(X)</span>

        <span class="s1">results_nodist.append(neigh.kneighbors(query</span><span class="s0">, </span><span class="s1">return_distance=</span><span class="s0">False</span><span class="s1">))</span>
        <span class="s1">results.append(neigh.kneighbors(query</span><span class="s0">, </span><span class="s1">return_distance=</span><span class="s0">True</span><span class="s1">))</span>

    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(results) - </span><span class="s2">1</span><span class="s1">):</span>
        <span class="s1">algorithm = ALGORITHMS[i]</span>
        <span class="s1">next_algorithm = ALGORITHMS[i + </span><span class="s2">1</span><span class="s1">]</span>

        <span class="s1">indices_no_dist = results_nodist[i]</span>
        <span class="s1">distances</span><span class="s0">, </span><span class="s1">next_distances = results[i][</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">results[i + </span><span class="s2">1</span><span class="s1">][</span><span class="s2">0</span><span class="s1">]</span>
        <span class="s1">indices</span><span class="s0">, </span><span class="s1">next_indices = results[i][</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">results[i + </span><span class="s2">1</span><span class="s1">][</span><span class="s2">1</span><span class="s1">]</span>
        <span class="s1">assert_array_equal(</span>
            <span class="s1">indices_no_dist</span><span class="s0">,</span>
            <span class="s1">indices</span><span class="s0">,</span>
            <span class="s1">err_msg=(</span>
                <span class="s4">f&quot;The '</span><span class="s0">{</span><span class="s1">algorithm</span><span class="s0">}</span><span class="s4">' algorithm returns different&quot;</span>
                <span class="s4">&quot;indices depending on 'return_distances'.&quot;</span>
            <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">assert_array_equal(</span>
            <span class="s1">indices</span><span class="s0">,</span>
            <span class="s1">next_indices</span><span class="s0">,</span>
            <span class="s1">err_msg=(</span>
                <span class="s4">f&quot;The '</span><span class="s0">{</span><span class="s1">algorithm</span><span class="s0">}</span><span class="s4">' and '</span><span class="s0">{</span><span class="s1">next_algorithm</span><span class="s0">}</span><span class="s4">' &quot;</span>
                <span class="s4">&quot;algorithms return different indices.&quot;</span>
            <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">distances</span><span class="s0">,</span>
            <span class="s1">next_distances</span><span class="s0">,</span>
            <span class="s1">err_msg=(</span>
                <span class="s4">f&quot;The '</span><span class="s0">{</span><span class="s1">algorithm</span><span class="s0">}</span><span class="s4">' and '</span><span class="s0">{</span><span class="s1">next_algorithm</span><span class="s0">}</span><span class="s4">' &quot;</span>
                <span class="s4">&quot;algorithms return different distances.&quot;</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">atol=</span><span class="s2">1e-6</span><span class="s0">,</span>
        <span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s4">&quot;n_samples, n_features, n_query_pts&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span><span class="s2">100</span><span class="s0">, </span><span class="s2">100</span><span class="s0">, </span><span class="s2">10</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">1000</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">100</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;metric&quot;</span><span class="s0">, </span><span class="s1">COMMON_VALID_METRICS)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;n_neighbors, radius&quot;</span><span class="s0">, </span><span class="s1">[(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">50</span><span class="s0">, </span><span class="s2">500</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">100</span><span class="s0">, </span><span class="s2">1000</span><span class="s1">)])</span>
<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s4">&quot;NeighborsMixinSubclass&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">neighbors.KNeighborsClassifier</span><span class="s0">,</span>
        <span class="s1">neighbors.KNeighborsRegressor</span><span class="s0">,</span>
        <span class="s1">neighbors.RadiusNeighborsClassifier</span><span class="s0">,</span>
        <span class="s1">neighbors.RadiusNeighborsRegressor</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_neigh_predictions_algorithm_agnosticity(</span>
    <span class="s1">global_dtype</span><span class="s0">,</span>
    <span class="s1">n_samples</span><span class="s0">,</span>
    <span class="s1">n_features</span><span class="s0">,</span>
    <span class="s1">n_query_pts</span><span class="s0">,</span>
    <span class="s1">metric</span><span class="s0">,</span>
    <span class="s1">n_neighbors</span><span class="s0">,</span>
    <span class="s1">radius</span><span class="s0">,</span>
    <span class="s1">NeighborsMixinSubclass</span><span class="s0">,</span>
<span class="s1">):</span>
    <span class="s3"># The different algorithms must return identical predictions results</span>
    <span class="s3"># on their common metrics.</span>

    <span class="s3"># Redefining the rng locally to use the same generated X</span>
    <span class="s1">local_rng = np.random.RandomState(</span><span class="s2">0</span><span class="s1">)</span>
    <span class="s1">X = local_rng.rand(n_samples</span><span class="s0">, </span><span class="s1">n_features).astype(global_dtype</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">y = local_rng.randint(</span><span class="s2">3</span><span class="s0">, </span><span class="s1">size=n_samples)</span>

    <span class="s1">query = local_rng.rand(n_query_pts</span><span class="s0">, </span><span class="s1">n_features).astype(global_dtype</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s1">predict_results = []</span>

    <span class="s1">parameter = (</span>
        <span class="s1">n_neighbors </span><span class="s0">if </span><span class="s1">issubclass(NeighborsMixinSubclass</span><span class="s0">, </span><span class="s1">KNeighborsMixin) </span><span class="s0">else </span><span class="s1">radius</span>
    <span class="s1">)</span>

    <span class="s0">for </span><span class="s1">algorithm </span><span class="s0">in </span><span class="s1">ALGORITHMS:</span>
        <span class="s1">neigh = NeighborsMixinSubclass(parameter</span><span class="s0">, </span><span class="s1">algorithm=algorithm</span><span class="s0">, </span><span class="s1">metric=metric)</span>
        <span class="s1">neigh.fit(X</span><span class="s0">, </span><span class="s1">y)</span>

        <span class="s1">predict_results.append(neigh.predict(query))</span>

    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(predict_results) - </span><span class="s2">1</span><span class="s1">):</span>
        <span class="s1">algorithm = ALGORITHMS[i]</span>
        <span class="s1">next_algorithm = ALGORITHMS[i + </span><span class="s2">1</span><span class="s1">]</span>

        <span class="s1">predictions</span><span class="s0">, </span><span class="s1">next_predictions = predict_results[i]</span><span class="s0">, </span><span class="s1">predict_results[i + </span><span class="s2">1</span><span class="s1">]</span>

        <span class="s1">assert_allclose(</span>
            <span class="s1">predictions</span><span class="s0">,</span>
            <span class="s1">next_predictions</span><span class="s0">,</span>
            <span class="s1">err_msg=(</span>
                <span class="s4">f&quot;The '</span><span class="s0">{</span><span class="s1">algorithm</span><span class="s0">}</span><span class="s4">' and '</span><span class="s0">{</span><span class="s1">next_algorithm</span><span class="s0">}</span><span class="s4">' &quot;</span>
                <span class="s4">&quot;algorithms return different predictions.&quot;</span>
            <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s4">&quot;KNeighborsMixinSubclass&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">neighbors.KNeighborsClassifier</span><span class="s0">,</span>
        <span class="s1">neighbors.KNeighborsRegressor</span><span class="s0">,</span>
        <span class="s1">neighbors.NearestNeighbors</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_unsupervised_inputs(global_dtype</span><span class="s0">, </span><span class="s1">KNeighborsMixinSubclass):</span>
    <span class="s3"># Test unsupervised inputs for neighbors estimators</span>

    <span class="s1">X = rng.random_sample((</span><span class="s2">10</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)).astype(global_dtype</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">y = rng.randint(</span><span class="s2">3</span><span class="s0">, </span><span class="s1">size=</span><span class="s2">10</span><span class="s1">)</span>
    <span class="s1">nbrs_fid = neighbors.NearestNeighbors(n_neighbors=</span><span class="s2">1</span><span class="s1">)</span>
    <span class="s1">nbrs_fid.fit(X)</span>

    <span class="s1">dist1</span><span class="s0">, </span><span class="s1">ind1 = nbrs_fid.kneighbors(X)</span>

    <span class="s1">nbrs = KNeighborsMixinSubclass(n_neighbors=</span><span class="s2">1</span><span class="s1">)</span>

    <span class="s0">for </span><span class="s1">data </span><span class="s0">in </span><span class="s1">(nbrs_fid</span><span class="s0">, </span><span class="s1">neighbors.BallTree(X)</span><span class="s0">, </span><span class="s1">neighbors.KDTree(X)):</span>
        <span class="s1">nbrs.fit(data</span><span class="s0">, </span><span class="s1">y)</span>

        <span class="s1">dist2</span><span class="s0">, </span><span class="s1">ind2 = nbrs.kneighbors(X)</span>

        <span class="s1">assert_allclose(dist1</span><span class="s0">, </span><span class="s1">dist2)</span>
        <span class="s1">assert_array_equal(ind1</span><span class="s0">, </span><span class="s1">ind2)</span>


<span class="s0">def </span><span class="s1">test_not_fitted_error_gets_raised():</span>
    <span class="s1">X = [[</span><span class="s2">1</span><span class="s1">]]</span>
    <span class="s1">neighbors_ = neighbors.NearestNeighbors()</span>
    <span class="s0">with </span><span class="s1">pytest.raises(NotFittedError):</span>
        <span class="s1">neighbors_.kneighbors_graph(X)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(NotFittedError):</span>
        <span class="s1">neighbors_.radius_neighbors_graph(X)</span>


<span class="s1">@pytest.mark.filterwarnings(</span><span class="s4">&quot;ignore:EfficiencyWarning&quot;</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">check_precomputed(make_train_test</span><span class="s0">, </span><span class="s1">estimators):</span>
    <span class="s5">&quot;&quot;&quot;Tests unsupervised NearestNeighbors with a distance matrix.&quot;&quot;&quot;</span>
    <span class="s3"># Note: smaller samples may result in spurious test success</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s2">42</span><span class="s1">)</span>
    <span class="s1">X = rng.random_sample((</span><span class="s2">10</span><span class="s0">, </span><span class="s2">4</span><span class="s1">))</span>
    <span class="s1">Y = rng.random_sample((</span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s1">))</span>
    <span class="s1">DXX</span><span class="s0">, </span><span class="s1">DYX = make_train_test(X</span><span class="s0">, </span><span class="s1">Y)</span>
    <span class="s0">for </span><span class="s1">method </span><span class="s0">in </span><span class="s1">[</span>
        <span class="s4">&quot;kneighbors&quot;</span><span class="s0">,</span>
    <span class="s1">]:</span>
        <span class="s3"># TODO: also test radius_neighbors, but requires different assertion</span>

        <span class="s3"># As a feature matrix (n_samples by n_features)</span>
        <span class="s1">nbrs_X = neighbors.NearestNeighbors(n_neighbors=</span><span class="s2">3</span><span class="s1">)</span>
        <span class="s1">nbrs_X.fit(X)</span>
        <span class="s1">dist_X</span><span class="s0">, </span><span class="s1">ind_X = getattr(nbrs_X</span><span class="s0">, </span><span class="s1">method)(Y)</span>

        <span class="s3"># As a dense distance matrix (n_samples by n_samples)</span>
        <span class="s1">nbrs_D = neighbors.NearestNeighbors(</span>
            <span class="s1">n_neighbors=</span><span class="s2">3</span><span class="s0">, </span><span class="s1">algorithm=</span><span class="s4">&quot;brute&quot;</span><span class="s0">, </span><span class="s1">metric=</span><span class="s4">&quot;precomputed&quot;</span>
        <span class="s1">)</span>
        <span class="s1">nbrs_D.fit(DXX)</span>
        <span class="s1">dist_D</span><span class="s0">, </span><span class="s1">ind_D = getattr(nbrs_D</span><span class="s0">, </span><span class="s1">method)(DYX)</span>
        <span class="s1">assert_allclose(dist_X</span><span class="s0">, </span><span class="s1">dist_D)</span>
        <span class="s1">assert_array_equal(ind_X</span><span class="s0">, </span><span class="s1">ind_D)</span>

        <span class="s3"># Check auto works too</span>
        <span class="s1">nbrs_D = neighbors.NearestNeighbors(</span>
            <span class="s1">n_neighbors=</span><span class="s2">3</span><span class="s0">, </span><span class="s1">algorithm=</span><span class="s4">&quot;auto&quot;</span><span class="s0">, </span><span class="s1">metric=</span><span class="s4">&quot;precomputed&quot;</span>
        <span class="s1">)</span>
        <span class="s1">nbrs_D.fit(DXX)</span>
        <span class="s1">dist_D</span><span class="s0">, </span><span class="s1">ind_D = getattr(nbrs_D</span><span class="s0">, </span><span class="s1">method)(DYX)</span>
        <span class="s1">assert_allclose(dist_X</span><span class="s0">, </span><span class="s1">dist_D)</span>
        <span class="s1">assert_array_equal(ind_X</span><span class="s0">, </span><span class="s1">ind_D)</span>

        <span class="s3"># Check X=None in prediction</span>
        <span class="s1">dist_X</span><span class="s0">, </span><span class="s1">ind_X = getattr(nbrs_X</span><span class="s0">, </span><span class="s1">method)(</span><span class="s0">None</span><span class="s1">)</span>
        <span class="s1">dist_D</span><span class="s0">, </span><span class="s1">ind_D = getattr(nbrs_D</span><span class="s0">, </span><span class="s1">method)(</span><span class="s0">None</span><span class="s1">)</span>
        <span class="s1">assert_allclose(dist_X</span><span class="s0">, </span><span class="s1">dist_D)</span>
        <span class="s1">assert_array_equal(ind_X</span><span class="s0">, </span><span class="s1">ind_D)</span>

        <span class="s3"># Must raise a ValueError if the matrix is not of correct shape</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">getattr(nbrs_D</span><span class="s0">, </span><span class="s1">method)(X)</span>

    <span class="s1">target = np.arange(X.shape[</span><span class="s2">0</span><span class="s1">])</span>
    <span class="s0">for </span><span class="s1">Est </span><span class="s0">in </span><span class="s1">estimators:</span>
        <span class="s1">est = Est(metric=</span><span class="s4">&quot;euclidean&quot;</span><span class="s1">)</span>
        <span class="s1">est.radius = est.n_neighbors = </span><span class="s2">1</span>
        <span class="s1">pred_X = est.fit(X</span><span class="s0">, </span><span class="s1">target).predict(Y)</span>
        <span class="s1">est.metric = </span><span class="s4">&quot;precomputed&quot;</span>
        <span class="s1">pred_D = est.fit(DXX</span><span class="s0">, </span><span class="s1">target).predict(DYX)</span>
        <span class="s1">assert_allclose(pred_X</span><span class="s0">, </span><span class="s1">pred_D)</span>


<span class="s0">def </span><span class="s1">test_precomputed_dense():</span>
    <span class="s0">def </span><span class="s1">make_train_test(X_train</span><span class="s0">, </span><span class="s1">X_test):</span>
        <span class="s0">return </span><span class="s1">(</span>
            <span class="s1">metrics.pairwise_distances(X_train)</span><span class="s0">,</span>
            <span class="s1">metrics.pairwise_distances(X_test</span><span class="s0">, </span><span class="s1">X_train)</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s1">estimators = [</span>
        <span class="s1">neighbors.KNeighborsClassifier</span><span class="s0">,</span>
        <span class="s1">neighbors.KNeighborsRegressor</span><span class="s0">,</span>
        <span class="s1">neighbors.RadiusNeighborsClassifier</span><span class="s0">,</span>
        <span class="s1">neighbors.RadiusNeighborsRegressor</span><span class="s0">,</span>
    <span class="s1">]</span>
    <span class="s1">check_precomputed(make_train_test</span><span class="s0">, </span><span class="s1">estimators)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;fmt&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;csr&quot;</span><span class="s0">, </span><span class="s4">&quot;lil&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_precomputed_sparse_knn(fmt):</span>
    <span class="s0">def </span><span class="s1">make_train_test(X_train</span><span class="s0">, </span><span class="s1">X_test):</span>
        <span class="s1">nn = neighbors.NearestNeighbors(n_neighbors=</span><span class="s2">3 </span><span class="s1">+ </span><span class="s2">1</span><span class="s1">).fit(X_train)</span>
        <span class="s0">return </span><span class="s1">(</span>
            <span class="s1">nn.kneighbors_graph(X_train</span><span class="s0">, </span><span class="s1">mode=</span><span class="s4">&quot;distance&quot;</span><span class="s1">).asformat(fmt)</span><span class="s0">,</span>
            <span class="s1">nn.kneighbors_graph(X_test</span><span class="s0">, </span><span class="s1">mode=</span><span class="s4">&quot;distance&quot;</span><span class="s1">).asformat(fmt)</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s3"># We do not test RadiusNeighborsClassifier and RadiusNeighborsRegressor</span>
    <span class="s3"># since the precomputed neighbors graph is built with k neighbors only.</span>
    <span class="s1">estimators = [</span>
        <span class="s1">neighbors.KNeighborsClassifier</span><span class="s0">,</span>
        <span class="s1">neighbors.KNeighborsRegressor</span><span class="s0">,</span>
    <span class="s1">]</span>
    <span class="s1">check_precomputed(make_train_test</span><span class="s0">, </span><span class="s1">estimators)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;fmt&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;csr&quot;</span><span class="s0">, </span><span class="s4">&quot;lil&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_precomputed_sparse_radius(fmt):</span>
    <span class="s0">def </span><span class="s1">make_train_test(X_train</span><span class="s0">, </span><span class="s1">X_test):</span>
        <span class="s1">nn = neighbors.NearestNeighbors(radius=</span><span class="s2">1</span><span class="s1">).fit(X_train)</span>
        <span class="s0">return </span><span class="s1">(</span>
            <span class="s1">nn.radius_neighbors_graph(X_train</span><span class="s0">, </span><span class="s1">mode=</span><span class="s4">&quot;distance&quot;</span><span class="s1">).asformat(fmt)</span><span class="s0">,</span>
            <span class="s1">nn.radius_neighbors_graph(X_test</span><span class="s0">, </span><span class="s1">mode=</span><span class="s4">&quot;distance&quot;</span><span class="s1">).asformat(fmt)</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s3"># We do not test KNeighborsClassifier and KNeighborsRegressor</span>
    <span class="s3"># since the precomputed neighbors graph is built with a radius.</span>
    <span class="s1">estimators = [</span>
        <span class="s1">neighbors.RadiusNeighborsClassifier</span><span class="s0">,</span>
        <span class="s1">neighbors.RadiusNeighborsRegressor</span><span class="s0">,</span>
    <span class="s1">]</span>
    <span class="s1">check_precomputed(make_train_test</span><span class="s0">, </span><span class="s1">estimators)</span>


<span class="s0">def </span><span class="s1">test_is_sorted_by_data():</span>
    <span class="s3"># Test that _is_sorted_by_data works as expected. In CSR sparse matrix,</span>
    <span class="s3"># entries in each row can be sorted by indices, by data, or unsorted.</span>
    <span class="s3"># _is_sorted_by_data should return True when entries are sorted by data,</span>
    <span class="s3"># and False in all other cases.</span>

    <span class="s3"># Test with sorted 1D array</span>
    <span class="s1">X = csr_matrix(np.arange(</span><span class="s2">10</span><span class="s1">))</span>
    <span class="s0">assert </span><span class="s1">_is_sorted_by_data(X)</span>
    <span class="s3"># Test with unsorted 1D array</span>
    <span class="s1">X[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s1">] = </span><span class="s2">5</span>
    <span class="s0">assert not </span><span class="s1">_is_sorted_by_data(X)</span>

    <span class="s3"># Test when the data is sorted in each sample, but not necessarily</span>
    <span class="s3"># between samples</span>
    <span class="s1">X = csr_matrix([[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]])</span>
    <span class="s0">assert </span><span class="s1">_is_sorted_by_data(X)</span>

    <span class="s3"># Test with duplicates entries in X.indptr</span>
    <span class="s1">data</span><span class="s0">, </span><span class="s1">indices</span><span class="s0">, </span><span class="s1">indptr = [</span><span class="s2">0</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]</span>
    <span class="s1">X = csr_matrix((data</span><span class="s0">, </span><span class="s1">indices</span><span class="s0">, </span><span class="s1">indptr)</span><span class="s0">, </span><span class="s1">shape=(</span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s1">))</span>
    <span class="s0">assert </span><span class="s1">_is_sorted_by_data(X)</span>


<span class="s1">@pytest.mark.filterwarnings(</span><span class="s4">&quot;ignore:EfficiencyWarning&quot;</span><span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;function&quot;</span><span class="s0">, </span><span class="s1">[sort_graph_by_row_values</span><span class="s0">, </span><span class="s1">_check_precomputed])</span>
<span class="s0">def </span><span class="s1">test_sort_graph_by_row_values(function):</span>
    <span class="s3"># Test that sort_graph_by_row_values returns a graph sorted by row values</span>
    <span class="s1">X = csr_matrix(np.abs(np.random.RandomState(</span><span class="s2">42</span><span class="s1">).randn(</span><span class="s2">10</span><span class="s0">, </span><span class="s2">10</span><span class="s1">)))</span>
    <span class="s0">assert not </span><span class="s1">_is_sorted_by_data(X)</span>
    <span class="s1">Xt = function(X)</span>
    <span class="s0">assert </span><span class="s1">_is_sorted_by_data(Xt)</span>

    <span class="s3"># test with a different number of nonzero entries for each sample</span>
    <span class="s1">mask = np.random.RandomState(</span><span class="s2">42</span><span class="s1">).randint(</span><span class="s2">2</span><span class="s0">, </span><span class="s1">size=(</span><span class="s2">10</span><span class="s0">, </span><span class="s2">10</span><span class="s1">))</span>
    <span class="s1">X = X.toarray()</span>
    <span class="s1">X[mask == </span><span class="s2">1</span><span class="s1">] = </span><span class="s2">0</span>
    <span class="s1">X = csr_matrix(X)</span>
    <span class="s0">assert not </span><span class="s1">_is_sorted_by_data(X)</span>
    <span class="s1">Xt = function(X)</span>
    <span class="s0">assert </span><span class="s1">_is_sorted_by_data(Xt)</span>


<span class="s1">@pytest.mark.filterwarnings(</span><span class="s4">&quot;ignore:EfficiencyWarning&quot;</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_sort_graph_by_row_values_copy():</span>
    <span class="s3"># Test if the sorting is done inplace if X is CSR, so that Xt is X.</span>
    <span class="s1">X_ = csr_matrix(np.abs(np.random.RandomState(</span><span class="s2">42</span><span class="s1">).randn(</span><span class="s2">10</span><span class="s0">, </span><span class="s2">10</span><span class="s1">)))</span>
    <span class="s0">assert not </span><span class="s1">_is_sorted_by_data(X_)</span>

    <span class="s3"># sort_graph_by_row_values is done inplace if copy=False</span>
    <span class="s1">X = X_.copy()</span>
    <span class="s0">assert </span><span class="s1">sort_graph_by_row_values(X).data </span><span class="s0">is </span><span class="s1">X.data</span>

    <span class="s1">X = X_.copy()</span>
    <span class="s0">assert </span><span class="s1">sort_graph_by_row_values(X</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">).data </span><span class="s0">is </span><span class="s1">X.data</span>

    <span class="s1">X = X_.copy()</span>
    <span class="s0">assert </span><span class="s1">sort_graph_by_row_values(X</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">True</span><span class="s1">).data </span><span class="s0">is not </span><span class="s1">X.data</span>

    <span class="s3"># _check_precomputed is never done inplace</span>
    <span class="s1">X = X_.copy()</span>
    <span class="s0">assert </span><span class="s1">_check_precomputed(X).data </span><span class="s0">is not </span><span class="s1">X.data</span>

    <span class="s3"># do not raise if X is not CSR and copy=True</span>
    <span class="s1">sort_graph_by_row_values(X.tocsc()</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s3"># raise if X is not CSR and copy=False</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;Use copy=True to allow the conversion&quot;</span><span class="s1">):</span>
        <span class="s1">sort_graph_by_row_values(X.tocsc()</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_sort_graph_by_row_values_warning():</span>
    <span class="s3"># Test that the parameter warn_when_not_sorted works as expected.</span>
    <span class="s1">X = csr_matrix(np.abs(np.random.RandomState(</span><span class="s2">42</span><span class="s1">).randn(</span><span class="s2">10</span><span class="s0">, </span><span class="s2">10</span><span class="s1">)))</span>
    <span class="s0">assert not </span><span class="s1">_is_sorted_by_data(X)</span>

    <span class="s3"># warning</span>
    <span class="s0">with </span><span class="s1">pytest.warns(EfficiencyWarning</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;was not sorted by row values&quot;</span><span class="s1">):</span>
        <span class="s1">sort_graph_by_row_values(X</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.warns(EfficiencyWarning</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;was not sorted by row values&quot;</span><span class="s1">):</span>
        <span class="s1">sort_graph_by_row_values(X</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">True, </span><span class="s1">warn_when_not_sorted=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.warns(EfficiencyWarning</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;was not sorted by row values&quot;</span><span class="s1">):</span>
        <span class="s1">_check_precomputed(X)</span>

    <span class="s3"># no warning</span>
    <span class="s0">with </span><span class="s1">warnings.catch_warnings():</span>
        <span class="s1">warnings.simplefilter(</span><span class="s4">&quot;error&quot;</span><span class="s1">)</span>
        <span class="s1">sort_graph_by_row_values(X</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">True, </span><span class="s1">warn_when_not_sorted=</span><span class="s0">False</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;format&quot;</span><span class="s0">, </span><span class="s1">[dok_matrix</span><span class="s0">, </span><span class="s1">bsr_matrix</span><span class="s0">, </span><span class="s1">dia_matrix])</span>
<span class="s0">def </span><span class="s1">test_sort_graph_by_row_values_bad_sparse_format(format):</span>
    <span class="s3"># Test that sort_graph_by_row_values and _check_precomputed error on bad formats</span>
    <span class="s1">X = format(np.abs(np.random.RandomState(</span><span class="s2">42</span><span class="s1">).randn(</span><span class="s2">10</span><span class="s0">, </span><span class="s2">10</span><span class="s1">)))</span>
    <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;format is not supported&quot;</span><span class="s1">):</span>
        <span class="s1">sort_graph_by_row_values(X)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;format is not supported&quot;</span><span class="s1">):</span>
        <span class="s1">_check_precomputed(X)</span>


<span class="s1">@pytest.mark.filterwarnings(</span><span class="s4">&quot;ignore:EfficiencyWarning&quot;</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_precomputed_sparse_invalid():</span>
    <span class="s1">dist = np.array([[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">2.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">3.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">3.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]])</span>
    <span class="s1">dist_csr = csr_matrix(dist)</span>
    <span class="s1">neigh = neighbors.NearestNeighbors(n_neighbors=</span><span class="s2">1</span><span class="s0">, </span><span class="s1">metric=</span><span class="s4">&quot;precomputed&quot;</span><span class="s1">)</span>
    <span class="s1">neigh.fit(dist_csr)</span>
    <span class="s1">neigh.kneighbors(</span><span class="s0">None, </span><span class="s1">n_neighbors=</span><span class="s2">1</span><span class="s1">)</span>
    <span class="s1">neigh.kneighbors(np.array([[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]])</span><span class="s0">, </span><span class="s1">n_neighbors=</span><span class="s2">2</span><span class="s1">)</span>

    <span class="s3"># Ensures enough number of nearest neighbors</span>
    <span class="s1">dist = np.array([[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">2.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">3.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">3.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]])</span>
    <span class="s1">dist_csr = csr_matrix(dist)</span>
    <span class="s1">neigh.fit(dist_csr)</span>
    <span class="s1">msg = </span><span class="s4">&quot;2 neighbors per samples are required, but some samples have only 1&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">neigh.kneighbors(</span><span class="s0">None, </span><span class="s1">n_neighbors=</span><span class="s2">1</span><span class="s1">)</span>

    <span class="s3"># Checks error with inconsistent distance matrix</span>
    <span class="s1">dist = np.array([[</span><span class="s2">5.0</span><span class="s0">, </span><span class="s2">2.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">2.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">3.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">3.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]])</span>
    <span class="s1">dist_csr = csr_matrix(dist)</span>
    <span class="s1">msg = </span><span class="s4">&quot;Negative values in data passed to precomputed distance matrix.&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">neigh.kneighbors(dist_csr</span><span class="s0">, </span><span class="s1">n_neighbors=</span><span class="s2">1</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_precomputed_cross_validation():</span>
    <span class="s3"># Ensure array is split correctly</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s2">0</span><span class="s1">)</span>
    <span class="s1">X = rng.rand(</span><span class="s2">20</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>
    <span class="s1">D = pairwise_distances(X</span><span class="s0">, </span><span class="s1">metric=</span><span class="s4">&quot;euclidean&quot;</span><span class="s1">)</span>
    <span class="s1">y = rng.randint(</span><span class="s2">3</span><span class="s0">, </span><span class="s1">size=</span><span class="s2">20</span><span class="s1">)</span>
    <span class="s0">for </span><span class="s1">Est </span><span class="s0">in </span><span class="s1">(</span>
        <span class="s1">neighbors.KNeighborsClassifier</span><span class="s0">,</span>
        <span class="s1">neighbors.RadiusNeighborsClassifier</span><span class="s0">,</span>
        <span class="s1">neighbors.KNeighborsRegressor</span><span class="s0">,</span>
        <span class="s1">neighbors.RadiusNeighborsRegressor</span><span class="s0">,</span>
    <span class="s1">):</span>
        <span class="s1">metric_score = cross_val_score(Est()</span><span class="s0">, </span><span class="s1">X</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s1">precomp_score = cross_val_score(Est(metric=</span><span class="s4">&quot;precomputed&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">D</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s1">assert_array_equal(metric_score</span><span class="s0">, </span><span class="s1">precomp_score)</span>


<span class="s0">def </span><span class="s1">test_unsupervised_radius_neighbors(</span>
    <span class="s1">global_dtype</span><span class="s0">, </span><span class="s1">n_samples=</span><span class="s2">20</span><span class="s0">, </span><span class="s1">n_features=</span><span class="s2">5</span><span class="s0">, </span><span class="s1">n_query_pts=</span><span class="s2">2</span><span class="s0">, </span><span class="s1">radius=</span><span class="s2">0.5</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s2">0</span>
<span class="s1">):</span>
    <span class="s3"># Test unsupervised radius-based query</span>
    <span class="s1">rng = np.random.RandomState(random_state)</span>

    <span class="s1">X = rng.rand(n_samples</span><span class="s0">, </span><span class="s1">n_features).astype(global_dtype</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s1">test = rng.rand(n_query_pts</span><span class="s0">, </span><span class="s1">n_features).astype(global_dtype</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">for </span><span class="s1">p </span><span class="s0">in </span><span class="s1">P:</span>
        <span class="s1">results = []</span>

        <span class="s0">for </span><span class="s1">algorithm </span><span class="s0">in </span><span class="s1">ALGORITHMS:</span>
            <span class="s1">neigh = neighbors.NearestNeighbors(radius=radius</span><span class="s0">, </span><span class="s1">algorithm=algorithm</span><span class="s0">, </span><span class="s1">p=p)</span>
            <span class="s1">neigh.fit(X)</span>

            <span class="s1">ind1 = neigh.radius_neighbors(test</span><span class="s0">, </span><span class="s1">return_distance=</span><span class="s0">False</span><span class="s1">)</span>

            <span class="s3"># sort the results: this is not done automatically for</span>
            <span class="s3"># radius searches</span>
            <span class="s1">dist</span><span class="s0">, </span><span class="s1">ind = neigh.radius_neighbors(test</span><span class="s0">, </span><span class="s1">return_distance=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s0">for </span><span class="s1">d</span><span class="s0">, </span><span class="s1">i</span><span class="s0">, </span><span class="s1">i1 </span><span class="s0">in </span><span class="s1">zip(dist</span><span class="s0">, </span><span class="s1">ind</span><span class="s0">, </span><span class="s1">ind1):</span>
                <span class="s1">j = d.argsort()</span>
                <span class="s1">d[:] = d[j]</span>
                <span class="s1">i[:] = i[j]</span>
                <span class="s1">i1[:] = i1[j]</span>
            <span class="s1">results.append((dist</span><span class="s0">, </span><span class="s1">ind))</span>

            <span class="s1">assert_allclose(np.concatenate(list(ind))</span><span class="s0">, </span><span class="s1">np.concatenate(list(ind1)))</span>

        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(results) - </span><span class="s2">1</span><span class="s1">):</span>
            <span class="s1">assert_allclose(</span>
                <span class="s1">np.concatenate(list(results[i][</span><span class="s2">0</span><span class="s1">]))</span><span class="s0">,</span>
                <span class="s1">np.concatenate(list(results[i + </span><span class="s2">1</span><span class="s1">][</span><span class="s2">0</span><span class="s1">]))</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">assert_allclose(</span>
                <span class="s1">np.concatenate(list(results[i][</span><span class="s2">1</span><span class="s1">]))</span><span class="s0">,</span>
                <span class="s1">np.concatenate(list(results[i + </span><span class="s2">1</span><span class="s1">][</span><span class="s2">1</span><span class="s1">]))</span><span class="s0">,</span>
            <span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;algorithm&quot;</span><span class="s0">, </span><span class="s1">ALGORITHMS)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;weights&quot;</span><span class="s0">, </span><span class="s1">WEIGHTS)</span>
<span class="s0">def </span><span class="s1">test_kneighbors_classifier(</span>
    <span class="s1">global_dtype</span><span class="s0">,</span>
    <span class="s1">algorithm</span><span class="s0">,</span>
    <span class="s1">weights</span><span class="s0">,</span>
    <span class="s1">n_samples=</span><span class="s2">40</span><span class="s0">,</span>
    <span class="s1">n_features=</span><span class="s2">5</span><span class="s0">,</span>
    <span class="s1">n_test_pts=</span><span class="s2">10</span><span class="s0">,</span>
    <span class="s1">n_neighbors=</span><span class="s2">5</span><span class="s0">,</span>
    <span class="s1">random_state=</span><span class="s2">0</span><span class="s0">,</span>
<span class="s1">):</span>
    <span class="s3"># Test k-neighbors classification</span>
    <span class="s1">rng = np.random.RandomState(random_state)</span>
    <span class="s1">X = </span><span class="s2">2 </span><span class="s1">* rng.rand(n_samples</span><span class="s0">, </span><span class="s1">n_features).astype(global_dtype</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">) - </span><span class="s2">1</span>
    <span class="s1">y = ((X**</span><span class="s2">2</span><span class="s1">).sum(axis=</span><span class="s2">1</span><span class="s1">) &lt; </span><span class="s2">0.5</span><span class="s1">).astype(int)</span>
    <span class="s1">y_str = y.astype(str)</span>

    <span class="s1">knn = neighbors.KNeighborsClassifier(</span>
        <span class="s1">n_neighbors=n_neighbors</span><span class="s0">, </span><span class="s1">weights=weights</span><span class="s0">, </span><span class="s1">algorithm=algorithm</span>
    <span class="s1">)</span>
    <span class="s1">knn.fit(X</span><span class="s0">, </span><span class="s1">y)</span>
    <span class="s1">epsilon = </span><span class="s2">1e-5 </span><span class="s1">* (</span><span class="s2">2 </span><span class="s1">* rng.rand(</span><span class="s2">1</span><span class="s0">, </span><span class="s1">n_features) - </span><span class="s2">1</span><span class="s1">)</span>
    <span class="s1">y_pred = knn.predict(X[:n_test_pts] + epsilon)</span>
    <span class="s1">assert_array_equal(y_pred</span><span class="s0">, </span><span class="s1">y[:n_test_pts])</span>
    <span class="s3"># Test prediction with y_str</span>
    <span class="s1">knn.fit(X</span><span class="s0">, </span><span class="s1">y_str)</span>
    <span class="s1">y_pred = knn.predict(X[:n_test_pts] + epsilon)</span>
    <span class="s1">assert_array_equal(y_pred</span><span class="s0">, </span><span class="s1">y_str[:n_test_pts])</span>


<span class="s0">def </span><span class="s1">test_kneighbors_classifier_float_labels(</span>
    <span class="s1">global_dtype</span><span class="s0">,</span>
    <span class="s1">n_samples=</span><span class="s2">40</span><span class="s0">,</span>
    <span class="s1">n_features=</span><span class="s2">5</span><span class="s0">,</span>
    <span class="s1">n_test_pts=</span><span class="s2">10</span><span class="s0">,</span>
    <span class="s1">n_neighbors=</span><span class="s2">5</span><span class="s0">,</span>
    <span class="s1">random_state=</span><span class="s2">0</span><span class="s0">,</span>
<span class="s1">):</span>
    <span class="s3"># Test k-neighbors classification</span>
    <span class="s1">rng = np.random.RandomState(random_state)</span>
    <span class="s1">X = </span><span class="s2">2 </span><span class="s1">* rng.rand(n_samples</span><span class="s0">, </span><span class="s1">n_features).astype(global_dtype</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">) - </span><span class="s2">1</span>
    <span class="s1">y = ((X**</span><span class="s2">2</span><span class="s1">).sum(axis=</span><span class="s2">1</span><span class="s1">) &lt; </span><span class="s2">0.5</span><span class="s1">).astype(int)</span>

    <span class="s1">knn = neighbors.KNeighborsClassifier(n_neighbors=n_neighbors)</span>
    <span class="s1">knn.fit(X</span><span class="s0">, </span><span class="s1">y.astype(float))</span>
    <span class="s1">epsilon = </span><span class="s2">1e-5 </span><span class="s1">* (</span><span class="s2">2 </span><span class="s1">* rng.rand(</span><span class="s2">1</span><span class="s0">, </span><span class="s1">n_features) - </span><span class="s2">1</span><span class="s1">)</span>
    <span class="s1">y_pred = knn.predict(X[:n_test_pts] + epsilon)</span>
    <span class="s1">assert_array_equal(y_pred</span><span class="s0">, </span><span class="s1">y[:n_test_pts])</span>


<span class="s0">def </span><span class="s1">test_kneighbors_classifier_predict_proba(global_dtype):</span>
    <span class="s3"># Test KNeighborsClassifier.predict_proba() method</span>
    <span class="s1">X = np.array(</span>
        <span class="s1">[[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]]</span>
    <span class="s1">).astype(global_dtype</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">y = np.array([</span><span class="s2">4</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
    <span class="s1">cls = neighbors.KNeighborsClassifier(n_neighbors=</span><span class="s2">3</span><span class="s0">, </span><span class="s1">p=</span><span class="s2">1</span><span class="s1">)  </span><span class="s3"># cityblock dist</span>
    <span class="s1">cls.fit(X</span><span class="s0">, </span><span class="s1">y)</span>
    <span class="s1">y_prob = cls.predict_proba(X)</span>
    <span class="s1">real_prob = (</span>
        <span class="s1">np.array(</span>
            <span class="s1">[</span>
                <span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">/ </span><span class="s2">3.0</span>
    <span class="s1">)</span>
    <span class="s1">assert_array_equal(real_prob</span><span class="s0">, </span><span class="s1">y_prob)</span>
    <span class="s3"># Check that it also works with non integer labels</span>
    <span class="s1">cls.fit(X</span><span class="s0">, </span><span class="s1">y.astype(str))</span>
    <span class="s1">y_prob = cls.predict_proba(X)</span>
    <span class="s1">assert_array_equal(real_prob</span><span class="s0">, </span><span class="s1">y_prob)</span>
    <span class="s3"># Check that it works with weights='distance'</span>
    <span class="s1">cls = neighbors.KNeighborsClassifier(n_neighbors=</span><span class="s2">2</span><span class="s0">, </span><span class="s1">p=</span><span class="s2">1</span><span class="s0">, </span><span class="s1">weights=</span><span class="s4">&quot;distance&quot;</span><span class="s1">)</span>
    <span class="s1">cls.fit(X</span><span class="s0">, </span><span class="s1">y)</span>
    <span class="s1">y_prob = cls.predict_proba(np.array([[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]]))</span>
    <span class="s1">real_prob = np.array([[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0.4</span><span class="s0">, </span><span class="s2">0.6</span><span class="s1">]])</span>
    <span class="s1">assert_allclose(real_prob</span><span class="s0">, </span><span class="s1">y_prob)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;algorithm&quot;</span><span class="s0">, </span><span class="s1">ALGORITHMS)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;weights&quot;</span><span class="s0">, </span><span class="s1">WEIGHTS)</span>
<span class="s0">def </span><span class="s1">test_radius_neighbors_classifier(</span>
    <span class="s1">global_dtype</span><span class="s0">,</span>
    <span class="s1">algorithm</span><span class="s0">,</span>
    <span class="s1">weights</span><span class="s0">,</span>
    <span class="s1">n_samples=</span><span class="s2">40</span><span class="s0">,</span>
    <span class="s1">n_features=</span><span class="s2">5</span><span class="s0">,</span>
    <span class="s1">n_test_pts=</span><span class="s2">10</span><span class="s0">,</span>
    <span class="s1">radius=</span><span class="s2">0.5</span><span class="s0">,</span>
    <span class="s1">random_state=</span><span class="s2">0</span><span class="s0">,</span>
<span class="s1">):</span>
    <span class="s3"># Test radius-based classification</span>
    <span class="s1">rng = np.random.RandomState(random_state)</span>
    <span class="s1">X = </span><span class="s2">2 </span><span class="s1">* rng.rand(n_samples</span><span class="s0">, </span><span class="s1">n_features).astype(global_dtype</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">) - </span><span class="s2">1</span>
    <span class="s1">y = ((X**</span><span class="s2">2</span><span class="s1">).sum(axis=</span><span class="s2">1</span><span class="s1">) &lt; radius).astype(int)</span>
    <span class="s1">y_str = y.astype(str)</span>

    <span class="s1">neigh = neighbors.RadiusNeighborsClassifier(</span>
        <span class="s1">radius=radius</span><span class="s0">, </span><span class="s1">weights=weights</span><span class="s0">, </span><span class="s1">algorithm=algorithm</span>
    <span class="s1">)</span>
    <span class="s1">neigh.fit(X</span><span class="s0">, </span><span class="s1">y)</span>
    <span class="s1">epsilon = </span><span class="s2">1e-5 </span><span class="s1">* (</span><span class="s2">2 </span><span class="s1">* rng.rand(</span><span class="s2">1</span><span class="s0">, </span><span class="s1">n_features) - </span><span class="s2">1</span><span class="s1">)</span>
    <span class="s1">y_pred = neigh.predict(X[:n_test_pts] + epsilon)</span>
    <span class="s1">assert_array_equal(y_pred</span><span class="s0">, </span><span class="s1">y[:n_test_pts])</span>
    <span class="s1">neigh.fit(X</span><span class="s0">, </span><span class="s1">y_str)</span>
    <span class="s1">y_pred = neigh.predict(X[:n_test_pts] + epsilon)</span>
    <span class="s1">assert_array_equal(y_pred</span><span class="s0">, </span><span class="s1">y_str[:n_test_pts])</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;algorithm&quot;</span><span class="s0">, </span><span class="s1">ALGORITHMS)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;weights&quot;</span><span class="s0">, </span><span class="s1">WEIGHTS)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;outlier_label&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, None</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_radius_neighbors_classifier_when_no_neighbors(</span>
    <span class="s1">global_dtype</span><span class="s0">, </span><span class="s1">algorithm</span><span class="s0">, </span><span class="s1">weights</span><span class="s0">, </span><span class="s1">outlier_label</span>
<span class="s1">):</span>
    <span class="s3"># Test radius-based classifier when no neighbors found.</span>
    <span class="s3"># In this case it should rise an informative exception</span>

    <span class="s1">X = np.array([[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2.0</span><span class="s0">, </span><span class="s2">2.0</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">dtype=global_dtype)</span>
    <span class="s1">y = np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>
    <span class="s1">radius = </span><span class="s2">0.1</span>

    <span class="s3"># no outliers</span>
    <span class="s1">z1 = np.array([[</span><span class="s2">1.01</span><span class="s0">, </span><span class="s2">1.01</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2.01</span><span class="s0">, </span><span class="s2">2.01</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">dtype=global_dtype)</span>

    <span class="s3"># one outlier</span>
    <span class="s1">z2 = np.array([[</span><span class="s2">1.01</span><span class="s0">, </span><span class="s2">1.01</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.4</span><span class="s0">, </span><span class="s2">1.4</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">dtype=global_dtype)</span>

    <span class="s1">rnc = neighbors.RadiusNeighborsClassifier</span>
    <span class="s1">clf = rnc(</span>
        <span class="s1">radius=radius</span><span class="s0">,</span>
        <span class="s1">weights=weights</span><span class="s0">,</span>
        <span class="s1">algorithm=algorithm</span><span class="s0">,</span>
        <span class="s1">outlier_label=outlier_label</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">clf.fit(X</span><span class="s0">, </span><span class="s1">y)</span>
    <span class="s1">assert_array_equal(np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span><span class="s0">, </span><span class="s1">clf.predict(z1))</span>
    <span class="s0">if </span><span class="s1">outlier_label </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">clf.predict(z2)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;algorithm&quot;</span><span class="s0">, </span><span class="s1">ALGORITHMS)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;weights&quot;</span><span class="s0">, </span><span class="s1">WEIGHTS)</span>
<span class="s0">def </span><span class="s1">test_radius_neighbors_classifier_outlier_labeling(global_dtype</span><span class="s0">, </span><span class="s1">algorithm</span><span class="s0">, </span><span class="s1">weights):</span>
    <span class="s3"># Test radius-based classifier when no neighbors found and outliers</span>
    <span class="s3"># are labeled.</span>

    <span class="s1">X = np.array(</span>
        <span class="s1">[[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2.0</span><span class="s0">, </span><span class="s2">2.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.99</span><span class="s0">, </span><span class="s2">0.99</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.98</span><span class="s0">, </span><span class="s2">0.98</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2.01</span><span class="s0">, </span><span class="s2">2.01</span><span class="s1">]]</span><span class="s0">,</span>
        <span class="s1">dtype=global_dtype</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">y = np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>
    <span class="s1">radius = </span><span class="s2">0.1</span>

    <span class="s3"># no outliers</span>
    <span class="s1">z1 = np.array([[</span><span class="s2">1.01</span><span class="s0">, </span><span class="s2">1.01</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2.01</span><span class="s0">, </span><span class="s2">2.01</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">dtype=global_dtype)</span>

    <span class="s3"># one outlier</span>
    <span class="s1">z2 = np.array([[</span><span class="s2">1.4</span><span class="s0">, </span><span class="s2">1.4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.01</span><span class="s0">, </span><span class="s2">1.01</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2.01</span><span class="s0">, </span><span class="s2">2.01</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">dtype=global_dtype)</span>

    <span class="s1">correct_labels1 = np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>
    <span class="s1">correct_labels2 = np.array([-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>
    <span class="s1">outlier_proba = np.array([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">])</span>

    <span class="s1">clf = neighbors.RadiusNeighborsClassifier(</span>
        <span class="s1">radius=radius</span><span class="s0">, </span><span class="s1">weights=weights</span><span class="s0">, </span><span class="s1">algorithm=algorithm</span><span class="s0">, </span><span class="s1">outlier_label=-</span><span class="s2">1</span>
    <span class="s1">)</span>
    <span class="s1">clf.fit(X</span><span class="s0">, </span><span class="s1">y)</span>
    <span class="s1">assert_array_equal(correct_labels1</span><span class="s0">, </span><span class="s1">clf.predict(z1))</span>
    <span class="s0">with </span><span class="s1">pytest.warns(UserWarning</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;Outlier label -1 is not in training classes&quot;</span><span class="s1">):</span>
        <span class="s1">assert_array_equal(correct_labels2</span><span class="s0">, </span><span class="s1">clf.predict(z2))</span>
    <span class="s0">with </span><span class="s1">pytest.warns(UserWarning</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;Outlier label -1 is not in training classes&quot;</span><span class="s1">):</span>
        <span class="s1">assert_allclose(outlier_proba</span><span class="s0">, </span><span class="s1">clf.predict_proba(z2)[</span><span class="s2">0</span><span class="s1">])</span>

    <span class="s3"># test outlier_labeling of using predict_proba()</span>
    <span class="s1">RNC = neighbors.RadiusNeighborsClassifier</span>
    <span class="s1">X = np.array([[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">6</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">7</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">8</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">9</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">dtype=global_dtype)</span>
    <span class="s1">y = np.array([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>

    <span class="s3"># test outlier_label scalar verification</span>
    <span class="s0">def </span><span class="s1">check_array_exception():</span>
        <span class="s1">clf = RNC(radius=</span><span class="s2">1</span><span class="s0">, </span><span class="s1">outlier_label=[[</span><span class="s2">5</span><span class="s1">]])</span>
        <span class="s1">clf.fit(X</span><span class="s0">, </span><span class="s1">y)</span>

    <span class="s0">with </span><span class="s1">pytest.raises(TypeError):</span>
        <span class="s1">check_array_exception()</span>

    <span class="s3"># test invalid outlier_label dtype</span>
    <span class="s0">def </span><span class="s1">check_dtype_exception():</span>
        <span class="s1">clf = RNC(radius=</span><span class="s2">1</span><span class="s0">, </span><span class="s1">outlier_label=</span><span class="s4">&quot;a&quot;</span><span class="s1">)</span>
        <span class="s1">clf.fit(X</span><span class="s0">, </span><span class="s1">y)</span>

    <span class="s0">with </span><span class="s1">pytest.raises(TypeError):</span>
        <span class="s1">check_dtype_exception()</span>

    <span class="s3"># test most frequent</span>
    <span class="s1">clf = RNC(radius=</span><span class="s2">1</span><span class="s0">, </span><span class="s1">outlier_label=</span><span class="s4">&quot;most_frequent&quot;</span><span class="s1">)</span>
    <span class="s1">clf.fit(X</span><span class="s0">, </span><span class="s1">y)</span>
    <span class="s1">proba = clf.predict_proba([[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">15</span><span class="s1">]])</span>
    <span class="s1">assert_array_equal(proba[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">:]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>

    <span class="s3"># test manual label in y</span>
    <span class="s1">clf = RNC(radius=</span><span class="s2">1</span><span class="s0">, </span><span class="s1">outlier_label=</span><span class="s2">1</span><span class="s1">)</span>
    <span class="s1">clf.fit(X</span><span class="s0">, </span><span class="s1">y)</span>
    <span class="s1">proba = clf.predict_proba([[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">15</span><span class="s1">]])</span>
    <span class="s1">assert_array_equal(proba[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">:]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">])</span>
    <span class="s1">pred = clf.predict([[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">15</span><span class="s1">]])</span>
    <span class="s1">assert_array_equal(pred</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>

    <span class="s3"># test manual label out of y warning</span>
    <span class="s0">def </span><span class="s1">check_warning():</span>
        <span class="s1">clf = RNC(radius=</span><span class="s2">1</span><span class="s0">, </span><span class="s1">outlier_label=</span><span class="s2">4</span><span class="s1">)</span>
        <span class="s1">clf.fit(X</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s1">clf.predict_proba([[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">15</span><span class="s1">]])</span>

    <span class="s0">with </span><span class="s1">pytest.warns(UserWarning):</span>
        <span class="s1">check_warning()</span>

    <span class="s3"># test multi output same outlier label</span>
    <span class="s1">y_multi = [</span>
        <span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">]</span>
    <span class="s1">clf = RNC(radius=</span><span class="s2">1</span><span class="s0">, </span><span class="s1">outlier_label=</span><span class="s2">1</span><span class="s1">)</span>
    <span class="s1">clf.fit(X</span><span class="s0">, </span><span class="s1">y_multi)</span>
    <span class="s1">proba = clf.predict_proba([[</span><span class="s2">7</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">15</span><span class="s1">]])</span>
    <span class="s1">assert_array_equal(proba[</span><span class="s2">1</span><span class="s1">][</span><span class="s2">1</span><span class="s0">, </span><span class="s1">:]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">])</span>
    <span class="s1">pred = clf.predict([[</span><span class="s2">7</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">15</span><span class="s1">]])</span>
    <span class="s1">assert_array_equal(pred[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">:]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>

    <span class="s3"># test multi output different outlier label</span>
    <span class="s1">y_multi = [</span>
        <span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">]</span>
    <span class="s1">clf = RNC(radius=</span><span class="s2">1</span><span class="s0">, </span><span class="s1">outlier_label=[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
    <span class="s1">clf.fit(X</span><span class="s0">, </span><span class="s1">y_multi)</span>
    <span class="s1">proba = clf.predict_proba([[</span><span class="s2">7</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">15</span><span class="s1">]])</span>
    <span class="s1">assert_array_equal(proba[</span><span class="s2">0</span><span class="s1">][</span><span class="s2">1</span><span class="s0">, </span><span class="s1">:]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(proba[</span><span class="s2">1</span><span class="s1">][</span><span class="s2">1</span><span class="s0">, </span><span class="s1">:]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">])</span>
    <span class="s1">pred = clf.predict([[</span><span class="s2">7</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">15</span><span class="s1">]])</span>
    <span class="s1">assert_array_equal(pred[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">:]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>

    <span class="s3"># test inconsistent outlier label list length</span>
    <span class="s0">def </span><span class="s1">check_exception():</span>
        <span class="s1">clf = RNC(radius=</span><span class="s2">1</span><span class="s0">, </span><span class="s1">outlier_label=[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>
        <span class="s1">clf.fit(X</span><span class="s0">, </span><span class="s1">y_multi)</span>

    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">check_exception()</span>


<span class="s0">def </span><span class="s1">test_radius_neighbors_classifier_zero_distance():</span>
    <span class="s3"># Test radius-based classifier, when distance to a sample is zero.</span>

    <span class="s1">X = np.array([[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2.0</span><span class="s0">, </span><span class="s2">2.0</span><span class="s1">]])</span>
    <span class="s1">y = np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>
    <span class="s1">radius = </span><span class="s2">0.1</span>

    <span class="s1">z1 = np.array([[</span><span class="s2">1.01</span><span class="s0">, </span><span class="s2">1.01</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2.0</span><span class="s0">, </span><span class="s2">2.0</span><span class="s1">]])</span>
    <span class="s1">correct_labels1 = np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>

    <span class="s1">weight_func = _weight_func</span>

    <span class="s0">for </span><span class="s1">algorithm </span><span class="s0">in </span><span class="s1">ALGORITHMS:</span>
        <span class="s0">for </span><span class="s1">weights </span><span class="s0">in </span><span class="s1">[</span><span class="s4">&quot;uniform&quot;</span><span class="s0">, </span><span class="s4">&quot;distance&quot;</span><span class="s0">, </span><span class="s1">weight_func]:</span>
            <span class="s1">clf = neighbors.RadiusNeighborsClassifier(</span>
                <span class="s1">radius=radius</span><span class="s0">, </span><span class="s1">weights=weights</span><span class="s0">, </span><span class="s1">algorithm=algorithm</span>
            <span class="s1">)</span>
            <span class="s1">clf.fit(X</span><span class="s0">, </span><span class="s1">y)</span>
            <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s4">&quot;ignore&quot;</span><span class="s1">):</span>
                <span class="s3"># Ignore the warning raised in _weight_func when making</span>
                <span class="s3"># predictions with null distances resulting in np.inf values.</span>
                <span class="s1">assert_array_equal(correct_labels1</span><span class="s0">, </span><span class="s1">clf.predict(z1))</span>


<span class="s0">def </span><span class="s1">test_neighbors_regressors_zero_distance():</span>
    <span class="s3"># Test radius-based regressor, when distance to a sample is zero.</span>

    <span class="s1">X = np.array([[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2.0</span><span class="s0">, </span><span class="s2">2.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2.5</span><span class="s0">, </span><span class="s2">2.5</span><span class="s1">]])</span>
    <span class="s1">y = np.array([</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.5</span><span class="s0">, </span><span class="s2">2.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">])</span>
    <span class="s1">radius = </span><span class="s2">0.2</span>
    <span class="s1">z = np.array([[</span><span class="s2">1.1</span><span class="s0">, </span><span class="s2">1.1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2.0</span><span class="s0">, </span><span class="s2">2.0</span><span class="s1">]])</span>

    <span class="s1">rnn_correct_labels = np.array([</span><span class="s2">1.25</span><span class="s0">, </span><span class="s2">2.0</span><span class="s1">])</span>

    <span class="s1">knn_correct_unif = np.array([</span><span class="s2">1.25</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">])</span>
    <span class="s1">knn_correct_dist = np.array([</span><span class="s2">1.25</span><span class="s0">, </span><span class="s2">2.0</span><span class="s1">])</span>

    <span class="s0">for </span><span class="s1">algorithm </span><span class="s0">in </span><span class="s1">ALGORITHMS:</span>
        <span class="s3"># we don't test for weights=_weight_func since user will be expected</span>
        <span class="s3"># to handle zero distances themselves in the function.</span>
        <span class="s0">for </span><span class="s1">weights </span><span class="s0">in </span><span class="s1">[</span><span class="s4">&quot;uniform&quot;</span><span class="s0">, </span><span class="s4">&quot;distance&quot;</span><span class="s1">]:</span>
            <span class="s1">rnn = neighbors.RadiusNeighborsRegressor(</span>
                <span class="s1">radius=radius</span><span class="s0">, </span><span class="s1">weights=weights</span><span class="s0">, </span><span class="s1">algorithm=algorithm</span>
            <span class="s1">)</span>
            <span class="s1">rnn.fit(X</span><span class="s0">, </span><span class="s1">y)</span>
            <span class="s1">assert_allclose(rnn_correct_labels</span><span class="s0">, </span><span class="s1">rnn.predict(z))</span>

        <span class="s0">for </span><span class="s1">weights</span><span class="s0">, </span><span class="s1">corr_labels </span><span class="s0">in </span><span class="s1">zip(</span>
            <span class="s1">[</span><span class="s4">&quot;uniform&quot;</span><span class="s0">, </span><span class="s4">&quot;distance&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[knn_correct_unif</span><span class="s0">, </span><span class="s1">knn_correct_dist]</span>
        <span class="s1">):</span>
            <span class="s1">knn = neighbors.KNeighborsRegressor(</span>
                <span class="s1">n_neighbors=</span><span class="s2">2</span><span class="s0">, </span><span class="s1">weights=weights</span><span class="s0">, </span><span class="s1">algorithm=algorithm</span>
            <span class="s1">)</span>
            <span class="s1">knn.fit(X</span><span class="s0">, </span><span class="s1">y)</span>
            <span class="s1">assert_allclose(corr_labels</span><span class="s0">, </span><span class="s1">knn.predict(z))</span>


<span class="s0">def </span><span class="s1">test_radius_neighbors_boundary_handling():</span>
    <span class="s5">&quot;&quot;&quot;Test whether points lying on boundary are handled consistently 
 
    Also ensures that even with only one query point, an object array 
    is returned rather than a 2d array. 
    &quot;&quot;&quot;</span>

    <span class="s1">X = np.array([[</span><span class="s2">1.5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3.01</span><span class="s1">]])</span>
    <span class="s1">radius = </span><span class="s2">3.0</span>

    <span class="s0">for </span><span class="s1">algorithm </span><span class="s0">in </span><span class="s1">ALGORITHMS:</span>
        <span class="s1">nbrs = neighbors.NearestNeighbors(radius=radius</span><span class="s0">, </span><span class="s1">algorithm=algorithm).fit(X)</span>
        <span class="s1">results = nbrs.radius_neighbors([[</span><span class="s2">0.0</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">return_distance=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">results.shape == (</span><span class="s2">1</span><span class="s0">,</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">results.dtype == object</span>
        <span class="s1">assert_array_equal(results[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>


<span class="s0">def </span><span class="s1">test_radius_neighbors_returns_array_of_objects():</span>
    <span class="s3"># check that we can pass precomputed distances to</span>
    <span class="s3"># NearestNeighbors.radius_neighbors()</span>
    <span class="s3"># non-regression test for</span>
    <span class="s3"># https://github.com/scikit-learn/scikit-learn/issues/16036</span>
    <span class="s1">X = csr_matrix(np.ones((</span><span class="s2">4</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)))</span>
    <span class="s1">X.setdiag([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">])</span>

    <span class="s1">nbrs = neighbors.NearestNeighbors(</span>
        <span class="s1">radius=</span><span class="s2">0.5</span><span class="s0">, </span><span class="s1">algorithm=</span><span class="s4">&quot;auto&quot;</span><span class="s0">, </span><span class="s1">leaf_size=</span><span class="s2">30</span><span class="s0">, </span><span class="s1">metric=</span><span class="s4">&quot;precomputed&quot;</span>
    <span class="s1">).fit(X)</span>
    <span class="s1">neigh_dist</span><span class="s0">, </span><span class="s1">neigh_ind = nbrs.radius_neighbors(X</span><span class="s0">, </span><span class="s1">return_distance=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s1">expected_dist = np.empty(X.shape[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=object)</span>
    <span class="s1">expected_dist[:] = [np.array([</span><span class="s2">0</span><span class="s1">])</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s2">0</span><span class="s1">])</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s2">0</span><span class="s1">])</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s2">0</span><span class="s1">])]</span>
    <span class="s1">expected_ind = np.empty(X.shape[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=object)</span>
    <span class="s1">expected_ind[:] = [np.array([</span><span class="s2">0</span><span class="s1">])</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s2">1</span><span class="s1">])</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s2">2</span><span class="s1">])</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s2">3</span><span class="s1">])]</span>

    <span class="s1">assert_array_equal(neigh_dist</span><span class="s0">, </span><span class="s1">expected_dist)</span>
    <span class="s1">assert_array_equal(neigh_ind</span><span class="s0">, </span><span class="s1">expected_ind)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;algorithm&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;ball_tree&quot;</span><span class="s0">, </span><span class="s4">&quot;kd_tree&quot;</span><span class="s0">, </span><span class="s4">&quot;brute&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_query_equidistant_kth_nn(algorithm):</span>
    <span class="s3"># For several candidates for the k-th nearest neighbor position,</span>
    <span class="s3"># the first candidate should be chosen</span>
    <span class="s1">query_point = np.array([[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]])</span>
    <span class="s1">equidistant_points = np.array([[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">]])</span>
    <span class="s3"># The 3rd and 4th points should not replace the 2nd point</span>
    <span class="s3"># for the 2th nearest neighbor position</span>
    <span class="s1">k = </span><span class="s2">2</span>
    <span class="s1">knn_indices = np.array([[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]])</span>
    <span class="s1">nn = neighbors.NearestNeighbors(algorithm=algorithm).fit(equidistant_points)</span>
    <span class="s1">indices = np.sort(nn.kneighbors(query_point</span><span class="s0">, </span><span class="s1">n_neighbors=k</span><span class="s0">, </span><span class="s1">return_distance=</span><span class="s0">False</span><span class="s1">))</span>
    <span class="s1">assert_array_equal(indices</span><span class="s0">, </span><span class="s1">knn_indices)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s1">[</span><span class="s4">&quot;algorithm&quot;</span><span class="s0">, </span><span class="s4">&quot;metric&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span><span class="s4">&quot;ball_tree&quot;</span><span class="s0">, </span><span class="s4">&quot;euclidean&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s4">&quot;kd_tree&quot;</span><span class="s0">, </span><span class="s4">&quot;euclidean&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s4">&quot;brute&quot;</span><span class="s0">, </span><span class="s4">&quot;euclidean&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s4">&quot;brute&quot;</span><span class="s0">, </span><span class="s4">&quot;precomputed&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_radius_neighbors_sort_results(algorithm</span><span class="s0">, </span><span class="s1">metric):</span>
    <span class="s3"># Test radius_neighbors[_graph] output when sort_result is True</span>
    <span class="s1">n_samples = </span><span class="s2">10</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s2">42</span><span class="s1">)</span>
    <span class="s1">X = rng.random_sample((n_samples</span><span class="s0">, </span><span class="s2">4</span><span class="s1">))</span>

    <span class="s0">if </span><span class="s1">metric == </span><span class="s4">&quot;precomputed&quot;</span><span class="s1">:</span>
        <span class="s1">X = neighbors.radius_neighbors_graph(X</span><span class="s0">, </span><span class="s1">radius=np.inf</span><span class="s0">, </span><span class="s1">mode=</span><span class="s4">&quot;distance&quot;</span><span class="s1">)</span>
    <span class="s1">model = neighbors.NearestNeighbors(algorithm=algorithm</span><span class="s0">, </span><span class="s1">metric=metric)</span>
    <span class="s1">model.fit(X)</span>

    <span class="s3"># self.radius_neighbors</span>
    <span class="s1">distances</span><span class="s0">, </span><span class="s1">indices = model.radius_neighbors(X=X</span><span class="s0">, </span><span class="s1">radius=np.inf</span><span class="s0">, </span><span class="s1">sort_results=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">for </span><span class="s1">ii </span><span class="s0">in </span><span class="s1">range(n_samples):</span>
        <span class="s1">assert_array_equal(distances[ii]</span><span class="s0">, </span><span class="s1">np.sort(distances[ii]))</span>

    <span class="s3"># sort_results=True and return_distance=False</span>
    <span class="s0">if </span><span class="s1">metric != </span><span class="s4">&quot;precomputed&quot;</span><span class="s1">:  </span><span class="s3"># no need to raise with precomputed graph</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;return_distance must be True&quot;</span><span class="s1">):</span>
            <span class="s1">model.radius_neighbors(</span>
                <span class="s1">X=X</span><span class="s0">, </span><span class="s1">radius=np.inf</span><span class="s0">, </span><span class="s1">sort_results=</span><span class="s0">True, </span><span class="s1">return_distance=</span><span class="s0">False</span>
            <span class="s1">)</span>

    <span class="s3"># self.radius_neighbors_graph</span>
    <span class="s1">graph = model.radius_neighbors_graph(</span>
        <span class="s1">X=X</span><span class="s0">, </span><span class="s1">radius=np.inf</span><span class="s0">, </span><span class="s1">mode=</span><span class="s4">&quot;distance&quot;</span><span class="s0">, </span><span class="s1">sort_results=</span><span class="s0">True</span>
    <span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">_is_sorted_by_data(graph)</span>


<span class="s0">def </span><span class="s1">test_RadiusNeighborsClassifier_multioutput():</span>
    <span class="s3"># Test k-NN classifier on multioutput data</span>
    <span class="s1">rng = check_random_state(</span><span class="s2">0</span><span class="s1">)</span>
    <span class="s1">n_features = </span><span class="s2">2</span>
    <span class="s1">n_samples = </span><span class="s2">40</span>
    <span class="s1">n_output = </span><span class="s2">3</span>

    <span class="s1">X = rng.rand(n_samples</span><span class="s0">, </span><span class="s1">n_features)</span>
    <span class="s1">y = rng.randint(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s1">(n_samples</span><span class="s0">, </span><span class="s1">n_output))</span>

    <span class="s1">X_train</span><span class="s0">, </span><span class="s1">X_test</span><span class="s0">, </span><span class="s1">y_train</span><span class="s0">, </span><span class="s1">y_test = train_test_split(X</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s2">0</span><span class="s1">)</span>

    <span class="s1">weights = [</span><span class="s0">None, </span><span class="s4">&quot;uniform&quot;</span><span class="s0">, </span><span class="s4">&quot;distance&quot;</span><span class="s0">, </span><span class="s1">_weight_func]</span>

    <span class="s0">for </span><span class="s1">algorithm</span><span class="s0">, </span><span class="s1">weights </span><span class="s0">in </span><span class="s1">product(ALGORITHMS</span><span class="s0">, </span><span class="s1">weights):</span>
        <span class="s3"># Stack single output prediction</span>
        <span class="s1">y_pred_so = []</span>
        <span class="s0">for </span><span class="s1">o </span><span class="s0">in </span><span class="s1">range(n_output):</span>
            <span class="s1">rnn = neighbors.RadiusNeighborsClassifier(</span>
                <span class="s1">weights=weights</span><span class="s0">, </span><span class="s1">algorithm=algorithm</span>
            <span class="s1">)</span>
            <span class="s1">rnn.fit(X_train</span><span class="s0">, </span><span class="s1">y_train[:</span><span class="s0">, </span><span class="s1">o])</span>
            <span class="s1">y_pred_so.append(rnn.predict(X_test))</span>

        <span class="s1">y_pred_so = np.vstack(y_pred_so).T</span>
        <span class="s0">assert </span><span class="s1">y_pred_so.shape == y_test.shape</span>

        <span class="s3"># Multioutput prediction</span>
        <span class="s1">rnn_mo = neighbors.RadiusNeighborsClassifier(</span>
            <span class="s1">weights=weights</span><span class="s0">, </span><span class="s1">algorithm=algorithm</span>
        <span class="s1">)</span>
        <span class="s1">rnn_mo.fit(X_train</span><span class="s0">, </span><span class="s1">y_train)</span>
        <span class="s1">y_pred_mo = rnn_mo.predict(X_test)</span>

        <span class="s0">assert </span><span class="s1">y_pred_mo.shape == y_test.shape</span>
        <span class="s1">assert_array_equal(y_pred_mo</span><span class="s0">, </span><span class="s1">y_pred_so)</span>


<span class="s0">def </span><span class="s1">test_kneighbors_classifier_sparse(</span>
    <span class="s1">n_samples=</span><span class="s2">40</span><span class="s0">, </span><span class="s1">n_features=</span><span class="s2">5</span><span class="s0">, </span><span class="s1">n_test_pts=</span><span class="s2">10</span><span class="s0">, </span><span class="s1">n_neighbors=</span><span class="s2">5</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s2">0</span>
<span class="s1">):</span>
    <span class="s3"># Test k-NN classifier on sparse matrices</span>
    <span class="s3"># Like the above, but with various types of sparse matrices</span>
    <span class="s1">rng = np.random.RandomState(random_state)</span>
    <span class="s1">X = </span><span class="s2">2 </span><span class="s1">* rng.rand(n_samples</span><span class="s0">, </span><span class="s1">n_features) - </span><span class="s2">1</span>
    <span class="s1">X *= X &gt; </span><span class="s2">0.2</span>
    <span class="s1">y = ((X**</span><span class="s2">2</span><span class="s1">).sum(axis=</span><span class="s2">1</span><span class="s1">) &lt; </span><span class="s2">0.5</span><span class="s1">).astype(int)</span>

    <span class="s0">for </span><span class="s1">sparsemat </span><span class="s0">in </span><span class="s1">SPARSE_TYPES:</span>
        <span class="s1">knn = neighbors.KNeighborsClassifier(n_neighbors=n_neighbors</span><span class="s0">, </span><span class="s1">algorithm=</span><span class="s4">&quot;auto&quot;</span><span class="s1">)</span>
        <span class="s1">knn.fit(sparsemat(X)</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s1">epsilon = </span><span class="s2">1e-5 </span><span class="s1">* (</span><span class="s2">2 </span><span class="s1">* rng.rand(</span><span class="s2">1</span><span class="s0">, </span><span class="s1">n_features) - </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">sparsev </span><span class="s0">in </span><span class="s1">SPARSE_TYPES + (np.asarray</span><span class="s0">,</span><span class="s1">):</span>
            <span class="s1">X_eps = sparsev(X[:n_test_pts] + epsilon)</span>
            <span class="s1">y_pred = knn.predict(X_eps)</span>
            <span class="s1">assert_array_equal(y_pred</span><span class="s0">, </span><span class="s1">y[:n_test_pts])</span>


<span class="s0">def </span><span class="s1">test_KNeighborsClassifier_multioutput():</span>
    <span class="s3"># Test k-NN classifier on multioutput data</span>
    <span class="s1">rng = check_random_state(</span><span class="s2">0</span><span class="s1">)</span>
    <span class="s1">n_features = </span><span class="s2">5</span>
    <span class="s1">n_samples = </span><span class="s2">50</span>
    <span class="s1">n_output = </span><span class="s2">3</span>

    <span class="s1">X = rng.rand(n_samples</span><span class="s0">, </span><span class="s1">n_features)</span>
    <span class="s1">y = rng.randint(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s1">(n_samples</span><span class="s0">, </span><span class="s1">n_output))</span>

    <span class="s1">X_train</span><span class="s0">, </span><span class="s1">X_test</span><span class="s0">, </span><span class="s1">y_train</span><span class="s0">, </span><span class="s1">y_test = train_test_split(X</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s2">0</span><span class="s1">)</span>

    <span class="s1">weights = [</span><span class="s0">None, </span><span class="s4">&quot;uniform&quot;</span><span class="s0">, </span><span class="s4">&quot;distance&quot;</span><span class="s0">, </span><span class="s1">_weight_func]</span>

    <span class="s0">for </span><span class="s1">algorithm</span><span class="s0">, </span><span class="s1">weights </span><span class="s0">in </span><span class="s1">product(ALGORITHMS</span><span class="s0">, </span><span class="s1">weights):</span>
        <span class="s3"># Stack single output prediction</span>
        <span class="s1">y_pred_so = []</span>
        <span class="s1">y_pred_proba_so = []</span>
        <span class="s0">for </span><span class="s1">o </span><span class="s0">in </span><span class="s1">range(n_output):</span>
            <span class="s1">knn = neighbors.KNeighborsClassifier(weights=weights</span><span class="s0">, </span><span class="s1">algorithm=algorithm)</span>
            <span class="s1">knn.fit(X_train</span><span class="s0">, </span><span class="s1">y_train[:</span><span class="s0">, </span><span class="s1">o])</span>
            <span class="s1">y_pred_so.append(knn.predict(X_test))</span>
            <span class="s1">y_pred_proba_so.append(knn.predict_proba(X_test))</span>

        <span class="s1">y_pred_so = np.vstack(y_pred_so).T</span>
        <span class="s0">assert </span><span class="s1">y_pred_so.shape == y_test.shape</span>
        <span class="s0">assert </span><span class="s1">len(y_pred_proba_so) == n_output</span>

        <span class="s3"># Multioutput prediction</span>
        <span class="s1">knn_mo = neighbors.KNeighborsClassifier(weights=weights</span><span class="s0">, </span><span class="s1">algorithm=algorithm)</span>
        <span class="s1">knn_mo.fit(X_train</span><span class="s0">, </span><span class="s1">y_train)</span>
        <span class="s1">y_pred_mo = knn_mo.predict(X_test)</span>

        <span class="s0">assert </span><span class="s1">y_pred_mo.shape == y_test.shape</span>
        <span class="s1">assert_array_equal(y_pred_mo</span><span class="s0">, </span><span class="s1">y_pred_so)</span>

        <span class="s3"># Check proba</span>
        <span class="s1">y_pred_proba_mo = knn_mo.predict_proba(X_test)</span>
        <span class="s0">assert </span><span class="s1">len(y_pred_proba_mo) == n_output</span>

        <span class="s0">for </span><span class="s1">proba_mo</span><span class="s0">, </span><span class="s1">proba_so </span><span class="s0">in </span><span class="s1">zip(y_pred_proba_mo</span><span class="s0">, </span><span class="s1">y_pred_proba_so):</span>
            <span class="s1">assert_array_equal(proba_mo</span><span class="s0">, </span><span class="s1">proba_so)</span>


<span class="s0">def </span><span class="s1">test_kneighbors_regressor(</span>
    <span class="s1">n_samples=</span><span class="s2">40</span><span class="s0">, </span><span class="s1">n_features=</span><span class="s2">5</span><span class="s0">, </span><span class="s1">n_test_pts=</span><span class="s2">10</span><span class="s0">, </span><span class="s1">n_neighbors=</span><span class="s2">3</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s2">0</span>
<span class="s1">):</span>
    <span class="s3"># Test k-neighbors regression</span>
    <span class="s1">rng = np.random.RandomState(random_state)</span>
    <span class="s1">X = </span><span class="s2">2 </span><span class="s1">* rng.rand(n_samples</span><span class="s0">, </span><span class="s1">n_features) - </span><span class="s2">1</span>
    <span class="s1">y = np.sqrt((X**</span><span class="s2">2</span><span class="s1">).sum(</span><span class="s2">1</span><span class="s1">))</span>
    <span class="s1">y /= y.max()</span>

    <span class="s1">y_target = y[:n_test_pts]</span>

    <span class="s1">weight_func = _weight_func</span>

    <span class="s0">for </span><span class="s1">algorithm </span><span class="s0">in </span><span class="s1">ALGORITHMS:</span>
        <span class="s0">for </span><span class="s1">weights </span><span class="s0">in </span><span class="s1">[</span><span class="s4">&quot;uniform&quot;</span><span class="s0">, </span><span class="s4">&quot;distance&quot;</span><span class="s0">, </span><span class="s1">weight_func]:</span>
            <span class="s1">knn = neighbors.KNeighborsRegressor(</span>
                <span class="s1">n_neighbors=n_neighbors</span><span class="s0">, </span><span class="s1">weights=weights</span><span class="s0">, </span><span class="s1">algorithm=algorithm</span>
            <span class="s1">)</span>
            <span class="s1">knn.fit(X</span><span class="s0">, </span><span class="s1">y)</span>
            <span class="s1">epsilon = </span><span class="s2">1e-5 </span><span class="s1">* (</span><span class="s2">2 </span><span class="s1">* rng.rand(</span><span class="s2">1</span><span class="s0">, </span><span class="s1">n_features) - </span><span class="s2">1</span><span class="s1">)</span>
            <span class="s1">y_pred = knn.predict(X[:n_test_pts] + epsilon)</span>
            <span class="s0">assert </span><span class="s1">np.all(abs(y_pred - y_target) &lt; </span><span class="s2">0.3</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_KNeighborsRegressor_multioutput_uniform_weight():</span>
    <span class="s3"># Test k-neighbors in multi-output regression with uniform weight</span>
    <span class="s1">rng = check_random_state(</span><span class="s2">0</span><span class="s1">)</span>
    <span class="s1">n_features = </span><span class="s2">5</span>
    <span class="s1">n_samples = </span><span class="s2">40</span>
    <span class="s1">n_output = </span><span class="s2">4</span>

    <span class="s1">X = rng.rand(n_samples</span><span class="s0">, </span><span class="s1">n_features)</span>
    <span class="s1">y = rng.rand(n_samples</span><span class="s0">, </span><span class="s1">n_output)</span>

    <span class="s1">X_train</span><span class="s0">, </span><span class="s1">X_test</span><span class="s0">, </span><span class="s1">y_train</span><span class="s0">, </span><span class="s1">y_test = train_test_split(X</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s2">0</span><span class="s1">)</span>
    <span class="s0">for </span><span class="s1">algorithm</span><span class="s0">, </span><span class="s1">weights </span><span class="s0">in </span><span class="s1">product(ALGORITHMS</span><span class="s0">, </span><span class="s1">[</span><span class="s0">None, </span><span class="s4">&quot;uniform&quot;</span><span class="s1">]):</span>
        <span class="s1">knn = neighbors.KNeighborsRegressor(weights=weights</span><span class="s0">, </span><span class="s1">algorithm=algorithm)</span>
        <span class="s1">knn.fit(X_train</span><span class="s0">, </span><span class="s1">y_train)</span>

        <span class="s1">neigh_idx = knn.kneighbors(X_test</span><span class="s0">, </span><span class="s1">return_distance=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">y_pred_idx = np.array([np.mean(y_train[idx]</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">0</span><span class="s1">) </span><span class="s0">for </span><span class="s1">idx </span><span class="s0">in </span><span class="s1">neigh_idx])</span>

        <span class="s1">y_pred = knn.predict(X_test)</span>

        <span class="s0">assert </span><span class="s1">y_pred.shape == y_test.shape</span>
        <span class="s0">assert </span><span class="s1">y_pred_idx.shape == y_test.shape</span>
        <span class="s1">assert_allclose(y_pred</span><span class="s0">, </span><span class="s1">y_pred_idx)</span>


<span class="s0">def </span><span class="s1">test_kneighbors_regressor_multioutput(</span>
    <span class="s1">n_samples=</span><span class="s2">40</span><span class="s0">, </span><span class="s1">n_features=</span><span class="s2">5</span><span class="s0">, </span><span class="s1">n_test_pts=</span><span class="s2">10</span><span class="s0">, </span><span class="s1">n_neighbors=</span><span class="s2">3</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s2">0</span>
<span class="s1">):</span>
    <span class="s3"># Test k-neighbors in multi-output regression</span>
    <span class="s1">rng = np.random.RandomState(random_state)</span>
    <span class="s1">X = </span><span class="s2">2 </span><span class="s1">* rng.rand(n_samples</span><span class="s0">, </span><span class="s1">n_features) - </span><span class="s2">1</span>
    <span class="s1">y = np.sqrt((X**</span><span class="s2">2</span><span class="s1">).sum(</span><span class="s2">1</span><span class="s1">))</span>
    <span class="s1">y /= y.max()</span>
    <span class="s1">y = np.vstack([y</span><span class="s0">, </span><span class="s1">y]).T</span>

    <span class="s1">y_target = y[:n_test_pts]</span>

    <span class="s1">weights = [</span><span class="s4">&quot;uniform&quot;</span><span class="s0">, </span><span class="s4">&quot;distance&quot;</span><span class="s0">, </span><span class="s1">_weight_func]</span>
    <span class="s0">for </span><span class="s1">algorithm</span><span class="s0">, </span><span class="s1">weights </span><span class="s0">in </span><span class="s1">product(ALGORITHMS</span><span class="s0">, </span><span class="s1">weights):</span>
        <span class="s1">knn = neighbors.KNeighborsRegressor(</span>
            <span class="s1">n_neighbors=n_neighbors</span><span class="s0">, </span><span class="s1">weights=weights</span><span class="s0">, </span><span class="s1">algorithm=algorithm</span>
        <span class="s1">)</span>
        <span class="s1">knn.fit(X</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s1">epsilon = </span><span class="s2">1e-5 </span><span class="s1">* (</span><span class="s2">2 </span><span class="s1">* rng.rand(</span><span class="s2">1</span><span class="s0">, </span><span class="s1">n_features) - </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">y_pred = knn.predict(X[:n_test_pts] + epsilon)</span>
        <span class="s0">assert </span><span class="s1">y_pred.shape == y_target.shape</span>

        <span class="s0">assert </span><span class="s1">np.all(np.abs(y_pred - y_target) &lt; </span><span class="s2">0.3</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_radius_neighbors_regressor(</span>
    <span class="s1">n_samples=</span><span class="s2">40</span><span class="s0">, </span><span class="s1">n_features=</span><span class="s2">3</span><span class="s0">, </span><span class="s1">n_test_pts=</span><span class="s2">10</span><span class="s0">, </span><span class="s1">radius=</span><span class="s2">0.5</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s2">0</span>
<span class="s1">):</span>
    <span class="s3"># Test radius-based neighbors regression</span>
    <span class="s1">rng = np.random.RandomState(random_state)</span>
    <span class="s1">X = </span><span class="s2">2 </span><span class="s1">* rng.rand(n_samples</span><span class="s0">, </span><span class="s1">n_features) - </span><span class="s2">1</span>
    <span class="s1">y = np.sqrt((X**</span><span class="s2">2</span><span class="s1">).sum(</span><span class="s2">1</span><span class="s1">))</span>
    <span class="s1">y /= y.max()</span>

    <span class="s1">y_target = y[:n_test_pts]</span>

    <span class="s1">weight_func = _weight_func</span>

    <span class="s0">for </span><span class="s1">algorithm </span><span class="s0">in </span><span class="s1">ALGORITHMS:</span>
        <span class="s0">for </span><span class="s1">weights </span><span class="s0">in </span><span class="s1">[</span><span class="s4">&quot;uniform&quot;</span><span class="s0">, </span><span class="s4">&quot;distance&quot;</span><span class="s0">, </span><span class="s1">weight_func]:</span>
            <span class="s1">neigh = neighbors.RadiusNeighborsRegressor(</span>
                <span class="s1">radius=radius</span><span class="s0">, </span><span class="s1">weights=weights</span><span class="s0">, </span><span class="s1">algorithm=algorithm</span>
            <span class="s1">)</span>
            <span class="s1">neigh.fit(X</span><span class="s0">, </span><span class="s1">y)</span>
            <span class="s1">epsilon = </span><span class="s2">1e-5 </span><span class="s1">* (</span><span class="s2">2 </span><span class="s1">* rng.rand(</span><span class="s2">1</span><span class="s0">, </span><span class="s1">n_features) - </span><span class="s2">1</span><span class="s1">)</span>
            <span class="s1">y_pred = neigh.predict(X[:n_test_pts] + epsilon)</span>
            <span class="s0">assert </span><span class="s1">np.all(abs(y_pred - y_target) &lt; radius / </span><span class="s2">2</span><span class="s1">)</span>

    <span class="s3"># test that nan is returned when no nearby observations</span>
    <span class="s0">for </span><span class="s1">weights </span><span class="s0">in </span><span class="s1">[</span><span class="s4">&quot;uniform&quot;</span><span class="s0">, </span><span class="s4">&quot;distance&quot;</span><span class="s1">]:</span>
        <span class="s1">neigh = neighbors.RadiusNeighborsRegressor(</span>
            <span class="s1">radius=radius</span><span class="s0">, </span><span class="s1">weights=weights</span><span class="s0">, </span><span class="s1">algorithm=</span><span class="s4">&quot;auto&quot;</span>
        <span class="s1">)</span>
        <span class="s1">neigh.fit(X</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s1">X_test_nan = np.full((</span><span class="s2">1</span><span class="s0">, </span><span class="s1">n_features)</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.0</span><span class="s1">)</span>
        <span class="s1">empty_warning_msg = (</span>
            <span class="s4">&quot;One or more samples have no neighbors &quot;</span>
            <span class="s4">&quot;within specified radius; predicting NaN.&quot;</span>
        <span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.warns(UserWarning</span><span class="s0">, </span><span class="s1">match=re.escape(empty_warning_msg)):</span>
            <span class="s1">pred = neigh.predict(X_test_nan)</span>
        <span class="s0">assert </span><span class="s1">np.all(np.isnan(pred))</span>


<span class="s0">def </span><span class="s1">test_RadiusNeighborsRegressor_multioutput_with_uniform_weight():</span>
    <span class="s3"># Test radius neighbors in multi-output regression (uniform weight)</span>

    <span class="s1">rng = check_random_state(</span><span class="s2">0</span><span class="s1">)</span>
    <span class="s1">n_features = </span><span class="s2">5</span>
    <span class="s1">n_samples = </span><span class="s2">40</span>
    <span class="s1">n_output = </span><span class="s2">4</span>

    <span class="s1">X = rng.rand(n_samples</span><span class="s0">, </span><span class="s1">n_features)</span>
    <span class="s1">y = rng.rand(n_samples</span><span class="s0">, </span><span class="s1">n_output)</span>
    <span class="s1">X_train</span><span class="s0">, </span><span class="s1">X_test</span><span class="s0">, </span><span class="s1">y_train</span><span class="s0">, </span><span class="s1">y_test = train_test_split(X</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s2">0</span><span class="s1">)</span>

    <span class="s0">for </span><span class="s1">algorithm</span><span class="s0">, </span><span class="s1">weights </span><span class="s0">in </span><span class="s1">product(ALGORITHMS</span><span class="s0">, </span><span class="s1">[</span><span class="s0">None, </span><span class="s4">&quot;uniform&quot;</span><span class="s1">]):</span>
        <span class="s1">rnn = neighbors.RadiusNeighborsRegressor(weights=weights</span><span class="s0">, </span><span class="s1">algorithm=algorithm)</span>
        <span class="s1">rnn.fit(X_train</span><span class="s0">, </span><span class="s1">y_train)</span>

        <span class="s1">neigh_idx = rnn.radius_neighbors(X_test</span><span class="s0">, </span><span class="s1">return_distance=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">y_pred_idx = np.array([np.mean(y_train[idx]</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">0</span><span class="s1">) </span><span class="s0">for </span><span class="s1">idx </span><span class="s0">in </span><span class="s1">neigh_idx])</span>

        <span class="s1">y_pred_idx = np.array(y_pred_idx)</span>
        <span class="s1">y_pred = rnn.predict(X_test)</span>

        <span class="s0">assert </span><span class="s1">y_pred_idx.shape == y_test.shape</span>
        <span class="s0">assert </span><span class="s1">y_pred.shape == y_test.shape</span>
        <span class="s1">assert_allclose(y_pred</span><span class="s0">, </span><span class="s1">y_pred_idx)</span>


<span class="s0">def </span><span class="s1">test_RadiusNeighborsRegressor_multioutput(</span>
    <span class="s1">n_samples=</span><span class="s2">40</span><span class="s0">, </span><span class="s1">n_features=</span><span class="s2">5</span><span class="s0">, </span><span class="s1">n_test_pts=</span><span class="s2">10</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s2">0</span>
<span class="s1">):</span>
    <span class="s3"># Test k-neighbors in multi-output regression with various weight</span>
    <span class="s1">rng = np.random.RandomState(random_state)</span>
    <span class="s1">X = </span><span class="s2">2 </span><span class="s1">* rng.rand(n_samples</span><span class="s0">, </span><span class="s1">n_features) - </span><span class="s2">1</span>
    <span class="s1">y = np.sqrt((X**</span><span class="s2">2</span><span class="s1">).sum(</span><span class="s2">1</span><span class="s1">))</span>
    <span class="s1">y /= y.max()</span>
    <span class="s1">y = np.vstack([y</span><span class="s0">, </span><span class="s1">y]).T</span>

    <span class="s1">y_target = y[:n_test_pts]</span>
    <span class="s1">weights = [</span><span class="s4">&quot;uniform&quot;</span><span class="s0">, </span><span class="s4">&quot;distance&quot;</span><span class="s0">, </span><span class="s1">_weight_func]</span>

    <span class="s0">for </span><span class="s1">algorithm</span><span class="s0">, </span><span class="s1">weights </span><span class="s0">in </span><span class="s1">product(ALGORITHMS</span><span class="s0">, </span><span class="s1">weights):</span>
        <span class="s1">rnn = neighbors.RadiusNeighborsRegressor(weights=weights</span><span class="s0">, </span><span class="s1">algorithm=algorithm)</span>
        <span class="s1">rnn.fit(X</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s1">epsilon = </span><span class="s2">1e-5 </span><span class="s1">* (</span><span class="s2">2 </span><span class="s1">* rng.rand(</span><span class="s2">1</span><span class="s0">, </span><span class="s1">n_features) - </span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">y_pred = rnn.predict(X[:n_test_pts] + epsilon)</span>

        <span class="s0">assert </span><span class="s1">y_pred.shape == y_target.shape</span>
        <span class="s0">assert </span><span class="s1">np.all(np.abs(y_pred - y_target) &lt; </span><span class="s2">0.3</span><span class="s1">)</span>


<span class="s1">@pytest.mark.filterwarnings(</span><span class="s4">&quot;ignore:EfficiencyWarning&quot;</span><span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_kneighbors_regressor_sparse(</span>
    <span class="s1">n_samples=</span><span class="s2">40</span><span class="s0">, </span><span class="s1">n_features=</span><span class="s2">5</span><span class="s0">, </span><span class="s1">n_test_pts=</span><span class="s2">10</span><span class="s0">, </span><span class="s1">n_neighbors=</span><span class="s2">5</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s2">0</span>
<span class="s1">):</span>
    <span class="s3"># Test radius-based regression on sparse matrices</span>
    <span class="s3"># Like the above, but with various types of sparse matrices</span>
    <span class="s1">rng = np.random.RandomState(random_state)</span>
    <span class="s1">X = </span><span class="s2">2 </span><span class="s1">* rng.rand(n_samples</span><span class="s0">, </span><span class="s1">n_features) - </span><span class="s2">1</span>
    <span class="s1">y = ((X**</span><span class="s2">2</span><span class="s1">).sum(axis=</span><span class="s2">1</span><span class="s1">) &lt; </span><span class="s2">0.25</span><span class="s1">).astype(int)</span>

    <span class="s0">for </span><span class="s1">sparsemat </span><span class="s0">in </span><span class="s1">SPARSE_TYPES:</span>
        <span class="s1">knn = neighbors.KNeighborsRegressor(n_neighbors=n_neighbors</span><span class="s0">, </span><span class="s1">algorithm=</span><span class="s4">&quot;auto&quot;</span><span class="s1">)</span>
        <span class="s1">knn.fit(sparsemat(X)</span><span class="s0">, </span><span class="s1">y)</span>

        <span class="s1">knn_pre = neighbors.KNeighborsRegressor(</span>
            <span class="s1">n_neighbors=n_neighbors</span><span class="s0">, </span><span class="s1">metric=</span><span class="s4">&quot;precomputed&quot;</span>
        <span class="s1">)</span>
        <span class="s1">knn_pre.fit(pairwise_distances(X</span><span class="s0">, </span><span class="s1">metric=</span><span class="s4">&quot;euclidean&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">y)</span>

        <span class="s0">for </span><span class="s1">sparsev </span><span class="s0">in </span><span class="s1">SPARSE_OR_DENSE:</span>
            <span class="s1">X2 = sparsev(X)</span>
            <span class="s0">assert </span><span class="s1">np.mean(knn.predict(X2).round() == y) &gt; </span><span class="s2">0.95</span>

            <span class="s1">X2_pre = sparsev(pairwise_distances(X</span><span class="s0">, </span><span class="s1">metric=</span><span class="s4">&quot;euclidean&quot;</span><span class="s1">))</span>
            <span class="s0">if </span><span class="s1">sparsev </span><span class="s0">in </span><span class="s1">{dok_matrix</span><span class="s0">, </span><span class="s1">bsr_matrix}:</span>
                <span class="s1">msg = </span><span class="s4">&quot;not supported due to its handling of explicit zeros&quot;</span>
                <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                    <span class="s1">knn_pre.predict(X2_pre)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">assert </span><span class="s1">np.mean(knn_pre.predict(X2_pre).round() == y) &gt; </span><span class="s2">0.95</span>


<span class="s0">def </span><span class="s1">test_neighbors_iris():</span>
    <span class="s3"># Sanity checks on the iris dataset</span>
    <span class="s3"># Puts three points of each label in the plane and performs a</span>
    <span class="s3"># nearest neighbor query on points near the decision boundary.</span>

    <span class="s0">for </span><span class="s1">algorithm </span><span class="s0">in </span><span class="s1">ALGORITHMS:</span>
        <span class="s1">clf = neighbors.KNeighborsClassifier(n_neighbors=</span><span class="s2">1</span><span class="s0">, </span><span class="s1">algorithm=algorithm)</span>
        <span class="s1">clf.fit(iris.data</span><span class="s0">, </span><span class="s1">iris.target)</span>
        <span class="s1">assert_array_equal(clf.predict(iris.data)</span><span class="s0">, </span><span class="s1">iris.target)</span>

        <span class="s1">clf.set_params(n_neighbors=</span><span class="s2">9</span><span class="s0">, </span><span class="s1">algorithm=algorithm)</span>
        <span class="s1">clf.fit(iris.data</span><span class="s0">, </span><span class="s1">iris.target)</span>
        <span class="s0">assert </span><span class="s1">np.mean(clf.predict(iris.data) == iris.target) &gt; </span><span class="s2">0.95</span>

        <span class="s1">rgs = neighbors.KNeighborsRegressor(n_neighbors=</span><span class="s2">5</span><span class="s0">, </span><span class="s1">algorithm=algorithm)</span>
        <span class="s1">rgs.fit(iris.data</span><span class="s0">, </span><span class="s1">iris.target)</span>
        <span class="s0">assert </span><span class="s1">np.mean(rgs.predict(iris.data).round() == iris.target) &gt; </span><span class="s2">0.95</span>


<span class="s0">def </span><span class="s1">test_neighbors_digits():</span>
    <span class="s3"># Sanity check on the digits dataset</span>
    <span class="s3"># the 'brute' algorithm has been observed to fail if the input</span>
    <span class="s3"># dtype is uint8 due to overflow in distance calculations.</span>

    <span class="s1">X = digits.data.astype(</span><span class="s4">&quot;uint8&quot;</span><span class="s1">)</span>
    <span class="s1">Y = digits.target</span>
    <span class="s1">(n_samples</span><span class="s0">, </span><span class="s1">n_features) = X.shape</span>
    <span class="s1">train_test_boundary = int(n_samples * </span><span class="s2">0.8</span><span class="s1">)</span>
    <span class="s1">train = np.arange(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">train_test_boundary)</span>
    <span class="s1">test = np.arange(train_test_boundary</span><span class="s0">, </span><span class="s1">n_samples)</span>
    <span class="s1">(X_train</span><span class="s0">, </span><span class="s1">Y_train</span><span class="s0">, </span><span class="s1">X_test</span><span class="s0">, </span><span class="s1">Y_test) = X[train]</span><span class="s0">, </span><span class="s1">Y[train]</span><span class="s0">, </span><span class="s1">X[test]</span><span class="s0">, </span><span class="s1">Y[test]</span>

    <span class="s1">clf = neighbors.KNeighborsClassifier(n_neighbors=</span><span class="s2">1</span><span class="s0">, </span><span class="s1">algorithm=</span><span class="s4">&quot;brute&quot;</span><span class="s1">)</span>
    <span class="s1">score_uint8 = clf.fit(X_train</span><span class="s0">, </span><span class="s1">Y_train).score(X_test</span><span class="s0">, </span><span class="s1">Y_test)</span>
    <span class="s1">score_float = clf.fit(X_train.astype(float</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span><span class="s0">, </span><span class="s1">Y_train).score(</span>
        <span class="s1">X_test.astype(float</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span><span class="s0">, </span><span class="s1">Y_test</span>
    <span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">score_uint8 == score_float</span>


<span class="s0">def </span><span class="s1">test_kneighbors_graph():</span>
    <span class="s3"># Test kneighbors_graph to build the k-Nearest Neighbor graph.</span>
    <span class="s1">X = np.array([[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.01</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]])</span>

    <span class="s3"># n_neighbors = 1</span>
    <span class="s1">A = neighbors.kneighbors_graph(X</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">mode=</span><span class="s4">&quot;connectivity&quot;</span><span class="s0">, </span><span class="s1">include_self=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">assert_array_equal(A.toarray()</span><span class="s0">, </span><span class="s1">np.eye(A.shape[</span><span class="s2">0</span><span class="s1">]))</span>

    <span class="s1">A = neighbors.kneighbors_graph(X</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">mode=</span><span class="s4">&quot;distance&quot;</span><span class="s1">)</span>
    <span class="s1">assert_allclose(</span>
        <span class="s1">A.toarray()</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0.00</span><span class="s0">, </span><span class="s2">1.01</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.01</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.00</span><span class="s0">, </span><span class="s2">1.40716026</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]]</span>
    <span class="s1">)</span>

    <span class="s3"># n_neighbors = 2</span>
    <span class="s1">A = neighbors.kneighbors_graph(X</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s1">mode=</span><span class="s4">&quot;connectivity&quot;</span><span class="s0">, </span><span class="s1">include_self=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">assert_array_equal(A.toarray()</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]])</span>

    <span class="s1">A = neighbors.kneighbors_graph(X</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s1">mode=</span><span class="s4">&quot;distance&quot;</span><span class="s1">)</span>
    <span class="s1">assert_allclose(</span>
        <span class="s1">A.toarray()</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.01</span><span class="s0">, </span><span class="s2">2.23606798</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s2">1.01</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.40716026</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s2">2.23606798</span><span class="s0">, </span><span class="s2">1.40716026</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s3"># n_neighbors = 3</span>
    <span class="s1">A = neighbors.kneighbors_graph(X</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s1">mode=</span><span class="s4">&quot;connectivity&quot;</span><span class="s0">, </span><span class="s1">include_self=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">assert_allclose(A.toarray()</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]])</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;n_neighbors&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;mode&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;connectivity&quot;</span><span class="s0">, </span><span class="s4">&quot;distance&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_kneighbors_graph_sparse(n_neighbors</span><span class="s0">, </span><span class="s1">mode</span><span class="s0">, </span><span class="s1">seed=</span><span class="s2">36</span><span class="s1">):</span>
    <span class="s3"># Test kneighbors_graph to build the k-Nearest Neighbor graph</span>
    <span class="s3"># for sparse input.</span>
    <span class="s1">rng = np.random.RandomState(seed)</span>
    <span class="s1">X = rng.randn(</span><span class="s2">10</span><span class="s0">, </span><span class="s2">10</span><span class="s1">)</span>
    <span class="s1">Xcsr = csr_matrix(X)</span>

    <span class="s1">assert_allclose(</span>
        <span class="s1">neighbors.kneighbors_graph(X</span><span class="s0">, </span><span class="s1">n_neighbors</span><span class="s0">, </span><span class="s1">mode=mode).toarray()</span><span class="s0">,</span>
        <span class="s1">neighbors.kneighbors_graph(Xcsr</span><span class="s0">, </span><span class="s1">n_neighbors</span><span class="s0">, </span><span class="s1">mode=mode).toarray()</span><span class="s0">,</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_radius_neighbors_graph():</span>
    <span class="s3"># Test radius_neighbors_graph to build the Nearest Neighbor graph.</span>
    <span class="s1">X = np.array([[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.01</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]])</span>

    <span class="s1">A = neighbors.radius_neighbors_graph(X</span><span class="s0">, </span><span class="s2">1.5</span><span class="s0">, </span><span class="s1">mode=</span><span class="s4">&quot;connectivity&quot;</span><span class="s0">, </span><span class="s1">include_self=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">assert_array_equal(A.toarray()</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]])</span>

    <span class="s1">A = neighbors.radius_neighbors_graph(X</span><span class="s0">, </span><span class="s2">1.5</span><span class="s0">, </span><span class="s1">mode=</span><span class="s4">&quot;distance&quot;</span><span class="s1">)</span>
    <span class="s1">assert_allclose(</span>
        <span class="s1">A.toarray()</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.01</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.01</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.40716026</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.40716026</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]]</span>
    <span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;n_neighbors&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;mode&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;connectivity&quot;</span><span class="s0">, </span><span class="s4">&quot;distance&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_radius_neighbors_graph_sparse(n_neighbors</span><span class="s0">, </span><span class="s1">mode</span><span class="s0">, </span><span class="s1">seed=</span><span class="s2">36</span><span class="s1">):</span>
    <span class="s3"># Test radius_neighbors_graph to build the Nearest Neighbor graph</span>
    <span class="s3"># for sparse input.</span>
    <span class="s1">rng = np.random.RandomState(seed)</span>
    <span class="s1">X = rng.randn(</span><span class="s2">10</span><span class="s0">, </span><span class="s2">10</span><span class="s1">)</span>
    <span class="s1">Xcsr = csr_matrix(X)</span>

    <span class="s1">assert_allclose(</span>
        <span class="s1">neighbors.radius_neighbors_graph(X</span><span class="s0">, </span><span class="s1">n_neighbors</span><span class="s0">, </span><span class="s1">mode=mode).toarray()</span><span class="s0">,</span>
        <span class="s1">neighbors.radius_neighbors_graph(Xcsr</span><span class="s0">, </span><span class="s1">n_neighbors</span><span class="s0">, </span><span class="s1">mode=mode).toarray()</span><span class="s0">,</span>
    <span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s4">&quot;Estimator&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">neighbors.KNeighborsClassifier</span><span class="s0">,</span>
        <span class="s1">neighbors.RadiusNeighborsClassifier</span><span class="s0">,</span>
        <span class="s1">neighbors.KNeighborsRegressor</span><span class="s0">,</span>
        <span class="s1">neighbors.RadiusNeighborsRegressor</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_neighbors_validate_parameters(Estimator):</span>
    <span class="s5">&quot;&quot;&quot;Additional parameter validation for *Neighbors* estimators not covered by common 
    validation.&quot;&quot;&quot;</span>
    <span class="s1">X = rng.random_sample((</span><span class="s2">10</span><span class="s0">, </span><span class="s2">2</span><span class="s1">))</span>
    <span class="s1">Xsparse = csr_matrix(X)</span>
    <span class="s1">X3 = rng.random_sample((</span><span class="s2">10</span><span class="s0">, </span><span class="s2">3</span><span class="s1">))</span>
    <span class="s1">y = np.ones(</span><span class="s2">10</span><span class="s1">)</span>

    <span class="s1">nbrs = Estimator(algorithm=</span><span class="s4">&quot;ball_tree&quot;</span><span class="s0">, </span><span class="s1">metric=</span><span class="s4">&quot;haversine&quot;</span><span class="s1">)</span>
    <span class="s1">msg = </span><span class="s4">&quot;instance is not fitted yet&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">nbrs.predict(X)</span>
    <span class="s1">msg = </span><span class="s4">&quot;Metric 'haversine' not valid for sparse input.&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">ignore_warnings(nbrs.fit(Xsparse</span><span class="s0">, </span><span class="s1">y))</span>

    <span class="s1">nbrs = Estimator(metric=</span><span class="s4">&quot;haversine&quot;</span><span class="s0">, </span><span class="s1">algorithm=</span><span class="s4">&quot;brute&quot;</span><span class="s1">)</span>
    <span class="s1">nbrs.fit(X3</span><span class="s0">, </span><span class="s1">y)</span>
    <span class="s1">msg = </span><span class="s4">&quot;Haversine distance only valid in 2 dimensions&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">nbrs.predict(X3)</span>

    <span class="s1">nbrs = Estimator()</span>
    <span class="s1">msg = re.escape(</span><span class="s4">&quot;Found array with 0 sample(s)&quot;</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">nbrs.fit(np.ones((</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s1">))</span><span class="s0">, </span><span class="s1">np.ones(</span><span class="s2">0</span><span class="s1">))</span>

    <span class="s1">msg = </span><span class="s4">&quot;Found array with dim 3&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">nbrs.fit(X[:</span><span class="s0">, </span><span class="s1">:</span><span class="s0">, None</span><span class="s1">]</span><span class="s0">, </span><span class="s1">y)</span>
    <span class="s1">nbrs.fit(X</span><span class="s0">, </span><span class="s1">y)</span>

    <span class="s1">msg = re.escape(</span><span class="s4">&quot;Found array with 0 feature(s)&quot;</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">nbrs.predict([[]])</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s4">&quot;Estimator&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">neighbors.KNeighborsClassifier</span><span class="s0">,</span>
        <span class="s1">neighbors.RadiusNeighborsClassifier</span><span class="s0">,</span>
        <span class="s1">neighbors.KNeighborsRegressor</span><span class="s0">,</span>
        <span class="s1">neighbors.RadiusNeighborsRegressor</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;n_features&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">100</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;algorithm&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;auto&quot;</span><span class="s0">, </span><span class="s4">&quot;brute&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_neighbors_minkowski_semimetric_algo_warn(Estimator</span><span class="s0">, </span><span class="s1">n_features</span><span class="s0">, </span><span class="s1">algorithm):</span>
    <span class="s5">&quot;&quot;&quot; 
    Validation of all classes extending NeighborsBase with 
    Minkowski semi-metrics (i.e. when 0 &lt; p &lt; 1). That proper 
    Warning is raised for `algorithm=&quot;auto&quot;` and &quot;brute&quot;. 
    &quot;&quot;&quot;</span>
    <span class="s1">X = rng.random_sample((</span><span class="s2">10</span><span class="s0">, </span><span class="s1">n_features))</span>
    <span class="s1">y = np.ones(</span><span class="s2">10</span><span class="s1">)</span>

    <span class="s1">model = Estimator(p=</span><span class="s2">0.1</span><span class="s0">, </span><span class="s1">algorithm=algorithm)</span>
    <span class="s1">msg = (</span>
        <span class="s4">&quot;Mind that for 0 &lt; p &lt; 1, Minkowski metrics are not distance&quot;</span>
        <span class="s4">&quot; metrics. Continuing the execution with `algorithm='brute'`.&quot;</span>
    <span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.warns(UserWarning</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">model.fit(X</span><span class="s0">, </span><span class="s1">y)</span>

    <span class="s0">assert </span><span class="s1">model._fit_method == </span><span class="s4">&quot;brute&quot;</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s4">&quot;Estimator&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">neighbors.KNeighborsClassifier</span><span class="s0">,</span>
        <span class="s1">neighbors.RadiusNeighborsClassifier</span><span class="s0">,</span>
        <span class="s1">neighbors.KNeighborsRegressor</span><span class="s0">,</span>
        <span class="s1">neighbors.RadiusNeighborsRegressor</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;n_features&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">100</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;algorithm&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;kd_tree&quot;</span><span class="s0">, </span><span class="s4">&quot;ball_tree&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_neighbors_minkowski_semimetric_algo_error(Estimator</span><span class="s0">, </span><span class="s1">n_features</span><span class="s0">, </span><span class="s1">algorithm):</span>
    <span class="s5">&quot;&quot;&quot;Check that we raise a proper error if `algorithm!='brute'` and `p&lt;1`.&quot;&quot;&quot;</span>
    <span class="s1">X = rng.random_sample((</span><span class="s2">10</span><span class="s0">, </span><span class="s2">2</span><span class="s1">))</span>
    <span class="s1">y = np.ones(</span><span class="s2">10</span><span class="s1">)</span>

    <span class="s1">model = Estimator(algorithm=algorithm</span><span class="s0">, </span><span class="s1">p=</span><span class="s2">0.1</span><span class="s1">)</span>
    <span class="s1">msg = (</span>
        <span class="s4">f'algorithm=&quot;</span><span class="s0">{</span><span class="s1">algorithm</span><span class="s0">}</span><span class="s4">&quot; does not support 0 &lt; p &lt; 1 for '</span>
        <span class="s4">&quot;the Minkowski metric. To resolve this problem either &quot;</span>
        <span class="s4">'set p &gt;= 1 or algorithm=&quot;brute&quot;.'</span>
    <span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">model.fit(X</span><span class="s0">, </span><span class="s1">y)</span>


<span class="s3"># TODO: remove when NearestNeighbors methods uses parameter validation mechanism</span>
<span class="s0">def </span><span class="s1">test_nearest_neighbors_validate_params():</span>
    <span class="s5">&quot;&quot;&quot;Validate parameter of NearestNeighbors.&quot;&quot;&quot;</span>
    <span class="s1">X = rng.random_sample((</span><span class="s2">10</span><span class="s0">, </span><span class="s2">2</span><span class="s1">))</span>

    <span class="s1">nbrs = neighbors.NearestNeighbors().fit(X)</span>
    <span class="s1">msg = (</span>
        <span class="s4">'Unsupported mode, must be one of &quot;connectivity&quot;, or &quot;distance&quot; but got &quot;blah&quot;'</span>
        <span class="s4">&quot; instead&quot;</span>
    <span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">nbrs.kneighbors_graph(X</span><span class="s0">, </span><span class="s1">mode=</span><span class="s4">&quot;blah&quot;</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">nbrs.radius_neighbors_graph(X</span><span class="s0">, </span><span class="s1">mode=</span><span class="s4">&quot;blah&quot;</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s4">&quot;metric&quot;</span><span class="s0">,</span>
    <span class="s1">sorted(</span>
        <span class="s1">set(neighbors.VALID_METRICS[</span><span class="s4">&quot;ball_tree&quot;</span><span class="s1">]).intersection(</span>
            <span class="s1">neighbors.VALID_METRICS[</span><span class="s4">&quot;brute&quot;</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">- set([</span><span class="s4">&quot;pyfunc&quot;</span><span class="s0">, </span><span class="s1">*BOOL_METRICS])</span>
    <span class="s1">)</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_neighbors_metrics(</span>
    <span class="s1">global_dtype</span><span class="s0">, </span><span class="s1">metric</span><span class="s0">, </span><span class="s1">n_samples=</span><span class="s2">20</span><span class="s0">, </span><span class="s1">n_features=</span><span class="s2">3</span><span class="s0">, </span><span class="s1">n_query_pts=</span><span class="s2">2</span><span class="s0">, </span><span class="s1">n_neighbors=</span><span class="s2">5</span>
<span class="s1">):</span>
    <span class="s3"># Test computing the neighbors for various metrics</span>
    <span class="s1">algorithms = [</span><span class="s4">&quot;brute&quot;</span><span class="s0">, </span><span class="s4">&quot;ball_tree&quot;</span><span class="s0">, </span><span class="s4">&quot;kd_tree&quot;</span><span class="s1">]</span>
    <span class="s1">X_train = rng.rand(n_samples</span><span class="s0">, </span><span class="s1">n_features).astype(global_dtype</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">X_test = rng.rand(n_query_pts</span><span class="s0">, </span><span class="s1">n_features).astype(global_dtype</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s1">metric_params_list = _generate_test_params_for(metric</span><span class="s0">, </span><span class="s1">n_features)</span>

    <span class="s0">for </span><span class="s1">metric_params </span><span class="s0">in </span><span class="s1">metric_params_list:</span>
        <span class="s3"># Some metric (e.g. Weighted minkowski) are not supported by KDTree</span>
        <span class="s1">exclude_kd_tree = metric </span><span class="s0">not in </span><span class="s1">neighbors.VALID_METRICS[</span><span class="s4">&quot;kd_tree&quot;</span><span class="s1">] </span><span class="s0">or </span><span class="s1">(</span>
            <span class="s4">&quot;minkowski&quot; </span><span class="s0">in </span><span class="s1">metric </span><span class="s0">and </span><span class="s4">&quot;w&quot; </span><span class="s0">in </span><span class="s1">metric_params</span>
        <span class="s1">)</span>
        <span class="s1">results = {}</span>
        <span class="s1">p = metric_params.pop(</span><span class="s4">&quot;p&quot;</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">algorithm </span><span class="s0">in </span><span class="s1">algorithms:</span>
            <span class="s1">neigh = neighbors.NearestNeighbors(</span>
                <span class="s1">n_neighbors=n_neighbors</span><span class="s0">,</span>
                <span class="s1">algorithm=algorithm</span><span class="s0">,</span>
                <span class="s1">metric=metric</span><span class="s0">,</span>
                <span class="s1">p=p</span><span class="s0">,</span>
                <span class="s1">metric_params=metric_params</span><span class="s0">,</span>
            <span class="s1">)</span>

            <span class="s0">if </span><span class="s1">exclude_kd_tree </span><span class="s0">and </span><span class="s1">algorithm == </span><span class="s4">&quot;kd_tree&quot;</span><span class="s1">:</span>
                <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
                    <span class="s1">neigh.fit(X_train)</span>
                <span class="s0">continue</span>

            <span class="s3"># Haversine distance only accepts 2D data</span>
            <span class="s0">if </span><span class="s1">metric == </span><span class="s4">&quot;haversine&quot;</span><span class="s1">:</span>
                <span class="s1">feature_sl = slice(</span><span class="s0">None, </span><span class="s2">2</span><span class="s1">)</span>
                <span class="s1">X_train = np.ascontiguousarray(X_train[:</span><span class="s0">, </span><span class="s1">feature_sl])</span>
                <span class="s1">X_test = np.ascontiguousarray(X_test[:</span><span class="s0">, </span><span class="s1">feature_sl])</span>

            <span class="s1">neigh.fit(X_train)</span>
            <span class="s1">results[algorithm] = neigh.kneighbors(X_test</span><span class="s0">, </span><span class="s1">return_distance=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s1">brute_dst</span><span class="s0">, </span><span class="s1">brute_idx = results[</span><span class="s4">&quot;brute&quot;</span><span class="s1">]</span>
        <span class="s1">ball_tree_dst</span><span class="s0">, </span><span class="s1">ball_tree_idx = results[</span><span class="s4">&quot;ball_tree&quot;</span><span class="s1">]</span>

        <span class="s1">assert_allclose(brute_dst</span><span class="s0">, </span><span class="s1">ball_tree_dst)</span>
        <span class="s1">assert_array_equal(brute_idx</span><span class="s0">, </span><span class="s1">ball_tree_idx)</span>

        <span class="s0">if not </span><span class="s1">exclude_kd_tree:</span>
            <span class="s1">kd_tree_dst</span><span class="s0">, </span><span class="s1">kd_tree_idx = results[</span><span class="s4">&quot;kd_tree&quot;</span><span class="s1">]</span>
            <span class="s1">assert_allclose(brute_dst</span><span class="s0">, </span><span class="s1">kd_tree_dst)</span>
            <span class="s1">assert_array_equal(brute_idx</span><span class="s0">, </span><span class="s1">kd_tree_idx)</span>

            <span class="s1">assert_allclose(ball_tree_dst</span><span class="s0">, </span><span class="s1">kd_tree_dst)</span>
            <span class="s1">assert_array_equal(ball_tree_idx</span><span class="s0">, </span><span class="s1">kd_tree_idx)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s4">&quot;metric&quot;</span><span class="s0">, </span><span class="s1">sorted(set(neighbors.VALID_METRICS[</span><span class="s4">&quot;brute&quot;</span><span class="s1">]) - set([</span><span class="s4">&quot;precomputed&quot;</span><span class="s1">]))</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_kneighbors_brute_backend(</span>
    <span class="s1">global_dtype</span><span class="s0">, </span><span class="s1">metric</span><span class="s0">, </span><span class="s1">n_samples=</span><span class="s2">2000</span><span class="s0">, </span><span class="s1">n_features=</span><span class="s2">30</span><span class="s0">, </span><span class="s1">n_query_pts=</span><span class="s2">100</span><span class="s0">, </span><span class="s1">n_neighbors=</span><span class="s2">5</span>
<span class="s1">):</span>
    <span class="s3"># Both backend for the 'brute' algorithm of kneighbors must give identical results.</span>
    <span class="s1">X_train = rng.rand(n_samples</span><span class="s0">, </span><span class="s1">n_features).astype(global_dtype</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">X_test = rng.rand(n_query_pts</span><span class="s0">, </span><span class="s1">n_features).astype(global_dtype</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s3"># Haversine distance only accepts 2D data</span>
    <span class="s0">if </span><span class="s1">metric == </span><span class="s4">&quot;haversine&quot;</span><span class="s1">:</span>
        <span class="s1">feature_sl = slice(</span><span class="s0">None, </span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">X_train = np.ascontiguousarray(X_train[:</span><span class="s0">, </span><span class="s1">feature_sl])</span>
        <span class="s1">X_test = np.ascontiguousarray(X_test[:</span><span class="s0">, </span><span class="s1">feature_sl])</span>

    <span class="s1">metric_params_list = _generate_test_params_for(metric</span><span class="s0">, </span><span class="s1">n_features)</span>

    <span class="s0">for </span><span class="s1">metric_params </span><span class="s0">in </span><span class="s1">metric_params_list:</span>
        <span class="s1">p = metric_params.pop(</span><span class="s4">&quot;p&quot;</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>

        <span class="s1">neigh = neighbors.NearestNeighbors(</span>
            <span class="s1">n_neighbors=n_neighbors</span><span class="s0">,</span>
            <span class="s1">algorithm=</span><span class="s4">&quot;brute&quot;</span><span class="s0">,</span>
            <span class="s1">metric=metric</span><span class="s0">,</span>
            <span class="s1">p=p</span><span class="s0">,</span>
            <span class="s1">metric_params=metric_params</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s1">neigh.fit(X_train)</span>

        <span class="s0">with </span><span class="s1">config_context(enable_cython_pairwise_dist=</span><span class="s0">False</span><span class="s1">):</span>
            <span class="s3"># Use the legacy backend for brute</span>
            <span class="s1">legacy_brute_dst</span><span class="s0">, </span><span class="s1">legacy_brute_idx = neigh.kneighbors(</span>
                <span class="s1">X_test</span><span class="s0">, </span><span class="s1">return_distance=</span><span class="s0">True</span>
            <span class="s1">)</span>
        <span class="s0">with </span><span class="s1">config_context(enable_cython_pairwise_dist=</span><span class="s0">True</span><span class="s1">):</span>
            <span class="s3"># Use the pairwise-distances reduction backend for brute</span>
            <span class="s1">pdr_brute_dst</span><span class="s0">, </span><span class="s1">pdr_brute_idx = neigh.kneighbors(</span>
                <span class="s1">X_test</span><span class="s0">, </span><span class="s1">return_distance=</span><span class="s0">True</span>
            <span class="s1">)</span>

        <span class="s1">assert_allclose(legacy_brute_dst</span><span class="s0">, </span><span class="s1">pdr_brute_dst)</span>
        <span class="s1">assert_array_equal(legacy_brute_idx</span><span class="s0">, </span><span class="s1">pdr_brute_idx)</span>


<span class="s0">def </span><span class="s1">test_callable_metric():</span>
    <span class="s0">def </span><span class="s1">custom_metric(x1</span><span class="s0">, </span><span class="s1">x2):</span>
        <span class="s0">return </span><span class="s1">np.sqrt(np.sum(x1**</span><span class="s2">2 </span><span class="s1">+ x2**</span><span class="s2">2</span><span class="s1">))</span>

    <span class="s1">X = np.random.RandomState(</span><span class="s2">42</span><span class="s1">).rand(</span><span class="s2">20</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>
    <span class="s1">nbrs1 = neighbors.NearestNeighbors(</span>
        <span class="s1">n_neighbors=</span><span class="s2">3</span><span class="s0">, </span><span class="s1">algorithm=</span><span class="s4">&quot;auto&quot;</span><span class="s0">, </span><span class="s1">metric=custom_metric</span>
    <span class="s1">)</span>
    <span class="s1">nbrs2 = neighbors.NearestNeighbors(</span>
        <span class="s1">n_neighbors=</span><span class="s2">3</span><span class="s0">, </span><span class="s1">algorithm=</span><span class="s4">&quot;brute&quot;</span><span class="s0">, </span><span class="s1">metric=custom_metric</span>
    <span class="s1">)</span>

    <span class="s1">nbrs1.fit(X)</span>
    <span class="s1">nbrs2.fit(X)</span>

    <span class="s1">dist1</span><span class="s0">, </span><span class="s1">ind1 = nbrs1.kneighbors(X)</span>
    <span class="s1">dist2</span><span class="s0">, </span><span class="s1">ind2 = nbrs2.kneighbors(X)</span>

    <span class="s1">assert_allclose(dist1</span><span class="s0">, </span><span class="s1">dist2)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;metric&quot;</span><span class="s0">, </span><span class="s1">neighbors.VALID_METRICS[</span><span class="s4">&quot;brute&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_valid_brute_metric_for_auto_algorithm(</span>
    <span class="s1">global_dtype</span><span class="s0">, </span><span class="s1">metric</span><span class="s0">, </span><span class="s1">n_samples=</span><span class="s2">20</span><span class="s0">, </span><span class="s1">n_features=</span><span class="s2">12</span>
<span class="s1">):</span>
    <span class="s1">X = rng.rand(n_samples</span><span class="s0">, </span><span class="s1">n_features).astype(global_dtype</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">Xcsr = csr_matrix(X)</span>

    <span class="s1">metric_params_list = _generate_test_params_for(metric</span><span class="s0">, </span><span class="s1">n_features)</span>

    <span class="s0">if </span><span class="s1">metric == </span><span class="s4">&quot;precomputed&quot;</span><span class="s1">:</span>
        <span class="s1">X_precomputed = rng.random_sample((</span><span class="s2">10</span><span class="s0">, </span><span class="s2">4</span><span class="s1">))</span>
        <span class="s1">Y_precomputed = rng.random_sample((</span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s1">))</span>
        <span class="s1">DXX = metrics.pairwise_distances(X_precomputed</span><span class="s0">, </span><span class="s1">metric=</span><span class="s4">&quot;euclidean&quot;</span><span class="s1">)</span>
        <span class="s1">DYX = metrics.pairwise_distances(</span>
            <span class="s1">Y_precomputed</span><span class="s0">, </span><span class="s1">X_precomputed</span><span class="s0">, </span><span class="s1">metric=</span><span class="s4">&quot;euclidean&quot;</span>
        <span class="s1">)</span>
        <span class="s1">nb_p = neighbors.NearestNeighbors(n_neighbors=</span><span class="s2">3</span><span class="s0">, </span><span class="s1">metric=</span><span class="s4">&quot;precomputed&quot;</span><span class="s1">)</span>
        <span class="s1">nb_p.fit(DXX)</span>
        <span class="s1">nb_p.kneighbors(DYX)</span>

    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">for </span><span class="s1">metric_params </span><span class="s0">in </span><span class="s1">metric_params_list:</span>
            <span class="s1">nn = neighbors.NearestNeighbors(</span>
                <span class="s1">n_neighbors=</span><span class="s2">3</span><span class="s0">,</span>
                <span class="s1">algorithm=</span><span class="s4">&quot;auto&quot;</span><span class="s0">,</span>
                <span class="s1">metric=metric</span><span class="s0">,</span>
                <span class="s1">metric_params=metric_params</span><span class="s0">,</span>
            <span class="s1">)</span>
            <span class="s3"># Haversine distance only accepts 2D data</span>
            <span class="s0">if </span><span class="s1">metric == </span><span class="s4">&quot;haversine&quot;</span><span class="s1">:</span>
                <span class="s1">feature_sl = slice(</span><span class="s0">None, </span><span class="s2">2</span><span class="s1">)</span>
                <span class="s1">X = np.ascontiguousarray(X[:</span><span class="s0">, </span><span class="s1">feature_sl])</span>

            <span class="s1">nn.fit(X)</span>
            <span class="s1">nn.kneighbors(X)</span>

            <span class="s0">if </span><span class="s1">metric </span><span class="s0">in </span><span class="s1">VALID_METRICS_SPARSE[</span><span class="s4">&quot;brute&quot;</span><span class="s1">]:</span>
                <span class="s1">nn = neighbors.NearestNeighbors(</span>
                    <span class="s1">n_neighbors=</span><span class="s2">3</span><span class="s0">, </span><span class="s1">algorithm=</span><span class="s4">&quot;auto&quot;</span><span class="s0">, </span><span class="s1">metric=metric</span>
                <span class="s1">).fit(Xcsr)</span>
                <span class="s1">nn.kneighbors(Xcsr)</span>


<span class="s0">def </span><span class="s1">test_metric_params_interface():</span>
    <span class="s1">X = rng.rand(</span><span class="s2">5</span><span class="s0">, </span><span class="s2">5</span><span class="s1">)</span>
    <span class="s1">y = rng.randint(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">5</span><span class="s1">)</span>
    <span class="s1">est = neighbors.KNeighborsClassifier(metric_params={</span><span class="s4">&quot;p&quot;</span><span class="s1">: </span><span class="s2">3</span><span class="s1">})</span>
    <span class="s0">with </span><span class="s1">pytest.warns(SyntaxWarning):</span>
        <span class="s1">est.fit(X</span><span class="s0">, </span><span class="s1">y)</span>


<span class="s0">def </span><span class="s1">test_predict_sparse_ball_kd_tree():</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s2">0</span><span class="s1">)</span>
    <span class="s1">X = rng.rand(</span><span class="s2">5</span><span class="s0">, </span><span class="s2">5</span><span class="s1">)</span>
    <span class="s1">y = rng.randint(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">5</span><span class="s1">)</span>
    <span class="s1">nbrs1 = neighbors.KNeighborsClassifier(</span><span class="s2">1</span><span class="s0">, </span><span class="s1">algorithm=</span><span class="s4">&quot;kd_tree&quot;</span><span class="s1">)</span>
    <span class="s1">nbrs2 = neighbors.KNeighborsRegressor(</span><span class="s2">1</span><span class="s0">, </span><span class="s1">algorithm=</span><span class="s4">&quot;ball_tree&quot;</span><span class="s1">)</span>
    <span class="s0">for </span><span class="s1">model </span><span class="s0">in </span><span class="s1">[nbrs1</span><span class="s0">, </span><span class="s1">nbrs2]:</span>
        <span class="s1">model.fit(X</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
            <span class="s1">model.predict(csr_matrix(X))</span>


<span class="s0">def </span><span class="s1">test_non_euclidean_kneighbors():</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s2">0</span><span class="s1">)</span>
    <span class="s1">X = rng.rand(</span><span class="s2">5</span><span class="s0">, </span><span class="s2">5</span><span class="s1">)</span>

    <span class="s3"># Find a reasonable radius.</span>
    <span class="s1">dist_array = pairwise_distances(X).flatten()</span>
    <span class="s1">np.sort(dist_array)</span>
    <span class="s1">radius = dist_array[</span><span class="s2">15</span><span class="s1">]</span>

    <span class="s3"># Test kneighbors_graph</span>
    <span class="s0">for </span><span class="s1">metric </span><span class="s0">in </span><span class="s1">[</span><span class="s4">&quot;manhattan&quot;</span><span class="s0">, </span><span class="s4">&quot;chebyshev&quot;</span><span class="s1">]:</span>
        <span class="s1">nbrs_graph = neighbors.kneighbors_graph(</span>
            <span class="s1">X</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s1">metric=metric</span><span class="s0">, </span><span class="s1">mode=</span><span class="s4">&quot;connectivity&quot;</span><span class="s0">, </span><span class="s1">include_self=</span><span class="s0">True</span>
        <span class="s1">).toarray()</span>
        <span class="s1">nbrs1 = neighbors.NearestNeighbors(n_neighbors=</span><span class="s2">3</span><span class="s0">, </span><span class="s1">metric=metric).fit(X)</span>
        <span class="s1">assert_array_equal(nbrs_graph</span><span class="s0">, </span><span class="s1">nbrs1.kneighbors_graph(X).toarray())</span>

    <span class="s3"># Test radiusneighbors_graph</span>
    <span class="s0">for </span><span class="s1">metric </span><span class="s0">in </span><span class="s1">[</span><span class="s4">&quot;manhattan&quot;</span><span class="s0">, </span><span class="s4">&quot;chebyshev&quot;</span><span class="s1">]:</span>
        <span class="s1">nbrs_graph = neighbors.radius_neighbors_graph(</span>
            <span class="s1">X</span><span class="s0">, </span><span class="s1">radius</span><span class="s0">, </span><span class="s1">metric=metric</span><span class="s0">, </span><span class="s1">mode=</span><span class="s4">&quot;connectivity&quot;</span><span class="s0">, </span><span class="s1">include_self=</span><span class="s0">True</span>
        <span class="s1">).toarray()</span>
        <span class="s1">nbrs1 = neighbors.NearestNeighbors(metric=metric</span><span class="s0">, </span><span class="s1">radius=radius).fit(X)</span>
        <span class="s1">assert_array_equal(nbrs_graph</span><span class="s0">, </span><span class="s1">nbrs1.radius_neighbors_graph(X).toarray())</span>

    <span class="s3"># Raise error when wrong parameters are supplied,</span>
    <span class="s1">X_nbrs = neighbors.NearestNeighbors(n_neighbors=</span><span class="s2">3</span><span class="s0">, </span><span class="s1">metric=</span><span class="s4">&quot;manhattan&quot;</span><span class="s1">)</span>
    <span class="s1">X_nbrs.fit(X)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">neighbors.kneighbors_graph(X_nbrs</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s1">metric=</span><span class="s4">&quot;euclidean&quot;</span><span class="s1">)</span>
    <span class="s1">X_nbrs = neighbors.NearestNeighbors(radius=radius</span><span class="s0">, </span><span class="s1">metric=</span><span class="s4">&quot;manhattan&quot;</span><span class="s1">)</span>
    <span class="s1">X_nbrs.fit(X)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError):</span>
        <span class="s1">neighbors.radius_neighbors_graph(X_nbrs</span><span class="s0">, </span><span class="s1">radius</span><span class="s0">, </span><span class="s1">metric=</span><span class="s4">&quot;euclidean&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">check_object_arrays(nparray</span><span class="s0">, </span><span class="s1">list_check):</span>
    <span class="s0">for </span><span class="s1">ind</span><span class="s0">, </span><span class="s1">ele </span><span class="s0">in </span><span class="s1">enumerate(nparray):</span>
        <span class="s1">assert_array_equal(ele</span><span class="s0">, </span><span class="s1">list_check[ind])</span>


<span class="s0">def </span><span class="s1">test_k_and_radius_neighbors_train_is_not_query():</span>
    <span class="s3"># Test kneighbors et.al when query is not training data</span>

    <span class="s0">for </span><span class="s1">algorithm </span><span class="s0">in </span><span class="s1">ALGORITHMS:</span>
        <span class="s1">nn = neighbors.NearestNeighbors(n_neighbors=</span><span class="s2">1</span><span class="s0">, </span><span class="s1">algorithm=algorithm)</span>

        <span class="s1">X = [[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]]</span>
        <span class="s1">nn.fit(X)</span>
        <span class="s1">test_data = [[</span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]]</span>

        <span class="s3"># Test neighbors.</span>
        <span class="s1">dist</span><span class="s0">, </span><span class="s1">ind = nn.kneighbors(test_data)</span>
        <span class="s1">assert_array_equal(dist</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s1">]])</span>
        <span class="s1">assert_array_equal(ind</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]])</span>
        <span class="s1">dist</span><span class="s0">, </span><span class="s1">ind = nn.radius_neighbors([[</span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">radius=</span><span class="s2">1.5</span><span class="s1">)</span>
        <span class="s1">check_object_arrays(dist</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]])</span>
        <span class="s1">check_object_arrays(ind</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]])</span>

        <span class="s3"># Test the graph variants.</span>
        <span class="s1">assert_array_equal(</span>
            <span class="s1">nn.kneighbors_graph(test_data).toarray()</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]]</span>
        <span class="s1">)</span>
        <span class="s1">assert_array_equal(</span>
            <span class="s1">nn.kneighbors_graph([[</span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">mode=</span><span class="s4">&quot;distance&quot;</span><span class="s1">).toarray()</span><span class="s0">,</span>
            <span class="s1">np.array([[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]])</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">rng = nn.radius_neighbors_graph([[</span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">radius=</span><span class="s2">1.5</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(rng.toarray()</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]])</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;algorithm&quot;</span><span class="s0">, </span><span class="s1">ALGORITHMS)</span>
<span class="s0">def </span><span class="s1">test_k_and_radius_neighbors_X_None(algorithm):</span>
    <span class="s3"># Test kneighbors et.al when query is None</span>
    <span class="s1">nn = neighbors.NearestNeighbors(n_neighbors=</span><span class="s2">1</span><span class="s0">, </span><span class="s1">algorithm=algorithm)</span>

    <span class="s1">X = [[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]]</span>
    <span class="s1">nn.fit(X)</span>

    <span class="s1">dist</span><span class="s0">, </span><span class="s1">ind = nn.kneighbors()</span>
    <span class="s1">assert_array_equal(dist</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]])</span>
    <span class="s1">assert_array_equal(ind</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s1">]])</span>
    <span class="s1">dist</span><span class="s0">, </span><span class="s1">ind = nn.radius_neighbors(</span><span class="s0">None, </span><span class="s1">radius=</span><span class="s2">1.5</span><span class="s1">)</span>
    <span class="s1">check_object_arrays(dist</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]])</span>
    <span class="s1">check_object_arrays(ind</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s1">]])</span>

    <span class="s3"># Test the graph variants.</span>
    <span class="s1">rng = nn.radius_neighbors_graph(</span><span class="s0">None, </span><span class="s1">radius=</span><span class="s2">1.5</span><span class="s1">)</span>
    <span class="s1">kng = nn.kneighbors_graph(</span><span class="s0">None</span><span class="s1">)</span>
    <span class="s0">for </span><span class="s1">graph </span><span class="s0">in </span><span class="s1">[rng</span><span class="s0">, </span><span class="s1">kng]:</span>
        <span class="s1">assert_array_equal(graph.toarray()</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]])</span>
        <span class="s1">assert_array_equal(graph.data</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">assert_array_equal(graph.indices</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">])</span>

    <span class="s1">X = [[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]]</span>
    <span class="s1">nn = neighbors.NearestNeighbors(n_neighbors=</span><span class="s2">2</span><span class="s0">, </span><span class="s1">algorithm=algorithm)</span>
    <span class="s1">nn.fit(X)</span>
    <span class="s1">assert_array_equal(</span>
        <span class="s1">nn.kneighbors_graph().toarray()</span><span class="s0">,</span>
        <span class="s1">np.array([[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]])</span><span class="s0">,</span>
    <span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;algorithm&quot;</span><span class="s0">, </span><span class="s1">ALGORITHMS)</span>
<span class="s0">def </span><span class="s1">test_k_and_radius_neighbors_duplicates(algorithm):</span>
    <span class="s3"># Test behavior of kneighbors when duplicates are present in query</span>
    <span class="s1">nn = neighbors.NearestNeighbors(n_neighbors=</span><span class="s2">1</span><span class="s0">, </span><span class="s1">algorithm=algorithm)</span>
    <span class="s1">duplicates = [[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s1">]]</span>

    <span class="s1">nn.fit(duplicates)</span>

    <span class="s3"># Do not do anything special to duplicates.</span>
    <span class="s1">kng = nn.kneighbors_graph(duplicates</span><span class="s0">, </span><span class="s1">mode=</span><span class="s4">&quot;distance&quot;</span><span class="s1">)</span>
    <span class="s1">assert_allclose(</span>
        <span class="s1">kng.toarray()</span><span class="s0">, </span><span class="s1">np.array([[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]])</span>
    <span class="s1">)</span>
    <span class="s1">assert_allclose(kng.data</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">])</span>
    <span class="s1">assert_allclose(kng.indices</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>

    <span class="s1">dist</span><span class="s0">, </span><span class="s1">ind = nn.radius_neighbors([[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">radius=</span><span class="s2">1.5</span><span class="s1">)</span>
    <span class="s1">check_object_arrays(dist</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]])</span>
    <span class="s1">check_object_arrays(ind</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]])</span>

    <span class="s1">rng = nn.radius_neighbors_graph(duplicates</span><span class="s0">, </span><span class="s1">radius=</span><span class="s2">1.5</span><span class="s1">)</span>
    <span class="s1">assert_allclose(</span>
        <span class="s1">rng.toarray()</span><span class="s0">, </span><span class="s1">np.array([[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]])</span>
    <span class="s1">)</span>

    <span class="s1">rng = nn.radius_neighbors_graph([[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">radius=</span><span class="s2">1.5</span><span class="s0">, </span><span class="s1">mode=</span><span class="s4">&quot;distance&quot;</span><span class="s1">)</span>
    <span class="s1">rng.sort_indices()</span>
    <span class="s1">assert_allclose(rng.toarray()</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]])</span>
    <span class="s1">assert_allclose(rng.indices</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
    <span class="s1">assert_allclose(rng.data</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">])</span>

    <span class="s3"># Mask the first duplicates when n_duplicates &gt; n_neighbors.</span>
    <span class="s1">X = np.ones((</span><span class="s2">3</span><span class="s0">, </span><span class="s2">1</span><span class="s1">))</span>
    <span class="s1">nn = neighbors.NearestNeighbors(n_neighbors=</span><span class="s2">1</span><span class="s0">, </span><span class="s1">algorithm=</span><span class="s4">&quot;brute&quot;</span><span class="s1">)</span>
    <span class="s1">nn.fit(X)</span>
    <span class="s1">dist</span><span class="s0">, </span><span class="s1">ind = nn.kneighbors()</span>
    <span class="s1">assert_allclose(dist</span><span class="s0">, </span><span class="s1">np.zeros((</span><span class="s2">3</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)))</span>
    <span class="s1">assert_allclose(ind</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]])</span>

    <span class="s3"># Test that zeros are explicitly marked in kneighbors_graph.</span>
    <span class="s1">kng = nn.kneighbors_graph(mode=</span><span class="s4">&quot;distance&quot;</span><span class="s1">)</span>
    <span class="s1">assert_allclose(kng.toarray()</span><span class="s0">, </span><span class="s1">np.zeros((</span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)))</span>
    <span class="s1">assert_allclose(kng.data</span><span class="s0">, </span><span class="s1">np.zeros(</span><span class="s2">3</span><span class="s1">))</span>
    <span class="s1">assert_allclose(kng.indices</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
    <span class="s1">assert_allclose(</span>
        <span class="s1">nn.kneighbors_graph().toarray()</span><span class="s0">,</span>
        <span class="s1">np.array([[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]])</span><span class="s0">,</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_include_self_neighbors_graph():</span>
    <span class="s3"># Test include_self parameter in neighbors_graph</span>
    <span class="s1">X = [[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]]</span>
    <span class="s1">kng = neighbors.kneighbors_graph(X</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">include_self=</span><span class="s0">True</span><span class="s1">).toarray()</span>
    <span class="s1">kng_not_self = neighbors.kneighbors_graph(X</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">include_self=</span><span class="s0">False</span><span class="s1">).toarray()</span>
    <span class="s1">assert_array_equal(kng</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]])</span>
    <span class="s1">assert_array_equal(kng_not_self</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]])</span>

    <span class="s1">rng = neighbors.radius_neighbors_graph(X</span><span class="s0">, </span><span class="s2">5.0</span><span class="s0">, </span><span class="s1">include_self=</span><span class="s0">True</span><span class="s1">).toarray()</span>
    <span class="s1">rng_not_self = neighbors.radius_neighbors_graph(</span>
        <span class="s1">X</span><span class="s0">, </span><span class="s2">5.0</span><span class="s0">, </span><span class="s1">include_self=</span><span class="s0">False</span>
    <span class="s1">).toarray()</span>
    <span class="s1">assert_array_equal(rng</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]])</span>
    <span class="s1">assert_array_equal(rng_not_self</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]])</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;algorithm&quot;</span><span class="s0">, </span><span class="s1">ALGORITHMS)</span>
<span class="s0">def </span><span class="s1">test_same_knn_parallel(algorithm):</span>
    <span class="s1">X</span><span class="s0">, </span><span class="s1">y = datasets.make_classification(</span>
        <span class="s1">n_samples=</span><span class="s2">30</span><span class="s0">, </span><span class="s1">n_features=</span><span class="s2">5</span><span class="s0">, </span><span class="s1">n_redundant=</span><span class="s2">0</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s2">0</span>
    <span class="s1">)</span>
    <span class="s1">X_train</span><span class="s0">, </span><span class="s1">X_test</span><span class="s0">, </span><span class="s1">y_train</span><span class="s0">, </span><span class="s1">y_test = train_test_split(X</span><span class="s0">, </span><span class="s1">y)</span>

    <span class="s1">clf = neighbors.KNeighborsClassifier(n_neighbors=</span><span class="s2">3</span><span class="s0">, </span><span class="s1">algorithm=algorithm)</span>
    <span class="s1">clf.fit(X_train</span><span class="s0">, </span><span class="s1">y_train)</span>
    <span class="s1">y = clf.predict(X_test)</span>
    <span class="s1">dist</span><span class="s0">, </span><span class="s1">ind = clf.kneighbors(X_test)</span>
    <span class="s1">graph = clf.kneighbors_graph(X_test</span><span class="s0">, </span><span class="s1">mode=</span><span class="s4">&quot;distance&quot;</span><span class="s1">).toarray()</span>

    <span class="s1">clf.set_params(n_jobs=</span><span class="s2">3</span><span class="s1">)</span>
    <span class="s1">clf.fit(X_train</span><span class="s0">, </span><span class="s1">y_train)</span>
    <span class="s1">y_parallel = clf.predict(X_test)</span>
    <span class="s1">dist_parallel</span><span class="s0">, </span><span class="s1">ind_parallel = clf.kneighbors(X_test)</span>
    <span class="s1">graph_parallel = clf.kneighbors_graph(X_test</span><span class="s0">, </span><span class="s1">mode=</span><span class="s4">&quot;distance&quot;</span><span class="s1">).toarray()</span>

    <span class="s1">assert_array_equal(y</span><span class="s0">, </span><span class="s1">y_parallel)</span>
    <span class="s1">assert_allclose(dist</span><span class="s0">, </span><span class="s1">dist_parallel)</span>
    <span class="s1">assert_array_equal(ind</span><span class="s0">, </span><span class="s1">ind_parallel)</span>
    <span class="s1">assert_allclose(graph</span><span class="s0">, </span><span class="s1">graph_parallel)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;algorithm&quot;</span><span class="s0">, </span><span class="s1">ALGORITHMS)</span>
<span class="s0">def </span><span class="s1">test_same_radius_neighbors_parallel(algorithm):</span>
    <span class="s1">X</span><span class="s0">, </span><span class="s1">y = datasets.make_classification(</span>
        <span class="s1">n_samples=</span><span class="s2">30</span><span class="s0">, </span><span class="s1">n_features=</span><span class="s2">5</span><span class="s0">, </span><span class="s1">n_redundant=</span><span class="s2">0</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s2">0</span>
    <span class="s1">)</span>
    <span class="s1">X_train</span><span class="s0">, </span><span class="s1">X_test</span><span class="s0">, </span><span class="s1">y_train</span><span class="s0">, </span><span class="s1">y_test = train_test_split(X</span><span class="s0">, </span><span class="s1">y)</span>

    <span class="s1">clf = neighbors.RadiusNeighborsClassifier(radius=</span><span class="s2">10</span><span class="s0">, </span><span class="s1">algorithm=algorithm)</span>
    <span class="s1">clf.fit(X_train</span><span class="s0">, </span><span class="s1">y_train)</span>
    <span class="s1">y = clf.predict(X_test)</span>
    <span class="s1">dist</span><span class="s0">, </span><span class="s1">ind = clf.radius_neighbors(X_test)</span>
    <span class="s1">graph = clf.radius_neighbors_graph(X_test</span><span class="s0">, </span><span class="s1">mode=</span><span class="s4">&quot;distance&quot;</span><span class="s1">).toarray()</span>

    <span class="s1">clf.set_params(n_jobs=</span><span class="s2">3</span><span class="s1">)</span>
    <span class="s1">clf.fit(X_train</span><span class="s0">, </span><span class="s1">y_train)</span>
    <span class="s1">y_parallel = clf.predict(X_test)</span>
    <span class="s1">dist_parallel</span><span class="s0">, </span><span class="s1">ind_parallel = clf.radius_neighbors(X_test)</span>
    <span class="s1">graph_parallel = clf.radius_neighbors_graph(X_test</span><span class="s0">, </span><span class="s1">mode=</span><span class="s4">&quot;distance&quot;</span><span class="s1">).toarray()</span>

    <span class="s1">assert_array_equal(y</span><span class="s0">, </span><span class="s1">y_parallel)</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(dist)):</span>
        <span class="s1">assert_allclose(dist[i]</span><span class="s0">, </span><span class="s1">dist_parallel[i])</span>
        <span class="s1">assert_array_equal(ind[i]</span><span class="s0">, </span><span class="s1">ind_parallel[i])</span>
    <span class="s1">assert_allclose(graph</span><span class="s0">, </span><span class="s1">graph_parallel)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;backend&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;threading&quot;</span><span class="s0">, </span><span class="s4">&quot;loky&quot;</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;algorithm&quot;</span><span class="s0">, </span><span class="s1">ALGORITHMS)</span>
<span class="s0">def </span><span class="s1">test_knn_forcing_backend(backend</span><span class="s0">, </span><span class="s1">algorithm):</span>
    <span class="s3"># Non-regression test which ensures the knn methods are properly working</span>
    <span class="s3"># even when forcing the global joblib backend.</span>
    <span class="s0">with </span><span class="s1">joblib.parallel_backend(backend):</span>
        <span class="s1">X</span><span class="s0">, </span><span class="s1">y = datasets.make_classification(</span>
            <span class="s1">n_samples=</span><span class="s2">30</span><span class="s0">, </span><span class="s1">n_features=</span><span class="s2">5</span><span class="s0">, </span><span class="s1">n_redundant=</span><span class="s2">0</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s2">0</span>
        <span class="s1">)</span>
        <span class="s1">X_train</span><span class="s0">, </span><span class="s1">X_test</span><span class="s0">, </span><span class="s1">y_train</span><span class="s0">, </span><span class="s1">y_test = train_test_split(X</span><span class="s0">, </span><span class="s1">y)</span>

        <span class="s1">clf = neighbors.KNeighborsClassifier(</span>
            <span class="s1">n_neighbors=</span><span class="s2">3</span><span class="s0">, </span><span class="s1">algorithm=algorithm</span><span class="s0">, </span><span class="s1">n_jobs=</span><span class="s2">2</span>
        <span class="s1">)</span>
        <span class="s1">clf.fit(X_train</span><span class="s0">, </span><span class="s1">y_train)</span>
        <span class="s1">clf.predict(X_test)</span>
        <span class="s1">clf.kneighbors(X_test)</span>
        <span class="s1">clf.kneighbors_graph(X_test</span><span class="s0">, </span><span class="s1">mode=</span><span class="s4">&quot;distance&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_dtype_convert():</span>
    <span class="s1">classifier = neighbors.KNeighborsClassifier(n_neighbors=</span><span class="s2">1</span><span class="s1">)</span>
    <span class="s1">CLASSES = </span><span class="s2">15</span>
    <span class="s1">X = np.eye(CLASSES)</span>
    <span class="s1">y = [ch </span><span class="s0">for </span><span class="s1">ch </span><span class="s0">in </span><span class="s4">&quot;ABCDEFGHIJKLMNOPQRSTU&quot;</span><span class="s1">[:CLASSES]]</span>

    <span class="s1">result = classifier.fit(X</span><span class="s0">, </span><span class="s1">y).predict(X)</span>
    <span class="s1">assert_array_equal(result</span><span class="s0">, </span><span class="s1">y)</span>


<span class="s0">def </span><span class="s1">test_sparse_metric_callable():</span>
    <span class="s0">def </span><span class="s1">sparse_metric(x</span><span class="s0">, </span><span class="s1">y):  </span><span class="s3"># Metric accepting sparse matrix input (only)</span>
        <span class="s0">assert </span><span class="s1">issparse(x) </span><span class="s0">and </span><span class="s1">issparse(y)</span>
        <span class="s0">return </span><span class="s1">x.dot(y.T).toarray().item()</span>

    <span class="s1">X = csr_matrix(</span>
        <span class="s1">[[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]]  </span><span class="s3"># Population matrix</span>
    <span class="s1">)</span>

    <span class="s1">Y = csr_matrix([[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]])  </span><span class="s3"># Query matrix</span>

    <span class="s1">nn = neighbors.NearestNeighbors(</span>
        <span class="s1">algorithm=</span><span class="s4">&quot;brute&quot;</span><span class="s0">, </span><span class="s1">n_neighbors=</span><span class="s2">2</span><span class="s0">, </span><span class="s1">metric=sparse_metric</span>
    <span class="s1">).fit(X)</span>
    <span class="s1">N = nn.kneighbors(Y</span><span class="s0">, </span><span class="s1">return_distance=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s3"># GS indices of nearest neighbours in `X` for `sparse_metric`</span>
    <span class="s1">gold_standard_nn = np.array([[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]])</span>

    <span class="s1">assert_array_equal(N</span><span class="s0">, </span><span class="s1">gold_standard_nn)</span>


<span class="s3"># ignore conversion to boolean in pairwise_distances</span>
<span class="s1">@ignore_warnings(category=DataConversionWarning)</span>
<span class="s0">def </span><span class="s1">test_pairwise_boolean_distance():</span>
    <span class="s3"># Non-regression test for #4523</span>
    <span class="s3"># 'brute': uses scipy.spatial.distance through pairwise_distances</span>
    <span class="s3"># 'ball_tree': uses sklearn.neighbors._dist_metrics</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s2">0</span><span class="s1">)</span>
    <span class="s1">X = rng.uniform(size=(</span><span class="s2">6</span><span class="s0">, </span><span class="s2">5</span><span class="s1">))</span>
    <span class="s1">NN = neighbors.NearestNeighbors</span>

    <span class="s1">nn1 = NN(metric=</span><span class="s4">&quot;jaccard&quot;</span><span class="s0">, </span><span class="s1">algorithm=</span><span class="s4">&quot;brute&quot;</span><span class="s1">).fit(X)</span>
    <span class="s1">nn2 = NN(metric=</span><span class="s4">&quot;jaccard&quot;</span><span class="s0">, </span><span class="s1">algorithm=</span><span class="s4">&quot;ball_tree&quot;</span><span class="s1">).fit(X)</span>
    <span class="s1">assert_array_equal(nn1.kneighbors(X)[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">nn2.kneighbors(X)[</span><span class="s2">0</span><span class="s1">])</span>


<span class="s0">def </span><span class="s1">test_radius_neighbors_predict_proba():</span>
    <span class="s0">for </span><span class="s1">seed </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">5</span><span class="s1">):</span>
        <span class="s1">X</span><span class="s0">, </span><span class="s1">y = datasets.make_classification(</span>
            <span class="s1">n_samples=</span><span class="s2">50</span><span class="s0">,</span>
            <span class="s1">n_features=</span><span class="s2">5</span><span class="s0">,</span>
            <span class="s1">n_informative=</span><span class="s2">3</span><span class="s0">,</span>
            <span class="s1">n_redundant=</span><span class="s2">0</span><span class="s0">,</span>
            <span class="s1">n_classes=</span><span class="s2">3</span><span class="s0">,</span>
            <span class="s1">random_state=seed</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">X_tr</span><span class="s0">, </span><span class="s1">X_te</span><span class="s0">, </span><span class="s1">y_tr</span><span class="s0">, </span><span class="s1">y_te = train_test_split(X</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">outlier_label = int(</span><span class="s2">2 </span><span class="s1">- seed)</span>
        <span class="s1">clf = neighbors.RadiusNeighborsClassifier(radius=</span><span class="s2">2</span><span class="s0">, </span><span class="s1">outlier_label=outlier_label)</span>
        <span class="s1">clf.fit(X_tr</span><span class="s0">, </span><span class="s1">y_tr)</span>
        <span class="s1">pred = clf.predict(X_te)</span>
        <span class="s1">proba = clf.predict_proba(X_te)</span>
        <span class="s1">proba_label = proba.argmax(axis=</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">proba_label = np.where(proba.sum(axis=</span><span class="s2">1</span><span class="s1">) == </span><span class="s2">0</span><span class="s0">, </span><span class="s1">outlier_label</span><span class="s0">, </span><span class="s1">proba_label)</span>
        <span class="s1">assert_array_equal(pred</span><span class="s0">, </span><span class="s1">proba_label)</span>


<span class="s0">def </span><span class="s1">test_pipeline_with_nearest_neighbors_transformer():</span>
    <span class="s3"># Test chaining KNeighborsTransformer and classifiers/regressors</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s2">0</span><span class="s1">)</span>
    <span class="s1">X = </span><span class="s2">2 </span><span class="s1">* rng.rand(</span><span class="s2">40</span><span class="s0">, </span><span class="s2">5</span><span class="s1">) - </span><span class="s2">1</span>
    <span class="s1">X2 = </span><span class="s2">2 </span><span class="s1">* rng.rand(</span><span class="s2">40</span><span class="s0">, </span><span class="s2">5</span><span class="s1">) - </span><span class="s2">1</span>
    <span class="s1">y = rng.rand(</span><span class="s2">40</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>

    <span class="s1">n_neighbors = </span><span class="s2">12</span>
    <span class="s1">radius = </span><span class="s2">1.5</span>
    <span class="s3"># We precompute more neighbors than necessary, to have equivalence between</span>
    <span class="s3"># k-neighbors estimator after radius-neighbors transformer, and vice-versa.</span>
    <span class="s1">factor = </span><span class="s2">2</span>

    <span class="s1">k_trans = neighbors.KNeighborsTransformer(n_neighbors=n_neighbors</span><span class="s0">, </span><span class="s1">mode=</span><span class="s4">&quot;distance&quot;</span><span class="s1">)</span>
    <span class="s1">k_trans_factor = neighbors.KNeighborsTransformer(</span>
        <span class="s1">n_neighbors=int(n_neighbors * factor)</span><span class="s0">, </span><span class="s1">mode=</span><span class="s4">&quot;distance&quot;</span>
    <span class="s1">)</span>

    <span class="s1">r_trans = neighbors.RadiusNeighborsTransformer(radius=radius</span><span class="s0">, </span><span class="s1">mode=</span><span class="s4">&quot;distance&quot;</span><span class="s1">)</span>
    <span class="s1">r_trans_factor = neighbors.RadiusNeighborsTransformer(</span>
        <span class="s1">radius=int(radius * factor)</span><span class="s0">, </span><span class="s1">mode=</span><span class="s4">&quot;distance&quot;</span>
    <span class="s1">)</span>

    <span class="s1">k_reg = neighbors.KNeighborsRegressor(n_neighbors=n_neighbors)</span>
    <span class="s1">r_reg = neighbors.RadiusNeighborsRegressor(radius=radius)</span>

    <span class="s1">test_list = [</span>
        <span class="s1">(k_trans</span><span class="s0">, </span><span class="s1">k_reg)</span><span class="s0">,</span>
        <span class="s1">(k_trans_factor</span><span class="s0">, </span><span class="s1">r_reg)</span><span class="s0">,</span>
        <span class="s1">(r_trans</span><span class="s0">, </span><span class="s1">r_reg)</span><span class="s0">,</span>
        <span class="s1">(r_trans_factor</span><span class="s0">, </span><span class="s1">k_reg)</span><span class="s0">,</span>
    <span class="s1">]</span>

    <span class="s0">for </span><span class="s1">trans</span><span class="s0">, </span><span class="s1">reg </span><span class="s0">in </span><span class="s1">test_list:</span>
        <span class="s3"># compare the chained version and the compact version</span>
        <span class="s1">reg_compact = clone(reg)</span>
        <span class="s1">reg_precomp = clone(reg)</span>
        <span class="s1">reg_precomp.set_params(metric=</span><span class="s4">&quot;precomputed&quot;</span><span class="s1">)</span>

        <span class="s1">reg_chain = make_pipeline(clone(trans)</span><span class="s0">, </span><span class="s1">reg_precomp)</span>

        <span class="s1">y_pred_chain = reg_chain.fit(X</span><span class="s0">, </span><span class="s1">y).predict(X2)</span>
        <span class="s1">y_pred_compact = reg_compact.fit(X</span><span class="s0">, </span><span class="s1">y).predict(X2)</span>
        <span class="s1">assert_allclose(y_pred_chain</span><span class="s0">, </span><span class="s1">y_pred_compact)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s4">&quot;X, metric, metric_params, expected_algo&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(np.random.randint(</span><span class="s2">10</span><span class="s0">, </span><span class="s1">size=(</span><span class="s2">10</span><span class="s0">, </span><span class="s2">10</span><span class="s1">))</span><span class="s0">, </span><span class="s4">&quot;precomputed&quot;</span><span class="s0">, None, </span><span class="s4">&quot;brute&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(np.random.randn(</span><span class="s2">10</span><span class="s0">, </span><span class="s2">20</span><span class="s1">)</span><span class="s0">, </span><span class="s4">&quot;euclidean&quot;</span><span class="s0">, None, </span><span class="s4">&quot;brute&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(np.random.randn(</span><span class="s2">8</span><span class="s0">, </span><span class="s2">5</span><span class="s1">)</span><span class="s0">, </span><span class="s4">&quot;euclidean&quot;</span><span class="s0">, None, </span><span class="s4">&quot;brute&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(np.random.randn(</span><span class="s2">10</span><span class="s0">, </span><span class="s2">5</span><span class="s1">)</span><span class="s0">, </span><span class="s4">&quot;euclidean&quot;</span><span class="s0">, None, </span><span class="s4">&quot;kd_tree&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(np.random.randn(</span><span class="s2">10</span><span class="s0">, </span><span class="s2">5</span><span class="s1">)</span><span class="s0">, </span><span class="s4">&quot;seuclidean&quot;</span><span class="s0">, </span><span class="s1">{</span><span class="s4">&quot;V&quot;</span><span class="s1">: [</span><span class="s2">2</span><span class="s1">] * </span><span class="s2">5</span><span class="s1">}</span><span class="s0">, </span><span class="s4">&quot;ball_tree&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(np.random.randn(</span><span class="s2">10</span><span class="s0">, </span><span class="s2">5</span><span class="s1">)</span><span class="s0">, </span><span class="s4">&quot;correlation&quot;</span><span class="s0">, None, </span><span class="s4">&quot;brute&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_auto_algorithm(X</span><span class="s0">, </span><span class="s1">metric</span><span class="s0">, </span><span class="s1">metric_params</span><span class="s0">, </span><span class="s1">expected_algo):</span>
    <span class="s1">model = neighbors.NearestNeighbors(</span>
        <span class="s1">n_neighbors=</span><span class="s2">4</span><span class="s0">, </span><span class="s1">algorithm=</span><span class="s4">&quot;auto&quot;</span><span class="s0">, </span><span class="s1">metric=metric</span><span class="s0">, </span><span class="s1">metric_params=metric_params</span>
    <span class="s1">)</span>
    <span class="s1">model.fit(X)</span>
    <span class="s0">assert </span><span class="s1">model._fit_method == expected_algo</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s4">&quot;metric&quot;</span><span class="s0">, </span><span class="s1">sorted(set(neighbors.VALID_METRICS[</span><span class="s4">&quot;brute&quot;</span><span class="s1">]) - set([</span><span class="s4">&quot;precomputed&quot;</span><span class="s1">]))</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_radius_neighbors_brute_backend(</span>
    <span class="s1">metric</span><span class="s0">,</span>
    <span class="s1">n_samples=</span><span class="s2">2000</span><span class="s0">,</span>
    <span class="s1">n_features=</span><span class="s2">30</span><span class="s0">,</span>
    <span class="s1">n_query_pts=</span><span class="s2">100</span><span class="s0">,</span>
    <span class="s1">n_neighbors=</span><span class="s2">5</span><span class="s0">,</span>
    <span class="s1">radius=</span><span class="s2">1.0</span><span class="s0">,</span>
<span class="s1">):</span>
    <span class="s3"># Both backends for the 'brute' algorithm of radius_neighbors</span>
    <span class="s3"># must give identical results.</span>
    <span class="s1">X_train = rng.rand(n_samples</span><span class="s0">, </span><span class="s1">n_features)</span>
    <span class="s1">X_test = rng.rand(n_query_pts</span><span class="s0">, </span><span class="s1">n_features)</span>

    <span class="s3"># Haversine distance only accepts 2D data</span>
    <span class="s0">if </span><span class="s1">metric == </span><span class="s4">&quot;haversine&quot;</span><span class="s1">:</span>
        <span class="s1">feature_sl = slice(</span><span class="s0">None, </span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">X_train = np.ascontiguousarray(X_train[:</span><span class="s0">, </span><span class="s1">feature_sl])</span>
        <span class="s1">X_test = np.ascontiguousarray(X_test[:</span><span class="s0">, </span><span class="s1">feature_sl])</span>

    <span class="s1">metric_params_list = _generate_test_params_for(metric</span><span class="s0">, </span><span class="s1">n_features)</span>

    <span class="s0">for </span><span class="s1">metric_params </span><span class="s0">in </span><span class="s1">metric_params_list:</span>
        <span class="s1">p = metric_params.pop(</span><span class="s4">&quot;p&quot;</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>

        <span class="s1">neigh = neighbors.NearestNeighbors(</span>
            <span class="s1">n_neighbors=n_neighbors</span><span class="s0">,</span>
            <span class="s1">radius=radius</span><span class="s0">,</span>
            <span class="s1">algorithm=</span><span class="s4">&quot;brute&quot;</span><span class="s0">,</span>
            <span class="s1">metric=metric</span><span class="s0">,</span>
            <span class="s1">p=p</span><span class="s0">,</span>
            <span class="s1">metric_params=metric_params</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s1">neigh.fit(X_train)</span>

        <span class="s0">with </span><span class="s1">config_context(enable_cython_pairwise_dist=</span><span class="s0">False</span><span class="s1">):</span>
            <span class="s3"># Use the legacy backend for brute</span>
            <span class="s1">legacy_brute_dst</span><span class="s0">, </span><span class="s1">legacy_brute_idx = neigh.radius_neighbors(</span>
                <span class="s1">X_test</span><span class="s0">, </span><span class="s1">return_distance=</span><span class="s0">True</span>
            <span class="s1">)</span>
        <span class="s0">with </span><span class="s1">config_context(enable_cython_pairwise_dist=</span><span class="s0">True</span><span class="s1">):</span>
            <span class="s3"># Use the pairwise-distances reduction backend for brute</span>
            <span class="s1">pdr_brute_dst</span><span class="s0">, </span><span class="s1">pdr_brute_idx = neigh.radius_neighbors(</span>
                <span class="s1">X_test</span><span class="s0">, </span><span class="s1">return_distance=</span><span class="s0">True</span>
            <span class="s1">)</span>

        <span class="s1">assert_radius_neighbors_results_equality(</span>
            <span class="s1">legacy_brute_dst</span><span class="s0">,</span>
            <span class="s1">pdr_brute_dst</span><span class="s0">,</span>
            <span class="s1">legacy_brute_idx</span><span class="s0">,</span>
            <span class="s1">pdr_brute_idx</span><span class="s0">,</span>
            <span class="s1">radius=radius</span><span class="s0">,</span>
        <span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_valid_metrics_has_no_duplicate():</span>
    <span class="s0">for </span><span class="s1">val </span><span class="s0">in </span><span class="s1">neighbors.VALID_METRICS.values():</span>
        <span class="s0">assert </span><span class="s1">len(val) == len(set(val))</span>


<span class="s0">def </span><span class="s1">test_regressor_predict_on_arraylikes():</span>
    <span class="s5">&quot;&quot;&quot;Ensures that `predict` works for array-likes when `weights` is a callable. 
 
    Non-regression test for #22687. 
    &quot;&quot;&quot;</span>
    <span class="s1">X = [[</span><span class="s2">5</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">4</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]]</span>
    <span class="s1">y = [</span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">_weights(dist):</span>
        <span class="s0">return </span><span class="s1">np.ones_like(dist)</span>

    <span class="s1">est = KNeighborsRegressor(n_neighbors=</span><span class="s2">1</span><span class="s0">, </span><span class="s1">algorithm=</span><span class="s4">&quot;brute&quot;</span><span class="s0">, </span><span class="s1">weights=_weights)</span>
    <span class="s1">est.fit(X</span><span class="s0">, </span><span class="s1">y)</span>
    <span class="s1">assert_allclose(est.predict([[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">2.5</span><span class="s1">]])</span><span class="s0">, </span><span class="s1">[</span><span class="s2">6</span><span class="s1">])</span>


<span class="s0">def </span><span class="s1">test_predict_dataframe():</span>
    <span class="s5">&quot;&quot;&quot;Check that KNN predict works with dataframes 
 
    non-regression test for issue #26768 
    &quot;&quot;&quot;</span>
    <span class="s1">pd = pytest.importorskip(</span><span class="s4">&quot;pandas&quot;</span><span class="s1">)</span>

    <span class="s1">X = pd.DataFrame(np.array([[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">7</span><span class="s0">, </span><span class="s2">8</span><span class="s1">]])</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s4">&quot;a&quot;</span><span class="s0">, </span><span class="s4">&quot;b&quot;</span><span class="s1">])</span>
    <span class="s1">y = np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s1">])</span>

    <span class="s1">knn = neighbors.KNeighborsClassifier(n_neighbors=</span><span class="s2">2</span><span class="s1">).fit(X</span><span class="s0">, </span><span class="s1">y)</span>
    <span class="s1">knn.predict(X)</span>


<span class="s0">def </span><span class="s1">test_nearest_neighbours_works_with_p_less_than_1():</span>
    <span class="s5">&quot;&quot;&quot;Check that NearestNeighbors works with :math:`p \\in (0,1)` when `algorithm` 
    is `&quot;auto&quot;` or `&quot;brute&quot;` regardless of the dtype of X. 
 
    Non-regression test for issue #26548 
    &quot;&quot;&quot;</span>
    <span class="s1">X = np.array([[</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]])</span>
    <span class="s1">neigh = neighbors.NearestNeighbors(</span>
        <span class="s1">n_neighbors=</span><span class="s2">3</span><span class="s0">, </span><span class="s1">algorithm=</span><span class="s4">&quot;brute&quot;</span><span class="s0">, </span><span class="s1">metric_params={</span><span class="s4">&quot;p&quot;</span><span class="s1">: </span><span class="s2">0.5</span><span class="s1">}</span>
    <span class="s1">)</span>
    <span class="s1">neigh.fit(X)</span>

    <span class="s1">y = neigh.radius_neighbors(X[</span><span class="s2">0</span><span class="s1">].reshape(</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">radius=</span><span class="s2">4</span><span class="s0">, </span><span class="s1">return_distance=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">assert_allclose(y[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>

    <span class="s1">y = neigh.kneighbors(X[</span><span class="s2">0</span><span class="s1">].reshape(</span><span class="s2">1</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">return_distance=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">assert_allclose(y[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">])</span>
</pre>
</body>
</html>