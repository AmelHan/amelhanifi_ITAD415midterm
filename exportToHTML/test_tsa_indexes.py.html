<html>
<head>
<title>test_tsa_indexes.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_tsa_indexes.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Test index support in time series models 
 
1. Test support for passing / constructing the underlying index in __init__ 
2. Test wrapping of output using the underlying index 
3. Test wrapping of prediction / forecasting using the underlying index or 
   extensions of it. 
 
Author: Chad Fulton 
License: BSD-3 
&quot;&quot;&quot;</span>
<span class="s2">from </span><span class="s1">statsmodels.compat.pandas </span><span class="s2">import </span><span class="s1">is_int_index</span>

<span class="s2">import </span><span class="s1">warnings</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">numpy.testing </span><span class="s2">import </span><span class="s1">assert_equal</span><span class="s2">, </span><span class="s1">assert_raises</span>
<span class="s2">import </span><span class="s1">pandas </span><span class="s2">as </span><span class="s1">pd</span>
<span class="s2">import </span><span class="s1">pytest</span>

<span class="s2">from </span><span class="s1">statsmodels.tools.sm_exceptions </span><span class="s2">import </span><span class="s1">ValueWarning</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.base </span><span class="s2">import </span><span class="s1">tsa_model</span>

<span class="s1">nobs = </span><span class="s3">5</span>
<span class="s1">base_dta = np.arange(nobs)</span>
<span class="s1">dta = [</span>
    <span class="s1">base_dta.tolist()</span><span class="s2">,</span>
    <span class="s1">base_dta</span><span class="s2">,</span>
    <span class="s1">pd.Series(base_dta)</span><span class="s2">,</span>
    <span class="s1">pd.DataFrame(base_dta)</span><span class="s2">,</span>
<span class="s1">]</span>

<span class="s1">base_date_indexes = [</span>
    <span class="s4"># (usual candidates)</span>
    <span class="s1">pd.date_range(start=</span><span class="s5">&quot;1950-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=nobs</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;D&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">pd.date_range(start=</span><span class="s5">&quot;1950-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=nobs</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;W&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">pd.date_range(start=</span><span class="s5">&quot;1950-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=nobs</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;M&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">pd.date_range(start=</span><span class="s5">&quot;1950-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=nobs</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;Q&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">pd.date_range(start=</span><span class="s5">&quot;1950-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=nobs</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;A&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s4"># (some more complicated frequencies)</span>
    <span class="s1">pd.date_range(start=</span><span class="s5">&quot;1950-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=nobs</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;2Q&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">pd.date_range(start=</span><span class="s5">&quot;1950-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=nobs</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;2QS&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">pd.date_range(start=</span><span class="s5">&quot;1950-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=nobs</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;5s&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">pd.date_range(start=</span><span class="s5">&quot;1950-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=nobs</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;1D10min&quot;</span><span class="s1">)</span><span class="s2">,</span>
<span class="s1">]</span>

<span class="s4"># Note: we separate datetime indexes and period indexes because the</span>
<span class="s4"># date coercion does not handle string versions of PeriodIndex objects</span>
<span class="s4"># most of the time.</span>
<span class="s1">base_period_indexes = [</span>
    <span class="s1">pd.period_range(start=</span><span class="s5">&quot;1950-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=nobs</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;D&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">pd.period_range(start=</span><span class="s5">&quot;1950-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=nobs</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;W&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">pd.period_range(start=</span><span class="s5">&quot;1950-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=nobs</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;M&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">pd.period_range(start=</span><span class="s5">&quot;1950-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=nobs</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;Q&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">pd.period_range(start=</span><span class="s5">&quot;1950-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=nobs</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;A&quot;</span><span class="s1">)</span><span class="s2">,</span>
<span class="s1">]</span>
<span class="s2">try</span><span class="s1">:</span>
    <span class="s4"># Only later versions of pandas support these</span>
    <span class="s1">base_period_indexes += [</span>
        <span class="s1">pd.period_range(start=</span><span class="s5">&quot;1950-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=nobs</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;2Q&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">pd.period_range(start=</span><span class="s5">&quot;1950-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=nobs</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;5s&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">pd.period_range(start=</span><span class="s5">&quot;1950-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=nobs</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;1D10min&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">]</span>
<span class="s2">except </span><span class="s1">AttributeError:</span>
    <span class="s2">pass</span>

<span class="s1">date_indexes = [(x</span><span class="s2">, None</span><span class="s1">) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">base_date_indexes]</span>
<span class="s1">period_indexes = [(x</span><span class="s2">, None</span><span class="s1">) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">base_period_indexes]</span>

<span class="s1">numpy_datestr_indexes = [(x.map(str)</span><span class="s2">, </span><span class="s1">x.freq) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">base_date_indexes]</span>
<span class="s1">list_datestr_indexes = [(x.tolist()</span><span class="s2">, </span><span class="s1">y) </span><span class="s2">for </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y </span><span class="s2">in </span><span class="s1">numpy_datestr_indexes]</span>
<span class="s1">series_datestr_indexes = [(pd.Series(x)</span><span class="s2">, </span><span class="s1">y) </span><span class="s2">for </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y </span><span class="s2">in </span><span class="s1">list_datestr_indexes]</span>

<span class="s1">numpy_datetime_indexes = [</span>
    <span class="s1">(pd.to_datetime(x).to_pydatetime()</span><span class="s2">, </span><span class="s1">x.freq) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">base_date_indexes</span>
<span class="s1">]</span>
<span class="s1">list_datetime_indexes = [(x.tolist()</span><span class="s2">, </span><span class="s1">y) </span><span class="s2">for </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y </span><span class="s2">in </span><span class="s1">numpy_datetime_indexes]</span>
<span class="s1">series_datetime_indexes = [</span>
    <span class="s1">(pd.Series(x</span><span class="s2">, </span><span class="s1">dtype=object)</span><span class="s2">, </span><span class="s1">y) </span><span class="s2">for </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y </span><span class="s2">in </span><span class="s1">list_datetime_indexes</span>
<span class="s1">]</span>

<span class="s1">series_timestamp_indexes = [(pd.Series(x)</span><span class="s2">, </span><span class="s1">x.freq) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">base_date_indexes]</span>

<span class="s4"># Supported increment indexes</span>
<span class="s1">supported_increment_indexes = [</span>
    <span class="s1">(pd.Index(np.arange(nobs))</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">(pd.RangeIndex(start=</span><span class="s3">0</span><span class="s2">, </span><span class="s1">stop=nobs</span><span class="s2">, </span><span class="s1">step=</span><span class="s3">1</span><span class="s1">)</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">(pd.RangeIndex(start=-</span><span class="s3">5</span><span class="s2">, </span><span class="s1">stop=nobs - </span><span class="s3">5</span><span class="s2">, </span><span class="s1">step=</span><span class="s3">1</span><span class="s1">)</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">(pd.RangeIndex(start=</span><span class="s3">0</span><span class="s2">, </span><span class="s1">stop=nobs * </span><span class="s3">6</span><span class="s2">, </span><span class="s1">step=</span><span class="s3">6</span><span class="s1">)</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">,</span>
<span class="s1">]</span>

<span class="s4"># Supported date indexes</span>
<span class="s4"># Only the NumericIndex and the `date_indexes` are valid without</span>
<span class="s4"># frequency information</span>
<span class="s1">supported_date_indexes = (</span>
    <span class="s1">numpy_datestr_indexes</span>
    <span class="s1">+ list_datestr_indexes</span>
    <span class="s1">+ series_datestr_indexes</span>
    <span class="s1">+ numpy_datetime_indexes</span>
    <span class="s1">+ list_datetime_indexes</span>
    <span class="s1">+ series_datetime_indexes</span>
    <span class="s1">+ series_timestamp_indexes</span>
<span class="s1">)</span>

<span class="s4"># Unsupported (but still valid) indexes</span>
<span class="s1">unsupported_indexes = [</span>
    <span class="s4"># Non-incrementing-from-zero indexes</span>
    <span class="s1">(np.arange(</span><span class="s3">1</span><span class="s2">, </span><span class="s1">nobs + </span><span class="s3">1</span><span class="s1">)</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">(np.arange(nobs)[::-</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s4"># Float indexes, even if they increment from zero</span>
    <span class="s1">(np.arange(nobs) * </span><span class="s3">1.0</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s4"># Non-date-string indexes</span>
    <span class="s1">([x </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s5">&quot;abcde&quot;</span><span class="s1">]</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s4"># Non-date-object indexes</span>
    <span class="s1">([str</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s5">&quot;a&quot;</span><span class="s2">, </span><span class="s1">-</span><span class="s3">30.1</span><span class="s2">, </span><span class="s1">{}]</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">,</span>
<span class="s1">]</span>

<span class="s4"># Unsupported date indexes (i.e. those without inferrable frequency)</span>
<span class="s1">unsupported_date_indexes = [</span>
    <span class="s1">([</span><span class="s5">&quot;1950&quot;</span><span class="s2">, </span><span class="s5">&quot;1952&quot;</span><span class="s2">, </span><span class="s5">&quot;1941&quot;</span><span class="s2">, </span><span class="s5">&quot;1954&quot;</span><span class="s2">, </span><span class="s5">&quot;1991&quot;</span><span class="s1">]</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">(</span>
        <span class="s1">[</span><span class="s5">&quot;1950-01-01&quot;</span><span class="s2">, </span><span class="s5">&quot;1950-01-02&quot;</span><span class="s2">, </span><span class="s5">&quot;1950-01-03&quot;</span><span class="s2">, </span><span class="s5">&quot;1950-01-04&quot;</span><span class="s2">, </span><span class="s5">&quot;1950-01-06&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s2">None,</span>
    <span class="s1">)</span><span class="s2">,</span>
<span class="s1">]</span>


<span class="s2">def </span><span class="s1">test_instantiation_valid():</span>
    <span class="s1">tsa_model.__warningregistry__ = {}</span>

    <span class="s4"># The primary goal of this test function is to make sure the</span>
    <span class="s4"># combinations that are supposed to be valid are actually valid, and</span>
    <span class="s4"># that valid but unsupported options give the appropriate warning</span>
    <span class="s4"># Secondarily, it also has some tests that invalid combinations raise</span>
    <span class="s4"># exceptions, although it's not intended to be comprehensive.</span>
    <span class="s4">#</span>
    <span class="s4"># Each of `endog`, `exog` can be in the following categories:</span>
    <span class="s4"># 0. None (only for exog)</span>
    <span class="s4"># 1. list</span>
    <span class="s4"># 2. numpy array</span>
    <span class="s4"># 3. pandas series</span>
    <span class="s4"># 4. pandas dataframe</span>
    <span class="s4">#</span>
    <span class="s4"># Each pandas index (of `endog`, `exog`, or passed to `dates`) can be:</span>
    <span class="s4"># 0. None</span>
    <span class="s4"># 1. RangeIndex (if applicable; i.e. if Pandas &gt;= 0.18)</span>
    <span class="s4"># 2. Integral Indexes with values exactly equal to 0, 1, ..., nobs-1</span>
    <span class="s4"># 3. DatetimeIndex with frequency</span>
    <span class="s4"># 4. PeriodIndex with frequency</span>
    <span class="s4"># 5. Anything that does not fall into the above categories also should</span>
    <span class="s4">#    only raise an exception if it was passed to dates, and may trigger</span>
    <span class="s4">#    a warning otherwise.</span>
    <span class="s4">#</span>
    <span class="s4"># `date` can be one of the following:</span>
    <span class="s4"># 0. None</span>
    <span class="s4"># 2. Pandas index #2</span>
    <span class="s4"># 3. Pandas index #3</span>
    <span class="s4"># 4. List of date strings (requires freq)</span>
    <span class="s4"># 5. List of datetime objects (requires freq)</span>
    <span class="s4"># 6. Array of date strings (requires freq)</span>
    <span class="s4"># 7. Array of datetime objects (requires freq)</span>
    <span class="s4"># 8. Series of date strings (requires freq)</span>
    <span class="s4"># 9. Series of datetime objects (requires freq)</span>
    <span class="s4"># 10. Series of pandas timestamps (requires freq)</span>
    <span class="s4"># 11. Anything that does not fall into the above categories should raise</span>
    <span class="s4">#     an exception.</span>
    <span class="s4">#</span>
    <span class="s4"># `freq` can be:</span>
    <span class="s4"># 0. None</span>
    <span class="s4"># 1. Something that can be passed to `pd.to_offset`</span>
    <span class="s4"># 2. Anything that cannot should raise an Exception</span>
    <span class="s4">#</span>
    <span class="s4"># Each test will be denoted by:</span>
    <span class="s4"># endog.index:exog.index/date/freq where the corresponding</span>
    <span class="s4"># location is the integer from above; e.g. 1.0:0.0/9/1 corresponds to</span>
    <span class="s4"># - List endog (with no index)</span>
    <span class="s4"># - No exog</span>
    <span class="s4"># - Series of datetime objects</span>
    <span class="s4"># - Something valid for `pd.to_offset` (e.g. 'D', if that works with</span>
    <span class="s4">#   dates)</span>
    <span class="s4">#</span>
    <span class="s4"># Notice that the endog.index:exog.index really collapses to a single</span>
    <span class="s4"># element, which is the evaluated `row_label`. This is first the exog</span>
    <span class="s4"># index, if exists, then the endog index, if it exists, or None</span>
    <span class="s4"># otherwise. **Thus, we will not test `exog` here.**</span>
    <span class="s4">#</span>
    <span class="s4"># Example valid combinations of row_label/date/freq include:</span>
    <span class="s4"># - */0/0 (i.e. anything is valid if date and freq are not passed)</span>
    <span class="s4"># - */%/% where %/% denotes a valid date/freq combination (i.e. any</span>
    <span class="s4">#   row_label is valid if a valid date/freq combination is given)</span>
    <span class="s4">#</span>
    <span class="s4"># Example invalid combinations include:</span>
    <span class="s4"># - [1-2],[3-4].4/0/[1-2] (i.e. if have freq, then must have, or</span>
    <span class="s4">#   coerce, a date index)</span>
    <span class="s4"># - */[4-10]/0 (i.e. for some types of dates, freq must be passed)</span>

    <span class="s4"># Baseline: list, numpy endog with no dates, no freq</span>
    <span class="s2">for </span><span class="s1">endog </span><span class="s2">in </span><span class="s1">dta[:</span><span class="s3">2</span><span class="s1">]:</span>
        <span class="s4"># No indexes, should not raise warnings</span>
        <span class="s2">with </span><span class="s1">warnings.catch_warnings():</span>
            <span class="s1">warnings.simplefilter(</span><span class="s5">&quot;error&quot;</span><span class="s1">)</span>

            <span class="s1">mod = tsa_model.TimeSeriesModel(endog)</span>
            <span class="s2">assert </span><span class="s1">isinstance(mod._index</span><span class="s2">, </span><span class="s1">pd.RangeIndex) </span><span class="s2">or </span><span class="s1">np.issubdtype(</span>
                <span class="s1">mod._index.dtype</span><span class="s2">, </span><span class="s1">np.integer</span>
            <span class="s1">)</span>
            <span class="s1">assert_equal(mod._index_none</span><span class="s2">, True</span><span class="s1">)</span>
            <span class="s1">assert_equal(mod._index_dates</span><span class="s2">, False</span><span class="s1">)</span>
            <span class="s1">assert_equal(mod._index_generated</span><span class="s2">, True</span><span class="s1">)</span>
            <span class="s1">assert_equal(mod.data.dates</span><span class="s2">, None</span><span class="s1">)</span>
            <span class="s1">assert_equal(mod.data.freq</span><span class="s2">, None</span><span class="s1">)</span>

    <span class="s4"># Test list, numpy endog, pandas w/o index; with dates / freq argument</span>
    <span class="s2">for </span><span class="s1">endog </span><span class="s2">in </span><span class="s1">dta:</span>
        <span class="s4"># Supported date indexes, should not raise warnings, do not need freq</span>
        <span class="s2">with </span><span class="s1">warnings.catch_warnings():</span>
            <span class="s1">warnings.simplefilter(</span><span class="s5">&quot;error&quot;</span><span class="s1">)</span>

            <span class="s2">for </span><span class="s1">ix</span><span class="s2">, </span><span class="s1">freq </span><span class="s2">in </span><span class="s1">date_indexes + period_indexes:</span>
                <span class="s1">mod = tsa_model.TimeSeriesModel(endog</span><span class="s2">, </span><span class="s1">dates=ix)</span>
                <span class="s2">if </span><span class="s1">freq </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s1">freq = ix.freq</span>
                <span class="s2">if not </span><span class="s1">isinstance(freq</span><span class="s2">, </span><span class="s1">str):</span>
                    <span class="s1">freq = freq.freqstr</span>
                <span class="s1">assert_equal(</span>
                    <span class="s1">isinstance(mod._index</span><span class="s2">, </span><span class="s1">(pd.DatetimeIndex</span><span class="s2">, </span><span class="s1">pd.PeriodIndex))</span><span class="s2">,</span>
                    <span class="s2">True,</span>
                <span class="s1">)</span>
                <span class="s1">assert_equal(mod._index_none</span><span class="s2">, False</span><span class="s1">)</span>
                <span class="s1">assert_equal(mod._index_dates</span><span class="s2">, True</span><span class="s1">)</span>
                <span class="s1">assert_equal(mod._index_generated</span><span class="s2">, False</span><span class="s1">)</span>
                <span class="s1">assert_equal(mod._index.freq</span><span class="s2">, </span><span class="s1">mod._index_freq)</span>
                <span class="s1">assert_equal(mod.data.dates.equals(mod._index)</span><span class="s2">, True</span><span class="s1">)</span>
                <span class="s1">assert_equal(mod.data.freq</span><span class="s2">, </span><span class="s1">freq)</span>

        <span class="s4"># Supported date indexes, should not raise warnings, can use valid freq</span>
        <span class="s2">with </span><span class="s1">warnings.catch_warnings():</span>
            <span class="s1">warnings.simplefilter(</span><span class="s5">&quot;error&quot;</span><span class="s1">)</span>

            <span class="s2">for </span><span class="s1">ix</span><span class="s2">, </span><span class="s1">freq </span><span class="s2">in </span><span class="s1">date_indexes + period_indexes:</span>
                <span class="s1">mod = tsa_model.TimeSeriesModel(endog</span><span class="s2">, </span><span class="s1">dates=ix</span><span class="s2">, </span><span class="s1">freq=freq)</span>
                <span class="s2">if </span><span class="s1">freq </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s1">freq = ix.freq</span>
                <span class="s2">if not </span><span class="s1">isinstance(freq</span><span class="s2">, </span><span class="s1">str):</span>
                    <span class="s1">freq = freq.freqstr</span>
                <span class="s1">assert_equal(</span>
                    <span class="s1">isinstance(mod._index</span><span class="s2">, </span><span class="s1">(pd.DatetimeIndex</span><span class="s2">, </span><span class="s1">pd.PeriodIndex))</span><span class="s2">,</span>
                    <span class="s2">True,</span>
                <span class="s1">)</span>
                <span class="s1">assert_equal(mod._index_none</span><span class="s2">, False</span><span class="s1">)</span>
                <span class="s1">assert_equal(mod._index_dates</span><span class="s2">, True</span><span class="s1">)</span>
                <span class="s1">assert_equal(mod._index_generated</span><span class="s2">, False</span><span class="s1">)</span>
                <span class="s1">assert_equal(mod._index.freq</span><span class="s2">, </span><span class="s1">mod._index_freq)</span>
                <span class="s1">assert_equal(mod.data.dates.equals(mod._index)</span><span class="s2">, True</span><span class="s1">)</span>
                <span class="s1">assert_equal(mod.data.freq</span><span class="s2">, </span><span class="s1">freq)</span>

        <span class="s4"># Other supported indexes, with valid freq, should not raise warnings</span>
        <span class="s2">with </span><span class="s1">warnings.catch_warnings():</span>
            <span class="s1">warnings.simplefilter(</span><span class="s5">&quot;error&quot;</span><span class="s1">)</span>

            <span class="s2">for </span><span class="s1">ix</span><span class="s2">, </span><span class="s1">freq </span><span class="s2">in </span><span class="s1">supported_date_indexes:</span>
                <span class="s1">mod = tsa_model.TimeSeriesModel(endog</span><span class="s2">, </span><span class="s1">dates=ix</span><span class="s2">, </span><span class="s1">freq=freq)</span>
                <span class="s2">if </span><span class="s1">freq </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s1">freq = ix.freq</span>
                <span class="s2">if not </span><span class="s1">isinstance(freq</span><span class="s2">, </span><span class="s1">str):</span>
                    <span class="s1">freq = freq.freqstr</span>
                <span class="s1">assert_equal(</span>
                    <span class="s1">isinstance(mod._index</span><span class="s2">, </span><span class="s1">(pd.DatetimeIndex</span><span class="s2">, </span><span class="s1">pd.PeriodIndex))</span><span class="s2">,</span>
                    <span class="s2">True,</span>
                <span class="s1">)</span>
                <span class="s1">assert_equal(mod._index_none</span><span class="s2">, False</span><span class="s1">)</span>
                <span class="s1">assert_equal(mod._index_dates</span><span class="s2">, True</span><span class="s1">)</span>
                <span class="s1">assert_equal(mod._index_generated</span><span class="s2">, False</span><span class="s1">)</span>
                <span class="s1">assert_equal(mod._index.freq</span><span class="s2">, </span><span class="s1">mod._index_freq)</span>
                <span class="s1">assert_equal(mod.data.dates.equals(mod._index)</span><span class="s2">, True</span><span class="s1">)</span>
                <span class="s1">assert_equal(mod.data.freq</span><span class="s2">, </span><span class="s1">freq)</span>

        <span class="s4"># Since only supported indexes are valid `dates` arguments, everything</span>
        <span class="s4"># else is invalid here</span>
        <span class="s2">for </span><span class="s1">ix</span><span class="s2">, </span><span class="s1">freq </span><span class="s2">in </span><span class="s1">supported_increment_indexes + unsupported_indexes:</span>
            <span class="s1">assert_raises(</span>
                <span class="s1">ValueError</span><span class="s2">, </span><span class="s1">tsa_model.TimeSeriesModel</span><span class="s2">, </span><span class="s1">endog</span><span class="s2">, </span><span class="s1">dates=ix</span>
            <span class="s1">)</span>

    <span class="s4"># Test pandas (Series, DataFrame); with index (no dates/freq argument)</span>
    <span class="s2">for </span><span class="s1">base_endog </span><span class="s2">in </span><span class="s1">dta[</span><span class="s3">2</span><span class="s1">:</span><span class="s3">4</span><span class="s1">]:</span>
        <span class="s4"># DatetimeIndex and PeriodIndex, should not raise warnings</span>
        <span class="s2">with </span><span class="s1">warnings.catch_warnings():</span>
            <span class="s1">warnings.simplefilter(</span><span class="s5">&quot;error&quot;</span><span class="s1">)</span>

            <span class="s2">for </span><span class="s1">ix</span><span class="s2">, </span><span class="s1">freq </span><span class="s2">in </span><span class="s1">date_indexes + period_indexes:</span>
                <span class="s1">endog = base_endog.copy()</span>
                <span class="s1">endog.index = ix</span>

                <span class="s1">mod = tsa_model.TimeSeriesModel(endog)</span>
                <span class="s2">if </span><span class="s1">freq </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s1">freq = ix.freq</span>
                <span class="s2">if not </span><span class="s1">isinstance(freq</span><span class="s2">, </span><span class="s1">str):</span>
                    <span class="s1">freq = freq.freqstr</span>
                <span class="s1">assert_equal(</span>
                    <span class="s1">isinstance(mod._index</span><span class="s2">, </span><span class="s1">(pd.DatetimeIndex</span><span class="s2">, </span><span class="s1">pd.PeriodIndex))</span><span class="s2">,</span>
                    <span class="s2">True,</span>
                <span class="s1">)</span>
                <span class="s1">assert_equal(mod._index_none</span><span class="s2">, False</span><span class="s1">)</span>
                <span class="s1">assert_equal(mod._index_dates</span><span class="s2">, True</span><span class="s1">)</span>
                <span class="s1">assert_equal(mod._index_generated</span><span class="s2">, False</span><span class="s1">)</span>
                <span class="s1">assert_equal(mod._index.freq</span><span class="s2">, </span><span class="s1">mod._index_freq)</span>
                <span class="s1">assert_equal(mod.data.dates.equals(mod._index)</span><span class="s2">, True</span><span class="s1">)</span>
                <span class="s1">assert_equal(mod.data.freq</span><span class="s2">, </span><span class="s1">freq)</span>

        <span class="s4"># Increment index (this is a &quot;supported&quot; index in the sense that it</span>
        <span class="s4"># does not raise a warning, but obviously not a date index)</span>
        <span class="s1">endog = base_endog.copy()</span>
        <span class="s1">endog.index = supported_increment_indexes[</span><span class="s3">0</span><span class="s1">][</span><span class="s3">0</span><span class="s1">]</span>

        <span class="s1">mod = tsa_model.TimeSeriesModel(endog)</span>
        <span class="s2">assert </span><span class="s1">is_int_index(mod._index)</span>
        <span class="s1">assert_equal(mod._index_none</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s1">assert_equal(mod._index_dates</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s1">assert_equal(mod._index_generated</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s1">assert_equal(mod._index_freq</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s1">assert_equal(mod.data.dates</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s1">assert_equal(mod.data.freq</span><span class="s2">, None</span><span class="s1">)</span>

        <span class="s4"># RangeIndex (start=0, end=nobs, so equivalent to increment index)</span>
        <span class="s1">endog = base_endog.copy()</span>
        <span class="s1">endog.index = supported_increment_indexes[</span><span class="s3">1</span><span class="s1">][</span><span class="s3">0</span><span class="s1">]</span>

        <span class="s1">mod = tsa_model.TimeSeriesModel(endog)</span>
        <span class="s1">assert_equal(type(mod._index) == pd.RangeIndex</span><span class="s2">, True</span><span class="s1">)</span>
        <span class="s1">assert_equal(mod._index_none</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s1">assert_equal(mod._index_dates</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s1">assert_equal(mod._index_generated</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s1">assert_equal(mod._index_freq</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s1">assert_equal(mod.data.dates</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s1">assert_equal(mod.data.freq</span><span class="s2">, None</span><span class="s1">)</span>

        <span class="s4"># Supported indexes *when a freq is given*, should not raise a warning</span>
        <span class="s2">with </span><span class="s1">warnings.catch_warnings():</span>
            <span class="s1">warnings.simplefilter(</span><span class="s5">&quot;error&quot;</span><span class="s1">)</span>

            <span class="s2">for </span><span class="s1">ix</span><span class="s2">, </span><span class="s1">freq </span><span class="s2">in </span><span class="s1">supported_date_indexes:</span>
                <span class="s1">endog = base_endog.copy()</span>
                <span class="s1">endog.index = ix</span>

                <span class="s1">mod = tsa_model.TimeSeriesModel(endog</span><span class="s2">, </span><span class="s1">freq=freq)</span>
                <span class="s2">if </span><span class="s1">freq </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s1">freq = ix.freq</span>
                <span class="s2">if not </span><span class="s1">isinstance(freq</span><span class="s2">, </span><span class="s1">str):</span>
                    <span class="s1">freq = freq.freqstr</span>
                <span class="s1">assert_equal(</span>
                    <span class="s1">isinstance(mod._index</span><span class="s2">, </span><span class="s1">(pd.DatetimeIndex</span><span class="s2">, </span><span class="s1">pd.PeriodIndex))</span><span class="s2">,</span>
                    <span class="s2">True,</span>
                <span class="s1">)</span>
                <span class="s1">assert_equal(mod._index_none</span><span class="s2">, False</span><span class="s1">)</span>
                <span class="s1">assert_equal(mod._index_dates</span><span class="s2">, True</span><span class="s1">)</span>
                <span class="s1">assert_equal(mod._index_generated</span><span class="s2">, False</span><span class="s1">)</span>
                <span class="s1">assert_equal(mod._index.freq</span><span class="s2">, </span><span class="s1">mod._index_freq)</span>
                <span class="s1">assert_equal(mod.data.dates.equals(mod._index)</span><span class="s2">, True</span><span class="s1">)</span>
                <span class="s1">assert_equal(mod.data.freq</span><span class="s2">, </span><span class="s1">freq)</span>

        <span class="s4"># Unsupported (or any) indexes to the given series, *when a supported</span>
        <span class="s4"># date and freq is given*, should not raise a warning</span>
        <span class="s2">with </span><span class="s1">warnings.catch_warnings():</span>
            <span class="s1">warnings.simplefilter(</span><span class="s5">&quot;error&quot;</span><span class="s1">)</span>

            <span class="s2">for </span><span class="s1">ix</span><span class="s2">, </span><span class="s1">freq </span><span class="s2">in </span><span class="s1">supported_date_indexes:</span>
                <span class="s1">endog = base_endog.copy()</span>
                <span class="s1">endog.index = unsupported_indexes[</span><span class="s3">0</span><span class="s1">][</span><span class="s3">0</span><span class="s1">]</span>

                <span class="s1">mod = tsa_model.TimeSeriesModel(endog</span><span class="s2">, </span><span class="s1">dates=ix</span><span class="s2">, </span><span class="s1">freq=freq)</span>
                <span class="s2">if </span><span class="s1">freq </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s1">freq = ix.freq</span>
                <span class="s2">if not </span><span class="s1">isinstance(freq</span><span class="s2">, </span><span class="s1">str):</span>
                    <span class="s1">freq = freq.freqstr</span>
                <span class="s1">assert_equal(</span>
                    <span class="s1">isinstance(mod._index</span><span class="s2">, </span><span class="s1">(pd.DatetimeIndex</span><span class="s2">, </span><span class="s1">pd.PeriodIndex))</span><span class="s2">,</span>
                    <span class="s2">True,</span>
                <span class="s1">)</span>
                <span class="s1">assert_equal(mod._index_none</span><span class="s2">, False</span><span class="s1">)</span>
                <span class="s1">assert_equal(mod._index_dates</span><span class="s2">, True</span><span class="s1">)</span>
                <span class="s1">assert_equal(mod._index_generated</span><span class="s2">, False</span><span class="s1">)</span>
                <span class="s1">assert_equal(mod._index.freq</span><span class="s2">, </span><span class="s1">mod._index_freq)</span>
                <span class="s1">assert_equal(mod.data.dates.equals(mod._index)</span><span class="s2">, True</span><span class="s1">)</span>
                <span class="s1">assert_equal(mod.data.freq</span><span class="s2">, </span><span class="s1">freq)</span>

        <span class="s4"># Date indexes with inferrable freq, but no given freq, should all give</span>
        <span class="s4"># warnings</span>
        <span class="s1">message = (</span>
            <span class="s5">&quot;No frequency information was provided,&quot;</span>
            <span class="s5">&quot; so inferred frequency %s will be used.&quot;</span>
        <span class="s1">)</span>
        <span class="s1">last_len = </span><span class="s3">0</span>
        <span class="s2">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s2">True</span><span class="s1">) </span><span class="s2">as </span><span class="s1">w:</span>
            <span class="s1">warnings.simplefilter(</span><span class="s5">&quot;always&quot;</span><span class="s1">)</span>

            <span class="s2">for </span><span class="s1">ix</span><span class="s2">, </span><span class="s1">freq </span><span class="s2">in </span><span class="s1">supported_date_indexes:</span>
                <span class="s1">endog = base_endog.copy()</span>
                <span class="s1">endog.index = ix</span>
                <span class="s1">mod = tsa_model.TimeSeriesModel(endog)</span>
                <span class="s2">if </span><span class="s1">freq </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s1">freq = ix.freq</span>
                <span class="s2">if not </span><span class="s1">isinstance(freq</span><span class="s2">, </span><span class="s1">str):</span>
                    <span class="s1">freq = freq.freqstr</span>
                <span class="s1">assert_equal(type(mod._index) == pd.DatetimeIndex</span><span class="s2">, True</span><span class="s1">)</span>
                <span class="s1">assert_equal(mod._index_none</span><span class="s2">, False</span><span class="s1">)</span>
                <span class="s1">assert_equal(mod._index_dates</span><span class="s2">, True</span><span class="s1">)</span>
                <span class="s1">assert_equal(mod._index_generated</span><span class="s2">, False</span><span class="s1">)</span>
                <span class="s1">assert_equal(mod._index.freq</span><span class="s2">, </span><span class="s1">mod._index_freq)</span>
                <span class="s1">assert_equal(mod.data.dates.equals(mod._index)</span><span class="s2">, True</span><span class="s1">)</span>

                <span class="s4"># Note: here, we need to hedge the test a little bit because</span>
                <span class="s4"># inferred frequencies are not always the same as the original</span>
                <span class="s4"># frequency. From the examples above, when the actual freq is</span>
                <span class="s4"># 2QS-OCT, the inferred freq is 2QS-JAN. This is an issue with</span>
                <span class="s4"># inferred frequencies, but since we are warning the user, it's</span>
                <span class="s4"># not a failure of the code. Thus we only test the &quot;major&quot; part</span>
                <span class="s4"># of the freq, and just test that the right message is given</span>
                <span class="s4"># (even though it will not have the actual freq of the data in</span>
                <span class="s4"># it).</span>
                <span class="s2">if </span><span class="s1">len(w) == last_len:</span>
                    <span class="s2">continue</span>
                <span class="s1">assert_equal(mod.data.freq.split(</span><span class="s5">&quot;-&quot;</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">freq.split(</span><span class="s5">&quot;-&quot;</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">])</span>
                <span class="s1">assert_equal(str(w[-</span><span class="s3">1</span><span class="s1">].message)</span><span class="s2">, </span><span class="s1">message % mod.data.freq)</span>
                <span class="s1">last_len = len(w)</span>

        <span class="s4"># Unsupported (but valid) indexes, should all give warnings</span>
        <span class="s1">message = (</span>
            <span class="s5">&quot;An unsupported index was provided and will be&quot;</span>
            <span class="s5">&quot; ignored when e.g. forecasting.&quot;</span>
        <span class="s1">)</span>
        <span class="s2">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s2">True</span><span class="s1">) </span><span class="s2">as </span><span class="s1">w:</span>
            <span class="s1">warnings.simplefilter(</span><span class="s5">&quot;always&quot;</span><span class="s1">)</span>

            <span class="s2">for </span><span class="s1">ix</span><span class="s2">, </span><span class="s1">freq </span><span class="s2">in </span><span class="s1">unsupported_indexes:</span>
                <span class="s1">endog = base_endog.copy()</span>
                <span class="s1">endog.index = ix</span>
                <span class="s1">mod = tsa_model.TimeSeriesModel(endog)</span>
                <span class="s1">assert_equal(</span>
                    <span class="s1">isinstance(mod._index</span><span class="s2">, </span><span class="s1">(pd.Index</span><span class="s2">, </span><span class="s1">pd.RangeIndex))</span><span class="s2">, True</span>
                <span class="s1">)</span>
                <span class="s1">assert_equal(mod._index_none</span><span class="s2">, False</span><span class="s1">)</span>
                <span class="s1">assert_equal(mod._index_dates</span><span class="s2">, False</span><span class="s1">)</span>
                <span class="s1">assert_equal(mod._index_generated</span><span class="s2">, True</span><span class="s1">)</span>
                <span class="s1">assert_equal(mod._index_freq</span><span class="s2">, None</span><span class="s1">)</span>
                <span class="s1">assert_equal(mod.data.dates</span><span class="s2">, None</span><span class="s1">)</span>
                <span class="s1">assert_equal(mod.data.freq</span><span class="s2">, None</span><span class="s1">)</span>

                <span class="s1">assert_equal(str(w[</span><span class="s3">0</span><span class="s1">].message)</span><span class="s2">, </span><span class="s1">message)</span>

        <span class="s4"># Date indexes without inferrable freq, and with no given freq, should</span>
        <span class="s4"># all give warnings</span>
        <span class="s1">message = (</span>
            <span class="s5">&quot;A date index has been provided, but it has no&quot;</span>
            <span class="s5">&quot; associated frequency information and so will be&quot;</span>
            <span class="s5">&quot; ignored when e.g. forecasting.&quot;</span>
        <span class="s1">)</span>
        <span class="s2">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s2">True</span><span class="s1">) </span><span class="s2">as </span><span class="s1">w:</span>
            <span class="s1">warnings.simplefilter(</span><span class="s5">&quot;always&quot;</span><span class="s1">)</span>

            <span class="s2">for </span><span class="s1">ix</span><span class="s2">, </span><span class="s1">freq </span><span class="s2">in </span><span class="s1">unsupported_date_indexes:</span>
                <span class="s1">endog = base_endog.copy()</span>
                <span class="s1">endog.index = ix</span>
                <span class="s1">mod = tsa_model.TimeSeriesModel(endog)</span>
                <span class="s2">assert </span><span class="s1">isinstance(mod._index</span><span class="s2">, </span><span class="s1">pd.RangeIndex) </span><span class="s2">or </span><span class="s1">is_int_index(</span>
                    <span class="s1">mod._index</span>
                <span class="s1">)</span>
                <span class="s1">assert_equal(mod._index_none</span><span class="s2">, False</span><span class="s1">)</span>
                <span class="s1">assert_equal(mod._index_dates</span><span class="s2">, False</span><span class="s1">)</span>
                <span class="s1">assert_equal(mod._index_generated</span><span class="s2">, True</span><span class="s1">)</span>
                <span class="s1">assert_equal(mod._index_freq</span><span class="s2">, None</span><span class="s1">)</span>
                <span class="s1">assert_equal(mod.data.dates</span><span class="s2">, None</span><span class="s1">)</span>
                <span class="s1">assert_equal(mod.data.freq</span><span class="s2">, None</span><span class="s1">)</span>

                <span class="s1">assert_equal(str(w[</span><span class="s3">0</span><span class="s1">].message)</span><span class="s2">, </span><span class="s1">message)</span>

    <span class="s4"># Test (invalid) freq with no index</span>
    <span class="s1">endog = dta[</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s1">assert_raises(</span>
        <span class="s1">ValueError</span><span class="s2">,</span>
        <span class="s1">tsa_model.TimeSeriesModel</span><span class="s2">,</span>
        <span class="s1">endog</span><span class="s2">,</span>
        <span class="s1">freq=date_indexes[</span><span class="s3">1</span><span class="s1">][</span><span class="s3">0</span><span class="s1">].freq</span><span class="s2">,</span>
    <span class="s1">)</span>

    <span class="s4"># Test conflicting index, freq specifications</span>
    <span class="s1">endog = dta[</span><span class="s3">2</span><span class="s1">].copy()</span>
    <span class="s1">endog.index = date_indexes[</span><span class="s3">0</span><span class="s1">][</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s1">assert_raises(</span>
        <span class="s1">ValueError</span><span class="s2">,</span>
        <span class="s1">tsa_model.TimeSeriesModel</span><span class="s2">,</span>
        <span class="s1">endog</span><span class="s2">,</span>
        <span class="s1">freq=date_indexes[</span><span class="s3">1</span><span class="s1">][</span><span class="s3">0</span><span class="s1">].freq</span><span class="s2">,</span>
    <span class="s1">)</span>

    <span class="s4"># Test unsupported index, but a freq specification</span>
    <span class="s1">endog = dta[</span><span class="s3">2</span><span class="s1">].copy()</span>
    <span class="s1">endog.index = unsupported_indexes[</span><span class="s3">0</span><span class="s1">][</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s1">assert_raises(</span>
        <span class="s1">ValueError</span><span class="s2">,</span>
        <span class="s1">tsa_model.TimeSeriesModel</span><span class="s2">,</span>
        <span class="s1">endog</span><span class="s2">,</span>
        <span class="s1">freq=date_indexes[</span><span class="s3">1</span><span class="s1">][</span><span class="s3">0</span><span class="s1">].freq</span><span class="s2">,</span>
    <span class="s1">)</span>

    <span class="s4"># Test index that can coerce to date time but incorrect freq</span>
    <span class="s1">endog = dta[</span><span class="s3">2</span><span class="s1">].copy()</span>
    <span class="s1">endog.index = numpy_datestr_indexes[</span><span class="s3">0</span><span class="s1">][</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s1">assert_raises(</span>
        <span class="s1">ValueError</span><span class="s2">,</span>
        <span class="s1">tsa_model.TimeSeriesModel</span><span class="s2">,</span>
        <span class="s1">endog</span><span class="s2">,</span>
        <span class="s1">freq=date_indexes[</span><span class="s3">1</span><span class="s1">][</span><span class="s3">0</span><span class="s1">].freq</span><span class="s2">,</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_prediction_increment_unsupported():</span>
    <span class="s4"># a. Generated from unsupported index</span>
    <span class="s1">endog = dta[</span><span class="s3">2</span><span class="s1">].copy()</span>
    <span class="s1">endog.index = unsupported_indexes[-</span><span class="s3">2</span><span class="s1">][</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s2">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s2">True</span><span class="s1">) </span><span class="s2">as </span><span class="s1">w:</span>
        <span class="s1">warnings.simplefilter(</span><span class="s5">&quot;ignore&quot;</span><span class="s1">)</span>
        <span class="s1">mod = tsa_model.TimeSeriesModel(endog)</span>

    <span class="s4"># Tests three common use cases: basic prediction, negative indexes, and</span>
    <span class="s4"># out-of-sample indexes.</span>

    <span class="s4"># Basic prediction: [0, end]; notice that since this is an in-sample</span>
    <span class="s4"># prediction, the index returned is the (unsupported) original index</span>
    <span class="s1">start_key = </span><span class="s3">0</span>
    <span class="s1">end_key = </span><span class="s2">None</span>
    <span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">out_of_sample</span><span class="s2">, </span><span class="s1">prediction_index = mod._get_prediction_index(</span>
        <span class="s1">start_key</span><span class="s2">, </span><span class="s1">end_key</span>
    <span class="s1">)</span>

    <span class="s1">assert_equal(start</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">assert_equal(end</span><span class="s2">, </span><span class="s1">nobs - </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(out_of_sample</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">assert_equal(prediction_index.equals(mod.data.row_labels)</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s4"># Negative index: [-2, end]; notice that since this is an in-sample</span>
    <span class="s4"># prediction, the index returned is a piece of the (unsupported)</span>
    <span class="s4"># original index</span>
    <span class="s1">start_key = -</span><span class="s3">2</span>
    <span class="s1">end_key = -</span><span class="s3">1</span>
    <span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">out_of_sample</span><span class="s2">, </span><span class="s1">prediction_index = mod._get_prediction_index(</span>
        <span class="s1">start_key</span><span class="s2">, </span><span class="s1">end_key</span>
    <span class="s1">)</span>

    <span class="s1">assert_equal(start</span><span class="s2">, </span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">assert_equal(end</span><span class="s2">, </span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">assert_equal(out_of_sample</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">assert_equal(prediction_index.equals(mod.data.row_labels[</span><span class="s3">3</span><span class="s1">:])</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s4"># Forecasting: [1, 5], notice that since an unsupported index was given,</span>
    <span class="s4"># a warning will be issued</span>
    <span class="s1">start_key = </span><span class="s3">1</span>
    <span class="s1">end_key = nobs</span>
    <span class="s1">message = (</span>
        <span class="s5">&quot;No supported index is available.&quot;</span>
        <span class="s5">&quot; Prediction results will be given with&quot;</span>
        <span class="s5">&quot; an integer index beginning at `start`.&quot;</span>
    <span class="s1">)</span>
    <span class="s2">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s2">True</span><span class="s1">) </span><span class="s2">as </span><span class="s1">w:</span>
        <span class="s1">warnings.simplefilter(</span><span class="s5">&quot;always&quot;</span><span class="s1">)</span>

        <span class="s1">(</span>
            <span class="s1">start</span><span class="s2">,</span>
            <span class="s1">end</span><span class="s2">,</span>
            <span class="s1">out_of_sample</span><span class="s2">,</span>
            <span class="s1">prediction_index</span><span class="s2">,</span>
        <span class="s1">) = mod._get_prediction_index(start_key</span><span class="s2">, </span><span class="s1">end_key)</span>

        <span class="s1">assert_equal(str(w[</span><span class="s3">0</span><span class="s1">].message)</span><span class="s2">, </span><span class="s1">message)</span>

    <span class="s1">assert_equal(start</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(end</span><span class="s2">, </span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">assert_equal(out_of_sample</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(prediction_index.equals(pd.Index(np.arange(</span><span class="s3">1</span><span class="s2">, </span><span class="s3">6</span><span class="s1">)))</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s4"># Test getting a location that exists in the (internal) index</span>
    <span class="s1">loc</span><span class="s2">, </span><span class="s1">index</span><span class="s2">, </span><span class="s1">index_was_expanded = mod._get_index_loc(</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">assert_equal(loc</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">desired_index = pd.RangeIndex(start=</span><span class="s3">0</span><span class="s2">, </span><span class="s1">stop=</span><span class="s3">3</span><span class="s2">, </span><span class="s1">step=</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(index.equals(desired_index)</span><span class="s2">, True</span><span class="s1">)</span>
    <span class="s1">assert_equal(index_was_expanded</span><span class="s2">, False</span><span class="s1">)</span>

    <span class="s4"># Test getting a location that exists in the (internal) index</span>
    <span class="s4"># when using the function that alternatively falls back to the row labels</span>
    <span class="s1">loc</span><span class="s2">, </span><span class="s1">index</span><span class="s2">, </span><span class="s1">index_was_expanded = mod._get_index_label_loc(</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">assert_equal(loc</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">desired_index = pd.RangeIndex(start=</span><span class="s3">0</span><span class="s2">, </span><span class="s1">stop=</span><span class="s3">3</span><span class="s2">, </span><span class="s1">step=</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(index.equals(desired_index)</span><span class="s2">, True</span><span class="s1">)</span>
    <span class="s1">assert_equal(index_was_expanded</span><span class="s2">, False</span><span class="s1">)</span>

    <span class="s4"># Test getting a location that exists in the given (unsupported) index</span>
    <span class="s4"># Note that the returned index is now like the row labels</span>
    <span class="s1">loc</span><span class="s2">, </span><span class="s1">index</span><span class="s2">, </span><span class="s1">index_was_expanded = mod._get_index_label_loc(</span><span class="s5">&quot;c&quot;</span><span class="s1">)</span>
    <span class="s1">assert_equal(loc</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">desired_index = mod.data.row_labels[:</span><span class="s3">3</span><span class="s1">]</span>
    <span class="s1">assert_equal(index.equals(desired_index)</span><span class="s2">, True</span><span class="s1">)</span>
    <span class="s1">assert_equal(index_was_expanded</span><span class="s2">, False</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_prediction_increment_nonpandas():</span>
    <span class="s1">endog = dta[</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s1">mod = tsa_model.TimeSeriesModel(endog)</span>

    <span class="s4"># Tests three common use cases: basic prediction, negative indexes, and</span>
    <span class="s4"># out-of-sample indexes.</span>

    <span class="s4"># Basic prediction: [0, end]; since there was no index at all and the data</span>
    <span class="s4"># is not Pandas, the returned prediction_index is None</span>
    <span class="s1">start_key = </span><span class="s3">0</span>
    <span class="s1">end_key = </span><span class="s2">None</span>
    <span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">out_of_sample</span><span class="s2">, </span><span class="s1">prediction_index = mod._get_prediction_index(</span>
        <span class="s1">start_key</span><span class="s2">, </span><span class="s1">end_key</span>
    <span class="s1">)</span>

    <span class="s1">assert_equal(start</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">assert_equal(end</span><span class="s2">, </span><span class="s1">nobs - </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(out_of_sample</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">assert_equal(prediction_index </span><span class="s2">is None, True</span><span class="s1">)</span>

    <span class="s4"># Negative index: [-2, end]; since there was no index at all and the data</span>
    <span class="s4"># is not Pandas, the returned prediction_index is None</span>
    <span class="s1">start_key = -</span><span class="s3">2</span>
    <span class="s1">end_key = -</span><span class="s3">1</span>
    <span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">out_of_sample</span><span class="s2">, </span><span class="s1">prediction_index = mod._get_prediction_index(</span>
        <span class="s1">start_key</span><span class="s2">, </span><span class="s1">end_key</span>
    <span class="s1">)</span>

    <span class="s1">assert_equal(start</span><span class="s2">, </span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">assert_equal(end</span><span class="s2">, </span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">assert_equal(out_of_sample</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">assert_equal(prediction_index </span><span class="s2">is None, True</span><span class="s1">)</span>

    <span class="s4"># Forecasting: [1, 5]; since there was no index at all and the data</span>
    <span class="s4"># is not Pandas, the returned prediction_index is None</span>
    <span class="s1">start_key = </span><span class="s3">1</span>
    <span class="s1">end_key = nobs</span>
    <span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">out_of_sample</span><span class="s2">, </span><span class="s1">prediction_index = mod._get_prediction_index(</span>
        <span class="s1">start_key</span><span class="s2">, </span><span class="s1">end_key</span>
    <span class="s1">)</span>

    <span class="s1">assert_equal(start</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(end</span><span class="s2">, </span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">assert_equal(out_of_sample</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(prediction_index </span><span class="s2">is None, True</span><span class="s1">)</span>

    <span class="s4"># Test getting a location that exists in the (internal) index</span>
    <span class="s1">loc</span><span class="s2">, </span><span class="s1">index</span><span class="s2">, </span><span class="s1">index_was_expanded = mod._get_index_loc(</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">assert_equal(loc</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">desired_index = pd.RangeIndex(start=</span><span class="s3">0</span><span class="s2">, </span><span class="s1">stop=</span><span class="s3">3</span><span class="s2">, </span><span class="s1">step=</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(index.equals(desired_index)</span><span class="s2">, True</span><span class="s1">)</span>
    <span class="s1">assert_equal(index_was_expanded</span><span class="s2">, False</span><span class="s1">)</span>

    <span class="s4"># Test getting a location that exists in the (internal) index</span>
    <span class="s4"># when using the function that alternatively falls back to the row labels</span>
    <span class="s1">loc</span><span class="s2">, </span><span class="s1">index</span><span class="s2">, </span><span class="s1">index_was_expanded = mod._get_index_label_loc(</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">assert_equal(loc</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">desired_index = pd.RangeIndex(start=</span><span class="s3">0</span><span class="s2">, </span><span class="s1">stop=</span><span class="s3">3</span><span class="s2">, </span><span class="s1">step=</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(index.equals(desired_index)</span><span class="s2">, True</span><span class="s1">)</span>
    <span class="s1">assert_equal(index_was_expanded</span><span class="s2">, False</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_prediction_increment_pandas_noindex():</span>
    <span class="s1">endog = dta[</span><span class="s3">2</span><span class="s1">].copy()</span>
    <span class="s1">mod = tsa_model.TimeSeriesModel(endog)</span>

    <span class="s4"># Tests three common use cases: basic prediction, negative indexes, and</span>
    <span class="s4"># out-of-sample indexes.</span>

    <span class="s4"># Basic prediction: [0, end]; since there was no index and the data is</span>
    <span class="s4"># Pandas, the index is the generated incrementing index, and no warning is</span>
    <span class="s4"># issued</span>
    <span class="s1">start_key = </span><span class="s3">0</span>
    <span class="s1">end_key = </span><span class="s2">None</span>
    <span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">out_of_sample</span><span class="s2">, </span><span class="s1">prediction_index = mod._get_prediction_index(</span>
        <span class="s1">start_key</span><span class="s2">, </span><span class="s1">end_key</span>
    <span class="s1">)</span>

    <span class="s1">assert_equal(start</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">assert_equal(end</span><span class="s2">, </span><span class="s1">nobs - </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(out_of_sample</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">assert_equal(prediction_index.equals(mod._index)</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s4"># Negative index: [-2, end]; since there was no index and the data is</span>
    <span class="s4"># Pandas, the index is the generated incrementing index, and no warning is</span>
    <span class="s4"># issued</span>
    <span class="s1">start_key = -</span><span class="s3">2</span>
    <span class="s1">end_key = -</span><span class="s3">1</span>
    <span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">out_of_sample</span><span class="s2">, </span><span class="s1">prediction_index = mod._get_prediction_index(</span>
        <span class="s1">start_key</span><span class="s2">, </span><span class="s1">end_key</span>
    <span class="s1">)</span>

    <span class="s1">assert_equal(start</span><span class="s2">, </span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">assert_equal(end</span><span class="s2">, </span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">assert_equal(out_of_sample</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">assert_equal(prediction_index.equals(mod._index[</span><span class="s3">3</span><span class="s1">:])</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s4"># Forecasting: [1, 5]; since there was no index and the data is</span>
    <span class="s4"># Pandas, the index is the generated incrementing index, and no warning is</span>
    <span class="s4"># issued</span>
    <span class="s1">start_key = </span><span class="s3">1</span>
    <span class="s1">end_key = nobs</span>
    <span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">out_of_sample</span><span class="s2">, </span><span class="s1">prediction_index = mod._get_prediction_index(</span>
        <span class="s1">start_key</span><span class="s2">, </span><span class="s1">end_key</span>
    <span class="s1">)</span>

    <span class="s1">assert_equal(start</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(end</span><span class="s2">, </span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">assert_equal(out_of_sample</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(prediction_index.equals(pd.Index(np.arange(</span><span class="s3">1</span><span class="s2">, </span><span class="s3">6</span><span class="s1">)))</span><span class="s2">, True</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_prediction_increment_pandas_dates_daily():</span>
    <span class="s4"># Date-based index</span>
    <span class="s1">endog = dta[</span><span class="s3">2</span><span class="s1">].copy()</span>
    <span class="s1">endog.index = date_indexes[</span><span class="s3">0</span><span class="s1">][</span><span class="s3">0</span><span class="s1">]  </span><span class="s4"># Daily, 1950-01-01, 1950-01-02, ...</span>
    <span class="s1">mod = tsa_model.TimeSeriesModel(endog)</span>

    <span class="s4"># Tests three common use cases: basic prediction, negative indexes, and</span>
    <span class="s4"># out-of-sample indexes.</span>

    <span class="s4"># Basic prediction: [0, end]; the index is the date index</span>
    <span class="s1">start_key = </span><span class="s3">0</span>
    <span class="s1">end_key = </span><span class="s2">None</span>
    <span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">out_of_sample</span><span class="s2">, </span><span class="s1">prediction_index = mod._get_prediction_index(</span>
        <span class="s1">start_key</span><span class="s2">, </span><span class="s1">end_key</span>
    <span class="s1">)</span>

    <span class="s1">assert_equal(start</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">assert_equal(end</span><span class="s2">, </span><span class="s1">nobs - </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(out_of_sample</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">type(prediction_index) </span><span class="s2">is </span><span class="s1">type(endog.index)  </span><span class="s4"># noqa: E721</span>
    <span class="s1">assert_equal(prediction_index.equals(mod._index)</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s4"># In-sample prediction: [0, 3]; the index is a subset of the date index</span>
    <span class="s1">start_key = </span><span class="s3">0</span>
    <span class="s1">end_key = </span><span class="s3">3</span>
    <span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">out_of_sample</span><span class="s2">, </span><span class="s1">prediction_index = mod._get_prediction_index(</span>
        <span class="s1">start_key</span><span class="s2">, </span><span class="s1">end_key</span>
    <span class="s1">)</span>

    <span class="s1">assert_equal(start</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">assert_equal(end</span><span class="s2">, </span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">assert_equal(out_of_sample</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">type(prediction_index) </span><span class="s2">is </span><span class="s1">type(endog.index)  </span><span class="s4"># noqa: E721</span>
    <span class="s1">assert_equal(prediction_index.equals(mod._index[:</span><span class="s3">4</span><span class="s1">])</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s4"># Negative index: [-2, end]</span>
    <span class="s1">start_key = -</span><span class="s3">2</span>
    <span class="s1">end_key = -</span><span class="s3">1</span>
    <span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">out_of_sample</span><span class="s2">, </span><span class="s1">prediction_index = mod._get_prediction_index(</span>
        <span class="s1">start_key</span><span class="s2">, </span><span class="s1">end_key</span>
    <span class="s1">)</span>

    <span class="s1">assert_equal(start</span><span class="s2">, </span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">assert_equal(end</span><span class="s2">, </span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">assert_equal(out_of_sample</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">type(prediction_index) </span><span class="s2">is </span><span class="s1">type(endog.index)  </span><span class="s4"># noqa: E721</span>
    <span class="s1">assert_equal(prediction_index.equals(mod._index[</span><span class="s3">3</span><span class="s1">:])</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s4"># Forecasting: [1, 5]; the index is an extended version of the date index</span>
    <span class="s1">start_key = </span><span class="s3">1</span>
    <span class="s1">end_key = nobs</span>
    <span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">out_of_sample</span><span class="s2">, </span><span class="s1">prediction_index = mod._get_prediction_index(</span>
        <span class="s1">start_key</span><span class="s2">, </span><span class="s1">end_key</span>
    <span class="s1">)</span>

    <span class="s1">assert_equal(start</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(end</span><span class="s2">, </span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">assert_equal(out_of_sample</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">desired_index = pd.date_range(start=</span><span class="s5">&quot;1950-01-02&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s3">5</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;D&quot;</span><span class="s1">)</span>
    <span class="s1">assert_equal(prediction_index.equals(desired_index)</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s4"># Date-based keys</span>

    <span class="s4"># In-sample prediction (equivalent to [1, 3])</span>
    <span class="s1">start_key = </span><span class="s5">&quot;1950-01-02&quot;</span>
    <span class="s1">end_key = </span><span class="s5">&quot;1950-01-04&quot;</span>
    <span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">out_of_sample</span><span class="s2">, </span><span class="s1">prediction_index = mod._get_prediction_index(</span>
        <span class="s1">start_key</span><span class="s2">, </span><span class="s1">end_key</span>
    <span class="s1">)</span>

    <span class="s1">assert_equal(start</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(end</span><span class="s2">, </span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">assert_equal(out_of_sample</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">type(prediction_index) </span><span class="s2">is </span><span class="s1">type(endog.index)  </span><span class="s4"># noqa: E721</span>
    <span class="s1">assert_equal(prediction_index.equals(mod._index[</span><span class="s3">1</span><span class="s1">:</span><span class="s3">4</span><span class="s1">])</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s4"># Out-of-sample forecasting (equivalent to [0, 5])</span>
    <span class="s1">start_key = </span><span class="s5">&quot;1950-01-01&quot;</span>
    <span class="s1">end_key = </span><span class="s5">&quot;1950-01-08&quot;</span>
    <span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">out_of_sample</span><span class="s2">, </span><span class="s1">prediction_index = mod._get_prediction_index(</span>
        <span class="s1">start_key</span><span class="s2">, </span><span class="s1">end_key</span>
    <span class="s1">)</span>

    <span class="s1">assert_equal(start</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">assert_equal(end</span><span class="s2">, </span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">assert_equal(out_of_sample</span><span class="s2">, </span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">desired_index = pd.date_range(start=</span><span class="s5">&quot;1950-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s3">8</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;D&quot;</span><span class="s1">)</span>
    <span class="s1">assert_equal(prediction_index.equals(desired_index)</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s4"># Test getting a location that exists in the (internal) index</span>
    <span class="s1">loc</span><span class="s2">, </span><span class="s1">index</span><span class="s2">, </span><span class="s1">index_was_expanded = mod._get_index_loc(</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">assert_equal(loc</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">desired_index = pd.date_range(start=</span><span class="s5">&quot;1950-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s3">3</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;D&quot;</span><span class="s1">)</span>
    <span class="s1">assert_equal(index.equals(desired_index)</span><span class="s2">, True</span><span class="s1">)</span>
    <span class="s1">assert_equal(index_was_expanded</span><span class="s2">, False</span><span class="s1">)</span>

    <span class="s4"># Test getting a location that exists in the (internal) index</span>
    <span class="s4"># when using the function that alternatively falls back to the row labels</span>
    <span class="s1">loc</span><span class="s2">, </span><span class="s1">index</span><span class="s2">, </span><span class="s1">index_was_expanded = mod._get_index_label_loc(</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">assert_equal(loc</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">desired_index = pd.date_range(start=</span><span class="s5">&quot;1950-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s3">3</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;D&quot;</span><span class="s1">)</span>
    <span class="s1">assert_equal(index.equals(desired_index)</span><span class="s2">, True</span><span class="s1">)</span>
    <span class="s1">assert_equal(index_was_expanded</span><span class="s2">, False</span><span class="s1">)</span>

    <span class="s4"># Test getting a location that exists in the given (unsupported) index</span>
    <span class="s4"># Note that the returned index is now like the row labels</span>
    <span class="s1">loc</span><span class="s2">, </span><span class="s1">index</span><span class="s2">, </span><span class="s1">index_was_expanded = mod._get_index_label_loc(</span><span class="s5">&quot;1950-01-03&quot;</span><span class="s1">)</span>
    <span class="s1">assert_equal(loc</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">desired_index = mod.data.row_labels[:</span><span class="s3">3</span><span class="s1">]</span>
    <span class="s1">assert_equal(index.equals(desired_index)</span><span class="s2">, True</span><span class="s1">)</span>
    <span class="s1">assert_equal(index_was_expanded</span><span class="s2">, False</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_prediction_increment_pandas_dates_monthly():</span>
    <span class="s4"># Date-based index</span>
    <span class="s1">endog = dta[</span><span class="s3">2</span><span class="s1">].copy()</span>
    <span class="s1">endog.index = date_indexes[</span><span class="s3">2</span><span class="s1">][</span><span class="s3">0</span><span class="s1">]  </span><span class="s4"># Monthly, 1950-01, 1950-02, ...</span>
    <span class="s1">mod = tsa_model.TimeSeriesModel(endog)</span>

    <span class="s4"># Tests three common use cases: basic prediction, negative indexes, and</span>
    <span class="s4"># out-of-sample indexes.</span>

    <span class="s4"># Basic prediction: [0, end]; the index is the date index</span>
    <span class="s1">start_key = </span><span class="s3">0</span>
    <span class="s1">end_key = </span><span class="s2">None</span>
    <span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">out_of_sample</span><span class="s2">, </span><span class="s1">prediction_index = mod._get_prediction_index(</span>
        <span class="s1">start_key</span><span class="s2">, </span><span class="s1">end_key</span>
    <span class="s1">)</span>

    <span class="s1">assert_equal(start</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">assert_equal(end</span><span class="s2">, </span><span class="s1">nobs - </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(out_of_sample</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">type(prediction_index) </span><span class="s2">is </span><span class="s1">type(endog.index)  </span><span class="s4"># noqa: E721</span>
    <span class="s1">assert_equal(prediction_index.equals(mod._index)</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s4"># In-sample prediction: [0, 3]; the index is a subset of the date index</span>
    <span class="s1">start_key = </span><span class="s3">0</span>
    <span class="s1">end_key = </span><span class="s3">3</span>
    <span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">out_of_sample</span><span class="s2">, </span><span class="s1">prediction_index = mod._get_prediction_index(</span>
        <span class="s1">start_key</span><span class="s2">, </span><span class="s1">end_key</span>
    <span class="s1">)</span>

    <span class="s1">assert_equal(start</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">assert_equal(end</span><span class="s2">, </span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">assert_equal(out_of_sample</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">type(prediction_index) </span><span class="s2">is </span><span class="s1">type(endog.index)  </span><span class="s4"># noqa: E721</span>
    <span class="s1">assert_equal(prediction_index.equals(mod._index[:</span><span class="s3">4</span><span class="s1">])</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s4"># Negative index: [-2, end]</span>
    <span class="s1">start_key = -</span><span class="s3">2</span>
    <span class="s1">end_key = -</span><span class="s3">1</span>
    <span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">out_of_sample</span><span class="s2">, </span><span class="s1">prediction_index = mod._get_prediction_index(</span>
        <span class="s1">start_key</span><span class="s2">, </span><span class="s1">end_key</span>
    <span class="s1">)</span>

    <span class="s1">assert_equal(start</span><span class="s2">, </span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">assert_equal(end</span><span class="s2">, </span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">assert_equal(out_of_sample</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">type(prediction_index) </span><span class="s2">is </span><span class="s1">type(endog.index)  </span><span class="s4"># noqa: E721</span>
    <span class="s1">assert_equal(prediction_index.equals(mod._index[</span><span class="s3">3</span><span class="s1">:])</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s4"># Forecasting: [1, 5]; the index is an extended version of the date index</span>
    <span class="s1">start_key = </span><span class="s3">1</span>
    <span class="s1">end_key = nobs</span>
    <span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">out_of_sample</span><span class="s2">, </span><span class="s1">prediction_index = mod._get_prediction_index(</span>
        <span class="s1">start_key</span><span class="s2">, </span><span class="s1">end_key</span>
    <span class="s1">)</span>

    <span class="s1">assert_equal(start</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(end</span><span class="s2">, </span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">assert_equal(out_of_sample</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">desired_index = pd.date_range(start=</span><span class="s5">&quot;1950-02&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s3">5</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;M&quot;</span><span class="s1">)</span>
    <span class="s1">assert_equal(prediction_index.equals(desired_index)</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s4"># Date-based keys</span>

    <span class="s4"># In-sample prediction (equivalent to [1, 3])</span>
    <span class="s1">start_key = </span><span class="s5">&quot;1950-02&quot;</span>
    <span class="s1">end_key = </span><span class="s5">&quot;1950-04&quot;</span>
    <span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">out_of_sample</span><span class="s2">, </span><span class="s1">prediction_index = mod._get_prediction_index(</span>
        <span class="s1">start_key</span><span class="s2">, </span><span class="s1">end_key</span>
    <span class="s1">)</span>

    <span class="s1">assert_equal(start</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(end</span><span class="s2">, </span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">assert_equal(out_of_sample</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">type(prediction_index) </span><span class="s2">is </span><span class="s1">type(endog.index)  </span><span class="s4"># noqa: E721</span>
    <span class="s1">assert_equal(prediction_index.equals(mod._index[</span><span class="s3">1</span><span class="s1">:</span><span class="s3">4</span><span class="s1">])</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s4"># Out-of-sample forecasting (equivalent to [0, 5])</span>
    <span class="s1">start_key = </span><span class="s5">&quot;1950-01&quot;</span>
    <span class="s1">end_key = </span><span class="s5">&quot;1950-08&quot;</span>
    <span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">out_of_sample</span><span class="s2">, </span><span class="s1">prediction_index = mod._get_prediction_index(</span>
        <span class="s1">start_key</span><span class="s2">, </span><span class="s1">end_key</span>
    <span class="s1">)</span>

    <span class="s1">assert_equal(start</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">assert_equal(end</span><span class="s2">, </span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">assert_equal(out_of_sample</span><span class="s2">, </span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">desired_index = pd.date_range(start=</span><span class="s5">&quot;1950-01&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s3">8</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;M&quot;</span><span class="s1">)</span>
    <span class="s1">assert_equal(prediction_index.equals(desired_index)</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s4"># Test getting a location that exists in the (internal) index</span>
    <span class="s1">loc</span><span class="s2">, </span><span class="s1">index</span><span class="s2">, </span><span class="s1">index_was_expanded = mod._get_index_loc(</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">assert_equal(loc</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">desired_index = pd.date_range(start=</span><span class="s5">&quot;1950-01&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s3">3</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;M&quot;</span><span class="s1">)</span>
    <span class="s1">assert_equal(index.equals(desired_index)</span><span class="s2">, True</span><span class="s1">)</span>
    <span class="s1">assert_equal(index_was_expanded</span><span class="s2">, False</span><span class="s1">)</span>

    <span class="s4"># Test getting a location that exists in the (internal) index</span>
    <span class="s4"># when using the function that alternatively falls back to the row labels</span>
    <span class="s1">loc</span><span class="s2">, </span><span class="s1">index</span><span class="s2">, </span><span class="s1">index_was_expanded = mod._get_index_label_loc(</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">assert_equal(loc</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">desired_index = pd.date_range(start=</span><span class="s5">&quot;1950-01&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s3">3</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;M&quot;</span><span class="s1">)</span>
    <span class="s1">assert_equal(index.equals(desired_index)</span><span class="s2">, True</span><span class="s1">)</span>
    <span class="s1">assert_equal(index_was_expanded</span><span class="s2">, False</span><span class="s1">)</span>

    <span class="s4"># Test getting a location that exists in the given (unsupported) index</span>
    <span class="s4"># Note that the returned index is now like the row labels</span>
    <span class="s1">loc</span><span class="s2">, </span><span class="s1">index</span><span class="s2">, </span><span class="s1">index_was_expanded = mod._get_index_label_loc(</span><span class="s5">&quot;1950-03&quot;</span><span class="s1">)</span>
    <span class="s1">assert_equal(loc</span><span class="s2">, </span><span class="s1">slice(</span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, None</span><span class="s1">))</span>
    <span class="s1">desired_index = mod.data.row_labels[:</span><span class="s3">3</span><span class="s1">]</span>
    <span class="s1">assert_equal(index.equals(desired_index)</span><span class="s2">, True</span><span class="s1">)</span>
    <span class="s1">assert_equal(index_was_expanded</span><span class="s2">, False</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_prediction_increment_pandas_dates_nanosecond():</span>
    <span class="s4"># Date-based index</span>
    <span class="s1">endog = dta[</span><span class="s3">2</span><span class="s1">].copy()</span>
    <span class="s1">endog.index = pd.date_range(</span>
        <span class="s1">start=</span><span class="s5">&quot;1970-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=len(endog)</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;N&quot;</span>
    <span class="s1">)</span>
    <span class="s1">mod = tsa_model.TimeSeriesModel(endog)</span>

    <span class="s4"># Tests three common use cases: basic prediction, negative indexes, and</span>
    <span class="s4"># out-of-sample indexes.</span>

    <span class="s4"># Basic prediction: [0, end]; the index is the date index</span>
    <span class="s1">start_key = </span><span class="s3">0</span>
    <span class="s1">end_key = </span><span class="s2">None</span>
    <span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">out_of_sample</span><span class="s2">, </span><span class="s1">prediction_index = mod._get_prediction_index(</span>
        <span class="s1">start_key</span><span class="s2">, </span><span class="s1">end_key</span>
    <span class="s1">)</span>

    <span class="s1">assert_equal(start</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">assert_equal(end</span><span class="s2">, </span><span class="s1">nobs - </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(out_of_sample</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">type(prediction_index) </span><span class="s2">is </span><span class="s1">type(endog.index)  </span><span class="s4"># noqa: E721</span>
    <span class="s1">assert_equal(prediction_index.equals(mod._index)</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s4"># Negative index: [-2, end]</span>
    <span class="s1">start_key = -</span><span class="s3">2</span>
    <span class="s1">end_key = -</span><span class="s3">1</span>
    <span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">out_of_sample</span><span class="s2">, </span><span class="s1">prediction_index = mod._get_prediction_index(</span>
        <span class="s1">start_key</span><span class="s2">, </span><span class="s1">end_key</span>
    <span class="s1">)</span>

    <span class="s1">assert_equal(start</span><span class="s2">, </span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">assert_equal(end</span><span class="s2">, </span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">assert_equal(out_of_sample</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">type(prediction_index) </span><span class="s2">is </span><span class="s1">type(endog.index)  </span><span class="s4"># noqa: E721</span>
    <span class="s1">assert_equal(prediction_index.equals(mod._index[</span><span class="s3">3</span><span class="s1">:])</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s4"># Forecasting: [1, 5]; the index is an extended version of the date index</span>
    <span class="s1">start_key = </span><span class="s3">1</span>
    <span class="s1">end_key = nobs</span>
    <span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">out_of_sample</span><span class="s2">, </span><span class="s1">prediction_index = mod._get_prediction_index(</span>
        <span class="s1">start_key</span><span class="s2">, </span><span class="s1">end_key</span>
    <span class="s1">)</span>

    <span class="s1">assert_equal(start</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(end</span><span class="s2">, </span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">assert_equal(out_of_sample</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">desired_index = pd.date_range(start=</span><span class="s5">&quot;1970-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s3">6</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;N&quot;</span><span class="s1">)[</span><span class="s3">1</span><span class="s1">:]</span>
    <span class="s1">assert_equal(prediction_index.equals(desired_index)</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s4"># Date-based keys</span>
    <span class="s1">start_key = pd.Timestamp(</span><span class="s5">&quot;1970-01-01&quot;</span><span class="s1">)</span>
    <span class="s1">end_key = pd.Timestamp(start_key.value + </span><span class="s3">7</span><span class="s1">)</span>
    <span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">out_of_sample</span><span class="s2">, </span><span class="s1">prediction_index = mod._get_prediction_index(</span>
        <span class="s1">start_key</span><span class="s2">, </span><span class="s1">end_key</span>
    <span class="s1">)</span>

    <span class="s1">assert_equal(start</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">assert_equal(end</span><span class="s2">, </span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">assert_equal(out_of_sample</span><span class="s2">, </span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">desired_index = pd.date_range(start=</span><span class="s5">&quot;1970-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s3">8</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;N&quot;</span><span class="s1">)</span>
    <span class="s1">assert_equal(prediction_index.equals(desired_index)</span><span class="s2">, True</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_range_index():</span>
    <span class="s1">tsa_model.__warningregistry__ = {}</span>

    <span class="s1">endog = pd.Series(np.random.normal(size=</span><span class="s3">5</span><span class="s1">))</span>
    <span class="s1">assert_equal(isinstance(endog.index</span><span class="s2">, </span><span class="s1">pd.RangeIndex)</span><span class="s2">, True</span><span class="s1">)</span>
    <span class="s4"># Warning should not be given</span>
    <span class="s2">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s2">True</span><span class="s1">) </span><span class="s2">as </span><span class="s1">w:</span>
        <span class="s1">warnings.simplefilter(</span><span class="s5">&quot;always&quot;</span><span class="s1">)</span>
        <span class="s1">mod = tsa_model.TimeSeriesModel(endog)</span>
        <span class="s1">assert_equal(len(w)</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_prediction_rangeindex():</span>
    <span class="s1">index = supported_increment_indexes[</span><span class="s3">2</span><span class="s1">][</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s1">endog = pd.Series(dta[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">index=index)</span>
    <span class="s1">mod = tsa_model.TimeSeriesModel(endog)</span>

    <span class="s4"># Tests three common use cases: basic prediction, negative indexes, and</span>
    <span class="s4"># out-of-sample indexes.</span>

    <span class="s4"># Basic prediction: [0, end]</span>
    <span class="s1">start_key = </span><span class="s3">0</span>
    <span class="s1">end_key = </span><span class="s2">None</span>
    <span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">out_of_sample</span><span class="s2">, </span><span class="s1">prediction_index = mod._get_prediction_index(</span>
        <span class="s1">start_key</span><span class="s2">, </span><span class="s1">end_key</span>
    <span class="s1">)</span>

    <span class="s1">assert_equal(start</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">assert_equal(end</span><span class="s2">, </span><span class="s1">nobs - </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(out_of_sample</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">desired_index = pd.RangeIndex(start=-</span><span class="s3">5</span><span class="s2">, </span><span class="s1">stop=</span><span class="s3">0</span><span class="s2">, </span><span class="s1">step=</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(prediction_index.equals(desired_index)</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s4"># Negative index: [-2, end]</span>
    <span class="s1">start_key = -</span><span class="s3">2</span>
    <span class="s1">end_key = -</span><span class="s3">1</span>
    <span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">out_of_sample</span><span class="s2">, </span><span class="s1">prediction_index = mod._get_prediction_index(</span>
        <span class="s1">start_key</span><span class="s2">, </span><span class="s1">end_key</span>
    <span class="s1">)</span>

    <span class="s1">assert_equal(start</span><span class="s2">, </span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">assert_equal(end</span><span class="s2">, </span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">assert_equal(out_of_sample</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">desired_index = pd.RangeIndex(start=-</span><span class="s3">2</span><span class="s2">, </span><span class="s1">stop=</span><span class="s3">0</span><span class="s2">, </span><span class="s1">step=</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(prediction_index.equals(desired_index)</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s4"># Forecasting: [1, 5]</span>
    <span class="s1">start_key = </span><span class="s3">1</span>
    <span class="s1">end_key = nobs</span>
    <span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">out_of_sample</span><span class="s2">, </span><span class="s1">prediction_index = mod._get_prediction_index(</span>
        <span class="s1">start_key</span><span class="s2">, </span><span class="s1">end_key</span>
    <span class="s1">)</span>

    <span class="s1">assert_equal(start</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(end</span><span class="s2">, </span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">assert_equal(out_of_sample</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">desired_index = pd.RangeIndex(start=-</span><span class="s3">4</span><span class="s2">, </span><span class="s1">stop=</span><span class="s3">1</span><span class="s2">, </span><span class="s1">step=</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(prediction_index.equals(desired_index)</span><span class="s2">, True</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_prediction_rangeindex_withstep():</span>
    <span class="s1">index = supported_increment_indexes[</span><span class="s3">3</span><span class="s1">][</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s1">endog = pd.Series(dta[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">index=index)</span>
    <span class="s1">mod = tsa_model.TimeSeriesModel(endog)</span>

    <span class="s4"># Tests three common use cases: basic prediction, negative indexes, and</span>
    <span class="s4"># out-of-sample indexes.</span>

    <span class="s4"># Basic prediction: [0, end]</span>
    <span class="s1">start_key = </span><span class="s3">0</span>
    <span class="s1">end_key = </span><span class="s2">None</span>
    <span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">out_of_sample</span><span class="s2">, </span><span class="s1">prediction_index = mod._get_prediction_index(</span>
        <span class="s1">start_key</span><span class="s2">, </span><span class="s1">end_key</span>
    <span class="s1">)</span>

    <span class="s1">assert_equal(start</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">assert_equal(end</span><span class="s2">, </span><span class="s1">nobs - </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(out_of_sample</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">desired_index = pd.RangeIndex(start=</span><span class="s3">0</span><span class="s2">, </span><span class="s1">stop=nobs * </span><span class="s3">6</span><span class="s2">, </span><span class="s1">step=</span><span class="s3">6</span><span class="s1">)</span>
    <span class="s1">assert_equal(prediction_index.equals(desired_index)</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s4"># Negative index: [-2, end]</span>
    <span class="s1">start_key = -</span><span class="s3">2</span>
    <span class="s1">end_key = -</span><span class="s3">1</span>
    <span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">out_of_sample</span><span class="s2">, </span><span class="s1">prediction_index = mod._get_prediction_index(</span>
        <span class="s1">start_key</span><span class="s2">, </span><span class="s1">end_key</span>
    <span class="s1">)</span>

    <span class="s1">assert_equal(start</span><span class="s2">, </span><span class="s3">3</span><span class="s1">)</span>
    <span class="s1">assert_equal(end</span><span class="s2">, </span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">assert_equal(out_of_sample</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">desired_index = pd.RangeIndex(start=</span><span class="s3">3 </span><span class="s1">* </span><span class="s3">6</span><span class="s2">, </span><span class="s1">stop=nobs * </span><span class="s3">6</span><span class="s2">, </span><span class="s1">step=</span><span class="s3">6</span><span class="s1">)</span>
    <span class="s1">assert_equal(prediction_index.equals(desired_index)</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s4"># Forecasting: [1, 5]</span>
    <span class="s1">start_key = </span><span class="s3">1</span>
    <span class="s1">end_key = nobs</span>
    <span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">out_of_sample</span><span class="s2">, </span><span class="s1">prediction_index = mod._get_prediction_index(</span>
        <span class="s1">start_key</span><span class="s2">, </span><span class="s1">end_key</span>
    <span class="s1">)</span>

    <span class="s1">assert_equal(start</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(end</span><span class="s2">, </span><span class="s3">4</span><span class="s1">)</span>
    <span class="s1">assert_equal(out_of_sample</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">desired_index = pd.RangeIndex(start=</span><span class="s3">1 </span><span class="s1">* </span><span class="s3">6</span><span class="s2">, </span><span class="s1">stop=(nobs + </span><span class="s3">1</span><span class="s1">) * </span><span class="s3">6</span><span class="s2">, </span><span class="s1">step=</span><span class="s3">6</span><span class="s1">)</span>
    <span class="s1">assert_equal(prediction_index.equals(desired_index)</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s4"># Test getting a location that exists in the index</span>
    <span class="s1">loc</span><span class="s2">, </span><span class="s1">index</span><span class="s2">, </span><span class="s1">index_was_expanded = mod._get_index_loc(</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">assert_equal(loc</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">desired_index = pd.RangeIndex(start=</span><span class="s3">0</span><span class="s2">, </span><span class="s1">stop=</span><span class="s3">3 </span><span class="s1">* </span><span class="s3">6</span><span class="s2">, </span><span class="s1">step=</span><span class="s3">6</span><span class="s1">)</span>
    <span class="s1">assert_equal(index.equals(desired_index)</span><span class="s2">, True</span><span class="s1">)</span>
    <span class="s1">assert_equal(index_was_expanded</span><span class="s2">, False</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_custom_index():</span>
    <span class="s1">tsa_model.__warningregistry__ = {}</span>

    <span class="s1">endog = pd.Series(</span>
        <span class="s1">np.random.normal(size=</span><span class="s3">5</span><span class="s1">)</span><span class="s2">, </span><span class="s1">index=[</span><span class="s5">&quot;a&quot;</span><span class="s2">, </span><span class="s5">&quot;b&quot;</span><span class="s2">, </span><span class="s5">&quot;c&quot;</span><span class="s2">, </span><span class="s5">&quot;d&quot;</span><span class="s2">, </span><span class="s5">&quot;e&quot;</span><span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s1">message = (</span>
        <span class="s5">&quot;An unsupported index was provided and will be ignored when&quot;</span>
        <span class="s5">&quot; e.g. forecasting.&quot;</span>
    <span class="s1">)</span>
    <span class="s2">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s2">True</span><span class="s1">) </span><span class="s2">as </span><span class="s1">w:</span>
        <span class="s1">warnings.simplefilter(</span><span class="s5">&quot;always&quot;</span><span class="s1">)</span>

        <span class="s1">mod = tsa_model.TimeSeriesModel(endog)</span>
        <span class="s4"># Change due to pandas changes that produce a warning</span>
        <span class="s1">messages = [str(warn.message) </span><span class="s2">for </span><span class="s1">warn </span><span class="s2">in </span><span class="s1">w]</span>
        <span class="s2">assert </span><span class="s1">message </span><span class="s2">in </span><span class="s1">messages</span>
    <span class="s1">start_key = -</span><span class="s3">2</span>
    <span class="s1">end_key = -</span><span class="s3">1</span>
    <span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">out_of_sample</span><span class="s2">, </span><span class="s1">prediction_index = mod._get_prediction_index(</span>
        <span class="s1">start_key</span><span class="s2">, </span><span class="s1">end_key</span>
    <span class="s1">)</span>

    <span class="s4"># Test the default output index</span>
    <span class="s1">assert_equal(prediction_index.equals(pd.Index([</span><span class="s5">&quot;d&quot;</span><span class="s2">, </span><span class="s5">&quot;e&quot;</span><span class="s1">]))</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s4"># Test custom output index</span>
    <span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">out_of_sample</span><span class="s2">, </span><span class="s1">prediction_index = mod._get_prediction_index(</span>
        <span class="s1">start_key</span><span class="s2">, </span><span class="s1">end_key</span><span class="s2">, </span><span class="s1">index=[</span><span class="s5">&quot;f&quot;</span><span class="s2">, </span><span class="s5">&quot;g&quot;</span><span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s1">assert_equal(prediction_index.equals(pd.Index([</span><span class="s5">&quot;f&quot;</span><span class="s2">, </span><span class="s5">&quot;g&quot;</span><span class="s1">]))</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s4"># Test getting a location in the index w/o fallback to row labels</span>
    <span class="s1">loc</span><span class="s2">, </span><span class="s1">index</span><span class="s2">, </span><span class="s1">index_was_expanded = mod._get_index_loc(</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">assert_equal(loc</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">assert_equal(index.equals(pd.RangeIndex(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">3</span><span class="s1">))</span><span class="s2">, True</span><span class="s1">)</span>
    <span class="s1">assert_equal(index_was_expanded</span><span class="s2">, False</span><span class="s1">)</span>
    <span class="s1">assert_equal(index_was_expanded</span><span class="s2">, False</span><span class="s1">)</span>

    <span class="s4"># Test getting an invalid location in the index w/ fallback to row labels</span>
    <span class="s2">with </span><span class="s1">pytest.raises(KeyError):</span>
        <span class="s1">mod._get_index_loc(</span><span class="s5">&quot;c&quot;</span><span class="s1">)</span>

    <span class="s4"># Test getting a location in the index w/ fallback to row labels</span>
    <span class="s1">loc</span><span class="s2">, </span><span class="s1">index</span><span class="s2">, </span><span class="s1">index_was_expanded = mod._get_index_label_loc(</span><span class="s5">&quot;c&quot;</span><span class="s1">)</span>
    <span class="s1">assert_equal(loc</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">assert_equal(index.equals(pd.Index([</span><span class="s5">&quot;a&quot;</span><span class="s2">, </span><span class="s5">&quot;b&quot;</span><span class="s2">, </span><span class="s5">&quot;c&quot;</span><span class="s1">]))</span><span class="s2">, True</span><span class="s1">)</span>
    <span class="s1">assert_equal(index_was_expanded</span><span class="s2">, False</span><span class="s1">)</span>

    <span class="s4"># Test getting an invalid location in the index w/ fallback to row labels</span>
    <span class="s2">with </span><span class="s1">pytest.raises(KeyError):</span>
        <span class="s1">mod._get_index_label_loc(</span><span class="s5">&quot;aa&quot;</span><span class="s1">)</span>

    <span class="s4"># Test out-of-sample</span>
    <span class="s1">start_key = </span><span class="s3">4</span>
    <span class="s1">end_key = </span><span class="s3">5</span>
    <span class="s1">message = (</span>
        <span class="s5">&quot;No supported index is available.&quot;</span>
        <span class="s5">&quot; Prediction results will be given with&quot;</span>
        <span class="s5">&quot; an integer index beginning at `start`.&quot;</span>
    <span class="s1">)</span>
    <span class="s2">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s2">True</span><span class="s1">) </span><span class="s2">as </span><span class="s1">w:</span>
        <span class="s1">warnings.simplefilter(</span><span class="s5">&quot;always&quot;</span><span class="s1">)</span>

        <span class="s1">(</span>
            <span class="s1">start</span><span class="s2">,</span>
            <span class="s1">end</span><span class="s2">,</span>
            <span class="s1">out_of_sample</span><span class="s2">,</span>
            <span class="s1">prediction_index</span><span class="s2">,</span>
        <span class="s1">) = mod._get_prediction_index(start_key</span><span class="s2">, </span><span class="s1">end_key)</span>
        <span class="s1">assert_equal(prediction_index.equals(pd.Index([</span><span class="s3">4</span><span class="s2">, </span><span class="s3">5</span><span class="s1">]))</span><span class="s2">, True</span><span class="s1">)</span>
        <span class="s1">assert_equal(str(w[</span><span class="s3">0</span><span class="s1">].message)</span><span class="s2">, </span><span class="s1">message)</span>

    <span class="s4"># Test out-of-sample custom index</span>
    <span class="s1">start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">out_of_sample</span><span class="s2">, </span><span class="s1">prediction_index = mod._get_prediction_index(</span>
        <span class="s1">start_key</span><span class="s2">, </span><span class="s1">end_key</span><span class="s2">, </span><span class="s1">index=[</span><span class="s5">&quot;f&quot;</span><span class="s2">, </span><span class="s5">&quot;g&quot;</span><span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s1">assert_equal(prediction_index.equals(pd.Index([</span><span class="s5">&quot;f&quot;</span><span class="s2">, </span><span class="s5">&quot;g&quot;</span><span class="s1">]))</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s4"># Test invalid custom index</span>
    <span class="s1">assert_raises(</span>
        <span class="s1">ValueError</span><span class="s2">,</span>
        <span class="s1">mod._get_prediction_index</span><span class="s2">,</span>
        <span class="s1">start_key</span><span class="s2">,</span>
        <span class="s1">end_key</span><span class="s2">,</span>
        <span class="s1">index=[</span><span class="s5">&quot;f&quot;</span><span class="s2">, </span><span class="s5">&quot;g&quot;</span><span class="s2">, </span><span class="s5">&quot;h&quot;</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_nonmonotonic_periodindex():</span>
    <span class="s4"># Create a nonmonotonic period index</span>
    <span class="s1">tmp = pd.period_range(start=</span><span class="s3">2000</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">2002</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;A&quot;</span><span class="s1">)</span>
    <span class="s1">index = tmp.tolist() + tmp.tolist()</span>
    <span class="s1">endog = pd.Series(np.zeros(len(index))</span><span class="s2">, </span><span class="s1">index=index)</span>

    <span class="s1">message = (</span>
        <span class="s5">&quot;A date index has been provided, but it is not&quot;</span>
        <span class="s5">&quot; monotonic and so will be ignored when e.g.&quot;</span>
        <span class="s5">&quot; forecasting.&quot;</span>
    <span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.warns(ValueWarning</span><span class="s2">, </span><span class="s1">match=message):</span>
        <span class="s1">tsa_model.TimeSeriesModel(endog)</span>


<span class="s1">@pytest.mark.xfail(</span>
    <span class="s1">reason=</span><span class="s5">&quot;Pandas PeriodIndex.is_full does not yet work for&quot;</span>
    <span class="s5">&quot; all frequencies (e.g. frequencies with a&quot;</span>
    <span class="s5">' multiplier, like &quot;2Q&quot;).'</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_nonfull_periodindex():</span>
    <span class="s1">index = pd.PeriodIndex([</span><span class="s5">&quot;2000-01&quot;</span><span class="s2">, </span><span class="s5">&quot;2000-03&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;M&quot;</span><span class="s1">)</span>
    <span class="s1">endog = pd.Series(np.zeros(len(index))</span><span class="s2">, </span><span class="s1">index=index)</span>

    <span class="s1">message = (</span>
        <span class="s5">&quot;A Period index has been provided, but it is not&quot;</span>
        <span class="s5">&quot; full and so will be ignored when e.g.&quot;</span>
        <span class="s5">&quot; forecasting.&quot;</span>
    <span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.warns(ValueWarning</span><span class="s2">, </span><span class="s1">match=message):</span>
        <span class="s1">tsa_model.TimeSeriesModel(endog)</span>


<span class="s2">def </span><span class="s1">test_get_index_loc_quarterly():</span>
    <span class="s4"># See GH#6339</span>

    <span class="s1">ix = pd.date_range(</span><span class="s5">&quot;2000Q1&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s3">8</span><span class="s2">, </span><span class="s1">freq=</span><span class="s5">&quot;QS&quot;</span><span class="s1">)</span>
    <span class="s1">endog = pd.Series(np.zeros(</span><span class="s3">8</span><span class="s1">)</span><span class="s2">, </span><span class="s1">index=ix)</span>

    <span class="s1">mod = tsa_model.TimeSeriesModel(endog)</span>
    <span class="s1">loc</span><span class="s2">, </span><span class="s1">index</span><span class="s2">, </span><span class="s1">_ = mod._get_index_loc(</span><span class="s5">&quot;2003Q2&quot;</span><span class="s1">)</span>
    <span class="s1">assert_equal(index[loc]</span><span class="s2">, </span><span class="s1">pd.Timestamp(</span><span class="s5">&quot;2003Q2&quot;</span><span class="s1">))</span>
</pre>
</body>
</html>