<html>
<head>
<title>simulation_smoother.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
simulation_smoother.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
State Space Representation, Kalman Filter, Smoother, and Simulation Smoother 
 
Author: Chad Fulton 
License: Simplified-BSD 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">numbers</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">.kalman_smoother </span><span class="s2">import </span><span class="s1">KalmanSmoother</span>
<span class="s2">from </span><span class="s1">.cfa_simulation_smoother </span><span class="s2">import </span><span class="s1">CFASimulationSmoother</span>
<span class="s2">from </span><span class="s1">. </span><span class="s2">import </span><span class="s1">tools</span>

<span class="s1">SIMULATION_STATE = </span><span class="s3">0x01</span>
<span class="s1">SIMULATION_DISTURBANCE = </span><span class="s3">0x04</span>
<span class="s1">SIMULATION_ALL = (</span>
    <span class="s1">SIMULATION_STATE | SIMULATION_DISTURBANCE</span>
<span class="s1">)</span>


<span class="s4"># Based on scipy.states._qmc.check_random_state</span>
<span class="s2">def </span><span class="s1">check_random_state(seed=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Turn `seed` into a `numpy.random.Generator` instance. 
    Parameters 
    ---------- 
    seed : {None, int, Generator, RandomState}, optional 
        If `seed` is None (or `np.random`), the `numpy.random.RandomState` 
        singleton is used. 
        If `seed` is an int, a new ``numpy.random.RandomState`` instance 
        is used, seeded with `seed`. 
        If `seed` is already a ``numpy.random.Generator`` or 
        ``numpy.random.RandomState`` instance then that instance is used. 
    Returns 
    ------- 
    seed : {`numpy.random.Generator`, `numpy.random.RandomState`} 
        Random number generator. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">seed </span><span class="s2">is None or </span><span class="s1">isinstance(seed</span><span class="s2">, </span><span class="s1">(numbers.Integral</span><span class="s2">, </span><span class="s1">np.integer)):</span>
        <span class="s2">return </span><span class="s1">np.random.default_rng(seed)</span>
    <span class="s2">elif </span><span class="s1">isinstance(seed</span><span class="s2">, </span><span class="s1">(np.random.RandomState</span><span class="s2">, </span><span class="s1">np.random.Generator)):</span>
        <span class="s2">return </span><span class="s1">seed</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">f'</span><span class="s2">{</span><span class="s1">seed</span><span class="s2">!r} </span><span class="s5">cannot be used to seed a'</span>
                         <span class="s5">' numpy.random.Generator instance'</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">SimulationSmoother(KalmanSmoother):</span>
    <span class="s0">r&quot;&quot;&quot; 
    State space representation of a time series process, with Kalman filter 
    and smoother, and with simulation smoother. 
 
    Parameters 
    ---------- 
    k_endog : {array_like, int} 
        The observed time-series process :math:`y` if array like or the 
        number of variables in the process if an integer. 
    k_states : int 
        The dimension of the unobserved state process. 
    k_posdef : int, optional 
        The dimension of a guaranteed positive definite covariance matrix 
        describing the shocks in the measurement equation. Must be less than 
        or equal to `k_states`. Default is `k_states`. 
    simulation_smooth_results_class : class, optional 
        Default results class to use to save output of simulation smoothing. 
        Default is `SimulationSmoothResults`. If specified, class must extend 
        from `SimulationSmoothResults`. 
    simulation_smoother_classes : dict, optional 
        Dictionary with BLAS prefixes as keys and classes as values. 
    **kwargs 
        Keyword arguments may be used to provide default values for state space 
        matrices, for Kalman filtering options, for Kalman smoothing 
        options, or for Simulation smoothing options. 
        See `Representation`, `KalmanFilter`, and `KalmanSmoother` for more 
        details. 
    &quot;&quot;&quot;</span>

    <span class="s1">simulation_outputs = [</span>
        <span class="s5">'simulate_state'</span><span class="s2">, </span><span class="s5">'simulate_disturbance'</span><span class="s2">, </span><span class="s5">'simulate_all'</span>
    <span class="s1">]</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">k_endog</span><span class="s2">, </span><span class="s1">k_states</span><span class="s2">, </span><span class="s1">k_posdef=</span><span class="s2">None,</span>
                 <span class="s1">simulation_smooth_results_class=</span><span class="s2">None,</span>
                 <span class="s1">simulation_smoother_classes=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s1">super(SimulationSmoother</span><span class="s2">, </span><span class="s1">self).__init__(</span>
            <span class="s1">k_endog</span><span class="s2">, </span><span class="s1">k_states</span><span class="s2">, </span><span class="s1">k_posdef</span><span class="s2">, </span><span class="s1">**kwargs</span>
        <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">simulation_smooth_results_class </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">simulation_smooth_results_class = SimulationSmoothResults</span>
        <span class="s1">self.simulation_smooth_results_class = simulation_smooth_results_class</span>

        <span class="s1">self.prefix_simulation_smoother_map = (</span>
            <span class="s1">simulation_smoother_classes</span>
            <span class="s2">if </span><span class="s1">simulation_smoother_classes </span><span class="s2">is not None</span>
            <span class="s2">else </span><span class="s1">tools.prefix_simulation_smoother_map.copy())</span>

        <span class="s4"># Holder for an model-level simulation smoother objects, to use in</span>
        <span class="s4"># simulating new time series.</span>
        <span class="s1">self._simulators = {}</span>

    <span class="s2">def </span><span class="s1">get_simulation_output(self</span><span class="s2">, </span><span class="s1">simulation_output=</span><span class="s2">None,</span>
                              <span class="s1">simulate_state=</span><span class="s2">None, </span><span class="s1">simulate_disturbance=</span><span class="s2">None,</span>
                              <span class="s1">simulate_all=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s0">r&quot;&quot;&quot; 
        Get simulation output bitmask 
 
        Helper method to get final simulation output bitmask from a set of 
        optional arguments including the bitmask itself and possibly boolean 
        flags. 
 
        Parameters 
        ---------- 
        simulation_output : int, optional 
            Simulation output bitmask. If this is specified, it is simply 
            returned and the other arguments are ignored. 
        simulate_state : bool, optional 
            Whether or not to include the state in the simulation output. 
        simulate_disturbance : bool, optional 
            Whether or not to include the state and observation disturbances 
            in the simulation output. 
        simulate_all : bool, optional 
            Whether or not to include all simulation output. 
        \*\*kwargs 
            Additional keyword arguments. Present so that calls to this method 
            can use \*\*kwargs without clearing out additional arguments. 
        &quot;&quot;&quot;</span>
        <span class="s4"># If we do not explicitly have simulation_output, try to get it from</span>
        <span class="s4"># kwargs</span>
        <span class="s2">if </span><span class="s1">simulation_output </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">simulation_output = </span><span class="s3">0</span>

            <span class="s2">if </span><span class="s1">simulate_state:</span>
                <span class="s1">simulation_output |= SIMULATION_STATE</span>
            <span class="s2">if </span><span class="s1">simulate_disturbance:</span>
                <span class="s1">simulation_output |= SIMULATION_DISTURBANCE</span>
            <span class="s2">if </span><span class="s1">simulate_all:</span>
                <span class="s1">simulation_output |= SIMULATION_ALL</span>

            <span class="s4"># Handle case of no information in kwargs</span>
            <span class="s2">if </span><span class="s1">simulation_output == </span><span class="s3">0</span><span class="s1">:</span>

                <span class="s4"># If some arguments were passed, but we still do not have any</span>
                <span class="s4"># simulation output, raise an exception</span>
                <span class="s1">argument_set = </span><span class="s2">not </span><span class="s1">all([</span>
                    <span class="s1">simulate_state </span><span class="s2">is None, </span><span class="s1">simulate_disturbance </span><span class="s2">is None,</span>
                    <span class="s1">simulate_all </span><span class="s2">is None</span>
                <span class="s1">])</span>
                <span class="s2">if </span><span class="s1">argument_set:</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;Invalid simulation output options:&quot;</span>
                                     <span class="s5">&quot; given options would result in no&quot;</span>
                                     <span class="s5">&quot; output.&quot;</span><span class="s1">)</span>

                <span class="s4"># Otherwise set simulation output to be the same as smoother</span>
                <span class="s4"># output</span>
                <span class="s1">simulation_output = self.smoother_output</span>

        <span class="s2">return </span><span class="s1">simulation_output</span>

    <span class="s2">def </span><span class="s1">_simulate(self</span><span class="s2">, </span><span class="s1">nsimulations</span><span class="s2">, </span><span class="s1">simulator=</span><span class="s2">None, </span><span class="s1">random_state=</span><span class="s2">None,</span>
                  <span class="s1">return_simulator=</span><span class="s2">False, </span><span class="s1">**kwargs):</span>
        <span class="s4"># Create the simulator, if necessary</span>
        <span class="s2">if </span><span class="s1">simulator </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">simulator = self.simulator(nsimulations</span><span class="s2">, </span><span class="s1">random_state=random_state)</span>

        <span class="s4"># Perform simulation smoothing</span>
        <span class="s1">simulator.simulate(**kwargs)</span>

        <span class="s4"># Retrieve and return the objects of interest</span>
        <span class="s1">simulated_obs = np.array(simulator.generated_obs</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">simulated_state = np.array(simulator.generated_state</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s1">out = (simulated_obs.T[:nsimulations]</span><span class="s2">,</span>
               <span class="s1">simulated_state.T[:nsimulations])</span>
        <span class="s2">if </span><span class="s1">return_simulator:</span>
            <span class="s1">out = out + (simulator</span><span class="s2">,</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">out</span>

    <span class="s2">def </span><span class="s1">simulator(self</span><span class="s2">, </span><span class="s1">nsimulations</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s1">self.simulation_smoother(simulation_output=</span><span class="s3">0</span><span class="s2">, </span><span class="s1">method=</span><span class="s5">'kfs'</span><span class="s2">,</span>
                                        <span class="s1">nobs=nsimulations</span><span class="s2">,</span>
                                        <span class="s1">random_state=random_state)</span>

    <span class="s2">def </span><span class="s1">simulation_smoother(self</span><span class="s2">, </span><span class="s1">simulation_output=</span><span class="s2">None, </span><span class="s1">method=</span><span class="s5">'kfs'</span><span class="s2">,</span>
                            <span class="s1">results_class=</span><span class="s2">None, </span><span class="s1">prefix=</span><span class="s2">None, </span><span class="s1">nobs=-</span><span class="s3">1</span><span class="s2">,</span>
                            <span class="s1">random_state=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s0">r&quot;&quot;&quot; 
        Retrieve a simulation smoother for the statespace model. 
 
        Parameters 
        ---------- 
        simulation_output : int, optional 
            Determines which simulation smoother output is calculated. 
            Default is all (including state and disturbances). 
        method : {'kfs', 'cfa'}, optional 
            Method for simulation smoothing. If `method='kfs'`, then the 
            simulation smoother is based on Kalman filtering and smoothing 
            recursions. If `method='cfa'`, then the simulation smoother is 
            based on the Cholesky Factor Algorithm (CFA) approach. The CFA 
            approach is not applicable to all state space models, but can be 
            faster for the cases in which it is supported. 
        results_class : class, optional 
            Default results class to use to save output of simulation 
            smoothing. Default is `SimulationSmoothResults`. If specified, 
            class must extend from `SimulationSmoothResults`. 
        prefix : str 
            The prefix of the datatype. Usually only used internally. 
        nobs : int 
            The number of observations to simulate. If set to anything other 
            than -1, only simulation will be performed (i.e. simulation 
            smoothing will not be performed), so that only the `generated_obs` 
            and `generated_state` attributes will be available. 
        random_state : {None, int, Generator, RandomState}, optional 
            If `seed` is None (or `np.random`), the `numpy.random.RandomState` 
            singleton is used. 
            If `seed` is an int, a new ``numpy.random.RandomState`` instance 
            is used, seeded with `seed`. 
            If `seed` is already a ``numpy.random.Generator`` or 
            ``numpy.random.RandomState`` instance then that instance is used. 
        **kwargs 
            Additional keyword arguments, used to set the simulation output. 
            See `set_simulation_output` for more details. 
 
        Returns 
        ------- 
        SimulationSmoothResults 
        &quot;&quot;&quot;</span>
        <span class="s1">method = method.lower()</span>

        <span class="s4"># Short-circuit for CFA</span>
        <span class="s2">if </span><span class="s1">method == </span><span class="s5">'cfa'</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">simulation_output </span><span class="s2">not in </span><span class="s1">[</span><span class="s2">None, </span><span class="s3">1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">]:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'Can only retrieve simulations of the state'</span>
                                 <span class="s5">' vector using the CFA simulation smoother.'</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">CFASimulationSmoother(self)</span>
        <span class="s2">elif </span><span class="s1">method != </span><span class="s5">'kfs'</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'Invalid simulation smoother method &quot;%s&quot;. Valid'</span>
                             <span class="s5">' methods are &quot;kfs&quot; or &quot;cfa&quot;.' </span><span class="s1">% method)</span>

        <span class="s4"># Set the class to be the default results class, if None provided</span>
        <span class="s2">if </span><span class="s1">results_class </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">results_class = self.simulation_smooth_results_class</span>

        <span class="s4"># Instantiate a new results object</span>
        <span class="s2">if not </span><span class="s1">issubclass(results_class</span><span class="s2">, </span><span class="s1">SimulationSmoothResults):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'Invalid results class provided.'</span><span class="s1">)</span>

        <span class="s4"># Make sure we have the required Statespace representation</span>
        <span class="s1">prefix</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">create_smoother</span><span class="s2">, </span><span class="s1">create_filter</span><span class="s2">, </span><span class="s1">create_statespace = (</span>
            <span class="s1">self._initialize_smoother())</span>

        <span class="s4"># Simulation smoother parameters</span>
        <span class="s1">simulation_output = self.get_simulation_output(simulation_output</span><span class="s2">,</span>
                                                       <span class="s1">**kwargs)</span>

        <span class="s4"># Kalman smoother parameters</span>
        <span class="s1">smoother_output = kwargs.get(</span><span class="s5">'smoother_output'</span><span class="s2">, </span><span class="s1">simulation_output)</span>

        <span class="s4"># Kalman filter parameters</span>
        <span class="s1">filter_method = kwargs.get(</span><span class="s5">'filter_method'</span><span class="s2">, </span><span class="s1">self.filter_method)</span>
        <span class="s1">inversion_method = kwargs.get(</span><span class="s5">'inversion_method'</span><span class="s2">,</span>
                                      <span class="s1">self.inversion_method)</span>
        <span class="s1">stability_method = kwargs.get(</span><span class="s5">'stability_method'</span><span class="s2">,</span>
                                      <span class="s1">self.stability_method)</span>
        <span class="s1">conserve_memory = kwargs.get(</span><span class="s5">'conserve_memory'</span><span class="s2">,</span>
                                     <span class="s1">self.conserve_memory)</span>
        <span class="s1">filter_timing = kwargs.get(</span><span class="s5">'filter_timing'</span><span class="s2">,</span>
                                   <span class="s1">self.filter_timing)</span>
        <span class="s1">loglikelihood_burn = kwargs.get(</span><span class="s5">'loglikelihood_burn'</span><span class="s2">,</span>
                                        <span class="s1">self.loglikelihood_burn)</span>
        <span class="s1">tolerance = kwargs.get(</span><span class="s5">'tolerance'</span><span class="s2">, </span><span class="s1">self.tolerance)</span>

        <span class="s4"># Create a new simulation smoother object</span>
        <span class="s1">cls = self.prefix_simulation_smoother_map[prefix]</span>
        <span class="s1">simulation_smoother = cls(</span>
            <span class="s1">self._statespaces[prefix]</span><span class="s2">,</span>
            <span class="s1">filter_method</span><span class="s2">, </span><span class="s1">inversion_method</span><span class="s2">, </span><span class="s1">stability_method</span><span class="s2">, </span><span class="s1">conserve_memory</span><span class="s2">,</span>
            <span class="s1">filter_timing</span><span class="s2">, </span><span class="s1">tolerance</span><span class="s2">, </span><span class="s1">loglikelihood_burn</span><span class="s2">, </span><span class="s1">smoother_output</span><span class="s2">,</span>
            <span class="s1">simulation_output</span><span class="s2">, </span><span class="s1">nobs</span>
        <span class="s1">)</span>

        <span class="s4"># Create results object</span>
        <span class="s1">results = results_class(self</span><span class="s2">, </span><span class="s1">simulation_smoother</span><span class="s2">,</span>
                                <span class="s1">random_state=random_state)</span>

        <span class="s2">return </span><span class="s1">results</span>


<span class="s2">class </span><span class="s1">SimulationSmoothResults:</span>
    <span class="s0">r&quot;&quot;&quot; 
    Results from applying the Kalman smoother and/or filter to a state space 
    model. 
 
    Parameters 
    ---------- 
    model : Representation 
        A Statespace representation 
    simulation_smoother : {{prefix}}SimulationSmoother object 
        The Cython simulation smoother object with which to simulation smooth. 
    random_state : {None, int, Generator, RandomState}, optional 
        If `seed` is None (or `np.random`), the `numpy.random.RandomState` 
        singleton is used. 
        If `seed` is an int, a new ``numpy.random.RandomState`` instance 
        is used, seeded with `seed`. 
        If `seed` is already a ``numpy.random.Generator`` or 
        ``numpy.random.RandomState`` instance then that instance is used. 
 
    Attributes 
    ---------- 
    model : Representation 
        A Statespace representation 
    dtype : dtype 
        Datatype of representation matrices 
    prefix : str 
        BLAS prefix of representation matrices 
    simulation_output : int 
        Bitmask controlling simulation output. 
    simulate_state : bool 
        Flag for if the state is included in simulation output. 
    simulate_disturbance : bool 
        Flag for if the state and observation disturbances are included in 
        simulation output. 
    simulate_all : bool 
        Flag for if simulation output should include everything. 
    generated_measurement_disturbance : ndarray 
        Measurement disturbance variates used to genereate the observation 
        vector. 
    generated_state_disturbance : ndarray 
        State disturbance variates used to genereate the state and 
        observation vectors. 
    generated_obs : ndarray 
        Generated observation vector produced as a byproduct of simulation 
        smoothing. 
    generated_state : ndarray 
        Generated state vector produced as a byproduct of simulation smoothing. 
    simulated_state : ndarray 
        Simulated state. 
    simulated_measurement_disturbance : ndarray 
        Simulated measurement disturbance. 
    simulated_state_disturbance : ndarray 
        Simulated state disturbance. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">model</span><span class="s2">, </span><span class="s1">simulation_smoother</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">self.model = model</span>
        <span class="s1">self.prefix = model.prefix</span>
        <span class="s1">self.dtype = model.dtype</span>
        <span class="s1">self._simulation_smoother = simulation_smoother</span>
        <span class="s1">self.random_state = check_random_state(random_state)</span>

        <span class="s4"># Output</span>
        <span class="s1">self._generated_measurement_disturbance = </span><span class="s2">None</span>
        <span class="s1">self._generated_state_disturbance = </span><span class="s2">None</span>
        <span class="s1">self._generated_obs = </span><span class="s2">None</span>
        <span class="s1">self._generated_state = </span><span class="s2">None</span>
        <span class="s1">self._simulated_state = </span><span class="s2">None</span>
        <span class="s1">self._simulated_measurement_disturbance = </span><span class="s2">None</span>
        <span class="s1">self._simulated_state_disturbance = </span><span class="s2">None</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">simulation_output(self):</span>
        <span class="s2">return </span><span class="s1">self._simulation_smoother.simulation_output</span>

    <span class="s1">@simulation_output.setter</span>
    <span class="s2">def </span><span class="s1">simulation_output(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s1">self._simulation_smoother.simulation_output = value</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">simulate_state(self):</span>
        <span class="s2">return </span><span class="s1">bool(self.simulation_output &amp; SIMULATION_STATE)</span>

    <span class="s1">@simulate_state.setter</span>
    <span class="s2">def </span><span class="s1">simulate_state(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s2">if </span><span class="s1">bool(value):</span>
            <span class="s1">self.simulation_output = self.simulation_output | SIMULATION_STATE</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.simulation_output = self.simulation_output &amp; ~SIMULATION_STATE</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">simulate_disturbance(self):</span>
        <span class="s2">return </span><span class="s1">bool(self.simulation_output &amp; SIMULATION_DISTURBANCE)</span>

    <span class="s1">@simulate_disturbance.setter</span>
    <span class="s2">def </span><span class="s1">simulate_disturbance(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s2">if </span><span class="s1">bool(value):</span>
            <span class="s1">self.simulation_output = (</span>
                <span class="s1">self.simulation_output | SIMULATION_DISTURBANCE)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.simulation_output = (</span>
                <span class="s1">self.simulation_output &amp; ~SIMULATION_DISTURBANCE)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">simulate_all(self):</span>
        <span class="s2">return </span><span class="s1">bool(self.simulation_output &amp; SIMULATION_ALL)</span>

    <span class="s1">@simulate_all.setter</span>
    <span class="s2">def </span><span class="s1">simulate_all(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s2">if </span><span class="s1">bool(value):</span>
            <span class="s1">self.simulation_output = self.simulation_output | SIMULATION_ALL</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.simulation_output = self.simulation_output &amp; ~SIMULATION_ALL</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">generated_measurement_disturbance(self):</span>
        <span class="s0">r&quot;&quot;&quot; 
        Randomly drawn measurement disturbance variates 
 
        Used to construct `generated_obs`. 
 
        Notes 
        ----- 
 
        .. math:: 
 
           \varepsilon_t^+ ~ N(0, H_t) 
 
        If `disturbance_variates` were provided to the `simulate()` method, 
        then this returns those variates (which were N(0,1)) transformed to the 
        distribution above. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._generated_measurement_disturbance </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self._generated_measurement_disturbance = np.array(</span>
                <span class="s1">self._simulation_smoother.measurement_disturbance_variates</span><span class="s2">,</span>
                <span class="s1">copy=</span><span class="s2">True</span><span class="s1">).reshape(self.model.nobs</span><span class="s2">, </span><span class="s1">self.model.k_endog)</span>
        <span class="s2">return </span><span class="s1">self._generated_measurement_disturbance</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">generated_state_disturbance(self):</span>
        <span class="s0">r&quot;&quot;&quot; 
        Randomly drawn state disturbance variates, used to construct 
        `generated_state` and `generated_obs`. 
 
        Notes 
        ----- 
 
        .. math:: 
 
            \eta_t^+ ~ N(0, Q_t) 
 
        If `disturbance_variates` were provided to the `simulate()` method, 
        then this returns those variates (which were N(0,1)) transformed to the 
        distribution above. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._generated_state_disturbance </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self._generated_state_disturbance = np.array(</span>
                <span class="s1">self._simulation_smoother.state_disturbance_variates</span><span class="s2">,</span>
                <span class="s1">copy=</span><span class="s2">True</span><span class="s1">).reshape(self.model.nobs</span><span class="s2">, </span><span class="s1">self.model.k_posdef)</span>
        <span class="s2">return </span><span class="s1">self._generated_state_disturbance</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">generated_obs(self):</span>
        <span class="s0">r&quot;&quot;&quot; 
        Generated vector of observations by iterating on the observation and 
        transition equations, given a random initial state draw and random 
        disturbance draws. 
 
        Notes 
        ----- 
 
        .. math:: 
 
            y_t^+ = d_t + Z_t \alpha_t^+ + \varepsilon_t^+ 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._generated_obs </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self._generated_obs = np.array(</span>
                <span class="s1">self._simulation_smoother.generated_obs</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">True</span>
            <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self._generated_obs</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">generated_state(self):</span>
        <span class="s0">r&quot;&quot;&quot; 
        Generated vector of states by iterating on the transition equation, 
        given a random initial state draw and random disturbance draws. 
 
        Notes 
        ----- 
 
        .. math:: 
 
            \alpha_{t+1}^+ = c_t + T_t \alpha_t^+ + \eta_t^+ 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._generated_state </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self._generated_state = np.array(</span>
                <span class="s1">self._simulation_smoother.generated_state</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">True</span>
            <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self._generated_state</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">simulated_state(self):</span>
        <span class="s0">r&quot;&quot;&quot; 
        Random draw of the state vector from its conditional distribution. 
 
        Notes 
        ----- 
 
        .. math:: 
 
            \alpha ~ p(\alpha \mid Y_n) 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._simulated_state </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self._simulated_state = np.array(</span>
                <span class="s1">self._simulation_smoother.simulated_state</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">True</span>
            <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self._simulated_state</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">simulated_measurement_disturbance(self):</span>
        <span class="s0">r&quot;&quot;&quot; 
        Random draw of the measurement disturbance vector from its conditional 
        distribution. 
 
        Notes 
        ----- 
 
        .. math:: 
 
            \varepsilon ~ N(\hat \varepsilon, Var(\hat \varepsilon \mid Y_n)) 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._simulated_measurement_disturbance </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self._simulated_measurement_disturbance = np.array(</span>
                <span class="s1">self._simulation_smoother.simulated_measurement_disturbance</span><span class="s2">,</span>
                <span class="s1">copy=</span><span class="s2">True</span>
            <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self._simulated_measurement_disturbance</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">simulated_state_disturbance(self):</span>
        <span class="s0">r&quot;&quot;&quot; 
        Random draw of the state disturbanc e vector from its conditional 
        distribution. 
 
        Notes 
        ----- 
 
        .. math:: 
 
            \eta ~ N(\hat \eta, Var(\hat \eta \mid Y_n)) 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._simulated_state_disturbance </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self._simulated_state_disturbance = np.array(</span>
                <span class="s1">self._simulation_smoother.simulated_state_disturbance</span><span class="s2">,</span>
                <span class="s1">copy=</span><span class="s2">True</span>
            <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self._simulated_state_disturbance</span>

    <span class="s2">def </span><span class="s1">simulate(self</span><span class="s2">, </span><span class="s1">simulation_output=-</span><span class="s3">1</span><span class="s2">,</span>
                 <span class="s1">disturbance_variates=</span><span class="s2">None,</span>
                 <span class="s1">measurement_disturbance_variates=</span><span class="s2">None,</span>
                 <span class="s1">state_disturbance_variates=</span><span class="s2">None,</span>
                 <span class="s1">initial_state_variates=</span><span class="s2">None,</span>
                 <span class="s1">pretransformed=</span><span class="s2">None,</span>
                 <span class="s1">pretransformed_measurement_disturbance_variates=</span><span class="s2">None,</span>
                 <span class="s1">pretransformed_state_disturbance_variates=</span><span class="s2">None,</span>
                 <span class="s1">pretransformed_initial_state_variates=</span><span class="s2">False,</span>
                 <span class="s1">random_state=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">r&quot;&quot;&quot; 
        Perform simulation smoothing 
 
        Does not return anything, but populates the object's `simulated_*` 
        attributes, as specified by simulation output. 
 
        Parameters 
        ---------- 
        simulation_output : int, optional 
            Bitmask controlling simulation output. Default is to use the 
            simulation output defined in object initialization. 
        measurement_disturbance_variates : array_like, optional 
            If specified, these are the shocks to the measurement equation, 
            :math:`\varepsilon_t`. If unspecified, these are automatically 
            generated using a pseudo-random number generator. If specified, 
            must be shaped `nsimulations` x `k_endog`, where `k_endog` is the 
            same as in the state space model. 
        state_disturbance_variates : array_like, optional 
            If specified, these are the shocks to the state equation, 
            :math:`\eta_t`. If unspecified, these are automatically 
            generated using a pseudo-random number generator. If specified, 
            must be shaped `nsimulations` x `k_posdef` where `k_posdef` is the 
            same as in the state space model. 
        initial_state_variates : array_like, optional 
            If specified, this is the state vector at time zero, which should 
            be shaped (`k_states` x 1), where `k_states` is the same as in the 
            state space model. If unspecified, but the model has been 
            initialized, then that initialization is used. 
        initial_state_variates : array_likes, optional 
            Random values to use as initial state variates. Usually only 
            specified if results are to be replicated (e.g. to enforce a seed) 
            or for testing. If not specified, random variates are drawn. 
        pretransformed_measurement_disturbance_variates : bool, optional 
            If `measurement_disturbance_variates` is provided, this flag 
            indicates whether it should be directly used as the shocks. If 
            False, then it is assumed to contain draws from the standard Normal 
            distribution that must be transformed using the `obs_cov` 
            covariance matrix. Default is False. 
        pretransformed_state_disturbance_variates : bool, optional 
            If `state_disturbance_variates` is provided, this flag indicates 
            whether it should be directly used as the shocks. If False, then it 
            is assumed to contain draws from the standard Normal distribution 
            that must be transformed using the `state_cov` covariance matrix. 
            Default is False. 
        pretransformed_initial_state_variates : bool, optional 
            If `initial_state_variates` is provided, this flag indicates 
            whether it should be directly used as the initial_state. If False, 
            then it is assumed to contain draws from the standard Normal 
            distribution that must be transformed using the `initial_state_cov` 
            covariance matrix. Default is False. 
        random_state : {None, int, Generator, RandomState}, optional 
            If `seed` is None (or `np.random`), the `numpy.random.RandomState` 
            singleton is used. 
            If `seed` is an int, a new ``numpy.random.RandomState`` instance 
            is used, seeded with `seed`. 
            If `seed` is already a ``numpy.random.Generator`` or 
            ``numpy.random.RandomState`` instance then that instance is used. 
        disturbance_variates : bool, optional 
            Deprecated, please use pretransformed_measurement_shocks and 
            pretransformed_state_shocks instead. 
 
            .. deprecated:: 0.14.0 
 
               Use ``measurement_disturbance_variates`` and 
               ``state_disturbance_variates`` as replacements. 
 
        pretransformed : bool, optional 
            Deprecated, please use pretransformed_measurement_shocks and 
            pretransformed_state_shocks instead. 
 
            .. deprecated:: 0.14.0 
 
               Use ``pretransformed_measurement_disturbance_variates`` and 
               ``pretransformed_state_disturbance_variates`` as replacements. 
        &quot;&quot;&quot;</span>
        <span class="s4"># Handle deprecated argumennts</span>
        <span class="s2">if </span><span class="s1">disturbance_variates </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">msg = (</span><span class="s5">'`disturbance_variates` keyword is deprecated, use'</span>
                   <span class="s5">' `measurement_disturbance_variates` and'</span>
                   <span class="s5">' `state_disturbance_variates` instead.'</span><span class="s1">)</span>
            <span class="s1">warnings.warn(msg</span><span class="s2">, </span><span class="s1">FutureWarning)</span>
            <span class="s2">if </span><span class="s1">(measurement_disturbance_variates </span><span class="s2">is not None</span>
                    <span class="s2">or </span><span class="s1">state_disturbance_variates </span><span class="s2">is not None</span><span class="s1">):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'Cannot use `disturbance_variates` in'</span>
                                 <span class="s5">' combination with '</span>
                                 <span class="s5">' `measurement_disturbance_variates` or'</span>
                                 <span class="s5">' `state_disturbance_variates`.'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">disturbance_variates </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">disturbance_variates = disturbance_variates.ravel()</span>
                <span class="s1">n_mds = self.model.nobs * self.model.k_endog</span>
                <span class="s1">measurement_disturbance_variates = disturbance_variates[:n_mds]</span>
                <span class="s1">state_disturbance_variates = disturbance_variates[n_mds:]</span>
        <span class="s2">if </span><span class="s1">pretransformed </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">msg = (</span><span class="s5">'`pretransformed` keyword is deprecated, use'</span>
                   <span class="s5">' `pretransformed_measurement_disturbance_variates` and'</span>
                   <span class="s5">' `pretransformed_state_disturbance_variates` instead.'</span><span class="s1">)</span>
            <span class="s1">warnings.warn(msg</span><span class="s2">, </span><span class="s1">FutureWarning)</span>
            <span class="s2">if </span><span class="s1">(pretransformed_measurement_disturbance_variates </span><span class="s2">is not None</span>
                    <span class="s2">or </span><span class="s1">pretransformed_state_disturbance_variates </span><span class="s2">is not None</span><span class="s1">):</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s5">'Cannot use `pretransformed` in combination with '</span>
                    <span class="s5">' `pretransformed_measurement_disturbance_variates` or'</span>
                    <span class="s5">' `pretransformed_state_disturbance_variates`.'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">pretransformed </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">pretransformed_measurement_disturbance_variates = (</span>
                    <span class="s1">pretransformed)</span>
                <span class="s1">pretransformed_state_disturbance_variates = pretransformed</span>

        <span class="s2">if </span><span class="s1">pretransformed_measurement_disturbance_variates </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">pretransformed_measurement_disturbance_variates = </span><span class="s2">False</span>
        <span class="s2">if </span><span class="s1">pretransformed_state_disturbance_variates </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">pretransformed_state_disturbance_variates = </span><span class="s2">False</span>

        <span class="s4"># Clear any previous output</span>
        <span class="s1">self._generated_measurement_disturbance = </span><span class="s2">None</span>
        <span class="s1">self._generated_state_disturbance = </span><span class="s2">None</span>
        <span class="s1">self._generated_state = </span><span class="s2">None</span>
        <span class="s1">self._generated_obs = </span><span class="s2">None</span>
        <span class="s1">self._generated_state = </span><span class="s2">None</span>
        <span class="s1">self._simulated_state = </span><span class="s2">None</span>
        <span class="s1">self._simulated_measurement_disturbance = </span><span class="s2">None</span>
        <span class="s1">self._simulated_state_disturbance = </span><span class="s2">None</span>

        <span class="s4"># Handle the random state</span>
        <span class="s2">if </span><span class="s1">random_state </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">random_state = self.random_state</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">random_state = check_random_state(random_state)</span>

        <span class="s4"># Re-initialize the _statespace representation</span>
        <span class="s1">prefix</span><span class="s2">, </span><span class="s1">dtype</span><span class="s2">, </span><span class="s1">create_smoother</span><span class="s2">, </span><span class="s1">create_filter</span><span class="s2">, </span><span class="s1">create_statespace = (</span>
            <span class="s1">self.model._initialize_smoother())</span>
        <span class="s2">if </span><span class="s1">create_statespace:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'The simulation smoother currently cannot replace'</span>
                             <span class="s5">' the underlying _{{prefix}}Representation model'</span>
                             <span class="s5">' object if it changes (which happens e.g. if the'</span>
                             <span class="s5">' dimensions of some system matrices change.'</span><span class="s1">)</span>

        <span class="s4"># Initialize the state</span>
        <span class="s1">self.model._initialize_state(prefix=prefix)</span>

        <span class="s4"># Draw the (independent) random variates for disturbances in the</span>
        <span class="s4"># simulation</span>
        <span class="s2">if </span><span class="s1">measurement_disturbance_variates </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._simulation_smoother.set_measurement_disturbance_variates(</span>
                <span class="s1">np.array(measurement_disturbance_variates</span><span class="s2">,</span>
                         <span class="s1">dtype=self.dtype).ravel()</span><span class="s2">,</span>
                <span class="s1">pretransformed=pretransformed_measurement_disturbance_variates</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._simulation_smoother.draw_measurement_disturbance_variates(</span>
                <span class="s1">random_state)</span>

        <span class="s4"># Draw the (independent) random variates for disturbances in the</span>
        <span class="s4"># simulation</span>
        <span class="s2">if </span><span class="s1">state_disturbance_variates </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._simulation_smoother.set_state_disturbance_variates(</span>
                <span class="s1">np.array(state_disturbance_variates</span><span class="s2">, </span><span class="s1">dtype=self.dtype).ravel()</span><span class="s2">,</span>
                <span class="s1">pretransformed=pretransformed_state_disturbance_variates</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._simulation_smoother.draw_state_disturbance_variates(</span>
                <span class="s1">random_state)</span>

        <span class="s4"># Draw the (independent) random variates for the initial states in the</span>
        <span class="s4"># simulation</span>
        <span class="s2">if </span><span class="s1">initial_state_variates </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">pretransformed_initial_state_variates:</span>
                <span class="s1">self._simulation_smoother.set_initial_state(</span>
                    <span class="s1">np.array(initial_state_variates</span><span class="s2">, </span><span class="s1">dtype=self.dtype)</span>
                <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self._simulation_smoother.set_initial_state_variates(</span>
                    <span class="s1">np.array(initial_state_variates</span><span class="s2">, </span><span class="s1">dtype=self.dtype)</span><span class="s2">,</span>
                    <span class="s1">pretransformed=</span><span class="s2">False</span>
                <span class="s1">)</span>
            <span class="s4"># Note: there is a third option, which is to set the initial state</span>
            <span class="s4"># variates with pretransformed = True. However, this option simply</span>
            <span class="s4"># eliminates the multiplication by the Cholesky factor of the</span>
            <span class="s4"># initial state cov, but still adds the initial state mean. It's</span>
            <span class="s4"># not clear when this would be useful...</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._simulation_smoother.draw_initial_state_variates(</span>
                <span class="s1">random_state)</span>

        <span class="s4"># Perform simulation smoothing</span>
        <span class="s1">self._simulation_smoother.simulate(simulation_output)</span>
</pre>
</body>
</html>