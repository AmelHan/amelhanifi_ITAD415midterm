<html>
<head>
<title>_special_matrices.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_special_matrices.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">math</span>
<span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">numpy.lib.stride_tricks </span><span class="s0">import </span><span class="s1">as_strided</span>

<span class="s1">__all__ = [</span><span class="s2">'tri'</span><span class="s0">, </span><span class="s2">'tril'</span><span class="s0">, </span><span class="s2">'triu'</span><span class="s0">, </span><span class="s2">'toeplitz'</span><span class="s0">, </span><span class="s2">'circulant'</span><span class="s0">, </span><span class="s2">'hankel'</span><span class="s0">,</span>
           <span class="s2">'hadamard'</span><span class="s0">, </span><span class="s2">'leslie'</span><span class="s0">, </span><span class="s2">'kron'</span><span class="s0">, </span><span class="s2">'block_diag'</span><span class="s0">, </span><span class="s2">'companion'</span><span class="s0">,</span>
           <span class="s2">'helmert'</span><span class="s0">, </span><span class="s2">'hilbert'</span><span class="s0">, </span><span class="s2">'invhilbert'</span><span class="s0">, </span><span class="s2">'pascal'</span><span class="s0">, </span><span class="s2">'invpascal'</span><span class="s0">, </span><span class="s2">'dft'</span><span class="s0">,</span>
           <span class="s2">'fiedler'</span><span class="s0">, </span><span class="s2">'fiedler_companion'</span><span class="s0">, </span><span class="s2">'convolution_matrix'</span><span class="s1">]</span>


<span class="s3"># -----------------------------------------------------------------------------</span>
<span class="s3">#  matrix construction functions</span>
<span class="s3"># -----------------------------------------------------------------------------</span>

<span class="s3">#</span>
<span class="s3"># *Note*: tri{,u,l} is implemented in NumPy, but an important bug was fixed in</span>
<span class="s3"># 2.0.0.dev-1af2f3, the following tri{,u,l} definitions are here for backwards</span>
<span class="s3"># compatibility.</span>

<span class="s0">def </span><span class="s1">tri(N</span><span class="s0">, </span><span class="s1">M=</span><span class="s0">None, </span><span class="s1">k=</span><span class="s4">0</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    .. deprecated:: 1.11.0 
        `tri` is deprecated in favour of `numpy.tri` and will be removed in 
        SciPy 1.13.0.     
     
    Construct (N, M) matrix filled with ones at and below the kth diagonal. 
 
    The matrix has A[i,j] == 1 for j &lt;= i + k 
 
    Parameters 
    ---------- 
    N : int 
        The size of the first dimension of the matrix. 
    M : int or None, optional 
        The size of the second dimension of the matrix. If `M` is None, 
        `M = N` is assumed. 
    k : int, optional 
        Number of subdiagonal below which matrix is filled with ones. 
        `k` = 0 is the main diagonal, `k` &lt; 0 subdiagonal and `k` &gt; 0 
        superdiagonal. 
    dtype : dtype, optional 
        Data type of the matrix. 
 
    Returns 
    ------- 
    tri : (N, M) ndarray 
        Tri matrix. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.linalg import tri 
    &gt;&gt;&gt; tri(3, 5, 2, dtype=int) 
    array([[1, 1, 1, 0, 0], 
           [1, 1, 1, 1, 0], 
           [1, 1, 1, 1, 1]]) 
    &gt;&gt;&gt; tri(3, 5, -1, dtype=int) 
    array([[0, 0, 0, 0, 0], 
           [1, 0, 0, 0, 0], 
           [1, 1, 0, 0, 0]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">warnings.warn(</span><span class="s2">&quot;'tri'/'tril/'triu' are deprecated as of SciPy 1.11.0 and &quot;</span>
                  <span class="s2">&quot;will be removed in v1.13.0. Please use &quot;</span>
                  <span class="s2">&quot;numpy.(tri/tril/triu) instead.&quot;</span><span class="s0">,</span>
                  <span class="s1">DeprecationWarning</span><span class="s0">, </span><span class="s1">stacklevel=</span><span class="s4">2</span><span class="s1">)</span>
    
    <span class="s0">if </span><span class="s1">M </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">M = N</span>
    <span class="s0">if </span><span class="s1">isinstance(M</span><span class="s0">, </span><span class="s1">str):</span>
        <span class="s3"># pearu: any objections to remove this feature?</span>
        <span class="s3">#       As tri(N,'d') is equivalent to tri(N,dtype='d')</span>
        <span class="s1">dtype = M</span>
        <span class="s1">M = N</span>
    <span class="s1">m = np.greater_equal.outer(np.arange(k</span><span class="s0">, </span><span class="s1">N+k)</span><span class="s0">, </span><span class="s1">np.arange(M))</span>
    <span class="s0">if </span><span class="s1">dtype </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">m</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">m.astype(dtype)</span>


<span class="s0">def </span><span class="s1">tril(m</span><span class="s0">, </span><span class="s1">k=</span><span class="s4">0</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    .. deprecated:: 1.11.0 
        `tril` is deprecated in favour of `numpy.tril` and will be removed in 
        SciPy 1.13.0. 
 
    Make a copy of a matrix with elements above the kth diagonal zeroed. 
 
    Parameters 
    ---------- 
    m : array_like 
        Matrix whose elements to return 
    k : int, optional 
        Diagonal above which to zero elements. 
        `k` == 0 is the main diagonal, `k` &lt; 0 subdiagonal and 
        `k` &gt; 0 superdiagonal. 
 
    Returns 
    ------- 
    tril : ndarray 
        Return is the same shape and type as `m`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.linalg import tril 
    &gt;&gt;&gt; tril([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1) 
    array([[ 0,  0,  0], 
           [ 4,  0,  0], 
           [ 7,  8,  0], 
           [10, 11, 12]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">m = np.asarray(m)</span>
    <span class="s1">out = tri(m.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">m.shape[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">k=k</span><span class="s0">, </span><span class="s1">dtype=m.dtype.char) * m</span>
    <span class="s0">return </span><span class="s1">out</span>


<span class="s0">def </span><span class="s1">triu(m</span><span class="s0">, </span><span class="s1">k=</span><span class="s4">0</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    .. deprecated:: 1.11.0 
        `tril` is deprecated in favour of `numpy.triu` and will be removed in 
        SciPy 1.13.0. 
 
    Make a copy of a matrix with elements below the kth diagonal zeroed. 
 
    Parameters 
    ---------- 
    m : array_like 
        Matrix whose elements to return 
    k : int, optional 
        Diagonal below which to zero elements. 
        `k` == 0 is the main diagonal, `k` &lt; 0 subdiagonal and 
        `k` &gt; 0 superdiagonal. 
 
    Returns 
    ------- 
    triu : ndarray 
        Return matrix with zeroed elements below the kth diagonal and has 
        same shape and type as `m`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.linalg import triu 
    &gt;&gt;&gt; triu([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1) 
    array([[ 1,  2,  3], 
           [ 4,  5,  6], 
           [ 0,  8,  9], 
           [ 0,  0, 12]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">m = np.asarray(m)</span>
    <span class="s1">out = (</span><span class="s4">1 </span><span class="s1">- tri(m.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">m.shape[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">k - </span><span class="s4">1</span><span class="s0">, </span><span class="s1">m.dtype.char)) * m</span>
    <span class="s0">return </span><span class="s1">out</span>


<span class="s0">def </span><span class="s1">toeplitz(c</span><span class="s0">, </span><span class="s1">r=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Construct a Toeplitz matrix. 
 
    The Toeplitz matrix has constant diagonals, with c as its first column 
    and r as its first row. If r is not given, ``r == conjugate(c)`` is 
    assumed. 
 
    Parameters 
    ---------- 
    c : array_like 
        First column of the matrix.  Whatever the actual shape of `c`, it 
        will be converted to a 1-D array. 
    r : array_like, optional 
        First row of the matrix. If None, ``r = conjugate(c)`` is assumed; 
        in this case, if c[0] is real, the result is a Hermitian matrix. 
        r[0] is ignored; the first row of the returned matrix is 
        ``[c[0], r[1:]]``.  Whatever the actual shape of `r`, it will be 
        converted to a 1-D array. 
 
    Returns 
    ------- 
    A : (len(c), len(r)) ndarray 
        The Toeplitz matrix. Dtype is the same as ``(c[0] + r[0]).dtype``. 
 
    See Also 
    -------- 
    circulant : circulant matrix 
    hankel : Hankel matrix 
    solve_toeplitz : Solve a Toeplitz system. 
 
    Notes 
    ----- 
    The behavior when `c` or `r` is a scalar, or when `c` is complex and 
    `r` is None, was changed in version 0.8.0. The behavior in previous 
    versions was undocumented and is no longer supported. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.linalg import toeplitz 
    &gt;&gt;&gt; toeplitz([1,2,3], [1,4,5,6]) 
    array([[1, 4, 5, 6], 
           [2, 1, 4, 5], 
           [3, 2, 1, 4]]) 
    &gt;&gt;&gt; toeplitz([1.0, 2+3j, 4-1j]) 
    array([[ 1.+0.j,  2.-3.j,  4.+1.j], 
           [ 2.+3.j,  1.+0.j,  2.-3.j], 
           [ 4.-1.j,  2.+3.j,  1.+0.j]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">c = np.asarray(c).ravel()</span>
    <span class="s0">if </span><span class="s1">r </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">r = c.conjugate()</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">r = np.asarray(r).ravel()</span>
    <span class="s3"># Form a 1-D array containing a reversed c followed by r[1:] that could be</span>
    <span class="s3"># strided to give us toeplitz matrix.</span>
    <span class="s1">vals = np.concatenate((c[::-</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">r[</span><span class="s4">1</span><span class="s1">:]))</span>
    <span class="s1">out_shp = len(c)</span><span class="s0">, </span><span class="s1">len(r)</span>
    <span class="s1">n = vals.strides[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s0">return </span><span class="s1">as_strided(vals[len(c)-</span><span class="s4">1</span><span class="s1">:]</span><span class="s0">, </span><span class="s1">shape=out_shp</span><span class="s0">, </span><span class="s1">strides=(-n</span><span class="s0">, </span><span class="s1">n)).copy()</span>


<span class="s0">def </span><span class="s1">circulant(c):</span>
    <span class="s5">&quot;&quot;&quot; 
    Construct a circulant matrix. 
 
    Parameters 
    ---------- 
    c : (N,) array_like 
        1-D array, the first column of the matrix. 
 
    Returns 
    ------- 
    A : (N, N) ndarray 
        A circulant matrix whose first column is `c`. 
 
    See Also 
    -------- 
    toeplitz : Toeplitz matrix 
    hankel : Hankel matrix 
    solve_circulant : Solve a circulant system. 
 
    Notes 
    ----- 
    .. versionadded:: 0.8.0 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.linalg import circulant 
    &gt;&gt;&gt; circulant([1, 2, 3]) 
    array([[1, 3, 2], 
           [2, 1, 3], 
           [3, 2, 1]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">c = np.asarray(c).ravel()</span>
    <span class="s3"># Form an extended array that could be strided to give circulant version</span>
    <span class="s1">c_ext = np.concatenate((c[::-</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">c[:</span><span class="s4">0</span><span class="s1">:-</span><span class="s4">1</span><span class="s1">]))</span>
    <span class="s1">L = len(c)</span>
    <span class="s1">n = c_ext.strides[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s0">return </span><span class="s1">as_strided(c_ext[L-</span><span class="s4">1</span><span class="s1">:]</span><span class="s0">, </span><span class="s1">shape=(L</span><span class="s0">, </span><span class="s1">L)</span><span class="s0">, </span><span class="s1">strides=(-n</span><span class="s0">, </span><span class="s1">n)).copy()</span>


<span class="s0">def </span><span class="s1">hankel(c</span><span class="s0">, </span><span class="s1">r=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Construct a Hankel matrix. 
 
    The Hankel matrix has constant anti-diagonals, with `c` as its 
    first column and `r` as its last row. If `r` is not given, then 
    `r = zeros_like(c)` is assumed. 
 
    Parameters 
    ---------- 
    c : array_like 
        First column of the matrix. Whatever the actual shape of `c`, it 
        will be converted to a 1-D array. 
    r : array_like, optional 
        Last row of the matrix. If None, ``r = zeros_like(c)`` is assumed. 
        r[0] is ignored; the last row of the returned matrix is 
        ``[c[-1], r[1:]]``. Whatever the actual shape of `r`, it will be 
        converted to a 1-D array. 
 
    Returns 
    ------- 
    A : (len(c), len(r)) ndarray 
        The Hankel matrix. Dtype is the same as ``(c[0] + r[0]).dtype``. 
 
    See Also 
    -------- 
    toeplitz : Toeplitz matrix 
    circulant : circulant matrix 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.linalg import hankel 
    &gt;&gt;&gt; hankel([1, 17, 99]) 
    array([[ 1, 17, 99], 
           [17, 99,  0], 
           [99,  0,  0]]) 
    &gt;&gt;&gt; hankel([1,2,3,4], [4,7,7,8,9]) 
    array([[1, 2, 3, 4, 7], 
           [2, 3, 4, 7, 7], 
           [3, 4, 7, 7, 8], 
           [4, 7, 7, 8, 9]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">c = np.asarray(c).ravel()</span>
    <span class="s0">if </span><span class="s1">r </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">r = np.zeros_like(c)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">r = np.asarray(r).ravel()</span>
    <span class="s3"># Form a 1-D array of values to be used in the matrix, containing `c`</span>
    <span class="s3"># followed by r[1:].</span>
    <span class="s1">vals = np.concatenate((c</span><span class="s0">, </span><span class="s1">r[</span><span class="s4">1</span><span class="s1">:]))</span>
    <span class="s3"># Stride on concatenated array to get hankel matrix</span>
    <span class="s1">out_shp = len(c)</span><span class="s0">, </span><span class="s1">len(r)</span>
    <span class="s1">n = vals.strides[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s0">return </span><span class="s1">as_strided(vals</span><span class="s0">, </span><span class="s1">shape=out_shp</span><span class="s0">, </span><span class="s1">strides=(n</span><span class="s0">, </span><span class="s1">n)).copy()</span>


<span class="s0">def </span><span class="s1">hadamard(n</span><span class="s0">, </span><span class="s1">dtype=int):</span>
    <span class="s5">&quot;&quot;&quot; 
    Construct an Hadamard matrix. 
 
    Constructs an n-by-n Hadamard matrix, using Sylvester's 
    construction. `n` must be a power of 2. 
 
    Parameters 
    ---------- 
    n : int 
        The order of the matrix. `n` must be a power of 2. 
    dtype : dtype, optional 
        The data type of the array to be constructed. 
 
    Returns 
    ------- 
    H : (n, n) ndarray 
        The Hadamard matrix. 
 
    Notes 
    ----- 
    .. versionadded:: 0.8.0 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.linalg import hadamard 
    &gt;&gt;&gt; hadamard(2, dtype=complex) 
    array([[ 1.+0.j,  1.+0.j], 
           [ 1.+0.j, -1.-0.j]]) 
    &gt;&gt;&gt; hadamard(4) 
    array([[ 1,  1,  1,  1], 
           [ 1, -1,  1, -1], 
           [ 1,  1, -1, -1], 
           [ 1, -1, -1,  1]]) 
 
    &quot;&quot;&quot;</span>

    <span class="s3"># This function is a slightly modified version of the</span>
    <span class="s3"># function contributed by Ivo in ticket #675.</span>

    <span class="s0">if </span><span class="s1">n &lt; </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">lg2 = </span><span class="s4">0</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">lg2 = int(math.log(n</span><span class="s0">, </span><span class="s4">2</span><span class="s1">))</span>
    <span class="s0">if </span><span class="s4">2 </span><span class="s1">** lg2 != n:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;n must be an positive integer, and n must be &quot;</span>
                         <span class="s2">&quot;a power of 2&quot;</span><span class="s1">)</span>

    <span class="s1">H = np.array([[</span><span class="s4">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>

    <span class="s3"># Sylvester's construction</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">lg2):</span>
        <span class="s1">H = np.vstack((np.hstack((H</span><span class="s0">, </span><span class="s1">H))</span><span class="s0">, </span><span class="s1">np.hstack((H</span><span class="s0">, </span><span class="s1">-H))))</span>

    <span class="s0">return </span><span class="s1">H</span>


<span class="s0">def </span><span class="s1">leslie(f</span><span class="s0">, </span><span class="s1">s):</span>
    <span class="s5">&quot;&quot;&quot; 
    Create a Leslie matrix. 
 
    Given the length n array of fecundity coefficients `f` and the length 
    n-1 array of survival coefficients `s`, return the associated Leslie 
    matrix. 
 
    Parameters 
    ---------- 
    f : (N,) array_like 
        The &quot;fecundity&quot; coefficients. 
    s : (N-1,) array_like 
        The &quot;survival&quot; coefficients, has to be 1-D.  The length of `s` 
        must be one less than the length of `f`, and it must be at least 1. 
 
    Returns 
    ------- 
    L : (N, N) ndarray 
        The array is zero except for the first row, 
        which is `f`, and the first sub-diagonal, which is `s`. 
        The data-type of the array will be the data-type of ``f[0]+s[0]``. 
 
    Notes 
    ----- 
    .. versionadded:: 0.8.0 
 
    The Leslie matrix is used to model discrete-time, age-structured 
    population growth [1]_ [2]_. In a population with `n` age classes, two sets 
    of parameters define a Leslie matrix: the `n` &quot;fecundity coefficients&quot;, 
    which give the number of offspring per-capita produced by each age 
    class, and the `n` - 1 &quot;survival coefficients&quot;, which give the 
    per-capita survival rate of each age class. 
 
    References 
    ---------- 
    .. [1] P. H. Leslie, On the use of matrices in certain population 
           mathematics, Biometrika, Vol. 33, No. 3, 183--212 (Nov. 1945) 
    .. [2] P. H. Leslie, Some further notes on the use of matrices in 
           population mathematics, Biometrika, Vol. 35, No. 3/4, 213--245 
           (Dec. 1948) 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.linalg import leslie 
    &gt;&gt;&gt; leslie([0.1, 2.0, 1.0, 0.1], [0.2, 0.8, 0.7]) 
    array([[ 0.1,  2. ,  1. ,  0.1], 
           [ 0.2,  0. ,  0. ,  0. ], 
           [ 0. ,  0.8,  0. ,  0. ], 
           [ 0. ,  0. ,  0.7,  0. ]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">f = np.atleast_1d(f)</span>
    <span class="s1">s = np.atleast_1d(s)</span>
    <span class="s0">if </span><span class="s1">f.ndim != </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Incorrect shape for f.  f must be 1D&quot;</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">s.ndim != </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Incorrect shape for s.  s must be 1D&quot;</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">f.size != s.size + </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Incorrect lengths for f and s.  The length&quot;</span>
                         <span class="s2">&quot; of s must be one less than the length of f.&quot;</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">s.size == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;The length of s must be at least 1.&quot;</span><span class="s1">)</span>

    <span class="s1">tmp = f[</span><span class="s4">0</span><span class="s1">] + s[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">n = f.size</span>
    <span class="s1">a = np.zeros((n</span><span class="s0">, </span><span class="s1">n)</span><span class="s0">, </span><span class="s1">dtype=tmp.dtype)</span>
    <span class="s1">a[</span><span class="s4">0</span><span class="s1">] = f</span>
    <span class="s1">a[list(range(</span><span class="s4">1</span><span class="s0">, </span><span class="s1">n))</span><span class="s0">, </span><span class="s1">list(range(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">n - </span><span class="s4">1</span><span class="s1">))] = s</span>
    <span class="s0">return </span><span class="s1">a</span>


<span class="s0">def </span><span class="s1">kron(a</span><span class="s0">, </span><span class="s1">b):</span>
    <span class="s5">&quot;&quot;&quot; 
    Kronecker product. 
 
    The result is the block matrix:: 
 
        a[0,0]*b    a[0,1]*b  ... a[0,-1]*b 
        a[1,0]*b    a[1,1]*b  ... a[1,-1]*b 
        ... 
        a[-1,0]*b   a[-1,1]*b ... a[-1,-1]*b 
 
    Parameters 
    ---------- 
    a : (M, N) ndarray 
        Input array 
    b : (P, Q) ndarray 
        Input array 
 
    Returns 
    ------- 
    A : (M*P, N*Q) ndarray 
        Kronecker product of `a` and `b`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from numpy import array 
    &gt;&gt;&gt; from scipy.linalg import kron 
    &gt;&gt;&gt; kron(array([[1,2],[3,4]]), array([[1,1,1]])) 
    array([[1, 1, 1, 2, 2, 2], 
           [3, 3, 3, 4, 4, 4]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s0">if not </span><span class="s1">a.flags[</span><span class="s2">'CONTIGUOUS'</span><span class="s1">]:</span>
        <span class="s1">a = np.reshape(a</span><span class="s0">, </span><span class="s1">a.shape)</span>
    <span class="s0">if not </span><span class="s1">b.flags[</span><span class="s2">'CONTIGUOUS'</span><span class="s1">]:</span>
        <span class="s1">b = np.reshape(b</span><span class="s0">, </span><span class="s1">b.shape)</span>
    <span class="s1">o = np.outer(a</span><span class="s0">, </span><span class="s1">b)</span>
    <span class="s1">o = o.reshape(a.shape + b.shape)</span>
    <span class="s0">return </span><span class="s1">np.concatenate(np.concatenate(o</span><span class="s0">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">block_diag(*arrs):</span>
    <span class="s5">&quot;&quot;&quot; 
    Create a block diagonal matrix from provided arrays. 
 
    Given the inputs `A`, `B` and `C`, the output will have these 
    arrays arranged on the diagonal:: 
 
        [[A, 0, 0], 
         [0, B, 0], 
         [0, 0, C]] 
 
    Parameters 
    ---------- 
    A, B, C, ... : array_like, up to 2-D 
        Input arrays.  A 1-D array or array_like sequence of length `n` is 
        treated as a 2-D array with shape ``(1,n)``. 
 
    Returns 
    ------- 
    D : ndarray 
        Array with `A`, `B`, `C`, ... on the diagonal. `D` has the 
        same dtype as `A`. 
 
    Notes 
    ----- 
    If all the input arrays are square, the output is known as a 
    block diagonal matrix. 
 
    Empty sequences (i.e., array-likes of zero size) will not be ignored. 
    Noteworthy, both [] and [[]] are treated as matrices with shape ``(1,0)``. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.linalg import block_diag 
    &gt;&gt;&gt; A = [[1, 0], 
    ...      [0, 1]] 
    &gt;&gt;&gt; B = [[3, 4, 5], 
    ...      [6, 7, 8]] 
    &gt;&gt;&gt; C = [[7]] 
    &gt;&gt;&gt; P = np.zeros((2, 0), dtype='int32') 
    &gt;&gt;&gt; block_diag(A, B, C) 
    array([[1, 0, 0, 0, 0, 0], 
           [0, 1, 0, 0, 0, 0], 
           [0, 0, 3, 4, 5, 0], 
           [0, 0, 6, 7, 8, 0], 
           [0, 0, 0, 0, 0, 7]]) 
    &gt;&gt;&gt; block_diag(A, P, B, C) 
    array([[1, 0, 0, 0, 0, 0], 
           [0, 1, 0, 0, 0, 0], 
           [0, 0, 0, 0, 0, 0], 
           [0, 0, 0, 0, 0, 0], 
           [0, 0, 3, 4, 5, 0], 
           [0, 0, 6, 7, 8, 0], 
           [0, 0, 0, 0, 0, 7]]) 
    &gt;&gt;&gt; block_diag(1.0, [2, 3], [[4, 5], [6, 7]]) 
    array([[ 1.,  0.,  0.,  0.,  0.], 
           [ 0.,  2.,  3.,  0.,  0.], 
           [ 0.,  0.,  0.,  4.,  5.], 
           [ 0.,  0.,  0.,  6.,  7.]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">arrs == ():</span>
        <span class="s1">arrs = ([]</span><span class="s0">,</span><span class="s1">)</span>
    <span class="s1">arrs = [np.atleast_2d(a) </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">arrs]</span>

    <span class="s1">bad_args = [k </span><span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range(len(arrs)) </span><span class="s0">if </span><span class="s1">arrs[k].ndim &gt; </span><span class="s4">2</span><span class="s1">]</span>
    <span class="s0">if </span><span class="s1">bad_args:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;arguments in the following positions have dimension &quot;</span>
                         <span class="s2">&quot;greater than 2: %s&quot; </span><span class="s1">% bad_args)</span>

    <span class="s1">shapes = np.array([a.shape </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">arrs])</span>
    <span class="s1">out_dtype = np.result_type(*[arr.dtype </span><span class="s0">for </span><span class="s1">arr </span><span class="s0">in </span><span class="s1">arrs])</span>
    <span class="s1">out = np.zeros(np.sum(shapes</span><span class="s0">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=out_dtype)</span>

    <span class="s1">r</span><span class="s0">, </span><span class="s1">c = </span><span class="s4">0</span><span class="s0">, </span><span class="s4">0</span>
    <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">(rr</span><span class="s0">, </span><span class="s1">cc) </span><span class="s0">in </span><span class="s1">enumerate(shapes):</span>
        <span class="s1">out[r:r + rr</span><span class="s0">, </span><span class="s1">c:c + cc] = arrs[i]</span>
        <span class="s1">r += rr</span>
        <span class="s1">c += cc</span>
    <span class="s0">return </span><span class="s1">out</span>


<span class="s0">def </span><span class="s1">companion(a):</span>
    <span class="s5">&quot;&quot;&quot; 
    Create a companion matrix. 
 
    Create the companion matrix [1]_ associated with the polynomial whose 
    coefficients are given in `a`. 
 
    Parameters 
    ---------- 
    a : (N,) array_like 
        1-D array of polynomial coefficients. The length of `a` must be 
        at least two, and ``a[0]`` must not be zero. 
 
    Returns 
    ------- 
    c : (N-1, N-1) ndarray 
        The first row of `c` is ``-a[1:]/a[0]``, and the first 
        sub-diagonal is all ones.  The data-type of the array is the same 
        as the data-type of ``1.0*a[0]``. 
 
    Raises 
    ------ 
    ValueError 
        If any of the following are true: a) ``a.ndim != 1``; 
        b) ``a.size &lt; 2``; c) ``a[0] == 0``. 
 
    Notes 
    ----- 
    .. versionadded:: 0.8.0 
 
    References 
    ---------- 
    .. [1] R. A. Horn &amp; C. R. Johnson, *Matrix Analysis*.  Cambridge, UK: 
        Cambridge University Press, 1999, pp. 146-7. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.linalg import companion 
    &gt;&gt;&gt; companion([1, -10, 31, -30]) 
    array([[ 10., -31.,  30.], 
           [  1.,   0.,   0.], 
           [  0.,   1.,   0.]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a = np.atleast_1d(a)</span>

    <span class="s0">if </span><span class="s1">a.ndim != </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Incorrect shape for `a`.  `a` must be &quot;</span>
                         <span class="s2">&quot;one-dimensional.&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">a.size &lt; </span><span class="s4">2</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;The length of `a` must be at least 2.&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">a[</span><span class="s4">0</span><span class="s1">] == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;The first coefficient in `a` must not be zero.&quot;</span><span class="s1">)</span>

    <span class="s1">first_row = -a[</span><span class="s4">1</span><span class="s1">:] / (</span><span class="s4">1.0 </span><span class="s1">* a[</span><span class="s4">0</span><span class="s1">])</span>
    <span class="s1">n = a.size</span>
    <span class="s1">c = np.zeros((n - </span><span class="s4">1</span><span class="s0">, </span><span class="s1">n - </span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=first_row.dtype)</span>
    <span class="s1">c[</span><span class="s4">0</span><span class="s1">] = first_row</span>
    <span class="s1">c[list(range(</span><span class="s4">1</span><span class="s0">, </span><span class="s1">n - </span><span class="s4">1</span><span class="s1">))</span><span class="s0">, </span><span class="s1">list(range(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">n - </span><span class="s4">2</span><span class="s1">))] = </span><span class="s4">1</span>
    <span class="s0">return </span><span class="s1">c</span>


<span class="s0">def </span><span class="s1">helmert(n</span><span class="s0">, </span><span class="s1">full=</span><span class="s0">False</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Create an Helmert matrix of order `n`. 
 
    This has applications in statistics, compositional or simplicial analysis, 
    and in Aitchison geometry. 
 
    Parameters 
    ---------- 
    n : int 
        The size of the array to create. 
    full : bool, optional 
        If True the (n, n) ndarray will be returned. 
        Otherwise the submatrix that does not include the first 
        row will be returned. 
        Default: False. 
 
    Returns 
    ------- 
    M : ndarray 
        The Helmert matrix. 
        The shape is (n, n) or (n-1, n) depending on the `full` argument. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.linalg import helmert 
    &gt;&gt;&gt; helmert(5, full=True) 
    array([[ 0.4472136 ,  0.4472136 ,  0.4472136 ,  0.4472136 ,  0.4472136 ], 
           [ 0.70710678, -0.70710678,  0.        ,  0.        ,  0.        ], 
           [ 0.40824829,  0.40824829, -0.81649658,  0.        ,  0.        ], 
           [ 0.28867513,  0.28867513,  0.28867513, -0.8660254 ,  0.        ], 
           [ 0.2236068 ,  0.2236068 ,  0.2236068 ,  0.2236068 , -0.89442719]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">H = np.tril(np.ones((n</span><span class="s0">, </span><span class="s1">n))</span><span class="s0">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">) - np.diag(np.arange(n))</span>
    <span class="s1">d = np.arange(n) * np.arange(</span><span class="s4">1</span><span class="s0">, </span><span class="s1">n+</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">H[</span><span class="s4">0</span><span class="s1">] = </span><span class="s4">1</span>
    <span class="s1">d[</span><span class="s4">0</span><span class="s1">] = n</span>
    <span class="s1">H_full = H / np.sqrt(d)[:</span><span class="s0">, </span><span class="s1">np.newaxis]</span>
    <span class="s0">if </span><span class="s1">full:</span>
        <span class="s0">return </span><span class="s1">H_full</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">H_full[</span><span class="s4">1</span><span class="s1">:]</span>


<span class="s0">def </span><span class="s1">hilbert(n):</span>
    <span class="s5">&quot;&quot;&quot; 
    Create a Hilbert matrix of order `n`. 
 
    Returns the `n` by `n` array with entries `h[i,j] = 1 / (i + j + 1)`. 
 
    Parameters 
    ---------- 
    n : int 
        The size of the array to create. 
 
    Returns 
    ------- 
    h : (n, n) ndarray 
        The Hilbert matrix. 
 
    See Also 
    -------- 
    invhilbert : Compute the inverse of a Hilbert matrix. 
 
    Notes 
    ----- 
    .. versionadded:: 0.10.0 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.linalg import hilbert 
    &gt;&gt;&gt; hilbert(3) 
    array([[ 1.        ,  0.5       ,  0.33333333], 
           [ 0.5       ,  0.33333333,  0.25      ], 
           [ 0.33333333,  0.25      ,  0.2       ]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">values = </span><span class="s4">1.0 </span><span class="s1">/ (</span><span class="s4">1.0 </span><span class="s1">+ np.arange(</span><span class="s4">2 </span><span class="s1">* n - </span><span class="s4">1</span><span class="s1">))</span>
    <span class="s1">h = hankel(values[:n]</span><span class="s0">, </span><span class="s1">r=values[n - </span><span class="s4">1</span><span class="s1">:])</span>
    <span class="s0">return </span><span class="s1">h</span>


<span class="s0">def </span><span class="s1">invhilbert(n</span><span class="s0">, </span><span class="s1">exact=</span><span class="s0">False</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Compute the inverse of the Hilbert matrix of order `n`. 
 
    The entries in the inverse of a Hilbert matrix are integers. When `n` 
    is greater than 14, some entries in the inverse exceed the upper limit 
    of 64 bit integers. The `exact` argument provides two options for 
    dealing with these large integers. 
 
    Parameters 
    ---------- 
    n : int 
        The order of the Hilbert matrix. 
    exact : bool, optional 
        If False, the data type of the array that is returned is np.float64, 
        and the array is an approximation of the inverse. 
        If True, the array is the exact integer inverse array. To represent 
        the exact inverse when n &gt; 14, the returned array is an object array 
        of long integers. For n &lt;= 14, the exact inverse is returned as an 
        array with data type np.int64. 
 
    Returns 
    ------- 
    invh : (n, n) ndarray 
        The data type of the array is np.float64 if `exact` is False. 
        If `exact` is True, the data type is either np.int64 (for n &lt;= 14) 
        or object (for n &gt; 14). In the latter case, the objects in the 
        array will be long integers. 
 
    See Also 
    -------- 
    hilbert : Create a Hilbert matrix. 
 
    Notes 
    ----- 
    .. versionadded:: 0.10.0 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.linalg import invhilbert 
    &gt;&gt;&gt; invhilbert(4) 
    array([[   16.,  -120.,   240.,  -140.], 
           [ -120.,  1200., -2700.,  1680.], 
           [  240., -2700.,  6480., -4200.], 
           [ -140.,  1680., -4200.,  2800.]]) 
    &gt;&gt;&gt; invhilbert(4, exact=True) 
    array([[   16,  -120,   240,  -140], 
           [ -120,  1200, -2700,  1680], 
           [  240, -2700,  6480, -4200], 
           [ -140,  1680, -4200,  2800]], dtype=int64) 
    &gt;&gt;&gt; invhilbert(16)[7,7] 
    4.2475099528537506e+19 
    &gt;&gt;&gt; invhilbert(16, exact=True)[7,7] 
    42475099528537378560 
 
    &quot;&quot;&quot;</span>
    <span class="s0">from </span><span class="s1">scipy.special </span><span class="s0">import </span><span class="s1">comb</span>
    <span class="s0">if </span><span class="s1">exact:</span>
        <span class="s0">if </span><span class="s1">n &gt; </span><span class="s4">14</span><span class="s1">:</span>
            <span class="s1">dtype = object</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">dtype = np.int64</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">dtype = np.float64</span>
    <span class="s1">invh = np.empty((n</span><span class="s0">, </span><span class="s1">n)</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(n):</span>
        <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">i + </span><span class="s4">1</span><span class="s1">):</span>
            <span class="s1">s = i + j</span>
            <span class="s1">invh[i</span><span class="s0">, </span><span class="s1">j] = ((-</span><span class="s4">1</span><span class="s1">) ** s * (s + </span><span class="s4">1</span><span class="s1">) *</span>
                          <span class="s1">comb(n + i</span><span class="s0">, </span><span class="s1">n - j - </span><span class="s4">1</span><span class="s0">, </span><span class="s1">exact) *</span>
                          <span class="s1">comb(n + j</span><span class="s0">, </span><span class="s1">n - i - </span><span class="s4">1</span><span class="s0">, </span><span class="s1">exact) *</span>
                          <span class="s1">comb(s</span><span class="s0">, </span><span class="s1">i</span><span class="s0">, </span><span class="s1">exact) ** </span><span class="s4">2</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">i != j:</span>
                <span class="s1">invh[j</span><span class="s0">, </span><span class="s1">i] = invh[i</span><span class="s0">, </span><span class="s1">j]</span>
    <span class="s0">return </span><span class="s1">invh</span>


<span class="s0">def </span><span class="s1">pascal(n</span><span class="s0">, </span><span class="s1">kind=</span><span class="s2">'symmetric'</span><span class="s0">, </span><span class="s1">exact=</span><span class="s0">True</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Returns the n x n Pascal matrix. 
 
    The Pascal matrix is a matrix containing the binomial coefficients as 
    its elements. 
 
    Parameters 
    ---------- 
    n : int 
        The size of the matrix to create; that is, the result is an n x n 
        matrix. 
    kind : str, optional 
        Must be one of 'symmetric', 'lower', or 'upper'. 
        Default is 'symmetric'. 
    exact : bool, optional 
        If `exact` is True, the result is either an array of type 
        numpy.uint64 (if n &lt; 35) or an object array of Python long integers. 
        If `exact` is False, the coefficients in the matrix are computed using 
        `scipy.special.comb` with `exact=False`. The result will be a floating 
        point array, and the values in the array will not be the exact 
        coefficients, but this version is much faster than `exact=True`. 
 
    Returns 
    ------- 
    p : (n, n) ndarray 
        The Pascal matrix. 
 
    See Also 
    -------- 
    invpascal 
 
    Notes 
    ----- 
    See https://en.wikipedia.org/wiki/Pascal_matrix for more information 
    about Pascal matrices. 
 
    .. versionadded:: 0.11.0 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.linalg import pascal 
    &gt;&gt;&gt; pascal(4) 
    array([[ 1,  1,  1,  1], 
           [ 1,  2,  3,  4], 
           [ 1,  3,  6, 10], 
           [ 1,  4, 10, 20]], dtype=uint64) 
    &gt;&gt;&gt; pascal(4, kind='lower') 
    array([[1, 0, 0, 0], 
           [1, 1, 0, 0], 
           [1, 2, 1, 0], 
           [1, 3, 3, 1]], dtype=uint64) 
    &gt;&gt;&gt; pascal(50)[-1, -1] 
    25477612258980856902730428600 
    &gt;&gt;&gt; from scipy.special import comb 
    &gt;&gt;&gt; comb(98, 49, exact=True) 
    25477612258980856902730428600 
 
    &quot;&quot;&quot;</span>

    <span class="s0">from </span><span class="s1">scipy.special </span><span class="s0">import </span><span class="s1">comb</span>
    <span class="s0">if </span><span class="s1">kind </span><span class="s0">not in </span><span class="s1">[</span><span class="s2">'symmetric'</span><span class="s0">, </span><span class="s2">'lower'</span><span class="s0">, </span><span class="s2">'upper'</span><span class="s1">]:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;kind must be 'symmetric', 'lower', or 'upper'&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">exact:</span>
        <span class="s0">if </span><span class="s1">n &gt;= </span><span class="s4">35</span><span class="s1">:</span>
            <span class="s1">L_n = np.empty((n</span><span class="s0">, </span><span class="s1">n)</span><span class="s0">, </span><span class="s1">dtype=object)</span>
            <span class="s1">L_n.fill(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">L_n = np.zeros((n</span><span class="s0">, </span><span class="s1">n)</span><span class="s0">, </span><span class="s1">dtype=np.uint64)</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(n):</span>
            <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(i + </span><span class="s4">1</span><span class="s1">):</span>
                <span class="s1">L_n[i</span><span class="s0">, </span><span class="s1">j] = comb(i</span><span class="s0">, </span><span class="s1">j</span><span class="s0">, </span><span class="s1">exact=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">L_n = comb(*np.ogrid[:n</span><span class="s0">, </span><span class="s1">:n])</span>

    <span class="s0">if </span><span class="s1">kind == </span><span class="s2">'lower'</span><span class="s1">:</span>
        <span class="s1">p = L_n</span>
    <span class="s0">elif </span><span class="s1">kind == </span><span class="s2">'upper'</span><span class="s1">:</span>
        <span class="s1">p = L_n.T</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">p = np.dot(L_n</span><span class="s0">, </span><span class="s1">L_n.T)</span>

    <span class="s0">return </span><span class="s1">p</span>


<span class="s0">def </span><span class="s1">invpascal(n</span><span class="s0">, </span><span class="s1">kind=</span><span class="s2">'symmetric'</span><span class="s0">, </span><span class="s1">exact=</span><span class="s0">True</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Returns the inverse of the n x n Pascal matrix. 
 
    The Pascal matrix is a matrix containing the binomial coefficients as 
    its elements. 
 
    Parameters 
    ---------- 
    n : int 
        The size of the matrix to create; that is, the result is an n x n 
        matrix. 
    kind : str, optional 
        Must be one of 'symmetric', 'lower', or 'upper'. 
        Default is 'symmetric'. 
    exact : bool, optional 
        If `exact` is True, the result is either an array of type 
        ``numpy.int64`` (if `n` &lt;= 35) or an object array of Python integers. 
        If `exact` is False, the coefficients in the matrix are computed using 
        `scipy.special.comb` with `exact=False`. The result will be a floating 
        point array, and for large `n`, the values in the array will not be the 
        exact coefficients. 
 
    Returns 
    ------- 
    invp : (n, n) ndarray 
        The inverse of the Pascal matrix. 
 
    See Also 
    -------- 
    pascal 
 
    Notes 
    ----- 
 
    .. versionadded:: 0.16.0 
 
    References 
    ---------- 
    .. [1] &quot;Pascal matrix&quot;, https://en.wikipedia.org/wiki/Pascal_matrix 
    .. [2] Cohen, A. M., &quot;The inverse of a Pascal matrix&quot;, Mathematical 
           Gazette, 59(408), pp. 111-112, 1975. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.linalg import invpascal, pascal 
    &gt;&gt;&gt; invp = invpascal(5) 
    &gt;&gt;&gt; invp 
    array([[  5, -10,  10,  -5,   1], 
           [-10,  30, -35,  19,  -4], 
           [ 10, -35,  46, -27,   6], 
           [ -5,  19, -27,  17,  -4], 
           [  1,  -4,   6,  -4,   1]]) 
 
    &gt;&gt;&gt; p = pascal(5) 
    &gt;&gt;&gt; p.dot(invp) 
    array([[ 1.,  0.,  0.,  0.,  0.], 
           [ 0.,  1.,  0.,  0.,  0.], 
           [ 0.,  0.,  1.,  0.,  0.], 
           [ 0.,  0.,  0.,  1.,  0.], 
           [ 0.,  0.,  0.,  0.,  1.]]) 
 
    An example of the use of `kind` and `exact`: 
 
    &gt;&gt;&gt; invpascal(5, kind='lower', exact=False) 
    array([[ 1., -0.,  0., -0.,  0.], 
           [-1.,  1., -0.,  0., -0.], 
           [ 1., -2.,  1., -0.,  0.], 
           [-1.,  3., -3.,  1., -0.], 
           [ 1., -4.,  6., -4.,  1.]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s0">from </span><span class="s1">scipy.special </span><span class="s0">import </span><span class="s1">comb</span>

    <span class="s0">if </span><span class="s1">kind </span><span class="s0">not in </span><span class="s1">[</span><span class="s2">'symmetric'</span><span class="s0">, </span><span class="s2">'lower'</span><span class="s0">, </span><span class="s2">'upper'</span><span class="s1">]:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;'kind' must be 'symmetric', 'lower' or 'upper'.&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">kind == </span><span class="s2">'symmetric'</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">exact:</span>
            <span class="s0">if </span><span class="s1">n &gt; </span><span class="s4">34</span><span class="s1">:</span>
                <span class="s1">dt = object</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">dt = np.int64</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">dt = np.float64</span>
        <span class="s1">invp = np.empty((n</span><span class="s0">, </span><span class="s1">n)</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(n):</span>
            <span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">i + </span><span class="s4">1</span><span class="s1">):</span>
                <span class="s1">v = </span><span class="s4">0</span>
                <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range(n - i):</span>
                    <span class="s1">v += comb(i + k</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">exact=exact) * comb(i + k</span><span class="s0">, </span><span class="s1">i + k - j</span><span class="s0">,</span>
                                                            <span class="s1">exact=exact)</span>
                <span class="s1">invp[i</span><span class="s0">, </span><span class="s1">j] = (-</span><span class="s4">1</span><span class="s1">)**(i - j) * v</span>
                <span class="s0">if </span><span class="s1">i != j:</span>
                    <span class="s1">invp[j</span><span class="s0">, </span><span class="s1">i] = invp[i</span><span class="s0">, </span><span class="s1">j]</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s3"># For the 'lower' and 'upper' cases, we computer the inverse by</span>
        <span class="s3"># changing the sign of every other diagonal of the pascal matrix.</span>
        <span class="s1">invp = pascal(n</span><span class="s0">, </span><span class="s1">kind=kind</span><span class="s0">, </span><span class="s1">exact=exact)</span>
        <span class="s0">if </span><span class="s1">invp.dtype == np.uint64:</span>
            <span class="s3"># This cast from np.uint64 to int64 OK, because if `kind` is not</span>
            <span class="s3"># &quot;symmetric&quot;, the values in invp are all much less than 2**63.</span>
            <span class="s1">invp = invp.view(np.int64)</span>

        <span class="s3"># The toeplitz matrix has alternating bands of 1 and -1.</span>
        <span class="s1">invp *= toeplitz((-</span><span class="s4">1</span><span class="s1">)**np.arange(n)).astype(invp.dtype)</span>

    <span class="s0">return </span><span class="s1">invp</span>


<span class="s0">def </span><span class="s1">dft(n</span><span class="s0">, </span><span class="s1">scale=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Discrete Fourier transform matrix. 
 
    Create the matrix that computes the discrete Fourier transform of a 
    sequence [1]_. The nth primitive root of unity used to generate the 
    matrix is exp(-2*pi*i/n), where i = sqrt(-1). 
 
    Parameters 
    ---------- 
    n : int 
        Size the matrix to create. 
    scale : str, optional 
        Must be None, 'sqrtn', or 'n'. 
        If `scale` is 'sqrtn', the matrix is divided by `sqrt(n)`. 
        If `scale` is 'n', the matrix is divided by `n`. 
        If `scale` is None (the default), the matrix is not normalized, and the 
        return value is simply the Vandermonde matrix of the roots of unity. 
 
    Returns 
    ------- 
    m : (n, n) ndarray 
        The DFT matrix. 
 
    Notes 
    ----- 
    When `scale` is None, multiplying a vector by the matrix returned by 
    `dft` is mathematically equivalent to (but much less efficient than) 
    the calculation performed by `scipy.fft.fft`. 
 
    .. versionadded:: 0.14.0 
 
    References 
    ---------- 
    .. [1] &quot;DFT matrix&quot;, https://en.wikipedia.org/wiki/DFT_matrix 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.linalg import dft 
    &gt;&gt;&gt; np.set_printoptions(precision=2, suppress=True)  # for compact output 
    &gt;&gt;&gt; m = dft(5) 
    &gt;&gt;&gt; m 
    array([[ 1.  +0.j  ,  1.  +0.j  ,  1.  +0.j  ,  1.  +0.j  ,  1.  +0.j  ], 
           [ 1.  +0.j  ,  0.31-0.95j, -0.81-0.59j, -0.81+0.59j,  0.31+0.95j], 
           [ 1.  +0.j  , -0.81-0.59j,  0.31+0.95j,  0.31-0.95j, -0.81+0.59j], 
           [ 1.  +0.j  , -0.81+0.59j,  0.31-0.95j,  0.31+0.95j, -0.81-0.59j], 
           [ 1.  +0.j  ,  0.31+0.95j, -0.81+0.59j, -0.81-0.59j,  0.31-0.95j]]) 
    &gt;&gt;&gt; x = np.array([1, 2, 3, 0, 3]) 
    &gt;&gt;&gt; m @ x  # Compute the DFT of x 
    array([ 9.  +0.j  ,  0.12-0.81j, -2.12+3.44j, -2.12-3.44j,  0.12+0.81j]) 
 
    Verify that ``m @ x`` is the same as ``fft(x)``. 
 
    &gt;&gt;&gt; from scipy.fft import fft 
    &gt;&gt;&gt; fft(x)     # Same result as m @ x 
    array([ 9.  +0.j  ,  0.12-0.81j, -2.12+3.44j, -2.12-3.44j,  0.12+0.81j]) 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">scale </span><span class="s0">not in </span><span class="s1">[</span><span class="s0">None, </span><span class="s2">'sqrtn'</span><span class="s0">, </span><span class="s2">'n'</span><span class="s1">]:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;scale must be None, 'sqrtn', or 'n'; &quot;</span>
                         <span class="s2">&quot;{!r} is not valid.&quot;</span><span class="s1">.format(scale))</span>

    <span class="s1">omegas = np.exp(-</span><span class="s4">2j </span><span class="s1">* np.pi * np.arange(n) / n).reshape(-</span><span class="s4">1</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">m = omegas ** np.arange(n)</span>
    <span class="s0">if </span><span class="s1">scale == </span><span class="s2">'sqrtn'</span><span class="s1">:</span>
        <span class="s1">m /= math.sqrt(n)</span>
    <span class="s0">elif </span><span class="s1">scale == </span><span class="s2">'n'</span><span class="s1">:</span>
        <span class="s1">m /= n</span>
    <span class="s0">return </span><span class="s1">m</span>


<span class="s0">def </span><span class="s1">fiedler(a):</span>
    <span class="s5">&quot;&quot;&quot;Returns a symmetric Fiedler matrix 
 
    Given an sequence of numbers `a`, Fiedler matrices have the structure 
    ``F[i, j] = np.abs(a[i] - a[j])``, and hence zero diagonals and nonnegative 
    entries. A Fiedler matrix has a dominant positive eigenvalue and other 
    eigenvalues are negative. Although not valid generally, for certain inputs, 
    the inverse and the determinant can be derived explicitly as given in [1]_. 
 
    Parameters 
    ---------- 
    a : (n,) array_like 
        coefficient array 
 
    Returns 
    ------- 
    F : (n, n) ndarray 
 
    See Also 
    -------- 
    circulant, toeplitz 
 
    Notes 
    ----- 
 
    .. versionadded:: 1.3.0 
 
    References 
    ---------- 
    .. [1] J. Todd, &quot;Basic Numerical Mathematics: Vol.2 : Numerical Algebra&quot;, 
        1977, Birkhauser, :doi:`10.1007/978-3-0348-7286-7` 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.linalg import det, inv, fiedler 
    &gt;&gt;&gt; a = [1, 4, 12, 45, 77] 
    &gt;&gt;&gt; n = len(a) 
    &gt;&gt;&gt; A = fiedler(a) 
    &gt;&gt;&gt; A 
    array([[ 0,  3, 11, 44, 76], 
           [ 3,  0,  8, 41, 73], 
           [11,  8,  0, 33, 65], 
           [44, 41, 33,  0, 32], 
           [76, 73, 65, 32,  0]]) 
 
    The explicit formulas for determinant and inverse seem to hold only for 
    monotonically increasing/decreasing arrays. Note the tridiagonal structure 
    and the corners. 
 
    &gt;&gt;&gt; Ai = inv(A) 
    &gt;&gt;&gt; Ai[np.abs(Ai) &lt; 1e-12] = 0.  # cleanup the numerical noise for display 
    &gt;&gt;&gt; Ai 
    array([[-0.16008772,  0.16666667,  0.        ,  0.        ,  0.00657895], 
           [ 0.16666667, -0.22916667,  0.0625    ,  0.        ,  0.        ], 
           [ 0.        ,  0.0625    , -0.07765152,  0.01515152,  0.        ], 
           [ 0.        ,  0.        ,  0.01515152, -0.03077652,  0.015625  ], 
           [ 0.00657895,  0.        ,  0.        ,  0.015625  , -0.00904605]]) 
    &gt;&gt;&gt; det(A) 
    15409151.999999998 
    &gt;&gt;&gt; (-1)**(n-1) * 2**(n-2) * np.diff(a).prod() * (a[-1] - a[0]) 
    15409152 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a = np.atleast_1d(a)</span>

    <span class="s0">if </span><span class="s1">a.ndim != </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Input 'a' must be a 1D array.&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">a.size == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">np.array([]</span><span class="s0">, </span><span class="s1">dtype=float)</span>
    <span class="s0">elif </span><span class="s1">a.size == </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">np.array([[</span><span class="s4">0.</span><span class="s1">]])</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">np.abs(a[:</span><span class="s0">, None</span><span class="s1">] - a)</span>


<span class="s0">def </span><span class="s1">fiedler_companion(a):</span>
    <span class="s5">&quot;&quot;&quot; Returns a Fiedler companion matrix 
 
    Given a polynomial coefficient array ``a``, this function forms a 
    pentadiagonal matrix with a special structure whose eigenvalues coincides 
    with the roots of ``a``. 
 
    Parameters 
    ---------- 
    a : (N,) array_like 
        1-D array of polynomial coefficients in descending order with a nonzero 
        leading coefficient. For ``N &lt; 2``, an empty array is returned. 
 
    Returns 
    ------- 
    c : (N-1, N-1) ndarray 
        Resulting companion matrix 
 
    See Also 
    -------- 
    companion 
 
    Notes 
    ----- 
    Similar to `companion` the leading coefficient should be nonzero. In the case 
    the leading coefficient is not 1, other coefficients are rescaled before 
    the array generation. To avoid numerical issues, it is best to provide a 
    monic polynomial. 
 
    .. versionadded:: 1.3.0 
 
    References 
    ---------- 
    .. [1] M. Fiedler, &quot; A note on companion matrices&quot;, Linear Algebra and its 
        Applications, 2003, :doi:`10.1016/S0024-3795(03)00548-2` 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.linalg import fiedler_companion, eigvals 
    &gt;&gt;&gt; p = np.poly(np.arange(1, 9, 2))  # [1., -16., 86., -176., 105.] 
    &gt;&gt;&gt; fc = fiedler_companion(p) 
    &gt;&gt;&gt; fc 
    array([[  16.,  -86.,    1.,    0.], 
           [   1.,    0.,    0.,    0.], 
           [   0.,  176.,    0., -105.], 
           [   0.,    1.,    0.,    0.]]) 
    &gt;&gt;&gt; eigvals(fc) 
    array([7.+0.j, 5.+0.j, 3.+0.j, 1.+0.j]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">a = np.atleast_1d(a)</span>

    <span class="s0">if </span><span class="s1">a.ndim != </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Input 'a' must be a 1-D array.&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">a.size &lt;= </span><span class="s4">2</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">a.size == </span><span class="s4">2</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">np.array([[-(a/a[</span><span class="s4">0</span><span class="s1">])[-</span><span class="s4">1</span><span class="s1">]]])</span>
        <span class="s0">return </span><span class="s1">np.array([]</span><span class="s0">, </span><span class="s1">dtype=a.dtype)</span>

    <span class="s0">if </span><span class="s1">a[</span><span class="s4">0</span><span class="s1">] == </span><span class="s4">0.</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">'Leading coefficient is zero.'</span><span class="s1">)</span>

    <span class="s1">a = a/a[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">n = a.size - </span><span class="s4">1</span>
    <span class="s1">c = np.zeros((n</span><span class="s0">, </span><span class="s1">n)</span><span class="s0">, </span><span class="s1">dtype=a.dtype)</span>
    <span class="s3"># subdiagonals</span>
    <span class="s1">c[range(</span><span class="s4">3</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">range(</span><span class="s4">1</span><span class="s0">, </span><span class="s1">n-</span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)] = </span><span class="s4">1.</span>
    <span class="s1">c[range(</span><span class="s4">2</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">range(</span><span class="s4">1</span><span class="s0">, </span><span class="s1">n-</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)] = -a[</span><span class="s4">3</span><span class="s1">::</span><span class="s4">2</span><span class="s1">]</span>
    <span class="s3"># superdiagonals</span>
    <span class="s1">c[range(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">n-</span><span class="s4">2</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">range(</span><span class="s4">2</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)] = </span><span class="s4">1.</span>
    <span class="s1">c[range(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">n-</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">range(</span><span class="s4">1</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s4">2</span><span class="s1">)] = -a[</span><span class="s4">2</span><span class="s1">::</span><span class="s4">2</span><span class="s1">]</span>
    <span class="s1">c[[</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s4">0</span><span class="s1">] = [-a[</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s4">1</span><span class="s1">]</span>

    <span class="s0">return </span><span class="s1">c</span>


<span class="s0">def </span><span class="s1">convolution_matrix(a</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">mode=</span><span class="s2">'full'</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Construct a convolution matrix. 
 
    Constructs the Toeplitz matrix representing one-dimensional 
    convolution [1]_.  See the notes below for details. 
 
    Parameters 
    ---------- 
    a : (m,) array_like 
        The 1-D array to convolve. 
    n : int 
        The number of columns in the resulting matrix.  It gives the length 
        of the input to be convolved with `a`.  This is analogous to the 
        length of `v` in ``numpy.convolve(a, v)``. 
    mode : str 
        This is analogous to `mode` in ``numpy.convolve(v, a, mode)``. 
        It must be one of ('full', 'valid', 'same'). 
        See below for how `mode` determines the shape of the result. 
 
    Returns 
    ------- 
    A : (k, n) ndarray 
        The convolution matrix whose row count `k` depends on `mode`:: 
 
            =======  ========================= 
             mode    k 
            =======  ========================= 
            'full'   m + n -1 
            'same'   max(m, n) 
            'valid'  max(m, n) - min(m, n) + 1 
            =======  ========================= 
 
    See Also 
    -------- 
    toeplitz : Toeplitz matrix 
 
    Notes 
    ----- 
    The code:: 
 
        A = convolution_matrix(a, n, mode) 
 
    creates a Toeplitz matrix `A` such that ``A @ v`` is equivalent to 
    using ``convolve(a, v, mode)``.  The returned array always has `n` 
    columns.  The number of rows depends on the specified `mode`, as 
    explained above. 
 
    In the default 'full' mode, the entries of `A` are given by:: 
 
        A[i, j] == (a[i-j] if (0 &lt;= (i-j) &lt; m) else 0) 
 
    where ``m = len(a)``.  Suppose, for example, the input array is 
    ``[x, y, z]``.  The convolution matrix has the form:: 
 
        [x, 0, 0, ..., 0, 0] 
        [y, x, 0, ..., 0, 0] 
        [z, y, x, ..., 0, 0] 
        ... 
        [0, 0, 0, ..., x, 0] 
        [0, 0, 0, ..., y, x] 
        [0, 0, 0, ..., z, y] 
        [0, 0, 0, ..., 0, z] 
 
    In 'valid' mode, the entries of `A` are given by:: 
 
        A[i, j] == (a[i-j+m-1] if (0 &lt;= (i-j+m-1) &lt; m) else 0) 
 
    This corresponds to a matrix whose rows are the subset of those from 
    the 'full' case where all the coefficients in `a` are contained in the 
    row.  For input ``[x, y, z]``, this array looks like:: 
 
        [z, y, x, 0, 0, ..., 0, 0, 0] 
        [0, z, y, x, 0, ..., 0, 0, 0] 
        [0, 0, z, y, x, ..., 0, 0, 0] 
        ... 
        [0, 0, 0, 0, 0, ..., x, 0, 0] 
        [0, 0, 0, 0, 0, ..., y, x, 0] 
        [0, 0, 0, 0, 0, ..., z, y, x] 
 
    In the 'same' mode, the entries of `A` are given by:: 
 
        d = (m - 1) // 2 
        A[i, j] == (a[i-j+d] if (0 &lt;= (i-j+d) &lt; m) else 0) 
 
    The typical application of the 'same' mode is when one has a signal of 
    length `n` (with `n` greater than ``len(a)``), and the desired output 
    is a filtered signal that is still of length `n`. 
 
    For input ``[x, y, z]``, this array looks like:: 
 
        [y, x, 0, 0, ..., 0, 0, 0] 
        [z, y, x, 0, ..., 0, 0, 0] 
        [0, z, y, x, ..., 0, 0, 0] 
        [0, 0, z, y, ..., 0, 0, 0] 
        ... 
        [0, 0, 0, 0, ..., y, x, 0] 
        [0, 0, 0, 0, ..., z, y, x] 
        [0, 0, 0, 0, ..., 0, z, y] 
 
    .. versionadded:: 1.5.0 
 
    References 
    ---------- 
    .. [1] &quot;Convolution&quot;, https://en.wikipedia.org/wiki/Convolution 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.linalg import convolution_matrix 
    &gt;&gt;&gt; A = convolution_matrix([-1, 4, -2], 5, mode='same') 
    &gt;&gt;&gt; A 
    array([[ 4, -1,  0,  0,  0], 
           [-2,  4, -1,  0,  0], 
           [ 0, -2,  4, -1,  0], 
           [ 0,  0, -2,  4, -1], 
           [ 0,  0,  0, -2,  4]]) 
 
    Compare multiplication by `A` with the use of `numpy.convolve`. 
 
    &gt;&gt;&gt; x = np.array([1, 2, 0, -3, 0.5]) 
    &gt;&gt;&gt; A @ x 
    array([  2. ,   6. ,  -1. , -12.5,   8. ]) 
 
    Verify that ``A @ x`` produced the same result as applying the 
    convolution function. 
 
    &gt;&gt;&gt; np.convolve([-1, 4, -2], x, mode='same') 
    array([  2. ,   6. ,  -1. , -12.5,   8. ]) 
 
    For comparison to the case ``mode='same'`` shown above, here are the 
    matrices produced by ``mode='full'`` and ``mode='valid'`` for the 
    same coefficients and size. 
 
    &gt;&gt;&gt; convolution_matrix([-1, 4, -2], 5, mode='full') 
    array([[-1,  0,  0,  0,  0], 
           [ 4, -1,  0,  0,  0], 
           [-2,  4, -1,  0,  0], 
           [ 0, -2,  4, -1,  0], 
           [ 0,  0, -2,  4, -1], 
           [ 0,  0,  0, -2,  4], 
           [ 0,  0,  0,  0, -2]]) 
 
    &gt;&gt;&gt; convolution_matrix([-1, 4, -2], 5, mode='valid') 
    array([[-2,  4, -1,  0,  0], 
           [ 0, -2,  4, -1,  0], 
           [ 0,  0, -2,  4, -1]]) 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">n &lt;= </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">'n must be a positive integer.'</span><span class="s1">)</span>

    <span class="s1">a = np.asarray(a)</span>
    <span class="s0">if </span><span class="s1">a.ndim != </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">'convolution_matrix expects a one-dimensional '</span>
                         <span class="s2">'array as input'</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">a.size == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">'len(a) must be at least 1.'</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">mode </span><span class="s0">not in </span><span class="s1">(</span><span class="s2">'full'</span><span class="s0">, </span><span class="s2">'valid'</span><span class="s0">, </span><span class="s2">'same'</span><span class="s1">):</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span>
            <span class="s2">&quot;'mode' argument must be one of ('full', 'valid', 'same')&quot;</span><span class="s1">)</span>

    <span class="s3"># create zero padded versions of the array</span>
    <span class="s1">az = np.pad(a</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">n-</span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s2">'constant'</span><span class="s1">)</span>
    <span class="s1">raz = np.pad(a[::-</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">(</span><span class="s4">0</span><span class="s0">, </span><span class="s1">n-</span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s2">'constant'</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">mode == </span><span class="s2">'same'</span><span class="s1">:</span>
        <span class="s1">trim = min(n</span><span class="s0">, </span><span class="s1">len(a)) - </span><span class="s4">1</span>
        <span class="s1">tb = trim//</span><span class="s4">2</span>
        <span class="s1">te = trim - tb</span>
        <span class="s1">col0 = az[tb:len(az)-te]</span>
        <span class="s1">row0 = raz[-n-tb:len(raz)-tb]</span>
    <span class="s0">elif </span><span class="s1">mode == </span><span class="s2">'valid'</span><span class="s1">:</span>
        <span class="s1">tb = min(n</span><span class="s0">, </span><span class="s1">len(a)) - </span><span class="s4">1</span>
        <span class="s1">te = tb</span>
        <span class="s1">col0 = az[tb:len(az)-te]</span>
        <span class="s1">row0 = raz[-n-tb:len(raz)-tb]</span>
    <span class="s0">else</span><span class="s1">:  </span><span class="s3"># 'full'</span>
        <span class="s1">col0 = az</span>
        <span class="s1">row0 = raz[-n:]</span>
    <span class="s0">return </span><span class="s1">toeplitz(col0</span><span class="s0">, </span><span class="s1">row0)</span>
</pre>
</body>
</html>