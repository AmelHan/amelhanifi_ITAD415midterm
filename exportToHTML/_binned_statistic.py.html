<html>
<head>
<title>_binned_statistic.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #6897bb;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_binned_statistic.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">builtins</span>
<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">numpy.testing </span><span class="s0">import </span><span class="s1">suppress_warnings</span>
<span class="s0">from </span><span class="s1">operator </span><span class="s0">import </span><span class="s1">index</span>
<span class="s0">from </span><span class="s1">collections </span><span class="s0">import </span><span class="s1">namedtuple</span>

<span class="s1">__all__ = [</span><span class="s2">'binned_statistic'</span><span class="s0">,</span>
           <span class="s2">'binned_statistic_2d'</span><span class="s0">,</span>
           <span class="s2">'binned_statistic_dd'</span><span class="s1">]</span>


<span class="s1">BinnedStatisticResult = namedtuple(</span><span class="s2">'BinnedStatisticResult'</span><span class="s0">,</span>
                                   <span class="s1">(</span><span class="s2">'statistic'</span><span class="s0">, </span><span class="s2">'bin_edges'</span><span class="s0">, </span><span class="s2">'binnumber'</span><span class="s1">))</span>


<span class="s0">def </span><span class="s1">binned_statistic(x</span><span class="s0">, </span><span class="s1">values</span><span class="s0">, </span><span class="s1">statistic=</span><span class="s2">'mean'</span><span class="s0">,</span>
                     <span class="s1">bins=</span><span class="s3">10</span><span class="s0">, </span><span class="s1">range=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Compute a binned statistic for one or more sets of data. 
 
    This is a generalization of a histogram function.  A histogram divides 
    the space into bins, and returns the count of the number of points in 
    each bin.  This function allows the computation of the sum, mean, median, 
    or other statistic of the values (or set of values) within each bin. 
 
    Parameters 
    ---------- 
    x : (N,) array_like 
        A sequence of values to be binned. 
    values : (N,) array_like or list of (N,) array_like 
        The data on which the statistic will be computed.  This must be 
        the same shape as `x`, or a set of sequences - each the same shape as 
        `x`.  If `values` is a set of sequences, the statistic will be computed 
        on each independently. 
    statistic : string or callable, optional 
        The statistic to compute (default is 'mean'). 
        The following statistics are available: 
 
          * 'mean' : compute the mean of values for points within each bin. 
            Empty bins will be represented by NaN. 
          * 'std' : compute the standard deviation within each bin. This 
            is implicitly calculated with ddof=0. 
          * 'median' : compute the median of values for points within each 
            bin. Empty bins will be represented by NaN. 
          * 'count' : compute the count of points within each bin.  This is 
            identical to an unweighted histogram.  `values` array is not 
            referenced. 
          * 'sum' : compute the sum of values for points within each bin. 
            This is identical to a weighted histogram. 
          * 'min' : compute the minimum of values for points within each bin. 
            Empty bins will be represented by NaN. 
          * 'max' : compute the maximum of values for point within each bin. 
            Empty bins will be represented by NaN. 
          * function : a user-defined function which takes a 1D array of 
            values, and outputs a single numerical statistic. This function 
            will be called on the values in each bin.  Empty bins will be 
            represented by function([]), or NaN if this returns an error. 
 
    bins : int or sequence of scalars, optional 
        If `bins` is an int, it defines the number of equal-width bins in the 
        given range (10 by default).  If `bins` is a sequence, it defines the 
        bin edges, including the rightmost edge, allowing for non-uniform bin 
        widths.  Values in `x` that are smaller than lowest bin edge are 
        assigned to bin number 0, values beyond the highest bin are assigned to 
        ``bins[-1]``.  If the bin edges are specified, the number of bins will 
        be, (nx = len(bins)-1). 
    range : (float, float) or [(float, float)], optional 
        The lower and upper range of the bins.  If not provided, range 
        is simply ``(x.min(), x.max())``.  Values outside the range are 
        ignored. 
 
    Returns 
    ------- 
    statistic : array 
        The values of the selected statistic in each bin. 
    bin_edges : array of dtype float 
        Return the bin edges ``(length(statistic)+1)``. 
    binnumber: 1-D ndarray of ints 
        Indices of the bins (corresponding to `bin_edges`) in which each value 
        of `x` belongs.  Same length as `values`.  A binnumber of `i` means the 
        corresponding value is between (bin_edges[i-1], bin_edges[i]). 
 
    See Also 
    -------- 
    numpy.digitize, numpy.histogram, binned_statistic_2d, binned_statistic_dd 
 
    Notes 
    ----- 
    All but the last (righthand-most) bin is half-open.  In other words, if 
    `bins` is ``[1, 2, 3, 4]``, then the first bin is ``[1, 2)`` (including 1, 
    but excluding 2) and the second ``[2, 3)``.  The last bin, however, is 
    ``[3, 4]``, which *includes* 4. 
 
    .. versionadded:: 0.11.0 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    First some basic examples: 
 
    Create two evenly spaced bins in the range of the given sample, and sum the 
    corresponding values in each of those bins: 
 
    &gt;&gt;&gt; values = [1.0, 1.0, 2.0, 1.5, 3.0] 
    &gt;&gt;&gt; stats.binned_statistic([1, 1, 2, 5, 7], values, 'sum', bins=2) 
    BinnedStatisticResult(statistic=array([4. , 4.5]), 
            bin_edges=array([1., 4., 7.]), binnumber=array([1, 1, 1, 2, 2])) 
 
    Multiple arrays of values can also be passed.  The statistic is calculated 
    on each set independently: 
 
    &gt;&gt;&gt; values = [[1.0, 1.0, 2.0, 1.5, 3.0], [2.0, 2.0, 4.0, 3.0, 6.0]] 
    &gt;&gt;&gt; stats.binned_statistic([1, 1, 2, 5, 7], values, 'sum', bins=2) 
    BinnedStatisticResult(statistic=array([[4. , 4.5], 
           [8. , 9. ]]), bin_edges=array([1., 4., 7.]), 
           binnumber=array([1, 1, 1, 2, 2])) 
 
    &gt;&gt;&gt; stats.binned_statistic([1, 2, 1, 2, 4], np.arange(5), statistic='mean', 
    ...                        bins=3) 
    BinnedStatisticResult(statistic=array([1., 2., 4.]), 
            bin_edges=array([1., 2., 3., 4.]), 
            binnumber=array([1, 2, 1, 2, 3])) 
 
    As a second example, we now generate some random data of sailing boat speed 
    as a function of wind speed, and then determine how fast our boat is for 
    certain wind speeds: 
 
    &gt;&gt;&gt; rng = np.random.default_rng() 
    &gt;&gt;&gt; windspeed = 8 * rng.random(500) 
    &gt;&gt;&gt; boatspeed = .3 * windspeed**.5 + .2 * rng.random(500) 
    &gt;&gt;&gt; bin_means, bin_edges, binnumber = stats.binned_statistic(windspeed, 
    ...                 boatspeed, statistic='median', bins=[1,2,3,4,5,6,7]) 
    &gt;&gt;&gt; plt.figure() 
    &gt;&gt;&gt; plt.plot(windspeed, boatspeed, 'b.', label='raw data') 
    &gt;&gt;&gt; plt.hlines(bin_means, bin_edges[:-1], bin_edges[1:], colors='g', lw=5, 
    ...            label='binned statistic of data') 
    &gt;&gt;&gt; plt.legend() 
 
    Now we can use ``binnumber`` to select all datapoints with a windspeed 
    below 1: 
 
    &gt;&gt;&gt; low_boatspeed = boatspeed[binnumber == 0] 
 
    As a final example, we will use ``bin_edges`` and ``binnumber`` to make a 
    plot of a distribution that shows the mean and distribution around that 
    mean per bin, on top of a regular histogram and the probability 
    distribution function: 
 
    &gt;&gt;&gt; x = np.linspace(0, 5, num=500) 
    &gt;&gt;&gt; x_pdf = stats.maxwell.pdf(x) 
    &gt;&gt;&gt; samples = stats.maxwell.rvs(size=10000) 
 
    &gt;&gt;&gt; bin_means, bin_edges, binnumber = stats.binned_statistic(x, x_pdf, 
    ...         statistic='mean', bins=25) 
    &gt;&gt;&gt; bin_width = (bin_edges[1] - bin_edges[0]) 
    &gt;&gt;&gt; bin_centers = bin_edges[1:] - bin_width/2 
 
    &gt;&gt;&gt; plt.figure() 
    &gt;&gt;&gt; plt.hist(samples, bins=50, density=True, histtype='stepfilled', 
    ...          alpha=0.2, label='histogram of data') 
    &gt;&gt;&gt; plt.plot(x, x_pdf, 'r-', label='analytical pdf') 
    &gt;&gt;&gt; plt.hlines(bin_means, bin_edges[:-1], bin_edges[1:], colors='g', lw=2, 
    ...            label='binned statistic of data') 
    &gt;&gt;&gt; plt.plot((binnumber - 0.5) * bin_width, x_pdf, 'g.', alpha=0.5) 
    &gt;&gt;&gt; plt.legend(fontsize=10) 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">N = len(bins)</span>
    <span class="s0">except </span><span class="s1">TypeError:</span>
        <span class="s1">N = </span><span class="s3">1</span>

    <span class="s0">if </span><span class="s1">N != </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s1">bins = [np.asarray(bins</span><span class="s0">, </span><span class="s1">float)]</span>

    <span class="s0">if </span><span class="s1">range </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">len(range) == </span><span class="s3">2</span><span class="s1">:</span>
            <span class="s1">range = [range]</span>

    <span class="s1">medians</span><span class="s0">, </span><span class="s1">edges</span><span class="s0">, </span><span class="s1">binnumbers = binned_statistic_dd(</span>
        <span class="s1">[x]</span><span class="s0">, </span><span class="s1">values</span><span class="s0">, </span><span class="s1">statistic</span><span class="s0">, </span><span class="s1">bins</span><span class="s0">, </span><span class="s1">range)</span>

    <span class="s0">return </span><span class="s1">BinnedStatisticResult(medians</span><span class="s0">, </span><span class="s1">edges[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">binnumbers)</span>


<span class="s1">BinnedStatistic2dResult = namedtuple(</span><span class="s2">'BinnedStatistic2dResult'</span><span class="s0">,</span>
                                     <span class="s1">(</span><span class="s2">'statistic'</span><span class="s0">, </span><span class="s2">'x_edge'</span><span class="s0">, </span><span class="s2">'y_edge'</span><span class="s0">,</span>
                                      <span class="s2">'binnumber'</span><span class="s1">))</span>


<span class="s0">def </span><span class="s1">binned_statistic_2d(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">values</span><span class="s0">, </span><span class="s1">statistic=</span><span class="s2">'mean'</span><span class="s0">,</span>
                        <span class="s1">bins=</span><span class="s3">10</span><span class="s0">, </span><span class="s1">range=</span><span class="s0">None, </span><span class="s1">expand_binnumbers=</span><span class="s0">False</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Compute a bidimensional binned statistic for one or more sets of data. 
 
    This is a generalization of a histogram2d function.  A histogram divides 
    the space into bins, and returns the count of the number of points in 
    each bin.  This function allows the computation of the sum, mean, median, 
    or other statistic of the values (or set of values) within each bin. 
 
    Parameters 
    ---------- 
    x : (N,) array_like 
        A sequence of values to be binned along the first dimension. 
    y : (N,) array_like 
        A sequence of values to be binned along the second dimension. 
    values : (N,) array_like or list of (N,) array_like 
        The data on which the statistic will be computed.  This must be 
        the same shape as `x`, or a list of sequences - each with the same 
        shape as `x`.  If `values` is such a list, the statistic will be 
        computed on each independently. 
    statistic : string or callable, optional 
        The statistic to compute (default is 'mean'). 
        The following statistics are available: 
 
          * 'mean' : compute the mean of values for points within each bin. 
            Empty bins will be represented by NaN. 
          * 'std' : compute the standard deviation within each bin. This 
            is implicitly calculated with ddof=0. 
          * 'median' : compute the median of values for points within each 
            bin. Empty bins will be represented by NaN. 
          * 'count' : compute the count of points within each bin.  This is 
            identical to an unweighted histogram.  `values` array is not 
            referenced. 
          * 'sum' : compute the sum of values for points within each bin. 
            This is identical to a weighted histogram. 
          * 'min' : compute the minimum of values for points within each bin. 
            Empty bins will be represented by NaN. 
          * 'max' : compute the maximum of values for point within each bin. 
            Empty bins will be represented by NaN. 
          * function : a user-defined function which takes a 1D array of 
            values, and outputs a single numerical statistic. This function 
            will be called on the values in each bin.  Empty bins will be 
            represented by function([]), or NaN if this returns an error. 
 
    bins : int or [int, int] or array_like or [array, array], optional 
        The bin specification: 
 
          * the number of bins for the two dimensions (nx = ny = bins), 
          * the number of bins in each dimension (nx, ny = bins), 
          * the bin edges for the two dimensions (x_edge = y_edge = bins), 
          * the bin edges in each dimension (x_edge, y_edge = bins). 
 
        If the bin edges are specified, the number of bins will be, 
        (nx = len(x_edge)-1, ny = len(y_edge)-1). 
 
    range : (2,2) array_like, optional 
        The leftmost and rightmost edges of the bins along each dimension 
        (if not specified explicitly in the `bins` parameters): 
        [[xmin, xmax], [ymin, ymax]]. All values outside of this range will be 
        considered outliers and not tallied in the histogram. 
    expand_binnumbers : bool, optional 
        'False' (default): the returned `binnumber` is a shape (N,) array of 
        linearized bin indices. 
        'True': the returned `binnumber` is 'unraveled' into a shape (2,N) 
        ndarray, where each row gives the bin numbers in the corresponding 
        dimension. 
        See the `binnumber` returned value, and the `Examples` section. 
 
        .. versionadded:: 0.17.0 
 
    Returns 
    ------- 
    statistic : (nx, ny) ndarray 
        The values of the selected statistic in each two-dimensional bin. 
    x_edge : (nx + 1) ndarray 
        The bin edges along the first dimension. 
    y_edge : (ny + 1) ndarray 
        The bin edges along the second dimension. 
    binnumber : (N,) array of ints or (2,N) ndarray of ints 
        This assigns to each element of `sample` an integer that represents the 
        bin in which this observation falls.  The representation depends on the 
        `expand_binnumbers` argument.  See `Notes` for details. 
 
 
    See Also 
    -------- 
    numpy.digitize, numpy.histogram2d, binned_statistic, binned_statistic_dd 
 
    Notes 
    ----- 
    Binedges: 
    All but the last (righthand-most) bin is half-open.  In other words, if 
    `bins` is ``[1, 2, 3, 4]``, then the first bin is ``[1, 2)`` (including 1, 
    but excluding 2) and the second ``[2, 3)``.  The last bin, however, is 
    ``[3, 4]``, which *includes* 4. 
 
    `binnumber`: 
    This returned argument assigns to each element of `sample` an integer that 
    represents the bin in which it belongs.  The representation depends on the 
    `expand_binnumbers` argument. If 'False' (default): The returned 
    `binnumber` is a shape (N,) array of linearized indices mapping each 
    element of `sample` to its corresponding bin (using row-major ordering). 
    Note that the returned linearized bin indices are used for an array with 
    extra bins on the outer binedges to capture values outside of the defined 
    bin bounds. 
    If 'True': The returned `binnumber` is a shape (2,N) ndarray where 
    each row indicates bin placements for each dimension respectively.  In each 
    dimension, a binnumber of `i` means the corresponding value is between 
    (D_edge[i-1], D_edge[i]), where 'D' is either 'x' or 'y'. 
 
    .. versionadded:: 0.11.0 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import stats 
 
    Calculate the counts with explicit bin-edges: 
 
    &gt;&gt;&gt; x = [0.1, 0.1, 0.1, 0.6] 
    &gt;&gt;&gt; y = [2.1, 2.6, 2.1, 2.1] 
    &gt;&gt;&gt; binx = [0.0, 0.5, 1.0] 
    &gt;&gt;&gt; biny = [2.0, 2.5, 3.0] 
    &gt;&gt;&gt; ret = stats.binned_statistic_2d(x, y, None, 'count', bins=[binx, biny]) 
    &gt;&gt;&gt; ret.statistic 
    array([[2., 1.], 
           [1., 0.]]) 
 
    The bin in which each sample is placed is given by the `binnumber` 
    returned parameter.  By default, these are the linearized bin indices: 
 
    &gt;&gt;&gt; ret.binnumber 
    array([5, 6, 5, 9]) 
 
    The bin indices can also be expanded into separate entries for each 
    dimension using the `expand_binnumbers` parameter: 
 
    &gt;&gt;&gt; ret = stats.binned_statistic_2d(x, y, None, 'count', bins=[binx, biny], 
    ...                                 expand_binnumbers=True) 
    &gt;&gt;&gt; ret.binnumber 
    array([[1, 1, 1, 2], 
           [1, 2, 1, 1]]) 
 
    Which shows that the first three elements belong in the xbin 1, and the 
    fourth into xbin 2; and so on for y. 
 
    &quot;&quot;&quot;</span>

    <span class="s5"># This code is based on np.histogram2d</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">N = len(bins)</span>
    <span class="s0">except </span><span class="s1">TypeError:</span>
        <span class="s1">N = </span><span class="s3">1</span>

    <span class="s0">if </span><span class="s1">N != </span><span class="s3">1 </span><span class="s0">and </span><span class="s1">N != </span><span class="s3">2</span><span class="s1">:</span>
        <span class="s1">xedges = yedges = np.asarray(bins</span><span class="s0">, </span><span class="s1">float)</span>
        <span class="s1">bins = [xedges</span><span class="s0">, </span><span class="s1">yedges]</span>

    <span class="s1">medians</span><span class="s0">, </span><span class="s1">edges</span><span class="s0">, </span><span class="s1">binnumbers = binned_statistic_dd(</span>
        <span class="s1">[x</span><span class="s0">, </span><span class="s1">y]</span><span class="s0">, </span><span class="s1">values</span><span class="s0">, </span><span class="s1">statistic</span><span class="s0">, </span><span class="s1">bins</span><span class="s0">, </span><span class="s1">range</span><span class="s0">,</span>
        <span class="s1">expand_binnumbers=expand_binnumbers)</span>

    <span class="s0">return </span><span class="s1">BinnedStatistic2dResult(medians</span><span class="s0">, </span><span class="s1">edges[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">edges[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">binnumbers)</span>


<span class="s1">BinnedStatisticddResult = namedtuple(</span><span class="s2">'BinnedStatisticddResult'</span><span class="s0">,</span>
                                     <span class="s1">(</span><span class="s2">'statistic'</span><span class="s0">, </span><span class="s2">'bin_edges'</span><span class="s0">,</span>
                                      <span class="s2">'binnumber'</span><span class="s1">))</span>


<span class="s0">def </span><span class="s1">_bincount(x</span><span class="s0">, </span><span class="s1">weights):</span>
    <span class="s0">if </span><span class="s1">np.iscomplexobj(weights):</span>
        <span class="s1">a = np.bincount(x</span><span class="s0">, </span><span class="s1">np.real(weights))</span>
        <span class="s1">b = np.bincount(x</span><span class="s0">, </span><span class="s1">np.imag(weights))</span>
        <span class="s1">z = a + b*</span><span class="s3">1j</span>

    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">z = np.bincount(x</span><span class="s0">, </span><span class="s1">weights)</span>
    <span class="s0">return </span><span class="s1">z</span>


<span class="s0">def </span><span class="s1">binned_statistic_dd(sample</span><span class="s0">, </span><span class="s1">values</span><span class="s0">, </span><span class="s1">statistic=</span><span class="s2">'mean'</span><span class="s0">,</span>
                        <span class="s1">bins=</span><span class="s3">10</span><span class="s0">, </span><span class="s1">range=</span><span class="s0">None, </span><span class="s1">expand_binnumbers=</span><span class="s0">False,</span>
                        <span class="s1">binned_statistic_result=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot; 
    Compute a multidimensional binned statistic for a set of data. 
 
    This is a generalization of a histogramdd function.  A histogram divides 
    the space into bins, and returns the count of the number of points in 
    each bin.  This function allows the computation of the sum, mean, median, 
    or other statistic of the values within each bin. 
 
    Parameters 
    ---------- 
    sample : array_like 
        Data to histogram passed as a sequence of N arrays of length D, or 
        as an (N,D) array. 
    values : (N,) array_like or list of (N,) array_like 
        The data on which the statistic will be computed.  This must be 
        the same shape as `sample`, or a list of sequences - each with the 
        same shape as `sample`.  If `values` is such a list, the statistic 
        will be computed on each independently. 
    statistic : string or callable, optional 
        The statistic to compute (default is 'mean'). 
        The following statistics are available: 
 
          * 'mean' : compute the mean of values for points within each bin. 
            Empty bins will be represented by NaN. 
          * 'median' : compute the median of values for points within each 
            bin. Empty bins will be represented by NaN. 
          * 'count' : compute the count of points within each bin.  This is 
            identical to an unweighted histogram.  `values` array is not 
            referenced. 
          * 'sum' : compute the sum of values for points within each bin. 
            This is identical to a weighted histogram. 
          * 'std' : compute the standard deviation within each bin. This 
            is implicitly calculated with ddof=0. If the number of values 
            within a given bin is 0 or 1, the computed standard deviation value 
            will be 0 for the bin. 
          * 'min' : compute the minimum of values for points within each bin. 
            Empty bins will be represented by NaN. 
          * 'max' : compute the maximum of values for point within each bin. 
            Empty bins will be represented by NaN. 
          * function : a user-defined function which takes a 1D array of 
            values, and outputs a single numerical statistic. This function 
            will be called on the values in each bin.  Empty bins will be 
            represented by function([]), or NaN if this returns an error. 
 
    bins : sequence or positive int, optional 
        The bin specification must be in one of the following forms: 
 
          * A sequence of arrays describing the bin edges along each dimension. 
          * The number of bins for each dimension (nx, ny, ... = bins). 
          * The number of bins for all dimensions (nx = ny = ... = bins). 
    range : sequence, optional 
        A sequence of lower and upper bin edges to be used if the edges are 
        not given explicitly in `bins`. Defaults to the minimum and maximum 
        values along each dimension. 
    expand_binnumbers : bool, optional 
        'False' (default): the returned `binnumber` is a shape (N,) array of 
        linearized bin indices. 
        'True': the returned `binnumber` is 'unraveled' into a shape (D,N) 
        ndarray, where each row gives the bin numbers in the corresponding 
        dimension. 
        See the `binnumber` returned value, and the `Examples` section of 
        `binned_statistic_2d`. 
    binned_statistic_result : binnedStatisticddResult 
        Result of a previous call to the function in order to reuse bin edges 
        and bin numbers with new values and/or a different statistic. 
        To reuse bin numbers, `expand_binnumbers` must have been set to False 
        (the default) 
 
        .. versionadded:: 0.17.0 
 
    Returns 
    ------- 
    statistic : ndarray, shape(nx1, nx2, nx3,...) 
        The values of the selected statistic in each two-dimensional bin. 
    bin_edges : list of ndarrays 
        A list of D arrays describing the (nxi + 1) bin edges for each 
        dimension. 
    binnumber : (N,) array of ints or (D,N) ndarray of ints 
        This assigns to each element of `sample` an integer that represents the 
        bin in which this observation falls.  The representation depends on the 
        `expand_binnumbers` argument.  See `Notes` for details. 
 
 
    See Also 
    -------- 
    numpy.digitize, numpy.histogramdd, binned_statistic, binned_statistic_2d 
 
    Notes 
    ----- 
    Binedges: 
    All but the last (righthand-most) bin is half-open in each dimension.  In 
    other words, if `bins` is ``[1, 2, 3, 4]``, then the first bin is 
    ``[1, 2)`` (including 1, but excluding 2) and the second ``[2, 3)``.  The 
    last bin, however, is ``[3, 4]``, which *includes* 4. 
 
    `binnumber`: 
    This returned argument assigns to each element of `sample` an integer that 
    represents the bin in which it belongs.  The representation depends on the 
    `expand_binnumbers` argument. If 'False' (default): The returned 
    `binnumber` is a shape (N,) array of linearized indices mapping each 
    element of `sample` to its corresponding bin (using row-major ordering). 
    If 'True': The returned `binnumber` is a shape (D,N) ndarray where 
    each row indicates bin placements for each dimension respectively.  In each 
    dimension, a binnumber of `i` means the corresponding value is between 
    (bin_edges[D][i-1], bin_edges[D][i]), for each dimension 'D'. 
 
    .. versionadded:: 0.11.0 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import stats 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; from mpl_toolkits.mplot3d import Axes3D 
 
    Take an array of 600 (x, y) coordinates as an example. 
    `binned_statistic_dd` can handle arrays of higher dimension `D`. But a plot 
    of dimension `D+1` is required. 
 
    &gt;&gt;&gt; mu = np.array([0., 1.]) 
    &gt;&gt;&gt; sigma = np.array([[1., -0.5],[-0.5, 1.5]]) 
    &gt;&gt;&gt; multinormal = stats.multivariate_normal(mu, sigma) 
    &gt;&gt;&gt; data = multinormal.rvs(size=600, random_state=235412) 
    &gt;&gt;&gt; data.shape 
    (600, 2) 
 
    Create bins and count how many arrays fall in each bin: 
 
    &gt;&gt;&gt; N = 60 
    &gt;&gt;&gt; x = np.linspace(-3, 3, N) 
    &gt;&gt;&gt; y = np.linspace(-3, 4, N) 
    &gt;&gt;&gt; ret = stats.binned_statistic_dd(data, np.arange(600), bins=[x, y], 
    ...                                 statistic='count') 
    &gt;&gt;&gt; bincounts = ret.statistic 
 
    Set the volume and the location of bars: 
 
    &gt;&gt;&gt; dx = x[1] - x[0] 
    &gt;&gt;&gt; dy = y[1] - y[0] 
    &gt;&gt;&gt; x, y = np.meshgrid(x[:-1]+dx/2, y[:-1]+dy/2) 
    &gt;&gt;&gt; z = 0 
 
    &gt;&gt;&gt; bincounts = bincounts.ravel() 
    &gt;&gt;&gt; x = x.ravel() 
    &gt;&gt;&gt; y = y.ravel() 
 
    &gt;&gt;&gt; fig = plt.figure() 
    &gt;&gt;&gt; ax = fig.add_subplot(111, projection='3d') 
    &gt;&gt;&gt; with np.errstate(divide='ignore'):   # silence random axes3d warning 
    ...     ax.bar3d(x, y, z, dx, dy, bincounts) 
 
    Reuse bin numbers and bin edges with new values: 
 
    &gt;&gt;&gt; ret2 = stats.binned_statistic_dd(data, -np.arange(600), 
    ...                                  binned_statistic_result=ret, 
    ...                                  statistic='mean') 
    &quot;&quot;&quot;</span>
    <span class="s1">known_stats = [</span><span class="s2">'mean'</span><span class="s0">, </span><span class="s2">'median'</span><span class="s0">, </span><span class="s2">'count'</span><span class="s0">, </span><span class="s2">'sum'</span><span class="s0">, </span><span class="s2">'std'</span><span class="s0">, </span><span class="s2">'min'</span><span class="s0">, </span><span class="s2">'max'</span><span class="s1">]</span>
    <span class="s0">if not </span><span class="s1">callable(statistic) </span><span class="s0">and </span><span class="s1">statistic </span><span class="s0">not in </span><span class="s1">known_stats:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">f'invalid statistic </span><span class="s0">{</span><span class="s1">statistic</span><span class="s0">!r}</span><span class="s2">'</span><span class="s1">)</span>

    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">bins = index(bins)</span>
    <span class="s0">except </span><span class="s1">TypeError:</span>
        <span class="s5"># bins is not an integer</span>
        <span class="s0">pass</span>
    <span class="s5"># If bins was an integer-like object, now it is an actual Python int.</span>

    <span class="s5"># NOTE: for _bin_edges(), see e.g. gh-11365</span>
    <span class="s0">if </span><span class="s1">isinstance(bins</span><span class="s0">, </span><span class="s1">int) </span><span class="s0">and not </span><span class="s1">np.isfinite(sample).all():</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">f'</span><span class="s0">{</span><span class="s1">sample</span><span class="s0">!r} </span><span class="s2">contains non-finite values.'</span><span class="s1">)</span>

    <span class="s5"># `Ndim` is the number of dimensions (e.g. `2` for `binned_statistic_2d`)</span>
    <span class="s5"># `Dlen` is the length of elements along each dimension.</span>
    <span class="s5"># This code is based on np.histogramdd</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s5"># `sample` is an ND-array.</span>
        <span class="s1">Dlen</span><span class="s0">, </span><span class="s1">Ndim = sample.shape</span>
    <span class="s0">except </span><span class="s1">(AttributeError</span><span class="s0">, </span><span class="s1">ValueError):</span>
        <span class="s5"># `sample` is a sequence of 1D arrays.</span>
        <span class="s1">sample = np.atleast_2d(sample).T</span>
        <span class="s1">Dlen</span><span class="s0">, </span><span class="s1">Ndim = sample.shape</span>

    <span class="s5"># Store initial shape of `values` to preserve it in the output</span>
    <span class="s1">values = np.asarray(values)</span>
    <span class="s1">input_shape = list(values.shape)</span>
    <span class="s5"># Make sure that `values` is 2D to iterate over rows</span>
    <span class="s1">values = np.atleast_2d(values)</span>
    <span class="s1">Vdim</span><span class="s0">, </span><span class="s1">Vlen = values.shape</span>

    <span class="s5"># Make sure `values` match `sample`</span>
    <span class="s0">if </span><span class="s1">statistic != </span><span class="s2">'count' </span><span class="s0">and </span><span class="s1">Vlen != Dlen:</span>
        <span class="s0">raise </span><span class="s1">AttributeError(</span><span class="s2">'The number of `values` elements must match the '</span>
                             <span class="s2">'length of each `sample` dimension.'</span><span class="s1">)</span>

    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">M = len(bins)</span>
        <span class="s0">if </span><span class="s1">M != Ndim:</span>
            <span class="s0">raise </span><span class="s1">AttributeError(</span><span class="s2">'The dimension of bins must be equal '</span>
                                 <span class="s2">'to the dimension of the sample x.'</span><span class="s1">)</span>
    <span class="s0">except </span><span class="s1">TypeError:</span>
        <span class="s1">bins = Ndim * [bins]</span>

    <span class="s0">if </span><span class="s1">binned_statistic_result </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">nbin</span><span class="s0">, </span><span class="s1">edges</span><span class="s0">, </span><span class="s1">dedges = _bin_edges(sample</span><span class="s0">, </span><span class="s1">bins</span><span class="s0">, </span><span class="s1">range)</span>
        <span class="s1">binnumbers = _bin_numbers(sample</span><span class="s0">, </span><span class="s1">nbin</span><span class="s0">, </span><span class="s1">edges</span><span class="s0">, </span><span class="s1">dedges)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">edges = binned_statistic_result.bin_edges</span>
        <span class="s1">nbin = np.array([len(edges[i]) + </span><span class="s3">1 </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">builtins.range(Ndim)])</span>
        <span class="s5"># +1 for outlier bins</span>
        <span class="s1">dedges = [np.diff(edges[i]) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">builtins.range(Ndim)]</span>
        <span class="s1">binnumbers = binned_statistic_result.binnumber</span>

    <span class="s5"># Avoid overflow with double precision. Complex `values` -&gt; `complex128`.</span>
    <span class="s1">result_type = np.result_type(values</span><span class="s0">, </span><span class="s1">np.float64)</span>
    <span class="s1">result = np.empty([Vdim</span><span class="s0">, </span><span class="s1">nbin.prod()]</span><span class="s0">, </span><span class="s1">dtype=result_type)</span>

    <span class="s0">if </span><span class="s1">statistic </span><span class="s0">in </span><span class="s1">{</span><span class="s2">'mean'</span><span class="s0">, </span><span class="s1">np.mean}:</span>
        <span class="s1">result.fill(np.nan)</span>
        <span class="s1">flatcount = _bincount(binnumbers</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s1">a = flatcount.nonzero()</span>
        <span class="s0">for </span><span class="s1">vv </span><span class="s0">in </span><span class="s1">builtins.range(Vdim):</span>
            <span class="s1">flatsum = _bincount(binnumbers</span><span class="s0">, </span><span class="s1">values[vv])</span>
            <span class="s1">result[vv</span><span class="s0">, </span><span class="s1">a] = flatsum[a] / flatcount[a]</span>
    <span class="s0">elif </span><span class="s1">statistic </span><span class="s0">in </span><span class="s1">{</span><span class="s2">'std'</span><span class="s0">, </span><span class="s1">np.std}:</span>
        <span class="s1">result.fill(np.nan)</span>
        <span class="s1">flatcount = _bincount(binnumbers</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s1">a = flatcount.nonzero()</span>
        <span class="s0">for </span><span class="s1">vv </span><span class="s0">in </span><span class="s1">builtins.range(Vdim):</span>
            <span class="s1">flatsum = _bincount(binnumbers</span><span class="s0">, </span><span class="s1">values[vv])</span>
            <span class="s1">delta = values[vv] - flatsum[binnumbers] / flatcount[binnumbers]</span>
            <span class="s1">std = np.sqrt(</span>
                <span class="s1">_bincount(binnumbers</span><span class="s0">, </span><span class="s1">delta*np.conj(delta))[a] / flatcount[a]</span>
            <span class="s1">)</span>
            <span class="s1">result[vv</span><span class="s0">, </span><span class="s1">a] = std</span>
        <span class="s1">result = np.real(result)</span>
    <span class="s0">elif </span><span class="s1">statistic == </span><span class="s2">'count'</span><span class="s1">:</span>
        <span class="s1">result = np.empty([Vdim</span><span class="s0">, </span><span class="s1">nbin.prod()]</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s1">result.fill(</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">flatcount = _bincount(binnumbers</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s1">a = np.arange(len(flatcount))</span>
        <span class="s1">result[:</span><span class="s0">, </span><span class="s1">a] = flatcount[np.newaxis</span><span class="s0">, </span><span class="s1">:]</span>
    <span class="s0">elif </span><span class="s1">statistic </span><span class="s0">in </span><span class="s1">{</span><span class="s2">'sum'</span><span class="s0">, </span><span class="s1">np.sum}:</span>
        <span class="s1">result.fill(</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">vv </span><span class="s0">in </span><span class="s1">builtins.range(Vdim):</span>
            <span class="s1">flatsum = _bincount(binnumbers</span><span class="s0">, </span><span class="s1">values[vv])</span>
            <span class="s1">a = np.arange(len(flatsum))</span>
            <span class="s1">result[vv</span><span class="s0">, </span><span class="s1">a] = flatsum</span>
    <span class="s0">elif </span><span class="s1">statistic </span><span class="s0">in </span><span class="s1">{</span><span class="s2">'median'</span><span class="s0">, </span><span class="s1">np.median}:</span>
        <span class="s1">result.fill(np.nan)</span>
        <span class="s0">for </span><span class="s1">vv </span><span class="s0">in </span><span class="s1">builtins.range(Vdim):</span>
            <span class="s1">i = np.lexsort((values[vv]</span><span class="s0">, </span><span class="s1">binnumbers))</span>
            <span class="s1">_</span><span class="s0">, </span><span class="s1">j</span><span class="s0">, </span><span class="s1">counts = np.unique(binnumbers[i]</span><span class="s0">,</span>
                                     <span class="s1">return_index=</span><span class="s0">True, </span><span class="s1">return_counts=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s1">mid = j + (counts - </span><span class="s3">1</span><span class="s1">) / </span><span class="s3">2</span>
            <span class="s1">mid_a = values[vv</span><span class="s0">, </span><span class="s1">i][np.floor(mid).astype(int)]</span>
            <span class="s1">mid_b = values[vv</span><span class="s0">, </span><span class="s1">i][np.ceil(mid).astype(int)]</span>
            <span class="s1">medians = (mid_a + mid_b) / </span><span class="s3">2</span>
            <span class="s1">result[vv</span><span class="s0">, </span><span class="s1">binnumbers[i][j]] = medians</span>
    <span class="s0">elif </span><span class="s1">statistic </span><span class="s0">in </span><span class="s1">{</span><span class="s2">'min'</span><span class="s0">, </span><span class="s1">np.min}:</span>
        <span class="s1">result.fill(np.nan)</span>
        <span class="s0">for </span><span class="s1">vv </span><span class="s0">in </span><span class="s1">builtins.range(Vdim):</span>
            <span class="s1">i = np.argsort(values[vv])[::-</span><span class="s3">1</span><span class="s1">]  </span><span class="s5"># Reversed so the min is last</span>
            <span class="s1">result[vv</span><span class="s0">, </span><span class="s1">binnumbers[i]] = values[vv</span><span class="s0">, </span><span class="s1">i]</span>
    <span class="s0">elif </span><span class="s1">statistic </span><span class="s0">in </span><span class="s1">{</span><span class="s2">'max'</span><span class="s0">, </span><span class="s1">np.max}:</span>
        <span class="s1">result.fill(np.nan)</span>
        <span class="s0">for </span><span class="s1">vv </span><span class="s0">in </span><span class="s1">builtins.range(Vdim):</span>
            <span class="s1">i = np.argsort(values[vv])</span>
            <span class="s1">result[vv</span><span class="s0">, </span><span class="s1">binnumbers[i]] = values[vv</span><span class="s0">, </span><span class="s1">i]</span>
    <span class="s0">elif </span><span class="s1">callable(statistic):</span>
        <span class="s0">with </span><span class="s1">np.errstate(invalid=</span><span class="s2">'ignore'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(RuntimeWarning)</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">null = statistic([])</span>
            <span class="s0">except </span><span class="s1">Exception:</span>
                <span class="s1">null = np.nan</span>
        <span class="s0">if </span><span class="s1">np.iscomplexobj(null):</span>
            <span class="s1">result = result.astype(np.complex128)</span>
        <span class="s1">result.fill(null)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">_calc_binned_statistic(</span>
                <span class="s1">Vdim</span><span class="s0">, </span><span class="s1">binnumbers</span><span class="s0">, </span><span class="s1">result</span><span class="s0">, </span><span class="s1">values</span><span class="s0">, </span><span class="s1">statistic</span>
            <span class="s1">)</span>
        <span class="s0">except </span><span class="s1">ValueError:</span>
            <span class="s1">result = result.astype(np.complex128)</span>
            <span class="s1">_calc_binned_statistic(</span>
                <span class="s1">Vdim</span><span class="s0">, </span><span class="s1">binnumbers</span><span class="s0">, </span><span class="s1">result</span><span class="s0">, </span><span class="s1">values</span><span class="s0">, </span><span class="s1">statistic</span>
            <span class="s1">)</span>

    <span class="s5"># Shape into a proper matrix</span>
    <span class="s1">result = result.reshape(np.append(Vdim</span><span class="s0">, </span><span class="s1">nbin))</span>

    <span class="s5"># Remove outliers (indices 0 and -1 for each bin-dimension).</span>
    <span class="s1">core = tuple([slice(</span><span class="s0">None</span><span class="s1">)] + Ndim * [slice(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)])</span>
    <span class="s1">result = result[core]</span>

    <span class="s5"># Unravel binnumbers into an ndarray, each row the bins for each dimension</span>
    <span class="s0">if </span><span class="s1">expand_binnumbers </span><span class="s0">and </span><span class="s1">Ndim &gt; </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s1">binnumbers = np.asarray(np.unravel_index(binnumbers</span><span class="s0">, </span><span class="s1">nbin))</span>

    <span class="s0">if </span><span class="s1">np.any(result.shape[</span><span class="s3">1</span><span class="s1">:] != nbin - </span><span class="s3">2</span><span class="s1">):</span>
        <span class="s0">raise </span><span class="s1">RuntimeError(</span><span class="s2">'Internal Shape Error'</span><span class="s1">)</span>

    <span class="s5"># Reshape to have output (`result`) match input (`values`) shape</span>
    <span class="s1">result = result.reshape(input_shape[:-</span><span class="s3">1</span><span class="s1">] + list(nbin-</span><span class="s3">2</span><span class="s1">))</span>

    <span class="s0">return </span><span class="s1">BinnedStatisticddResult(result</span><span class="s0">, </span><span class="s1">edges</span><span class="s0">, </span><span class="s1">binnumbers)</span>


<span class="s0">def </span><span class="s1">_calc_binned_statistic(Vdim</span><span class="s0">, </span><span class="s1">bin_numbers</span><span class="s0">, </span><span class="s1">result</span><span class="s0">, </span><span class="s1">values</span><span class="s0">, </span><span class="s1">stat_func):</span>
    <span class="s1">unique_bin_numbers = np.unique(bin_numbers)</span>
    <span class="s0">for </span><span class="s1">vv </span><span class="s0">in </span><span class="s1">builtins.range(Vdim):</span>
        <span class="s1">bin_map = _create_binned_data(bin_numbers</span><span class="s0">, </span><span class="s1">unique_bin_numbers</span><span class="s0">,</span>
                                      <span class="s1">values</span><span class="s0">, </span><span class="s1">vv)</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">unique_bin_numbers:</span>
            <span class="s1">stat = stat_func(np.array(bin_map[i]))</span>
            <span class="s0">if </span><span class="s1">np.iscomplexobj(stat) </span><span class="s0">and not </span><span class="s1">np.iscomplexobj(result):</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;The statistic function returns complex &quot;</span><span class="s1">)</span>
            <span class="s1">result[vv</span><span class="s0">, </span><span class="s1">i] = stat</span>


<span class="s0">def </span><span class="s1">_create_binned_data(bin_numbers</span><span class="s0">, </span><span class="s1">unique_bin_numbers</span><span class="s0">, </span><span class="s1">values</span><span class="s0">, </span><span class="s1">vv):</span>
    <span class="s4">&quot;&quot;&quot; Create hashmap of bin ids to values in bins 
    key: bin number 
    value: list of binned data 
    &quot;&quot;&quot;</span>
    <span class="s1">bin_map = dict()</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">unique_bin_numbers:</span>
        <span class="s1">bin_map[i] = []</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">builtins.range(len(bin_numbers)):</span>
        <span class="s1">bin_map[bin_numbers[i]].append(values[vv</span><span class="s0">, </span><span class="s1">i])</span>
    <span class="s0">return </span><span class="s1">bin_map</span>


<span class="s0">def </span><span class="s1">_bin_edges(sample</span><span class="s0">, </span><span class="s1">bins=</span><span class="s0">None, </span><span class="s1">range=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot; Create edge arrays 
    &quot;&quot;&quot;</span>
    <span class="s1">Dlen</span><span class="s0">, </span><span class="s1">Ndim = sample.shape</span>

    <span class="s1">nbin = np.empty(Ndim</span><span class="s0">, </span><span class="s1">int)    </span><span class="s5"># Number of bins in each dimension</span>
    <span class="s1">edges = Ndim * [</span><span class="s0">None</span><span class="s1">]         </span><span class="s5"># Bin edges for each dim (will be 2D array)</span>
    <span class="s1">dedges = Ndim * [</span><span class="s0">None</span><span class="s1">]        </span><span class="s5"># Spacing between edges (will be 2D array)</span>

    <span class="s5"># Select range for each dimension</span>
    <span class="s5"># Used only if number of bins is given.</span>
    <span class="s0">if </span><span class="s1">range </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">smin = np.atleast_1d(np.array(sample.min(axis=</span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">float))</span>
        <span class="s1">smax = np.atleast_1d(np.array(sample.max(axis=</span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">float))</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">len(range) != Ndim:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s2">f&quot;range given for </span><span class="s0">{</span><span class="s1">len(range)</span><span class="s0">} </span><span class="s2">dimensions; </span><span class="s0">{</span><span class="s1">Ndim</span><span class="s0">} </span><span class="s2">required&quot;</span><span class="s1">)</span>
        <span class="s1">smin = np.empty(Ndim)</span>
        <span class="s1">smax = np.empty(Ndim)</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">builtins.range(Ndim):</span>
            <span class="s0">if </span><span class="s1">range[i][</span><span class="s3">1</span><span class="s1">] &lt; range[i][</span><span class="s3">0</span><span class="s1">]:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span>
                    <span class="s2">&quot;In {}range, start must be &lt;= stop&quot;</span><span class="s1">.format(</span>
                        <span class="s2">f&quot;dimension </span><span class="s0">{</span><span class="s1">i + </span><span class="s3">1</span><span class="s0">} </span><span class="s2">of &quot; </span><span class="s0">if </span><span class="s1">Ndim &gt; </span><span class="s3">1 </span><span class="s0">else </span><span class="s2">&quot;&quot;</span><span class="s1">))</span>
            <span class="s1">smin[i]</span><span class="s0">, </span><span class="s1">smax[i] = range[i]</span>

    <span class="s5"># Make sure the bins have a finite width.</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">builtins.range(len(smin)):</span>
        <span class="s0">if </span><span class="s1">smin[i] == smax[i]:</span>
            <span class="s1">smin[i] = smin[i] - </span><span class="s3">.5</span>
            <span class="s1">smax[i] = smax[i] + </span><span class="s3">.5</span>

    <span class="s5"># Preserve sample floating point precision in bin edges</span>
    <span class="s1">edges_dtype = (sample.dtype </span><span class="s0">if </span><span class="s1">np.issubdtype(sample.dtype</span><span class="s0">, </span><span class="s1">np.floating)</span>
                   <span class="s0">else </span><span class="s1">float)</span>

    <span class="s5"># Create edge arrays</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">builtins.range(Ndim):</span>
        <span class="s0">if </span><span class="s1">np.isscalar(bins[i]):</span>
            <span class="s1">nbin[i] = bins[i] + </span><span class="s3">2  </span><span class="s5"># +2 for outlier bins</span>
            <span class="s1">edges[i] = np.linspace(smin[i]</span><span class="s0">, </span><span class="s1">smax[i]</span><span class="s0">, </span><span class="s1">nbin[i] - </span><span class="s3">1</span><span class="s0">,</span>
                                   <span class="s1">dtype=edges_dtype)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">edges[i] = np.asarray(bins[i]</span><span class="s0">, </span><span class="s1">edges_dtype)</span>
            <span class="s1">nbin[i] = len(edges[i]) + </span><span class="s3">1  </span><span class="s5"># +1 for outlier bins</span>
        <span class="s1">dedges[i] = np.diff(edges[i])</span>

    <span class="s1">nbin = np.asarray(nbin)</span>

    <span class="s0">return </span><span class="s1">nbin</span><span class="s0">, </span><span class="s1">edges</span><span class="s0">, </span><span class="s1">dedges</span>


<span class="s0">def </span><span class="s1">_bin_numbers(sample</span><span class="s0">, </span><span class="s1">nbin</span><span class="s0">, </span><span class="s1">edges</span><span class="s0">, </span><span class="s1">dedges):</span>
    <span class="s4">&quot;&quot;&quot;Compute the bin number each sample falls into, in each dimension 
    &quot;&quot;&quot;</span>
    <span class="s1">Dlen</span><span class="s0">, </span><span class="s1">Ndim = sample.shape</span>

    <span class="s1">sampBin = [</span>
        <span class="s1">np.digitize(sample[:</span><span class="s0">, </span><span class="s1">i]</span><span class="s0">, </span><span class="s1">edges[i])</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(Ndim)</span>
    <span class="s1">]</span>

    <span class="s5"># Using `digitize`, values that fall on an edge are put in the right bin.</span>
    <span class="s5"># For the rightmost bin, we want values equal to the right</span>
    <span class="s5"># edge to be counted in the last bin, and not as an outlier.</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(Ndim):</span>
        <span class="s5"># Find the rounding precision</span>
        <span class="s1">dedges_min = dedges[i].min()</span>
        <span class="s0">if </span><span class="s1">dedges_min == </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">'The smallest edge difference is numerically 0.'</span><span class="s1">)</span>
        <span class="s1">decimal = int(-np.log10(dedges_min)) + </span><span class="s3">6</span>
        <span class="s5"># Find which points are on the rightmost edge.</span>
        <span class="s1">on_edge = np.where((sample[:</span><span class="s0">, </span><span class="s1">i] &gt;= edges[i][-</span><span class="s3">1</span><span class="s1">]) &amp;</span>
                           <span class="s1">(np.around(sample[:</span><span class="s0">, </span><span class="s1">i]</span><span class="s0">, </span><span class="s1">decimal) ==</span>
                            <span class="s1">np.around(edges[i][-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">decimal)))[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s5"># Shift these points one bin to the left.</span>
        <span class="s1">sampBin[i][on_edge] -= </span><span class="s3">1</span>

    <span class="s5"># Compute the sample indices in the flattened statistic matrix.</span>
    <span class="s1">binnumbers = np.ravel_multi_index(sampBin</span><span class="s0">, </span><span class="s1">nbin)</span>

    <span class="s0">return </span><span class="s1">binnumbers</span>
</pre>
</body>
</html>