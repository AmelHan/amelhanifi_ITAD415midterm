<html>
<head>
<title>_idl.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_idl.py</font>
</center></td></tr></table>
<pre><span class="s0"># IDLSave - a python module to read IDL 'save' files</span>
<span class="s0"># Copyright (c) 2010 Thomas P. Robitaille</span>

<span class="s0"># Many thanks to Craig Markwardt for publishing the Unofficial Format</span>
<span class="s0"># Specification for IDL .sav files, without which this Python module would not</span>
<span class="s0"># exist (http://cow.physics.wisc.edu/~craigm/idl/savefmt).</span>

<span class="s0"># This code was developed by with permission from ITT Visual Information</span>
<span class="s0"># Systems. IDL(r) is a registered trademark of ITT Visual Information Systems,</span>
<span class="s0"># Inc. for their Interactive Data Language software.</span>

<span class="s0"># Permission is hereby granted, free of charge, to any person obtaining a</span>
<span class="s0"># copy of this software and associated documentation files (the &quot;Software&quot;),</span>
<span class="s0"># to deal in the Software without restriction, including without limitation</span>
<span class="s0"># the rights to use, copy, modify, merge, publish, distribute, sublicense,</span>
<span class="s0"># and/or sell copies of the Software, and to permit persons to whom the</span>
<span class="s0"># Software is furnished to do so, subject to the following conditions:</span>

<span class="s0"># The above copyright notice and this permission notice shall be included in</span>
<span class="s0"># all copies or substantial portions of the Software.</span>

<span class="s0"># THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="s0"># IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="s0"># FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span>
<span class="s0"># AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
<span class="s0"># LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING</span>
<span class="s0"># FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER</span>
<span class="s0"># DEALINGS IN THE SOFTWARE.</span>

<span class="s1">__all__ = [</span><span class="s2">'readsav'</span><span class="s1">]</span>

<span class="s3">import </span><span class="s1">struct</span>
<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">import </span><span class="s1">tempfile</span>
<span class="s3">import </span><span class="s1">zlib</span>
<span class="s3">import </span><span class="s1">warnings</span>

<span class="s0"># Define the different data types that can be found in an IDL save file</span>
<span class="s1">DTYPE_DICT = {</span><span class="s4">1</span><span class="s1">: </span><span class="s2">'&gt;u1'</span><span class="s3">,</span>
              <span class="s4">2</span><span class="s1">: </span><span class="s2">'&gt;i2'</span><span class="s3">,</span>
              <span class="s4">3</span><span class="s1">: </span><span class="s2">'&gt;i4'</span><span class="s3">,</span>
              <span class="s4">4</span><span class="s1">: </span><span class="s2">'&gt;f4'</span><span class="s3">,</span>
              <span class="s4">5</span><span class="s1">: </span><span class="s2">'&gt;f8'</span><span class="s3">,</span>
              <span class="s4">6</span><span class="s1">: </span><span class="s2">'&gt;c8'</span><span class="s3">,</span>
              <span class="s4">7</span><span class="s1">: </span><span class="s2">'|O'</span><span class="s3">,</span>
              <span class="s4">8</span><span class="s1">: </span><span class="s2">'|O'</span><span class="s3">,</span>
              <span class="s4">9</span><span class="s1">: </span><span class="s2">'&gt;c16'</span><span class="s3">,</span>
              <span class="s4">10</span><span class="s1">: </span><span class="s2">'|O'</span><span class="s3">,</span>
              <span class="s4">11</span><span class="s1">: </span><span class="s2">'|O'</span><span class="s3">,</span>
              <span class="s4">12</span><span class="s1">: </span><span class="s2">'&gt;u2'</span><span class="s3">,</span>
              <span class="s4">13</span><span class="s1">: </span><span class="s2">'&gt;u4'</span><span class="s3">,</span>
              <span class="s4">14</span><span class="s1">: </span><span class="s2">'&gt;i8'</span><span class="s3">,</span>
              <span class="s4">15</span><span class="s1">: </span><span class="s2">'&gt;u8'</span><span class="s1">}</span>

<span class="s0"># Define the different record types that can be found in an IDL save file</span>
<span class="s1">RECTYPE_DICT = {</span><span class="s4">0</span><span class="s1">: </span><span class="s2">&quot;START_MARKER&quot;</span><span class="s3">,</span>
                <span class="s4">1</span><span class="s1">: </span><span class="s2">&quot;COMMON_VARIABLE&quot;</span><span class="s3">,</span>
                <span class="s4">2</span><span class="s1">: </span><span class="s2">&quot;VARIABLE&quot;</span><span class="s3">,</span>
                <span class="s4">3</span><span class="s1">: </span><span class="s2">&quot;SYSTEM_VARIABLE&quot;</span><span class="s3">,</span>
                <span class="s4">6</span><span class="s1">: </span><span class="s2">&quot;END_MARKER&quot;</span><span class="s3">,</span>
                <span class="s4">10</span><span class="s1">: </span><span class="s2">&quot;TIMESTAMP&quot;</span><span class="s3">,</span>
                <span class="s4">12</span><span class="s1">: </span><span class="s2">&quot;COMPILED&quot;</span><span class="s3">,</span>
                <span class="s4">13</span><span class="s1">: </span><span class="s2">&quot;IDENTIFICATION&quot;</span><span class="s3">,</span>
                <span class="s4">14</span><span class="s1">: </span><span class="s2">&quot;VERSION&quot;</span><span class="s3">,</span>
                <span class="s4">15</span><span class="s1">: </span><span class="s2">&quot;HEAP_HEADER&quot;</span><span class="s3">,</span>
                <span class="s4">16</span><span class="s1">: </span><span class="s2">&quot;HEAP_DATA&quot;</span><span class="s3">,</span>
                <span class="s4">17</span><span class="s1">: </span><span class="s2">&quot;PROMOTE64&quot;</span><span class="s3">,</span>
                <span class="s4">19</span><span class="s1">: </span><span class="s2">&quot;NOTICE&quot;</span><span class="s3">,</span>
                <span class="s4">20</span><span class="s1">: </span><span class="s2">&quot;DESCRIPTION&quot;</span><span class="s1">}</span>

<span class="s0"># Define a dictionary to contain structure definitions</span>
<span class="s1">STRUCT_DICT = {}</span>


<span class="s3">def </span><span class="s1">_align_32(f):</span>
    <span class="s5">'''Align to the next 32-bit position in a file'''</span>

    <span class="s1">pos = f.tell()</span>
    <span class="s3">if </span><span class="s1">pos % </span><span class="s4">4 </span><span class="s1">!= </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">f.seek(pos + </span><span class="s4">4 </span><span class="s1">- pos % </span><span class="s4">4</span><span class="s1">)</span>
    <span class="s3">return</span>


<span class="s3">def </span><span class="s1">_skip_bytes(f</span><span class="s3">, </span><span class="s1">n):</span>
    <span class="s5">'''Skip `n` bytes'''</span>
    <span class="s1">f.read(n)</span>
    <span class="s3">return</span>


<span class="s3">def </span><span class="s1">_read_bytes(f</span><span class="s3">, </span><span class="s1">n):</span>
    <span class="s5">'''Read the next `n` bytes'''</span>
    <span class="s3">return </span><span class="s1">f.read(n)</span>


<span class="s3">def </span><span class="s1">_read_byte(f):</span>
    <span class="s5">'''Read a single byte'''</span>
    <span class="s3">return </span><span class="s1">np.uint8(struct.unpack(</span><span class="s2">'&gt;B'</span><span class="s3">, </span><span class="s1">f.read(</span><span class="s4">4</span><span class="s1">)[:</span><span class="s4">1</span><span class="s1">])[</span><span class="s4">0</span><span class="s1">])</span>


<span class="s3">def </span><span class="s1">_read_long(f):</span>
    <span class="s5">'''Read a signed 32-bit integer'''</span>
    <span class="s3">return </span><span class="s1">np.int32(struct.unpack(</span><span class="s2">'&gt;l'</span><span class="s3">, </span><span class="s1">f.read(</span><span class="s4">4</span><span class="s1">))[</span><span class="s4">0</span><span class="s1">])</span>


<span class="s3">def </span><span class="s1">_read_int16(f):</span>
    <span class="s5">'''Read a signed 16-bit integer'''</span>
    <span class="s3">return </span><span class="s1">np.int16(struct.unpack(</span><span class="s2">'&gt;h'</span><span class="s3">, </span><span class="s1">f.read(</span><span class="s4">4</span><span class="s1">)[</span><span class="s4">2</span><span class="s1">:</span><span class="s4">4</span><span class="s1">])[</span><span class="s4">0</span><span class="s1">])</span>


<span class="s3">def </span><span class="s1">_read_int32(f):</span>
    <span class="s5">'''Read a signed 32-bit integer'''</span>
    <span class="s3">return </span><span class="s1">np.int32(struct.unpack(</span><span class="s2">'&gt;i'</span><span class="s3">, </span><span class="s1">f.read(</span><span class="s4">4</span><span class="s1">))[</span><span class="s4">0</span><span class="s1">])</span>


<span class="s3">def </span><span class="s1">_read_int64(f):</span>
    <span class="s5">'''Read a signed 64-bit integer'''</span>
    <span class="s3">return </span><span class="s1">np.int64(struct.unpack(</span><span class="s2">'&gt;q'</span><span class="s3">, </span><span class="s1">f.read(</span><span class="s4">8</span><span class="s1">))[</span><span class="s4">0</span><span class="s1">])</span>


<span class="s3">def </span><span class="s1">_read_uint16(f):</span>
    <span class="s5">'''Read an unsigned 16-bit integer'''</span>
    <span class="s3">return </span><span class="s1">np.uint16(struct.unpack(</span><span class="s2">'&gt;H'</span><span class="s3">, </span><span class="s1">f.read(</span><span class="s4">4</span><span class="s1">)[</span><span class="s4">2</span><span class="s1">:</span><span class="s4">4</span><span class="s1">])[</span><span class="s4">0</span><span class="s1">])</span>


<span class="s3">def </span><span class="s1">_read_uint32(f):</span>
    <span class="s5">'''Read an unsigned 32-bit integer'''</span>
    <span class="s3">return </span><span class="s1">np.uint32(struct.unpack(</span><span class="s2">'&gt;I'</span><span class="s3">, </span><span class="s1">f.read(</span><span class="s4">4</span><span class="s1">))[</span><span class="s4">0</span><span class="s1">])</span>


<span class="s3">def </span><span class="s1">_read_uint64(f):</span>
    <span class="s5">'''Read an unsigned 64-bit integer'''</span>
    <span class="s3">return </span><span class="s1">np.uint64(struct.unpack(</span><span class="s2">'&gt;Q'</span><span class="s3">, </span><span class="s1">f.read(</span><span class="s4">8</span><span class="s1">))[</span><span class="s4">0</span><span class="s1">])</span>


<span class="s3">def </span><span class="s1">_read_float32(f):</span>
    <span class="s5">'''Read a 32-bit float'''</span>
    <span class="s3">return </span><span class="s1">np.float32(struct.unpack(</span><span class="s2">'&gt;f'</span><span class="s3">, </span><span class="s1">f.read(</span><span class="s4">4</span><span class="s1">))[</span><span class="s4">0</span><span class="s1">])</span>


<span class="s3">def </span><span class="s1">_read_float64(f):</span>
    <span class="s5">'''Read a 64-bit float'''</span>
    <span class="s3">return </span><span class="s1">np.float64(struct.unpack(</span><span class="s2">'&gt;d'</span><span class="s3">, </span><span class="s1">f.read(</span><span class="s4">8</span><span class="s1">))[</span><span class="s4">0</span><span class="s1">])</span>


<span class="s3">class </span><span class="s1">Pointer:</span>
    <span class="s5">'''Class used to define pointers'''</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">index):</span>
        <span class="s1">self.index = index</span>
        <span class="s3">return</span>


<span class="s3">class </span><span class="s1">ObjectPointer(Pointer):</span>
    <span class="s5">'''Class used to define object pointers'''</span>
    <span class="s3">pass</span>


<span class="s3">def </span><span class="s1">_read_string(f):</span>
    <span class="s5">'''Read a string'''</span>
    <span class="s1">length = _read_long(f)</span>
    <span class="s3">if </span><span class="s1">length &gt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">chars = _read_bytes(f</span><span class="s3">, </span><span class="s1">length).decode(</span><span class="s2">'latin1'</span><span class="s1">)</span>
        <span class="s1">_align_32(f)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">chars = </span><span class="s2">''</span>
    <span class="s3">return </span><span class="s1">chars</span>


<span class="s3">def </span><span class="s1">_read_string_data(f):</span>
    <span class="s5">'''Read a data string (length is specified twice)'''</span>
    <span class="s1">length = _read_long(f)</span>
    <span class="s3">if </span><span class="s1">length &gt; </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s1">length = _read_long(f)</span>
        <span class="s1">string_data = _read_bytes(f</span><span class="s3">, </span><span class="s1">length)</span>
        <span class="s1">_align_32(f)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">string_data = </span><span class="s2">''</span>
    <span class="s3">return </span><span class="s1">string_data</span>


<span class="s3">def </span><span class="s1">_read_data(f</span><span class="s3">, </span><span class="s1">dtype):</span>
    <span class="s5">'''Read a variable with a specified data type'''</span>
    <span class="s3">if </span><span class="s1">dtype == </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">_read_int32(f) != </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">Exception(</span><span class="s2">&quot;Error occurred while reading byte variable&quot;</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">_read_byte(f)</span>
    <span class="s3">elif </span><span class="s1">dtype == </span><span class="s4">2</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">_read_int16(f)</span>
    <span class="s3">elif </span><span class="s1">dtype == </span><span class="s4">3</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">_read_int32(f)</span>
    <span class="s3">elif </span><span class="s1">dtype == </span><span class="s4">4</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">_read_float32(f)</span>
    <span class="s3">elif </span><span class="s1">dtype == </span><span class="s4">5</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">_read_float64(f)</span>
    <span class="s3">elif </span><span class="s1">dtype == </span><span class="s4">6</span><span class="s1">:</span>
        <span class="s1">real = _read_float32(f)</span>
        <span class="s1">imag = _read_float32(f)</span>
        <span class="s3">return </span><span class="s1">np.complex64(real + imag * </span><span class="s4">1j</span><span class="s1">)</span>
    <span class="s3">elif </span><span class="s1">dtype == </span><span class="s4">7</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">_read_string_data(f)</span>
    <span class="s3">elif </span><span class="s1">dtype == </span><span class="s4">8</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">Exception(</span><span class="s2">&quot;Should not be here - please report this&quot;</span><span class="s1">)</span>
    <span class="s3">elif </span><span class="s1">dtype == </span><span class="s4">9</span><span class="s1">:</span>
        <span class="s1">real = _read_float64(f)</span>
        <span class="s1">imag = _read_float64(f)</span>
        <span class="s3">return </span><span class="s1">np.complex128(real + imag * </span><span class="s4">1j</span><span class="s1">)</span>
    <span class="s3">elif </span><span class="s1">dtype == </span><span class="s4">10</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">Pointer(_read_int32(f))</span>
    <span class="s3">elif </span><span class="s1">dtype == </span><span class="s4">11</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">ObjectPointer(_read_int32(f))</span>
    <span class="s3">elif </span><span class="s1">dtype == </span><span class="s4">12</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">_read_uint16(f)</span>
    <span class="s3">elif </span><span class="s1">dtype == </span><span class="s4">13</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">_read_uint32(f)</span>
    <span class="s3">elif </span><span class="s1">dtype == </span><span class="s4">14</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">_read_int64(f)</span>
    <span class="s3">elif </span><span class="s1">dtype == </span><span class="s4">15</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">_read_uint64(f)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">Exception(</span><span class="s2">&quot;Unknown IDL type: %i - please report this&quot; </span><span class="s1">% dtype)</span>


<span class="s3">def </span><span class="s1">_read_structure(f</span><span class="s3">, </span><span class="s1">array_desc</span><span class="s3">, </span><span class="s1">struct_desc):</span>
    <span class="s5">''' 
    Read a structure, with the array and structure descriptors given as 
    `array_desc` and `structure_desc` respectively. 
    '''</span>

    <span class="s1">nrows = array_desc[</span><span class="s2">'nelements'</span><span class="s1">]</span>
    <span class="s1">columns = struct_desc[</span><span class="s2">'tagtable'</span><span class="s1">]</span>

    <span class="s1">dtype = []</span>
    <span class="s3">for </span><span class="s1">col </span><span class="s3">in </span><span class="s1">columns:</span>
        <span class="s3">if </span><span class="s1">col[</span><span class="s2">'structure'</span><span class="s1">] </span><span class="s3">or </span><span class="s1">col[</span><span class="s2">'array'</span><span class="s1">]:</span>
            <span class="s1">dtype.append(((col[</span><span class="s2">'name'</span><span class="s1">].lower()</span><span class="s3">, </span><span class="s1">col[</span><span class="s2">'name'</span><span class="s1">])</span><span class="s3">, </span><span class="s1">np.object_))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">col[</span><span class="s2">'typecode'</span><span class="s1">] </span><span class="s3">in </span><span class="s1">DTYPE_DICT:</span>
                <span class="s1">dtype.append(((col[</span><span class="s2">'name'</span><span class="s1">].lower()</span><span class="s3">, </span><span class="s1">col[</span><span class="s2">'name'</span><span class="s1">])</span><span class="s3">,</span>
                                    <span class="s1">DTYPE_DICT[col[</span><span class="s2">'typecode'</span><span class="s1">]]))</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">Exception(</span><span class="s2">&quot;Variable type %i not implemented&quot; </span><span class="s1">%</span>
                                                            <span class="s1">col[</span><span class="s2">'typecode'</span><span class="s1">])</span>

    <span class="s1">structure = np.recarray((nrows</span><span class="s3">, </span><span class="s1">)</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>

    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(nrows):</span>
        <span class="s3">for </span><span class="s1">col </span><span class="s3">in </span><span class="s1">columns:</span>
            <span class="s1">dtype = col[</span><span class="s2">'typecode'</span><span class="s1">]</span>
            <span class="s3">if </span><span class="s1">col[</span><span class="s2">'structure'</span><span class="s1">]:</span>
                <span class="s1">structure[col[</span><span class="s2">'name'</span><span class="s1">]][i] = _read_structure(f</span><span class="s3">,</span>
                                      <span class="s1">struct_desc[</span><span class="s2">'arrtable'</span><span class="s1">][col[</span><span class="s2">'name'</span><span class="s1">]]</span><span class="s3">,</span>
                                      <span class="s1">struct_desc[</span><span class="s2">'structtable'</span><span class="s1">][col[</span><span class="s2">'name'</span><span class="s1">]])</span>
            <span class="s3">elif </span><span class="s1">col[</span><span class="s2">'array'</span><span class="s1">]:</span>
                <span class="s1">structure[col[</span><span class="s2">'name'</span><span class="s1">]][i] = _read_array(f</span><span class="s3">, </span><span class="s1">dtype</span><span class="s3">,</span>
                                      <span class="s1">struct_desc[</span><span class="s2">'arrtable'</span><span class="s1">][col[</span><span class="s2">'name'</span><span class="s1">]])</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">structure[col[</span><span class="s2">'name'</span><span class="s1">]][i] = _read_data(f</span><span class="s3">, </span><span class="s1">dtype)</span>

    <span class="s0"># Reshape structure if needed</span>
    <span class="s3">if </span><span class="s1">array_desc[</span><span class="s2">'ndims'</span><span class="s1">] &gt; </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">dims = array_desc[</span><span class="s2">'dims'</span><span class="s1">][:int(array_desc[</span><span class="s2">'ndims'</span><span class="s1">])]</span>
        <span class="s1">dims.reverse()</span>
        <span class="s1">structure = structure.reshape(dims)</span>

    <span class="s3">return </span><span class="s1">structure</span>


<span class="s3">def </span><span class="s1">_read_array(f</span><span class="s3">, </span><span class="s1">typecode</span><span class="s3">, </span><span class="s1">array_desc):</span>
    <span class="s5">''' 
    Read an array of type `typecode`, with the array descriptor given as 
    `array_desc`. 
    '''</span>

    <span class="s3">if </span><span class="s1">typecode </span><span class="s3">in </span><span class="s1">[</span><span class="s4">1</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">4</span><span class="s3">, </span><span class="s4">5</span><span class="s3">, </span><span class="s4">6</span><span class="s3">, </span><span class="s4">9</span><span class="s3">, </span><span class="s4">13</span><span class="s3">, </span><span class="s4">14</span><span class="s3">, </span><span class="s4">15</span><span class="s1">]:</span>

        <span class="s3">if </span><span class="s1">typecode == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">nbytes = _read_int32(f)</span>
            <span class="s3">if </span><span class="s1">nbytes != array_desc[</span><span class="s2">'nbytes'</span><span class="s1">]:</span>
                <span class="s1">warnings.warn(</span><span class="s2">&quot;Not able to verify number of bytes from header&quot;</span><span class="s1">)</span>

        <span class="s0"># Read bytes as numpy array</span>
        <span class="s1">array = np.frombuffer(f.read(array_desc[</span><span class="s2">'nbytes'</span><span class="s1">])</span><span class="s3">,</span>
                              <span class="s1">dtype=DTYPE_DICT[typecode])</span>

    <span class="s3">elif </span><span class="s1">typecode </span><span class="s3">in </span><span class="s1">[</span><span class="s4">2</span><span class="s3">, </span><span class="s4">12</span><span class="s1">]:</span>

        <span class="s0"># These are 2 byte types, need to skip every two as they are not packed</span>

        <span class="s1">array = np.frombuffer(f.read(array_desc[</span><span class="s2">'nbytes'</span><span class="s1">]*</span><span class="s4">2</span><span class="s1">)</span><span class="s3">,</span>
                              <span class="s1">dtype=DTYPE_DICT[typecode])[</span><span class="s4">1</span><span class="s1">::</span><span class="s4">2</span><span class="s1">]</span>

    <span class="s3">else</span><span class="s1">:</span>

        <span class="s0"># Read bytes into list</span>
        <span class="s1">array = []</span>
        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(array_desc[</span><span class="s2">'nelements'</span><span class="s1">]):</span>
            <span class="s1">dtype = typecode</span>
            <span class="s1">data = _read_data(f</span><span class="s3">, </span><span class="s1">dtype)</span>
            <span class="s1">array.append(data)</span>

        <span class="s1">array = np.array(array</span><span class="s3">, </span><span class="s1">dtype=np.object_)</span>

    <span class="s0"># Reshape array if needed</span>
    <span class="s3">if </span><span class="s1">array_desc[</span><span class="s2">'ndims'</span><span class="s1">] &gt; </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">dims = array_desc[</span><span class="s2">'dims'</span><span class="s1">][:int(array_desc[</span><span class="s2">'ndims'</span><span class="s1">])]</span>
        <span class="s1">dims.reverse()</span>
        <span class="s1">array = array.reshape(dims)</span>

    <span class="s0"># Go to next alignment position</span>
    <span class="s1">_align_32(f)</span>

    <span class="s3">return </span><span class="s1">array</span>


<span class="s3">def </span><span class="s1">_read_record(f):</span>
    <span class="s5">'''Function to read in a full record'''</span>

    <span class="s1">record = {</span><span class="s2">'rectype'</span><span class="s1">: _read_long(f)}</span>

    <span class="s1">nextrec = _read_uint32(f)</span>
    <span class="s1">nextrec += _read_uint32(f) * </span><span class="s4">2</span><span class="s1">**</span><span class="s4">32</span>

    <span class="s1">_skip_bytes(f</span><span class="s3">, </span><span class="s4">4</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">record[</span><span class="s2">'rectype'</span><span class="s1">] </span><span class="s3">not in </span><span class="s1">RECTYPE_DICT:</span>
        <span class="s3">raise </span><span class="s1">Exception(</span><span class="s2">&quot;Unknown RECTYPE: %i&quot; </span><span class="s1">% record[</span><span class="s2">'rectype'</span><span class="s1">])</span>

    <span class="s1">record[</span><span class="s2">'rectype'</span><span class="s1">] = RECTYPE_DICT[record[</span><span class="s2">'rectype'</span><span class="s1">]]</span>

    <span class="s3">if </span><span class="s1">record[</span><span class="s2">'rectype'</span><span class="s1">] </span><span class="s3">in </span><span class="s1">[</span><span class="s2">&quot;VARIABLE&quot;</span><span class="s3">, </span><span class="s2">&quot;HEAP_DATA&quot;</span><span class="s1">]:</span>

        <span class="s3">if </span><span class="s1">record[</span><span class="s2">'rectype'</span><span class="s1">] == </span><span class="s2">&quot;VARIABLE&quot;</span><span class="s1">:</span>
            <span class="s1">record[</span><span class="s2">'varname'</span><span class="s1">] = _read_string(f)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">record[</span><span class="s2">'heap_index'</span><span class="s1">] = _read_long(f)</span>
            <span class="s1">_skip_bytes(f</span><span class="s3">, </span><span class="s4">4</span><span class="s1">)</span>

        <span class="s1">rectypedesc = _read_typedesc(f)</span>

        <span class="s3">if </span><span class="s1">rectypedesc[</span><span class="s2">'typecode'</span><span class="s1">] == </span><span class="s4">0</span><span class="s1">:</span>

            <span class="s3">if </span><span class="s1">nextrec == f.tell():</span>
                <span class="s1">record[</span><span class="s2">'data'</span><span class="s1">] = </span><span class="s3">None  </span><span class="s0"># Indicates NULL value</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Unexpected type code: 0&quot;</span><span class="s1">)</span>

        <span class="s3">else</span><span class="s1">:</span>

            <span class="s1">varstart = _read_long(f)</span>
            <span class="s3">if </span><span class="s1">varstart != </span><span class="s4">7</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">Exception(</span><span class="s2">&quot;VARSTART is not 7&quot;</span><span class="s1">)</span>

            <span class="s3">if </span><span class="s1">rectypedesc[</span><span class="s2">'structure'</span><span class="s1">]:</span>
                <span class="s1">record[</span><span class="s2">'data'</span><span class="s1">] = _read_structure(f</span><span class="s3">, </span><span class="s1">rectypedesc[</span><span class="s2">'array_desc'</span><span class="s1">]</span><span class="s3">,</span>
                                                    <span class="s1">rectypedesc[</span><span class="s2">'struct_desc'</span><span class="s1">])</span>
            <span class="s3">elif </span><span class="s1">rectypedesc[</span><span class="s2">'array'</span><span class="s1">]:</span>
                <span class="s1">record[</span><span class="s2">'data'</span><span class="s1">] = _read_array(f</span><span class="s3">, </span><span class="s1">rectypedesc[</span><span class="s2">'typecode'</span><span class="s1">]</span><span class="s3">,</span>
                                                <span class="s1">rectypedesc[</span><span class="s2">'array_desc'</span><span class="s1">])</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">dtype = rectypedesc[</span><span class="s2">'typecode'</span><span class="s1">]</span>
                <span class="s1">record[</span><span class="s2">'data'</span><span class="s1">] = _read_data(f</span><span class="s3">, </span><span class="s1">dtype)</span>

    <span class="s3">elif </span><span class="s1">record[</span><span class="s2">'rectype'</span><span class="s1">] == </span><span class="s2">&quot;TIMESTAMP&quot;</span><span class="s1">:</span>

        <span class="s1">_skip_bytes(f</span><span class="s3">, </span><span class="s4">4</span><span class="s1">*</span><span class="s4">256</span><span class="s1">)</span>
        <span class="s1">record[</span><span class="s2">'date'</span><span class="s1">] = _read_string(f)</span>
        <span class="s1">record[</span><span class="s2">'user'</span><span class="s1">] = _read_string(f)</span>
        <span class="s1">record[</span><span class="s2">'host'</span><span class="s1">] = _read_string(f)</span>

    <span class="s3">elif </span><span class="s1">record[</span><span class="s2">'rectype'</span><span class="s1">] == </span><span class="s2">&quot;VERSION&quot;</span><span class="s1">:</span>

        <span class="s1">record[</span><span class="s2">'format'</span><span class="s1">] = _read_long(f)</span>
        <span class="s1">record[</span><span class="s2">'arch'</span><span class="s1">] = _read_string(f)</span>
        <span class="s1">record[</span><span class="s2">'os'</span><span class="s1">] = _read_string(f)</span>
        <span class="s1">record[</span><span class="s2">'release'</span><span class="s1">] = _read_string(f)</span>

    <span class="s3">elif </span><span class="s1">record[</span><span class="s2">'rectype'</span><span class="s1">] == </span><span class="s2">&quot;IDENTIFICATON&quot;</span><span class="s1">:</span>

        <span class="s1">record[</span><span class="s2">'author'</span><span class="s1">] = _read_string(f)</span>
        <span class="s1">record[</span><span class="s2">'title'</span><span class="s1">] = _read_string(f)</span>
        <span class="s1">record[</span><span class="s2">'idcode'</span><span class="s1">] = _read_string(f)</span>

    <span class="s3">elif </span><span class="s1">record[</span><span class="s2">'rectype'</span><span class="s1">] == </span><span class="s2">&quot;NOTICE&quot;</span><span class="s1">:</span>

        <span class="s1">record[</span><span class="s2">'notice'</span><span class="s1">] = _read_string(f)</span>

    <span class="s3">elif </span><span class="s1">record[</span><span class="s2">'rectype'</span><span class="s1">] == </span><span class="s2">&quot;DESCRIPTION&quot;</span><span class="s1">:</span>

        <span class="s1">record[</span><span class="s2">'description'</span><span class="s1">] = _read_string_data(f)</span>

    <span class="s3">elif </span><span class="s1">record[</span><span class="s2">'rectype'</span><span class="s1">] == </span><span class="s2">&quot;HEAP_HEADER&quot;</span><span class="s1">:</span>

        <span class="s1">record[</span><span class="s2">'nvalues'</span><span class="s1">] = _read_long(f)</span>
        <span class="s1">record[</span><span class="s2">'indices'</span><span class="s1">] = [_read_long(f) </span><span class="s3">for </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">range(record[</span><span class="s2">'nvalues'</span><span class="s1">])]</span>

    <span class="s3">elif </span><span class="s1">record[</span><span class="s2">'rectype'</span><span class="s1">] == </span><span class="s2">&quot;COMMONBLOCK&quot;</span><span class="s1">:</span>

        <span class="s1">record[</span><span class="s2">'nvars'</span><span class="s1">] = _read_long(f)</span>
        <span class="s1">record[</span><span class="s2">'name'</span><span class="s1">] = _read_string(f)</span>
        <span class="s1">record[</span><span class="s2">'varnames'</span><span class="s1">] = [_read_string(f) </span><span class="s3">for </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">range(record[</span><span class="s2">'nvars'</span><span class="s1">])]</span>

    <span class="s3">elif </span><span class="s1">record[</span><span class="s2">'rectype'</span><span class="s1">] == </span><span class="s2">&quot;END_MARKER&quot;</span><span class="s1">:</span>

        <span class="s1">record[</span><span class="s2">'end'</span><span class="s1">] = </span><span class="s3">True</span>

    <span class="s3">elif </span><span class="s1">record[</span><span class="s2">'rectype'</span><span class="s1">] == </span><span class="s2">&quot;UNKNOWN&quot;</span><span class="s1">:</span>

        <span class="s1">warnings.warn(</span><span class="s2">&quot;Skipping UNKNOWN record&quot;</span><span class="s1">)</span>

    <span class="s3">elif </span><span class="s1">record[</span><span class="s2">'rectype'</span><span class="s1">] == </span><span class="s2">&quot;SYSTEM_VARIABLE&quot;</span><span class="s1">:</span>

        <span class="s1">warnings.warn(</span><span class="s2">&quot;Skipping SYSTEM_VARIABLE record&quot;</span><span class="s1">)</span>

    <span class="s3">else</span><span class="s1">:</span>

        <span class="s3">raise </span><span class="s1">Exception(</span><span class="s2">&quot;record['rectype']=%s not implemented&quot; </span><span class="s1">%</span>
                                                            <span class="s1">record[</span><span class="s2">'rectype'</span><span class="s1">])</span>

    <span class="s1">f.seek(nextrec)</span>

    <span class="s3">return </span><span class="s1">record</span>


<span class="s3">def </span><span class="s1">_read_typedesc(f):</span>
    <span class="s5">'''Function to read in a type descriptor'''</span>

    <span class="s1">typedesc = {</span><span class="s2">'typecode'</span><span class="s1">: _read_long(f)</span><span class="s3">, </span><span class="s2">'varflags'</span><span class="s1">: _read_long(f)}</span>

    <span class="s3">if </span><span class="s1">typedesc[</span><span class="s2">'varflags'</span><span class="s1">] &amp; </span><span class="s4">2 </span><span class="s1">== </span><span class="s4">2</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">Exception(</span><span class="s2">&quot;System variables not implemented&quot;</span><span class="s1">)</span>

    <span class="s1">typedesc[</span><span class="s2">'array'</span><span class="s1">] = typedesc[</span><span class="s2">'varflags'</span><span class="s1">] &amp; </span><span class="s4">4 </span><span class="s1">== </span><span class="s4">4</span>
    <span class="s1">typedesc[</span><span class="s2">'structure'</span><span class="s1">] = typedesc[</span><span class="s2">'varflags'</span><span class="s1">] &amp; </span><span class="s4">32 </span><span class="s1">== </span><span class="s4">32</span>

    <span class="s3">if </span><span class="s1">typedesc[</span><span class="s2">'structure'</span><span class="s1">]:</span>
        <span class="s1">typedesc[</span><span class="s2">'array_desc'</span><span class="s1">] = _read_arraydesc(f)</span>
        <span class="s1">typedesc[</span><span class="s2">'struct_desc'</span><span class="s1">] = _read_structdesc(f)</span>
    <span class="s3">elif </span><span class="s1">typedesc[</span><span class="s2">'array'</span><span class="s1">]:</span>
        <span class="s1">typedesc[</span><span class="s2">'array_desc'</span><span class="s1">] = _read_arraydesc(f)</span>

    <span class="s3">return </span><span class="s1">typedesc</span>


<span class="s3">def </span><span class="s1">_read_arraydesc(f):</span>
    <span class="s5">'''Function to read in an array descriptor'''</span>

    <span class="s1">arraydesc = {</span><span class="s2">'arrstart'</span><span class="s1">: _read_long(f)}</span>

    <span class="s3">if </span><span class="s1">arraydesc[</span><span class="s2">'arrstart'</span><span class="s1">] == </span><span class="s4">8</span><span class="s1">:</span>

        <span class="s1">_skip_bytes(f</span><span class="s3">, </span><span class="s4">4</span><span class="s1">)</span>

        <span class="s1">arraydesc[</span><span class="s2">'nbytes'</span><span class="s1">] = _read_long(f)</span>
        <span class="s1">arraydesc[</span><span class="s2">'nelements'</span><span class="s1">] = _read_long(f)</span>
        <span class="s1">arraydesc[</span><span class="s2">'ndims'</span><span class="s1">] = _read_long(f)</span>

        <span class="s1">_skip_bytes(f</span><span class="s3">, </span><span class="s4">8</span><span class="s1">)</span>

        <span class="s1">arraydesc[</span><span class="s2">'nmax'</span><span class="s1">] = _read_long(f)</span>

        <span class="s1">arraydesc[</span><span class="s2">'dims'</span><span class="s1">] = [_read_long(f) </span><span class="s3">for </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">range(arraydesc[</span><span class="s2">'nmax'</span><span class="s1">])]</span>

    <span class="s3">elif </span><span class="s1">arraydesc[</span><span class="s2">'arrstart'</span><span class="s1">] == </span><span class="s4">18</span><span class="s1">:</span>

        <span class="s1">warnings.warn(</span><span class="s2">&quot;Using experimental 64-bit array read&quot;</span><span class="s1">)</span>

        <span class="s1">_skip_bytes(f</span><span class="s3">, </span><span class="s4">8</span><span class="s1">)</span>

        <span class="s1">arraydesc[</span><span class="s2">'nbytes'</span><span class="s1">] = _read_uint64(f)</span>
        <span class="s1">arraydesc[</span><span class="s2">'nelements'</span><span class="s1">] = _read_uint64(f)</span>
        <span class="s1">arraydesc[</span><span class="s2">'ndims'</span><span class="s1">] = _read_long(f)</span>

        <span class="s1">_skip_bytes(f</span><span class="s3">, </span><span class="s4">8</span><span class="s1">)</span>

        <span class="s1">arraydesc[</span><span class="s2">'nmax'</span><span class="s1">] = </span><span class="s4">8</span>

        <span class="s1">arraydesc[</span><span class="s2">'dims'</span><span class="s1">] = []</span>
        <span class="s3">for </span><span class="s1">d </span><span class="s3">in </span><span class="s1">range(arraydesc[</span><span class="s2">'nmax'</span><span class="s1">]):</span>
            <span class="s1">v = _read_long(f)</span>
            <span class="s3">if </span><span class="s1">v != </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">Exception(</span><span class="s2">&quot;Expected a zero in ARRAY_DESC&quot;</span><span class="s1">)</span>
            <span class="s1">arraydesc[</span><span class="s2">'dims'</span><span class="s1">].append(_read_long(f))</span>

    <span class="s3">else</span><span class="s1">:</span>

        <span class="s3">raise </span><span class="s1">Exception(</span><span class="s2">&quot;Unknown ARRSTART: %i&quot; </span><span class="s1">% arraydesc[</span><span class="s2">'arrstart'</span><span class="s1">])</span>

    <span class="s3">return </span><span class="s1">arraydesc</span>


<span class="s3">def </span><span class="s1">_read_structdesc(f):</span>
    <span class="s5">'''Function to read in a structure descriptor'''</span>

    <span class="s1">structdesc = {}</span>

    <span class="s1">structstart = _read_long(f)</span>
    <span class="s3">if </span><span class="s1">structstart != </span><span class="s4">9</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">Exception(</span><span class="s2">&quot;STRUCTSTART should be 9&quot;</span><span class="s1">)</span>

    <span class="s1">structdesc[</span><span class="s2">'name'</span><span class="s1">] = _read_string(f)</span>
    <span class="s1">predef = _read_long(f)</span>
    <span class="s1">structdesc[</span><span class="s2">'ntags'</span><span class="s1">] = _read_long(f)</span>
    <span class="s1">structdesc[</span><span class="s2">'nbytes'</span><span class="s1">] = _read_long(f)</span>

    <span class="s1">structdesc[</span><span class="s2">'predef'</span><span class="s1">] = predef &amp; </span><span class="s4">1</span>
    <span class="s1">structdesc[</span><span class="s2">'inherits'</span><span class="s1">] = predef &amp; </span><span class="s4">2</span>
    <span class="s1">structdesc[</span><span class="s2">'is_super'</span><span class="s1">] = predef &amp; </span><span class="s4">4</span>

    <span class="s3">if not </span><span class="s1">structdesc[</span><span class="s2">'predef'</span><span class="s1">]:</span>

        <span class="s1">structdesc[</span><span class="s2">'tagtable'</span><span class="s1">] = [_read_tagdesc(f)</span>
                                  <span class="s3">for </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">range(structdesc[</span><span class="s2">'ntags'</span><span class="s1">])]</span>

        <span class="s3">for </span><span class="s1">tag </span><span class="s3">in </span><span class="s1">structdesc[</span><span class="s2">'tagtable'</span><span class="s1">]:</span>
            <span class="s1">tag[</span><span class="s2">'name'</span><span class="s1">] = _read_string(f)</span>

        <span class="s1">structdesc[</span><span class="s2">'arrtable'</span><span class="s1">] = {tag[</span><span class="s2">'name'</span><span class="s1">]: _read_arraydesc(f)</span>
                                  <span class="s3">for </span><span class="s1">tag </span><span class="s3">in </span><span class="s1">structdesc[</span><span class="s2">'tagtable'</span><span class="s1">]</span>
                                  <span class="s3">if </span><span class="s1">tag[</span><span class="s2">'array'</span><span class="s1">]}</span>

        <span class="s1">structdesc[</span><span class="s2">'structtable'</span><span class="s1">] = {tag[</span><span class="s2">'name'</span><span class="s1">]: _read_structdesc(f)</span>
                                     <span class="s3">for </span><span class="s1">tag </span><span class="s3">in </span><span class="s1">structdesc[</span><span class="s2">'tagtable'</span><span class="s1">]</span>
                                     <span class="s3">if </span><span class="s1">tag[</span><span class="s2">'structure'</span><span class="s1">]}</span>

        <span class="s3">if </span><span class="s1">structdesc[</span><span class="s2">'inherits'</span><span class="s1">] </span><span class="s3">or </span><span class="s1">structdesc[</span><span class="s2">'is_super'</span><span class="s1">]:</span>
            <span class="s1">structdesc[</span><span class="s2">'classname'</span><span class="s1">] = _read_string(f)</span>
            <span class="s1">structdesc[</span><span class="s2">'nsupclasses'</span><span class="s1">] = _read_long(f)</span>
            <span class="s1">structdesc[</span><span class="s2">'supclassnames'</span><span class="s1">] = [</span>
                <span class="s1">_read_string(f) </span><span class="s3">for </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">range(structdesc[</span><span class="s2">'nsupclasses'</span><span class="s1">])]</span>
            <span class="s1">structdesc[</span><span class="s2">'supclasstable'</span><span class="s1">] = [</span>
                <span class="s1">_read_structdesc(f) </span><span class="s3">for </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">range(structdesc[</span><span class="s2">'nsupclasses'</span><span class="s1">])]</span>

        <span class="s1">STRUCT_DICT[structdesc[</span><span class="s2">'name'</span><span class="s1">]] = structdesc</span>

    <span class="s3">else</span><span class="s1">:</span>

        <span class="s3">if </span><span class="s1">structdesc[</span><span class="s2">'name'</span><span class="s1">] </span><span class="s3">not in </span><span class="s1">STRUCT_DICT:</span>
            <span class="s3">raise </span><span class="s1">Exception(</span><span class="s2">&quot;PREDEF=1 but can't find definition&quot;</span><span class="s1">)</span>

        <span class="s1">structdesc = STRUCT_DICT[structdesc[</span><span class="s2">'name'</span><span class="s1">]]</span>

    <span class="s3">return </span><span class="s1">structdesc</span>


<span class="s3">def </span><span class="s1">_read_tagdesc(f):</span>
    <span class="s5">'''Function to read in a tag descriptor'''</span>

    <span class="s1">tagdesc = {</span><span class="s2">'offset'</span><span class="s1">: _read_long(f)}</span>

    <span class="s3">if </span><span class="s1">tagdesc[</span><span class="s2">'offset'</span><span class="s1">] == -</span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">tagdesc[</span><span class="s2">'offset'</span><span class="s1">] = _read_uint64(f)</span>

    <span class="s1">tagdesc[</span><span class="s2">'typecode'</span><span class="s1">] = _read_long(f)</span>
    <span class="s1">tagflags = _read_long(f)</span>

    <span class="s1">tagdesc[</span><span class="s2">'array'</span><span class="s1">] = tagflags &amp; </span><span class="s4">4 </span><span class="s1">== </span><span class="s4">4</span>
    <span class="s1">tagdesc[</span><span class="s2">'structure'</span><span class="s1">] = tagflags &amp; </span><span class="s4">32 </span><span class="s1">== </span><span class="s4">32</span>
    <span class="s1">tagdesc[</span><span class="s2">'scalar'</span><span class="s1">] = tagdesc[</span><span class="s2">'typecode'</span><span class="s1">] </span><span class="s3">in </span><span class="s1">DTYPE_DICT</span>
    <span class="s0"># Assume '10'x is scalar</span>

    <span class="s3">return </span><span class="s1">tagdesc</span>


<span class="s3">def </span><span class="s1">_replace_heap(variable</span><span class="s3">, </span><span class="s1">heap):</span>

    <span class="s3">if </span><span class="s1">isinstance(variable</span><span class="s3">, </span><span class="s1">Pointer):</span>

        <span class="s3">while </span><span class="s1">isinstance(variable</span><span class="s3">, </span><span class="s1">Pointer):</span>

            <span class="s3">if </span><span class="s1">variable.index == </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">variable = </span><span class="s3">None</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">variable.index </span><span class="s3">in </span><span class="s1">heap:</span>
                    <span class="s1">variable = heap[variable.index]</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">warnings.warn(</span><span class="s2">&quot;Variable referenced by pointer not found &quot;</span>
                                  <span class="s2">&quot;in heap: variable will be set to None&quot;</span><span class="s1">)</span>
                    <span class="s1">variable = </span><span class="s3">None</span>

        <span class="s1">replace</span><span class="s3">, </span><span class="s1">new = _replace_heap(variable</span><span class="s3">, </span><span class="s1">heap)</span>

        <span class="s3">if </span><span class="s1">replace:</span>
            <span class="s1">variable = new</span>

        <span class="s3">return True, </span><span class="s1">variable</span>

    <span class="s3">elif </span><span class="s1">isinstance(variable</span><span class="s3">, </span><span class="s1">np.core.records.recarray):</span>

        <span class="s0"># Loop over records</span>
        <span class="s3">for </span><span class="s1">ir</span><span class="s3">, </span><span class="s1">record </span><span class="s3">in </span><span class="s1">enumerate(variable):</span>

            <span class="s1">replace</span><span class="s3">, </span><span class="s1">new = _replace_heap(record</span><span class="s3">, </span><span class="s1">heap)</span>

            <span class="s3">if </span><span class="s1">replace:</span>
                <span class="s1">variable[ir] = new</span>

        <span class="s3">return False, </span><span class="s1">variable</span>

    <span class="s3">elif </span><span class="s1">isinstance(variable</span><span class="s3">, </span><span class="s1">np.core.records.record):</span>

        <span class="s0"># Loop over values</span>
        <span class="s3">for </span><span class="s1">iv</span><span class="s3">, </span><span class="s1">value </span><span class="s3">in </span><span class="s1">enumerate(variable):</span>

            <span class="s1">replace</span><span class="s3">, </span><span class="s1">new = _replace_heap(value</span><span class="s3">, </span><span class="s1">heap)</span>

            <span class="s3">if </span><span class="s1">replace:</span>
                <span class="s1">variable[iv] = new</span>

        <span class="s3">return False, </span><span class="s1">variable</span>

    <span class="s3">elif </span><span class="s1">isinstance(variable</span><span class="s3">, </span><span class="s1">np.ndarray):</span>

        <span class="s0"># Loop over values if type is np.object_</span>
        <span class="s3">if </span><span class="s1">variable.dtype.type </span><span class="s3">is </span><span class="s1">np.object_:</span>

            <span class="s3">for </span><span class="s1">iv </span><span class="s3">in </span><span class="s1">range(variable.size):</span>

                <span class="s1">replace</span><span class="s3">, </span><span class="s1">new = _replace_heap(variable.item(iv)</span><span class="s3">, </span><span class="s1">heap)</span>

                <span class="s3">if </span><span class="s1">replace:</span>
                    <span class="s1">variable.itemset(iv</span><span class="s3">, </span><span class="s1">new)</span>

        <span class="s3">return False, </span><span class="s1">variable</span>

    <span class="s3">else</span><span class="s1">:</span>

        <span class="s3">return False, </span><span class="s1">variable</span>


<span class="s3">class </span><span class="s1">AttrDict(dict):</span>
    <span class="s5">''' 
    A case-insensitive dictionary with access via item, attribute, and call 
    notations: 
 
        &gt;&gt;&gt; d = AttrDict() 
        &gt;&gt;&gt; d['Variable'] = 123 
        &gt;&gt;&gt; d['Variable'] 
        123 
        &gt;&gt;&gt; d.Variable 
        123 
        &gt;&gt;&gt; d.variable 
        123 
        &gt;&gt;&gt; d('VARIABLE') 
        123 
        &gt;&gt;&gt; d['missing'] 
        Traceback (most recent error last): 
        ... 
        KeyError: 'missing' 
        &gt;&gt;&gt; d.missing 
        Traceback (most recent error last): 
        ... 
        AttributeError: 'AttrDict' object has no attribute 'missing' 
    '''</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">init={}):</span>
        <span class="s1">dict.__init__(self</span><span class="s3">, </span><span class="s1">init)</span>

    <span class="s3">def </span><span class="s1">__getitem__(self</span><span class="s3">, </span><span class="s1">name):</span>
        <span class="s3">return </span><span class="s1">super().__getitem__(name.lower())</span>

    <span class="s3">def </span><span class="s1">__setitem__(self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s3">return </span><span class="s1">super().__setitem__(key.lower()</span><span class="s3">, </span><span class="s1">value)</span>

    <span class="s3">def </span><span class="s1">__getattr__(self</span><span class="s3">, </span><span class="s1">name):</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.__getitem__(name)</span>
        <span class="s3">except </span><span class="s1">KeyError:</span>
            <span class="s3">raise </span><span class="s1">AttributeError(</span>
                <span class="s2">f&quot;'</span><span class="s3">{</span><span class="s1">type(self)</span><span class="s3">}</span><span class="s2">' object has no attribute '</span><span class="s3">{</span><span class="s1">name</span><span class="s3">}</span><span class="s2">'&quot;</span><span class="s1">) </span><span class="s3">from None</span>

    <span class="s1">__setattr__ = __setitem__</span>
    <span class="s1">__call__ = __getitem__</span>


<span class="s3">def </span><span class="s1">readsav(file_name</span><span class="s3">, </span><span class="s1">idict=</span><span class="s3">None, </span><span class="s1">python_dict=</span><span class="s3">False,</span>
            <span class="s1">uncompressed_file_name=</span><span class="s3">None, </span><span class="s1">verbose=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Read an IDL .sav file. 
 
    Parameters 
    ---------- 
    file_name : str 
        Name of the IDL save file. 
    idict : dict, optional 
        Dictionary in which to insert .sav file variables. 
    python_dict : bool, optional 
        By default, the object return is not a Python dictionary, but a 
        case-insensitive dictionary with item, attribute, and call access 
        to variables. To get a standard Python dictionary, set this option 
        to True. 
    uncompressed_file_name : str, optional 
        This option only has an effect for .sav files written with the 
        /compress option. If a file name is specified, compressed .sav 
        files are uncompressed to this file. Otherwise, readsav will use 
        the `tempfile` module to determine a temporary filename 
        automatically, and will remove the temporary file upon successfully 
        reading it in. 
    verbose : bool, optional 
        Whether to print out information about the save file, including 
        the records read, and available variables. 
 
    Returns 
    ------- 
    idl_dict : AttrDict or dict 
        If `python_dict` is set to False (default), this function returns a 
        case-insensitive dictionary with item, attribute, and call access 
        to variables. If `python_dict` is set to True, this function 
        returns a Python dictionary with all variable names in lowercase. 
        If `idict` was specified, then variables are written to the 
        dictionary specified, and the updated dictionary is returned. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from os.path import dirname, join as pjoin 
    &gt;&gt;&gt; import scipy.io as sio 
    &gt;&gt;&gt; from scipy.io import readsav 
 
    Get the filename for an example .sav file from the tests/data directory. 
 
    &gt;&gt;&gt; data_dir = pjoin(dirname(sio.__file__), 'tests', 'data') 
    &gt;&gt;&gt; sav_fname = pjoin(data_dir, 'array_float32_1d.sav') 
 
    Load the .sav file contents. 
 
    &gt;&gt;&gt; sav_data = readsav(sav_fname) 
 
    Get keys of the .sav file contents. 
 
    &gt;&gt;&gt; print(sav_data.keys()) 
    dict_keys(['array1d']) 
 
    Access a content with a key. 
 
    &gt;&gt;&gt; print(sav_data['array1d']) 
    [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 
     0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 
     0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 
     0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 
     0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 
     0. 0. 0.] 
 
    &quot;&quot;&quot;</span>

    <span class="s0"># Initialize record and variable holders</span>
    <span class="s1">records = []</span>
    <span class="s3">if </span><span class="s1">python_dict </span><span class="s3">or </span><span class="s1">idict:</span>
        <span class="s1">variables = {}</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">variables = AttrDict()</span>

    <span class="s0"># Open the IDL file</span>
    <span class="s1">f = open(file_name</span><span class="s3">, </span><span class="s2">'rb'</span><span class="s1">)</span>

    <span class="s0"># Read the signature, which should be 'SR'</span>
    <span class="s1">signature = _read_bytes(f</span><span class="s3">, </span><span class="s4">2</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">signature != </span><span class="s6">b'SR'</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">Exception(</span><span class="s2">&quot;Invalid SIGNATURE: %s&quot; </span><span class="s1">% signature)</span>

    <span class="s0"># Next, the record format, which is '\x00\x04' for normal .sav</span>
    <span class="s0"># files, and '\x00\x06' for compressed .sav files.</span>
    <span class="s1">recfmt = _read_bytes(f</span><span class="s3">, </span><span class="s4">2</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">recfmt == </span><span class="s6">b'</span><span class="s3">\x00\x04</span><span class="s6">'</span><span class="s1">:</span>
        <span class="s3">pass</span>

    <span class="s3">elif </span><span class="s1">recfmt == </span><span class="s6">b'</span><span class="s3">\x00\x06</span><span class="s6">'</span><span class="s1">:</span>

        <span class="s3">if </span><span class="s1">verbose:</span>
            <span class="s1">print(</span><span class="s2">&quot;IDL Save file is compressed&quot;</span><span class="s1">)</span>

        <span class="s3">if </span><span class="s1">uncompressed_file_name:</span>
            <span class="s1">fout = open(uncompressed_file_name</span><span class="s3">, </span><span class="s2">'w+b'</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">fout = tempfile.NamedTemporaryFile(suffix=</span><span class="s2">'.sav'</span><span class="s1">)</span>

        <span class="s3">if </span><span class="s1">verbose:</span>
            <span class="s1">print(</span><span class="s2">&quot; -&gt; expanding to %s&quot; </span><span class="s1">% fout.name)</span>

        <span class="s0"># Write header</span>
        <span class="s1">fout.write(</span><span class="s6">b'SR</span><span class="s3">\x00\x04</span><span class="s6">'</span><span class="s1">)</span>

        <span class="s0"># Cycle through records</span>
        <span class="s3">while True</span><span class="s1">:</span>

            <span class="s0"># Read record type</span>
            <span class="s1">rectype = _read_long(f)</span>
            <span class="s1">fout.write(struct.pack(</span><span class="s2">'&gt;l'</span><span class="s3">, </span><span class="s1">int(rectype)))</span>

            <span class="s0"># Read position of next record and return as int</span>
            <span class="s1">nextrec = _read_uint32(f)</span>
            <span class="s1">nextrec += _read_uint32(f) * </span><span class="s4">2</span><span class="s1">**</span><span class="s4">32</span>

            <span class="s0"># Read the unknown 4 bytes</span>
            <span class="s1">unknown = f.read(</span><span class="s4">4</span><span class="s1">)</span>

            <span class="s0"># Check if the end of the file has been reached</span>
            <span class="s3">if </span><span class="s1">RECTYPE_DICT[rectype] == </span><span class="s2">'END_MARKER'</span><span class="s1">:</span>
                <span class="s1">modval = np.int64(</span><span class="s4">2</span><span class="s1">**</span><span class="s4">32</span><span class="s1">)</span>
                <span class="s1">fout.write(struct.pack(</span><span class="s2">'&gt;I'</span><span class="s3">, </span><span class="s1">int(nextrec) % modval))</span>
                <span class="s1">fout.write(struct.pack(</span><span class="s2">'&gt;I'</span><span class="s3">, </span><span class="s1">int((nextrec - (nextrec % modval)) / modval)))</span>
                <span class="s1">fout.write(unknown)</span>
                <span class="s3">break</span>

            <span class="s0"># Find current position</span>
            <span class="s1">pos = f.tell()</span>

            <span class="s0"># Decompress record</span>
            <span class="s1">rec_string = zlib.decompress(f.read(nextrec-pos))</span>

            <span class="s0"># Find new position of next record</span>
            <span class="s1">nextrec = fout.tell() + len(rec_string) + </span><span class="s4">12</span>

            <span class="s0"># Write out record</span>
            <span class="s1">fout.write(struct.pack(</span><span class="s2">'&gt;I'</span><span class="s3">, </span><span class="s1">int(nextrec % </span><span class="s4">2</span><span class="s1">**</span><span class="s4">32</span><span class="s1">)))</span>
            <span class="s1">fout.write(struct.pack(</span><span class="s2">'&gt;I'</span><span class="s3">, </span><span class="s1">int((nextrec - (nextrec % </span><span class="s4">2</span><span class="s1">**</span><span class="s4">32</span><span class="s1">)) / </span><span class="s4">2</span><span class="s1">**</span><span class="s4">32</span><span class="s1">)))</span>
            <span class="s1">fout.write(unknown)</span>
            <span class="s1">fout.write(rec_string)</span>

        <span class="s0"># Close the original compressed file</span>
        <span class="s1">f.close()</span>

        <span class="s0"># Set f to be the decompressed file, and skip the first four bytes</span>
        <span class="s1">f = fout</span>
        <span class="s1">f.seek(</span><span class="s4">4</span><span class="s1">)</span>

    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">Exception(</span><span class="s2">&quot;Invalid RECFMT: %s&quot; </span><span class="s1">% recfmt)</span>

    <span class="s0"># Loop through records, and add them to the list</span>
    <span class="s3">while True</span><span class="s1">:</span>
        <span class="s1">r = _read_record(f)</span>
        <span class="s1">records.append(r)</span>
        <span class="s3">if </span><span class="s2">'end' </span><span class="s3">in </span><span class="s1">r:</span>
            <span class="s3">if </span><span class="s1">r[</span><span class="s2">'end'</span><span class="s1">]:</span>
                <span class="s3">break</span>

    <span class="s0"># Close the file</span>
    <span class="s1">f.close()</span>

    <span class="s0"># Find heap data variables</span>
    <span class="s1">heap = {}</span>
    <span class="s3">for </span><span class="s1">r </span><span class="s3">in </span><span class="s1">records:</span>
        <span class="s3">if </span><span class="s1">r[</span><span class="s2">'rectype'</span><span class="s1">] == </span><span class="s2">&quot;HEAP_DATA&quot;</span><span class="s1">:</span>
            <span class="s1">heap[r[</span><span class="s2">'heap_index'</span><span class="s1">]] = r[</span><span class="s2">'data'</span><span class="s1">]</span>

    <span class="s0"># Find all variables</span>
    <span class="s3">for </span><span class="s1">r </span><span class="s3">in </span><span class="s1">records:</span>
        <span class="s3">if </span><span class="s1">r[</span><span class="s2">'rectype'</span><span class="s1">] == </span><span class="s2">&quot;VARIABLE&quot;</span><span class="s1">:</span>
            <span class="s1">replace</span><span class="s3">, </span><span class="s1">new = _replace_heap(r[</span><span class="s2">'data'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">heap)</span>
            <span class="s3">if </span><span class="s1">replace:</span>
                <span class="s1">r[</span><span class="s2">'data'</span><span class="s1">] = new</span>
            <span class="s1">variables[r[</span><span class="s2">'varname'</span><span class="s1">].lower()] = r[</span><span class="s2">'data'</span><span class="s1">]</span>

    <span class="s3">if </span><span class="s1">verbose:</span>

        <span class="s0"># Print out timestamp info about the file</span>
        <span class="s3">for </span><span class="s1">record </span><span class="s3">in </span><span class="s1">records:</span>
            <span class="s3">if </span><span class="s1">record[</span><span class="s2">'rectype'</span><span class="s1">] == </span><span class="s2">&quot;TIMESTAMP&quot;</span><span class="s1">:</span>
                <span class="s1">print(</span><span class="s2">&quot;-&quot;</span><span class="s1">*</span><span class="s4">50</span><span class="s1">)</span>
                <span class="s1">print(</span><span class="s2">&quot;Date: %s&quot; </span><span class="s1">% record[</span><span class="s2">'date'</span><span class="s1">])</span>
                <span class="s1">print(</span><span class="s2">&quot;User: %s&quot; </span><span class="s1">% record[</span><span class="s2">'user'</span><span class="s1">])</span>
                <span class="s1">print(</span><span class="s2">&quot;Host: %s&quot; </span><span class="s1">% record[</span><span class="s2">'host'</span><span class="s1">])</span>
                <span class="s3">break</span>

        <span class="s0"># Print out version info about the file</span>
        <span class="s3">for </span><span class="s1">record </span><span class="s3">in </span><span class="s1">records:</span>
            <span class="s3">if </span><span class="s1">record[</span><span class="s2">'rectype'</span><span class="s1">] == </span><span class="s2">&quot;VERSION&quot;</span><span class="s1">:</span>
                <span class="s1">print(</span><span class="s2">&quot;-&quot;</span><span class="s1">*</span><span class="s4">50</span><span class="s1">)</span>
                <span class="s1">print(</span><span class="s2">&quot;Format: %s&quot; </span><span class="s1">% record[</span><span class="s2">'format'</span><span class="s1">])</span>
                <span class="s1">print(</span><span class="s2">&quot;Architecture: %s&quot; </span><span class="s1">% record[</span><span class="s2">'arch'</span><span class="s1">])</span>
                <span class="s1">print(</span><span class="s2">&quot;Operating System: %s&quot; </span><span class="s1">% record[</span><span class="s2">'os'</span><span class="s1">])</span>
                <span class="s1">print(</span><span class="s2">&quot;IDL Version: %s&quot; </span><span class="s1">% record[</span><span class="s2">'release'</span><span class="s1">])</span>
                <span class="s3">break</span>

        <span class="s0"># Print out identification info about the file</span>
        <span class="s3">for </span><span class="s1">record </span><span class="s3">in </span><span class="s1">records:</span>
            <span class="s3">if </span><span class="s1">record[</span><span class="s2">'rectype'</span><span class="s1">] == </span><span class="s2">&quot;IDENTIFICATON&quot;</span><span class="s1">:</span>
                <span class="s1">print(</span><span class="s2">&quot;-&quot;</span><span class="s1">*</span><span class="s4">50</span><span class="s1">)</span>
                <span class="s1">print(</span><span class="s2">&quot;Author: %s&quot; </span><span class="s1">% record[</span><span class="s2">'author'</span><span class="s1">])</span>
                <span class="s1">print(</span><span class="s2">&quot;Title: %s&quot; </span><span class="s1">% record[</span><span class="s2">'title'</span><span class="s1">])</span>
                <span class="s1">print(</span><span class="s2">&quot;ID Code: %s&quot; </span><span class="s1">% record[</span><span class="s2">'idcode'</span><span class="s1">])</span>
                <span class="s3">break</span>

        <span class="s0"># Print out descriptions saved with the file</span>
        <span class="s3">for </span><span class="s1">record </span><span class="s3">in </span><span class="s1">records:</span>
            <span class="s3">if </span><span class="s1">record[</span><span class="s2">'rectype'</span><span class="s1">] == </span><span class="s2">&quot;DESCRIPTION&quot;</span><span class="s1">:</span>
                <span class="s1">print(</span><span class="s2">&quot;-&quot;</span><span class="s1">*</span><span class="s4">50</span><span class="s1">)</span>
                <span class="s1">print(</span><span class="s2">&quot;Description: %s&quot; </span><span class="s1">% record[</span><span class="s2">'description'</span><span class="s1">])</span>
                <span class="s3">break</span>

        <span class="s1">print(</span><span class="s2">&quot;-&quot;</span><span class="s1">*</span><span class="s4">50</span><span class="s1">)</span>
        <span class="s1">print(</span><span class="s2">&quot;Successfully read %i records of which:&quot; </span><span class="s1">%</span>
                                            <span class="s1">(len(records)))</span>

        <span class="s0"># Create convenience list of record types</span>
        <span class="s1">rectypes = [r[</span><span class="s2">'rectype'</span><span class="s1">] </span><span class="s3">for </span><span class="s1">r </span><span class="s3">in </span><span class="s1">records]</span>

        <span class="s3">for </span><span class="s1">rt </span><span class="s3">in </span><span class="s1">set(rectypes):</span>
            <span class="s3">if </span><span class="s1">rt != </span><span class="s2">'END_MARKER'</span><span class="s1">:</span>
                <span class="s1">print(</span><span class="s2">&quot; - %i are of type %s&quot; </span><span class="s1">% (rectypes.count(rt)</span><span class="s3">, </span><span class="s1">rt))</span>
        <span class="s1">print(</span><span class="s2">&quot;-&quot;</span><span class="s1">*</span><span class="s4">50</span><span class="s1">)</span>

        <span class="s3">if </span><span class="s2">'VARIABLE' </span><span class="s3">in </span><span class="s1">rectypes:</span>
            <span class="s1">print(</span><span class="s2">&quot;Available variables:&quot;</span><span class="s1">)</span>
            <span class="s3">for </span><span class="s1">var </span><span class="s3">in </span><span class="s1">variables:</span>
                <span class="s1">print(</span><span class="s2">f&quot; - </span><span class="s3">{</span><span class="s1">var</span><span class="s3">} </span><span class="s2">[</span><span class="s3">{</span><span class="s1">type(variables[var])</span><span class="s3">}</span><span class="s2">]&quot;</span><span class="s1">)</span>
            <span class="s1">print(</span><span class="s2">&quot;-&quot;</span><span class="s1">*</span><span class="s4">50</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">idict:</span>
        <span class="s3">for </span><span class="s1">var </span><span class="s3">in </span><span class="s1">variables:</span>
            <span class="s1">idict[var] = variables[var]</span>
        <span class="s3">return </span><span class="s1">idict</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">variables</span>
</pre>
</body>
</html>