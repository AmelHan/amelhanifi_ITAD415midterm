<html>
<head>
<title>base_parser.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6897bb;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
base_parser.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">from </span><span class="s1">collections </span><span class="s0">import </span><span class="s1">defaultdict</span>
<span class="s0">from </span><span class="s1">copy </span><span class="s0">import </span><span class="s1">copy</span>
<span class="s0">import </span><span class="s1">csv</span>
<span class="s0">import </span><span class="s1">datetime</span>
<span class="s0">from </span><span class="s1">enum </span><span class="s0">import </span><span class="s1">Enum</span>
<span class="s0">import </span><span class="s1">itertools</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">TYPE_CHECKING</span><span class="s0">,</span>
    <span class="s1">Any</span><span class="s0">,</span>
    <span class="s1">Callable</span><span class="s0">,</span>
    <span class="s1">cast</span><span class="s0">,</span>
    <span class="s1">final</span><span class="s0">,</span>
    <span class="s1">overload</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">from </span><span class="s1">pandas._libs </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">lib</span><span class="s0">,</span>
    <span class="s1">parsers</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">import </span><span class="s1">pandas._libs.ops </span><span class="s0">as </span><span class="s1">libops</span>
<span class="s0">from </span><span class="s1">pandas._libs.parsers </span><span class="s0">import </span><span class="s1">STR_NA_VALUES</span>
<span class="s0">from </span><span class="s1">pandas._libs.tslibs </span><span class="s0">import </span><span class="s1">parsing</span>
<span class="s0">from </span><span class="s1">pandas.compat._optional </span><span class="s0">import </span><span class="s1">import_optional_dependency</span>
<span class="s0">from </span><span class="s1">pandas.errors </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">ParserError</span><span class="s0">,</span>
    <span class="s1">ParserWarning</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.util._exceptions </span><span class="s0">import </span><span class="s1">find_stack_level</span>

<span class="s0">from </span><span class="s1">pandas.core.dtypes.astype </span><span class="s0">import </span><span class="s1">astype_array</span>
<span class="s0">from </span><span class="s1">pandas.core.dtypes.common </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">ensure_object</span><span class="s0">,</span>
    <span class="s1">is_bool_dtype</span><span class="s0">,</span>
    <span class="s1">is_dict_like</span><span class="s0">,</span>
    <span class="s1">is_extension_array_dtype</span><span class="s0">,</span>
    <span class="s1">is_float_dtype</span><span class="s0">,</span>
    <span class="s1">is_integer</span><span class="s0">,</span>
    <span class="s1">is_integer_dtype</span><span class="s0">,</span>
    <span class="s1">is_list_like</span><span class="s0">,</span>
    <span class="s1">is_object_dtype</span><span class="s0">,</span>
    <span class="s1">is_scalar</span><span class="s0">,</span>
    <span class="s1">is_string_dtype</span><span class="s0">,</span>
    <span class="s1">pandas_dtype</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.dtypes.dtypes </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">CategoricalDtype</span><span class="s0">,</span>
    <span class="s1">ExtensionDtype</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.dtypes.missing </span><span class="s0">import </span><span class="s1">isna</span>

<span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">ArrowDtype</span><span class="s0">,</span>
    <span class="s1">DataFrame</span><span class="s0">,</span>
    <span class="s1">DatetimeIndex</span><span class="s0">,</span>
    <span class="s1">StringDtype</span><span class="s0">,</span>
    <span class="s1">concat</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core </span><span class="s0">import </span><span class="s1">algorithms</span>
<span class="s0">from </span><span class="s1">pandas.core.arrays </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">ArrowExtensionArray</span><span class="s0">,</span>
    <span class="s1">BooleanArray</span><span class="s0">,</span>
    <span class="s1">Categorical</span><span class="s0">,</span>
    <span class="s1">ExtensionArray</span><span class="s0">,</span>
    <span class="s1">FloatingArray</span><span class="s0">,</span>
    <span class="s1">IntegerArray</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.arrays.boolean </span><span class="s0">import </span><span class="s1">BooleanDtype</span>
<span class="s0">from </span><span class="s1">pandas.core.indexes.api </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">Index</span><span class="s0">,</span>
    <span class="s1">MultiIndex</span><span class="s0">,</span>
    <span class="s1">default_index</span><span class="s0">,</span>
    <span class="s1">ensure_index_from_sequences</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.series </span><span class="s0">import </span><span class="s1">Series</span>
<span class="s0">from </span><span class="s1">pandas.core.tools </span><span class="s0">import </span><span class="s1">datetimes </span><span class="s0">as </span><span class="s1">tools</span>

<span class="s0">from </span><span class="s1">pandas.io.common </span><span class="s0">import </span><span class="s1">is_potential_multi_index</span>

<span class="s0">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s0">from </span><span class="s1">collections.abc </span><span class="s0">import </span><span class="s1">(</span>
        <span class="s1">Hashable</span><span class="s0">,</span>
        <span class="s1">Iterable</span><span class="s0">,</span>
        <span class="s1">Mapping</span><span class="s0">,</span>
        <span class="s1">Sequence</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s0">from </span><span class="s1">pandas._typing </span><span class="s0">import </span><span class="s1">(</span>
        <span class="s1">ArrayLike</span><span class="s0">,</span>
        <span class="s1">DtypeArg</span><span class="s0">,</span>
        <span class="s1">DtypeObj</span><span class="s0">,</span>
        <span class="s1">Scalar</span><span class="s0">,</span>
    <span class="s1">)</span>


<span class="s0">class </span><span class="s1">ParserBase:</span>
    <span class="s0">class </span><span class="s1">BadLineHandleMethod(Enum):</span>
        <span class="s1">ERROR = </span><span class="s2">0</span>
        <span class="s1">WARN = </span><span class="s2">1</span>
        <span class="s1">SKIP = </span><span class="s2">2</span>

    <span class="s1">_implicit_index: bool</span>
    <span class="s1">_first_chunk: bool</span>
    <span class="s1">keep_default_na: bool</span>
    <span class="s1">dayfirst: bool</span>
    <span class="s1">cache_dates: bool</span>
    <span class="s1">keep_date_col: bool</span>
    <span class="s1">usecols_dtype: str | </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">kwds) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self._implicit_index = </span><span class="s0">False</span>

        <span class="s1">self.names = kwds.get(</span><span class="s3">&quot;names&quot;</span><span class="s1">)</span>
        <span class="s1">self.orig_names: Sequence[Hashable] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span>

        <span class="s1">self.index_col = kwds.get(</span><span class="s3">&quot;index_col&quot;</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s1">self.unnamed_cols: set = set()</span>
        <span class="s1">self.index_names: Sequence[Hashable] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span>
        <span class="s1">self.col_names: Sequence[Hashable] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span>

        <span class="s1">self.parse_dates = _validate_parse_dates_arg(kwds.pop(</span><span class="s3">&quot;parse_dates&quot;</span><span class="s0">, False</span><span class="s1">))</span>
        <span class="s1">self._parse_date_cols: Iterable = []</span>
        <span class="s1">self.date_parser = kwds.pop(</span><span class="s3">&quot;date_parser&quot;</span><span class="s0">, </span><span class="s1">lib.no_default)</span>
        <span class="s1">self.date_format = kwds.pop(</span><span class="s3">&quot;date_format&quot;</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s1">self.dayfirst = kwds.pop(</span><span class="s3">&quot;dayfirst&quot;</span><span class="s0">, False</span><span class="s1">)</span>
        <span class="s1">self.keep_date_col = kwds.pop(</span><span class="s3">&quot;keep_date_col&quot;</span><span class="s0">, False</span><span class="s1">)</span>

        <span class="s1">self.na_values = kwds.get(</span><span class="s3">&quot;na_values&quot;</span><span class="s1">)</span>
        <span class="s1">self.na_fvalues = kwds.get(</span><span class="s3">&quot;na_fvalues&quot;</span><span class="s1">)</span>
        <span class="s1">self.na_filter = kwds.get(</span><span class="s3">&quot;na_filter&quot;</span><span class="s0">, False</span><span class="s1">)</span>
        <span class="s1">self.keep_default_na = kwds.get(</span><span class="s3">&quot;keep_default_na&quot;</span><span class="s0">, True</span><span class="s1">)</span>

        <span class="s1">self.dtype = copy(kwds.get(</span><span class="s3">&quot;dtype&quot;</span><span class="s0">, None</span><span class="s1">))</span>
        <span class="s1">self.converters = kwds.get(</span><span class="s3">&quot;converters&quot;</span><span class="s1">)</span>
        <span class="s1">self.dtype_backend = kwds.get(</span><span class="s3">&quot;dtype_backend&quot;</span><span class="s1">)</span>

        <span class="s1">self.true_values = kwds.get(</span><span class="s3">&quot;true_values&quot;</span><span class="s1">)</span>
        <span class="s1">self.false_values = kwds.get(</span><span class="s3">&quot;false_values&quot;</span><span class="s1">)</span>
        <span class="s1">self.cache_dates = kwds.pop(</span><span class="s3">&quot;cache_dates&quot;</span><span class="s0">, True</span><span class="s1">)</span>

        <span class="s1">self._date_conv = _make_date_converter(</span>
            <span class="s1">date_parser=self.date_parser</span><span class="s0">,</span>
            <span class="s1">date_format=self.date_format</span><span class="s0">,</span>
            <span class="s1">dayfirst=self.dayfirst</span><span class="s0">,</span>
            <span class="s1">cache_dates=self.cache_dates</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s4"># validate header options for mi</span>
        <span class="s1">self.header = kwds.get(</span><span class="s3">&quot;header&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">is_list_like(self.header</span><span class="s0">, </span><span class="s1">allow_sets=</span><span class="s0">False</span><span class="s1">):</span>
            <span class="s0">if </span><span class="s1">kwds.get(</span><span class="s3">&quot;usecols&quot;</span><span class="s1">):</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">&quot;cannot specify usecols when specifying a multi-index header&quot;</span>
                <span class="s1">)</span>
            <span class="s0">if </span><span class="s1">kwds.get(</span><span class="s3">&quot;names&quot;</span><span class="s1">):</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">&quot;cannot specify names when specifying a multi-index header&quot;</span>
                <span class="s1">)</span>

            <span class="s4"># validate index_col that only contains integers</span>
            <span class="s0">if </span><span class="s1">self.index_col </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s4"># In this case we can pin down index_col as list[int]</span>
                <span class="s0">if </span><span class="s1">is_integer(self.index_col):</span>
                    <span class="s1">self.index_col = [self.index_col]</span>
                <span class="s0">elif not </span><span class="s1">(</span>
                    <span class="s1">is_list_like(self.index_col</span><span class="s0">, </span><span class="s1">allow_sets=</span><span class="s0">False</span><span class="s1">)</span>
                    <span class="s0">and </span><span class="s1">all(map(is_integer</span><span class="s0">, </span><span class="s1">self.index_col))</span>
                <span class="s1">):</span>
                    <span class="s0">raise </span><span class="s1">ValueError(</span>
                        <span class="s3">&quot;index_col must only contain row numbers &quot;</span>
                        <span class="s3">&quot;when specifying a multi-index header&quot;</span>
                    <span class="s1">)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">self.index_col = list(self.index_col)</span>

        <span class="s1">self._name_processed = </span><span class="s0">False</span>

        <span class="s1">self._first_chunk = </span><span class="s0">True</span>

        <span class="s1">self.usecols</span><span class="s0">, </span><span class="s1">self.usecols_dtype = self._validate_usecols_arg(kwds[</span><span class="s3">&quot;usecols&quot;</span><span class="s1">])</span>

        <span class="s4"># Fallback to error to pass a sketchy test(test_override_set_noconvert_columns)</span>
        <span class="s4"># Normally, this arg would get pre-processed earlier on</span>
        <span class="s1">self.on_bad_lines = kwds.get(</span><span class="s3">&quot;on_bad_lines&quot;</span><span class="s0">, </span><span class="s1">self.BadLineHandleMethod.ERROR)</span>

    <span class="s0">def </span><span class="s1">_validate_parse_dates_presence(self</span><span class="s0">, </span><span class="s1">columns: Sequence[Hashable]) -&gt; Iterable:</span>
        <span class="s5">&quot;&quot;&quot; 
        Check if parse_dates are in columns. 
 
        If user has provided names for parse_dates, check if those columns 
        are available. 
 
        Parameters 
        ---------- 
        columns : list 
            List of names of the dataframe. 
 
        Returns 
        ------- 
        The names of the columns which will get parsed later if a dict or list 
        is given as specification. 
 
        Raises 
        ------ 
        ValueError 
            If column to parse_date is not in dataframe. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">cols_needed: Iterable</span>
        <span class="s0">if </span><span class="s1">is_dict_like(self.parse_dates):</span>
            <span class="s1">cols_needed = itertools.chain(*self.parse_dates.values())</span>
        <span class="s0">elif </span><span class="s1">is_list_like(self.parse_dates):</span>
            <span class="s4"># a column in parse_dates could be represented</span>
            <span class="s4"># ColReference = Union[int, str]</span>
            <span class="s4"># DateGroups = List[ColReference]</span>
            <span class="s4"># ParseDates = Union[DateGroups, List[DateGroups],</span>
            <span class="s4">#     Dict[ColReference, DateGroups]]</span>
            <span class="s1">cols_needed = itertools.chain.from_iterable(</span>
                <span class="s1">col </span><span class="s0">if </span><span class="s1">is_list_like(col) </span><span class="s0">and not </span><span class="s1">isinstance(col</span><span class="s0">, </span><span class="s1">tuple) </span><span class="s0">else </span><span class="s1">[col]</span>
                <span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">self.parse_dates</span>
            <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">cols_needed = []</span>

        <span class="s1">cols_needed = list(cols_needed)</span>

        <span class="s4"># get only columns that are references using names (str), not by index</span>
        <span class="s1">missing_cols = </span><span class="s3">&quot;, &quot;</span><span class="s1">.join(</span>
            <span class="s1">sorted(</span>
                <span class="s1">{</span>
                    <span class="s1">col</span>
                    <span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">cols_needed</span>
                    <span class="s0">if </span><span class="s1">isinstance(col</span><span class="s0">, </span><span class="s1">str) </span><span class="s0">and </span><span class="s1">col </span><span class="s0">not in </span><span class="s1">columns</span>
                <span class="s1">}</span>
            <span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">missing_cols:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s3">f&quot;Missing column provided to 'parse_dates': '</span><span class="s0">{</span><span class="s1">missing_cols</span><span class="s0">}</span><span class="s3">'&quot;</span>
            <span class="s1">)</span>
        <span class="s4"># Convert positions to actual column names</span>
        <span class="s0">return </span><span class="s1">[</span>
            <span class="s1">col </span><span class="s0">if </span><span class="s1">(isinstance(col</span><span class="s0">, </span><span class="s1">str) </span><span class="s0">or </span><span class="s1">col </span><span class="s0">in </span><span class="s1">columns) </span><span class="s0">else </span><span class="s1">columns[col]</span>
            <span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">cols_needed</span>
        <span class="s1">]</span>

    <span class="s0">def </span><span class="s1">close(self) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s0">pass</span>

    <span class="s1">@final</span>
    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">_has_complex_date_col(self) -&gt; bool:</span>
        <span class="s0">return </span><span class="s1">isinstance(self.parse_dates</span><span class="s0">, </span><span class="s1">dict) </span><span class="s0">or </span><span class="s1">(</span>
            <span class="s1">isinstance(self.parse_dates</span><span class="s0">, </span><span class="s1">list)</span>
            <span class="s0">and </span><span class="s1">len(self.parse_dates) &gt; </span><span class="s2">0</span>
            <span class="s0">and </span><span class="s1">isinstance(self.parse_dates[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">list)</span>
        <span class="s1">)</span>

    <span class="s1">@final</span>
    <span class="s0">def </span><span class="s1">_should_parse_dates(self</span><span class="s0">, </span><span class="s1">i: int) -&gt; bool:</span>
        <span class="s0">if </span><span class="s1">lib.is_bool(self.parse_dates):</span>
            <span class="s0">return </span><span class="s1">bool(self.parse_dates)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">self.index_names </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">name = self.index_names[i]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">name = </span><span class="s0">None</span>
            <span class="s1">j = i </span><span class="s0">if </span><span class="s1">self.index_col </span><span class="s0">is None else </span><span class="s1">self.index_col[i]</span>

            <span class="s0">return </span><span class="s1">(j </span><span class="s0">in </span><span class="s1">self.parse_dates) </span><span class="s0">or </span><span class="s1">(</span>
                <span class="s1">name </span><span class="s0">is not None and </span><span class="s1">name </span><span class="s0">in </span><span class="s1">self.parse_dates</span>
            <span class="s1">)</span>

    <span class="s1">@final</span>
    <span class="s0">def </span><span class="s1">_extract_multi_indexer_columns(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">header</span><span class="s0">,</span>
        <span class="s1">index_names: Sequence[Hashable] | </span><span class="s0">None,</span>
        <span class="s1">passed_names: bool = </span><span class="s0">False,</span>
    <span class="s1">) -&gt; tuple[</span>
        <span class="s1">Sequence[Hashable]</span><span class="s0">, </span><span class="s1">Sequence[Hashable] | </span><span class="s0">None, </span><span class="s1">Sequence[Hashable] | </span><span class="s0">None, </span><span class="s1">bool</span>
    <span class="s1">]:</span>
        <span class="s5">&quot;&quot;&quot; 
        Extract and return the names, index_names, col_names if the column 
        names are a MultiIndex. 
 
        Parameters 
        ---------- 
        header: list of lists 
            The header rows 
        index_names: list, optional 
            The names of the future index 
        passed_names: bool, default False 
            A flag specifying if names where passed 
 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">len(header) &lt; </span><span class="s2">2</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">header[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index_names</span><span class="s0">, None, </span><span class="s1">passed_names</span>

        <span class="s4"># the names are the tuples of the header that are not the index cols</span>
        <span class="s4"># 0 is the name of the index, assuming index_col is a list of column</span>
        <span class="s4"># numbers</span>
        <span class="s1">ic = self.index_col</span>
        <span class="s0">if </span><span class="s1">ic </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">ic = []</span>

        <span class="s0">if not </span><span class="s1">isinstance(ic</span><span class="s0">, </span><span class="s1">(list</span><span class="s0">, </span><span class="s1">tuple</span><span class="s0">, </span><span class="s1">np.ndarray)):</span>
            <span class="s1">ic = [ic]</span>
        <span class="s1">sic = set(ic)</span>

        <span class="s4"># clean the index_names</span>
        <span class="s1">index_names = header.pop(-</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">index_names</span><span class="s0">, </span><span class="s1">_</span><span class="s0">, </span><span class="s1">_ = self._clean_index_names(index_names</span><span class="s0">, </span><span class="s1">self.index_col)</span>

        <span class="s4"># extract the columns</span>
        <span class="s1">field_count = len(header[</span><span class="s2">0</span><span class="s1">])</span>

        <span class="s4"># check if header lengths are equal</span>
        <span class="s0">if not </span><span class="s1">all(len(header_iter) == field_count </span><span class="s0">for </span><span class="s1">header_iter </span><span class="s0">in </span><span class="s1">header[</span><span class="s2">1</span><span class="s1">:]):</span>
            <span class="s0">raise </span><span class="s1">ParserError(</span><span class="s3">&quot;Header rows must have an equal number of columns.&quot;</span><span class="s1">)</span>

        <span class="s0">def </span><span class="s1">extract(r):</span>
            <span class="s0">return </span><span class="s1">tuple(r[i] </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(field_count) </span><span class="s0">if </span><span class="s1">i </span><span class="s0">not in </span><span class="s1">sic)</span>

        <span class="s1">columns = list(zip(*(extract(r) </span><span class="s0">for </span><span class="s1">r </span><span class="s0">in </span><span class="s1">header)))</span>
        <span class="s1">names = columns.copy()</span>
        <span class="s0">for </span><span class="s1">single_ic </span><span class="s0">in </span><span class="s1">sorted(ic):</span>
            <span class="s1">names.insert(single_ic</span><span class="s0">, </span><span class="s1">single_ic)</span>

        <span class="s4"># Clean the column names (if we have an index_col).</span>
        <span class="s0">if </span><span class="s1">len(ic):</span>
            <span class="s1">col_names = [</span>
                <span class="s1">r[ic[</span><span class="s2">0</span><span class="s1">]]</span>
                <span class="s0">if </span><span class="s1">((r[ic[</span><span class="s2">0</span><span class="s1">]] </span><span class="s0">is not None</span><span class="s1">) </span><span class="s0">and </span><span class="s1">r[ic[</span><span class="s2">0</span><span class="s1">]] </span><span class="s0">not in </span><span class="s1">self.unnamed_cols)</span>
                <span class="s0">else None</span>
                <span class="s0">for </span><span class="s1">r </span><span class="s0">in </span><span class="s1">header</span>
            <span class="s1">]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">col_names = [</span><span class="s0">None</span><span class="s1">] * len(header)</span>

        <span class="s1">passed_names = </span><span class="s0">True</span>

        <span class="s0">return </span><span class="s1">names</span><span class="s0">, </span><span class="s1">index_names</span><span class="s0">, </span><span class="s1">col_names</span><span class="s0">, </span><span class="s1">passed_names</span>

    <span class="s1">@final</span>
    <span class="s0">def </span><span class="s1">_maybe_make_multi_index_columns(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">columns: Sequence[Hashable]</span><span class="s0">,</span>
        <span class="s1">col_names: Sequence[Hashable] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">) -&gt; Sequence[Hashable] | MultiIndex:</span>
        <span class="s4"># possibly create a column mi here</span>
        <span class="s0">if </span><span class="s1">is_potential_multi_index(columns):</span>
            <span class="s1">list_columns = cast(list[tuple]</span><span class="s0">, </span><span class="s1">columns)</span>
            <span class="s0">return </span><span class="s1">MultiIndex.from_tuples(list_columns</span><span class="s0">, </span><span class="s1">names=col_names)</span>
        <span class="s0">return </span><span class="s1">columns</span>

    <span class="s1">@final</span>
    <span class="s0">def </span><span class="s1">_make_index(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">alldata</span><span class="s0">, </span><span class="s1">columns</span><span class="s0">, </span><span class="s1">indexnamerow: list[Scalar] | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span>
    <span class="s1">) -&gt; tuple[Index | </span><span class="s0">None, </span><span class="s1">Sequence[Hashable] | MultiIndex]:</span>
        <span class="s1">index: Index | </span><span class="s0">None</span>
        <span class="s0">if not </span><span class="s1">is_index_col(self.index_col) </span><span class="s0">or not </span><span class="s1">self.index_col:</span>
            <span class="s1">index = </span><span class="s0">None</span>

        <span class="s0">elif not </span><span class="s1">self._has_complex_date_col:</span>
            <span class="s1">simple_index = self._get_simple_index(alldata</span><span class="s0">, </span><span class="s1">columns)</span>
            <span class="s1">index = self._agg_index(simple_index)</span>
        <span class="s0">elif </span><span class="s1">self._has_complex_date_col:</span>
            <span class="s0">if not </span><span class="s1">self._name_processed:</span>
                <span class="s1">(self.index_names</span><span class="s0">, </span><span class="s1">_</span><span class="s0">, </span><span class="s1">self.index_col) = self._clean_index_names(</span>
                    <span class="s1">list(columns)</span><span class="s0">, </span><span class="s1">self.index_col</span>
                <span class="s1">)</span>
                <span class="s1">self._name_processed = </span><span class="s0">True</span>
            <span class="s1">date_index = self._get_complex_date_index(data</span><span class="s0">, </span><span class="s1">columns)</span>
            <span class="s1">index = self._agg_index(date_index</span><span class="s0">, </span><span class="s1">try_parse_dates=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s4"># add names for the index</span>
        <span class="s0">if </span><span class="s1">indexnamerow:</span>
            <span class="s1">coffset = len(indexnamerow) - len(columns)</span>
            <span class="s0">assert </span><span class="s1">index </span><span class="s0">is not None</span>
            <span class="s1">index = index.set_names(indexnamerow[:coffset])</span>

        <span class="s4"># maybe create a mi on the columns</span>
        <span class="s1">columns = self._maybe_make_multi_index_columns(columns</span><span class="s0">, </span><span class="s1">self.col_names)</span>

        <span class="s0">return </span><span class="s1">index</span><span class="s0">, </span><span class="s1">columns</span>

    <span class="s1">@final</span>
    <span class="s0">def </span><span class="s1">_get_simple_index(self</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">columns):</span>
        <span class="s0">def </span><span class="s1">ix(col):</span>
            <span class="s0">if not </span><span class="s1">isinstance(col</span><span class="s0">, </span><span class="s1">str):</span>
                <span class="s0">return </span><span class="s1">col</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;Index </span><span class="s0">{</span><span class="s1">col</span><span class="s0">} </span><span class="s3">invalid&quot;</span><span class="s1">)</span>

        <span class="s1">to_remove = []</span>
        <span class="s1">index = []</span>
        <span class="s0">for </span><span class="s1">idx </span><span class="s0">in </span><span class="s1">self.index_col:</span>
            <span class="s1">i = ix(idx)</span>
            <span class="s1">to_remove.append(i)</span>
            <span class="s1">index.append(data[i])</span>

        <span class="s4"># remove index items from content and columns, don't pop in</span>
        <span class="s4"># loop</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">sorted(to_remove</span><span class="s0">, </span><span class="s1">reverse=</span><span class="s0">True</span><span class="s1">):</span>
            <span class="s1">data.pop(i)</span>
            <span class="s0">if not </span><span class="s1">self._implicit_index:</span>
                <span class="s1">columns.pop(i)</span>

        <span class="s0">return </span><span class="s1">index</span>

    <span class="s1">@final</span>
    <span class="s0">def </span><span class="s1">_get_complex_date_index(self</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">col_names):</span>
        <span class="s0">def </span><span class="s1">_get_name(icol):</span>
            <span class="s0">if </span><span class="s1">isinstance(icol</span><span class="s0">, </span><span class="s1">str):</span>
                <span class="s0">return </span><span class="s1">icol</span>

            <span class="s0">if </span><span class="s1">col_names </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;Must supply column order to use </span><span class="s0">{</span><span class="s1">icol</span><span class="s0">!s} </span><span class="s3">as index&quot;</span><span class="s1">)</span>

            <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">c </span><span class="s0">in </span><span class="s1">enumerate(col_names):</span>
                <span class="s0">if </span><span class="s1">i == icol:</span>
                    <span class="s0">return </span><span class="s1">c</span>

        <span class="s1">to_remove = []</span>
        <span class="s1">index = []</span>
        <span class="s0">for </span><span class="s1">idx </span><span class="s0">in </span><span class="s1">self.index_col:</span>
            <span class="s1">name = _get_name(idx)</span>
            <span class="s1">to_remove.append(name)</span>
            <span class="s1">index.append(data[name])</span>

        <span class="s4"># remove index items from content and columns, don't pop in</span>
        <span class="s4"># loop</span>
        <span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">sorted(to_remove</span><span class="s0">, </span><span class="s1">reverse=</span><span class="s0">True</span><span class="s1">):</span>
            <span class="s1">data.pop(c)</span>
            <span class="s1">col_names.remove(c)</span>

        <span class="s0">return </span><span class="s1">index</span>

    <span class="s1">@final</span>
    <span class="s0">def </span><span class="s1">_clean_mapping(self</span><span class="s0">, </span><span class="s1">mapping):</span>
        <span class="s5">&quot;&quot;&quot;converts col numbers to names&quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">isinstance(mapping</span><span class="s0">, </span><span class="s1">dict):</span>
            <span class="s0">return </span><span class="s1">mapping</span>
        <span class="s1">clean = {}</span>
        <span class="s4"># for mypy</span>
        <span class="s0">assert </span><span class="s1">self.orig_names </span><span class="s0">is not None</span>

        <span class="s0">for </span><span class="s1">col</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">mapping.items():</span>
            <span class="s0">if </span><span class="s1">isinstance(col</span><span class="s0">, </span><span class="s1">int) </span><span class="s0">and </span><span class="s1">col </span><span class="s0">not in </span><span class="s1">self.orig_names:</span>
                <span class="s1">col = self.orig_names[col]</span>
            <span class="s1">clean[col] = v</span>
        <span class="s0">if </span><span class="s1">isinstance(mapping</span><span class="s0">, </span><span class="s1">defaultdict):</span>
            <span class="s1">remaining_cols = set(self.orig_names) - set(clean.keys())</span>
            <span class="s1">clean.update({col: mapping[col] </span><span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">remaining_cols})</span>
        <span class="s0">return </span><span class="s1">clean</span>

    <span class="s1">@final</span>
    <span class="s0">def </span><span class="s1">_agg_index(self</span><span class="s0">, </span><span class="s1">index</span><span class="s0">, </span><span class="s1">try_parse_dates: bool = </span><span class="s0">True</span><span class="s1">) -&gt; Index:</span>
        <span class="s1">arrays = []</span>
        <span class="s1">converters = self._clean_mapping(self.converters)</span>

        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">arr </span><span class="s0">in </span><span class="s1">enumerate(index):</span>
            <span class="s0">if </span><span class="s1">try_parse_dates </span><span class="s0">and </span><span class="s1">self._should_parse_dates(i):</span>
                <span class="s1">arr = self._date_conv(</span>
                    <span class="s1">arr</span><span class="s0">,</span>
                    <span class="s1">col=self.index_names[i] </span><span class="s0">if </span><span class="s1">self.index_names </span><span class="s0">is not None else None,</span>
                <span class="s1">)</span>

            <span class="s0">if </span><span class="s1">self.na_filter:</span>
                <span class="s1">col_na_values = self.na_values</span>
                <span class="s1">col_na_fvalues = self.na_fvalues</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">col_na_values = set()</span>
                <span class="s1">col_na_fvalues = set()</span>

            <span class="s0">if </span><span class="s1">isinstance(self.na_values</span><span class="s0">, </span><span class="s1">dict):</span>
                <span class="s0">assert </span><span class="s1">self.index_names </span><span class="s0">is not None</span>
                <span class="s1">col_name = self.index_names[i]</span>
                <span class="s0">if </span><span class="s1">col_name </span><span class="s0">is not None</span><span class="s1">:</span>
                    <span class="s1">col_na_values</span><span class="s0">, </span><span class="s1">col_na_fvalues = _get_na_values(</span>
                        <span class="s1">col_name</span><span class="s0">, </span><span class="s1">self.na_values</span><span class="s0">, </span><span class="s1">self.na_fvalues</span><span class="s0">, </span><span class="s1">self.keep_default_na</span>
                    <span class="s1">)</span>

            <span class="s1">clean_dtypes = self._clean_mapping(self.dtype)</span>

            <span class="s1">cast_type = </span><span class="s0">None</span>
            <span class="s1">index_converter = </span><span class="s0">False</span>
            <span class="s0">if </span><span class="s1">self.index_names </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">isinstance(clean_dtypes</span><span class="s0">, </span><span class="s1">dict):</span>
                    <span class="s1">cast_type = clean_dtypes.get(self.index_names[i]</span><span class="s0">, None</span><span class="s1">)</span>

                <span class="s0">if </span><span class="s1">isinstance(converters</span><span class="s0">, </span><span class="s1">dict):</span>
                    <span class="s1">index_converter = converters.get(self.index_names[i]) </span><span class="s0">is not None</span>

            <span class="s1">try_num_bool = </span><span class="s0">not </span><span class="s1">(</span>
                <span class="s1">cast_type </span><span class="s0">and </span><span class="s1">is_string_dtype(cast_type) </span><span class="s0">or </span><span class="s1">index_converter</span>
            <span class="s1">)</span>

            <span class="s1">arr</span><span class="s0">, </span><span class="s1">_ = self._infer_types(</span>
                <span class="s1">arr</span><span class="s0">, </span><span class="s1">col_na_values | col_na_fvalues</span><span class="s0">, </span><span class="s1">cast_type </span><span class="s0">is None, </span><span class="s1">try_num_bool</span>
            <span class="s1">)</span>
            <span class="s1">arrays.append(arr)</span>

        <span class="s1">names = self.index_names</span>
        <span class="s1">index = ensure_index_from_sequences(arrays</span><span class="s0">, </span><span class="s1">names)</span>

        <span class="s0">return </span><span class="s1">index</span>

    <span class="s1">@final</span>
    <span class="s0">def </span><span class="s1">_convert_to_ndarrays(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">dct: Mapping</span><span class="s0">,</span>
        <span class="s1">na_values</span><span class="s0">,</span>
        <span class="s1">na_fvalues</span><span class="s0">,</span>
        <span class="s1">verbose: bool = </span><span class="s0">False,</span>
        <span class="s1">converters=</span><span class="s0">None,</span>
        <span class="s1">dtypes=</span><span class="s0">None,</span>
    <span class="s1">):</span>
        <span class="s1">result = {}</span>
        <span class="s0">for </span><span class="s1">c</span><span class="s0">, </span><span class="s1">values </span><span class="s0">in </span><span class="s1">dct.items():</span>
            <span class="s1">conv_f = </span><span class="s0">None if </span><span class="s1">converters </span><span class="s0">is None else </span><span class="s1">converters.get(c</span><span class="s0">, None</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">isinstance(dtypes</span><span class="s0">, </span><span class="s1">dict):</span>
                <span class="s1">cast_type = dtypes.get(c</span><span class="s0">, None</span><span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s4"># single dtype or None</span>
                <span class="s1">cast_type = dtypes</span>

            <span class="s0">if </span><span class="s1">self.na_filter:</span>
                <span class="s1">col_na_values</span><span class="s0">, </span><span class="s1">col_na_fvalues = _get_na_values(</span>
                    <span class="s1">c</span><span class="s0">, </span><span class="s1">na_values</span><span class="s0">, </span><span class="s1">na_fvalues</span><span class="s0">, </span><span class="s1">self.keep_default_na</span>
                <span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">col_na_values</span><span class="s0">, </span><span class="s1">col_na_fvalues = set()</span><span class="s0">, </span><span class="s1">set()</span>

            <span class="s0">if </span><span class="s1">c </span><span class="s0">in </span><span class="s1">self._parse_date_cols:</span>
                <span class="s4"># GH#26203 Do not convert columns which get converted to dates</span>
                <span class="s4"># but replace nans to ensure to_datetime works</span>
                <span class="s1">mask = algorithms.isin(values</span><span class="s0">, </span><span class="s1">set(col_na_values) | col_na_fvalues)</span>
                <span class="s1">np.putmask(values</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">np.nan)</span>
                <span class="s1">result[c] = values</span>
                <span class="s0">continue</span>

            <span class="s0">if </span><span class="s1">conv_f </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s4"># conv_f applied to data before inference</span>
                <span class="s0">if </span><span class="s1">cast_type </span><span class="s0">is not None</span><span class="s1">:</span>
                    <span class="s1">warnings.warn(</span>
                        <span class="s1">(</span>
                            <span class="s3">&quot;Both a converter and dtype were specified &quot;</span>
                            <span class="s3">f&quot;for column </span><span class="s0">{</span><span class="s1">c</span><span class="s0">} </span><span class="s3">- only the converter will be used.&quot;</span>
                        <span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">ParserWarning</span><span class="s0">,</span>
                        <span class="s1">stacklevel=find_stack_level()</span><span class="s0">,</span>
                    <span class="s1">)</span>

                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">values = lib.map_infer(values</span><span class="s0">, </span><span class="s1">conv_f)</span>
                <span class="s0">except </span><span class="s1">ValueError:</span>
                    <span class="s1">mask = algorithms.isin(values</span><span class="s0">, </span><span class="s1">list(na_values)).view(np.uint8)</span>
                    <span class="s1">values = lib.map_infer_mask(values</span><span class="s0">, </span><span class="s1">conv_f</span><span class="s0">, </span><span class="s1">mask)</span>

                <span class="s1">cvals</span><span class="s0">, </span><span class="s1">na_count = self._infer_types(</span>
                    <span class="s1">values</span><span class="s0">,</span>
                    <span class="s1">set(col_na_values) | col_na_fvalues</span><span class="s0">,</span>
                    <span class="s1">cast_type </span><span class="s0">is None,</span>
                    <span class="s1">try_num_bool=</span><span class="s0">False,</span>
                <span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">is_ea = is_extension_array_dtype(cast_type)</span>
                <span class="s1">is_str_or_ea_dtype = is_ea </span><span class="s0">or </span><span class="s1">is_string_dtype(cast_type)</span>
                <span class="s4"># skip inference if specified dtype is object</span>
                <span class="s4"># or casting to an EA</span>
                <span class="s1">try_num_bool = </span><span class="s0">not </span><span class="s1">(cast_type </span><span class="s0">and </span><span class="s1">is_str_or_ea_dtype)</span>

                <span class="s4"># general type inference and conversion</span>
                <span class="s1">cvals</span><span class="s0">, </span><span class="s1">na_count = self._infer_types(</span>
                    <span class="s1">values</span><span class="s0">,</span>
                    <span class="s1">set(col_na_values) | col_na_fvalues</span><span class="s0">,</span>
                    <span class="s1">cast_type </span><span class="s0">is None,</span>
                    <span class="s1">try_num_bool</span><span class="s0">,</span>
                <span class="s1">)</span>

                <span class="s4"># type specified in dtype param or cast_type is an EA</span>
                <span class="s0">if </span><span class="s1">cast_type </span><span class="s0">is not None</span><span class="s1">:</span>
                    <span class="s1">cast_type = pandas_dtype(cast_type)</span>
                <span class="s0">if </span><span class="s1">cast_type </span><span class="s0">and </span><span class="s1">(cvals.dtype != cast_type </span><span class="s0">or </span><span class="s1">is_ea):</span>
                    <span class="s0">if not </span><span class="s1">is_ea </span><span class="s0">and </span><span class="s1">na_count &gt; </span><span class="s2">0</span><span class="s1">:</span>
                        <span class="s0">if </span><span class="s1">is_bool_dtype(cast_type):</span>
                            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;Bool column has NA values in column </span><span class="s0">{</span><span class="s1">c</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s1">)</span>
                    <span class="s1">cvals = self._cast_types(cvals</span><span class="s0">, </span><span class="s1">cast_type</span><span class="s0">, </span><span class="s1">c)</span>

            <span class="s1">result[c] = cvals</span>
            <span class="s0">if </span><span class="s1">verbose </span><span class="s0">and </span><span class="s1">na_count:</span>
                <span class="s1">print(</span><span class="s3">f&quot;Filled </span><span class="s0">{</span><span class="s1">na_count</span><span class="s0">} </span><span class="s3">NA values in column </span><span class="s0">{</span><span class="s1">c</span><span class="s0">!s}</span><span class="s3">&quot;</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s1">@final</span>
    <span class="s0">def </span><span class="s1">_set_noconvert_dtype_columns(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">col_indices: list[int]</span><span class="s0">, </span><span class="s1">names: Sequence[Hashable]</span>
    <span class="s1">) -&gt; set[int]:</span>
        <span class="s5">&quot;&quot;&quot; 
        Set the columns that should not undergo dtype conversions. 
 
        Currently, any column that is involved with date parsing will not 
        undergo such conversions. If usecols is specified, the positions of the columns 
        not to cast is relative to the usecols not to all columns. 
 
        Parameters 
        ---------- 
        col_indices: The indices specifying order and positions of the columns 
        names: The column names which order is corresponding with the order 
               of col_indices 
 
        Returns 
        ------- 
        A set of integers containing the positions of the columns not to convert. 
        &quot;&quot;&quot;</span>
        <span class="s1">usecols: list[int] | list[str] | </span><span class="s0">None</span>
        <span class="s1">noconvert_columns = set()</span>
        <span class="s0">if </span><span class="s1">self.usecols_dtype == </span><span class="s3">&quot;integer&quot;</span><span class="s1">:</span>
            <span class="s4"># A set of integers will be converted to a list in</span>
            <span class="s4"># the correct order every single time.</span>
            <span class="s1">usecols = sorted(self.usecols)</span>
        <span class="s0">elif </span><span class="s1">callable(self.usecols) </span><span class="s0">or </span><span class="s1">self.usecols_dtype </span><span class="s0">not in </span><span class="s1">(</span><span class="s3">&quot;empty&quot;</span><span class="s0">, None</span><span class="s1">):</span>
            <span class="s4"># The names attribute should have the correct columns</span>
            <span class="s4"># in the proper order for indexing with parse_dates.</span>
            <span class="s1">usecols = col_indices</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s4"># Usecols is empty.</span>
            <span class="s1">usecols = </span><span class="s0">None</span>

        <span class="s0">def </span><span class="s1">_set(x) -&gt; int:</span>
            <span class="s0">if </span><span class="s1">usecols </span><span class="s0">is not None and </span><span class="s1">is_integer(x):</span>
                <span class="s1">x = usecols[x]</span>

            <span class="s0">if not </span><span class="s1">is_integer(x):</span>
                <span class="s1">x = col_indices[names.index(x)]</span>

            <span class="s0">return </span><span class="s1">x</span>

        <span class="s0">if </span><span class="s1">isinstance(self.parse_dates</span><span class="s0">, </span><span class="s1">list):</span>
            <span class="s0">for </span><span class="s1">val </span><span class="s0">in </span><span class="s1">self.parse_dates:</span>
                <span class="s0">if </span><span class="s1">isinstance(val</span><span class="s0">, </span><span class="s1">list):</span>
                    <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">val:</span>
                        <span class="s1">noconvert_columns.add(_set(k))</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">noconvert_columns.add(_set(val))</span>

        <span class="s0">elif </span><span class="s1">isinstance(self.parse_dates</span><span class="s0">, </span><span class="s1">dict):</span>
            <span class="s0">for </span><span class="s1">val </span><span class="s0">in </span><span class="s1">self.parse_dates.values():</span>
                <span class="s0">if </span><span class="s1">isinstance(val</span><span class="s0">, </span><span class="s1">list):</span>
                    <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">val:</span>
                        <span class="s1">noconvert_columns.add(_set(k))</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">noconvert_columns.add(_set(val))</span>

        <span class="s0">elif </span><span class="s1">self.parse_dates:</span>
            <span class="s0">if </span><span class="s1">isinstance(self.index_col</span><span class="s0">, </span><span class="s1">list):</span>
                <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">self.index_col:</span>
                    <span class="s1">noconvert_columns.add(_set(k))</span>
            <span class="s0">elif </span><span class="s1">self.index_col </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">noconvert_columns.add(_set(self.index_col))</span>

        <span class="s0">return </span><span class="s1">noconvert_columns</span>

    <span class="s1">@final</span>
    <span class="s0">def </span><span class="s1">_infer_types(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">values</span><span class="s0">, </span><span class="s1">na_values</span><span class="s0">, </span><span class="s1">no_dtype_specified</span><span class="s0">, </span><span class="s1">try_num_bool: bool = </span><span class="s0">True</span>
    <span class="s1">) -&gt; tuple[ArrayLike</span><span class="s0">, </span><span class="s1">int]:</span>
        <span class="s5">&quot;&quot;&quot; 
        Infer types of values, possibly casting 
 
        Parameters 
        ---------- 
        values : ndarray 
        na_values : set 
        no_dtype_specified: Specifies if we want to cast explicitly 
        try_num_bool : bool, default try 
           try to cast values to numeric (first preference) or boolean 
 
        Returns 
        ------- 
        converted : ndarray or ExtensionArray 
        na_count : int 
        &quot;&quot;&quot;</span>
        <span class="s1">na_count = </span><span class="s2">0</span>
        <span class="s0">if </span><span class="s1">issubclass(values.dtype.type</span><span class="s0">, </span><span class="s1">(np.number</span><span class="s0">, </span><span class="s1">np.bool_)):</span>
            <span class="s4"># If our array has numeric dtype, we don't have to check for strings in isin</span>
            <span class="s1">na_values = np.array([val </span><span class="s0">for </span><span class="s1">val </span><span class="s0">in </span><span class="s1">na_values </span><span class="s0">if not </span><span class="s1">isinstance(val</span><span class="s0">, </span><span class="s1">str)])</span>
            <span class="s1">mask = algorithms.isin(values</span><span class="s0">, </span><span class="s1">na_values)</span>
            <span class="s1">na_count = mask.astype(</span><span class="s3">&quot;uint8&quot;</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">).sum()</span>
            <span class="s0">if </span><span class="s1">na_count &gt; </span><span class="s2">0</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">is_integer_dtype(values):</span>
                    <span class="s1">values = values.astype(np.float64)</span>
                <span class="s1">np.putmask(values</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">np.nan)</span>
            <span class="s0">return </span><span class="s1">values</span><span class="s0">, </span><span class="s1">na_count</span>

        <span class="s1">dtype_backend = self.dtype_backend</span>
        <span class="s1">non_default_dtype_backend = (</span>
            <span class="s1">no_dtype_specified </span><span class="s0">and </span><span class="s1">dtype_backend </span><span class="s0">is not </span><span class="s1">lib.no_default</span>
        <span class="s1">)</span>
        <span class="s1">result: ArrayLike</span>

        <span class="s0">if </span><span class="s1">try_num_bool </span><span class="s0">and </span><span class="s1">is_object_dtype(values.dtype):</span>
            <span class="s4"># exclude e.g DatetimeIndex here</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">result</span><span class="s0">, </span><span class="s1">result_mask = lib.maybe_convert_numeric(</span>
                    <span class="s1">values</span><span class="s0">,</span>
                    <span class="s1">na_values</span><span class="s0">,</span>
                    <span class="s0">False,</span>
                    <span class="s1">convert_to_masked_nullable=non_default_dtype_backend</span><span class="s0">,  </span><span class="s4"># type: ignore[arg-type]  # noqa: E501</span>
                <span class="s1">)</span>
            <span class="s0">except </span><span class="s1">(ValueError</span><span class="s0">, </span><span class="s1">TypeError):</span>
                <span class="s4"># e.g. encountering datetime string gets ValueError</span>
                <span class="s4">#  TypeError can be raised in floatify</span>
                <span class="s1">na_count = parsers.sanitize_objects(values</span><span class="s0">, </span><span class="s1">na_values)</span>
                <span class="s1">result = values</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">non_default_dtype_backend:</span>
                    <span class="s0">if </span><span class="s1">result_mask </span><span class="s0">is None</span><span class="s1">:</span>
                        <span class="s1">result_mask = np.zeros(result.shape</span><span class="s0">, </span><span class="s1">dtype=np.bool_)</span>

                    <span class="s0">if </span><span class="s1">result_mask.all():</span>
                        <span class="s1">result = IntegerArray(</span>
                            <span class="s1">np.ones(result_mask.shape</span><span class="s0">, </span><span class="s1">dtype=np.int64)</span><span class="s0">, </span><span class="s1">result_mask</span>
                        <span class="s1">)</span>
                    <span class="s0">elif </span><span class="s1">is_integer_dtype(result):</span>
                        <span class="s1">result = IntegerArray(result</span><span class="s0">, </span><span class="s1">result_mask)</span>
                    <span class="s0">elif </span><span class="s1">is_bool_dtype(result):</span>
                        <span class="s1">result = BooleanArray(result</span><span class="s0">, </span><span class="s1">result_mask)</span>
                    <span class="s0">elif </span><span class="s1">is_float_dtype(result):</span>
                        <span class="s1">result = FloatingArray(result</span><span class="s0">, </span><span class="s1">result_mask)</span>

                    <span class="s1">na_count = result_mask.sum()</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">na_count = isna(result).sum()</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">result = values</span>
            <span class="s0">if </span><span class="s1">values.dtype == np.object_:</span>
                <span class="s1">na_count = parsers.sanitize_objects(values</span><span class="s0">, </span><span class="s1">na_values)</span>

        <span class="s0">if </span><span class="s1">result.dtype == np.object_ </span><span class="s0">and </span><span class="s1">try_num_bool:</span>
            <span class="s1">result</span><span class="s0">, </span><span class="s1">bool_mask = libops.maybe_convert_bool(</span>
                <span class="s1">np.asarray(values)</span><span class="s0">,</span>
                <span class="s1">true_values=self.true_values</span><span class="s0">,</span>
                <span class="s1">false_values=self.false_values</span><span class="s0">,</span>
                <span class="s1">convert_to_masked_nullable=non_default_dtype_backend</span><span class="s0">,  </span><span class="s4"># type: ignore[arg-type]  # noqa: E501</span>
            <span class="s1">)</span>
            <span class="s0">if </span><span class="s1">result.dtype == np.bool_ </span><span class="s0">and </span><span class="s1">non_default_dtype_backend:</span>
                <span class="s0">if </span><span class="s1">bool_mask </span><span class="s0">is None</span><span class="s1">:</span>
                    <span class="s1">bool_mask = np.zeros(result.shape</span><span class="s0">, </span><span class="s1">dtype=np.bool_)</span>
                <span class="s1">result = BooleanArray(result</span><span class="s0">, </span><span class="s1">bool_mask)</span>
            <span class="s0">elif </span><span class="s1">result.dtype == np.object_ </span><span class="s0">and </span><span class="s1">non_default_dtype_backend:</span>
                <span class="s4"># read_excel sends array of datetime objects</span>
                <span class="s0">if not </span><span class="s1">lib.is_datetime_array(result</span><span class="s0">, </span><span class="s1">skipna=</span><span class="s0">True</span><span class="s1">):</span>
                    <span class="s1">result = StringDtype().construct_array_type()._from_sequence(values)</span>

        <span class="s0">if </span><span class="s1">dtype_backend == </span><span class="s3">&quot;pyarrow&quot;</span><span class="s1">:</span>
            <span class="s1">pa = import_optional_dependency(</span><span class="s3">&quot;pyarrow&quot;</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">isinstance(result</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
                <span class="s1">result = ArrowExtensionArray(pa.array(result</span><span class="s0">, </span><span class="s1">from_pandas=</span><span class="s0">True</span><span class="s1">))</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s4"># ExtensionArray</span>
                <span class="s1">result = ArrowExtensionArray(</span>
                    <span class="s1">pa.array(result.to_numpy()</span><span class="s0">, </span><span class="s1">from_pandas=</span><span class="s0">True</span><span class="s1">)</span>
                <span class="s1">)</span>

        <span class="s0">return </span><span class="s1">result</span><span class="s0">, </span><span class="s1">na_count</span>

    <span class="s1">@final</span>
    <span class="s0">def </span><span class="s1">_cast_types(self</span><span class="s0">, </span><span class="s1">values: ArrayLike</span><span class="s0">, </span><span class="s1">cast_type: DtypeObj</span><span class="s0">, </span><span class="s1">column) -&gt; ArrayLike:</span>
        <span class="s5">&quot;&quot;&quot; 
        Cast values to specified type 
 
        Parameters 
        ---------- 
        values : ndarray or ExtensionArray 
        cast_type : np.dtype or ExtensionDtype 
           dtype to cast values to 
        column : string 
            column name - used only for error reporting 
 
        Returns 
        ------- 
        converted : ndarray or ExtensionArray 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance(cast_type</span><span class="s0">, </span><span class="s1">CategoricalDtype):</span>
            <span class="s1">known_cats = cast_type.categories </span><span class="s0">is not None</span>

            <span class="s0">if not </span><span class="s1">is_object_dtype(values.dtype) </span><span class="s0">and not </span><span class="s1">known_cats:</span>
                <span class="s4"># TODO: this is for consistency with</span>
                <span class="s4"># c-parser which parses all categories</span>
                <span class="s4"># as strings</span>
                <span class="s1">values = lib.ensure_string_array(</span>
                    <span class="s1">values</span><span class="s0">, </span><span class="s1">skipna=</span><span class="s0">False, </span><span class="s1">convert_na_value=</span><span class="s0">False</span>
                <span class="s1">)</span>

            <span class="s1">cats = Index(values).unique().dropna()</span>
            <span class="s1">values = Categorical._from_inferred_categories(</span>
                <span class="s1">cats</span><span class="s0">, </span><span class="s1">cats.get_indexer(values)</span><span class="s0">, </span><span class="s1">cast_type</span><span class="s0">, </span><span class="s1">true_values=self.true_values</span>
            <span class="s1">)</span>

        <span class="s4"># use the EA's implementation of casting</span>
        <span class="s0">elif </span><span class="s1">isinstance(cast_type</span><span class="s0">, </span><span class="s1">ExtensionDtype):</span>
            <span class="s1">array_type = cast_type.construct_array_type()</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">isinstance(cast_type</span><span class="s0">, </span><span class="s1">BooleanDtype):</span>
                    <span class="s4"># error: Unexpected keyword argument &quot;true_values&quot; for</span>
                    <span class="s4"># &quot;_from_sequence_of_strings&quot; of &quot;ExtensionArray&quot;</span>
                    <span class="s0">return </span><span class="s1">array_type._from_sequence_of_strings(  </span><span class="s4"># type: ignore[call-arg]  # noqa: E501</span>
                        <span class="s1">values</span><span class="s0">,</span>
                        <span class="s1">dtype=cast_type</span><span class="s0">,</span>
                        <span class="s1">true_values=self.true_values</span><span class="s0">,</span>
                        <span class="s1">false_values=self.false_values</span><span class="s0">,</span>
                    <span class="s1">)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s1">array_type._from_sequence_of_strings(values</span><span class="s0">, </span><span class="s1">dtype=cast_type)</span>
            <span class="s0">except </span><span class="s1">NotImplementedError </span><span class="s0">as </span><span class="s1">err:</span>
                <span class="s0">raise </span><span class="s1">NotImplementedError(</span>
                    <span class="s3">f&quot;Extension Array: </span><span class="s0">{</span><span class="s1">array_type</span><span class="s0">} </span><span class="s3">must implement &quot;</span>
                    <span class="s3">&quot;_from_sequence_of_strings in order to be used in parser methods&quot;</span>
                <span class="s1">) </span><span class="s0">from </span><span class="s1">err</span>

        <span class="s0">elif </span><span class="s1">isinstance(values</span><span class="s0">, </span><span class="s1">ExtensionArray):</span>
            <span class="s1">values = values.astype(cast_type</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">issubclass(cast_type.type</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s4"># TODO: why skipna=True here and False above? some tests depend</span>
            <span class="s4">#  on it here, but nothing fails if we change it above</span>
            <span class="s4">#  (as no tests get there as of 2022-12-06)</span>
            <span class="s1">values = lib.ensure_string_array(</span>
                <span class="s1">values</span><span class="s0">, </span><span class="s1">skipna=</span><span class="s0">True, </span><span class="s1">convert_na_value=</span><span class="s0">False</span>
            <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">values = astype_array(values</span><span class="s0">, </span><span class="s1">cast_type</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s0">except </span><span class="s1">ValueError </span><span class="s0">as </span><span class="s1">err:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">f&quot;Unable to convert column </span><span class="s0">{</span><span class="s1">column</span><span class="s0">} </span><span class="s3">to type </span><span class="s0">{</span><span class="s1">cast_type</span><span class="s0">}</span><span class="s3">&quot;</span>
                <span class="s1">) </span><span class="s0">from </span><span class="s1">err</span>
        <span class="s0">return </span><span class="s1">values</span>

    <span class="s1">@overload</span>
    <span class="s0">def </span><span class="s1">_do_date_conversions(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">names: Index</span><span class="s0">,</span>
        <span class="s1">data: DataFrame</span><span class="s0">,</span>
    <span class="s1">) -&gt; tuple[Sequence[Hashable] | Index</span><span class="s0">, </span><span class="s1">DataFrame]:</span>
        <span class="s1">...</span>

    <span class="s1">@overload</span>
    <span class="s0">def </span><span class="s1">_do_date_conversions(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">names: Sequence[Hashable]</span><span class="s0">,</span>
        <span class="s1">data: Mapping[Hashable</span><span class="s0">, </span><span class="s1">ArrayLike]</span><span class="s0">,</span>
    <span class="s1">) -&gt; tuple[Sequence[Hashable]</span><span class="s0">, </span><span class="s1">Mapping[Hashable</span><span class="s0">, </span><span class="s1">ArrayLike]]:</span>
        <span class="s1">...</span>

    <span class="s1">@final</span>
    <span class="s0">def </span><span class="s1">_do_date_conversions(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">names: Sequence[Hashable] | Index</span><span class="s0">,</span>
        <span class="s1">data: Mapping[Hashable</span><span class="s0">, </span><span class="s1">ArrayLike] | DataFrame</span><span class="s0">,</span>
    <span class="s1">) -&gt; tuple[Sequence[Hashable] | Index</span><span class="s0">, </span><span class="s1">Mapping[Hashable</span><span class="s0">, </span><span class="s1">ArrayLike] | DataFrame]:</span>
        <span class="s4"># returns data, columns</span>

        <span class="s0">if </span><span class="s1">self.parse_dates </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">data</span><span class="s0">, </span><span class="s1">names = _process_date_conversion(</span>
                <span class="s1">data</span><span class="s0">,</span>
                <span class="s1">self._date_conv</span><span class="s0">,</span>
                <span class="s1">self.parse_dates</span><span class="s0">,</span>
                <span class="s1">self.index_col</span><span class="s0">,</span>
                <span class="s1">self.index_names</span><span class="s0">,</span>
                <span class="s1">names</span><span class="s0">,</span>
                <span class="s1">keep_date_col=self.keep_date_col</span><span class="s0">,</span>
                <span class="s1">dtype_backend=self.dtype_backend</span><span class="s0">,</span>
            <span class="s1">)</span>

        <span class="s0">return </span><span class="s1">names</span><span class="s0">, </span><span class="s1">data</span>

    <span class="s1">@final</span>
    <span class="s0">def </span><span class="s1">_check_data_length(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">columns: Sequence[Hashable]</span><span class="s0">,</span>
        <span class="s1">data: Sequence[ArrayLike]</span><span class="s0">,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s5">&quot;&quot;&quot;Checks if length of data is equal to length of column names. 
 
        One set of trailing commas is allowed. self.index_col not False 
        results in a ParserError previously when lengths do not match. 
 
        Parameters 
        ---------- 
        columns: list of column names 
        data: list of array-likes containing the data column-wise. 
        &quot;&quot;&quot;</span>
        <span class="s0">if not </span><span class="s1">self.index_col </span><span class="s0">and </span><span class="s1">len(columns) != len(data) </span><span class="s0">and </span><span class="s1">columns:</span>
            <span class="s1">empty_str = is_object_dtype(data[-</span><span class="s2">1</span><span class="s1">]) </span><span class="s0">and </span><span class="s1">data[-</span><span class="s2">1</span><span class="s1">] == </span><span class="s3">&quot;&quot;</span>
            <span class="s4"># error: No overload variant of &quot;__ror__&quot; of &quot;ndarray&quot; matches</span>
            <span class="s4"># argument type &quot;ExtensionArray&quot;</span>
            <span class="s1">empty_str_or_na = empty_str | isna(data[-</span><span class="s2">1</span><span class="s1">])  </span><span class="s4"># type: ignore[operator]</span>
            <span class="s0">if </span><span class="s1">len(columns) == len(data) - </span><span class="s2">1 </span><span class="s0">and </span><span class="s1">np.all(empty_str_or_na):</span>
                <span class="s0">return</span>
            <span class="s1">warnings.warn(</span>
                <span class="s3">&quot;Length of header or names does not match length of data. This leads &quot;</span>
                <span class="s3">&quot;to a loss of data with index_col=False.&quot;</span><span class="s0">,</span>
                <span class="s1">ParserWarning</span><span class="s0">,</span>
                <span class="s1">stacklevel=find_stack_level()</span><span class="s0">,</span>
            <span class="s1">)</span>

    <span class="s1">@overload</span>
    <span class="s0">def </span><span class="s1">_evaluate_usecols(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">usecols: set[int] | Callable[[Hashable]</span><span class="s0">, </span><span class="s1">object]</span><span class="s0">,</span>
        <span class="s1">names: Sequence[Hashable]</span><span class="s0">,</span>
    <span class="s1">) -&gt; set[int]:</span>
        <span class="s1">...</span>

    <span class="s1">@overload</span>
    <span class="s0">def </span><span class="s1">_evaluate_usecols(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">usecols: set[str]</span><span class="s0">, </span><span class="s1">names: Sequence[Hashable]</span>
    <span class="s1">) -&gt; set[str]:</span>
        <span class="s1">...</span>

    <span class="s1">@final</span>
    <span class="s0">def </span><span class="s1">_evaluate_usecols(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">usecols: Callable[[Hashable]</span><span class="s0">, </span><span class="s1">object] | set[str] | set[int]</span><span class="s0">,</span>
        <span class="s1">names: Sequence[Hashable]</span><span class="s0">,</span>
    <span class="s1">) -&gt; set[str] | set[int]:</span>
        <span class="s5">&quot;&quot;&quot; 
        Check whether or not the 'usecols' parameter 
        is a callable.  If so, enumerates the 'names' 
        parameter and returns a set of indices for 
        each entry in 'names' that evaluates to True. 
        If not a callable, returns 'usecols'. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">callable(usecols):</span>
            <span class="s0">return </span><span class="s1">{i </span><span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">name </span><span class="s0">in </span><span class="s1">enumerate(names) </span><span class="s0">if </span><span class="s1">usecols(name)}</span>
        <span class="s0">return </span><span class="s1">usecols</span>

    <span class="s1">@final</span>
    <span class="s0">def </span><span class="s1">_validate_usecols_names(self</span><span class="s0">, </span><span class="s1">usecols</span><span class="s0">, </span><span class="s1">names: Sequence):</span>
        <span class="s5">&quot;&quot;&quot; 
        Validates that all usecols are present in a given 
        list of names. If not, raise a ValueError that 
        shows what usecols are missing. 
 
        Parameters 
        ---------- 
        usecols : iterable of usecols 
            The columns to validate are present in names. 
        names : iterable of names 
            The column names to check against. 
 
        Returns 
        ------- 
        usecols : iterable of usecols 
            The `usecols` parameter if the validation succeeds. 
 
        Raises 
        ------ 
        ValueError : Columns were missing. Error message will list them. 
        &quot;&quot;&quot;</span>
        <span class="s1">missing = [c </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">usecols </span><span class="s0">if </span><span class="s1">c </span><span class="s0">not in </span><span class="s1">names]</span>
        <span class="s0">if </span><span class="s1">len(missing) &gt; </span><span class="s2">0</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s3">f&quot;Usecols do not match columns, columns expected but not found: &quot;</span>
                <span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">missing</span><span class="s0">}</span><span class="s3">&quot;</span>
            <span class="s1">)</span>

        <span class="s0">return </span><span class="s1">usecols</span>

    <span class="s1">@final</span>
    <span class="s0">def </span><span class="s1">_validate_usecols_arg(self</span><span class="s0">, </span><span class="s1">usecols):</span>
        <span class="s5">&quot;&quot;&quot; 
        Validate the 'usecols' parameter. 
 
        Checks whether or not the 'usecols' parameter contains all integers 
        (column selection by index), strings (column by name) or is a callable. 
        Raises a ValueError if that is not the case. 
 
        Parameters 
        ---------- 
        usecols : list-like, callable, or None 
            List of columns to use when parsing or a callable that can be used 
            to filter a list of table columns. 
 
        Returns 
        ------- 
        usecols_tuple : tuple 
            A tuple of (verified_usecols, usecols_dtype). 
 
            'verified_usecols' is either a set if an array-like is passed in or 
            'usecols' if a callable or None is passed in. 
 
            'usecols_dtype` is the inferred dtype of 'usecols' if an array-like 
            is passed in or None if a callable or None is passed in. 
        &quot;&quot;&quot;</span>
        <span class="s1">msg = (</span>
            <span class="s3">&quot;'usecols' must either be list-like of all strings, all unicode, &quot;</span>
            <span class="s3">&quot;all integers or a callable.&quot;</span>
        <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">usecols </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">callable(usecols):</span>
                <span class="s0">return </span><span class="s1">usecols</span><span class="s0">, None</span>

            <span class="s0">if not </span><span class="s1">is_list_like(usecols):</span>
                <span class="s4"># see gh-20529</span>
                <span class="s4">#</span>
                <span class="s4"># Ensure it is iterable container but not string.</span>
                <span class="s0">raise </span><span class="s1">ValueError(msg)</span>

            <span class="s1">usecols_dtype = lib.infer_dtype(usecols</span><span class="s0">, </span><span class="s1">skipna=</span><span class="s0">False</span><span class="s1">)</span>

            <span class="s0">if </span><span class="s1">usecols_dtype </span><span class="s0">not in </span><span class="s1">(</span><span class="s3">&quot;empty&quot;</span><span class="s0">, </span><span class="s3">&quot;integer&quot;</span><span class="s0">, </span><span class="s3">&quot;string&quot;</span><span class="s1">):</span>
                <span class="s0">raise </span><span class="s1">ValueError(msg)</span>

            <span class="s1">usecols = set(usecols)</span>

            <span class="s0">return </span><span class="s1">usecols</span><span class="s0">, </span><span class="s1">usecols_dtype</span>
        <span class="s0">return </span><span class="s1">usecols</span><span class="s0">, None</span>

    <span class="s1">@final</span>
    <span class="s0">def </span><span class="s1">_clean_index_names(self</span><span class="s0">, </span><span class="s1">columns</span><span class="s0">, </span><span class="s1">index_col) -&gt; tuple[list | </span><span class="s0">None, </span><span class="s1">list</span><span class="s0">, </span><span class="s1">list]:</span>
        <span class="s0">if not </span><span class="s1">is_index_col(index_col):</span>
            <span class="s0">return None, </span><span class="s1">columns</span><span class="s0">, </span><span class="s1">index_col</span>

        <span class="s1">columns = list(columns)</span>

        <span class="s4"># In case of no rows and multiindex columns we have to set index_names to</span>
        <span class="s4"># list of Nones GH#38292</span>
        <span class="s0">if not </span><span class="s1">columns:</span>
            <span class="s0">return </span><span class="s1">[</span><span class="s0">None</span><span class="s1">] * len(index_col)</span><span class="s0">, </span><span class="s1">columns</span><span class="s0">, </span><span class="s1">index_col</span>

        <span class="s1">cp_cols = list(columns)</span>
        <span class="s1">index_names: list[str | int | </span><span class="s0">None</span><span class="s1">] = []</span>

        <span class="s4"># don't mutate</span>
        <span class="s1">index_col = list(index_col)</span>

        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">c </span><span class="s0">in </span><span class="s1">enumerate(index_col):</span>
            <span class="s0">if </span><span class="s1">isinstance(c</span><span class="s0">, </span><span class="s1">str):</span>
                <span class="s1">index_names.append(c)</span>
                <span class="s0">for </span><span class="s1">j</span><span class="s0">, </span><span class="s1">name </span><span class="s0">in </span><span class="s1">enumerate(cp_cols):</span>
                    <span class="s0">if </span><span class="s1">name == c:</span>
                        <span class="s1">index_col[i] = j</span>
                        <span class="s1">columns.remove(name)</span>
                        <span class="s0">break</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">name = cp_cols[c]</span>
                <span class="s1">columns.remove(name)</span>
                <span class="s1">index_names.append(name)</span>

        <span class="s4"># Only clean index names that were placeholders.</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">name </span><span class="s0">in </span><span class="s1">enumerate(index_names):</span>
            <span class="s0">if </span><span class="s1">isinstance(name</span><span class="s0">, </span><span class="s1">str) </span><span class="s0">and </span><span class="s1">name </span><span class="s0">in </span><span class="s1">self.unnamed_cols:</span>
                <span class="s1">index_names[i] = </span><span class="s0">None</span>

        <span class="s0">return </span><span class="s1">index_names</span><span class="s0">, </span><span class="s1">columns</span><span class="s0">, </span><span class="s1">index_col</span>

    <span class="s1">@final</span>
    <span class="s0">def </span><span class="s1">_get_empty_meta(self</span><span class="s0">, </span><span class="s1">columns</span><span class="s0">, </span><span class="s1">dtype: DtypeArg | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">columns = list(columns)</span>

        <span class="s1">index_col = self.index_col</span>
        <span class="s1">index_names = self.index_names</span>

        <span class="s4"># Convert `dtype` to a defaultdict of some kind.</span>
        <span class="s4"># This will enable us to write `dtype[col_name]`</span>
        <span class="s4"># without worrying about KeyError issues later on.</span>
        <span class="s1">dtype_dict: defaultdict[Hashable</span><span class="s0">, </span><span class="s1">Any]</span>
        <span class="s0">if not </span><span class="s1">is_dict_like(dtype):</span>
            <span class="s4"># if dtype == None, default will be object.</span>
            <span class="s1">default_dtype = dtype </span><span class="s0">or </span><span class="s1">object</span>
            <span class="s1">dtype_dict = defaultdict(</span><span class="s0">lambda</span><span class="s1">: default_dtype)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">dtype = cast(dict</span><span class="s0">, </span><span class="s1">dtype)</span>
            <span class="s1">dtype_dict = defaultdict(</span>
                <span class="s0">lambda</span><span class="s1">: object</span><span class="s0">,</span>
                <span class="s1">{columns[k] </span><span class="s0">if </span><span class="s1">is_integer(k) </span><span class="s0">else </span><span class="s1">k: v </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">dtype.items()}</span><span class="s0">,</span>
            <span class="s1">)</span>

        <span class="s4"># Even though we have no data, the &quot;index&quot; of the empty DataFrame</span>
        <span class="s4"># could for example still be an empty MultiIndex. Thus, we need to</span>
        <span class="s4"># check whether we have any index columns specified, via either:</span>
        <span class="s4">#</span>
        <span class="s4"># 1) index_col (column indices)</span>
        <span class="s4"># 2) index_names (column names)</span>
        <span class="s4">#</span>
        <span class="s4"># Both must be non-null to ensure a successful construction. Otherwise,</span>
        <span class="s4"># we have to create a generic empty Index.</span>
        <span class="s1">index: Index</span>
        <span class="s0">if </span><span class="s1">(index_col </span><span class="s0">is None or </span><span class="s1">index_col </span><span class="s0">is False</span><span class="s1">) </span><span class="s0">or </span><span class="s1">index_names </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">index = default_index(</span><span class="s2">0</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">data = [Series([]</span><span class="s0">, </span><span class="s1">dtype=dtype_dict[name]) </span><span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">index_names]</span>
            <span class="s1">index = ensure_index_from_sequences(data</span><span class="s0">, </span><span class="s1">names=index_names)</span>
            <span class="s1">index_col.sort()</span>

            <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">n </span><span class="s0">in </span><span class="s1">enumerate(index_col):</span>
                <span class="s1">columns.pop(n - i)</span>

        <span class="s1">col_dict = {</span>
            <span class="s1">col_name: Series([]</span><span class="s0">, </span><span class="s1">dtype=dtype_dict[col_name]) </span><span class="s0">for </span><span class="s1">col_name </span><span class="s0">in </span><span class="s1">columns</span>
        <span class="s1">}</span>

        <span class="s0">return </span><span class="s1">index</span><span class="s0">, </span><span class="s1">columns</span><span class="s0">, </span><span class="s1">col_dict</span>


<span class="s0">def </span><span class="s1">_make_date_converter(</span>
    <span class="s1">date_parser=lib.no_default</span><span class="s0">,</span>
    <span class="s1">dayfirst: bool = </span><span class="s0">False,</span>
    <span class="s1">cache_dates: bool = </span><span class="s0">True,</span>
    <span class="s1">date_format: dict[Hashable</span><span class="s0">, </span><span class="s1">str] | str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
<span class="s1">):</span>
    <span class="s0">if </span><span class="s1">date_parser </span><span class="s0">is not </span><span class="s1">lib.no_default:</span>
        <span class="s1">warnings.warn(</span>
            <span class="s3">&quot;The argument 'date_parser' is deprecated and will &quot;</span>
            <span class="s3">&quot;be removed in a future version. &quot;</span>
            <span class="s3">&quot;Please use 'date_format' instead, or read your data in as 'object' dtype &quot;</span>
            <span class="s3">&quot;and then call 'to_datetime'.&quot;</span><span class="s0">,</span>
            <span class="s1">FutureWarning</span><span class="s0">,</span>
            <span class="s1">stacklevel=find_stack_level()</span><span class="s0">,</span>
        <span class="s1">)</span>
    <span class="s0">if </span><span class="s1">date_parser </span><span class="s0">is not </span><span class="s1">lib.no_default </span><span class="s0">and </span><span class="s1">date_format </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;Cannot use both 'date_parser' and 'date_format'&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">unpack_if_single_element(arg):</span>
        <span class="s4"># NumPy 1.25 deprecation: https://github.com/numpy/numpy/pull/10615</span>
        <span class="s0">if </span><span class="s1">isinstance(arg</span><span class="s0">, </span><span class="s1">np.ndarray) </span><span class="s0">and </span><span class="s1">arg.ndim == </span><span class="s2">1 </span><span class="s0">and </span><span class="s1">len(arg) == </span><span class="s2">1</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">arg[</span><span class="s2">0</span><span class="s1">]</span>
        <span class="s0">return </span><span class="s1">arg</span>

    <span class="s0">def </span><span class="s1">converter(*date_cols</span><span class="s0">, </span><span class="s1">col: Hashable):</span>
        <span class="s0">if </span><span class="s1">len(date_cols) == </span><span class="s2">1 </span><span class="s0">and </span><span class="s1">date_cols[</span><span class="s2">0</span><span class="s1">].dtype.kind </span><span class="s0">in </span><span class="s3">&quot;Mm&quot;</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">date_cols[</span><span class="s2">0</span><span class="s1">]</span>

        <span class="s0">if </span><span class="s1">date_parser </span><span class="s0">is </span><span class="s1">lib.no_default:</span>
            <span class="s1">strs = parsing.concat_date_cols(date_cols)</span>
            <span class="s1">date_fmt = (</span>
                <span class="s1">date_format.get(col) </span><span class="s0">if </span><span class="s1">isinstance(date_format</span><span class="s0">, </span><span class="s1">dict) </span><span class="s0">else </span><span class="s1">date_format</span>
            <span class="s1">)</span>

            <span class="s0">with </span><span class="s1">warnings.catch_warnings():</span>
                <span class="s1">warnings.filterwarnings(</span>
                    <span class="s3">&quot;ignore&quot;</span><span class="s0">,</span>
                    <span class="s3">&quot;.*parsing datetimes with mixed time zones will raise an error&quot;</span><span class="s0">,</span>
                    <span class="s1">category=FutureWarning</span><span class="s0">,</span>
                <span class="s1">)</span>
                <span class="s1">result = tools.to_datetime(</span>
                    <span class="s1">ensure_object(strs)</span><span class="s0">,</span>
                    <span class="s1">format=date_fmt</span><span class="s0">,</span>
                    <span class="s1">utc=</span><span class="s0">False,</span>
                    <span class="s1">dayfirst=dayfirst</span><span class="s0">,</span>
                    <span class="s1">errors=</span><span class="s3">&quot;ignore&quot;</span><span class="s0">,</span>
                    <span class="s1">cache=cache_dates</span><span class="s0">,</span>
                <span class="s1">)</span>
            <span class="s0">if </span><span class="s1">isinstance(result</span><span class="s0">, </span><span class="s1">DatetimeIndex):</span>
                <span class="s1">arr = result.to_numpy()</span>
                <span class="s1">arr.flags.writeable = </span><span class="s0">True</span>
                <span class="s0">return </span><span class="s1">arr</span>
            <span class="s0">return </span><span class="s1">result._values</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s0">with </span><span class="s1">warnings.catch_warnings():</span>
                    <span class="s1">warnings.filterwarnings(</span>
                        <span class="s3">&quot;ignore&quot;</span><span class="s0">,</span>
                        <span class="s3">&quot;.*parsing datetimes with mixed time zones &quot;</span>
                        <span class="s3">&quot;will raise an error&quot;</span><span class="s0">,</span>
                        <span class="s1">category=FutureWarning</span><span class="s0">,</span>
                    <span class="s1">)</span>
                    <span class="s1">result = tools.to_datetime(</span>
                        <span class="s1">date_parser(</span>
                            <span class="s1">*(unpack_if_single_element(arg) </span><span class="s0">for </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">date_cols)</span>
                        <span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">errors=</span><span class="s3">&quot;ignore&quot;</span><span class="s0">,</span>
                        <span class="s1">cache=cache_dates</span><span class="s0">,</span>
                    <span class="s1">)</span>
                <span class="s0">if </span><span class="s1">isinstance(result</span><span class="s0">, </span><span class="s1">datetime.datetime):</span>
                    <span class="s0">raise </span><span class="s1">Exception(</span><span class="s3">&quot;scalar parser&quot;</span><span class="s1">)</span>
                <span class="s0">return </span><span class="s1">result</span>
            <span class="s0">except </span><span class="s1">Exception:</span>
                <span class="s0">with </span><span class="s1">warnings.catch_warnings():</span>
                    <span class="s1">warnings.filterwarnings(</span>
                        <span class="s3">&quot;ignore&quot;</span><span class="s0">,</span>
                        <span class="s3">&quot;.*parsing datetimes with mixed time zones &quot;</span>
                        <span class="s3">&quot;will raise an error&quot;</span><span class="s0">,</span>
                        <span class="s1">category=FutureWarning</span><span class="s0">,</span>
                    <span class="s1">)</span>
                    <span class="s0">return </span><span class="s1">tools.to_datetime(</span>
                        <span class="s1">parsing.try_parse_dates(</span>
                            <span class="s1">parsing.concat_date_cols(date_cols)</span><span class="s0">,</span>
                            <span class="s1">parser=date_parser</span><span class="s0">,</span>
                        <span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">errors=</span><span class="s3">&quot;ignore&quot;</span><span class="s0">,</span>
                    <span class="s1">)</span>

    <span class="s0">return </span><span class="s1">converter</span>


<span class="s1">parser_defaults = {</span>
    <span class="s3">&quot;delimiter&quot;</span><span class="s1">: </span><span class="s0">None,</span>
    <span class="s3">&quot;escapechar&quot;</span><span class="s1">: </span><span class="s0">None,</span>
    <span class="s3">&quot;quotechar&quot;</span><span class="s1">: </span><span class="s3">'&quot;'</span><span class="s0">,</span>
    <span class="s3">&quot;quoting&quot;</span><span class="s1">: csv.QUOTE_MINIMAL</span><span class="s0">,</span>
    <span class="s3">&quot;doublequote&quot;</span><span class="s1">: </span><span class="s0">True,</span>
    <span class="s3">&quot;skipinitialspace&quot;</span><span class="s1">: </span><span class="s0">False,</span>
    <span class="s3">&quot;lineterminator&quot;</span><span class="s1">: </span><span class="s0">None,</span>
    <span class="s3">&quot;header&quot;</span><span class="s1">: </span><span class="s3">&quot;infer&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;index_col&quot;</span><span class="s1">: </span><span class="s0">None,</span>
    <span class="s3">&quot;names&quot;</span><span class="s1">: </span><span class="s0">None,</span>
    <span class="s3">&quot;skiprows&quot;</span><span class="s1">: </span><span class="s0">None,</span>
    <span class="s3">&quot;skipfooter&quot;</span><span class="s1">: </span><span class="s2">0</span><span class="s0">,</span>
    <span class="s3">&quot;nrows&quot;</span><span class="s1">: </span><span class="s0">None,</span>
    <span class="s3">&quot;na_values&quot;</span><span class="s1">: </span><span class="s0">None,</span>
    <span class="s3">&quot;keep_default_na&quot;</span><span class="s1">: </span><span class="s0">True,</span>
    <span class="s3">&quot;true_values&quot;</span><span class="s1">: </span><span class="s0">None,</span>
    <span class="s3">&quot;false_values&quot;</span><span class="s1">: </span><span class="s0">None,</span>
    <span class="s3">&quot;converters&quot;</span><span class="s1">: </span><span class="s0">None,</span>
    <span class="s3">&quot;dtype&quot;</span><span class="s1">: </span><span class="s0">None,</span>
    <span class="s3">&quot;cache_dates&quot;</span><span class="s1">: </span><span class="s0">True,</span>
    <span class="s3">&quot;thousands&quot;</span><span class="s1">: </span><span class="s0">None,</span>
    <span class="s3">&quot;comment&quot;</span><span class="s1">: </span><span class="s0">None,</span>
    <span class="s3">&quot;decimal&quot;</span><span class="s1">: </span><span class="s3">&quot;.&quot;</span><span class="s0">,</span>
    <span class="s4"># 'engine': 'c',</span>
    <span class="s3">&quot;parse_dates&quot;</span><span class="s1">: </span><span class="s0">False,</span>
    <span class="s3">&quot;keep_date_col&quot;</span><span class="s1">: </span><span class="s0">False,</span>
    <span class="s3">&quot;dayfirst&quot;</span><span class="s1">: </span><span class="s0">False,</span>
    <span class="s3">&quot;date_parser&quot;</span><span class="s1">: lib.no_default</span><span class="s0">,</span>
    <span class="s3">&quot;date_format&quot;</span><span class="s1">: </span><span class="s0">None,</span>
    <span class="s3">&quot;usecols&quot;</span><span class="s1">: </span><span class="s0">None,</span>
    <span class="s4"># 'iterator': False,</span>
    <span class="s3">&quot;chunksize&quot;</span><span class="s1">: </span><span class="s0">None,</span>
    <span class="s3">&quot;verbose&quot;</span><span class="s1">: </span><span class="s0">False,</span>
    <span class="s3">&quot;encoding&quot;</span><span class="s1">: </span><span class="s0">None,</span>
    <span class="s3">&quot;compression&quot;</span><span class="s1">: </span><span class="s0">None,</span>
    <span class="s3">&quot;skip_blank_lines&quot;</span><span class="s1">: </span><span class="s0">True,</span>
    <span class="s3">&quot;encoding_errors&quot;</span><span class="s1">: </span><span class="s3">&quot;strict&quot;</span><span class="s0">,</span>
    <span class="s3">&quot;on_bad_lines&quot;</span><span class="s1">: ParserBase.BadLineHandleMethod.ERROR</span><span class="s0">,</span>
    <span class="s3">&quot;dtype_backend&quot;</span><span class="s1">: lib.no_default</span><span class="s0">,</span>
<span class="s1">}</span>


<span class="s0">def </span><span class="s1">_process_date_conversion(</span>
    <span class="s1">data_dict</span><span class="s0">,</span>
    <span class="s1">converter: Callable</span><span class="s0">,</span>
    <span class="s1">parse_spec</span><span class="s0">,</span>
    <span class="s1">index_col</span><span class="s0">,</span>
    <span class="s1">index_names</span><span class="s0">,</span>
    <span class="s1">columns</span><span class="s0">,</span>
    <span class="s1">keep_date_col: bool = </span><span class="s0">False,</span>
    <span class="s1">dtype_backend=lib.no_default</span><span class="s0">,</span>
<span class="s1">):</span>
    <span class="s0">def </span><span class="s1">_isindex(colspec):</span>
        <span class="s0">return </span><span class="s1">(isinstance(index_col</span><span class="s0">, </span><span class="s1">list) </span><span class="s0">and </span><span class="s1">colspec </span><span class="s0">in </span><span class="s1">index_col) </span><span class="s0">or </span><span class="s1">(</span>
            <span class="s1">isinstance(index_names</span><span class="s0">, </span><span class="s1">list) </span><span class="s0">and </span><span class="s1">colspec </span><span class="s0">in </span><span class="s1">index_names</span>
        <span class="s1">)</span>

    <span class="s1">new_cols = []</span>
    <span class="s1">new_data = {}</span>

    <span class="s1">orig_names = columns</span>
    <span class="s1">columns = list(columns)</span>

    <span class="s1">date_cols = set()</span>

    <span class="s0">if </span><span class="s1">parse_spec </span><span class="s0">is None or </span><span class="s1">isinstance(parse_spec</span><span class="s0">, </span><span class="s1">bool):</span>
        <span class="s0">return </span><span class="s1">data_dict</span><span class="s0">, </span><span class="s1">columns</span>

    <span class="s0">if </span><span class="s1">isinstance(parse_spec</span><span class="s0">, </span><span class="s1">list):</span>
        <span class="s4"># list of column lists</span>
        <span class="s0">for </span><span class="s1">colspec </span><span class="s0">in </span><span class="s1">parse_spec:</span>
            <span class="s0">if </span><span class="s1">is_scalar(colspec) </span><span class="s0">or </span><span class="s1">isinstance(colspec</span><span class="s0">, </span><span class="s1">tuple):</span>
                <span class="s0">if </span><span class="s1">isinstance(colspec</span><span class="s0">, </span><span class="s1">int) </span><span class="s0">and </span><span class="s1">colspec </span><span class="s0">not in </span><span class="s1">data_dict:</span>
                    <span class="s1">colspec = orig_names[colspec]</span>
                <span class="s0">if </span><span class="s1">_isindex(colspec):</span>
                    <span class="s0">continue</span>
                <span class="s0">elif </span><span class="s1">dtype_backend == </span><span class="s3">&quot;pyarrow&quot;</span><span class="s1">:</span>
                    <span class="s0">import </span><span class="s1">pyarrow </span><span class="s0">as </span><span class="s1">pa</span>

                    <span class="s1">dtype = data_dict[colspec].dtype</span>
                    <span class="s0">if </span><span class="s1">isinstance(dtype</span><span class="s0">, </span><span class="s1">ArrowDtype) </span><span class="s0">and </span><span class="s1">(</span>
                        <span class="s1">pa.types.is_timestamp(dtype.pyarrow_dtype)</span>
                        <span class="s0">or </span><span class="s1">pa.types.is_date(dtype.pyarrow_dtype)</span>
                    <span class="s1">):</span>
                        <span class="s0">continue</span>

                <span class="s4"># Pyarrow engine returns Series which we need to convert to</span>
                <span class="s4"># numpy array before converter, its a no-op for other parsers</span>
                <span class="s1">data_dict[colspec] = converter(</span>
                    <span class="s1">np.asarray(data_dict[colspec])</span><span class="s0">, </span><span class="s1">col=colspec</span>
                <span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">new_name</span><span class="s0">, </span><span class="s1">col</span><span class="s0">, </span><span class="s1">old_names = _try_convert_dates(</span>
                    <span class="s1">converter</span><span class="s0">, </span><span class="s1">colspec</span><span class="s0">, </span><span class="s1">data_dict</span><span class="s0">, </span><span class="s1">orig_names</span>
                <span class="s1">)</span>
                <span class="s0">if </span><span class="s1">new_name </span><span class="s0">in </span><span class="s1">data_dict:</span>
                    <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;New date column already in dict </span><span class="s0">{</span><span class="s1">new_name</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s1">)</span>
                <span class="s1">new_data[new_name] = col</span>
                <span class="s1">new_cols.append(new_name)</span>
                <span class="s1">date_cols.update(old_names)</span>

    <span class="s0">elif </span><span class="s1">isinstance(parse_spec</span><span class="s0">, </span><span class="s1">dict):</span>
        <span class="s4"># dict of new name to column list</span>
        <span class="s0">for </span><span class="s1">new_name</span><span class="s0">, </span><span class="s1">colspec </span><span class="s0">in </span><span class="s1">parse_spec.items():</span>
            <span class="s0">if </span><span class="s1">new_name </span><span class="s0">in </span><span class="s1">data_dict:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;Date column </span><span class="s0">{</span><span class="s1">new_name</span><span class="s0">} </span><span class="s3">already in dict&quot;</span><span class="s1">)</span>

            <span class="s1">_</span><span class="s0">, </span><span class="s1">col</span><span class="s0">, </span><span class="s1">old_names = _try_convert_dates(</span>
                <span class="s1">converter</span><span class="s0">,</span>
                <span class="s1">colspec</span><span class="s0">,</span>
                <span class="s1">data_dict</span><span class="s0">,</span>
                <span class="s1">orig_names</span><span class="s0">,</span>
                <span class="s1">target_name=new_name</span><span class="s0">,</span>
            <span class="s1">)</span>

            <span class="s1">new_data[new_name] = col</span>

            <span class="s4"># If original column can be converted to date we keep the converted values</span>
            <span class="s4"># This can only happen if values are from single column</span>
            <span class="s0">if </span><span class="s1">len(colspec) == </span><span class="s2">1</span><span class="s1">:</span>
                <span class="s1">new_data[colspec[</span><span class="s2">0</span><span class="s1">]] = col</span>

            <span class="s1">new_cols.append(new_name)</span>
            <span class="s1">date_cols.update(old_names)</span>

    <span class="s0">if </span><span class="s1">isinstance(data_dict</span><span class="s0">, </span><span class="s1">DataFrame):</span>
        <span class="s1">data_dict = concat([DataFrame(new_data)</span><span class="s0">, </span><span class="s1">data_dict]</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">1</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">data_dict.update(new_data)</span>
    <span class="s1">new_cols.extend(columns)</span>

    <span class="s0">if not </span><span class="s1">keep_date_col:</span>
        <span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">list(date_cols):</span>
            <span class="s1">data_dict.pop(c)</span>
            <span class="s1">new_cols.remove(c)</span>

    <span class="s0">return </span><span class="s1">data_dict</span><span class="s0">, </span><span class="s1">new_cols</span>


<span class="s0">def </span><span class="s1">_try_convert_dates(</span>
    <span class="s1">parser: Callable</span><span class="s0">, </span><span class="s1">colspec</span><span class="s0">, </span><span class="s1">data_dict</span><span class="s0">, </span><span class="s1">columns</span><span class="s0">, </span><span class="s1">target_name: str | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span>
<span class="s1">):</span>
    <span class="s1">colset = set(columns)</span>
    <span class="s1">colnames = []</span>

    <span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">colspec:</span>
        <span class="s0">if </span><span class="s1">c </span><span class="s0">in </span><span class="s1">colset:</span>
            <span class="s1">colnames.append(c)</span>
        <span class="s0">elif </span><span class="s1">isinstance(c</span><span class="s0">, </span><span class="s1">int) </span><span class="s0">and </span><span class="s1">c </span><span class="s0">not in </span><span class="s1">columns:</span>
            <span class="s1">colnames.append(columns[c])</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">colnames.append(c)</span>

    <span class="s1">new_name: tuple | str</span>
    <span class="s0">if </span><span class="s1">all(isinstance(x</span><span class="s0">, </span><span class="s1">tuple) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">colnames):</span>
        <span class="s1">new_name = tuple(map(</span><span class="s3">&quot;_&quot;</span><span class="s1">.join</span><span class="s0">, </span><span class="s1">zip(*colnames)))</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">new_name = </span><span class="s3">&quot;_&quot;</span><span class="s1">.join([str(x) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">colnames])</span>
    <span class="s1">to_parse = [np.asarray(data_dict[c]) </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">colnames </span><span class="s0">if </span><span class="s1">c </span><span class="s0">in </span><span class="s1">data_dict]</span>

    <span class="s1">new_col = parser(*to_parse</span><span class="s0">, </span><span class="s1">col=new_name </span><span class="s0">if </span><span class="s1">target_name </span><span class="s0">is None else </span><span class="s1">target_name)</span>
    <span class="s0">return </span><span class="s1">new_name</span><span class="s0">, </span><span class="s1">new_col</span><span class="s0">, </span><span class="s1">colnames</span>


<span class="s0">def </span><span class="s1">_get_na_values(col</span><span class="s0">, </span><span class="s1">na_values</span><span class="s0">, </span><span class="s1">na_fvalues</span><span class="s0">, </span><span class="s1">keep_default_na: bool):</span>
    <span class="s5">&quot;&quot;&quot; 
    Get the NaN values for a given column. 
 
    Parameters 
    ---------- 
    col : str 
        The name of the column. 
    na_values : array-like, dict 
        The object listing the NaN values as strings. 
    na_fvalues : array-like, dict 
        The object listing the NaN values as floats. 
    keep_default_na : bool 
        If `na_values` is a dict, and the column is not mapped in the 
        dictionary, whether to return the default NaN values or the empty set. 
 
    Returns 
    ------- 
    nan_tuple : A length-two tuple composed of 
 
        1) na_values : the string NaN values for that column. 
        2) na_fvalues : the float NaN values for that column. 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">isinstance(na_values</span><span class="s0">, </span><span class="s1">dict):</span>
        <span class="s0">if </span><span class="s1">col </span><span class="s0">in </span><span class="s1">na_values:</span>
            <span class="s0">return </span><span class="s1">na_values[col]</span><span class="s0">, </span><span class="s1">na_fvalues[col]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">keep_default_na:</span>
                <span class="s0">return </span><span class="s1">STR_NA_VALUES</span><span class="s0">, </span><span class="s1">set()</span>

            <span class="s0">return </span><span class="s1">set()</span><span class="s0">, </span><span class="s1">set()</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">na_values</span><span class="s0">, </span><span class="s1">na_fvalues</span>


<span class="s0">def </span><span class="s1">_validate_parse_dates_arg(parse_dates):</span>
    <span class="s5">&quot;&quot;&quot; 
    Check whether or not the 'parse_dates' parameter 
    is a non-boolean scalar. Raises a ValueError if 
    that is the case. 
    &quot;&quot;&quot;</span>
    <span class="s1">msg = (</span>
        <span class="s3">&quot;Only booleans, lists, and dictionaries are accepted &quot;</span>
        <span class="s3">&quot;for the 'parse_dates' parameter&quot;</span>
    <span class="s1">)</span>

    <span class="s0">if not </span><span class="s1">(</span>
        <span class="s1">parse_dates </span><span class="s0">is None</span>
        <span class="s0">or </span><span class="s1">lib.is_bool(parse_dates)</span>
        <span class="s0">or </span><span class="s1">isinstance(parse_dates</span><span class="s0">, </span><span class="s1">(list</span><span class="s0">, </span><span class="s1">dict))</span>
    <span class="s1">):</span>
        <span class="s0">raise </span><span class="s1">TypeError(msg)</span>

    <span class="s0">return </span><span class="s1">parse_dates</span>


<span class="s0">def </span><span class="s1">is_index_col(col) -&gt; bool:</span>
    <span class="s0">return </span><span class="s1">col </span><span class="s0">is not None and </span><span class="s1">col </span><span class="s0">is not False</span>
</pre>
</body>
</html>