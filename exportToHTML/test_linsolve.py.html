<html>
<head>
<title>test_linsolve.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6897bb;}
.s4 { color: #6a8759;}
.s5 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_linsolve.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">sys</span>
<span class="s0">import </span><span class="s1">threading</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">numpy </span><span class="s0">import </span><span class="s1">array</span><span class="s0">, </span><span class="s1">finfo</span><span class="s0">, </span><span class="s1">arange</span><span class="s0">, </span><span class="s1">eye</span><span class="s0">, </span><span class="s1">all</span><span class="s0">, </span><span class="s1">unique</span><span class="s0">, </span><span class="s1">ones</span><span class="s0">, </span><span class="s1">dot</span>
<span class="s0">import </span><span class="s1">numpy.random </span><span class="s0">as </span><span class="s1">random</span>
<span class="s0">from </span><span class="s1">numpy.testing </span><span class="s0">import </span><span class="s1">(</span>
        <span class="s1">assert_array_almost_equal</span><span class="s0">, </span><span class="s1">assert_almost_equal</span><span class="s0">,</span>
        <span class="s1">assert_equal</span><span class="s0">, </span><span class="s1">assert_array_equal</span><span class="s0">, </span><span class="s1">assert_</span><span class="s0">, </span><span class="s1">assert_allclose</span><span class="s0">,</span>
        <span class="s1">assert_warns</span><span class="s0">, </span><span class="s1">suppress_warnings)</span>
<span class="s0">import </span><span class="s1">pytest</span>
<span class="s0">from </span><span class="s1">pytest </span><span class="s0">import </span><span class="s1">raises </span><span class="s0">as </span><span class="s1">assert_raises</span>

<span class="s0">import </span><span class="s1">scipy.linalg</span>
<span class="s0">from </span><span class="s1">scipy.linalg </span><span class="s0">import </span><span class="s1">norm</span><span class="s0">, </span><span class="s1">inv</span>
<span class="s0">from </span><span class="s1">scipy.sparse </span><span class="s0">import </span><span class="s1">(spdiags</span><span class="s0">, </span><span class="s1">SparseEfficiencyWarning</span><span class="s0">, </span><span class="s1">csc_matrix</span><span class="s0">,</span>
        <span class="s1">csr_matrix</span><span class="s0">, </span><span class="s1">identity</span><span class="s0">, </span><span class="s1">issparse</span><span class="s0">, </span><span class="s1">dok_matrix</span><span class="s0">, </span><span class="s1">lil_matrix</span><span class="s0">, </span><span class="s1">bsr_matrix)</span>
<span class="s0">from </span><span class="s1">scipy.sparse.linalg </span><span class="s0">import </span><span class="s1">SuperLU</span>
<span class="s0">from </span><span class="s1">scipy.sparse.linalg._dsolve </span><span class="s0">import </span><span class="s1">(spsolve</span><span class="s0">, </span><span class="s1">use_solver</span><span class="s0">, </span><span class="s1">splu</span><span class="s0">, </span><span class="s1">spilu</span><span class="s0">,</span>
        <span class="s1">MatrixRankWarning</span><span class="s0">, </span><span class="s1">_superlu</span><span class="s0">, </span><span class="s1">spsolve_triangular</span><span class="s0">, </span><span class="s1">factorized)</span>
<span class="s0">import </span><span class="s1">scipy.sparse</span>

<span class="s0">from </span><span class="s1">scipy._lib._testutils </span><span class="s0">import </span><span class="s1">check_free_memory</span>


<span class="s1">sup_sparse_efficiency = suppress_warnings()</span>
<span class="s1">sup_sparse_efficiency.filter(SparseEfficiencyWarning)</span>

<span class="s2"># scikits.umfpack is not a SciPy dependency but it is optionally used in</span>
<span class="s2"># dsolve, so check whether it's available</span>
<span class="s0">try</span><span class="s1">:</span>
    <span class="s0">import </span><span class="s1">scikits.umfpack </span><span class="s0">as </span><span class="s1">umfpack</span>
    <span class="s1">has_umfpack = </span><span class="s0">True</span>
<span class="s0">except </span><span class="s1">ImportError:</span>
    <span class="s1">has_umfpack = </span><span class="s0">False</span>

<span class="s0">def </span><span class="s1">toarray(a):</span>
    <span class="s0">if </span><span class="s1">issparse(a):</span>
        <span class="s0">return </span><span class="s1">a.toarray()</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">a</span>


<span class="s0">def </span><span class="s1">setup_bug_8278():</span>
    <span class="s1">N = </span><span class="s3">2 </span><span class="s1">** </span><span class="s3">6</span>
    <span class="s1">h = </span><span class="s3">1</span><span class="s1">/N</span>
    <span class="s1">Ah1D = scipy.sparse.diags([-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">,</span>
                              <span class="s1">shape=(N-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">N-</span><span class="s3">1</span><span class="s1">))/(h**</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">eyeN = scipy.sparse.eye(N - </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">A = (scipy.sparse.kron(eyeN</span><span class="s0">, </span><span class="s1">scipy.sparse.kron(eyeN</span><span class="s0">, </span><span class="s1">Ah1D))</span>
         <span class="s1">+ scipy.sparse.kron(eyeN</span><span class="s0">, </span><span class="s1">scipy.sparse.kron(Ah1D</span><span class="s0">, </span><span class="s1">eyeN))</span>
         <span class="s1">+ scipy.sparse.kron(Ah1D</span><span class="s0">, </span><span class="s1">scipy.sparse.kron(eyeN</span><span class="s0">, </span><span class="s1">eyeN)))</span>
    <span class="s1">b = np.random.rand((N-</span><span class="s3">1</span><span class="s1">)**</span><span class="s3">3</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">A</span><span class="s0">, </span><span class="s1">b</span>


<span class="s0">class </span><span class="s1">TestFactorized:</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">n = </span><span class="s3">5</span>
        <span class="s1">d = arange(n) + </span><span class="s3">1</span>
        <span class="s1">self.n = n</span>
        <span class="s1">self.A = spdiags((d</span><span class="s0">, </span><span class="s3">2</span><span class="s1">*d</span><span class="s0">, </span><span class="s1">d[::-</span><span class="s3">1</span><span class="s1">])</span><span class="s0">, </span><span class="s1">(-</span><span class="s3">3</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">n).tocsc()</span>
        <span class="s1">random.seed(</span><span class="s3">1234</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_check_singular(self):</span>
        <span class="s1">A = csc_matrix((</span><span class="s3">5</span><span class="s0">,</span><span class="s3">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s4">'d'</span><span class="s1">)</span>
        <span class="s1">b = ones(</span><span class="s3">5</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(</span><span class="s3">0. </span><span class="s1">* b</span><span class="s0">, </span><span class="s1">factorized(A)(b))</span>

    <span class="s0">def </span><span class="s1">_check_non_singular(self):</span>
        <span class="s2"># Make a diagonal dominant, to make sure it is not singular</span>
        <span class="s1">n = </span><span class="s3">5</span>
        <span class="s1">a = csc_matrix(random.rand(n</span><span class="s0">, </span><span class="s1">n))</span>
        <span class="s1">b = ones(n)</span>

        <span class="s1">expected = splu(a).solve(b)</span>
        <span class="s1">assert_array_almost_equal(factorized(a)(b)</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_singular_without_umfpack(self):</span>
        <span class="s1">use_solver(useUmfpack=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">assert_raises(RuntimeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;Factor is exactly singular&quot;</span><span class="s1">):</span>
            <span class="s1">self._check_singular()</span>

    <span class="s1">@pytest.mark.skipif(</span><span class="s0">not </span><span class="s1">has_umfpack</span><span class="s0">, </span><span class="s1">reason=</span><span class="s4">&quot;umfpack not available&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_singular_with_umfpack(self):</span>
        <span class="s1">use_solver(useUmfpack=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(RuntimeWarning</span><span class="s0">, </span><span class="s4">&quot;divide by zero encountered in double_scalars&quot;</span><span class="s1">)</span>
            <span class="s1">assert_warns(umfpack.UmfpackWarning</span><span class="s0">, </span><span class="s1">self._check_singular)</span>

    <span class="s0">def </span><span class="s1">test_non_singular_without_umfpack(self):</span>
        <span class="s1">use_solver(useUmfpack=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">self._check_non_singular()</span>

    <span class="s1">@pytest.mark.skipif(</span><span class="s0">not </span><span class="s1">has_umfpack</span><span class="s0">, </span><span class="s1">reason=</span><span class="s4">&quot;umfpack not available&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_non_singular_with_umfpack(self):</span>
        <span class="s1">use_solver(useUmfpack=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">self._check_non_singular()</span>

    <span class="s0">def </span><span class="s1">test_cannot_factorize_nonsquare_matrix_without_umfpack(self):</span>
        <span class="s1">use_solver(useUmfpack=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">msg = </span><span class="s4">&quot;can only factor square matrices&quot;</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">factorized(self.A[:</span><span class="s0">, </span><span class="s1">:</span><span class="s3">4</span><span class="s1">])</span>

    <span class="s1">@pytest.mark.skipif(</span><span class="s0">not </span><span class="s1">has_umfpack</span><span class="s0">, </span><span class="s1">reason=</span><span class="s4">&quot;umfpack not available&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_factorizes_nonsquare_matrix_with_umfpack(self):</span>
        <span class="s1">use_solver(useUmfpack=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s2"># does not raise</span>
        <span class="s1">factorized(self.A[:</span><span class="s0">,</span><span class="s1">:</span><span class="s3">4</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">test_call_with_incorrectly_sized_matrix_without_umfpack(self):</span>
        <span class="s1">use_solver(useUmfpack=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">solve = factorized(self.A)</span>
        <span class="s1">b = random.rand(</span><span class="s3">4</span><span class="s1">)</span>
        <span class="s1">B = random.rand(</span><span class="s3">4</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">BB = random.rand(self.n</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">9</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;is of incompatible size&quot;</span><span class="s1">):</span>
            <span class="s1">solve(b)</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;is of incompatible size&quot;</span><span class="s1">):</span>
            <span class="s1">solve(B)</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError</span><span class="s0">,</span>
                           <span class="s1">match=</span><span class="s4">&quot;object too deep for desired array&quot;</span><span class="s1">):</span>
            <span class="s1">solve(BB)</span>

    <span class="s1">@pytest.mark.skipif(</span><span class="s0">not </span><span class="s1">has_umfpack</span><span class="s0">, </span><span class="s1">reason=</span><span class="s4">&quot;umfpack not available&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_call_with_incorrectly_sized_matrix_with_umfpack(self):</span>
        <span class="s1">use_solver(useUmfpack=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">solve = factorized(self.A)</span>
        <span class="s1">b = random.rand(</span><span class="s3">4</span><span class="s1">)</span>
        <span class="s1">B = random.rand(</span><span class="s3">4</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">BB = random.rand(self.n</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">9</span><span class="s1">)</span>

        <span class="s2"># does not raise</span>
        <span class="s1">solve(b)</span>
        <span class="s1">msg = </span><span class="s4">&quot;object too deep for desired array&quot;</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">solve(B)</span>
        <span class="s0">with </span><span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">solve(BB)</span>

    <span class="s0">def </span><span class="s1">test_call_with_cast_to_complex_without_umfpack(self):</span>
        <span class="s1">use_solver(useUmfpack=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">solve = factorized(self.A)</span>
        <span class="s1">b = random.rand(</span><span class="s3">4</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">[np.complex64</span><span class="s0">, </span><span class="s1">np.complex128]:</span>
            <span class="s0">with </span><span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;Cannot cast array data&quot;</span><span class="s1">):</span>
                <span class="s1">solve(b.astype(t))</span>

    <span class="s1">@pytest.mark.skipif(</span><span class="s0">not </span><span class="s1">has_umfpack</span><span class="s0">, </span><span class="s1">reason=</span><span class="s4">&quot;umfpack not available&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_call_with_cast_to_complex_with_umfpack(self):</span>
        <span class="s1">use_solver(useUmfpack=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">solve = factorized(self.A)</span>
        <span class="s1">b = random.rand(</span><span class="s3">4</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">[np.complex64</span><span class="s0">, </span><span class="s1">np.complex128]:</span>
            <span class="s1">assert_warns(np.ComplexWarning</span><span class="s0">, </span><span class="s1">solve</span><span class="s0">, </span><span class="s1">b.astype(t))</span>

    <span class="s1">@pytest.mark.skipif(</span><span class="s0">not </span><span class="s1">has_umfpack</span><span class="s0">, </span><span class="s1">reason=</span><span class="s4">&quot;umfpack not available&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_assume_sorted_indices_flag(self):</span>
        <span class="s2"># a sparse matrix with unsorted indices</span>
        <span class="s1">unsorted_inds = np.array([</span><span class="s3">2</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">])</span>
        <span class="s1">data = np.array([</span><span class="s3">10</span><span class="s0">, </span><span class="s3">16</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">0.4</span><span class="s1">])</span>
        <span class="s1">indptr = np.array([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">4</span><span class="s1">])</span>
        <span class="s1">A = csc_matrix((data</span><span class="s0">, </span><span class="s1">unsorted_inds</span><span class="s0">, </span><span class="s1">indptr)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>
        <span class="s1">b = ones(</span><span class="s3">3</span><span class="s1">)</span>

        <span class="s2"># should raise when incorrectly assuming indices are sorted</span>
        <span class="s1">use_solver(useUmfpack=</span><span class="s0">True, </span><span class="s1">assumeSortedIndices=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">assert_raises(RuntimeError</span><span class="s0">,</span>
                           <span class="s1">match=</span><span class="s4">&quot;UMFPACK_ERROR_invalid_matrix&quot;</span><span class="s1">):</span>
            <span class="s1">factorized(A)</span>

        <span class="s2"># should sort indices and succeed when not assuming indices are sorted</span>
        <span class="s1">use_solver(useUmfpack=</span><span class="s0">True, </span><span class="s1">assumeSortedIndices=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">expected = splu(A.copy()).solve(b)</span>

        <span class="s1">assert_equal(A.has_sorted_indices</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(factorized(A)(b)</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s1">@pytest.mark.skipif(</span><span class="s0">not </span><span class="s1">has_umfpack</span><span class="s0">, </span><span class="s1">reason=</span><span class="s4">&quot;umfpack not available&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_bug_8278(self):</span>
        <span class="s1">check_free_memory(</span><span class="s3">8000</span><span class="s1">)</span>
        <span class="s1">use_solver(useUmfpack=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">A</span><span class="s0">, </span><span class="s1">b = setup_bug_8278()</span>
        <span class="s1">A = A.tocsc()</span>
        <span class="s1">f = factorized(A)</span>
        <span class="s1">x = f(b)</span>
        <span class="s1">assert_array_almost_equal(A @ x</span><span class="s0">, </span><span class="s1">b)</span>


<span class="s0">class </span><span class="s1">TestLinsolve:</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">use_solver(useUmfpack=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_singular(self):</span>
        <span class="s1">A = csc_matrix((</span><span class="s3">5</span><span class="s0">,</span><span class="s3">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s4">'d'</span><span class="s1">)</span>
        <span class="s1">b = array([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]</span><span class="s0">,</span><span class="s1">dtype=</span><span class="s4">'d'</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(MatrixRankWarning</span><span class="s0">, </span><span class="s4">&quot;Matrix is exactly singular&quot;</span><span class="s1">)</span>
            <span class="s1">x = spsolve(A</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">np.isfinite(x).any())</span>

    <span class="s0">def </span><span class="s1">test_singular_gh_3312(self):</span>
        <span class="s2"># &quot;Bad&quot; test case that leads SuperLU to call LAPACK with invalid</span>
        <span class="s2"># arguments. Check that it fails moderately gracefully.</span>
        <span class="s1">ij = np.array([(</span><span class="s3">17</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">17</span><span class="s0">, </span><span class="s3">6</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">17</span><span class="s0">, </span><span class="s3">12</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">13</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">dtype=np.int32)</span>
        <span class="s1">v = np.array([</span><span class="s3">0.284213</span><span class="s0">, </span><span class="s3">0.94933781</span><span class="s0">, </span><span class="s3">0.15767017</span><span class="s0">, </span><span class="s3">0.38797296</span><span class="s1">])</span>
        <span class="s1">A = csc_matrix((v</span><span class="s0">, </span><span class="s1">ij.T)</span><span class="s0">, </span><span class="s1">shape=(</span><span class="s3">20</span><span class="s0">, </span><span class="s3">20</span><span class="s1">))</span>
        <span class="s1">b = np.arange(</span><span class="s3">20</span><span class="s1">)</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s2"># should either raise a runtime error or return value</span>
            <span class="s2"># appropriate for singular input (which yields the warning)</span>
            <span class="s0">with </span><span class="s1">suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
                <span class="s1">sup.filter(MatrixRankWarning</span><span class="s0">, </span><span class="s4">&quot;Matrix is exactly singular&quot;</span><span class="s1">)</span>
                <span class="s1">x = spsolve(A</span><span class="s0">, </span><span class="s1">b)</span>
            <span class="s0">assert not </span><span class="s1">np.isfinite(x).any()</span>
        <span class="s0">except </span><span class="s1">RuntimeError:</span>
            <span class="s0">pass</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">'format'</span><span class="s0">, </span><span class="s1">[</span><span class="s4">'csc'</span><span class="s0">, </span><span class="s4">'csr'</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">'idx_dtype'</span><span class="s0">, </span><span class="s1">[np.int32</span><span class="s0">, </span><span class="s1">np.int64])</span>
    <span class="s0">def </span><span class="s1">test_twodiags(self</span><span class="s0">, </span><span class="s1">format: str</span><span class="s0">, </span><span class="s1">idx_dtype: np.dtype):</span>
        <span class="s1">A = spdiags([[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">6</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">8</span><span class="s0">, </span><span class="s3">9</span><span class="s0">, </span><span class="s3">10</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">5</span><span class="s0">,</span>
                    <span class="s1">format=format)</span>
        <span class="s1">b = array([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">])</span>

        <span class="s2"># condition number of A</span>
        <span class="s1">cond_A = norm(A.toarray()</span><span class="s0">, </span><span class="s3">2</span><span class="s1">) * norm(inv(A.toarray())</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">[</span><span class="s4">'f'</span><span class="s0">,</span><span class="s4">'d'</span><span class="s0">,</span><span class="s4">'F'</span><span class="s0">,</span><span class="s4">'D'</span><span class="s1">]:</span>
            <span class="s1">eps = finfo(t).eps  </span><span class="s2"># floating point epsilon</span>
            <span class="s1">b = b.astype(t)</span>
            <span class="s1">Asp = A.astype(t)</span>
            <span class="s1">Asp.indices = Asp.indices.astype(idx_dtype</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s1">Asp.indptr = Asp.indptr.astype(idx_dtype</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>

            <span class="s1">x = spsolve(Asp</span><span class="s0">, </span><span class="s1">b)</span>
            <span class="s1">assert_(norm(b - Asp@x) &lt; </span><span class="s3">10 </span><span class="s1">* cond_A * eps)</span>

    <span class="s0">def </span><span class="s1">test_bvector_smoketest(self):</span>
        <span class="s1">Adense = array([[</span><span class="s3">0.</span><span class="s0">, </span><span class="s3">1.</span><span class="s0">, </span><span class="s3">1.</span><span class="s1">]</span><span class="s0">,</span>
                        <span class="s1">[</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">0.</span><span class="s0">, </span><span class="s3">1.</span><span class="s1">]</span><span class="s0">,</span>
                        <span class="s1">[</span><span class="s3">0.</span><span class="s0">, </span><span class="s3">0.</span><span class="s0">, </span><span class="s3">1.</span><span class="s1">]])</span>
        <span class="s1">As = csc_matrix(Adense)</span>
        <span class="s1">random.seed(</span><span class="s3">1234</span><span class="s1">)</span>
        <span class="s1">x = random.randn(</span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">b = As@x</span>
        <span class="s1">x2 = spsolve(As</span><span class="s0">, </span><span class="s1">b)</span>

        <span class="s1">assert_array_almost_equal(x</span><span class="s0">, </span><span class="s1">x2)</span>

    <span class="s0">def </span><span class="s1">test_bmatrix_smoketest(self):</span>
        <span class="s1">Adense = array([[</span><span class="s3">0.</span><span class="s0">, </span><span class="s3">1.</span><span class="s0">, </span><span class="s3">1.</span><span class="s1">]</span><span class="s0">,</span>
                        <span class="s1">[</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">0.</span><span class="s0">, </span><span class="s3">1.</span><span class="s1">]</span><span class="s0">,</span>
                        <span class="s1">[</span><span class="s3">0.</span><span class="s0">, </span><span class="s3">0.</span><span class="s0">, </span><span class="s3">1.</span><span class="s1">]])</span>
        <span class="s1">As = csc_matrix(Adense)</span>
        <span class="s1">random.seed(</span><span class="s3">1234</span><span class="s1">)</span>
        <span class="s1">x = random.randn(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">)</span>
        <span class="s1">Bdense = As.dot(x)</span>
        <span class="s1">Bs = csc_matrix(Bdense)</span>
        <span class="s1">x2 = spsolve(As</span><span class="s0">, </span><span class="s1">Bs)</span>
        <span class="s1">assert_array_almost_equal(x</span><span class="s0">, </span><span class="s1">x2.toarray())</span>

    <span class="s1">@sup_sparse_efficiency</span>
    <span class="s0">def </span><span class="s1">test_non_square(self):</span>
        <span class="s2"># A is not square.</span>
        <span class="s1">A = ones((</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">))</span>
        <span class="s1">b = ones((</span><span class="s3">4</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">spsolve</span><span class="s0">, </span><span class="s1">A</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s2"># A2 and b2 have incompatible shapes.</span>
        <span class="s1">A2 = csc_matrix(eye(</span><span class="s3">3</span><span class="s1">))</span>
        <span class="s1">b2 = array([</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">2.0</span><span class="s1">])</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">spsolve</span><span class="s0">, </span><span class="s1">A2</span><span class="s0">, </span><span class="s1">b2)</span>

    <span class="s1">@sup_sparse_efficiency</span>
    <span class="s0">def </span><span class="s1">test_example_comparison(self):</span>
        <span class="s1">row = array([</span><span class="s3">0</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">2</span><span class="s1">])</span>
        <span class="s1">col = array([</span><span class="s3">0</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">2</span><span class="s1">])</span>
        <span class="s1">data = array([</span><span class="s3">1</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">3</span><span class="s0">,</span><span class="s1">-</span><span class="s3">4</span><span class="s0">,</span><span class="s3">5</span><span class="s0">,</span><span class="s3">6</span><span class="s1">])</span>
        <span class="s1">sM = csr_matrix((data</span><span class="s0">,</span><span class="s1">(row</span><span class="s0">,</span><span class="s1">col))</span><span class="s0">, </span><span class="s1">shape=(</span><span class="s3">3</span><span class="s0">,</span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=float)</span>
        <span class="s1">M = sM.toarray()</span>

        <span class="s1">row = array([</span><span class="s3">0</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">0</span><span class="s1">])</span>
        <span class="s1">col = array([</span><span class="s3">0</span><span class="s0">,</span><span class="s3">2</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">0</span><span class="s0">,</span><span class="s3">0</span><span class="s1">])</span>
        <span class="s1">data = array([</span><span class="s3">1</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">sN = csr_matrix((data</span><span class="s0">, </span><span class="s1">(row</span><span class="s0">,</span><span class="s1">col))</span><span class="s0">, </span><span class="s1">shape=(</span><span class="s3">3</span><span class="s0">,</span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=float)</span>
        <span class="s1">N = sN.toarray()</span>

        <span class="s1">sX = spsolve(sM</span><span class="s0">, </span><span class="s1">sN)</span>
        <span class="s1">X = scipy.linalg.solve(M</span><span class="s0">, </span><span class="s1">N)</span>

        <span class="s1">assert_array_almost_equal(X</span><span class="s0">, </span><span class="s1">sX.toarray())</span>

    <span class="s1">@sup_sparse_efficiency</span>
    <span class="s1">@pytest.mark.skipif(</span><span class="s0">not </span><span class="s1">has_umfpack</span><span class="s0">, </span><span class="s1">reason=</span><span class="s4">&quot;umfpack not available&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_shape_compatibility(self):</span>
        <span class="s1">use_solver(useUmfpack=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">A = csc_matrix([[</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]])</span>
        <span class="s1">bs = [</span>
            <span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">6</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">array([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">6</span><span class="s1">])</span><span class="s0">,</span>
            <span class="s1">[[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">6</span><span class="s1">]]</span><span class="s0">,</span>
            <span class="s1">array([[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">6</span><span class="s1">]])</span><span class="s0">,</span>
            <span class="s1">csc_matrix([[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">6</span><span class="s1">]])</span><span class="s0">,</span>
            <span class="s1">csr_matrix([[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">6</span><span class="s1">]])</span><span class="s0">,</span>
            <span class="s1">dok_matrix([[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">6</span><span class="s1">]])</span><span class="s0">,</span>
            <span class="s1">bsr_matrix([[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">6</span><span class="s1">]])</span><span class="s0">,</span>
            <span class="s1">array([[</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">2.</span><span class="s0">, </span><span class="s3">3.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">6.</span><span class="s0">, </span><span class="s3">8.</span><span class="s0">, </span><span class="s3">10.</span><span class="s1">]])</span><span class="s0">,</span>
            <span class="s1">csc_matrix([[</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">2.</span><span class="s0">, </span><span class="s3">3.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">6.</span><span class="s0">, </span><span class="s3">8.</span><span class="s0">, </span><span class="s3">10.</span><span class="s1">]])</span><span class="s0">,</span>
            <span class="s1">csr_matrix([[</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">2.</span><span class="s0">, </span><span class="s3">3.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">6.</span><span class="s0">, </span><span class="s3">8.</span><span class="s0">, </span><span class="s3">10.</span><span class="s1">]])</span><span class="s0">,</span>
            <span class="s1">dok_matrix([[</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">2.</span><span class="s0">, </span><span class="s3">3.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">6.</span><span class="s0">, </span><span class="s3">8.</span><span class="s0">, </span><span class="s3">10.</span><span class="s1">]])</span><span class="s0">,</span>
            <span class="s1">bsr_matrix([[</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">2.</span><span class="s0">, </span><span class="s3">3.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">6.</span><span class="s0">, </span><span class="s3">8.</span><span class="s0">, </span><span class="s3">10.</span><span class="s1">]])</span><span class="s0">,</span>
            <span class="s1">]</span>

        <span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">bs:</span>
            <span class="s1">x = np.linalg.solve(A.toarray()</span><span class="s0">, </span><span class="s1">toarray(b))</span>
            <span class="s0">for </span><span class="s1">spmattype </span><span class="s0">in </span><span class="s1">[csc_matrix</span><span class="s0">, </span><span class="s1">csr_matrix</span><span class="s0">, </span><span class="s1">dok_matrix</span><span class="s0">, </span><span class="s1">lil_matrix]:</span>
                <span class="s1">x1 = spsolve(spmattype(A)</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">use_umfpack=</span><span class="s0">True</span><span class="s1">)</span>
                <span class="s1">x2 = spsolve(spmattype(A)</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">use_umfpack=</span><span class="s0">False</span><span class="s1">)</span>

                <span class="s2"># check solution</span>
                <span class="s0">if </span><span class="s1">x.ndim == </span><span class="s3">2 </span><span class="s0">and </span><span class="s1">x.shape[</span><span class="s3">1</span><span class="s1">] == </span><span class="s3">1</span><span class="s1">:</span>
                    <span class="s2"># interprets also these as &quot;vectors&quot;</span>
                    <span class="s1">x = x.ravel()</span>

                <span class="s1">assert_array_almost_equal(toarray(x1)</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">err_msg=repr((b</span><span class="s0">, </span><span class="s1">spmattype</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)))</span>
                <span class="s1">assert_array_almost_equal(toarray(x2)</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">err_msg=repr((b</span><span class="s0">, </span><span class="s1">spmattype</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)))</span>

                <span class="s2"># dense vs. sparse output  (&quot;vectors&quot; are always dense)</span>
                <span class="s0">if </span><span class="s1">issparse(b) </span><span class="s0">and </span><span class="s1">x.ndim &gt; </span><span class="s3">1</span><span class="s1">:</span>
                    <span class="s1">assert_(issparse(x1)</span><span class="s0">, </span><span class="s1">repr((b</span><span class="s0">, </span><span class="s1">spmattype</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)))</span>
                    <span class="s1">assert_(issparse(x2)</span><span class="s0">, </span><span class="s1">repr((b</span><span class="s0">, </span><span class="s1">spmattype</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)))</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">assert_(isinstance(x1</span><span class="s0">, </span><span class="s1">np.ndarray)</span><span class="s0">, </span><span class="s1">repr((b</span><span class="s0">, </span><span class="s1">spmattype</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)))</span>
                    <span class="s1">assert_(isinstance(x2</span><span class="s0">, </span><span class="s1">np.ndarray)</span><span class="s0">, </span><span class="s1">repr((b</span><span class="s0">, </span><span class="s1">spmattype</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)))</span>

                <span class="s2"># check output shape</span>
                <span class="s0">if </span><span class="s1">x.ndim == </span><span class="s3">1</span><span class="s1">:</span>
                    <span class="s2"># &quot;vector&quot;</span>
                    <span class="s1">assert_equal(x1.shape</span><span class="s0">, </span><span class="s1">(A.shape[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">,</span><span class="s1">))</span>
                    <span class="s1">assert_equal(x2.shape</span><span class="s0">, </span><span class="s1">(A.shape[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">,</span><span class="s1">))</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s2"># &quot;matrix&quot;</span>
                    <span class="s1">assert_equal(x1.shape</span><span class="s0">, </span><span class="s1">x.shape)</span>
                    <span class="s1">assert_equal(x2.shape</span><span class="s0">, </span><span class="s1">x.shape)</span>

        <span class="s1">A = csc_matrix((</span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>
        <span class="s1">b = csc_matrix((</span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">spsolve</span><span class="s0">, </span><span class="s1">A</span><span class="s0">, </span><span class="s1">b)</span>

    <span class="s1">@sup_sparse_efficiency</span>
    <span class="s0">def </span><span class="s1">test_ndarray_support(self):</span>
        <span class="s1">A = array([[</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">2.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">2.</span><span class="s0">, </span><span class="s3">0.</span><span class="s1">]])</span>
        <span class="s1">x = array([[</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">1.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0.5</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.5</span><span class="s1">]])</span>
        <span class="s1">b = array([[</span><span class="s3">2.</span><span class="s0">, </span><span class="s3">0.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">2.</span><span class="s0">, </span><span class="s3">2.</span><span class="s1">]])</span>

        <span class="s1">assert_array_almost_equal(x</span><span class="s0">, </span><span class="s1">spsolve(A</span><span class="s0">, </span><span class="s1">b))</span>

    <span class="s0">def </span><span class="s1">test_gssv_badinput(self):</span>
        <span class="s1">N = </span><span class="s3">10</span>
        <span class="s1">d = arange(N) + </span><span class="s3">1.0</span>
        <span class="s1">A = spdiags((d</span><span class="s0">, </span><span class="s3">2</span><span class="s1">*d</span><span class="s0">, </span><span class="s1">d[::-</span><span class="s3">1</span><span class="s1">])</span><span class="s0">, </span><span class="s1">(-</span><span class="s3">3</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">N</span><span class="s0">, </span><span class="s1">N)</span>

        <span class="s0">for </span><span class="s1">spmatrix </span><span class="s0">in </span><span class="s1">(csc_matrix</span><span class="s0">, </span><span class="s1">csr_matrix):</span>
            <span class="s1">A = spmatrix(A)</span>
            <span class="s1">b = np.arange(N)</span>

            <span class="s0">def </span><span class="s1">not_c_contig(x):</span>
                <span class="s0">return </span><span class="s1">x.repeat(</span><span class="s3">2</span><span class="s1">)[::</span><span class="s3">2</span><span class="s1">]</span>

            <span class="s0">def </span><span class="s1">not_1dim(x):</span>
                <span class="s0">return </span><span class="s1">x[:</span><span class="s0">,None</span><span class="s1">]</span>

            <span class="s0">def </span><span class="s1">bad_type(x):</span>
                <span class="s0">return </span><span class="s1">x.astype(bool)</span>

            <span class="s0">def </span><span class="s1">too_short(x):</span>
                <span class="s0">return </span><span class="s1">x[:-</span><span class="s3">1</span><span class="s1">]</span>

            <span class="s1">badops = [not_c_contig</span><span class="s0">, </span><span class="s1">not_1dim</span><span class="s0">, </span><span class="s1">bad_type</span><span class="s0">, </span><span class="s1">too_short]</span>

            <span class="s0">for </span><span class="s1">badop </span><span class="s0">in </span><span class="s1">badops:</span>
                <span class="s1">msg = </span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">spmatrix</span><span class="s0">!r} {</span><span class="s1">badop</span><span class="s0">!r}</span><span class="s4">&quot;</span>
                <span class="s2"># Not C-contiguous</span>
                <span class="s1">assert_raises((ValueError</span><span class="s0">, </span><span class="s1">TypeError)</span><span class="s0">, </span><span class="s1">_superlu.gssv</span><span class="s0">,</span>
                              <span class="s1">N</span><span class="s0">, </span><span class="s1">A.nnz</span><span class="s0">, </span><span class="s1">badop(A.data)</span><span class="s0">, </span><span class="s1">A.indices</span><span class="s0">, </span><span class="s1">A.indptr</span><span class="s0">,</span>
                              <span class="s1">b</span><span class="s0">, </span><span class="s1">int(spmatrix == csc_matrix)</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>
                <span class="s1">assert_raises((ValueError</span><span class="s0">, </span><span class="s1">TypeError)</span><span class="s0">, </span><span class="s1">_superlu.gssv</span><span class="s0">,</span>
                              <span class="s1">N</span><span class="s0">, </span><span class="s1">A.nnz</span><span class="s0">, </span><span class="s1">A.data</span><span class="s0">, </span><span class="s1">badop(A.indices)</span><span class="s0">, </span><span class="s1">A.indptr</span><span class="s0">,</span>
                              <span class="s1">b</span><span class="s0">, </span><span class="s1">int(spmatrix == csc_matrix)</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>
                <span class="s1">assert_raises((ValueError</span><span class="s0">, </span><span class="s1">TypeError)</span><span class="s0">, </span><span class="s1">_superlu.gssv</span><span class="s0">,</span>
                              <span class="s1">N</span><span class="s0">, </span><span class="s1">A.nnz</span><span class="s0">, </span><span class="s1">A.data</span><span class="s0">, </span><span class="s1">A.indices</span><span class="s0">, </span><span class="s1">badop(A.indptr)</span><span class="s0">,</span>
                              <span class="s1">b</span><span class="s0">, </span><span class="s1">int(spmatrix == csc_matrix)</span><span class="s0">, </span><span class="s1">err_msg=msg)</span>

    <span class="s0">def </span><span class="s1">test_sparsity_preservation(self):</span>
        <span class="s1">ident = csc_matrix([</span>
            <span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]])</span>
        <span class="s1">b = csc_matrix([</span>
            <span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]])</span>
        <span class="s1">x = spsolve(ident</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">assert_equal(ident.nnz</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">assert_equal(b.nnz</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">assert_equal(x.nnz</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">assert_allclose(x.A</span><span class="s0">, </span><span class="s1">b.A</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-12</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-12</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_dtype_cast(self):</span>
        <span class="s1">A_real = scipy.sparse.csr_matrix([[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">,</span>
                                          <span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">,</span>
                                          <span class="s1">[</span><span class="s3">4</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]])</span>
        <span class="s1">A_complex = scipy.sparse.csr_matrix([[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">,</span>
                                             <span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">,</span>
                                             <span class="s1">[</span><span class="s3">4</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">5 </span><span class="s1">+ </span><span class="s3">1j</span><span class="s1">]])</span>
        <span class="s1">b_real = np.array([</span><span class="s3">1</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">b_complex = np.array([</span><span class="s3">1</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">1</span><span class="s1">]) + </span><span class="s3">1j</span><span class="s1">*np.array([</span><span class="s3">1</span><span class="s0">,</span><span class="s3">1</span><span class="s0">,</span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">x = spsolve(A_real</span><span class="s0">, </span><span class="s1">b_real)</span>
        <span class="s1">assert_(np.issubdtype(x.dtype</span><span class="s0">, </span><span class="s1">np.floating))</span>
        <span class="s1">x = spsolve(A_real</span><span class="s0">, </span><span class="s1">b_complex)</span>
        <span class="s1">assert_(np.issubdtype(x.dtype</span><span class="s0">, </span><span class="s1">np.complexfloating))</span>
        <span class="s1">x = spsolve(A_complex</span><span class="s0">, </span><span class="s1">b_real)</span>
        <span class="s1">assert_(np.issubdtype(x.dtype</span><span class="s0">, </span><span class="s1">np.complexfloating))</span>
        <span class="s1">x = spsolve(A_complex</span><span class="s0">, </span><span class="s1">b_complex)</span>
        <span class="s1">assert_(np.issubdtype(x.dtype</span><span class="s0">, </span><span class="s1">np.complexfloating))</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s1">@pytest.mark.skipif(</span><span class="s0">not </span><span class="s1">has_umfpack</span><span class="s0">, </span><span class="s1">reason=</span><span class="s4">&quot;umfpack not available&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_bug_8278(self):</span>
        <span class="s1">check_free_memory(</span><span class="s3">8000</span><span class="s1">)</span>
        <span class="s1">use_solver(useUmfpack=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">A</span><span class="s0">, </span><span class="s1">b = setup_bug_8278()</span>
        <span class="s1">x = spsolve(A</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s1">assert_array_almost_equal(A @ x</span><span class="s0">, </span><span class="s1">b)</span>


<span class="s0">class </span><span class="s1">TestSplu:</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">use_solver(useUmfpack=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">n = </span><span class="s3">40</span>
        <span class="s1">d = arange(n) + </span><span class="s3">1</span>
        <span class="s1">self.n = n</span>
        <span class="s1">self.A = spdiags((d</span><span class="s0">, </span><span class="s3">2</span><span class="s1">*d</span><span class="s0">, </span><span class="s1">d[::-</span><span class="s3">1</span><span class="s1">])</span><span class="s0">, </span><span class="s1">(-</span><span class="s3">3</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">format=</span><span class="s4">'csc'</span><span class="s1">)</span>
        <span class="s1">random.seed(</span><span class="s3">1234</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_smoketest(self</span><span class="s0">, </span><span class="s1">spxlu</span><span class="s0">, </span><span class="s1">check</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">idx_dtype):</span>
        <span class="s0">if </span><span class="s1">np.issubdtype(dtype</span><span class="s0">, </span><span class="s1">np.complexfloating):</span>
            <span class="s1">A = self.A + </span><span class="s3">1j</span><span class="s1">*self.A.T</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">A = self.A</span>

        <span class="s1">A = A.astype(dtype)</span>
        <span class="s1">A.indices = A.indices.astype(idx_dtype</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">A.indptr = A.indptr.astype(idx_dtype</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">lu = spxlu(A)</span>

        <span class="s1">rng = random.RandomState(</span><span class="s3">1234</span><span class="s1">)</span>

        <span class="s2"># Input shapes</span>
        <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">[</span><span class="s0">None, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">self.n</span><span class="s0">, </span><span class="s1">self.n+</span><span class="s3">2</span><span class="s1">]:</span>
            <span class="s1">msg = </span><span class="s4">f&quot;k=</span><span class="s0">{</span><span class="s1">k</span><span class="s0">!r}</span><span class="s4">&quot;</span>

            <span class="s0">if </span><span class="s1">k </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">b = rng.rand(self.n)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">b = rng.rand(self.n</span><span class="s0">, </span><span class="s1">k)</span>

            <span class="s0">if </span><span class="s1">np.issubdtype(dtype</span><span class="s0">, </span><span class="s1">np.complexfloating):</span>
                <span class="s1">b = b + </span><span class="s3">1j</span><span class="s1">*rng.rand(*b.shape)</span>
            <span class="s1">b = b.astype(dtype)</span>

            <span class="s1">x = lu.solve(b)</span>
            <span class="s1">check(A</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">msg)</span>

            <span class="s1">x = lu.solve(b</span><span class="s0">, </span><span class="s4">'T'</span><span class="s1">)</span>
            <span class="s1">check(A.T</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">msg)</span>

            <span class="s1">x = lu.solve(b</span><span class="s0">, </span><span class="s4">'H'</span><span class="s1">)</span>
            <span class="s1">check(A.T.conj()</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">msg)</span>

    <span class="s1">@sup_sparse_efficiency</span>
    <span class="s0">def </span><span class="s1">test_splu_smoketest(self):</span>
        <span class="s1">self._internal_test_splu_smoketest()</span>

    <span class="s0">def </span><span class="s1">_internal_test_splu_smoketest(self):</span>
        <span class="s2"># Check that splu works at all</span>
        <span class="s0">def </span><span class="s1">check(A</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">msg=</span><span class="s4">&quot;&quot;</span><span class="s1">):</span>
            <span class="s1">eps = np.finfo(A.dtype).eps</span>
            <span class="s1">r = A @ x</span>
            <span class="s1">assert_(abs(r - b).max() &lt; </span><span class="s3">1e3</span><span class="s1">*eps</span><span class="s0">, </span><span class="s1">msg)</span>

        <span class="s0">for </span><span class="s1">dtype </span><span class="s0">in </span><span class="s1">[np.float32</span><span class="s0">, </span><span class="s1">np.float64</span><span class="s0">, </span><span class="s1">np.complex64</span><span class="s0">, </span><span class="s1">np.complex128]:</span>
            <span class="s0">for </span><span class="s1">idx_dtype </span><span class="s0">in </span><span class="s1">[np.int32</span><span class="s0">, </span><span class="s1">np.int64]:</span>
                <span class="s1">self._smoketest(splu</span><span class="s0">, </span><span class="s1">check</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">idx_dtype)</span>

    <span class="s1">@sup_sparse_efficiency</span>
    <span class="s0">def </span><span class="s1">test_spilu_smoketest(self):</span>
        <span class="s1">self._internal_test_spilu_smoketest()</span>

    <span class="s0">def </span><span class="s1">_internal_test_spilu_smoketest(self):</span>
        <span class="s1">errors = []</span>

        <span class="s0">def </span><span class="s1">check(A</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">msg=</span><span class="s4">&quot;&quot;</span><span class="s1">):</span>
            <span class="s1">r = A @ x</span>
            <span class="s1">err = abs(r - b).max()</span>
            <span class="s1">assert_(err &lt; </span><span class="s3">1e-2</span><span class="s0">, </span><span class="s1">msg)</span>
            <span class="s0">if </span><span class="s1">b.dtype </span><span class="s0">in </span><span class="s1">(np.float64</span><span class="s0">, </span><span class="s1">np.complex128):</span>
                <span class="s1">errors.append(err)</span>

        <span class="s0">for </span><span class="s1">dtype </span><span class="s0">in </span><span class="s1">[np.float32</span><span class="s0">, </span><span class="s1">np.float64</span><span class="s0">, </span><span class="s1">np.complex64</span><span class="s0">, </span><span class="s1">np.complex128]:</span>
            <span class="s0">for </span><span class="s1">idx_dtype </span><span class="s0">in </span><span class="s1">[np.int32</span><span class="s0">, </span><span class="s1">np.int64]:</span>
                <span class="s1">self._smoketest(spilu</span><span class="s0">, </span><span class="s1">check</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">idx_dtype)</span>

        <span class="s1">assert_(max(errors) &gt; </span><span class="s3">1e-5</span><span class="s1">)</span>

    <span class="s1">@sup_sparse_efficiency</span>
    <span class="s0">def </span><span class="s1">test_spilu_drop_rule(self):</span>
        <span class="s2"># Test passing in the drop_rule argument to spilu.</span>
        <span class="s1">A = identity(</span><span class="s3">2</span><span class="s1">)</span>

        <span class="s1">rules = [</span>
            <span class="s5">b'basic,area'</span><span class="s1">.decode(</span><span class="s4">'ascii'</span><span class="s1">)</span><span class="s0">,  </span><span class="s2"># unicode</span>
            <span class="s5">b'basic,area'</span><span class="s0">,  </span><span class="s2"># ascii</span>
            <span class="s1">[</span><span class="s5">b'basic'</span><span class="s0">, </span><span class="s5">b'area'</span><span class="s1">.decode(</span><span class="s4">'ascii'</span><span class="s1">)]</span>
        <span class="s1">]</span>
        <span class="s0">for </span><span class="s1">rule </span><span class="s0">in </span><span class="s1">rules:</span>
            <span class="s2"># Argument should be accepted</span>
            <span class="s1">assert_(isinstance(spilu(A</span><span class="s0">, </span><span class="s1">drop_rule=rule)</span><span class="s0">, </span><span class="s1">SuperLU))</span>

    <span class="s0">def </span><span class="s1">test_splu_nnz0(self):</span>
        <span class="s1">A = csc_matrix((</span><span class="s3">5</span><span class="s0">,</span><span class="s3">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s4">'d'</span><span class="s1">)</span>
        <span class="s1">assert_raises(RuntimeError</span><span class="s0">, </span><span class="s1">splu</span><span class="s0">, </span><span class="s1">A)</span>

    <span class="s0">def </span><span class="s1">test_spilu_nnz0(self):</span>
        <span class="s1">A = csc_matrix((</span><span class="s3">5</span><span class="s0">,</span><span class="s3">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s4">'d'</span><span class="s1">)</span>
        <span class="s1">assert_raises(RuntimeError</span><span class="s0">, </span><span class="s1">spilu</span><span class="s0">, </span><span class="s1">A)</span>

    <span class="s0">def </span><span class="s1">test_splu_basic(self):</span>
        <span class="s2"># Test basic splu functionality.</span>
        <span class="s1">n = </span><span class="s3">30</span>
        <span class="s1">rng = random.RandomState(</span><span class="s3">12</span><span class="s1">)</span>
        <span class="s1">a = rng.rand(n</span><span class="s0">, </span><span class="s1">n)</span>
        <span class="s1">a[a &lt; </span><span class="s3">0.95</span><span class="s1">] = </span><span class="s3">0</span>
        <span class="s2"># First test with a singular matrix</span>
        <span class="s1">a[:</span><span class="s0">, </span><span class="s3">0</span><span class="s1">] = </span><span class="s3">0</span>
        <span class="s1">a_ = csc_matrix(a)</span>
        <span class="s2"># Matrix is exactly singular</span>
        <span class="s1">assert_raises(RuntimeError</span><span class="s0">, </span><span class="s1">splu</span><span class="s0">, </span><span class="s1">a_)</span>

        <span class="s2"># Make a diagonal dominant, to make sure it is not singular</span>
        <span class="s1">a += </span><span class="s3">4</span><span class="s1">*eye(n)</span>
        <span class="s1">a_ = csc_matrix(a)</span>
        <span class="s1">lu = splu(a_)</span>
        <span class="s1">b = ones(n)</span>
        <span class="s1">x = lu.solve(b)</span>
        <span class="s1">assert_almost_equal(dot(a</span><span class="s0">, </span><span class="s1">x)</span><span class="s0">, </span><span class="s1">b)</span>

    <span class="s0">def </span><span class="s1">test_splu_perm(self):</span>
        <span class="s2"># Test the permutation vectors exposed by splu.</span>
        <span class="s1">n = </span><span class="s3">30</span>
        <span class="s1">a = random.random((n</span><span class="s0">, </span><span class="s1">n))</span>
        <span class="s1">a[a &lt; </span><span class="s3">0.95</span><span class="s1">] = </span><span class="s3">0</span>
        <span class="s2"># Make a diagonal dominant, to make sure it is not singular</span>
        <span class="s1">a += </span><span class="s3">4</span><span class="s1">*eye(n)</span>
        <span class="s1">a_ = csc_matrix(a)</span>
        <span class="s1">lu = splu(a_)</span>
        <span class="s2"># Check that the permutation indices do belong to [0, n-1].</span>
        <span class="s0">for </span><span class="s1">perm </span><span class="s0">in </span><span class="s1">(lu.perm_r</span><span class="s0">, </span><span class="s1">lu.perm_c):</span>
            <span class="s1">assert_(all(perm &gt; -</span><span class="s3">1</span><span class="s1">))</span>
            <span class="s1">assert_(all(perm &lt; n))</span>
            <span class="s1">assert_equal(len(unique(perm))</span><span class="s0">, </span><span class="s1">len(perm))</span>

        <span class="s2"># Now make a symmetric, and test that the two permutation vectors are</span>
        <span class="s2"># the same</span>
        <span class="s2"># Note: a += a.T relies on undefined behavior.</span>
        <span class="s1">a = a + a.T</span>
        <span class="s1">a_ = csc_matrix(a)</span>
        <span class="s1">lu = splu(a_)</span>
        <span class="s1">assert_array_equal(lu.perm_r</span><span class="s0">, </span><span class="s1">lu.perm_c)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;splu_fun, rtol&quot;</span><span class="s0">, </span><span class="s1">[(splu</span><span class="s0">, </span><span class="s3">1e-7</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(spilu</span><span class="s0">, </span><span class="s3">1e-1</span><span class="s1">)])</span>
    <span class="s0">def </span><span class="s1">test_natural_permc(self</span><span class="s0">, </span><span class="s1">splu_fun</span><span class="s0">, </span><span class="s1">rtol):</span>
        <span class="s2"># Test that the &quot;NATURAL&quot; permc_spec does not permute the matrix</span>
        <span class="s1">np.random.seed(</span><span class="s3">42</span><span class="s1">)</span>
        <span class="s1">n = </span><span class="s3">500</span>
        <span class="s1">p = </span><span class="s3">0.01</span>
        <span class="s1">A = scipy.sparse.random(n</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">p)</span>
        <span class="s1">x = np.random.rand(n)</span>
        <span class="s2"># Make A diagonal dominant to make sure it is not singular</span>
        <span class="s1">A += (n+</span><span class="s3">1</span><span class="s1">)*scipy.sparse.identity(n)</span>
        <span class="s1">A_ = csc_matrix(A)</span>
        <span class="s1">b = A_ @ x</span>

        <span class="s2"># without permc_spec, permutation is not identity</span>
        <span class="s1">lu = splu_fun(A_)</span>
        <span class="s1">assert_(np.any(lu.perm_c != np.arange(n)))</span>

        <span class="s2"># with permc_spec=&quot;NATURAL&quot;, permutation is identity</span>
        <span class="s1">lu = splu_fun(A_</span><span class="s0">, </span><span class="s1">permc_spec=</span><span class="s4">&quot;NATURAL&quot;</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(lu.perm_c</span><span class="s0">, </span><span class="s1">np.arange(n))</span>

        <span class="s2"># Also, lu decomposition is valid</span>
        <span class="s1">x2 = lu.solve(b)</span>
        <span class="s1">assert_allclose(x</span><span class="s0">, </span><span class="s1">x2</span><span class="s0">, </span><span class="s1">rtol=rtol)</span>

    <span class="s1">@pytest.mark.skipif(</span><span class="s0">not </span><span class="s1">hasattr(sys</span><span class="s0">, </span><span class="s4">'getrefcount'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">reason=</span><span class="s4">&quot;no sys.getrefcount&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_lu_refcount(self):</span>
        <span class="s2"># Test that we are keeping track of the reference count with splu.</span>
        <span class="s1">n = </span><span class="s3">30</span>
        <span class="s1">a = random.random((n</span><span class="s0">, </span><span class="s1">n))</span>
        <span class="s1">a[a &lt; </span><span class="s3">0.95</span><span class="s1">] = </span><span class="s3">0</span>
        <span class="s2"># Make a diagonal dominant, to make sure it is not singular</span>
        <span class="s1">a += </span><span class="s3">4</span><span class="s1">*eye(n)</span>
        <span class="s1">a_ = csc_matrix(a)</span>
        <span class="s1">lu = splu(a_)</span>

        <span class="s2"># And now test that we don't have a refcount bug</span>
        <span class="s1">rc = sys.getrefcount(lu)</span>
        <span class="s0">for </span><span class="s1">attr </span><span class="s0">in </span><span class="s1">(</span><span class="s4">'perm_r'</span><span class="s0">, </span><span class="s4">'perm_c'</span><span class="s1">):</span>
            <span class="s1">perm = getattr(lu</span><span class="s0">, </span><span class="s1">attr)</span>
            <span class="s1">assert_equal(sys.getrefcount(lu)</span><span class="s0">, </span><span class="s1">rc + </span><span class="s3">1</span><span class="s1">)</span>
            <span class="s0">del </span><span class="s1">perm</span>
            <span class="s1">assert_equal(sys.getrefcount(lu)</span><span class="s0">, </span><span class="s1">rc)</span>

    <span class="s0">def </span><span class="s1">test_bad_inputs(self):</span>
        <span class="s1">A = self.A.tocsc()</span>

        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">splu</span><span class="s0">, </span><span class="s1">A[:</span><span class="s0">,</span><span class="s1">:</span><span class="s3">4</span><span class="s1">])</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">spilu</span><span class="s0">, </span><span class="s1">A[:</span><span class="s0">,</span><span class="s1">:</span><span class="s3">4</span><span class="s1">])</span>

        <span class="s0">for </span><span class="s1">lu </span><span class="s0">in </span><span class="s1">[splu(A)</span><span class="s0">, </span><span class="s1">spilu(A)]:</span>
            <span class="s1">b = random.rand(</span><span class="s3">42</span><span class="s1">)</span>
            <span class="s1">B = random.rand(</span><span class="s3">42</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
            <span class="s1">BB = random.rand(self.n</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">9</span><span class="s1">)</span>
            <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">lu.solve</span><span class="s0">, </span><span class="s1">b)</span>
            <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">lu.solve</span><span class="s0">, </span><span class="s1">B)</span>
            <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">lu.solve</span><span class="s0">, </span><span class="s1">BB)</span>
            <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">lu.solve</span><span class="s0">,</span>
                          <span class="s1">b.astype(np.complex64))</span>
            <span class="s1">assert_raises(TypeError</span><span class="s0">, </span><span class="s1">lu.solve</span><span class="s0">,</span>
                          <span class="s1">b.astype(np.complex128))</span>

    <span class="s1">@sup_sparse_efficiency</span>
    <span class="s0">def </span><span class="s1">test_superlu_dlamch_i386_nan(self):</span>
        <span class="s2"># SuperLU 4.3 calls some functions returning floats without</span>
        <span class="s2"># declaring them. On i386@linux call convention, this fails to</span>
        <span class="s2"># clear floating point registers after call. As a result, NaN</span>
        <span class="s2"># can appear in the next floating point operation made.</span>
        <span class="s2">#</span>
        <span class="s2"># Here's a test case that triggered the issue.</span>
        <span class="s1">n = </span><span class="s3">8</span>
        <span class="s1">d = np.arange(n) + </span><span class="s3">1</span>
        <span class="s1">A = spdiags((d</span><span class="s0">, </span><span class="s3">2</span><span class="s1">*d</span><span class="s0">, </span><span class="s1">d[::-</span><span class="s3">1</span><span class="s1">])</span><span class="s0">, </span><span class="s1">(-</span><span class="s3">3</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">n)</span>
        <span class="s1">A = A.astype(np.float32)</span>
        <span class="s1">spilu(A)</span>
        <span class="s1">A = A + </span><span class="s3">1j</span><span class="s1">*A</span>
        <span class="s1">B = A.A</span>
        <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">np.isnan(B).any())</span>

    <span class="s1">@sup_sparse_efficiency</span>
    <span class="s0">def </span><span class="s1">test_lu_attr(self):</span>

        <span class="s0">def </span><span class="s1">check(dtype</span><span class="s0">, </span><span class="s1">complex_2=</span><span class="s0">False</span><span class="s1">):</span>
            <span class="s1">A = self.A.astype(dtype)</span>

            <span class="s0">if </span><span class="s1">complex_2:</span>
                <span class="s1">A = A + </span><span class="s3">1j</span><span class="s1">*A.T</span>

            <span class="s1">n = A.shape[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s1">lu = splu(A)</span>

            <span class="s2"># Check that the decomposition is as advertized</span>

            <span class="s1">Pc = np.zeros((n</span><span class="s0">, </span><span class="s1">n))</span>
            <span class="s1">Pc[np.arange(n)</span><span class="s0">, </span><span class="s1">lu.perm_c] = </span><span class="s3">1</span>

            <span class="s1">Pr = np.zeros((n</span><span class="s0">, </span><span class="s1">n))</span>
            <span class="s1">Pr[lu.perm_r</span><span class="s0">, </span><span class="s1">np.arange(n)] = </span><span class="s3">1</span>

            <span class="s1">Ad = A.toarray()</span>
            <span class="s1">lhs = Pr.dot(Ad).dot(Pc)</span>
            <span class="s1">rhs = (lu.L @ lu.U).toarray()</span>

            <span class="s1">eps = np.finfo(dtype).eps</span>

            <span class="s1">assert_allclose(lhs</span><span class="s0">, </span><span class="s1">rhs</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">100</span><span class="s1">*eps)</span>

        <span class="s1">check(np.float32)</span>
        <span class="s1">check(np.float64)</span>
        <span class="s1">check(np.complex64)</span>
        <span class="s1">check(np.complex128)</span>
        <span class="s1">check(np.complex64</span><span class="s0">, True</span><span class="s1">)</span>
        <span class="s1">check(np.complex128</span><span class="s0">, True</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s1">@sup_sparse_efficiency</span>
    <span class="s0">def </span><span class="s1">test_threads_parallel(self):</span>
        <span class="s1">oks = []</span>

        <span class="s0">def </span><span class="s1">worker():</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">self.test_splu_basic()</span>
                <span class="s1">self._internal_test_splu_smoketest()</span>
                <span class="s1">self._internal_test_spilu_smoketest()</span>
                <span class="s1">oks.append(</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s0">except </span><span class="s1">Exception:</span>
                <span class="s0">pass</span>

        <span class="s1">threads = [threading.Thread(target=worker)</span>
                   <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">20</span><span class="s1">)]</span>
        <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">threads:</span>
            <span class="s1">t.start()</span>
        <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">threads:</span>
            <span class="s1">t.join()</span>

        <span class="s1">assert_equal(len(oks)</span><span class="s0">, </span><span class="s3">20</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestSpsolveTriangular:</span>
    <span class="s0">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">use_solver(useUmfpack=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_zero_diagonal(self):</span>
        <span class="s1">n = </span><span class="s3">5</span>
        <span class="s1">rng = np.random.default_rng(</span><span class="s3">43876432987</span><span class="s1">)</span>
        <span class="s1">A = rng.standard_normal((n</span><span class="s0">, </span><span class="s1">n))</span>
        <span class="s1">b = np.arange(n)</span>
        <span class="s1">A = scipy.sparse.tril(A</span><span class="s0">, </span><span class="s1">k=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">format=</span><span class="s4">'csr'</span><span class="s1">)</span>

        <span class="s1">x = spsolve_triangular(A</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">unit_diagonal=</span><span class="s0">True, </span><span class="s1">lower=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s1">A.setdiag(</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(A.dot(x)</span><span class="s0">, </span><span class="s1">b)</span>

        <span class="s2"># Regression test from gh-15199</span>
        <span class="s1">A = np.array([[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s1">b = np.array([</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">2.</span><span class="s0">, </span><span class="s3">3.</span><span class="s1">])</span>
        <span class="s0">with </span><span class="s1">suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(SparseEfficiencyWarning</span><span class="s0">, </span><span class="s4">&quot;CSR matrix format is&quot;</span><span class="s1">)</span>
            <span class="s1">spsolve_triangular(A</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">unit_diagonal=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_singular(self):</span>
        <span class="s1">n = </span><span class="s3">5</span>
        <span class="s1">A = csr_matrix((n</span><span class="s0">, </span><span class="s1">n))</span>
        <span class="s1">b = np.arange(n)</span>
        <span class="s0">for </span><span class="s1">lower </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s1">assert_raises(scipy.linalg.LinAlgError</span><span class="s0">, </span><span class="s1">spsolve_triangular</span><span class="s0">, </span><span class="s1">A</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">lower=lower)</span>

    <span class="s1">@sup_sparse_efficiency</span>
    <span class="s0">def </span><span class="s1">test_bad_shape(self):</span>
        <span class="s2"># A is not square.</span>
        <span class="s1">A = np.zeros((</span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">))</span>
        <span class="s1">b = ones((</span><span class="s3">4</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">spsolve_triangular</span><span class="s0">, </span><span class="s1">A</span><span class="s0">, </span><span class="s1">b)</span>
        <span class="s2"># A2 and b2 have incompatible shapes.</span>
        <span class="s1">A2 = csr_matrix(eye(</span><span class="s3">3</span><span class="s1">))</span>
        <span class="s1">b2 = array([</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">2.0</span><span class="s1">])</span>
        <span class="s1">assert_raises(ValueError</span><span class="s0">, </span><span class="s1">spsolve_triangular</span><span class="s0">, </span><span class="s1">A2</span><span class="s0">, </span><span class="s1">b2)</span>

    <span class="s1">@sup_sparse_efficiency</span>
    <span class="s0">def </span><span class="s1">test_input_types(self):</span>
        <span class="s1">A = array([[</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">0.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1.</span><span class="s0">, </span><span class="s3">2.</span><span class="s1">]])</span>
        <span class="s1">b = array([[</span><span class="s3">2.</span><span class="s0">, </span><span class="s3">0.</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">2.</span><span class="s0">, </span><span class="s3">2.</span><span class="s1">]])</span>
        <span class="s0">for </span><span class="s1">matrix_type </span><span class="s0">in </span><span class="s1">(array</span><span class="s0">, </span><span class="s1">csc_matrix</span><span class="s0">, </span><span class="s1">csr_matrix):</span>
            <span class="s1">x = spsolve_triangular(matrix_type(A)</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">lower=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s1">assert_array_almost_equal(A.dot(x)</span><span class="s0">, </span><span class="s1">b)</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s1">@pytest.mark.timeout(</span><span class="s3">120</span><span class="s1">)  </span><span class="s2"># prerelease_deps_coverage_64bit_blas job</span>
    <span class="s1">@sup_sparse_efficiency</span>
    <span class="s0">def </span><span class="s1">test_random(self):</span>
        <span class="s0">def </span><span class="s1">random_triangle_matrix(n</span><span class="s0">, </span><span class="s1">lower=</span><span class="s0">True</span><span class="s1">):</span>
            <span class="s1">A = scipy.sparse.random(n</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">density=</span><span class="s3">0.1</span><span class="s0">, </span><span class="s1">format=</span><span class="s4">'coo'</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">lower:</span>
                <span class="s1">A = scipy.sparse.tril(A)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">A = scipy.sparse.triu(A)</span>
            <span class="s1">A = A.tocsr(copy=</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(n):</span>
                <span class="s1">A[i</span><span class="s0">, </span><span class="s1">i] = np.random.rand() + </span><span class="s3">1</span>
            <span class="s0">return </span><span class="s1">A</span>

        <span class="s1">np.random.seed(</span><span class="s3">1234</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">lower </span><span class="s0">in </span><span class="s1">(</span><span class="s0">True, False</span><span class="s1">):</span>
            <span class="s0">for </span><span class="s1">n </span><span class="s0">in </span><span class="s1">(</span><span class="s3">10</span><span class="s0">, </span><span class="s3">10</span><span class="s1">**</span><span class="s3">2</span><span class="s0">, </span><span class="s3">10</span><span class="s1">**</span><span class="s3">3</span><span class="s1">):</span>
                <span class="s1">A = random_triangle_matrix(n</span><span class="s0">, </span><span class="s1">lower=lower)</span>
                <span class="s0">for </span><span class="s1">m </span><span class="s0">in </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">10</span><span class="s1">):</span>
                    <span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">(np.random.rand(n</span><span class="s0">, </span><span class="s1">m)</span><span class="s0">,</span>
                              <span class="s1">np.random.randint(-</span><span class="s3">9</span><span class="s0">, </span><span class="s3">9</span><span class="s0">, </span><span class="s1">(n</span><span class="s0">, </span><span class="s1">m))</span><span class="s0">,</span>
                              <span class="s1">np.random.randint(-</span><span class="s3">9</span><span class="s0">, </span><span class="s3">9</span><span class="s0">, </span><span class="s1">(n</span><span class="s0">, </span><span class="s1">m)) +</span>
                              <span class="s1">np.random.randint(-</span><span class="s3">9</span><span class="s0">, </span><span class="s3">9</span><span class="s0">, </span><span class="s1">(n</span><span class="s0">, </span><span class="s1">m)) * </span><span class="s3">1j</span><span class="s1">):</span>
                        <span class="s1">x = spsolve_triangular(A</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">lower=lower)</span>
                        <span class="s1">assert_array_almost_equal(A.dot(x)</span><span class="s0">, </span><span class="s1">b)</span>
                        <span class="s1">x = spsolve_triangular(A</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">lower=lower</span><span class="s0">,</span>
                                               <span class="s1">unit_diagonal=</span><span class="s0">True</span><span class="s1">)</span>
                        <span class="s1">A.setdiag(</span><span class="s3">1</span><span class="s1">)</span>
                        <span class="s1">assert_array_almost_equal(A.dot(x)</span><span class="s0">, </span><span class="s1">b)</span>
</pre>
</body>
</html>