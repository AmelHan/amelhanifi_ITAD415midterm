<html>
<head>
<title>survfunc.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
survfunc.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">pandas </span><span class="s0">as </span><span class="s1">pd</span>
<span class="s0">from </span><span class="s1">scipy.stats.distributions </span><span class="s0">import </span><span class="s1">chi2</span><span class="s0">, </span><span class="s1">norm</span>
<span class="s0">from </span><span class="s1">statsmodels.graphics </span><span class="s0">import </span><span class="s1">utils</span>


<span class="s0">def </span><span class="s1">_calc_survfunc_right(time</span><span class="s0">, </span><span class="s1">status</span><span class="s0">, </span><span class="s1">weights=</span><span class="s0">None, </span><span class="s1">entry=</span><span class="s0">None, </span><span class="s1">compress=</span><span class="s0">True,</span>
                         <span class="s1">retall=</span><span class="s0">True</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Calculate the survival function and its standard error for a single 
    group. 
    &quot;&quot;&quot;</span>

    <span class="s3"># Convert the unique times to ranks (0, 1, 2, ...)</span>
    <span class="s0">if </span><span class="s1">entry </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">utime</span><span class="s0">, </span><span class="s1">rtime = np.unique(time</span><span class="s0">, </span><span class="s1">return_inverse=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">tx = np.concatenate((time</span><span class="s0">, </span><span class="s1">entry))</span>
        <span class="s1">utime</span><span class="s0">, </span><span class="s1">rtime = np.unique(tx</span><span class="s0">, </span><span class="s1">return_inverse=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">rtime = rtime[</span><span class="s4">0</span><span class="s1">:len(time)]</span>

    <span class="s3"># Number of deaths at each unique time.</span>
    <span class="s1">ml = len(utime)</span>
    <span class="s0">if </span><span class="s1">weights </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">d = np.bincount(rtime</span><span class="s0">, </span><span class="s1">weights=status</span><span class="s0">, </span><span class="s1">minlength=ml)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">d = np.bincount(rtime</span><span class="s0">, </span><span class="s1">weights=status*weights</span><span class="s0">, </span><span class="s1">minlength=ml)</span>

    <span class="s3"># Size of risk set just prior to each event time.</span>
    <span class="s0">if </span><span class="s1">weights </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">n = np.bincount(rtime</span><span class="s0">, </span><span class="s1">minlength=ml)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">n = np.bincount(rtime</span><span class="s0">, </span><span class="s1">weights=weights</span><span class="s0">, </span><span class="s1">minlength=ml)</span>
    <span class="s0">if </span><span class="s1">entry </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">n = np.cumsum(n) - n</span>
        <span class="s1">rentry = np.searchsorted(utime</span><span class="s0">, </span><span class="s1">entry</span><span class="s0">, </span><span class="s1">side=</span><span class="s5">'left'</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">weights </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">n0 = np.bincount(rentry</span><span class="s0">, </span><span class="s1">minlength=ml)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">n0 = np.bincount(rentry</span><span class="s0">, </span><span class="s1">weights=weights</span><span class="s0">, </span><span class="s1">minlength=ml)</span>
        <span class="s1">n0 = np.cumsum(n0) - n0</span>
        <span class="s1">n = n0 - n</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">n = np.cumsum(n[::-</span><span class="s4">1</span><span class="s1">])[::-</span><span class="s4">1</span><span class="s1">]</span>

    <span class="s3"># Only retain times where an event occurred.</span>
    <span class="s0">if </span><span class="s1">compress:</span>
        <span class="s1">ii = np.flatnonzero(d &gt; </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">d = d[ii]</span>
        <span class="s1">n = n[ii]</span>
        <span class="s1">utime = utime[ii]</span>

    <span class="s3"># The survival function probabilities.</span>
    <span class="s1">sp = </span><span class="s4">1 </span><span class="s1">- d / n.astype(np.float64)</span>
    <span class="s1">ii = sp &lt; </span><span class="s4">1e-16</span>
    <span class="s1">sp[ii] = </span><span class="s4">1e-16</span>
    <span class="s1">sp = np.log(sp)</span>
    <span class="s1">sp = np.cumsum(sp)</span>
    <span class="s1">sp = np.exp(sp)</span>
    <span class="s1">sp[ii] = </span><span class="s4">0</span>

    <span class="s0">if not </span><span class="s1">retall:</span>
        <span class="s0">return </span><span class="s1">sp</span><span class="s0">, </span><span class="s1">utime</span><span class="s0">, </span><span class="s1">rtime</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">d</span>

    <span class="s3"># Standard errors</span>
    <span class="s0">if </span><span class="s1">weights </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s3"># Greenwood's formula</span>
        <span class="s1">denom = n * (n - d)</span>
        <span class="s1">denom = np.clip(denom</span><span class="s0">, </span><span class="s4">1e-12</span><span class="s0">, </span><span class="s1">np.inf)</span>
        <span class="s1">se = d / denom.astype(np.float64)</span>
        <span class="s1">se[(n == d) | (n == </span><span class="s4">0</span><span class="s1">)] = np.nan</span>
        <span class="s1">se = np.cumsum(se)</span>
        <span class="s1">se = np.sqrt(se)</span>
        <span class="s1">locs = np.isfinite(se) | (sp != </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">se[locs] *= sp[locs]</span>
        <span class="s1">se[~locs] = np.nan</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s3"># Tsiatis' (1981) formula</span>
        <span class="s1">se = d / (n * n).astype(np.float64)</span>
        <span class="s1">se = np.cumsum(se)</span>
        <span class="s1">se = np.sqrt(se)</span>

    <span class="s0">return </span><span class="s1">sp</span><span class="s0">, </span><span class="s1">se</span><span class="s0">, </span><span class="s1">utime</span><span class="s0">, </span><span class="s1">rtime</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">d</span>


<span class="s0">def </span><span class="s1">_calc_incidence_right(time</span><span class="s0">, </span><span class="s1">status</span><span class="s0">, </span><span class="s1">weights=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Calculate the cumulative incidence function and its standard error. 
    &quot;&quot;&quot;</span>

    <span class="s3"># Calculate the all-cause survival function.</span>
    <span class="s1">status0 = (status &gt;= </span><span class="s4">1</span><span class="s1">).astype(np.float64)</span>
    <span class="s1">sp</span><span class="s0">, </span><span class="s1">utime</span><span class="s0">, </span><span class="s1">rtime</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, </span><span class="s1">d = _calc_survfunc_right(time</span><span class="s0">, </span><span class="s1">status0</span><span class="s0">, </span><span class="s1">weights</span><span class="s0">,</span>
                                                  <span class="s1">compress=</span><span class="s0">False, </span><span class="s1">retall=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s1">ngrp = int(status.max())</span>

    <span class="s3"># Number of cause-specific deaths at each unique time.</span>
    <span class="s1">d = []</span>
    <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range(ngrp):</span>
        <span class="s1">status0 = (status == k + </span><span class="s4">1</span><span class="s1">).astype(np.float64)</span>
        <span class="s0">if </span><span class="s1">weights </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">d0 = np.bincount(rtime</span><span class="s0">, </span><span class="s1">weights=status0</span><span class="s0">, </span><span class="s1">minlength=len(utime))</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">d0 = np.bincount(rtime</span><span class="s0">, </span><span class="s1">weights=status0*weights</span><span class="s0">,</span>
                             <span class="s1">minlength=len(utime))</span>
        <span class="s1">d.append(d0)</span>

    <span class="s3"># The cumulative incidence function probabilities.</span>
    <span class="s1">ip = []</span>
    <span class="s1">sp0 = np.r_[</span><span class="s4">1</span><span class="s0">, </span><span class="s1">sp[:-</span><span class="s4">1</span><span class="s1">]] / n</span>
    <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range(ngrp):</span>
        <span class="s1">ip0 = np.cumsum(sp0 * d[k])</span>
        <span class="s1">ip.append(ip0)</span>

    <span class="s3"># The standard error of the cumulative incidence function.</span>
    <span class="s0">if </span><span class="s1">weights </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">ip</span><span class="s0">, None, </span><span class="s1">utime</span>
    <span class="s1">se = []</span>
    <span class="s1">da = sum(d)</span>
    <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range(ngrp):</span>

        <span class="s1">ra = da / (n * (n - da))</span>
        <span class="s1">v = ip[k]**</span><span class="s4">2 </span><span class="s1">* np.cumsum(ra)</span>
        <span class="s1">v -= </span><span class="s4">2 </span><span class="s1">* ip[k] * np.cumsum(ip[k] * ra)</span>
        <span class="s1">v += np.cumsum(ip[k]**</span><span class="s4">2 </span><span class="s1">* ra)</span>

        <span class="s1">ra = (n - d[k]) * d[k] / n</span>
        <span class="s1">v += np.cumsum(sp0**</span><span class="s4">2 </span><span class="s1">* ra)</span>

        <span class="s1">ra = sp0 * d[k] / n</span>
        <span class="s1">v -= </span><span class="s4">2 </span><span class="s1">* ip[k] * np.cumsum(ra)</span>
        <span class="s1">v += </span><span class="s4">2 </span><span class="s1">* np.cumsum(ip[k] * ra)</span>

        <span class="s1">se.append(np.sqrt(v))</span>

    <span class="s0">return </span><span class="s1">ip</span><span class="s0">, </span><span class="s1">se</span><span class="s0">, </span><span class="s1">utime</span>


<span class="s0">def </span><span class="s1">_checkargs(time</span><span class="s0">, </span><span class="s1">status</span><span class="s0">, </span><span class="s1">entry</span><span class="s0">, </span><span class="s1">freq_weights</span><span class="s0">, </span><span class="s1">exog):</span>

    <span class="s0">if </span><span class="s1">len(time) != len(status):</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;time and status must have the same length&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">entry </span><span class="s0">is not None and </span><span class="s1">(len(entry) != len(time)):</span>
        <span class="s1">msg = </span><span class="s5">&quot;entry times and event times must have the same length&quot;</span>
        <span class="s0">raise </span><span class="s1">ValueError(msg)</span>

    <span class="s0">if </span><span class="s1">entry </span><span class="s0">is not None and </span><span class="s1">np.any(entry &gt;= time):</span>
        <span class="s1">msg = </span><span class="s5">&quot;Entry times must not occur on or after event times&quot;</span>
        <span class="s0">raise </span><span class="s1">ValueError(msg)</span>

    <span class="s0">if </span><span class="s1">freq_weights </span><span class="s0">is not None and </span><span class="s1">(len(freq_weights) != len(time)):</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;weights, time and status must have the same length&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">exog </span><span class="s0">is not None and </span><span class="s1">(exog.shape[</span><span class="s4">0</span><span class="s1">] != len(time)):</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;the rows of exog should align with time&quot;</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">CumIncidenceRight:</span>
    <span class="s2">&quot;&quot;&quot; 
    Estimation and inference for a cumulative incidence function. 
 
    If J = 1, 2, ... indicates the event type, the cumulative 
    incidence function for cause j is: 
 
    I(t, j) = P(T &lt;= t and J=j) 
 
    Only right censoring is supported.  If frequency weights are provided, 
    the point estimate is returned without a standard error. 
 
    Parameters 
    ---------- 
    time : array_like 
        An array of times (censoring times or event times) 
    status : array_like 
        If status &gt;= 1 indicates which event occurred at time t.  If 
        status = 0, the subject was censored at time t. 
    title : str 
        Optional title used for plots and summary output. 
    freq_weights : array_like 
        Optional frequency weights 
    exog : array_like 
        Optional, if present used to account for violation of 
        independent censoring. 
    bw_factor : float 
        Band-width multiplier for kernel-based estimation.  Only 
        used if exog is provided. 
    dimred : bool 
        If True, proportional hazards regression models are used to 
        reduce exog to two columns by predicting overall events and 
        censoring in two separate models.  If False, exog is used 
        directly for calculating kernel weights without dimension 
        reduction. 
 
    Attributes 
    ---------- 
    times : array_like 
        The distinct times at which the incidence rates are estimated 
    cinc : list of arrays 
        cinc[k-1] contains the estimated cumulative incidence rates 
        for outcome k=1,2,... 
    cinc_se : list of arrays 
        The standard errors for the values in `cinc`.  Not available when 
        exog and/or frequency weights are provided. 
 
    Notes 
    ----- 
    When exog is provided, a local estimate of the cumulative incidence 
    rate around each point is provided, and these are averaged to 
    produce an estimate of the marginal cumulative incidence 
    functions.  The procedure is analogous to that described in Zeng 
    (2004) for estimation of the marginal survival function.  The 
    approach removes bias resulting from dependent censoring when the 
    censoring becomes independent conditioned on the columns of exog. 
 
    References 
    ---------- 
    The Stata stcompet procedure: 
        http://www.stata-journal.com/sjpdf.html?articlenum=st0059 
 
    Dinse, G. E. and M. G. Larson. 1986. A note on semi-Markov models 
    for partially censored data. Biometrika 73: 379-386. 
 
    Marubini, E. and M. G. Valsecchi. 1995. Analysing Survival Data 
    from Clinical Trials and Observational Studies. Chichester, UK: 
    John Wiley &amp; Sons. 
 
    D. Zeng (2004).  Estimating marginal survival function by 
    adjusting for dependent censoring using many covariates.  Annals 
    of Statistics 32:4. 
    https://arxiv.org/pdf/math/0409180.pdf 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">time</span><span class="s0">, </span><span class="s1">status</span><span class="s0">, </span><span class="s1">title=</span><span class="s0">None, </span><span class="s1">freq_weights=</span><span class="s0">None,</span>
                 <span class="s1">exog=</span><span class="s0">None, </span><span class="s1">bw_factor=</span><span class="s4">1.</span><span class="s0">, </span><span class="s1">dimred=</span><span class="s0">True</span><span class="s1">):</span>

        <span class="s1">_checkargs(time</span><span class="s0">, </span><span class="s1">status</span><span class="s0">, None, </span><span class="s1">freq_weights</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s1">time = self.time = np.asarray(time)</span>
        <span class="s1">status = self.status = np.asarray(status)</span>
        <span class="s0">if </span><span class="s1">freq_weights </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">freq_weights = self.freq_weights = np.asarray(freq_weights)</span>

        <span class="s0">if </span><span class="s1">exog </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">from </span><span class="s1">._kernel_estimates </span><span class="s0">import </span><span class="s1">_kernel_cumincidence</span>
            <span class="s1">exog = self.exog = np.asarray(exog)</span>
            <span class="s1">nobs = exog.shape[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">kw = nobs**(-</span><span class="s4">1</span><span class="s1">/</span><span class="s4">3.0</span><span class="s1">) * bw_factor</span>
            <span class="s1">kfunc = </span><span class="s0">lambda </span><span class="s1">x: np.exp(-x**</span><span class="s4">2 </span><span class="s1">/ kw**</span><span class="s4">2</span><span class="s1">).sum(</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">x = _kernel_cumincidence(time</span><span class="s0">, </span><span class="s1">status</span><span class="s0">, </span><span class="s1">exog</span><span class="s0">, </span><span class="s1">kfunc</span><span class="s0">, </span><span class="s1">freq_weights</span><span class="s0">,</span>
                                     <span class="s1">dimred)</span>
            <span class="s1">self.times = x[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">self.cinc = x[</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s0">return</span>

        <span class="s1">x = _calc_incidence_right(time</span><span class="s0">, </span><span class="s1">status</span><span class="s0">, </span><span class="s1">freq_weights)</span>
        <span class="s1">self.cinc = x[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">self.cinc_se = x[</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">self.times = x[</span><span class="s4">2</span><span class="s1">]</span>
        <span class="s1">self.title = </span><span class="s5">&quot;&quot; </span><span class="s0">if not </span><span class="s1">title </span><span class="s0">else </span><span class="s1">title</span>


<span class="s0">class </span><span class="s1">SurvfuncRight:</span>
    <span class="s2">&quot;&quot;&quot; 
    Estimation and inference for a survival function. 
 
    The survival function S(t) = P(T &gt; t) is the probability that an 
    event time T is greater than t. 
 
    This class currently only supports right censoring. 
 
    Parameters 
    ---------- 
    time : array_like 
        An array of times (censoring times or event times) 
    status : array_like 
        Status at the event time, status==1 is the 'event' 
        (e.g. death, failure), meaning that the event 
        occurs at the given value in `time`; status==0 
        indicates that censoring has occurred, meaning that 
        the event occurs after the given value in `time`. 
    entry : array_like, optional An array of entry times for handling 
        left truncation (the subject is not in the risk set on or 
        before the entry time) 
    title : str 
        Optional title used for plots and summary output. 
    freq_weights : array_like 
        Optional frequency weights 
    exog : array_like 
        Optional, if present used to account for violation of 
        independent censoring. 
    bw_factor : float 
        Band-width multiplier for kernel-based estimation.  Only used 
        if exog is provided. 
 
    Attributes 
    ---------- 
    surv_prob : array_like 
        The estimated value of the survivor function at each time 
        point in `surv_times`. 
    surv_prob_se : array_like 
        The standard errors for the values in `surv_prob`.  Not available 
        if exog is provided. 
    surv_times : array_like 
        The points where the survival function changes. 
    n_risk : array_like 
        The number of subjects at risk just before each time value in 
        `surv_times`.  Not available if exog is provided. 
    n_events : array_like 
        The number of events (e.g. deaths) that occur at each point 
        in `surv_times`.  Not available if exog is provided. 
 
    Notes 
    ----- 
    If exog is None, the standard Kaplan-Meier estimator is used.  If 
    exog is not None, a local estimate of the marginal survival 
    function around each point is constructed, and these are then 
    averaged.  This procedure gives an estimate of the marginal 
    survival function that accounts for dependent censoring as long as 
    the censoring becomes independent when conditioning on the 
    covariates in exog.  See Zeng et al. (2004) for details. 
 
    References 
    ---------- 
    D. Zeng (2004).  Estimating marginal survival function by 
    adjusting for dependent censoring using many covariates.  Annals 
    of Statistics 32:4. 
    https://arxiv.org/pdf/math/0409180.pdf 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">time</span><span class="s0">, </span><span class="s1">status</span><span class="s0">, </span><span class="s1">entry=</span><span class="s0">None, </span><span class="s1">title=</span><span class="s0">None,</span>
                 <span class="s1">freq_weights=</span><span class="s0">None, </span><span class="s1">exog=</span><span class="s0">None, </span><span class="s1">bw_factor=</span><span class="s4">1.</span><span class="s1">):</span>

        <span class="s1">_checkargs(time</span><span class="s0">, </span><span class="s1">status</span><span class="s0">, </span><span class="s1">entry</span><span class="s0">, </span><span class="s1">freq_weights</span><span class="s0">, </span><span class="s1">exog)</span>
        <span class="s1">time = self.time = np.asarray(time)</span>
        <span class="s1">status = self.status = np.asarray(status)</span>
        <span class="s0">if </span><span class="s1">freq_weights </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">freq_weights = self.freq_weights = np.asarray(freq_weights)</span>

        <span class="s0">if </span><span class="s1">entry </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">entry = self.entry = np.asarray(entry)</span>

        <span class="s0">if </span><span class="s1">exog </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">entry </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;exog and entry cannot both be present&quot;</span><span class="s1">)</span>
            <span class="s0">from </span><span class="s1">._kernel_estimates </span><span class="s0">import </span><span class="s1">_kernel_survfunc</span>
            <span class="s1">exog = self.exog = np.asarray(exog)</span>
            <span class="s1">nobs = exog.shape[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">kw = nobs**(-</span><span class="s4">1</span><span class="s1">/</span><span class="s4">3.0</span><span class="s1">) * bw_factor</span>
            <span class="s1">kfunc = </span><span class="s0">lambda </span><span class="s1">x: np.exp(-x**</span><span class="s4">2 </span><span class="s1">/ kw**</span><span class="s4">2</span><span class="s1">).sum(</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">x = _kernel_survfunc(time</span><span class="s0">, </span><span class="s1">status</span><span class="s0">, </span><span class="s1">exog</span><span class="s0">, </span><span class="s1">kfunc</span><span class="s0">, </span><span class="s1">freq_weights)</span>
            <span class="s1">self.surv_prob = x[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">self.surv_times = x[</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s0">return</span>

        <span class="s1">x = _calc_survfunc_right(time</span><span class="s0">, </span><span class="s1">status</span><span class="s0">, </span><span class="s1">weights=freq_weights</span><span class="s0">,</span>
                                 <span class="s1">entry=entry)</span>

        <span class="s1">self.surv_prob = x[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">self.surv_prob_se = x[</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">self.surv_times = x[</span><span class="s4">2</span><span class="s1">]</span>
        <span class="s1">self.n_risk = x[</span><span class="s4">4</span><span class="s1">]</span>
        <span class="s1">self.n_events = x[</span><span class="s4">5</span><span class="s1">]</span>
        <span class="s1">self.title = </span><span class="s5">&quot;&quot; </span><span class="s0">if not </span><span class="s1">title </span><span class="s0">else </span><span class="s1">title</span>

    <span class="s0">def </span><span class="s1">plot(self</span><span class="s0">, </span><span class="s1">ax=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Plot the survival function. 
 
        Examples 
        -------- 
        Change the line color: 
 
        &gt;&gt;&gt; import statsmodels.api as sm 
        &gt;&gt;&gt; data = sm.datasets.get_rdataset(&quot;flchain&quot;, &quot;survival&quot;).data 
        &gt;&gt;&gt; df = data.loc[data.sex == &quot;F&quot;, :] 
        &gt;&gt;&gt; sf = sm.SurvfuncRight(df[&quot;futime&quot;], df[&quot;death&quot;]) 
        &gt;&gt;&gt; fig = sf.plot() 
        &gt;&gt;&gt; ax = fig.get_axes()[0] 
        &gt;&gt;&gt; li = ax.get_lines() 
        &gt;&gt;&gt; li[0].set_color('purple') 
        &gt;&gt;&gt; li[1].set_color('purple') 
 
        Do not show the censoring points: 
 
        &gt;&gt;&gt; fig = sf.plot() 
        &gt;&gt;&gt; ax = fig.get_axes()[0] 
        &gt;&gt;&gt; li = ax.get_lines() 
        &gt;&gt;&gt; li[1].set_visible(False) 
        &quot;&quot;&quot;</span>

        <span class="s0">return </span><span class="s1">plot_survfunc(self</span><span class="s0">, </span><span class="s1">ax)</span>

    <span class="s0">def </span><span class="s1">quantile(self</span><span class="s0">, </span><span class="s1">p):</span>
        <span class="s2">&quot;&quot;&quot; 
        Estimated quantile of a survival distribution. 
 
        Parameters 
        ---------- 
        p : float 
            The probability point at which the quantile 
            is determined. 
 
        Returns the estimated quantile. 
        &quot;&quot;&quot;</span>

        <span class="s3"># SAS uses a strict inequality here.</span>
        <span class="s1">ii = np.flatnonzero(self.surv_prob &lt; </span><span class="s4">1 </span><span class="s1">- p)</span>

        <span class="s0">if </span><span class="s1">len(ii) == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">np.nan</span>

        <span class="s0">return </span><span class="s1">self.surv_times[ii[</span><span class="s4">0</span><span class="s1">]]</span>

    <span class="s0">def </span><span class="s1">quantile_ci(self</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">alpha=</span><span class="s4">0.05</span><span class="s0">, </span><span class="s1">method=</span><span class="s5">'cloglog'</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Returns a confidence interval for a survival quantile. 
 
        Parameters 
        ---------- 
        p : float 
            The probability point for which a confidence interval is 
            determined. 
        alpha : float 
            The confidence interval has nominal coverage probability 
            1 - `alpha`. 
        method : str 
            Function to use for g-transformation, must be ... 
 
        Returns 
        ------- 
        lb : float 
            The lower confidence limit. 
        ub : float 
            The upper confidence limit. 
 
        Notes 
        ----- 
        The confidence interval is obtained by inverting Z-tests.  The 
        limits of the confidence interval will always be observed 
        event times. 
 
        References 
        ---------- 
        The method is based on the approach used in SAS, documented here: 
 
          http://support.sas.com/documentation/cdl/en/statug/68162/HTML/default/viewer.htm#statug_lifetest_details03.htm 
        &quot;&quot;&quot;</span>

        <span class="s1">tr = norm.ppf(</span><span class="s4">1 </span><span class="s1">- alpha / </span><span class="s4">2</span><span class="s1">)</span>

        <span class="s1">method = method.lower()</span>
        <span class="s0">if </span><span class="s1">method == </span><span class="s5">&quot;cloglog&quot;</span><span class="s1">:</span>
            <span class="s1">g = </span><span class="s0">lambda </span><span class="s1">x: np.log(-np.log(x))</span>
            <span class="s1">gprime = </span><span class="s0">lambda </span><span class="s1">x: -</span><span class="s4">1 </span><span class="s1">/ (x * np.log(x))</span>
        <span class="s0">elif </span><span class="s1">method == </span><span class="s5">&quot;linear&quot;</span><span class="s1">:</span>
            <span class="s1">g = </span><span class="s0">lambda </span><span class="s1">x: x</span>
            <span class="s1">gprime = </span><span class="s0">lambda </span><span class="s1">x: </span><span class="s4">1</span>
        <span class="s0">elif </span><span class="s1">method == </span><span class="s5">&quot;log&quot;</span><span class="s1">:</span>
            <span class="s1">g = np.log</span>
            <span class="s1">gprime = </span><span class="s0">lambda </span><span class="s1">x: </span><span class="s4">1 </span><span class="s1">/ x</span>
        <span class="s0">elif </span><span class="s1">method == </span><span class="s5">&quot;logit&quot;</span><span class="s1">:</span>
            <span class="s1">g = </span><span class="s0">lambda </span><span class="s1">x: np.log(x / (</span><span class="s4">1 </span><span class="s1">- x))</span>
            <span class="s1">gprime = </span><span class="s0">lambda </span><span class="s1">x: </span><span class="s4">1 </span><span class="s1">/ (x * (</span><span class="s4">1 </span><span class="s1">- x))</span>
        <span class="s0">elif </span><span class="s1">method == </span><span class="s5">&quot;asinsqrt&quot;</span><span class="s1">:</span>
            <span class="s1">g = </span><span class="s0">lambda </span><span class="s1">x: np.arcsin(np.sqrt(x))</span>
            <span class="s1">gprime = </span><span class="s0">lambda </span><span class="s1">x: </span><span class="s4">1 </span><span class="s1">/ (</span><span class="s4">2 </span><span class="s1">* np.sqrt(x) * np.sqrt(</span><span class="s4">1 </span><span class="s1">- x))</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;unknown method&quot;</span><span class="s1">)</span>

        <span class="s1">r = g(self.surv_prob) - g(</span><span class="s4">1 </span><span class="s1">- p)</span>
        <span class="s1">r /= (gprime(self.surv_prob) * self.surv_prob_se)</span>

        <span class="s1">ii = np.flatnonzero(np.abs(r) &lt;= tr)</span>
        <span class="s0">if </span><span class="s1">len(ii) == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan</span>

        <span class="s1">lb = self.surv_times[ii[</span><span class="s4">0</span><span class="s1">]]</span>

        <span class="s0">if </span><span class="s1">ii[-</span><span class="s4">1</span><span class="s1">] == len(self.surv_times) - </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">ub = np.inf</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">ub = self.surv_times[ii[-</span><span class="s4">1</span><span class="s1">] + </span><span class="s4">1</span><span class="s1">]</span>

        <span class="s0">return </span><span class="s1">lb</span><span class="s0">, </span><span class="s1">ub</span>

    <span class="s0">def </span><span class="s1">summary(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Return a summary of the estimated survival function. 
 
        The summary is a dataframe containing the unique event times, 
        estimated survival function values, and related quantities. 
        &quot;&quot;&quot;</span>

        <span class="s1">df = pd.DataFrame(index=self.surv_times)</span>
        <span class="s1">df.index.name = </span><span class="s5">&quot;Time&quot;</span>
        <span class="s1">df[</span><span class="s5">&quot;Surv prob&quot;</span><span class="s1">] = self.surv_prob</span>
        <span class="s1">df[</span><span class="s5">&quot;Surv prob SE&quot;</span><span class="s1">] = self.surv_prob_se</span>
        <span class="s1">df[</span><span class="s5">&quot;num at risk&quot;</span><span class="s1">] = self.n_risk</span>
        <span class="s1">df[</span><span class="s5">&quot;num events&quot;</span><span class="s1">] = self.n_events</span>

        <span class="s0">return </span><span class="s1">df</span>

    <span class="s0">def </span><span class="s1">simultaneous_cb(self</span><span class="s0">, </span><span class="s1">alpha=</span><span class="s4">0.05</span><span class="s0">, </span><span class="s1">method=</span><span class="s5">&quot;hw&quot;</span><span class="s0">, </span><span class="s1">transform=</span><span class="s5">&quot;log&quot;</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Returns a simultaneous confidence band for the survival function. 
 
        Parameters 
        ---------- 
        alpha : float 
            `1 - alpha` is the desired simultaneous coverage 
            probability for the confidence region.  Currently alpha 
            must be set to 0.05, giving 95% simultaneous intervals. 
        method : str 
            The method used to produce the simultaneous confidence 
            band.  Only the Hall-Wellner (hw) method is currently 
            implemented. 
        transform : str 
            The used to produce the interval (note that the returned 
            interval is on the survival probability scale regardless 
            of which transform is used).  Only `log` and `arcsin` are 
            implemented. 
 
        Returns 
        ------- 
        lcb : array_like 
            The lower confidence limits corresponding to the points 
            in `surv_times`. 
        ucb : array_like 
            The upper confidence limits corresponding to the points 
            in `surv_times`. 
        &quot;&quot;&quot;</span>

        <span class="s1">method = method.lower()</span>
        <span class="s0">if </span><span class="s1">method != </span><span class="s5">&quot;hw&quot;</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s5">&quot;only the Hall-Wellner (hw) method is implemented&quot;</span>
            <span class="s0">raise </span><span class="s1">ValueError(msg)</span>

        <span class="s0">if </span><span class="s1">alpha != </span><span class="s4">0.05</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;alpha must be set to 0.05&quot;</span><span class="s1">)</span>

        <span class="s1">transform = transform.lower()</span>
        <span class="s1">s2 = self.surv_prob_se**</span><span class="s4">2 </span><span class="s1">/ self.surv_prob**</span><span class="s4">2</span>
        <span class="s1">nn = self.n_risk</span>
        <span class="s0">if </span><span class="s1">transform == </span><span class="s5">&quot;log&quot;</span><span class="s1">:</span>
            <span class="s1">denom = np.sqrt(nn) * np.log(self.surv_prob)</span>
            <span class="s1">theta = </span><span class="s4">1.3581 </span><span class="s1">* (</span><span class="s4">1 </span><span class="s1">+ nn * s2) / denom</span>
            <span class="s1">theta = np.exp(theta)</span>
            <span class="s1">lcb = self.surv_prob**(</span><span class="s4">1</span><span class="s1">/theta)</span>
            <span class="s1">ucb = self.surv_prob**theta</span>
        <span class="s0">elif </span><span class="s1">transform == </span><span class="s5">&quot;arcsin&quot;</span><span class="s1">:</span>
            <span class="s1">k = </span><span class="s4">1.3581</span>
            <span class="s1">k *= (</span><span class="s4">1 </span><span class="s1">+ nn * s2) / (</span><span class="s4">2 </span><span class="s1">* np.sqrt(nn))</span>
            <span class="s1">k *= np.sqrt(self.surv_prob / (</span><span class="s4">1 </span><span class="s1">- self.surv_prob))</span>
            <span class="s1">f = np.arcsin(np.sqrt(self.surv_prob))</span>
            <span class="s1">v = np.clip(f - k</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">np.inf)</span>
            <span class="s1">lcb = np.sin(v)**</span><span class="s4">2</span>
            <span class="s1">v = np.clip(f + k</span><span class="s0">, </span><span class="s1">-np.inf</span><span class="s0">, </span><span class="s1">np.pi/</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s1">ucb = np.sin(v)**</span><span class="s4">2</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;Unknown transform&quot;</span><span class="s1">)</span>

        <span class="s0">return </span><span class="s1">lcb</span><span class="s0">, </span><span class="s1">ucb</span>


<span class="s0">def </span><span class="s1">survdiff(time</span><span class="s0">, </span><span class="s1">status</span><span class="s0">, </span><span class="s1">group</span><span class="s0">, </span><span class="s1">weight_type=</span><span class="s0">None, </span><span class="s1">strata=</span><span class="s0">None,</span>
             <span class="s1">entry=</span><span class="s0">None, </span><span class="s1">**kwargs):</span>
    <span class="s2">&quot;&quot;&quot; 
    Test for the equality of two survival distributions. 
 
    Parameters 
    ---------- 
    time : array_like 
        The event or censoring times. 
    status : array_like 
        The censoring status variable, status=1 indicates that the 
        event occurred, status=0 indicates that the observation was 
        censored. 
    group : array_like 
        Indicators of the two groups 
    weight_type : str 
        The following weight types are implemented: 
            None (default) : logrank test 
            fh : Fleming-Harrington, weights by S^(fh_p), 
                 requires exponent fh_p to be provided as keyword 
                 argument; the weights are derived from S defined at 
                 the previous event time, and the first weight is 
                 always 1. 
            gb : Gehan-Breslow, weights by the number at risk 
            tw : Tarone-Ware, weights by the square root of the number 
                 at risk 
    strata : array_like 
        Optional stratum indicators for a stratified test 
    entry : array_like 
        Entry times to handle left truncation. The subject is not in 
        the risk set on or before the entry time. 
 
    Returns 
    ------- 
    chisq : The chi-square (1 degree of freedom) distributed test 
            statistic value 
    pvalue : The p-value for the chi^2 test 
    &quot;&quot;&quot;</span>

    <span class="s1">time = np.asarray(time)</span>
    <span class="s1">status = np.asarray(status)</span>
    <span class="s1">group = np.asarray(group)</span>

    <span class="s1">gr = np.unique(group)</span>

    <span class="s0">if </span><span class="s1">strata </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">obs</span><span class="s0">, </span><span class="s1">var = _survdiff(time</span><span class="s0">, </span><span class="s1">status</span><span class="s0">, </span><span class="s1">group</span><span class="s0">, </span><span class="s1">weight_type</span><span class="s0">, </span><span class="s1">gr</span><span class="s0">,</span>
                             <span class="s1">entry</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">strata = np.asarray(strata)</span>
        <span class="s1">stu = np.unique(strata)</span>
        <span class="s1">obs</span><span class="s0">, </span><span class="s1">var = </span><span class="s4">0.</span><span class="s0">, </span><span class="s4">0.</span>
        <span class="s0">for </span><span class="s1">st </span><span class="s0">in </span><span class="s1">stu:</span>
            <span class="s3"># could be more efficient?</span>
            <span class="s1">ii = (strata == st)</span>
            <span class="s1">obs1</span><span class="s0">, </span><span class="s1">var1 = _survdiff(time[ii]</span><span class="s0">, </span><span class="s1">status[ii]</span><span class="s0">, </span><span class="s1">group[ii]</span><span class="s0">,</span>
                                   <span class="s1">weight_type</span><span class="s0">, </span><span class="s1">gr</span><span class="s0">, </span><span class="s1">entry</span><span class="s0">, </span><span class="s1">**kwargs)</span>
            <span class="s1">obs += obs1</span>
            <span class="s1">var += var1</span>

    <span class="s1">chisq = obs.dot(np.linalg.solve(var</span><span class="s0">, </span><span class="s1">obs))  </span><span class="s3"># (O - E).T * V^(-1) * (O - E)</span>
    <span class="s1">pvalue = </span><span class="s4">1 </span><span class="s1">- chi2.cdf(chisq</span><span class="s0">, </span><span class="s1">len(gr)-</span><span class="s4">1</span><span class="s1">)</span>

    <span class="s0">return </span><span class="s1">chisq</span><span class="s0">, </span><span class="s1">pvalue</span>


<span class="s0">def </span><span class="s1">_survdiff(time</span><span class="s0">, </span><span class="s1">status</span><span class="s0">, </span><span class="s1">group</span><span class="s0">, </span><span class="s1">weight_type</span><span class="s0">, </span><span class="s1">gr</span><span class="s0">, </span><span class="s1">entry=</span><span class="s0">None,</span>
              <span class="s1">**kwargs):</span>
    <span class="s3"># logrank test for one stratum</span>
    <span class="s3"># calculations based on https://web.stanford.edu/~lutian/coursepdf/unit6.pdf</span>
    <span class="s3"># formula for variance better to take from https://web.stanford.edu/~lutian/coursepdf/survweek3.pdf</span>

    <span class="s3"># Get the unique times.</span>
    <span class="s0">if </span><span class="s1">entry </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">utimes</span><span class="s0">, </span><span class="s1">rtimes = np.unique(time</span><span class="s0">, </span><span class="s1">return_inverse=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">utimes</span><span class="s0">, </span><span class="s1">rtimes = np.unique(np.concatenate((time</span><span class="s0">, </span><span class="s1">entry))</span><span class="s0">,</span>
                                   <span class="s1">return_inverse=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">rtimes = rtimes[</span><span class="s4">0</span><span class="s1">:len(time)]</span>

    <span class="s3"># Split entry times by group if present (should use pandas groupby)</span>
    <span class="s1">tse = [(gr_i</span><span class="s0">, None</span><span class="s1">) </span><span class="s0">for </span><span class="s1">gr_i </span><span class="s0">in </span><span class="s1">gr]</span>
    <span class="s0">if </span><span class="s1">entry </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">enumerate(gr):</span>
            <span class="s1">ii = (group == gr[k])</span>
            <span class="s1">entry1 = entry[ii]</span>
            <span class="s1">tse[k] = (gr[k]</span><span class="s0">, </span><span class="s1">entry1)</span>

    <span class="s3"># Event count and risk set size at each time point, per group and overall.</span>
    <span class="s3"># TODO: should use Pandas groupby</span>
    <span class="s1">nrisk</span><span class="s0">, </span><span class="s1">obsv = []</span><span class="s0">, </span><span class="s1">[]</span>
    <span class="s1">ml = len(utimes)</span>
    <span class="s0">for </span><span class="s1">g</span><span class="s0">, </span><span class="s1">entry0 </span><span class="s0">in </span><span class="s1">tse:</span>

        <span class="s1">mk = (group == g)</span>
        <span class="s1">n = np.bincount(rtimes</span><span class="s0">, </span><span class="s1">weights=mk</span><span class="s0">, </span><span class="s1">minlength=ml)</span>

        <span class="s1">ob = np.bincount(rtimes</span><span class="s0">, </span><span class="s1">weights=status*mk</span><span class="s0">, </span><span class="s1">minlength=ml)</span>
        <span class="s1">obsv.append(ob)</span>

        <span class="s0">if </span><span class="s1">entry </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">n = np.cumsum(n) - n</span>
            <span class="s1">rentry = np.searchsorted(utimes</span><span class="s0">, </span><span class="s1">entry0</span><span class="s0">, </span><span class="s1">side=</span><span class="s5">'left'</span><span class="s1">)</span>
            <span class="s1">n0 = np.bincount(rentry</span><span class="s0">, </span><span class="s1">minlength=ml)</span>
            <span class="s1">n0 = np.cumsum(n0) - n0</span>
            <span class="s1">nr = n0 - n</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">nr = np.cumsum(n[::-</span><span class="s4">1</span><span class="s1">])[::-</span><span class="s4">1</span><span class="s1">]</span>

        <span class="s1">nrisk.append(nr)</span>

    <span class="s1">obs = sum(obsv)</span>
    <span class="s1">nrisk_tot = sum(nrisk)</span>
    <span class="s1">ix = np.flatnonzero(nrisk_tot &gt; </span><span class="s4">1</span><span class="s1">)</span>

    <span class="s1">weights = </span><span class="s0">None</span>
    <span class="s0">if </span><span class="s1">weight_type </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">weight_type = weight_type.lower()</span>
        <span class="s0">if </span><span class="s1">weight_type == </span><span class="s5">&quot;gb&quot;</span><span class="s1">:</span>
            <span class="s1">weights = nrisk_tot</span>
        <span class="s0">elif </span><span class="s1">weight_type == </span><span class="s5">&quot;tw&quot;</span><span class="s1">:</span>
            <span class="s1">weights = np.sqrt(nrisk_tot)</span>
        <span class="s0">elif </span><span class="s1">weight_type == </span><span class="s5">&quot;fh&quot;</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s5">&quot;fh_p&quot; </span><span class="s0">not in </span><span class="s1">kwargs:</span>
                <span class="s1">msg = </span><span class="s5">&quot;weight_type type 'fh' requires specification of fh_p&quot;</span>
                <span class="s0">raise </span><span class="s1">ValueError(msg)</span>
            <span class="s1">fh_p = kwargs[</span><span class="s5">&quot;fh_p&quot;</span><span class="s1">]</span>
            <span class="s3"># Calculate the survivor function directly to avoid the</span>
            <span class="s3"># overhead of creating a SurvfuncRight object</span>
            <span class="s1">sp = </span><span class="s4">1 </span><span class="s1">- obs / nrisk_tot.astype(np.float64)</span>
            <span class="s1">sp = np.log(sp)</span>
            <span class="s1">sp = np.cumsum(sp)</span>
            <span class="s1">sp = np.exp(sp)</span>
            <span class="s1">weights = sp**fh_p</span>
            <span class="s1">weights = np.roll(weights</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">weights[</span><span class="s4">0</span><span class="s1">] = </span><span class="s4">1</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s5">&quot;weight_type not implemented&quot;</span><span class="s1">)</span>

    <span class="s1">dfs = len(gr) - </span><span class="s4">1</span>
    <span class="s1">r = np.vstack(nrisk) / np.clip(nrisk_tot</span><span class="s0">, </span><span class="s4">1e-10</span><span class="s0">, </span><span class="s1">np.inf)[</span><span class="s0">None, </span><span class="s1">:]  </span><span class="s3"># each line is timeseries of r's. line per group</span>

    <span class="s3"># The variance of event counts in each group.</span>
    <span class="s1">groups_oe = []</span>
    <span class="s1">groups_var = []</span>

    <span class="s1">var_denom = nrisk_tot - </span><span class="s4">1</span>
    <span class="s1">var_denom = np.clip(var_denom</span><span class="s0">, </span><span class="s4">1e-10</span><span class="s0">, </span><span class="s1">np.inf)</span>

    <span class="s3"># use the first group as a reference</span>
    <span class="s0">for </span><span class="s1">g </span><span class="s0">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s0">, </span><span class="s1">dfs+</span><span class="s4">1</span><span class="s1">):</span>
        <span class="s3"># Difference between observed and  expected number of events in the group #g</span>
        <span class="s1">oe = obsv[g] - r[g]*obs</span>

        <span class="s3"># build one row of the dfs x dfs variance matrix</span>
        <span class="s1">var_tensor_part = r[</span><span class="s4">1</span><span class="s1">:</span><span class="s0">, </span><span class="s1">:].T * (np.eye(</span><span class="s4">1</span><span class="s0">, </span><span class="s1">dfs</span><span class="s0">, </span><span class="s1">g-</span><span class="s4">1</span><span class="s1">).ravel() - r[g</span><span class="s0">, </span><span class="s1">:</span><span class="s0">, None</span><span class="s1">])  </span><span class="s3"># r*(1 - r) in multidim</span>
        <span class="s1">var_scalar_part = obs * (nrisk_tot - obs) / var_denom</span>
        <span class="s1">var = var_tensor_part * var_scalar_part[:</span><span class="s0">, None</span><span class="s1">]</span>

        <span class="s0">if </span><span class="s1">weights </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">oe = weights * oe</span>
            <span class="s1">var = (weights**</span><span class="s4">2</span><span class="s1">)[:</span><span class="s0">, None</span><span class="s1">] * var</span>

        <span class="s3"># sum over times and store</span>
        <span class="s1">groups_oe.append(oe[ix].sum())</span>
        <span class="s1">groups_var.append(var[ix].sum(axis=</span><span class="s4">0</span><span class="s1">))</span>

    <span class="s1">obs_vec = np.hstack(groups_oe)</span>
    <span class="s1">var_mat = np.vstack(groups_var)</span>

    <span class="s0">return </span><span class="s1">obs_vec</span><span class="s0">, </span><span class="s1">var_mat</span>


<span class="s0">def </span><span class="s1">plot_survfunc(survfuncs</span><span class="s0">, </span><span class="s1">ax=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Plot one or more survivor functions. 
 
    Parameters 
    ---------- 
    survfuncs : object or array_like 
        A single SurvfuncRight object, or a list or SurvfuncRight 
        objects that are plotted together. 
 
    Returns 
    ------- 
    A figure instance on which the plot was drawn. 
 
    Examples 
    -------- 
    Add a legend: 
 
    &gt;&gt;&gt; import statsmodels.api as sm 
    &gt;&gt;&gt; from statsmodels.duration.survfunc import plot_survfunc 
    &gt;&gt;&gt; data = sm.datasets.get_rdataset(&quot;flchain&quot;, &quot;survival&quot;).data 
    &gt;&gt;&gt; df = data.loc[data.sex == &quot;F&quot;, :] 
    &gt;&gt;&gt; sf0 = sm.SurvfuncRight(df[&quot;futime&quot;], df[&quot;death&quot;]) 
    &gt;&gt;&gt; sf1 = sm.SurvfuncRight(3.0 * df[&quot;futime&quot;], df[&quot;death&quot;]) 
    &gt;&gt;&gt; fig = plot_survfunc([sf0, sf1]) 
    &gt;&gt;&gt; ax = fig.get_axes()[0] 
    &gt;&gt;&gt; ax.set_position([0.1, 0.1, 0.64, 0.8]) 
    &gt;&gt;&gt; ha, lb = ax.get_legend_handles_labels() 
    &gt;&gt;&gt; leg = fig.legend((ha[0], ha[1]), (lb[0], lb[1]), loc='center right') 
 
    Change the line colors: 
 
    &gt;&gt;&gt; fig = plot_survfunc([sf0, sf1]) 
    &gt;&gt;&gt; ax = fig.get_axes()[0] 
    &gt;&gt;&gt; ax.set_position([0.1, 0.1, 0.64, 0.8]) 
    &gt;&gt;&gt; ha, lb = ax.get_legend_handles_labels() 
    &gt;&gt;&gt; ha[0].set_color('purple') 
    &gt;&gt;&gt; ha[1].set_color('orange') 
    &quot;&quot;&quot;</span>

    <span class="s1">fig</span><span class="s0">, </span><span class="s1">ax = utils.create_mpl_ax(ax)</span>

    <span class="s3"># If we have only a single survival function to plot, put it into</span>
    <span class="s3"># a list.</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">assert </span><span class="s1">type(survfuncs[</span><span class="s4">0</span><span class="s1">]) </span><span class="s0">is </span><span class="s1">SurvfuncRight</span>
    <span class="s0">except</span><span class="s1">:</span>
        <span class="s1">survfuncs = [survfuncs]</span>

    <span class="s0">for </span><span class="s1">gx</span><span class="s0">, </span><span class="s1">sf </span><span class="s0">in </span><span class="s1">enumerate(survfuncs):</span>

        <span class="s3"># The estimated survival function does not include a point at</span>
        <span class="s3"># time 0, include it here for plotting.</span>
        <span class="s1">surv_times = np.concatenate(([</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">sf.surv_times))</span>
        <span class="s1">surv_prob = np.concatenate(([</span><span class="s4">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">sf.surv_prob))</span>

        <span class="s3"># If the final times are censoring times they are not included</span>
        <span class="s3"># in the survival function so we add them here</span>
        <span class="s1">mxt = max(sf.time)</span>
        <span class="s0">if </span><span class="s1">mxt &gt; surv_times[-</span><span class="s4">1</span><span class="s1">]:</span>
            <span class="s1">surv_times = np.concatenate((surv_times</span><span class="s0">, </span><span class="s1">[mxt]))</span>
            <span class="s1">surv_prob = np.concatenate((surv_prob</span><span class="s0">, </span><span class="s1">[surv_prob[-</span><span class="s4">1</span><span class="s1">]]))</span>

        <span class="s1">label = getattr(sf</span><span class="s0">, </span><span class="s5">&quot;title&quot;</span><span class="s0">, </span><span class="s5">&quot;Group %d&quot; </span><span class="s1">% (gx + </span><span class="s4">1</span><span class="s1">))</span>

        <span class="s1">li</span><span class="s0">, </span><span class="s1">= ax.step(surv_times</span><span class="s0">, </span><span class="s1">surv_prob</span><span class="s0">, </span><span class="s5">'-'</span><span class="s0">, </span><span class="s1">label=label</span><span class="s0">, </span><span class="s1">lw=</span><span class="s4">2</span><span class="s0">,</span>
                      <span class="s1">where=</span><span class="s5">'post'</span><span class="s1">)</span>

        <span class="s3"># Plot the censored points.</span>
        <span class="s1">ii = np.flatnonzero(np.logical_not(sf.status))</span>
        <span class="s1">ti = np.unique(sf.time[ii])</span>
        <span class="s1">jj = np.searchsorted(surv_times</span><span class="s0">, </span><span class="s1">ti) - </span><span class="s4">1</span>
        <span class="s1">sp = surv_prob[jj]</span>
        <span class="s1">ax.plot(ti</span><span class="s0">, </span><span class="s1">sp</span><span class="s0">, </span><span class="s5">'+'</span><span class="s0">, </span><span class="s1">ms=</span><span class="s4">12</span><span class="s0">, </span><span class="s1">color=li.get_color()</span><span class="s0">,</span>
                <span class="s1">label=label + </span><span class="s5">&quot; points&quot;</span><span class="s1">)</span>

    <span class="s1">ax.set_ylim(</span><span class="s4">0</span><span class="s0">, </span><span class="s4">1.01</span><span class="s1">)</span>

    <span class="s0">return </span><span class="s1">fig</span>
</pre>
</body>
</html>