<html>
<head>
<title>_bvp.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #6a8759;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_bvp.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Boundary value problem solver.&quot;&quot;&quot;</span>
<span class="s2">from </span><span class="s1">warnings </span><span class="s2">import </span><span class="s1">warn</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">numpy.linalg </span><span class="s2">import </span><span class="s1">pinv</span>

<span class="s2">from </span><span class="s1">scipy.sparse </span><span class="s2">import </span><span class="s1">coo_matrix</span><span class="s2">, </span><span class="s1">csc_matrix</span>
<span class="s2">from </span><span class="s1">scipy.sparse.linalg </span><span class="s2">import </span><span class="s1">splu</span>
<span class="s2">from </span><span class="s1">scipy.optimize </span><span class="s2">import </span><span class="s1">OptimizeResult</span>


<span class="s1">EPS = np.finfo(float).eps</span>


<span class="s2">def </span><span class="s1">estimate_fun_jac(fun</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">f0=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Estimate derivatives of an ODE system rhs with forward differences. 
 
    Returns 
    ------- 
    df_dy : ndarray, shape (n, n, m) 
        Derivatives with respect to y. An element (i, j, q) corresponds to 
        d f_i(x_q, y_q) / d (y_q)_j. 
    df_dp : ndarray with shape (n, k, m) or None 
        Derivatives with respect to p. An element (i, j, q) corresponds to 
        d f_i(x_q, y_q, p) / d p_j. If `p` is empty, None is returned. 
    &quot;&quot;&quot;</span>
    <span class="s1">n</span><span class="s2">, </span><span class="s1">m = y.shape</span>
    <span class="s2">if </span><span class="s1">f0 </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">f0 = fun(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">p)</span>

    <span class="s1">dtype = y.dtype</span>

    <span class="s1">df_dy = np.empty((n</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">m)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">h = EPS**</span><span class="s3">0.5 </span><span class="s1">* (</span><span class="s3">1 </span><span class="s1">+ np.abs(y))</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(n):</span>
        <span class="s1">y_new = y.copy()</span>
        <span class="s1">y_new[i] += h[i]</span>
        <span class="s1">hi = y_new[i] - y[i]</span>
        <span class="s1">f_new = fun(x</span><span class="s2">, </span><span class="s1">y_new</span><span class="s2">, </span><span class="s1">p)</span>
        <span class="s1">df_dy[:</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">:] = (f_new - f0) / hi</span>

    <span class="s1">k = p.shape[</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s2">if </span><span class="s1">k == </span><span class="s3">0</span><span class="s1">:</span>
        <span class="s1">df_dp = </span><span class="s2">None</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">df_dp = np.empty((n</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">m)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">h = EPS**</span><span class="s3">0.5 </span><span class="s1">* (</span><span class="s3">1 </span><span class="s1">+ np.abs(p))</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(k):</span>
            <span class="s1">p_new = p.copy()</span>
            <span class="s1">p_new[i] += h[i]</span>
            <span class="s1">hi = p_new[i] - p[i]</span>
            <span class="s1">f_new = fun(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">p_new)</span>
            <span class="s1">df_dp[:</span><span class="s2">, </span><span class="s1">i</span><span class="s2">, </span><span class="s1">:] = (f_new - f0) / hi</span>

    <span class="s2">return </span><span class="s1">df_dy</span><span class="s2">, </span><span class="s1">df_dp</span>


<span class="s2">def </span><span class="s1">estimate_bc_jac(bc</span><span class="s2">, </span><span class="s1">ya</span><span class="s2">, </span><span class="s1">yb</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">bc0=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Estimate derivatives of boundary conditions with forward differences. 
 
    Returns 
    ------- 
    dbc_dya : ndarray, shape (n + k, n) 
        Derivatives with respect to ya. An element (i, j) corresponds to 
        d bc_i / d ya_j. 
    dbc_dyb : ndarray, shape (n + k, n) 
        Derivatives with respect to yb. An element (i, j) corresponds to 
        d bc_i / d ya_j. 
    dbc_dp : ndarray with shape (n + k, k) or None 
        Derivatives with respect to p. An element (i, j) corresponds to 
        d bc_i / d p_j. If `p` is empty, None is returned. 
    &quot;&quot;&quot;</span>
    <span class="s1">n = ya.shape[</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s1">k = p.shape[</span><span class="s3">0</span><span class="s1">]</span>

    <span class="s2">if </span><span class="s1">bc0 </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">bc0 = bc(ya</span><span class="s2">, </span><span class="s1">yb</span><span class="s2">, </span><span class="s1">p)</span>

    <span class="s1">dtype = ya.dtype</span>

    <span class="s1">dbc_dya = np.empty((n</span><span class="s2">, </span><span class="s1">n + k)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">h = EPS**</span><span class="s3">0.5 </span><span class="s1">* (</span><span class="s3">1 </span><span class="s1">+ np.abs(ya))</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(n):</span>
        <span class="s1">ya_new = ya.copy()</span>
        <span class="s1">ya_new[i] += h[i]</span>
        <span class="s1">hi = ya_new[i] - ya[i]</span>
        <span class="s1">bc_new = bc(ya_new</span><span class="s2">, </span><span class="s1">yb</span><span class="s2">, </span><span class="s1">p)</span>
        <span class="s1">dbc_dya[i] = (bc_new - bc0) / hi</span>
    <span class="s1">dbc_dya = dbc_dya.T</span>

    <span class="s1">h = EPS**</span><span class="s3">0.5 </span><span class="s1">* (</span><span class="s3">1 </span><span class="s1">+ np.abs(yb))</span>
    <span class="s1">dbc_dyb = np.empty((n</span><span class="s2">, </span><span class="s1">n + k)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(n):</span>
        <span class="s1">yb_new = yb.copy()</span>
        <span class="s1">yb_new[i] += h[i]</span>
        <span class="s1">hi = yb_new[i] - yb[i]</span>
        <span class="s1">bc_new = bc(ya</span><span class="s2">, </span><span class="s1">yb_new</span><span class="s2">, </span><span class="s1">p)</span>
        <span class="s1">dbc_dyb[i] = (bc_new - bc0) / hi</span>
    <span class="s1">dbc_dyb = dbc_dyb.T</span>

    <span class="s2">if </span><span class="s1">k == </span><span class="s3">0</span><span class="s1">:</span>
        <span class="s1">dbc_dp = </span><span class="s2">None</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">h = EPS**</span><span class="s3">0.5 </span><span class="s1">* (</span><span class="s3">1 </span><span class="s1">+ np.abs(p))</span>
        <span class="s1">dbc_dp = np.empty((k</span><span class="s2">, </span><span class="s1">n + k)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(k):</span>
            <span class="s1">p_new = p.copy()</span>
            <span class="s1">p_new[i] += h[i]</span>
            <span class="s1">hi = p_new[i] - p[i]</span>
            <span class="s1">bc_new = bc(ya</span><span class="s2">, </span><span class="s1">yb</span><span class="s2">, </span><span class="s1">p_new)</span>
            <span class="s1">dbc_dp[i] = (bc_new - bc0) / hi</span>
        <span class="s1">dbc_dp = dbc_dp.T</span>

    <span class="s2">return </span><span class="s1">dbc_dya</span><span class="s2">, </span><span class="s1">dbc_dyb</span><span class="s2">, </span><span class="s1">dbc_dp</span>


<span class="s2">def </span><span class="s1">compute_jac_indices(n</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">k):</span>
    <span class="s0">&quot;&quot;&quot;Compute indices for the collocation system Jacobian construction. 
 
    See `construct_global_jac` for the explanation. 
    &quot;&quot;&quot;</span>
    <span class="s1">i_col = np.repeat(np.arange((m - </span><span class="s3">1</span><span class="s1">) * n)</span><span class="s2">, </span><span class="s1">n)</span>
    <span class="s1">j_col = (np.tile(np.arange(n)</span><span class="s2">, </span><span class="s1">n * (m - </span><span class="s3">1</span><span class="s1">)) +</span>
             <span class="s1">np.repeat(np.arange(m - </span><span class="s3">1</span><span class="s1">) * n</span><span class="s2">, </span><span class="s1">n**</span><span class="s3">2</span><span class="s1">))</span>

    <span class="s1">i_bc = np.repeat(np.arange((m - </span><span class="s3">1</span><span class="s1">) * n</span><span class="s2">, </span><span class="s1">m * n + k)</span><span class="s2">, </span><span class="s1">n)</span>
    <span class="s1">j_bc = np.tile(np.arange(n)</span><span class="s2">, </span><span class="s1">n + k)</span>

    <span class="s1">i_p_col = np.repeat(np.arange((m - </span><span class="s3">1</span><span class="s1">) * n)</span><span class="s2">, </span><span class="s1">k)</span>
    <span class="s1">j_p_col = np.tile(np.arange(m * n</span><span class="s2">, </span><span class="s1">m * n + k)</span><span class="s2">, </span><span class="s1">(m - </span><span class="s3">1</span><span class="s1">) * n)</span>

    <span class="s1">i_p_bc = np.repeat(np.arange((m - </span><span class="s3">1</span><span class="s1">) * n</span><span class="s2">, </span><span class="s1">m * n + k)</span><span class="s2">, </span><span class="s1">k)</span>
    <span class="s1">j_p_bc = np.tile(np.arange(m * n</span><span class="s2">, </span><span class="s1">m * n + k)</span><span class="s2">, </span><span class="s1">n + k)</span>

    <span class="s1">i = np.hstack((i_col</span><span class="s2">, </span><span class="s1">i_col</span><span class="s2">, </span><span class="s1">i_bc</span><span class="s2">, </span><span class="s1">i_bc</span><span class="s2">, </span><span class="s1">i_p_col</span><span class="s2">, </span><span class="s1">i_p_bc))</span>
    <span class="s1">j = np.hstack((j_col</span><span class="s2">, </span><span class="s1">j_col + n</span><span class="s2">,</span>
                   <span class="s1">j_bc</span><span class="s2">, </span><span class="s1">j_bc + (m - </span><span class="s3">1</span><span class="s1">) * n</span><span class="s2">,</span>
                   <span class="s1">j_p_col</span><span class="s2">, </span><span class="s1">j_p_bc))</span>

    <span class="s2">return </span><span class="s1">i</span><span class="s2">, </span><span class="s1">j</span>


<span class="s2">def </span><span class="s1">stacked_matmul(a</span><span class="s2">, </span><span class="s1">b):</span>
    <span class="s0">&quot;&quot;&quot;Stacked matrix multiply: out[i,:,:] = np.dot(a[i,:,:], b[i,:,:]). 
 
    Empirical optimization. Use outer Python loop and BLAS for large 
    matrices, otherwise use a single einsum call. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">a.shape[</span><span class="s3">1</span><span class="s1">] &gt; </span><span class="s3">50</span><span class="s1">:</span>
        <span class="s1">out = np.empty((a.shape[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">a.shape[</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">b.shape[</span><span class="s3">2</span><span class="s1">]))</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(a.shape[</span><span class="s3">0</span><span class="s1">]):</span>
            <span class="s1">out[i] = np.dot(a[i]</span><span class="s2">, </span><span class="s1">b[i])</span>
        <span class="s2">return </span><span class="s1">out</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">np.einsum(</span><span class="s4">'...ij,...jk-&gt;...ik'</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b)</span>


<span class="s2">def </span><span class="s1">construct_global_jac(n</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">i_jac</span><span class="s2">, </span><span class="s1">j_jac</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">df_dy</span><span class="s2">, </span><span class="s1">df_dy_middle</span><span class="s2">, </span><span class="s1">df_dp</span><span class="s2">,</span>
                         <span class="s1">df_dp_middle</span><span class="s2">, </span><span class="s1">dbc_dya</span><span class="s2">, </span><span class="s1">dbc_dyb</span><span class="s2">, </span><span class="s1">dbc_dp):</span>
    <span class="s0">&quot;&quot;&quot;Construct the Jacobian of the collocation system. 
 
    There are n * m + k functions: m - 1 collocations residuals, each 
    containing n components, followed by n + k boundary condition residuals. 
 
    There are n * m + k variables: m vectors of y, each containing n 
    components, followed by k values of vector p. 
 
    For example, let m = 4, n = 2 and k = 1, then the Jacobian will have 
    the following sparsity structure: 
 
        1 1 2 2 0 0 0 0  5 
        1 1 2 2 0 0 0 0  5 
        0 0 1 1 2 2 0 0  5 
        0 0 1 1 2 2 0 0  5 
        0 0 0 0 1 1 2 2  5 
        0 0 0 0 1 1 2 2  5 
 
        3 3 0 0 0 0 4 4  6 
        3 3 0 0 0 0 4 4  6 
        3 3 0 0 0 0 4 4  6 
 
    Zeros denote identically zero values, other values denote different kinds 
    of blocks in the matrix (see below). The blank row indicates the separation 
    of collocation residuals from boundary conditions. And the blank column 
    indicates the separation of y values from p values. 
 
    Refer to [1]_  (p. 306) for the formula of n x n blocks for derivatives 
    of collocation residuals with respect to y. 
 
    Parameters 
    ---------- 
    n : int 
        Number of equations in the ODE system. 
    m : int 
        Number of nodes in the mesh. 
    k : int 
        Number of the unknown parameters. 
    i_jac, j_jac : ndarray 
        Row and column indices returned by `compute_jac_indices`. They 
        represent different blocks in the Jacobian matrix in the following 
        order (see the scheme above): 
 
            * 1: m - 1 diagonal n x n blocks for the collocation residuals. 
            * 2: m - 1 off-diagonal n x n blocks for the collocation residuals. 
            * 3 : (n + k) x n block for the dependency of the boundary 
              conditions on ya. 
            * 4: (n + k) x n block for the dependency of the boundary 
              conditions on yb. 
            * 5: (m - 1) * n x k block for the dependency of the collocation 
              residuals on p. 
            * 6: (n + k) x k block for the dependency of the boundary 
              conditions on p. 
 
    df_dy : ndarray, shape (n, n, m) 
        Jacobian of f with respect to y computed at the mesh nodes. 
    df_dy_middle : ndarray, shape (n, n, m - 1) 
        Jacobian of f with respect to y computed at the middle between the 
        mesh nodes. 
    df_dp : ndarray with shape (n, k, m) or None 
        Jacobian of f with respect to p computed at the mesh nodes. 
    df_dp_middle : ndarray with shape (n, k, m - 1) or None 
        Jacobian of f with respect to p computed at the middle between the 
        mesh nodes. 
    dbc_dya, dbc_dyb : ndarray, shape (n, n) 
        Jacobian of bc with respect to ya and yb. 
    dbc_dp : ndarray with shape (n, k) or None 
        Jacobian of bc with respect to p. 
 
    Returns 
    ------- 
    J : csc_matrix, shape (n * m + k, n * m + k) 
        Jacobian of the collocation system in a sparse form. 
 
    References 
    ---------- 
    .. [1] J. Kierzenka, L. F. Shampine, &quot;A BVP Solver Based on Residual 
       Control and the Maltab PSE&quot;, ACM Trans. Math. Softw., Vol. 27, 
       Number 3, pp. 299-316, 2001. 
    &quot;&quot;&quot;</span>
    <span class="s1">df_dy = np.transpose(df_dy</span><span class="s2">, </span><span class="s1">(</span><span class="s3">2</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s1">))</span>
    <span class="s1">df_dy_middle = np.transpose(df_dy_middle</span><span class="s2">, </span><span class="s1">(</span><span class="s3">2</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s1">))</span>

    <span class="s1">h = h[:</span><span class="s2">, </span><span class="s1">np.newaxis</span><span class="s2">, </span><span class="s1">np.newaxis]</span>

    <span class="s1">dtype = df_dy.dtype</span>

    <span class="s5"># Computing diagonal n x n blocks.</span>
    <span class="s1">dPhi_dy_0 = np.empty((m - </span><span class="s3">1</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">n)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">dPhi_dy_0[:] = -np.identity(n)</span>
    <span class="s1">dPhi_dy_0 -= h / </span><span class="s3">6 </span><span class="s1">* (df_dy[:-</span><span class="s3">1</span><span class="s1">] + </span><span class="s3">2 </span><span class="s1">* df_dy_middle)</span>
    <span class="s1">T = stacked_matmul(df_dy_middle</span><span class="s2">, </span><span class="s1">df_dy[:-</span><span class="s3">1</span><span class="s1">])</span>
    <span class="s1">dPhi_dy_0 -= h**</span><span class="s3">2 </span><span class="s1">/ </span><span class="s3">12 </span><span class="s1">* T</span>

    <span class="s5"># Computing off-diagonal n x n blocks.</span>
    <span class="s1">dPhi_dy_1 = np.empty((m - </span><span class="s3">1</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">n)</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s1">dPhi_dy_1[:] = np.identity(n)</span>
    <span class="s1">dPhi_dy_1 -= h / </span><span class="s3">6 </span><span class="s1">* (df_dy[</span><span class="s3">1</span><span class="s1">:] + </span><span class="s3">2 </span><span class="s1">* df_dy_middle)</span>
    <span class="s1">T = stacked_matmul(df_dy_middle</span><span class="s2">, </span><span class="s1">df_dy[</span><span class="s3">1</span><span class="s1">:])</span>
    <span class="s1">dPhi_dy_1 += h**</span><span class="s3">2 </span><span class="s1">/ </span><span class="s3">12 </span><span class="s1">* T</span>

    <span class="s1">values = np.hstack((dPhi_dy_0.ravel()</span><span class="s2">, </span><span class="s1">dPhi_dy_1.ravel()</span><span class="s2">, </span><span class="s1">dbc_dya.ravel()</span><span class="s2">,</span>
                        <span class="s1">dbc_dyb.ravel()))</span>

    <span class="s2">if </span><span class="s1">k &gt; </span><span class="s3">0</span><span class="s1">:</span>
        <span class="s1">df_dp = np.transpose(df_dp</span><span class="s2">, </span><span class="s1">(</span><span class="s3">2</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">df_dp_middle = np.transpose(df_dp_middle</span><span class="s2">, </span><span class="s1">(</span><span class="s3">2</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">T = stacked_matmul(df_dy_middle</span><span class="s2">, </span><span class="s1">df_dp[:-</span><span class="s3">1</span><span class="s1">] - df_dp[</span><span class="s3">1</span><span class="s1">:])</span>
        <span class="s1">df_dp_middle += </span><span class="s3">0.125 </span><span class="s1">* h * T</span>
        <span class="s1">dPhi_dp = -h/</span><span class="s3">6 </span><span class="s1">* (df_dp[:-</span><span class="s3">1</span><span class="s1">] + df_dp[</span><span class="s3">1</span><span class="s1">:] + </span><span class="s3">4 </span><span class="s1">* df_dp_middle)</span>
        <span class="s1">values = np.hstack((values</span><span class="s2">, </span><span class="s1">dPhi_dp.ravel()</span><span class="s2">, </span><span class="s1">dbc_dp.ravel()))</span>

    <span class="s1">J = coo_matrix((values</span><span class="s2">, </span><span class="s1">(i_jac</span><span class="s2">, </span><span class="s1">j_jac)))</span>
    <span class="s2">return </span><span class="s1">csc_matrix(J)</span>


<span class="s2">def </span><span class="s1">collocation_fun(fun</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">h):</span>
    <span class="s0">&quot;&quot;&quot;Evaluate collocation residuals. 
 
    This function lies in the core of the method. The solution is sought 
    as a cubic C1 continuous spline with derivatives matching the ODE rhs 
    at given nodes `x`. Collocation conditions are formed from the equality 
    of the spline derivatives and rhs of the ODE system in the middle points 
    between nodes. 
 
    Such method is classified to Lobbato IIIA family in ODE literature. 
    Refer to [1]_ for the formula and some discussion. 
 
    Returns 
    ------- 
    col_res : ndarray, shape (n, m - 1) 
        Collocation residuals at the middle points of the mesh intervals. 
    y_middle : ndarray, shape (n, m - 1) 
        Values of the cubic spline evaluated at the middle points of the mesh 
        intervals. 
    f : ndarray, shape (n, m) 
        RHS of the ODE system evaluated at the mesh nodes. 
    f_middle : ndarray, shape (n, m - 1) 
        RHS of the ODE system evaluated at the middle points of the mesh 
        intervals (and using `y_middle`). 
 
    References 
    ---------- 
    .. [1] J. Kierzenka, L. F. Shampine, &quot;A BVP Solver Based on Residual 
           Control and the Maltab PSE&quot;, ACM Trans. Math. Softw., Vol. 27, 
           Number 3, pp. 299-316, 2001. 
    &quot;&quot;&quot;</span>
    <span class="s1">f = fun(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">p)</span>
    <span class="s1">y_middle = (</span><span class="s3">0.5 </span><span class="s1">* (y[:</span><span class="s2">, </span><span class="s3">1</span><span class="s1">:] + y[:</span><span class="s2">, </span><span class="s1">:-</span><span class="s3">1</span><span class="s1">]) -</span>
                <span class="s3">0.125 </span><span class="s1">* h * (f[:</span><span class="s2">, </span><span class="s3">1</span><span class="s1">:] - f[:</span><span class="s2">, </span><span class="s1">:-</span><span class="s3">1</span><span class="s1">]))</span>
    <span class="s1">f_middle = fun(x[:-</span><span class="s3">1</span><span class="s1">] + </span><span class="s3">0.5 </span><span class="s1">* h</span><span class="s2">, </span><span class="s1">y_middle</span><span class="s2">, </span><span class="s1">p)</span>
    <span class="s1">col_res = y[:</span><span class="s2">, </span><span class="s3">1</span><span class="s1">:] - y[:</span><span class="s2">, </span><span class="s1">:-</span><span class="s3">1</span><span class="s1">] - h / </span><span class="s3">6 </span><span class="s1">* (f[:</span><span class="s2">, </span><span class="s1">:-</span><span class="s3">1</span><span class="s1">] + f[:</span><span class="s2">, </span><span class="s3">1</span><span class="s1">:] +</span>
                                              <span class="s3">4 </span><span class="s1">* f_middle)</span>

    <span class="s2">return </span><span class="s1">col_res</span><span class="s2">, </span><span class="s1">y_middle</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">f_middle</span>


<span class="s2">def </span><span class="s1">prepare_sys(n</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">fun</span><span class="s2">, </span><span class="s1">bc</span><span class="s2">, </span><span class="s1">fun_jac</span><span class="s2">, </span><span class="s1">bc_jac</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">h):</span>
    <span class="s0">&quot;&quot;&quot;Create the function and the Jacobian for the collocation system.&quot;&quot;&quot;</span>
    <span class="s1">x_middle = x[:-</span><span class="s3">1</span><span class="s1">] + </span><span class="s3">0.5 </span><span class="s1">* h</span>
    <span class="s1">i_jac</span><span class="s2">, </span><span class="s1">j_jac = compute_jac_indices(n</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">k)</span>

    <span class="s2">def </span><span class="s1">col_fun(y</span><span class="s2">, </span><span class="s1">p):</span>
        <span class="s2">return </span><span class="s1">collocation_fun(fun</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">h)</span>

    <span class="s2">def </span><span class="s1">sys_jac(y</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">y_middle</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">f_middle</span><span class="s2">, </span><span class="s1">bc0):</span>
        <span class="s2">if </span><span class="s1">fun_jac </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">df_dy</span><span class="s2">, </span><span class="s1">df_dp = estimate_fun_jac(fun</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">f)</span>
            <span class="s1">df_dy_middle</span><span class="s2">, </span><span class="s1">df_dp_middle = estimate_fun_jac(</span>
                <span class="s1">fun</span><span class="s2">, </span><span class="s1">x_middle</span><span class="s2">, </span><span class="s1">y_middle</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">f_middle)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">df_dy</span><span class="s2">, </span><span class="s1">df_dp = fun_jac(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">p)</span>
            <span class="s1">df_dy_middle</span><span class="s2">, </span><span class="s1">df_dp_middle = fun_jac(x_middle</span><span class="s2">, </span><span class="s1">y_middle</span><span class="s2">, </span><span class="s1">p)</span>

        <span class="s2">if </span><span class="s1">bc_jac </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">dbc_dya</span><span class="s2">, </span><span class="s1">dbc_dyb</span><span class="s2">, </span><span class="s1">dbc_dp = estimate_bc_jac(bc</span><span class="s2">, </span><span class="s1">y[:</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">y[:</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">]</span><span class="s2">,</span>
                                                       <span class="s1">p</span><span class="s2">, </span><span class="s1">bc0)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">dbc_dya</span><span class="s2">, </span><span class="s1">dbc_dyb</span><span class="s2">, </span><span class="s1">dbc_dp = bc_jac(y[:</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">y[:</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">p)</span>

        <span class="s2">return </span><span class="s1">construct_global_jac(n</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">i_jac</span><span class="s2">, </span><span class="s1">j_jac</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">df_dy</span><span class="s2">,</span>
                                    <span class="s1">df_dy_middle</span><span class="s2">, </span><span class="s1">df_dp</span><span class="s2">, </span><span class="s1">df_dp_middle</span><span class="s2">, </span><span class="s1">dbc_dya</span><span class="s2">,</span>
                                    <span class="s1">dbc_dyb</span><span class="s2">, </span><span class="s1">dbc_dp)</span>

    <span class="s2">return </span><span class="s1">col_fun</span><span class="s2">, </span><span class="s1">sys_jac</span>


<span class="s2">def </span><span class="s1">solve_newton(n</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">col_fun</span><span class="s2">, </span><span class="s1">bc</span><span class="s2">, </span><span class="s1">jac</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, </span><span class="s1">bvp_tol</span><span class="s2">, </span><span class="s1">bc_tol):</span>
    <span class="s0">&quot;&quot;&quot;Solve the nonlinear collocation system by a Newton method. 
 
    This is a simple Newton method with a backtracking line search. As 
    advised in [1]_, an affine-invariant criterion function F = ||J^-1 r||^2 
    is used, where J is the Jacobian matrix at the current iteration and r is 
    the vector or collocation residuals (values of the system lhs). 
 
    The method alters between full Newton iterations and the fixed-Jacobian 
    iterations based 
 
    There are other tricks proposed in [1]_, but they are not used as they 
    don't seem to improve anything significantly, and even break the 
    convergence on some test problems I tried. 
 
    All important parameters of the algorithm are defined inside the function. 
 
    Parameters 
    ---------- 
    n : int 
        Number of equations in the ODE system. 
    m : int 
        Number of nodes in the mesh. 
    h : ndarray, shape (m-1,) 
        Mesh intervals. 
    col_fun : callable 
        Function computing collocation residuals. 
    bc : callable 
        Function computing boundary condition residuals. 
    jac : callable 
        Function computing the Jacobian of the whole system (including 
        collocation and boundary condition residuals). It is supposed to 
        return csc_matrix. 
    y : ndarray, shape (n, m) 
        Initial guess for the function values at the mesh nodes. 
    p : ndarray, shape (k,) 
        Initial guess for the unknown parameters. 
    B : ndarray with shape (n, n) or None 
        Matrix to force the S y(a) = 0 condition for a problems with the 
        singular term. If None, the singular term is assumed to be absent. 
    bvp_tol : float 
        Tolerance to which we want to solve a BVP. 
    bc_tol : float 
        Tolerance to which we want to satisfy the boundary conditions. 
 
    Returns 
    ------- 
    y : ndarray, shape (n, m) 
        Final iterate for the function values at the mesh nodes. 
    p : ndarray, shape (k,) 
        Final iterate for the unknown parameters. 
    singular : bool 
        True, if the LU decomposition failed because Jacobian turned out 
        to be singular. 
 
    References 
    ---------- 
    .. [1]  U. Ascher, R. Mattheij and R. Russell &quot;Numerical Solution of 
       Boundary Value Problems for Ordinary Differential Equations&quot; 
    &quot;&quot;&quot;</span>
    <span class="s5"># We know that the solution residuals at the middle points of the mesh</span>
    <span class="s5"># are connected with collocation residuals  r_middle = 1.5 * col_res / h.</span>
    <span class="s5"># As our BVP solver tries to decrease relative residuals below a certain</span>
    <span class="s5"># tolerance, it seems reasonable to terminated Newton iterations by</span>
    <span class="s5"># comparison of r_middle / (1 + np.abs(f_middle)) with a certain threshold,</span>
    <span class="s5"># which we choose to be 1.5 orders lower than the BVP tolerance. We rewrite</span>
    <span class="s5"># the condition as col_res &lt; tol_r * (1 + np.abs(f_middle)), then tol_r</span>
    <span class="s5"># should be computed as follows:</span>
    <span class="s1">tol_r = </span><span class="s3">2</span><span class="s1">/</span><span class="s3">3 </span><span class="s1">* h * </span><span class="s3">5e-2 </span><span class="s1">* bvp_tol</span>

    <span class="s5"># Maximum allowed number of Jacobian evaluation and factorization, in</span>
    <span class="s5"># other words, the maximum number of full Newton iterations. A small value</span>
    <span class="s5"># is recommended in the literature.</span>
    <span class="s1">max_njev = </span><span class="s3">4</span>

    <span class="s5"># Maximum number of iterations, considering that some of them can be</span>
    <span class="s5"># performed with the fixed Jacobian. In theory, such iterations are cheap,</span>
    <span class="s5"># but it's not that simple in Python.</span>
    <span class="s1">max_iter = </span><span class="s3">8</span>

    <span class="s5"># Minimum relative improvement of the criterion function to accept the</span>
    <span class="s5"># step (Armijo constant).</span>
    <span class="s1">sigma = </span><span class="s3">0.2</span>

    <span class="s5"># Step size decrease factor for backtracking.</span>
    <span class="s1">tau = </span><span class="s3">0.5</span>

    <span class="s5"># Maximum number of backtracking steps, the minimum step is then</span>
    <span class="s5"># tau ** n_trial.</span>
    <span class="s1">n_trial = </span><span class="s3">4</span>

    <span class="s1">col_res</span><span class="s2">, </span><span class="s1">y_middle</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">f_middle = col_fun(y</span><span class="s2">, </span><span class="s1">p)</span>
    <span class="s1">bc_res = bc(y[:</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">y[:</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">p)</span>
    <span class="s1">res = np.hstack((col_res.ravel(order=</span><span class="s4">'F'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">bc_res))</span>

    <span class="s1">njev = </span><span class="s3">0</span>
    <span class="s1">singular = </span><span class="s2">False</span>
    <span class="s1">recompute_jac = </span><span class="s2">True</span>
    <span class="s2">for </span><span class="s1">iteration </span><span class="s2">in </span><span class="s1">range(max_iter):</span>
        <span class="s2">if </span><span class="s1">recompute_jac:</span>
            <span class="s1">J = jac(y</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">y_middle</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">f_middle</span><span class="s2">, </span><span class="s1">bc_res)</span>
            <span class="s1">njev += </span><span class="s3">1</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">LU = splu(J)</span>
            <span class="s2">except </span><span class="s1">RuntimeError:</span>
                <span class="s1">singular = </span><span class="s2">True</span>
                <span class="s2">break</span>

            <span class="s1">step = LU.solve(res)</span>
            <span class="s1">cost = np.dot(step</span><span class="s2">, </span><span class="s1">step)</span>

        <span class="s1">y_step = step[:m * n].reshape((n</span><span class="s2">, </span><span class="s1">m)</span><span class="s2">, </span><span class="s1">order=</span><span class="s4">'F'</span><span class="s1">)</span>
        <span class="s1">p_step = step[m * n:]</span>

        <span class="s1">alpha = </span><span class="s3">1</span>
        <span class="s2">for </span><span class="s1">trial </span><span class="s2">in </span><span class="s1">range(n_trial + </span><span class="s3">1</span><span class="s1">):</span>
            <span class="s1">y_new = y - alpha * y_step</span>
            <span class="s2">if </span><span class="s1">B </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">y_new[:</span><span class="s2">, </span><span class="s3">0</span><span class="s1">] = np.dot(B</span><span class="s2">, </span><span class="s1">y_new[:</span><span class="s2">, </span><span class="s3">0</span><span class="s1">])</span>
            <span class="s1">p_new = p - alpha * p_step</span>

            <span class="s1">col_res</span><span class="s2">, </span><span class="s1">y_middle</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">f_middle = col_fun(y_new</span><span class="s2">, </span><span class="s1">p_new)</span>
            <span class="s1">bc_res = bc(y_new[:</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">y_new[:</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">p_new)</span>
            <span class="s1">res = np.hstack((col_res.ravel(order=</span><span class="s4">'F'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">bc_res))</span>

            <span class="s1">step_new = LU.solve(res)</span>
            <span class="s1">cost_new = np.dot(step_new</span><span class="s2">, </span><span class="s1">step_new)</span>
            <span class="s2">if </span><span class="s1">cost_new &lt; (</span><span class="s3">1 </span><span class="s1">- </span><span class="s3">2 </span><span class="s1">* alpha * sigma) * cost:</span>
                <span class="s2">break</span>

            <span class="s2">if </span><span class="s1">trial &lt; n_trial:</span>
                <span class="s1">alpha *= tau</span>

        <span class="s1">y = y_new</span>
        <span class="s1">p = p_new</span>

        <span class="s2">if </span><span class="s1">njev == max_njev:</span>
            <span class="s2">break</span>

        <span class="s2">if </span><span class="s1">(np.all(np.abs(col_res) &lt; tol_r * (</span><span class="s3">1 </span><span class="s1">+ np.abs(f_middle))) </span><span class="s2">and</span>
                <span class="s1">np.all(np.abs(bc_res) &lt; bc_tol)):</span>
            <span class="s2">break</span>

        <span class="s5"># If the full step was taken, then we are going to continue with</span>
        <span class="s5"># the same Jacobian. This is the approach of BVP_SOLVER.</span>
        <span class="s2">if </span><span class="s1">alpha == </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s1">step = step_new</span>
            <span class="s1">cost = cost_new</span>
            <span class="s1">recompute_jac = </span><span class="s2">False</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">recompute_jac = </span><span class="s2">True</span>

    <span class="s2">return </span><span class="s1">y</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">singular</span>


<span class="s2">def </span><span class="s1">print_iteration_header():</span>
    <span class="s1">print(</span><span class="s4">&quot;{:^15}{:^15}{:^15}{:^15}{:^15}&quot;</span><span class="s1">.format(</span>
        <span class="s4">&quot;Iteration&quot;</span><span class="s2">, </span><span class="s4">&quot;Max residual&quot;</span><span class="s2">, </span><span class="s4">&quot;Max BC residual&quot;</span><span class="s2">, </span><span class="s4">&quot;Total nodes&quot;</span><span class="s2">,</span>
        <span class="s4">&quot;Nodes added&quot;</span><span class="s1">))</span>


<span class="s2">def </span><span class="s1">print_iteration_progress(iteration</span><span class="s2">, </span><span class="s1">residual</span><span class="s2">, </span><span class="s1">bc_residual</span><span class="s2">, </span><span class="s1">total_nodes</span><span class="s2">,</span>
                             <span class="s1">nodes_added):</span>
    <span class="s1">print(</span><span class="s4">&quot;{:^15}{:^15.2e}{:^15.2e}{:^15}{:^15}&quot;</span><span class="s1">.format(</span>
        <span class="s1">iteration</span><span class="s2">, </span><span class="s1">residual</span><span class="s2">, </span><span class="s1">bc_residual</span><span class="s2">, </span><span class="s1">total_nodes</span><span class="s2">, </span><span class="s1">nodes_added))</span>


<span class="s2">class </span><span class="s1">BVPResult(OptimizeResult):</span>
    <span class="s2">pass</span>


<span class="s1">TERMINATION_MESSAGES = {</span>
    <span class="s3">0</span><span class="s1">: </span><span class="s4">&quot;The algorithm converged to the desired accuracy.&quot;</span><span class="s2">,</span>
    <span class="s3">1</span><span class="s1">: </span><span class="s4">&quot;The maximum number of mesh nodes is exceeded.&quot;</span><span class="s2">,</span>
    <span class="s3">2</span><span class="s1">: </span><span class="s4">&quot;A singular Jacobian encountered when solving the collocation system.&quot;</span><span class="s2">,</span>
    <span class="s3">3</span><span class="s1">: </span><span class="s4">&quot;The solver was unable to satisfy boundary conditions tolerance on iteration 10.&quot;</span>
<span class="s1">}</span>


<span class="s2">def </span><span class="s1">estimate_rms_residuals(fun</span><span class="s2">, </span><span class="s1">sol</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">r_middle</span><span class="s2">, </span><span class="s1">f_middle):</span>
    <span class="s0">&quot;&quot;&quot;Estimate rms values of collocation residuals using Lobatto quadrature. 
 
    The residuals are defined as the difference between the derivatives of 
    our solution and rhs of the ODE system. We use relative residuals, i.e., 
    normalized by 1 + np.abs(f). RMS values are computed as sqrt from the 
    normalized integrals of the squared relative residuals over each interval. 
    Integrals are estimated using 5-point Lobatto quadrature [1]_, we use the 
    fact that residuals at the mesh nodes are identically zero. 
 
    In [2] they don't normalize integrals by interval lengths, which gives 
    a higher rate of convergence of the residuals by the factor of h**0.5. 
    I chose to do such normalization for an ease of interpretation of return 
    values as RMS estimates. 
 
    Returns 
    ------- 
    rms_res : ndarray, shape (m - 1,) 
        Estimated rms values of the relative residuals over each interval. 
 
    References 
    ---------- 
    .. [1] http://mathworld.wolfram.com/LobattoQuadrature.html 
    .. [2] J. Kierzenka, L. F. Shampine, &quot;A BVP Solver Based on Residual 
       Control and the Maltab PSE&quot;, ACM Trans. Math. Softw., Vol. 27, 
       Number 3, pp. 299-316, 2001. 
    &quot;&quot;&quot;</span>
    <span class="s1">x_middle = x[:-</span><span class="s3">1</span><span class="s1">] + </span><span class="s3">0.5 </span><span class="s1">* h</span>
    <span class="s1">s = </span><span class="s3">0.5 </span><span class="s1">* h * (</span><span class="s3">3</span><span class="s1">/</span><span class="s3">7</span><span class="s1">)**</span><span class="s3">0.5</span>
    <span class="s1">x1 = x_middle + s</span>
    <span class="s1">x2 = x_middle - s</span>
    <span class="s1">y1 = sol(x1)</span>
    <span class="s1">y2 = sol(x2)</span>
    <span class="s1">y1_prime = sol(x1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">y2_prime = sol(x2</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">f1 = fun(x1</span><span class="s2">, </span><span class="s1">y1</span><span class="s2">, </span><span class="s1">p)</span>
    <span class="s1">f2 = fun(x2</span><span class="s2">, </span><span class="s1">y2</span><span class="s2">, </span><span class="s1">p)</span>
    <span class="s1">r1 = y1_prime - f1</span>
    <span class="s1">r2 = y2_prime - f2</span>

    <span class="s1">r_middle /= </span><span class="s3">1 </span><span class="s1">+ np.abs(f_middle)</span>
    <span class="s1">r1 /= </span><span class="s3">1 </span><span class="s1">+ np.abs(f1)</span>
    <span class="s1">r2 /= </span><span class="s3">1 </span><span class="s1">+ np.abs(f2)</span>

    <span class="s1">r1 = np.sum(np.real(r1 * np.conj(r1))</span><span class="s2">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">r2 = np.sum(np.real(r2 * np.conj(r2))</span><span class="s2">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">r_middle = np.sum(np.real(r_middle * np.conj(r_middle))</span><span class="s2">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)</span>

    <span class="s2">return </span><span class="s1">(</span><span class="s3">0.5 </span><span class="s1">* (</span><span class="s3">32 </span><span class="s1">/ </span><span class="s3">45 </span><span class="s1">* r_middle + </span><span class="s3">49 </span><span class="s1">/ </span><span class="s3">90 </span><span class="s1">* (r1 + r2))) ** </span><span class="s3">0.5</span>


<span class="s2">def </span><span class="s1">create_spline(y</span><span class="s2">, </span><span class="s1">yp</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">h):</span>
    <span class="s0">&quot;&quot;&quot;Create a cubic spline given values and derivatives. 
 
    Formulas for the coefficients are taken from interpolate.CubicSpline. 
 
    Returns 
    ------- 
    sol : PPoly 
        Constructed spline as a PPoly instance. 
    &quot;&quot;&quot;</span>
    <span class="s2">from </span><span class="s1">scipy.interpolate </span><span class="s2">import </span><span class="s1">PPoly</span>

    <span class="s1">n</span><span class="s2">, </span><span class="s1">m = y.shape</span>
    <span class="s1">c = np.empty((</span><span class="s3">4</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">m - </span><span class="s3">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">dtype=y.dtype)</span>
    <span class="s1">slope = (y[:</span><span class="s2">, </span><span class="s3">1</span><span class="s1">:] - y[:</span><span class="s2">, </span><span class="s1">:-</span><span class="s3">1</span><span class="s1">]) / h</span>
    <span class="s1">t = (yp[:</span><span class="s2">, </span><span class="s1">:-</span><span class="s3">1</span><span class="s1">] + yp[:</span><span class="s2">, </span><span class="s3">1</span><span class="s1">:] - </span><span class="s3">2 </span><span class="s1">* slope) / h</span>
    <span class="s1">c[</span><span class="s3">0</span><span class="s1">] = t / h</span>
    <span class="s1">c[</span><span class="s3">1</span><span class="s1">] = (slope - yp[:</span><span class="s2">, </span><span class="s1">:-</span><span class="s3">1</span><span class="s1">]) / h - t</span>
    <span class="s1">c[</span><span class="s3">2</span><span class="s1">] = yp[:</span><span class="s2">, </span><span class="s1">:-</span><span class="s3">1</span><span class="s1">]</span>
    <span class="s1">c[</span><span class="s3">3</span><span class="s1">] = y[:</span><span class="s2">, </span><span class="s1">:-</span><span class="s3">1</span><span class="s1">]</span>
    <span class="s1">c = np.moveaxis(c</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span>

    <span class="s2">return </span><span class="s1">PPoly(c</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">extrapolate=</span><span class="s2">True, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">modify_mesh(x</span><span class="s2">, </span><span class="s1">insert_1</span><span class="s2">, </span><span class="s1">insert_2):</span>
    <span class="s0">&quot;&quot;&quot;Insert nodes into a mesh. 
 
    Nodes removal logic is not established, its impact on the solver is 
    presumably negligible. So, only insertion is done in this function. 
 
    Parameters 
    ---------- 
    x : ndarray, shape (m,) 
        Mesh nodes. 
    insert_1 : ndarray 
        Intervals to each insert 1 new node in the middle. 
    insert_2 : ndarray 
        Intervals to each insert 2 new nodes, such that divide an interval 
        into 3 equal parts. 
 
    Returns 
    ------- 
    x_new : ndarray 
        New mesh nodes. 
 
    Notes 
    ----- 
    `insert_1` and `insert_2` should not have common values. 
    &quot;&quot;&quot;</span>
    <span class="s5"># Because np.insert implementation apparently varies with a version of</span>
    <span class="s5"># NumPy, we use a simple and reliable approach with sorting.</span>
    <span class="s2">return </span><span class="s1">np.sort(np.hstack((</span>
        <span class="s1">x</span><span class="s2">,</span>
        <span class="s3">0.5 </span><span class="s1">* (x[insert_1] + x[insert_1 + </span><span class="s3">1</span><span class="s1">])</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">2 </span><span class="s1">* x[insert_2] + x[insert_2 + </span><span class="s3">1</span><span class="s1">]) / </span><span class="s3">3</span><span class="s2">,</span>
        <span class="s1">(x[insert_2] + </span><span class="s3">2 </span><span class="s1">* x[insert_2 + </span><span class="s3">1</span><span class="s1">]) / </span><span class="s3">3</span>
    <span class="s1">)))</span>


<span class="s2">def </span><span class="s1">wrap_functions(fun</span><span class="s2">, </span><span class="s1">bc</span><span class="s2">, </span><span class="s1">fun_jac</span><span class="s2">, </span><span class="s1">bc_jac</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">S</span><span class="s2">, </span><span class="s1">D</span><span class="s2">, </span><span class="s1">dtype):</span>
    <span class="s0">&quot;&quot;&quot;Wrap functions for unified usage in the solver.&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">fun_jac </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">fun_jac_wrapped = </span><span class="s2">None</span>

    <span class="s2">if </span><span class="s1">bc_jac </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">bc_jac_wrapped = </span><span class="s2">None</span>

    <span class="s2">if </span><span class="s1">k == </span><span class="s3">0</span><span class="s1">:</span>
        <span class="s2">def </span><span class="s1">fun_p(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">_):</span>
            <span class="s2">return </span><span class="s1">np.asarray(fun(x</span><span class="s2">, </span><span class="s1">y)</span><span class="s2">, </span><span class="s1">dtype)</span>

        <span class="s2">def </span><span class="s1">bc_wrapped(ya</span><span class="s2">, </span><span class="s1">yb</span><span class="s2">, </span><span class="s1">_):</span>
            <span class="s2">return </span><span class="s1">np.asarray(bc(ya</span><span class="s2">, </span><span class="s1">yb)</span><span class="s2">, </span><span class="s1">dtype)</span>

        <span class="s2">if </span><span class="s1">fun_jac </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">def </span><span class="s1">fun_jac_p(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">_):</span>
                <span class="s2">return </span><span class="s1">np.asarray(fun_jac(x</span><span class="s2">, </span><span class="s1">y)</span><span class="s2">, </span><span class="s1">dtype)</span><span class="s2">, None</span>

        <span class="s2">if </span><span class="s1">bc_jac </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">def </span><span class="s1">bc_jac_wrapped(ya</span><span class="s2">, </span><span class="s1">yb</span><span class="s2">, </span><span class="s1">_):</span>
                <span class="s1">dbc_dya</span><span class="s2">, </span><span class="s1">dbc_dyb = bc_jac(ya</span><span class="s2">, </span><span class="s1">yb)</span>
                <span class="s2">return </span><span class="s1">(np.asarray(dbc_dya</span><span class="s2">, </span><span class="s1">dtype)</span><span class="s2">,</span>
                        <span class="s1">np.asarray(dbc_dyb</span><span class="s2">, </span><span class="s1">dtype)</span><span class="s2">, None</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">def </span><span class="s1">fun_p(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">p):</span>
            <span class="s2">return </span><span class="s1">np.asarray(fun(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">p)</span><span class="s2">, </span><span class="s1">dtype)</span>

        <span class="s2">def </span><span class="s1">bc_wrapped(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">p):</span>
            <span class="s2">return </span><span class="s1">np.asarray(bc(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">p)</span><span class="s2">, </span><span class="s1">dtype)</span>

        <span class="s2">if </span><span class="s1">fun_jac </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">def </span><span class="s1">fun_jac_p(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">p):</span>
                <span class="s1">df_dy</span><span class="s2">, </span><span class="s1">df_dp = fun_jac(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">p)</span>
                <span class="s2">return </span><span class="s1">np.asarray(df_dy</span><span class="s2">, </span><span class="s1">dtype)</span><span class="s2">, </span><span class="s1">np.asarray(df_dp</span><span class="s2">, </span><span class="s1">dtype)</span>

        <span class="s2">if </span><span class="s1">bc_jac </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">def </span><span class="s1">bc_jac_wrapped(ya</span><span class="s2">, </span><span class="s1">yb</span><span class="s2">, </span><span class="s1">p):</span>
                <span class="s1">dbc_dya</span><span class="s2">, </span><span class="s1">dbc_dyb</span><span class="s2">, </span><span class="s1">dbc_dp = bc_jac(ya</span><span class="s2">, </span><span class="s1">yb</span><span class="s2">, </span><span class="s1">p)</span>
                <span class="s2">return </span><span class="s1">(np.asarray(dbc_dya</span><span class="s2">, </span><span class="s1">dtype)</span><span class="s2">, </span><span class="s1">np.asarray(dbc_dyb</span><span class="s2">, </span><span class="s1">dtype)</span><span class="s2">,</span>
                        <span class="s1">np.asarray(dbc_dp</span><span class="s2">, </span><span class="s1">dtype))</span>

    <span class="s2">if </span><span class="s1">S </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">fun_wrapped = fun_p</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">def </span><span class="s1">fun_wrapped(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">p):</span>
            <span class="s1">f = fun_p(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">p)</span>
            <span class="s2">if </span><span class="s1">x[</span><span class="s3">0</span><span class="s1">] == a:</span>
                <span class="s1">f[:</span><span class="s2">, </span><span class="s3">0</span><span class="s1">] = np.dot(D</span><span class="s2">, </span><span class="s1">f[:</span><span class="s2">, </span><span class="s3">0</span><span class="s1">])</span>
                <span class="s1">f[:</span><span class="s2">, </span><span class="s3">1</span><span class="s1">:] += np.dot(S</span><span class="s2">, </span><span class="s1">y[:</span><span class="s2">, </span><span class="s3">1</span><span class="s1">:]) / (x[</span><span class="s3">1</span><span class="s1">:] - a)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">f += np.dot(S</span><span class="s2">, </span><span class="s1">y) / (x - a)</span>
            <span class="s2">return </span><span class="s1">f</span>

    <span class="s2">if </span><span class="s1">fun_jac </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">S </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">fun_jac_wrapped = fun_jac_p</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">Sr = S[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">np.newaxis]</span>

            <span class="s2">def </span><span class="s1">fun_jac_wrapped(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">p):</span>
                <span class="s1">df_dy</span><span class="s2">, </span><span class="s1">df_dp = fun_jac_p(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">p)</span>
                <span class="s2">if </span><span class="s1">x[</span><span class="s3">0</span><span class="s1">] == a:</span>
                    <span class="s1">df_dy[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s3">0</span><span class="s1">] = np.dot(D</span><span class="s2">, </span><span class="s1">df_dy[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s3">0</span><span class="s1">])</span>
                    <span class="s1">df_dy[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s3">1</span><span class="s1">:] += Sr / (x[</span><span class="s3">1</span><span class="s1">:] - a)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">df_dy += Sr / (x - a)</span>

                <span class="s2">return </span><span class="s1">df_dy</span><span class="s2">, </span><span class="s1">df_dp</span>

    <span class="s2">return </span><span class="s1">fun_wrapped</span><span class="s2">, </span><span class="s1">bc_wrapped</span><span class="s2">, </span><span class="s1">fun_jac_wrapped</span><span class="s2">, </span><span class="s1">bc_jac_wrapped</span>


<span class="s2">def </span><span class="s1">solve_bvp(fun</span><span class="s2">, </span><span class="s1">bc</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">p=</span><span class="s2">None, </span><span class="s1">S=</span><span class="s2">None, </span><span class="s1">fun_jac=</span><span class="s2">None, </span><span class="s1">bc_jac=</span><span class="s2">None,</span>
              <span class="s1">tol=</span><span class="s3">1e-3</span><span class="s2">, </span><span class="s1">max_nodes=</span><span class="s3">1000</span><span class="s2">, </span><span class="s1">verbose=</span><span class="s3">0</span><span class="s2">, </span><span class="s1">bc_tol=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Solve a boundary value problem for a system of ODEs. 
 
    This function numerically solves a first order system of ODEs subject to 
    two-point boundary conditions:: 
 
        dy / dx = f(x, y, p) + S * y / (x - a), a &lt;= x &lt;= b 
        bc(y(a), y(b), p) = 0 
 
    Here x is a 1-D independent variable, y(x) is an N-D 
    vector-valued function and p is a k-D vector of unknown 
    parameters which is to be found along with y(x). For the problem to be 
    determined, there must be n + k boundary conditions, i.e., bc must be an 
    (n + k)-D function. 
 
    The last singular term on the right-hand side of the system is optional. 
    It is defined by an n-by-n matrix S, such that the solution must satisfy 
    S y(a) = 0. This condition will be forced during iterations, so it must not 
    contradict boundary conditions. See [2]_ for the explanation how this term 
    is handled when solving BVPs numerically. 
 
    Problems in a complex domain can be solved as well. In this case, y and p 
    are considered to be complex, and f and bc are assumed to be complex-valued 
    functions, but x stays real. Note that f and bc must be complex 
    differentiable (satisfy Cauchy-Riemann equations [4]_), otherwise you 
    should rewrite your problem for real and imaginary parts separately. To 
    solve a problem in a complex domain, pass an initial guess for y with a 
    complex data type (see below). 
 
    Parameters 
    ---------- 
    fun : callable 
        Right-hand side of the system. The calling signature is ``fun(x, y)``, 
        or ``fun(x, y, p)`` if parameters are present. All arguments are 
        ndarray: ``x`` with shape (m,), ``y`` with shape (n, m), meaning that 
        ``y[:, i]`` corresponds to ``x[i]``, and ``p`` with shape (k,). The 
        return value must be an array with shape (n, m) and with the same 
        layout as ``y``. 
    bc : callable 
        Function evaluating residuals of the boundary conditions. The calling 
        signature is ``bc(ya, yb)``, or ``bc(ya, yb, p)`` if parameters are 
        present. All arguments are ndarray: ``ya`` and ``yb`` with shape (n,), 
        and ``p`` with shape (k,). The return value must be an array with 
        shape (n + k,). 
    x : array_like, shape (m,) 
        Initial mesh. Must be a strictly increasing sequence of real numbers 
        with ``x[0]=a`` and ``x[-1]=b``. 
    y : array_like, shape (n, m) 
        Initial guess for the function values at the mesh nodes, ith column 
        corresponds to ``x[i]``. For problems in a complex domain pass `y` 
        with a complex data type (even if the initial guess is purely real). 
    p : array_like with shape (k,) or None, optional 
        Initial guess for the unknown parameters. If None (default), it is 
        assumed that the problem doesn't depend on any parameters. 
    S : array_like with shape (n, n) or None 
        Matrix defining the singular term. If None (default), the problem is 
        solved without the singular term. 
    fun_jac : callable or None, optional 
        Function computing derivatives of f with respect to y and p. The 
        calling signature is ``fun_jac(x, y)``, or ``fun_jac(x, y, p)`` if 
        parameters are present. The return must contain 1 or 2 elements in the 
        following order: 
 
            * df_dy : array_like with shape (n, n, m), where an element 
              (i, j, q) equals to d f_i(x_q, y_q, p) / d (y_q)_j. 
            * df_dp : array_like with shape (n, k, m), where an element 
              (i, j, q) equals to d f_i(x_q, y_q, p) / d p_j. 
 
        Here q numbers nodes at which x and y are defined, whereas i and j 
        number vector components. If the problem is solved without unknown 
        parameters, df_dp should not be returned. 
 
        If `fun_jac` is None (default), the derivatives will be estimated 
        by the forward finite differences. 
    bc_jac : callable or None, optional 
        Function computing derivatives of bc with respect to ya, yb, and p. 
        The calling signature is ``bc_jac(ya, yb)``, or ``bc_jac(ya, yb, p)`` 
        if parameters are present. The return must contain 2 or 3 elements in 
        the following order: 
 
            * dbc_dya : array_like with shape (n, n), where an element (i, j) 
              equals to d bc_i(ya, yb, p) / d ya_j. 
            * dbc_dyb : array_like with shape (n, n), where an element (i, j) 
              equals to d bc_i(ya, yb, p) / d yb_j. 
            * dbc_dp : array_like with shape (n, k), where an element (i, j) 
              equals to d bc_i(ya, yb, p) / d p_j. 
 
        If the problem is solved without unknown parameters, dbc_dp should not 
        be returned. 
 
        If `bc_jac` is None (default), the derivatives will be estimated by 
        the forward finite differences. 
    tol : float, optional 
        Desired tolerance of the solution. If we define ``r = y' - f(x, y)``, 
        where y is the found solution, then the solver tries to achieve on each 
        mesh interval ``norm(r / (1 + abs(f)) &lt; tol``, where ``norm`` is 
        estimated in a root mean squared sense (using a numerical quadrature 
        formula). Default is 1e-3. 
    max_nodes : int, optional 
        Maximum allowed number of the mesh nodes. If exceeded, the algorithm 
        terminates. Default is 1000. 
    verbose : {0, 1, 2}, optional 
        Level of algorithm's verbosity: 
 
            * 0 (default) : work silently. 
            * 1 : display a termination report. 
            * 2 : display progress during iterations. 
    bc_tol : float, optional 
        Desired absolute tolerance for the boundary condition residuals: `bc` 
        value should satisfy ``abs(bc) &lt; bc_tol`` component-wise. 
        Equals to `tol` by default. Up to 10 iterations are allowed to achieve this 
        tolerance. 
 
    Returns 
    ------- 
    Bunch object with the following fields defined: 
    sol : PPoly 
        Found solution for y as `scipy.interpolate.PPoly` instance, a C1 
        continuous cubic spline. 
    p : ndarray or None, shape (k,) 
        Found parameters. None, if the parameters were not present in the 
        problem. 
    x : ndarray, shape (m,) 
        Nodes of the final mesh. 
    y : ndarray, shape (n, m) 
        Solution values at the mesh nodes. 
    yp : ndarray, shape (n, m) 
        Solution derivatives at the mesh nodes. 
    rms_residuals : ndarray, shape (m - 1,) 
        RMS values of the relative residuals over each mesh interval (see the 
        description of `tol` parameter). 
    niter : int 
        Number of completed iterations. 
    status : int 
        Reason for algorithm termination: 
 
            * 0: The algorithm converged to the desired accuracy. 
            * 1: The maximum number of mesh nodes is exceeded. 
            * 2: A singular Jacobian encountered when solving the collocation 
              system. 
 
    message : string 
        Verbal description of the termination reason. 
    success : bool 
        True if the algorithm converged to the desired accuracy (``status=0``). 
 
    Notes 
    ----- 
    This function implements a 4th order collocation algorithm with the 
    control of residuals similar to [1]_. A collocation system is solved 
    by a damped Newton method with an affine-invariant criterion function as 
    described in [3]_. 
 
    Note that in [1]_  integral residuals are defined without normalization 
    by interval lengths. So, their definition is different by a multiplier of 
    h**0.5 (h is an interval length) from the definition used here. 
 
    .. versionadded:: 0.18.0 
 
    References 
    ---------- 
    .. [1] J. Kierzenka, L. F. Shampine, &quot;A BVP Solver Based on Residual 
           Control and the Maltab PSE&quot;, ACM Trans. Math. Softw., Vol. 27, 
           Number 3, pp. 299-316, 2001. 
    .. [2] L.F. Shampine, P. H. Muir and H. Xu, &quot;A User-Friendly Fortran BVP 
           Solver&quot;. 
    .. [3] U. Ascher, R. Mattheij and R. Russell &quot;Numerical Solution of 
           Boundary Value Problems for Ordinary Differential Equations&quot;. 
    .. [4] `Cauchy-Riemann equations 
            &lt;https://en.wikipedia.org/wiki/Cauchy-Riemann_equations&gt;`_ on 
            Wikipedia. 
 
    Examples 
    -------- 
    In the first example, we solve Bratu's problem:: 
 
        y'' + k * exp(y) = 0 
        y(0) = y(1) = 0 
 
    for k = 1. 
 
    We rewrite the equation as a first-order system and implement its 
    right-hand side evaluation:: 
 
        y1' = y2 
        y2' = -exp(y1) 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; def fun(x, y): 
    ...     return np.vstack((y[1], -np.exp(y[0]))) 
 
    Implement evaluation of the boundary condition residuals: 
 
    &gt;&gt;&gt; def bc(ya, yb): 
    ...     return np.array([ya[0], yb[0]]) 
 
    Define the initial mesh with 5 nodes: 
 
    &gt;&gt;&gt; x = np.linspace(0, 1, 5) 
 
    This problem is known to have two solutions. To obtain both of them, we 
    use two different initial guesses for y. We denote them by subscripts 
    a and b. 
 
    &gt;&gt;&gt; y_a = np.zeros((2, x.size)) 
    &gt;&gt;&gt; y_b = np.zeros((2, x.size)) 
    &gt;&gt;&gt; y_b[0] = 3 
 
    Now we are ready to run the solver. 
 
    &gt;&gt;&gt; from scipy.integrate import solve_bvp 
    &gt;&gt;&gt; res_a = solve_bvp(fun, bc, x, y_a) 
    &gt;&gt;&gt; res_b = solve_bvp(fun, bc, x, y_b) 
 
    Let's plot the two found solutions. We take an advantage of having the 
    solution in a spline form to produce a smooth plot. 
 
    &gt;&gt;&gt; x_plot = np.linspace(0, 1, 100) 
    &gt;&gt;&gt; y_plot_a = res_a.sol(x_plot)[0] 
    &gt;&gt;&gt; y_plot_b = res_b.sol(x_plot)[0] 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; plt.plot(x_plot, y_plot_a, label='y_a') 
    &gt;&gt;&gt; plt.plot(x_plot, y_plot_b, label='y_b') 
    &gt;&gt;&gt; plt.legend() 
    &gt;&gt;&gt; plt.xlabel(&quot;x&quot;) 
    &gt;&gt;&gt; plt.ylabel(&quot;y&quot;) 
    &gt;&gt;&gt; plt.show() 
 
    We see that the two solutions have similar shape, but differ in scale 
    significantly. 
 
    In the second example, we solve a simple Sturm-Liouville problem:: 
 
        y'' + k**2 * y = 0 
        y(0) = y(1) = 0 
 
    It is known that a non-trivial solution y = A * sin(k * x) is possible for 
    k = pi * n, where n is an integer. To establish the normalization constant 
    A = 1 we add a boundary condition:: 
 
        y'(0) = k 
 
    Again, we rewrite our equation as a first-order system and implement its 
    right-hand side evaluation:: 
 
        y1' = y2 
        y2' = -k**2 * y1 
 
    &gt;&gt;&gt; def fun(x, y, p): 
    ...     k = p[0] 
    ...     return np.vstack((y[1], -k**2 * y[0])) 
 
    Note that parameters p are passed as a vector (with one element in our 
    case). 
 
    Implement the boundary conditions: 
 
    &gt;&gt;&gt; def bc(ya, yb, p): 
    ...     k = p[0] 
    ...     return np.array([ya[0], yb[0], ya[1] - k]) 
 
    Set up the initial mesh and guess for y. We aim to find the solution for 
    k = 2 * pi, to achieve that we set values of y to approximately follow 
    sin(2 * pi * x): 
 
    &gt;&gt;&gt; x = np.linspace(0, 1, 5) 
    &gt;&gt;&gt; y = np.zeros((2, x.size)) 
    &gt;&gt;&gt; y[0, 1] = 1 
    &gt;&gt;&gt; y[0, 3] = -1 
 
    Run the solver with 6 as an initial guess for k. 
 
    &gt;&gt;&gt; sol = solve_bvp(fun, bc, x, y, p=[6]) 
 
    We see that the found k is approximately correct: 
 
    &gt;&gt;&gt; sol.p[0] 
    6.28329460046 
 
    And, finally, plot the solution to see the anticipated sinusoid: 
 
    &gt;&gt;&gt; x_plot = np.linspace(0, 1, 100) 
    &gt;&gt;&gt; y_plot = sol.sol(x_plot)[0] 
    &gt;&gt;&gt; plt.plot(x_plot, y_plot) 
    &gt;&gt;&gt; plt.xlabel(&quot;x&quot;) 
    &gt;&gt;&gt; plt.ylabel(&quot;y&quot;) 
    &gt;&gt;&gt; plt.show() 
    &quot;&quot;&quot;</span>
    <span class="s1">x = np.asarray(x</span><span class="s2">, </span><span class="s1">dtype=float)</span>
    <span class="s2">if </span><span class="s1">x.ndim != </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;`x` must be 1 dimensional.&quot;</span><span class="s1">)</span>
    <span class="s1">h = np.diff(x)</span>
    <span class="s2">if </span><span class="s1">np.any(h &lt;= </span><span class="s3">0</span><span class="s1">):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;`x` must be strictly increasing.&quot;</span><span class="s1">)</span>
    <span class="s1">a = x[</span><span class="s3">0</span><span class="s1">]</span>

    <span class="s1">y = np.asarray(y)</span>
    <span class="s2">if </span><span class="s1">np.issubdtype(y.dtype</span><span class="s2">, </span><span class="s1">np.complexfloating):</span>
        <span class="s1">dtype = complex</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">dtype = float</span>
    <span class="s1">y = y.astype(dtype</span><span class="s2">, </span><span class="s1">copy=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">y.ndim != </span><span class="s3">2</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;`y` must be 2 dimensional.&quot;</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">y.shape[</span><span class="s3">1</span><span class="s1">] != x.shape[</span><span class="s3">0</span><span class="s1">]:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;`y` is expected to have {} columns, but actually &quot;</span>
                         <span class="s4">&quot;has {}.&quot;</span><span class="s1">.format(x.shape[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">y.shape[</span><span class="s3">1</span><span class="s1">]))</span>

    <span class="s2">if </span><span class="s1">p </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">p = np.array([])</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">p = np.asarray(p</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
    <span class="s2">if </span><span class="s1">p.ndim != </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;`p` must be 1 dimensional.&quot;</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">tol &lt; </span><span class="s3">100 </span><span class="s1">* EPS:</span>
        <span class="s1">warn(</span><span class="s4">f&quot;`tol` is too low, setting to </span><span class="s2">{</span><span class="s3">100 </span><span class="s1">* EPS</span><span class="s2">:</span><span class="s4">.2e</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s1">tol = </span><span class="s3">100 </span><span class="s1">* EPS</span>

    <span class="s2">if </span><span class="s1">verbose </span><span class="s2">not in </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s1">]:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;`verbose` must be in [0, 1, 2].&quot;</span><span class="s1">)</span>

    <span class="s1">n = y.shape[</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s1">k = p.shape[</span><span class="s3">0</span><span class="s1">]</span>

    <span class="s2">if </span><span class="s1">S </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">S = np.asarray(S</span><span class="s2">, </span><span class="s1">dtype=dtype)</span>
        <span class="s2">if </span><span class="s1">S.shape != (n</span><span class="s2">, </span><span class="s1">n):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;`S` is expected to have shape {}, &quot;</span>
                             <span class="s4">&quot;but actually has {}&quot;</span><span class="s1">.format((n</span><span class="s2">, </span><span class="s1">n)</span><span class="s2">, </span><span class="s1">S.shape))</span>

        <span class="s5"># Compute I - S^+ S to impose necessary boundary conditions.</span>
        <span class="s1">B = np.identity(n) - np.dot(pinv(S)</span><span class="s2">, </span><span class="s1">S)</span>

        <span class="s1">y[:</span><span class="s2">, </span><span class="s3">0</span><span class="s1">] = np.dot(B</span><span class="s2">, </span><span class="s1">y[:</span><span class="s2">, </span><span class="s3">0</span><span class="s1">])</span>

        <span class="s5"># Compute (I - S)^+ to correct derivatives at x=a.</span>
        <span class="s1">D = pinv(np.identity(n) - S)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">B = </span><span class="s2">None</span>
        <span class="s1">D = </span><span class="s2">None</span>

    <span class="s2">if </span><span class="s1">bc_tol </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">bc_tol = tol</span>

    <span class="s5"># Maximum number of iterations</span>
    <span class="s1">max_iteration = </span><span class="s3">10</span>

    <span class="s1">fun_wrapped</span><span class="s2">, </span><span class="s1">bc_wrapped</span><span class="s2">, </span><span class="s1">fun_jac_wrapped</span><span class="s2">, </span><span class="s1">bc_jac_wrapped = wrap_functions(</span>
        <span class="s1">fun</span><span class="s2">, </span><span class="s1">bc</span><span class="s2">, </span><span class="s1">fun_jac</span><span class="s2">, </span><span class="s1">bc_jac</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">S</span><span class="s2">, </span><span class="s1">D</span><span class="s2">, </span><span class="s1">dtype)</span>

    <span class="s1">f = fun_wrapped(x</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">p)</span>
    <span class="s2">if </span><span class="s1">f.shape != y.shape:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;`fun` return is expected to have shape {}, &quot;</span>
                         <span class="s4">&quot;but actually has {}.&quot;</span><span class="s1">.format(y.shape</span><span class="s2">, </span><span class="s1">f.shape))</span>

    <span class="s1">bc_res = bc_wrapped(y[:</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">y[:</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">p)</span>
    <span class="s2">if </span><span class="s1">bc_res.shape != (n + k</span><span class="s2">,</span><span class="s1">):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;`bc` return is expected to have shape {}, &quot;</span>
                         <span class="s4">&quot;but actually has {}.&quot;</span><span class="s1">.format((n + k</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">bc_res.shape))</span>

    <span class="s1">status = </span><span class="s3">0</span>
    <span class="s1">iteration = </span><span class="s3">0</span>
    <span class="s2">if </span><span class="s1">verbose == </span><span class="s3">2</span><span class="s1">:</span>
        <span class="s1">print_iteration_header()</span>

    <span class="s2">while True</span><span class="s1">:</span>
        <span class="s1">m = x.shape[</span><span class="s3">0</span><span class="s1">]</span>

        <span class="s1">col_fun</span><span class="s2">, </span><span class="s1">jac_sys = prepare_sys(n</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">fun_wrapped</span><span class="s2">, </span><span class="s1">bc_wrapped</span><span class="s2">,</span>
                                       <span class="s1">fun_jac_wrapped</span><span class="s2">, </span><span class="s1">bc_jac_wrapped</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">h)</span>
        <span class="s1">y</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">singular = solve_newton(n</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">col_fun</span><span class="s2">, </span><span class="s1">bc_wrapped</span><span class="s2">, </span><span class="s1">jac_sys</span><span class="s2">,</span>
                                      <span class="s1">y</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, </span><span class="s1">tol</span><span class="s2">, </span><span class="s1">bc_tol)</span>
        <span class="s1">iteration += </span><span class="s3">1</span>

        <span class="s1">col_res</span><span class="s2">, </span><span class="s1">y_middle</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">f_middle = collocation_fun(fun_wrapped</span><span class="s2">, </span><span class="s1">y</span><span class="s2">,</span>
                                                         <span class="s1">p</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">h)</span>
        <span class="s1">bc_res = bc_wrapped(y[:</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">y[:</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">p)</span>
        <span class="s1">max_bc_res = np.max(abs(bc_res))</span>

        <span class="s5"># This relation is not trivial, but can be verified.</span>
        <span class="s1">r_middle = </span><span class="s3">1.5 </span><span class="s1">* col_res / h</span>
        <span class="s1">sol = create_spline(y</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">h)</span>
        <span class="s1">rms_res = estimate_rms_residuals(fun_wrapped</span><span class="s2">, </span><span class="s1">sol</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">p</span><span class="s2">,</span>
                                         <span class="s1">r_middle</span><span class="s2">, </span><span class="s1">f_middle)</span>
        <span class="s1">max_rms_res = np.max(rms_res)</span>

        <span class="s2">if </span><span class="s1">singular:</span>
            <span class="s1">status = </span><span class="s3">2</span>
            <span class="s2">break</span>

        <span class="s1">insert_1</span><span class="s2">, </span><span class="s1">= np.nonzero((rms_res &gt; tol) &amp; (rms_res &lt; </span><span class="s3">100 </span><span class="s1">* tol))</span>
        <span class="s1">insert_2</span><span class="s2">, </span><span class="s1">= np.nonzero(rms_res &gt;= </span><span class="s3">100 </span><span class="s1">* tol)</span>
        <span class="s1">nodes_added = insert_1.shape[</span><span class="s3">0</span><span class="s1">] + </span><span class="s3">2 </span><span class="s1">* insert_2.shape[</span><span class="s3">0</span><span class="s1">]</span>

        <span class="s2">if </span><span class="s1">m + nodes_added &gt; max_nodes:</span>
            <span class="s1">status = </span><span class="s3">1</span>
            <span class="s2">if </span><span class="s1">verbose == </span><span class="s3">2</span><span class="s1">:</span>
                <span class="s1">nodes_added = </span><span class="s4">f&quot;(</span><span class="s2">{</span><span class="s1">nodes_added</span><span class="s2">}</span><span class="s4">)&quot;</span>
                <span class="s1">print_iteration_progress(iteration</span><span class="s2">, </span><span class="s1">max_rms_res</span><span class="s2">, </span><span class="s1">max_bc_res</span><span class="s2">,</span>
                                         <span class="s1">m</span><span class="s2">, </span><span class="s1">nodes_added)</span>
            <span class="s2">break</span>

        <span class="s2">if </span><span class="s1">verbose == </span><span class="s3">2</span><span class="s1">:</span>
            <span class="s1">print_iteration_progress(iteration</span><span class="s2">, </span><span class="s1">max_rms_res</span><span class="s2">, </span><span class="s1">max_bc_res</span><span class="s2">, </span><span class="s1">m</span><span class="s2">,</span>
                                     <span class="s1">nodes_added)</span>

        <span class="s2">if </span><span class="s1">nodes_added &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">x = modify_mesh(x</span><span class="s2">, </span><span class="s1">insert_1</span><span class="s2">, </span><span class="s1">insert_2)</span>
            <span class="s1">h = np.diff(x)</span>
            <span class="s1">y = sol(x)</span>
        <span class="s2">elif </span><span class="s1">max_bc_res &lt;= bc_tol:</span>
            <span class="s1">status = </span><span class="s3">0</span>
            <span class="s2">break</span>
        <span class="s2">elif </span><span class="s1">iteration &gt;= max_iteration:</span>
            <span class="s1">status = </span><span class="s3">3</span>
            <span class="s2">break</span>

    <span class="s2">if </span><span class="s1">verbose &gt; </span><span class="s3">0</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">status == </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">print(</span><span class="s4">&quot;Solved in {} iterations, number of nodes {}. </span><span class="s2">\n</span><span class="s4">&quot;</span>
                  <span class="s4">&quot;Maximum relative residual: {:.2e} </span><span class="s2">\n</span><span class="s4">&quot;</span>
                  <span class="s4">&quot;Maximum boundary residual: {:.2e}&quot;</span>
                  <span class="s1">.format(iteration</span><span class="s2">, </span><span class="s1">x.shape[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">max_rms_res</span><span class="s2">, </span><span class="s1">max_bc_res))</span>
        <span class="s2">elif </span><span class="s1">status == </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s1">print(</span><span class="s4">&quot;Number of nodes is exceeded after iteration {}. </span><span class="s2">\n</span><span class="s4">&quot;</span>
                  <span class="s4">&quot;Maximum relative residual: {:.2e} </span><span class="s2">\n</span><span class="s4">&quot;</span>
                  <span class="s4">&quot;Maximum boundary residual: {:.2e}&quot;</span>
                  <span class="s1">.format(iteration</span><span class="s2">, </span><span class="s1">max_rms_res</span><span class="s2">, </span><span class="s1">max_bc_res))</span>
        <span class="s2">elif </span><span class="s1">status == </span><span class="s3">2</span><span class="s1">:</span>
            <span class="s1">print(</span><span class="s4">&quot;Singular Jacobian encountered when solving the collocation &quot;</span>
                  <span class="s4">&quot;system on iteration {}. </span><span class="s2">\n</span><span class="s4">&quot;</span>
                  <span class="s4">&quot;Maximum relative residual: {:.2e} </span><span class="s2">\n</span><span class="s4">&quot;</span>
                  <span class="s4">&quot;Maximum boundary residual: {:.2e}&quot;</span>
                  <span class="s1">.format(iteration</span><span class="s2">, </span><span class="s1">max_rms_res</span><span class="s2">, </span><span class="s1">max_bc_res))</span>
        <span class="s2">elif </span><span class="s1">status == </span><span class="s3">3</span><span class="s1">:</span>
            <span class="s1">print(</span><span class="s4">&quot;The solver was unable to satisfy boundary conditions &quot;</span>
                  <span class="s4">&quot;tolerance on iteration {}. </span><span class="s2">\n</span><span class="s4">&quot;</span>
                  <span class="s4">&quot;Maximum relative residual: {:.2e} </span><span class="s2">\n</span><span class="s4">&quot;</span>
                  <span class="s4">&quot;Maximum boundary residual: {:.2e}&quot;</span>
                  <span class="s1">.format(iteration</span><span class="s2">, </span><span class="s1">max_rms_res</span><span class="s2">, </span><span class="s1">max_bc_res))</span>

    <span class="s2">if </span><span class="s1">p.size == </span><span class="s3">0</span><span class="s1">:</span>
        <span class="s1">p = </span><span class="s2">None</span>

    <span class="s2">return </span><span class="s1">BVPResult(sol=sol</span><span class="s2">, </span><span class="s1">p=p</span><span class="s2">, </span><span class="s1">x=x</span><span class="s2">, </span><span class="s1">y=y</span><span class="s2">, </span><span class="s1">yp=f</span><span class="s2">, </span><span class="s1">rms_residuals=rms_res</span><span class="s2">,</span>
                     <span class="s1">niter=iteration</span><span class="s2">, </span><span class="s1">status=status</span><span class="s2">,</span>
                     <span class="s1">message=TERMINATION_MESSAGES[status]</span><span class="s2">, </span><span class="s1">success=status == </span><span class="s3">0</span><span class="s1">)</span>
</pre>
</body>
</html>