<html>
<head>
<title>estimators.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
estimators.py</font>
</center></td></tr></table>
<pre><span class="s0">'''estimate distribution parameters by various methods 
method of moments or matching quantiles, and Maximum Likelihood estimation 
based on binned data and Maximum Product-of-Spacings 
 
Warning: I'm still finding cut-and-paste and refactoring errors, e.g. 
    hardcoded variables from outer scope in functions 
    some results do not seem to make sense for Pareto case, 
    looks better now after correcting some name errors 
 
initially loosely based on a paper and blog for quantile matching 
  by John D. Cook 
  formula for gamma quantile (ppf) matching by him (from paper) 
  http://www.codeproject.com/KB/recipes/ParameterPercentile.aspx 
  http://www.johndcook.com/blog/2010/01/31/parameters-from-percentiles/ 
  this is what I actually used (in parts): 
  http://www.bepress.com/mdandersonbiostat/paper55/ 
 
quantile based estimator 
^^^^^^^^^^^^^^^^^^^^^^^^ 
only special cases for number or parameters so far 
Is there a literature for GMM estimation of distribution parameters? check 
    found one: Wu/Perloff 2007 
 
 
binned estimator 
^^^^^^^^^^^^^^^^ 
* I added this also 
* use it for chisquare tests with estimation distribution parameters 
* move this to distribution_extras (next to gof tests powerdiscrepancy and 
  continuous) or add to distribution_patch 
 
 
example: t-distribution 
* works with quantiles if they contain tail quantiles 
* results with momentcondquant do not look as good as mle estimate 
 
TODOs 
* rearange and make sure I do not use module globals (as I did initially) DONE 
  make two version exactly identified method of moments with fsolve 
  and GMM (?) version with fmin 
  and maybe the special cases of JD Cook 
  update: maybe exact (MM) version is not so interesting compared to GMM 
* add semifrozen version of moment and quantile based estimators, 
  e.g. for beta (both loc and scale fixed), or gamma (loc fixed) 
* add beta example to the semifrozen MLE, fitfr, code 
  -&gt; added method of moment estimator to _fitstart for beta 
* start a list of how well different estimators, especially current mle work 
  for the different distributions 
* need general GMM code (with optimal weights ?), looks like a good example 
  for it 
* get example for binned data estimation, mailing list a while ago 
* any idea when these are better than mle ? 
* check language: I use quantile to mean the value of the random variable, not 
  quantile between 0 and 1. 
* for GMM: move moment conditions to separate function, so that they can be 
  used for further analysis, e.g. covariance matrix of parameter estimates 
* question: Are GMM properties different for matching quantiles with cdf or 
  ppf? Estimate should be the same, but derivatives of moment conditions 
  differ. 
* add maximum spacings estimator, Wikipedia, Per Brodtkorb -&gt; basic version Done 
* add parameter estimation based on empirical characteristic function 
  (Carrasco/Florens), especially for stable distribution 
* provide a model class based on estimating all distributions, and collect 
  all distribution specific information 
 
 
References 
---------- 
 
Ximing Wu, Jeffrey M. Perloff, GMM estimation of a maximum entropy 
distribution with interval data, Journal of Econometrics, Volume 138, 
Issue 2, 'Information and Entropy Econometrics' - A Volume in Honor of 
Arnold Zellner, June 2007, Pages 532-546, ISSN 0304-4076, 
DOI: 10.1016/j.jeconom.2006.05.008. 
http://www.sciencedirect.com/science/article/B6VC0-4K606TK-4/2/78bc07c6245546374490f777a6bdbbcc 
http://escholarship.org/uc/item/7jf5w1ht  (working paper) 
 
Johnson, Kotz, Balakrishnan: Volume 2 
 
 
Author : josef-pktd 
License : BSD 
created : 2010-04-20 
 
changes: 
added Maximum Product-of-Spacings 2010-05-12 
 
'''</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">scipy </span><span class="s2">import </span><span class="s1">stats</span><span class="s2">, </span><span class="s1">optimize</span><span class="s2">, </span><span class="s1">special</span>

<span class="s1">cache = {}   </span><span class="s3">#module global storage for temp results, not used</span>


<span class="s3"># the next two use distfn from module scope - not anymore</span>
<span class="s2">def </span><span class="s1">gammamomentcond(distfn</span><span class="s2">, </span><span class="s1">params</span><span class="s2">, </span><span class="s1">mom2</span><span class="s2">, </span><span class="s1">quantile=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">'''estimate distribution parameters based method of moments (mean, 
    variance) for distributions with 1 shape parameter and fixed loc=0. 
 
    Returns 
    ------- 
    cond : function 
 
    Notes 
    ----- 
    first test version, quantile argument not used 
 
    '''</span>
    <span class="s2">def </span><span class="s1">cond(params):</span>
        <span class="s1">alpha</span><span class="s2">, </span><span class="s1">scale = params</span>
        <span class="s1">mom2s = distfn.stats(alpha</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">,</span><span class="s1">scale)</span>
        <span class="s3">#quantil</span>
        <span class="s2">return </span><span class="s1">np.array(mom2)-mom2s</span>
    <span class="s2">return </span><span class="s1">cond</span>

<span class="s2">def </span><span class="s1">gammamomentcond2(distfn</span><span class="s2">, </span><span class="s1">params</span><span class="s2">, </span><span class="s1">mom2</span><span class="s2">, </span><span class="s1">quantile=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">'''estimate distribution parameters based method of moments (mean, 
    variance) for distributions with 1 shape parameter and fixed loc=0. 
 
    Returns 
    ------- 
    difference : ndarray 
        difference between theoretical and empirical moments 
 
    Notes 
    ----- 
    first test version, quantile argument not used 
 
    The only difference to previous function is return type. 
 
    '''</span>
    <span class="s1">alpha</span><span class="s2">, </span><span class="s1">scale = params</span>
    <span class="s1">mom2s = distfn.stats(alpha</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">,</span><span class="s1">scale)</span>
    <span class="s2">return </span><span class="s1">np.array(mom2)-mom2s</span>



<span class="s3">######### fsolve does not move in small samples, fmin not very accurate</span>
<span class="s2">def </span><span class="s1">momentcondunbound(distfn</span><span class="s2">, </span><span class="s1">params</span><span class="s2">, </span><span class="s1">mom2</span><span class="s2">, </span><span class="s1">quantile=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">'''moment conditions for estimating distribution parameters using method 
    of moments, uses mean, variance and one quantile for distributions 
    with 1 shape parameter. 
 
    Returns 
    ------- 
    difference : ndarray 
        difference between theoretical and empirical moments and quantiles 
 
    '''</span>
    <span class="s1">shape</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = params</span>
    <span class="s1">mom2diff = np.array(distfn.stats(shape</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">,</span><span class="s1">scale)) - mom2</span>
    <span class="s2">if </span><span class="s1">quantile </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">pq</span><span class="s2">, </span><span class="s1">xq = quantile</span>
        <span class="s3">#ppfdiff = distfn.ppf(pq, alpha)</span>
        <span class="s1">cdfdiff = distfn.cdf(xq</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale) - pq</span>
        <span class="s2">return </span><span class="s1">np.concatenate([mom2diff</span><span class="s2">, </span><span class="s1">cdfdiff[:</span><span class="s4">1</span><span class="s1">]])</span>
    <span class="s2">return </span><span class="s1">mom2diff</span>


<span class="s3">###### loc scale only</span>
<span class="s2">def </span><span class="s1">momentcondunboundls(distfn</span><span class="s2">, </span><span class="s1">params</span><span class="s2">, </span><span class="s1">mom2</span><span class="s2">, </span><span class="s1">quantile=</span><span class="s2">None, </span><span class="s1">shape=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">'''moment conditions for estimating loc and scale of a distribution 
    with method of moments using either 2 quantiles or 2 moments (not both). 
 
    Returns 
    ------- 
    difference : ndarray 
        difference between theoretical and empirical moments or quantiles 
 
    '''</span>
    <span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = params</span>
    <span class="s1">mom2diff = np.array(distfn.stats(shape</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale)) - mom2</span>
    <span class="s2">if </span><span class="s1">quantile </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s1">pq</span><span class="s2">, </span><span class="s1">xq = quantile</span>
        <span class="s3">#ppfdiff = distfn.ppf(pq, alpha)</span>
        <span class="s1">cdfdiff = distfn.cdf(xq</span><span class="s2">, </span><span class="s1">shape</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale) - pq</span>
        <span class="s3">#return np.concatenate([mom2diff, cdfdiff[:1]])</span>
        <span class="s2">return </span><span class="s1">cdfdiff</span>
    <span class="s2">return </span><span class="s1">mom2diff</span>



<span class="s3">######### try quantile GMM with identity weight matrix</span>
<span class="s3">#(just a guess that's what it is</span>

<span class="s2">def </span><span class="s1">momentcondquant(distfn</span><span class="s2">, </span><span class="s1">params</span><span class="s2">, </span><span class="s1">mom2</span><span class="s2">, </span><span class="s1">quantile=</span><span class="s2">None, </span><span class="s1">shape=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">'''moment conditions for estimating distribution parameters by matching 
    quantiles, defines as many moment conditions as quantiles. 
 
    Returns 
    ------- 
    difference : ndarray 
        difference between theoretical and empirical quantiles 
 
    Notes 
    ----- 
    This can be used for method of moments or for generalized method of 
    moments. 
 
    '''</span>
    <span class="s3">#this check looks redundant/unused know</span>
    <span class="s2">if </span><span class="s1">len(params) == </span><span class="s4">2</span><span class="s1">:</span>
        <span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = params</span>
    <span class="s2">elif </span><span class="s1">len(params) == </span><span class="s4">3</span><span class="s1">:</span>
        <span class="s1">shape</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = params</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s3">#raise NotImplementedError</span>
        <span class="s2">pass </span><span class="s3">#see whether this might work, seems to work for beta with 2 shape args</span>

    <span class="s3">#mom2diff = np.array(distfn.stats(*params)) - mom2</span>
    <span class="s3">#if not quantile is None:</span>
    <span class="s1">pq</span><span class="s2">, </span><span class="s1">xq = quantile</span>
    <span class="s3">#ppfdiff = distfn.ppf(pq, alpha)</span>
    <span class="s1">cdfdiff = distfn.cdf(xq</span><span class="s2">, </span><span class="s1">*params) - pq</span>
    <span class="s3">#return np.concatenate([mom2diff, cdfdiff[:1]])</span>
    <span class="s2">return </span><span class="s1">cdfdiff</span>
    <span class="s3">#return mom2diff</span>

<span class="s2">def </span><span class="s1">fitquantilesgmm(distfn</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">start=</span><span class="s2">None, </span><span class="s1">pquant=</span><span class="s2">None, </span><span class="s1">frozen=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">if </span><span class="s1">pquant </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">pquant = np.array([</span><span class="s4">0.01</span><span class="s2">, </span><span class="s4">0.05</span><span class="s2">,</span><span class="s4">0.1</span><span class="s2">,</span><span class="s4">0.4</span><span class="s2">,</span><span class="s4">0.6</span><span class="s2">,</span><span class="s4">0.9</span><span class="s2">,</span><span class="s4">0.95</span><span class="s2">,</span><span class="s4">0.99</span><span class="s1">])</span>
    <span class="s2">if </span><span class="s1">start </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">hasattr(distfn</span><span class="s2">, </span><span class="s5">'_fitstart'</span><span class="s1">):</span>
            <span class="s1">start = distfn._fitstart(x)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">start = [</span><span class="s4">1</span><span class="s1">]*distfn.numargs + [</span><span class="s4">0.</span><span class="s2">,</span><span class="s4">1.</span><span class="s1">]</span>
    <span class="s3">#TODO: vectorize this:</span>
    <span class="s1">xqs = [stats.scoreatpercentile(x</span><span class="s2">, </span><span class="s1">p) </span><span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">pquant*</span><span class="s4">100</span><span class="s1">]</span>
    <span class="s1">mom2s = </span><span class="s2">None</span>
    <span class="s1">parest = optimize.fmin(</span><span class="s2">lambda </span><span class="s1">params:np.sum(</span>
        <span class="s1">momentcondquant(distfn</span><span class="s2">, </span><span class="s1">params</span><span class="s2">, </span><span class="s1">mom2s</span><span class="s2">,</span><span class="s1">(pquant</span><span class="s2">,</span><span class="s1">xqs)</span><span class="s2">, </span><span class="s1">shape=</span><span class="s2">None</span><span class="s1">)**</span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">start)</span>
    <span class="s2">return </span><span class="s1">parest</span>



<span class="s2">def </span><span class="s1">fitbinned(distfn</span><span class="s2">, </span><span class="s1">freq</span><span class="s2">, </span><span class="s1">binedges</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">fixed=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">'''estimate parameters of distribution function for binned data using MLE 
 
    Parameters 
    ---------- 
    distfn : distribution instance 
        needs to have cdf method, as in scipy.stats 
    freq : ndarray, 1d 
        frequency count, e.g. obtained by histogram 
    binedges : ndarray, 1d 
        binedges including lower and upper bound 
    start : tuple or array_like ? 
        starting values, needs to have correct length 
 
    Returns 
    ------- 
    paramest : ndarray 
        estimated parameters 
 
    Notes 
    ----- 
    todo: add fixed parameter option 
 
    added factorial 
 
    '''</span>
    <span class="s2">if </span><span class="s1">fixed </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>
    <span class="s1">nobs = np.sum(freq)</span>
    <span class="s1">lnnobsfact = special.gammaln(nobs+</span><span class="s4">1</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">nloglike(params):</span>
        <span class="s0">'''negative loglikelihood function of binned data 
 
        corresponds to multinomial 
        '''</span>
        <span class="s1">prob = np.diff(distfn.cdf(binedges</span><span class="s2">, </span><span class="s1">*params))</span>
        <span class="s2">return </span><span class="s1">-(lnnobsfact + np.sum(freq*np.log(prob)- special.gammaln(freq+</span><span class="s4">1</span><span class="s1">)))</span>
    <span class="s2">return </span><span class="s1">optimize.fmin(nloglike</span><span class="s2">, </span><span class="s1">start)</span>


<span class="s2">def </span><span class="s1">fitbinnedgmm(distfn</span><span class="s2">, </span><span class="s1">freq</span><span class="s2">, </span><span class="s1">binedges</span><span class="s2">, </span><span class="s1">start</span><span class="s2">, </span><span class="s1">fixed=</span><span class="s2">None, </span><span class="s1">weightsoptimal=</span><span class="s2">True</span><span class="s1">):</span>
    <span class="s0">'''estimate parameters of distribution function for binned data using GMM 
 
    Parameters 
    ---------- 
    distfn : distribution instance 
        needs to have cdf method, as in scipy.stats 
    freq : ndarray, 1d 
        frequency count, e.g. obtained by histogram 
    binedges : ndarray, 1d 
        binedges including lower and upper bound 
    start : tuple or array_like ? 
        starting values, needs to have correct length 
    fixed : None 
        not used yet 
    weightsoptimal : bool 
        If true, then the optimal weighting matrix for GMM is used. If false, 
        then the identity matrix is used 
 
    Returns 
    ------- 
    paramest : ndarray 
        estimated parameters 
 
    Notes 
    ----- 
    todo: add fixed parameter option 
 
    added factorial 
 
    '''</span>
    <span class="s2">if </span><span class="s1">fixed </span><span class="s2">is not None</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>
    <span class="s1">nobs = np.sum(freq)</span>
    <span class="s2">if </span><span class="s1">weightsoptimal:</span>
        <span class="s1">weights = freq/float(nobs)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">weights = np.ones(len(freq))</span>
    <span class="s1">freqnormed = freq/float(nobs)</span>
    <span class="s3"># skip turning weights into matrix diag(freq/float(nobs))</span>

    <span class="s2">def </span><span class="s1">gmmobjective(params):</span>
        <span class="s0">'''negative loglikelihood function of binned data 
 
        corresponds to multinomial 
        '''</span>
        <span class="s1">prob = np.diff(distfn.cdf(binedges</span><span class="s2">, </span><span class="s1">*params))</span>
        <span class="s1">momcond = freqnormed - prob</span>
        <span class="s2">return </span><span class="s1">np.dot(momcond*weights</span><span class="s2">, </span><span class="s1">momcond)</span>
    <span class="s2">return </span><span class="s1">optimize.fmin(gmmobjective</span><span class="s2">, </span><span class="s1">start)</span>

<span class="s3">#Addition from try_maxproductspacings:</span>
<span class="s5">&quot;&quot;&quot;Estimating Parameters of Log-Normal Distribution with Maximum 
Likelihood and Maximum Product-of-Spacings 
 
MPS definiton from JKB page 233 
 
Created on Tue May 11 13:52:50 2010 
Author: josef-pktd 
License: BSD 
&quot;&quot;&quot;</span>

<span class="s2">def </span><span class="s1">hess_ndt(fun</span><span class="s2">, </span><span class="s1">pars</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">options):</span>
    <span class="s2">import </span><span class="s1">numdifftools </span><span class="s2">as </span><span class="s1">ndt</span>
    <span class="s2">if not </span><span class="s1">(</span><span class="s5">'stepMax' </span><span class="s2">in </span><span class="s1">options </span><span class="s2">or </span><span class="s5">'stepFix' </span><span class="s2">in </span><span class="s1">options):</span>
        <span class="s1">options[</span><span class="s5">'stepMax'</span><span class="s1">] = </span><span class="s4">1e-5</span>
    <span class="s1">f = </span><span class="s2">lambda </span><span class="s1">params: fun(params</span><span class="s2">, </span><span class="s1">*args)</span>
    <span class="s1">h = ndt.Hessian(f</span><span class="s2">, </span><span class="s1">**options)</span>
    <span class="s2">return </span><span class="s1">h(pars)</span><span class="s2">, </span><span class="s1">h</span>

<span class="s2">def </span><span class="s1">logmps(params</span><span class="s2">, </span><span class="s1">xsorted</span><span class="s2">, </span><span class="s1">dist):</span>
    <span class="s0">'''calculate negative log of Product-of-Spacings 
 
    Parameters 
    ---------- 
    params : array_like, tuple ? 
        parameters of the distribution funciton 
    xsorted : array_like 
        data that is already sorted 
    dist : instance of a distribution class 
        only cdf method is used 
 
    Returns 
    ------- 
    mps : float 
        negative log of Product-of-Spacings 
 
 
    Notes 
    ----- 
    MPS definiton from JKB page 233 
    '''</span>
    <span class="s1">xcdf = np.r_[</span><span class="s4">0.</span><span class="s2">, </span><span class="s1">dist.cdf(xsorted</span><span class="s2">, </span><span class="s1">*params)</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]</span>
    <span class="s1">D = np.diff(xcdf)</span>
    <span class="s2">return </span><span class="s1">-np.log(D).mean()</span>

<span class="s2">def </span><span class="s1">getstartparams(dist</span><span class="s2">, </span><span class="s1">data):</span>
    <span class="s0">'''get starting values for estimation of distribution parameters 
 
    Parameters 
    ---------- 
    dist : distribution instance 
        the distribution instance needs to have either a method fitstart 
        or an attribute numargs 
    data : ndarray 
        data for which preliminary estimator or starting value for 
        parameter estimation is desired 
 
    Returns 
    ------- 
    x0 : ndarray 
        preliminary estimate or starting value for the parameters of 
        the distribution given the data, including loc and scale 
 
    '''</span>
    <span class="s2">if </span><span class="s1">hasattr(dist</span><span class="s2">, </span><span class="s5">'fitstart'</span><span class="s1">):</span>
        <span class="s3">#x0 = getattr(dist, 'fitstart')(data)</span>
        <span class="s1">x0 = dist.fitstart(data)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">np.isfinite(dist.a):</span>
            <span class="s1">x0 = np.r_[[</span><span class="s4">1.</span><span class="s1">]*dist.numargs</span><span class="s2">, </span><span class="s1">(data.min()-</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">x0 = np.r_[[</span><span class="s4">1.</span><span class="s1">]*dist.numargs</span><span class="s2">, </span><span class="s1">(data.mean()-</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]</span>
    <span class="s2">return </span><span class="s1">x0</span>

<span class="s2">def </span><span class="s1">fit_mps(dist</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">x0=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">'''Estimate distribution parameters with Maximum Product-of-Spacings 
 
    Parameters 
    ---------- 
    params : array_like, tuple ? 
        parameters of the distribution funciton 
    xsorted : array_like 
        data that is already sorted 
    dist : instance of a distribution class 
        only cdf method is used 
 
    Returns 
    ------- 
    x : ndarray 
        estimates for the parameters of the distribution given the data, 
        including loc and scale 
 
 
    '''</span>
    <span class="s1">xsorted = np.sort(data)</span>
    <span class="s2">if </span><span class="s1">x0 </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">x0 = getstartparams(dist</span><span class="s2">, </span><span class="s1">xsorted)</span>
    <span class="s1">args = (xsorted</span><span class="s2">, </span><span class="s1">dist)</span>
    <span class="s1">print(x0)</span>
    <span class="s3">#print(args)</span>
    <span class="s2">return </span><span class="s1">optimize.fmin(logmps</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">args=args)</span>



<span class="s2">if </span><span class="s1">__name__ == </span><span class="s5">'__main__'</span><span class="s1">:</span>

    <span class="s3">#Example: gamma - distribution</span>
    <span class="s3">#-----------------------------</span>

    <span class="s1">print(</span><span class="s5">'</span><span class="s2">\n\n</span><span class="s5">Example: gamma Distribution'</span><span class="s1">)</span>
    <span class="s1">print(    </span><span class="s5">'---------------------------'</span><span class="s1">)</span>

    <span class="s1">alpha = </span><span class="s4">2</span>
    <span class="s1">xq = [</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span>
    <span class="s1">pq = [</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.9</span><span class="s1">]</span>
    <span class="s1">print(stats.gamma.ppf(pq</span><span class="s2">, </span><span class="s1">alpha))</span>
    <span class="s1">xq = stats.gamma.ppf(pq</span><span class="s2">, </span><span class="s1">alpha)</span>
    <span class="s1">print(np.diff((stats.gamma.ppf(pq</span><span class="s2">, </span><span class="s1">np.linspace(</span><span class="s4">0.01</span><span class="s2">,</span><span class="s4">4</span><span class="s2">,</span><span class="s4">10</span><span class="s1">)[:</span><span class="s2">,None</span><span class="s1">])*xq[::-</span><span class="s4">1</span><span class="s1">])))</span>
    <span class="s3">#optimize.bisect(lambda alpha: np.diff((stats.gamma.ppf(pq, alpha)*xq[::-1])))</span>
    <span class="s1">print(optimize.fsolve(</span><span class="s2">lambda </span><span class="s1">alpha: np.diff((stats.gamma.ppf(pq</span><span class="s2">, </span><span class="s1">alpha)*xq[::-</span><span class="s4">1</span><span class="s1">]))</span><span class="s2">, </span><span class="s4">3.</span><span class="s1">))</span>

    <span class="s1">distfn = stats.gamma</span>
    <span class="s1">mcond = gammamomentcond(distfn</span><span class="s2">, </span><span class="s1">[</span><span class="s4">5.</span><span class="s2">,</span><span class="s4">10</span><span class="s1">]</span><span class="s2">, </span><span class="s1">mom2=stats.gamma.stats(alpha</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">,</span><span class="s4">1.</span><span class="s1">)</span><span class="s2">, </span><span class="s1">quantile=</span><span class="s2">None</span><span class="s1">)</span>
    <span class="s1">print(optimize.fsolve(mcond</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1.</span><span class="s2">,</span><span class="s4">2.</span><span class="s1">]))</span>
    <span class="s1">mom2 = stats.gamma.stats(alpha</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">,</span><span class="s4">1.</span><span class="s1">)</span>
    <span class="s1">print(optimize.fsolve(</span><span class="s2">lambda </span><span class="s1">params:gammamomentcond2(distfn</span><span class="s2">, </span><span class="s1">params</span><span class="s2">, </span><span class="s1">mom2)</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1.</span><span class="s2">,</span><span class="s4">2.</span><span class="s1">]))</span>

    <span class="s1">grvs = stats.gamma.rvs(alpha</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">,</span><span class="s4">2.</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">1000</span><span class="s1">)</span>
    <span class="s1">mom2 = np.array([grvs.mean()</span><span class="s2">, </span><span class="s1">grvs.var()])</span>
    <span class="s1">alphaestq = optimize.fsolve(</span><span class="s2">lambda </span><span class="s1">params:gammamomentcond2(distfn</span><span class="s2">, </span><span class="s1">params</span><span class="s2">, </span><span class="s1">mom2)</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1.</span><span class="s2">,</span><span class="s4">3.</span><span class="s1">])</span>
    <span class="s1">print(alphaestq)</span>
    <span class="s1">print(</span><span class="s5">'scale = '</span><span class="s2">, </span><span class="s1">xq/stats.gamma.ppf(pq</span><span class="s2">, </span><span class="s1">alphaestq))</span>


    <span class="s3">#Example beta - distribution</span>
    <span class="s3">#---------------------------</span>

    <span class="s3">#Warning: this example had cut-and-paste errors</span>

    <span class="s1">print(</span><span class="s5">'</span><span class="s2">\n\n</span><span class="s5">Example: beta Distribution'</span><span class="s1">)</span>
    <span class="s1">print(    </span><span class="s5">'--------------------------'</span><span class="s1">)</span>

    <span class="s3">#monkey patching :</span>
<span class="s3">##    if hasattr(stats.beta, '_fitstart'):</span>
<span class="s3">##        del stats.beta._fitstart  #bug in _fitstart  #raises AttributeError: _fitstart</span>
    <span class="s3">#stats.distributions.beta_gen._fitstart = lambda self, data : np.array([1,1,0,1])</span>
    <span class="s3">#_fitstart seems to require a tuple</span>
    <span class="s1">stats.distributions.beta_gen._fitstart = </span><span class="s2">lambda </span><span class="s1">self</span><span class="s2">, </span><span class="s1">data : (</span><span class="s4">5</span><span class="s2">,</span><span class="s4">5</span><span class="s2">,</span><span class="s4">0</span><span class="s2">,</span><span class="s4">1</span><span class="s1">)</span>

    <span class="s1">pq = np.array([</span><span class="s4">0.01</span><span class="s2">, </span><span class="s4">0.05</span><span class="s2">,</span><span class="s4">0.1</span><span class="s2">,</span><span class="s4">0.4</span><span class="s2">,</span><span class="s4">0.6</span><span class="s2">,</span><span class="s4">0.9</span><span class="s2">,</span><span class="s4">0.95</span><span class="s2">,</span><span class="s4">0.99</span><span class="s1">])</span>
    <span class="s3">#rvsb = stats.beta.rvs(0.5,0.15,size=200)</span>
    <span class="s1">rvsb = stats.beta.rvs(</span><span class="s4">10</span><span class="s2">,</span><span class="s4">15</span><span class="s2">,</span><span class="s1">size=</span><span class="s4">2000</span><span class="s1">)</span>
    <span class="s1">print(</span><span class="s5">'true params'</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">15</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">print(stats.beta.fit(rvsb))</span>
    <span class="s1">xqsb = [stats.scoreatpercentile(rvsb</span><span class="s2">, </span><span class="s1">p) </span><span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">pq*</span><span class="s4">100</span><span class="s1">]</span>
    <span class="s1">mom2s = np.array([rvsb.mean()</span><span class="s2">, </span><span class="s1">rvsb.var()])</span>
    <span class="s1">betaparest_gmmquantile = optimize.fmin(</span><span class="s2">lambda </span><span class="s1">params:np.sum(momentcondquant(stats.beta</span><span class="s2">, </span><span class="s1">params</span><span class="s2">, </span><span class="s1">mom2s</span><span class="s2">,</span><span class="s1">(pq</span><span class="s2">,</span><span class="s1">xqsb)</span><span class="s2">, </span><span class="s1">shape=</span><span class="s2">None</span><span class="s1">)**</span><span class="s4">2</span><span class="s1">)</span><span class="s2">,</span>
                                           <span class="s1">[</span><span class="s4">10</span><span class="s2">,</span><span class="s4">10</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">maxiter=</span><span class="s4">2000</span><span class="s1">)</span>
    <span class="s1">print(</span><span class="s5">'betaparest_gmmquantile'</span><span class="s2">,  </span><span class="s1">betaparest_gmmquantile)</span>
    <span class="s3">#result sensitive to initial condition</span>


    <span class="s3">#Example t - distribution</span>
    <span class="s3">#------------------------</span>

    <span class="s1">print(</span><span class="s5">'</span><span class="s2">\n\n</span><span class="s5">Example: t Distribution'</span><span class="s1">)</span>
    <span class="s1">print(    </span><span class="s5">'-----------------------'</span><span class="s1">)</span>

    <span class="s1">nobs = </span><span class="s4">1000</span>
    <span class="s1">distfn = stats.t</span>
    <span class="s1">pq = np.array([</span><span class="s4">0.1</span><span class="s2">,</span><span class="s4">0.9</span><span class="s1">])</span>
    <span class="s1">paramsdgp = (</span><span class="s4">5</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">trvs = distfn.rvs(</span><span class="s4">5</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">size=nobs)</span>
    <span class="s1">xqs = [stats.scoreatpercentile(trvs</span><span class="s2">, </span><span class="s1">p) </span><span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">pq*</span><span class="s4">100</span><span class="s1">]</span>
    <span class="s1">mom2th = distfn.stats(*paramsdgp)</span>
    <span class="s1">mom2s = np.array([trvs.mean()</span><span class="s2">, </span><span class="s1">trvs.var()])</span>
    <span class="s1">tparest_gmm3quantilefsolve = optimize.fsolve(</span><span class="s2">lambda </span><span class="s1">params:momentcondunbound(distfn</span><span class="s2">,</span><span class="s1">params</span><span class="s2">, </span><span class="s1">mom2s</span><span class="s2">,</span><span class="s1">(pq</span><span class="s2">,</span><span class="s1">xqs))</span><span class="s2">, </span><span class="s1">[</span><span class="s4">10</span><span class="s2">,</span><span class="s4">1.</span><span class="s2">,</span><span class="s4">2.</span><span class="s1">])</span>
    <span class="s1">print(</span><span class="s5">'tparest_gmm3quantilefsolve'</span><span class="s2">, </span><span class="s1">tparest_gmm3quantilefsolve)</span>
    <span class="s1">tparest_gmm3quantile = optimize.fmin(</span><span class="s2">lambda </span><span class="s1">params:np.sum(momentcondunbound(distfn</span><span class="s2">,</span><span class="s1">params</span><span class="s2">, </span><span class="s1">mom2s</span><span class="s2">,</span><span class="s1">(pq</span><span class="s2">,</span><span class="s1">xqs))**</span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">[</span><span class="s4">10</span><span class="s2">,</span><span class="s4">1.</span><span class="s2">,</span><span class="s4">2.</span><span class="s1">])</span>
    <span class="s1">print(</span><span class="s5">'tparest_gmm3quantile'</span><span class="s2">, </span><span class="s1">tparest_gmm3quantile)</span>
    <span class="s1">print(distfn.fit(trvs))</span>

    <span class="s3">##</span>

    <span class="s3">##distfn = stats.t</span>
    <span class="s3">##pq = np.array([0.1,0.9])</span>
    <span class="s3">##paramsdgp = (5, 0, 1)</span>
    <span class="s3">##trvs = distfn.rvs(5, 0, 1, size=nobs)</span>
    <span class="s3">##xqs = [stats.scoreatpercentile(trvs, p) for p in pq*100]</span>
    <span class="s3">##mom2th = distfn.stats(*paramsdgp)</span>
    <span class="s3">##mom2s = np.array([trvs.mean(), trvs.var()])</span>
    <span class="s1">print(optimize.fsolve(</span><span class="s2">lambda </span><span class="s1">params:momentcondunboundls(distfn</span><span class="s2">, </span><span class="s1">params</span><span class="s2">, </span><span class="s1">mom2s</span><span class="s2">,</span><span class="s1">shape=</span><span class="s4">5</span><span class="s1">)</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1.</span><span class="s2">,</span><span class="s4">2.</span><span class="s1">]))</span>
    <span class="s1">print(optimize.fmin(</span><span class="s2">lambda </span><span class="s1">params:np.sum(momentcondunboundls(distfn</span><span class="s2">, </span><span class="s1">params</span><span class="s2">, </span><span class="s1">mom2s</span><span class="s2">,</span><span class="s1">shape=</span><span class="s4">5</span><span class="s1">)**</span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1.</span><span class="s2">,</span><span class="s4">2.</span><span class="s1">]))</span>
    <span class="s1">print(distfn.fit(trvs))</span>
    <span class="s3">#loc, scale, based on quantiles</span>
    <span class="s1">print(optimize.fsolve(</span><span class="s2">lambda </span><span class="s1">params:momentcondunboundls(distfn</span><span class="s2">, </span><span class="s1">params</span><span class="s2">, </span><span class="s1">mom2s</span><span class="s2">,</span><span class="s1">(pq</span><span class="s2">,</span><span class="s1">xqs)</span><span class="s2">,</span><span class="s1">shape=</span><span class="s4">5</span><span class="s1">)</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1.</span><span class="s2">,</span><span class="s4">2.</span><span class="s1">]))</span>

    <span class="s3">##</span>

    <span class="s1">pq = np.array([</span><span class="s4">0.01</span><span class="s2">, </span><span class="s4">0.05</span><span class="s2">,</span><span class="s4">0.1</span><span class="s2">,</span><span class="s4">0.4</span><span class="s2">,</span><span class="s4">0.6</span><span class="s2">,</span><span class="s4">0.9</span><span class="s2">,</span><span class="s4">0.95</span><span class="s2">,</span><span class="s4">0.99</span><span class="s1">])</span>
    <span class="s3">#paramsdgp = (5, 0, 1)</span>
    <span class="s1">xqs = [stats.scoreatpercentile(trvs</span><span class="s2">, </span><span class="s1">p) </span><span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">pq*</span><span class="s4">100</span><span class="s1">]</span>
    <span class="s1">tparest_gmmquantile = optimize.fmin(</span><span class="s2">lambda </span><span class="s1">params:np.sum(momentcondquant(distfn</span><span class="s2">, </span><span class="s1">params</span><span class="s2">, </span><span class="s1">mom2s</span><span class="s2">,</span><span class="s1">(pq</span><span class="s2">,</span><span class="s1">xqs)</span><span class="s2">, </span><span class="s1">shape=</span><span class="s2">None</span><span class="s1">)**</span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">[</span><span class="s4">10</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">,</span><span class="s4">2.</span><span class="s1">])</span>
    <span class="s1">print(</span><span class="s5">'tparest_gmmquantile'</span><span class="s2">, </span><span class="s1">tparest_gmmquantile)</span>
    <span class="s1">tparest_gmmquantile2 = fitquantilesgmm(distfn</span><span class="s2">, </span><span class="s1">trvs</span><span class="s2">, </span><span class="s1">start=[</span><span class="s4">10</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">,</span><span class="s4">2.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">pquant=</span><span class="s2">None, </span><span class="s1">frozen=</span><span class="s2">None</span><span class="s1">)</span>
    <span class="s1">print(</span><span class="s5">'tparest_gmmquantile2'</span><span class="s2">, </span><span class="s1">tparest_gmmquantile2)</span>


    <span class="s3">##</span>


    <span class="s3">#use trvs from before</span>
    <span class="s1">bt = stats.t.ppf(np.linspace(</span><span class="s4">0</span><span class="s2">,</span><span class="s4">1</span><span class="s2">,</span><span class="s4">21</span><span class="s1">)</span><span class="s2">,</span><span class="s4">5</span><span class="s1">)</span>
    <span class="s1">ft</span><span class="s2">,</span><span class="s1">bt = np.histogram(trvs</span><span class="s2">,</span><span class="s1">bins=bt)</span>
    <span class="s1">print(</span><span class="s5">'fitbinned t-distribution'</span><span class="s1">)</span>
    <span class="s1">tparest_mlebinew = fitbinned(stats.t</span><span class="s2">, </span><span class="s1">ft</span><span class="s2">, </span><span class="s1">bt</span><span class="s2">, </span><span class="s1">[</span><span class="s4">10</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">tparest_gmmbinewidentity = fitbinnedgmm(stats.t</span><span class="s2">, </span><span class="s1">ft</span><span class="s2">, </span><span class="s1">bt</span><span class="s2">, </span><span class="s1">[</span><span class="s4">10</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">tparest_gmmbinewoptimal = fitbinnedgmm(stats.t</span><span class="s2">, </span><span class="s1">ft</span><span class="s2">, </span><span class="s1">bt</span><span class="s2">, </span><span class="s1">[</span><span class="s4">10</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">weightsoptimal=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">print(paramsdgp)</span>

    <span class="s3">#Note: this can be used for chisquare test and then has correct asymptotic</span>
    <span class="s3">#   distribution for a distribution with estimated parameters, find ref again</span>
    <span class="s3">#TODO combine into test with binning included, check rule for number of bins</span>

    <span class="s3">#bt2 = stats.t.ppf(np.linspace(trvs.,1,21),5)</span>
    <span class="s1">ft2</span><span class="s2">,</span><span class="s1">bt2 = np.histogram(trvs</span><span class="s2">,</span><span class="s1">bins=</span><span class="s4">50</span><span class="s1">)</span>
    <span class="s5">'fitbinned t-distribution'</span>
    <span class="s1">tparest_mlebinel = fitbinned(stats.t</span><span class="s2">, </span><span class="s1">ft2</span><span class="s2">, </span><span class="s1">bt2</span><span class="s2">, </span><span class="s1">[</span><span class="s4">10</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">tparest_gmmbinelidentity = fitbinnedgmm(stats.t</span><span class="s2">, </span><span class="s1">ft2</span><span class="s2">, </span><span class="s1">bt2</span><span class="s2">, </span><span class="s1">[</span><span class="s4">10</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">tparest_gmmbineloptimal = fitbinnedgmm(stats.t</span><span class="s2">, </span><span class="s1">ft2</span><span class="s2">, </span><span class="s1">bt2</span><span class="s2">, </span><span class="s1">[</span><span class="s4">10</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">weightsoptimal=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">tparest_mle = stats.t.fit(trvs)</span>

    <span class="s1">np.set_printoptions(precision=</span><span class="s4">6</span><span class="s1">)</span>
    <span class="s1">print(</span><span class="s5">'sample size'</span><span class="s2">, </span><span class="s1">nobs)</span>
    <span class="s1">print(</span><span class="s5">'true (df, loc, scale)      '</span><span class="s2">, </span><span class="s1">paramsdgp)</span>
    <span class="s1">print(</span><span class="s5">'parest_mle                 '</span><span class="s2">, </span><span class="s1">tparest_mle)</span>
    <span class="s1">print</span>
    <span class="s1">print(</span><span class="s5">'tparest_mlebinel           '</span><span class="s2">, </span><span class="s1">tparest_mlebinel)</span>
    <span class="s1">print(</span><span class="s5">'tparest_gmmbinelidentity   '</span><span class="s2">, </span><span class="s1">tparest_gmmbinelidentity)</span>
    <span class="s1">print(</span><span class="s5">'tparest_gmmbineloptimal    '</span><span class="s2">, </span><span class="s1">tparest_gmmbineloptimal)</span>
    <span class="s1">print</span>
    <span class="s1">print(</span><span class="s5">'tparest_mlebinew           '</span><span class="s2">, </span><span class="s1">tparest_mlebinew)</span>
    <span class="s1">print(</span><span class="s5">'tparest_gmmbinewidentity   '</span><span class="s2">, </span><span class="s1">tparest_gmmbinewidentity)</span>
    <span class="s1">print(</span><span class="s5">'tparest_gmmbinewoptimal    '</span><span class="s2">, </span><span class="s1">tparest_gmmbinewoptimal)</span>
    <span class="s1">print</span>
    <span class="s1">print(</span><span class="s5">'tparest_gmmquantileidentity'</span><span class="s2">, </span><span class="s1">tparest_gmmquantile)</span>
    <span class="s1">print(</span><span class="s5">'tparest_gmm3quantilefsolve '</span><span class="s2">, </span><span class="s1">tparest_gmm3quantilefsolve)</span>
    <span class="s1">print(</span><span class="s5">'tparest_gmm3quantile       '</span><span class="s2">, </span><span class="s1">tparest_gmm3quantile)</span>

    <span class="s5">''' example results: 
    standard error for df estimate looks large 
    note: iI do not impose that df is an integer, (b/c not necessary) 
    need Monte Carlo to check variance of estimators 
 
 
    sample size 1000 
    true (df, loc, scale)       (5, 0, 1) 
    parest_mle                  [ 4.571405 -0.021493  1.028584] 
 
    tparest_mlebinel            [ 4.534069 -0.022605  1.02962 ] 
    tparest_gmmbinelidentity    [ 2.653056  0.012807  0.896958] 
    tparest_gmmbineloptimal     [ 2.437261 -0.020491  0.923308] 
 
    tparest_mlebinew            [ 2.999124 -0.0199    0.948811] 
    tparest_gmmbinewidentity    [ 2.900939 -0.020159  0.93481 ] 
    tparest_gmmbinewoptimal     [ 2.977764 -0.024925  0.946487] 
 
    tparest_gmmquantileidentity [ 3.940797 -0.046469  1.002001] 
    tparest_gmm3quantilefsolve  [ 10.   1.   2.] 
    tparest_gmm3quantile        [ 6.376101 -0.029322  1.112403] 
    '''</span>

    <span class="s3">#Example with Maximum Product of Spacings Estimation</span>
    <span class="s3">#===================================================</span>

    <span class="s3">#Example: Lognormal Distribution</span>
    <span class="s3">#-------------------------------</span>

    <span class="s3">#tough problem for MLE according to JKB</span>
    <span class="s3">#but not sure for which parameters</span>

    <span class="s1">print(</span><span class="s5">'</span><span class="s2">\n\n</span><span class="s5">Example: Lognormal Distribution'</span><span class="s1">)</span>
    <span class="s1">print(    </span><span class="s5">'-------------------------------'</span><span class="s1">)</span>

    <span class="s1">sh = np.exp(</span><span class="s4">10</span><span class="s1">)</span>
    <span class="s1">sh = </span><span class="s4">0.01</span>
    <span class="s1">print(sh)</span>
    <span class="s1">x = stats.lognorm.rvs(sh</span><span class="s2">,</span><span class="s1">loc=</span><span class="s4">100</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">10</span><span class="s2">,</span><span class="s1">size=</span><span class="s4">200</span><span class="s1">)</span>

    <span class="s1">print(x.min())</span>
    <span class="s1">print(stats.lognorm.fit(x</span><span class="s2">,  </span><span class="s4">1.</span><span class="s2">,</span><span class="s1">loc=x.min()-</span><span class="s4">1</span><span class="s2">,</span><span class="s1">scale=</span><span class="s4">1</span><span class="s1">))</span>

    <span class="s1">xsorted = np.sort(x)</span>

    <span class="s1">x0 = [</span><span class="s4">1.</span><span class="s2">, </span><span class="s1">x.min()-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">args = (xsorted</span><span class="s2">, </span><span class="s1">stats.lognorm)</span>
    <span class="s1">print(optimize.fmin(logmps</span><span class="s2">,</span><span class="s1">x0</span><span class="s2">,</span><span class="s1">args=args))</span>


    <span class="s3">#Example: Lomax, Pareto, Generalized Pareto Distributions</span>
    <span class="s3">#--------------------------------------------------------</span>

    <span class="s3">#partially a follow-up to the discussion about numpy.random.pareto</span>
    <span class="s3">#Reference: JKB</span>
    <span class="s3">#example Maximum Product of Spacings Estimation</span>

    <span class="s3"># current results:</span>
    <span class="s3"># does not look very good yet sensitivity to starting values</span>
    <span class="s3"># Pareto and Generalized Pareto look like a tough estimation problemprint('\n\nExample: Lognormal Distribution'</span>

    <span class="s1">print(</span><span class="s5">'</span><span class="s2">\n\n</span><span class="s5">Example: Lomax, Pareto, Generalized Pareto Distributions'</span><span class="s1">)</span>
    <span class="s1">print(    </span><span class="s5">'--------------------------------------------------------'</span><span class="s1">)</span>

    <span class="s1">p2rvs = stats.genpareto.rvs(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">500</span><span class="s1">)</span>
    <span class="s3">#Note: is Lomax without +1; and classical Pareto with +1</span>
    <span class="s1">p2rvssorted = np.sort(p2rvs)</span>
    <span class="s1">argsp = (p2rvssorted</span><span class="s2">, </span><span class="s1">stats.pareto)</span>
    <span class="s1">x0p = [</span><span class="s4">1.</span><span class="s2">, </span><span class="s1">p2rvs.min()-</span><span class="s4">5</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">print(optimize.fmin(logmps</span><span class="s2">,</span><span class="s1">x0p</span><span class="s2">,</span><span class="s1">args=argsp))</span>
    <span class="s1">print(stats.pareto.fit(p2rvs</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">loc=-</span><span class="s4">20</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">0.5</span><span class="s1">))</span>
    <span class="s1">print(</span><span class="s5">'gpdparest_ mle'</span><span class="s2">, </span><span class="s1">stats.genpareto.fit(p2rvs))</span>
    <span class="s1">parsgpd = fit_mps(stats.genpareto</span><span class="s2">, </span><span class="s1">p2rvs)</span>
    <span class="s1">print(</span><span class="s5">'gpdparest_ mps'</span><span class="s2">, </span><span class="s1">parsgpd)</span>
    <span class="s1">argsgpd = (p2rvssorted</span><span class="s2">, </span><span class="s1">stats.genpareto)</span>
    <span class="s1">options = dict(stepFix=</span><span class="s4">1e-7</span><span class="s1">)</span>
    <span class="s3">#hess_ndt(fun, pars, argsgdp, options)</span>
    <span class="s3">#the results for the following look strange, maybe refactoring error</span>
    <span class="s1">he</span><span class="s2">, </span><span class="s1">h = hess_ndt(logmps</span><span class="s2">, </span><span class="s1">parsgpd</span><span class="s2">, </span><span class="s1">argsgpd</span><span class="s2">, </span><span class="s1">options)</span>
    <span class="s1">print(np.linalg.eigh(he)[</span><span class="s4">0</span><span class="s1">])</span>
    <span class="s1">f = </span><span class="s2">lambda </span><span class="s1">params: logmps(params</span><span class="s2">, </span><span class="s1">*argsgpd)</span>
    <span class="s1">print(f(parsgpd))</span>
    <span class="s3">#add binned</span>
    <span class="s1">fp2</span><span class="s2">, </span><span class="s1">bp2 = np.histogram(p2rvs</span><span class="s2">, </span><span class="s1">bins=</span><span class="s4">50</span><span class="s1">)</span>
    <span class="s5">'fitbinned t-distribution'</span>
    <span class="s1">gpdparest_mlebinel = fitbinned(stats.genpareto</span><span class="s2">, </span><span class="s1">fp2</span><span class="s2">, </span><span class="s1">bp2</span><span class="s2">, </span><span class="s1">x0p)</span>
    <span class="s1">gpdparest_gmmbinelidentity = fitbinnedgmm(stats.genpareto</span><span class="s2">, </span><span class="s1">fp2</span><span class="s2">, </span><span class="s1">bp2</span><span class="s2">, </span><span class="s1">x0p)</span>
    <span class="s1">print(</span><span class="s5">'gpdparest_mlebinel'</span><span class="s2">, </span><span class="s1">gpdparest_mlebinel)</span>
    <span class="s1">print(</span><span class="s5">'gpdparest_gmmbinelidentity'</span><span class="s2">, </span><span class="s1">gpdparest_gmmbinelidentity)</span>
    <span class="s1">gpdparest_gmmquantile2 = fitquantilesgmm(</span>
        <span class="s1">stats.genpareto</span><span class="s2">, </span><span class="s1">p2rvs</span><span class="s2">, </span><span class="s1">start=x0p</span><span class="s2">, </span><span class="s1">pquant=</span><span class="s2">None, </span><span class="s1">frozen=</span><span class="s2">None</span><span class="s1">)</span>
    <span class="s1">print(</span><span class="s5">'gpdparest_gmmquantile2'</span><span class="s2">, </span><span class="s1">gpdparest_gmmquantile2)</span>

    <span class="s1">print(fitquantilesgmm(stats.genpareto</span><span class="s2">, </span><span class="s1">p2rvs</span><span class="s2">, </span><span class="s1">start=x0p</span><span class="s2">,</span>
                          <span class="s1">pquant=np.linspace(</span><span class="s4">0.01</span><span class="s2">,</span><span class="s4">0.99</span><span class="s2">,</span><span class="s4">10</span><span class="s1">)</span><span class="s2">, </span><span class="s1">frozen=</span><span class="s2">None</span><span class="s1">))</span>
    <span class="s1">fp2</span><span class="s2">, </span><span class="s1">bp2 = np.histogram(</span>
        <span class="s1">p2rvs</span><span class="s2">,</span>
        <span class="s1">bins=stats.genpareto(</span><span class="s4">2</span><span class="s1">).ppf(np.linspace(</span><span class="s4">0</span><span class="s2">,</span><span class="s4">0.99</span><span class="s2">,</span><span class="s4">10</span><span class="s1">)))</span>
    <span class="s1">print(</span><span class="s5">'fitbinnedgmm equal weight bins'</span><span class="s1">)</span>
    <span class="s1">print(fitbinnedgmm(stats.genpareto</span><span class="s2">, </span><span class="s1">fp2</span><span class="s2">, </span><span class="s1">bp2</span><span class="s2">, </span><span class="s1">x0p))</span>
</pre>
</body>
</html>