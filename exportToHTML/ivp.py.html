<html>
<head>
<title>ivp.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #6897bb;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ivp.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">inspect</span>
<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">.bdf </span><span class="s0">import </span><span class="s1">BDF</span>
<span class="s0">from </span><span class="s1">.radau </span><span class="s0">import </span><span class="s1">Radau</span>
<span class="s0">from </span><span class="s1">.rk </span><span class="s0">import </span><span class="s1">RK23</span><span class="s0">, </span><span class="s1">RK45</span><span class="s0">, </span><span class="s1">DOP853</span>
<span class="s0">from </span><span class="s1">.lsoda </span><span class="s0">import </span><span class="s1">LSODA</span>
<span class="s0">from </span><span class="s1">scipy.optimize </span><span class="s0">import </span><span class="s1">OptimizeResult</span>
<span class="s0">from </span><span class="s1">.common </span><span class="s0">import </span><span class="s1">EPS</span><span class="s0">, </span><span class="s1">OdeSolution</span>
<span class="s0">from </span><span class="s1">.base </span><span class="s0">import </span><span class="s1">OdeSolver</span>


<span class="s1">METHODS = {</span><span class="s2">'RK23'</span><span class="s1">: RK23</span><span class="s0">,</span>
           <span class="s2">'RK45'</span><span class="s1">: RK45</span><span class="s0">,</span>
           <span class="s2">'DOP853'</span><span class="s1">: DOP853</span><span class="s0">,</span>
           <span class="s2">'Radau'</span><span class="s1">: Radau</span><span class="s0">,</span>
           <span class="s2">'BDF'</span><span class="s1">: BDF</span><span class="s0">,</span>
           <span class="s2">'LSODA'</span><span class="s1">: LSODA}</span>


<span class="s1">MESSAGES = {</span><span class="s3">0</span><span class="s1">: </span><span class="s2">&quot;The solver successfully reached the end of the integration interval.&quot;</span><span class="s0">,</span>
            <span class="s3">1</span><span class="s1">: </span><span class="s2">&quot;A termination event occurred.&quot;</span><span class="s1">}</span>


<span class="s0">class </span><span class="s1">OdeResult(OptimizeResult):</span>
    <span class="s0">pass</span>


<span class="s0">def </span><span class="s1">prepare_events(events):</span>
    <span class="s4">&quot;&quot;&quot;Standardize event functions and extract is_terminal and direction.&quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">callable(events):</span>
        <span class="s1">events = (events</span><span class="s0">,</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">events </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">is_terminal = np.empty(len(events)</span><span class="s0">, </span><span class="s1">dtype=bool)</span>
        <span class="s1">direction = np.empty(len(events))</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">event </span><span class="s0">in </span><span class="s1">enumerate(events):</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">is_terminal[i] = event.terminal</span>
            <span class="s0">except </span><span class="s1">AttributeError:</span>
                <span class="s1">is_terminal[i] = </span><span class="s0">False</span>

            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">direction[i] = event.direction</span>
            <span class="s0">except </span><span class="s1">AttributeError:</span>
                <span class="s1">direction[i] = </span><span class="s3">0</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">is_terminal = </span><span class="s0">None</span>
        <span class="s1">direction = </span><span class="s0">None</span>

    <span class="s0">return </span><span class="s1">events</span><span class="s0">, </span><span class="s1">is_terminal</span><span class="s0">, </span><span class="s1">direction</span>


<span class="s0">def </span><span class="s1">solve_event_equation(event</span><span class="s0">, </span><span class="s1">sol</span><span class="s0">, </span><span class="s1">t_old</span><span class="s0">, </span><span class="s1">t):</span>
    <span class="s4">&quot;&quot;&quot;Solve an equation corresponding to an ODE event. 
 
    The equation is ``event(t, y(t)) = 0``, here ``y(t)`` is known from an 
    ODE solver using some sort of interpolation. It is solved by 
    `scipy.optimize.brentq` with xtol=atol=4*EPS. 
 
    Parameters 
    ---------- 
    event : callable 
        Function ``event(t, y)``. 
    sol : callable 
        Function ``sol(t)`` which evaluates an ODE solution between `t_old` 
        and  `t`. 
    t_old, t : float 
        Previous and new values of time. They will be used as a bracketing 
        interval. 
 
    Returns 
    ------- 
    root : float 
        Found solution. 
    &quot;&quot;&quot;</span>
    <span class="s0">from </span><span class="s1">scipy.optimize </span><span class="s0">import </span><span class="s1">brentq</span>
    <span class="s0">return </span><span class="s1">brentq(</span><span class="s0">lambda </span><span class="s1">t: event(t</span><span class="s0">, </span><span class="s1">sol(t))</span><span class="s0">, </span><span class="s1">t_old</span><span class="s0">, </span><span class="s1">t</span><span class="s0">,</span>
                  <span class="s1">xtol=</span><span class="s3">4 </span><span class="s1">* EPS</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">4 </span><span class="s1">* EPS)</span>


<span class="s0">def </span><span class="s1">handle_events(sol</span><span class="s0">, </span><span class="s1">events</span><span class="s0">, </span><span class="s1">active_events</span><span class="s0">, </span><span class="s1">is_terminal</span><span class="s0">, </span><span class="s1">t_old</span><span class="s0">, </span><span class="s1">t):</span>
    <span class="s4">&quot;&quot;&quot;Helper function to handle events. 
 
    Parameters 
    ---------- 
    sol : DenseOutput 
        Function ``sol(t)`` which evaluates an ODE solution between `t_old` 
        and  `t`. 
    events : list of callables, length n_events 
        Event functions with signatures ``event(t, y)``. 
    active_events : ndarray 
        Indices of events which occurred. 
    is_terminal : ndarray, shape (n_events,) 
        Which events are terminal. 
    t_old, t : float 
        Previous and new values of time. 
 
    Returns 
    ------- 
    root_indices : ndarray 
        Indices of events which take zero between `t_old` and `t` and before 
        a possible termination. 
    roots : ndarray 
        Values of t at which events occurred. 
    terminate : bool 
        Whether a terminal event occurred. 
    &quot;&quot;&quot;</span>
    <span class="s1">roots = [solve_event_equation(events[event_index]</span><span class="s0">, </span><span class="s1">sol</span><span class="s0">, </span><span class="s1">t_old</span><span class="s0">, </span><span class="s1">t)</span>
             <span class="s0">for </span><span class="s1">event_index </span><span class="s0">in </span><span class="s1">active_events]</span>

    <span class="s1">roots = np.asarray(roots)</span>

    <span class="s0">if </span><span class="s1">np.any(is_terminal[active_events]):</span>
        <span class="s0">if </span><span class="s1">t &gt; t_old:</span>
            <span class="s1">order = np.argsort(roots)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">order = np.argsort(-roots)</span>
        <span class="s1">active_events = active_events[order]</span>
        <span class="s1">roots = roots[order]</span>
        <span class="s1">t = np.nonzero(is_terminal[active_events])[</span><span class="s3">0</span><span class="s1">][</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">active_events = active_events[:t + </span><span class="s3">1</span><span class="s1">]</span>
        <span class="s1">roots = roots[:t + </span><span class="s3">1</span><span class="s1">]</span>
        <span class="s1">terminate = </span><span class="s0">True</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">terminate = </span><span class="s0">False</span>

    <span class="s0">return </span><span class="s1">active_events</span><span class="s0">, </span><span class="s1">roots</span><span class="s0">, </span><span class="s1">terminate</span>


<span class="s0">def </span><span class="s1">find_active_events(g</span><span class="s0">, </span><span class="s1">g_new</span><span class="s0">, </span><span class="s1">direction):</span>
    <span class="s4">&quot;&quot;&quot;Find which event occurred during an integration step. 
 
    Parameters 
    ---------- 
    g, g_new : array_like, shape (n_events,) 
        Values of event functions at a current and next points. 
    direction : ndarray, shape (n_events,) 
        Event &quot;direction&quot; according to the definition in `solve_ivp`. 
 
    Returns 
    ------- 
    active_events : ndarray 
        Indices of events which occurred during the step. 
    &quot;&quot;&quot;</span>
    <span class="s1">g</span><span class="s0">, </span><span class="s1">g_new = np.asarray(g)</span><span class="s0">, </span><span class="s1">np.asarray(g_new)</span>
    <span class="s1">up = (g &lt;= </span><span class="s3">0</span><span class="s1">) &amp; (g_new &gt;= </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">down = (g &gt;= </span><span class="s3">0</span><span class="s1">) &amp; (g_new &lt;= </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">either = up | down</span>
    <span class="s1">mask = (up &amp; (direction &gt; </span><span class="s3">0</span><span class="s1">) |</span>
            <span class="s1">down &amp; (direction &lt; </span><span class="s3">0</span><span class="s1">) |</span>
            <span class="s1">either &amp; (direction == </span><span class="s3">0</span><span class="s1">))</span>

    <span class="s0">return </span><span class="s1">np.nonzero(mask)[</span><span class="s3">0</span><span class="s1">]</span>


<span class="s0">def </span><span class="s1">solve_ivp(fun</span><span class="s0">, </span><span class="s1">t_span</span><span class="s0">, </span><span class="s1">y0</span><span class="s0">, </span><span class="s1">method=</span><span class="s2">'RK45'</span><span class="s0">, </span><span class="s1">t_eval=</span><span class="s0">None, </span><span class="s1">dense_output=</span><span class="s0">False,</span>
              <span class="s1">events=</span><span class="s0">None, </span><span class="s1">vectorized=</span><span class="s0">False, </span><span class="s1">args=</span><span class="s0">None, </span><span class="s1">**options):</span>
    <span class="s4">&quot;&quot;&quot;Solve an initial value problem for a system of ODEs. 
 
    This function numerically integrates a system of ordinary differential 
    equations given an initial value:: 
 
        dy / dt = f(t, y) 
        y(t0) = y0 
 
    Here t is a 1-D independent variable (time), y(t) is an 
    N-D vector-valued function (state), and an N-D 
    vector-valued function f(t, y) determines the differential equations. 
    The goal is to find y(t) approximately satisfying the differential 
    equations, given an initial value y(t0)=y0. 
 
    Some of the solvers support integration in the complex domain, but note 
    that for stiff ODE solvers, the right-hand side must be 
    complex-differentiable (satisfy Cauchy-Riemann equations [11]_). 
    To solve a problem in the complex domain, pass y0 with a complex data type. 
    Another option always available is to rewrite your problem for real and 
    imaginary parts separately. 
 
    Parameters 
    ---------- 
    fun : callable 
        Right-hand side of the system: the time derivative of the state ``y`` 
        at time ``t``. The calling signature is ``fun(t, y)``, where ``t`` is a 
        scalar and ``y`` is an ndarray with ``len(y) = len(y0)``. ``fun`` must 
        return an array of the same shape as ``y``. See `vectorized` for more 
        information. 
    t_span : 2-member sequence 
        Interval of integration (t0, tf). The solver starts with t=t0 and 
        integrates until it reaches t=tf. Both t0 and tf must be floats 
        or values interpretable by the float conversion function. 
    y0 : array_like, shape (n,) 
        Initial state. For problems in the complex domain, pass `y0` with a 
        complex data type (even if the initial value is purely real). 
    method : string or `OdeSolver`, optional 
        Integration method to use: 
 
            * 'RK45' (default): Explicit Runge-Kutta method of order 5(4) [1]_. 
              The error is controlled assuming accuracy of the fourth-order 
              method, but steps are taken using the fifth-order accurate 
              formula (local extrapolation is done). A quartic interpolation 
              polynomial is used for the dense output [2]_. Can be applied in 
              the complex domain. 
            * 'RK23': Explicit Runge-Kutta method of order 3(2) [3]_. The error 
              is controlled assuming accuracy of the second-order method, but 
              steps are taken using the third-order accurate formula (local 
              extrapolation is done). A cubic Hermite polynomial is used for the 
              dense output. Can be applied in the complex domain. 
            * 'DOP853': Explicit Runge-Kutta method of order 8 [13]_. 
              Python implementation of the &quot;DOP853&quot; algorithm originally 
              written in Fortran [14]_. A 7-th order interpolation polynomial 
              accurate to 7-th order is used for the dense output. 
              Can be applied in the complex domain. 
            * 'Radau': Implicit Runge-Kutta method of the Radau IIA family of 
              order 5 [4]_. The error is controlled with a third-order accurate 
              embedded formula. A cubic polynomial which satisfies the 
              collocation conditions is used for the dense output. 
            * 'BDF': Implicit multi-step variable-order (1 to 5) method based 
              on a backward differentiation formula for the derivative 
              approximation [5]_. The implementation follows the one described 
              in [6]_. A quasi-constant step scheme is used and accuracy is 
              enhanced using the NDF modification. Can be applied in the 
              complex domain. 
            * 'LSODA': Adams/BDF method with automatic stiffness detection and 
              switching [7]_, [8]_. This is a wrapper of the Fortran solver 
              from ODEPACK. 
 
        Explicit Runge-Kutta methods ('RK23', 'RK45', 'DOP853') should be used 
        for non-stiff problems and implicit methods ('Radau', 'BDF') for 
        stiff problems [9]_. Among Runge-Kutta methods, 'DOP853' is recommended 
        for solving with high precision (low values of `rtol` and `atol`). 
 
        If not sure, first try to run 'RK45'. If it makes unusually many 
        iterations, diverges, or fails, your problem is likely to be stiff and 
        you should use 'Radau' or 'BDF'. 'LSODA' can also be a good universal 
        choice, but it might be somewhat less convenient to work with as it 
        wraps old Fortran code. 
 
        You can also pass an arbitrary class derived from `OdeSolver` which 
        implements the solver. 
    t_eval : array_like or None, optional 
        Times at which to store the computed solution, must be sorted and lie 
        within `t_span`. If None (default), use points selected by the solver. 
    dense_output : bool, optional 
        Whether to compute a continuous solution. Default is False. 
    events : callable, or list of callables, optional 
        Events to track. If None (default), no events will be tracked. 
        Each event occurs at the zeros of a continuous function of time and 
        state. Each function must have the signature ``event(t, y)`` and return 
        a float. The solver will find an accurate value of `t` at which 
        ``event(t, y(t)) = 0`` using a root-finding algorithm. By default, all 
        zeros will be found. The solver looks for a sign change over each step, 
        so if multiple zero crossings occur within one step, events may be 
        missed. Additionally each `event` function might have the following 
        attributes: 
 
            terminal: bool, optional 
                Whether to terminate integration if this event occurs. 
                Implicitly False if not assigned. 
            direction: float, optional 
                Direction of a zero crossing. If `direction` is positive, 
                `event` will only trigger when going from negative to positive, 
                and vice versa if `direction` is negative. If 0, then either 
                direction will trigger event. Implicitly 0 if not assigned. 
 
        You can assign attributes like ``event.terminal = True`` to any 
        function in Python. 
    vectorized : bool, optional 
        Whether `fun` can be called in a vectorized fashion. Default is False. 
 
        If ``vectorized`` is False, `fun` will always be called with ``y`` of 
        shape ``(n,)``, where ``n = len(y0)``. 
 
        If ``vectorized`` is True, `fun` may be called with ``y`` of shape 
        ``(n, k)``, where ``k`` is an integer. In this case, `fun` must behave 
        such that ``fun(t, y)[:, i] == fun(t, y[:, i])`` (i.e. each column of 
        the returned array is the time derivative of the state corresponding 
        with a column of ``y``). 
 
        Setting ``vectorized=True`` allows for faster finite difference 
        approximation of the Jacobian by methods 'Radau' and 'BDF', but 
        will result in slower execution for other methods and for 'Radau' and 
        'BDF' in some circumstances (e.g. small ``len(y0)``). 
    args : tuple, optional 
        Additional arguments to pass to the user-defined functions.  If given, 
        the additional arguments are passed to all user-defined functions. 
        So if, for example, `fun` has the signature ``fun(t, y, a, b, c)``, 
        then `jac` (if given) and any event functions must have the same 
        signature, and `args` must be a tuple of length 3. 
    **options 
        Options passed to a chosen solver. All options available for already 
        implemented solvers are listed below. 
    first_step : float or None, optional 
        Initial step size. Default is `None` which means that the algorithm 
        should choose. 
    max_step : float, optional 
        Maximum allowed step size. Default is np.inf, i.e., the step size is not 
        bounded and determined solely by the solver. 
    rtol, atol : float or array_like, optional 
        Relative and absolute tolerances. The solver keeps the local error 
        estimates less than ``atol + rtol * abs(y)``. Here `rtol` controls a 
        relative accuracy (number of correct digits), while `atol` controls 
        absolute accuracy (number of correct decimal places). To achieve the 
        desired `rtol`, set `atol` to be smaller than the smallest value that 
        can be expected from ``rtol * abs(y)`` so that `rtol` dominates the 
        allowable error. If `atol` is larger than ``rtol * abs(y)`` the 
        number of correct digits is not guaranteed. Conversely, to achieve the 
        desired `atol` set `rtol` such that ``rtol * abs(y)`` is always smaller 
        than `atol`. If components of y have different scales, it might be 
        beneficial to set different `atol` values for different components by 
        passing array_like with shape (n,) for `atol`. Default values are 
        1e-3 for `rtol` and 1e-6 for `atol`. 
    jac : array_like, sparse_matrix, callable or None, optional 
        Jacobian matrix of the right-hand side of the system with respect 
        to y, required by the 'Radau', 'BDF' and 'LSODA' method. The 
        Jacobian matrix has shape (n, n) and its element (i, j) is equal to 
        ``d f_i / d y_j``.  There are three ways to define the Jacobian: 
 
            * If array_like or sparse_matrix, the Jacobian is assumed to 
              be constant. Not supported by 'LSODA'. 
            * If callable, the Jacobian is assumed to depend on both 
              t and y; it will be called as ``jac(t, y)``, as necessary. 
              For 'Radau' and 'BDF' methods, the return value might be a 
              sparse matrix. 
            * If None (default), the Jacobian will be approximated by 
              finite differences. 
 
        It is generally recommended to provide the Jacobian rather than 
        relying on a finite-difference approximation. 
    jac_sparsity : array_like, sparse matrix or None, optional 
        Defines a sparsity structure of the Jacobian matrix for a finite- 
        difference approximation. Its shape must be (n, n). This argument 
        is ignored if `jac` is not `None`. If the Jacobian has only few 
        non-zero elements in *each* row, providing the sparsity structure 
        will greatly speed up the computations [10]_. A zero entry means that 
        a corresponding element in the Jacobian is always zero. If None 
        (default), the Jacobian is assumed to be dense. 
        Not supported by 'LSODA', see `lband` and `uband` instead. 
    lband, uband : int or None, optional 
        Parameters defining the bandwidth of the Jacobian for the 'LSODA' 
        method, i.e., ``jac[i, j] != 0 only for i - lband &lt;= j &lt;= i + uband``. 
        Default is None. Setting these requires your jac routine to return the 
        Jacobian in the packed format: the returned array must have ``n`` 
        columns and ``uband + lband + 1`` rows in which Jacobian diagonals are 
        written. Specifically ``jac_packed[uband + i - j , j] = jac[i, j]``. 
        The same format is used in `scipy.linalg.solve_banded` (check for an 
        illustration).  These parameters can be also used with ``jac=None`` to 
        reduce the number of Jacobian elements estimated by finite differences. 
    min_step : float, optional 
        The minimum allowed step size for 'LSODA' method. 
        By default `min_step` is zero. 
 
    Returns 
    ------- 
    Bunch object with the following fields defined: 
    t : ndarray, shape (n_points,) 
        Time points. 
    y : ndarray, shape (n, n_points) 
        Values of the solution at `t`. 
    sol : `OdeSolution` or None 
        Found solution as `OdeSolution` instance; None if `dense_output` was 
        set to False. 
    t_events : list of ndarray or None 
        Contains for each event type a list of arrays at which an event of 
        that type event was detected. None if `events` was None. 
    y_events : list of ndarray or None 
        For each value of `t_events`, the corresponding value of the solution. 
        None if `events` was None. 
    nfev : int 
        Number of evaluations of the right-hand side. 
    njev : int 
        Number of evaluations of the Jacobian. 
    nlu : int 
        Number of LU decompositions. 
    status : int 
        Reason for algorithm termination: 
 
            * -1: Integration step failed. 
            *  0: The solver successfully reached the end of `tspan`. 
            *  1: A termination event occurred. 
 
    message : string 
        Human-readable description of the termination reason. 
    success : bool 
        True if the solver reached the interval end or a termination event 
        occurred (``status &gt;= 0``). 
 
    References 
    ---------- 
    .. [1] J. R. Dormand, P. J. Prince, &quot;A family of embedded Runge-Kutta 
           formulae&quot;, Journal of Computational and Applied Mathematics, Vol. 6, 
           No. 1, pp. 19-26, 1980. 
    .. [2] L. W. Shampine, &quot;Some Practical Runge-Kutta Formulas&quot;, Mathematics 
           of Computation,, Vol. 46, No. 173, pp. 135-150, 1986. 
    .. [3] P. Bogacki, L.F. Shampine, &quot;A 3(2) Pair of Runge-Kutta Formulas&quot;, 
           Appl. Math. Lett. Vol. 2, No. 4. pp. 321-325, 1989. 
    .. [4] E. Hairer, G. Wanner, &quot;Solving Ordinary Differential Equations II: 
           Stiff and Differential-Algebraic Problems&quot;, Sec. IV.8. 
    .. [5] `Backward Differentiation Formula 
            &lt;https://en.wikipedia.org/wiki/Backward_differentiation_formula&gt;`_ 
            on Wikipedia. 
    .. [6] L. F. Shampine, M. W. Reichelt, &quot;THE MATLAB ODE SUITE&quot;, SIAM J. SCI. 
           COMPUTE., Vol. 18, No. 1, pp. 1-22, January 1997. 
    .. [7] A. C. Hindmarsh, &quot;ODEPACK, A Systematized Collection of ODE 
           Solvers,&quot; IMACS Transactions on Scientific Computation, Vol 1., 
           pp. 55-64, 1983. 
    .. [8] L. Petzold, &quot;Automatic selection of methods for solving stiff and 
           nonstiff systems of ordinary differential equations&quot;, SIAM Journal 
           on Scientific and Statistical Computing, Vol. 4, No. 1, pp. 136-148, 
           1983. 
    .. [9] `Stiff equation &lt;https://en.wikipedia.org/wiki/Stiff_equation&gt;`_ on 
           Wikipedia. 
    .. [10] A. Curtis, M. J. D. Powell, and J. Reid, &quot;On the estimation of 
            sparse Jacobian matrices&quot;, Journal of the Institute of Mathematics 
            and its Applications, 13, pp. 117-120, 1974. 
    .. [11] `Cauchy-Riemann equations 
             &lt;https://en.wikipedia.org/wiki/Cauchy-Riemann_equations&gt;`_ on 
             Wikipedia. 
    .. [12] `Lotka-Volterra equations 
            &lt;https://en.wikipedia.org/wiki/Lotka%E2%80%93Volterra_equations&gt;`_ 
            on Wikipedia. 
    .. [13] E. Hairer, S. P. Norsett G. Wanner, &quot;Solving Ordinary Differential 
            Equations I: Nonstiff Problems&quot;, Sec. II. 
    .. [14] `Page with original Fortran code of DOP853 
            &lt;http://www.unige.ch/~hairer/software.html&gt;`_. 
 
    Examples 
    -------- 
    Basic exponential decay showing automatically chosen time points. 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.integrate import solve_ivp 
    &gt;&gt;&gt; def exponential_decay(t, y): return -0.5 * y 
    &gt;&gt;&gt; sol = solve_ivp(exponential_decay, [0, 10], [2, 4, 8]) 
    &gt;&gt;&gt; print(sol.t) 
    [ 0.          0.11487653  1.26364188  3.06061781  4.81611105  6.57445806 
      8.33328988 10.        ] 
    &gt;&gt;&gt; print(sol.y) 
    [[2.         1.88836035 1.06327177 0.43319312 0.18017253 0.07483045 
      0.03107158 0.01350781] 
     [4.         3.7767207  2.12654355 0.86638624 0.36034507 0.14966091 
      0.06214316 0.02701561] 
     [8.         7.5534414  4.25308709 1.73277247 0.72069014 0.29932181 
      0.12428631 0.05403123]] 
 
    Specifying points where the solution is desired. 
 
    &gt;&gt;&gt; sol = solve_ivp(exponential_decay, [0, 10], [2, 4, 8], 
    ...                 t_eval=[0, 1, 2, 4, 10]) 
    &gt;&gt;&gt; print(sol.t) 
    [ 0  1  2  4 10] 
    &gt;&gt;&gt; print(sol.y) 
    [[2.         1.21305369 0.73534021 0.27066736 0.01350938] 
     [4.         2.42610739 1.47068043 0.54133472 0.02701876] 
     [8.         4.85221478 2.94136085 1.08266944 0.05403753]] 
 
    Cannon fired upward with terminal event upon impact. The ``terminal`` and 
    ``direction`` fields of an event are applied by monkey patching a function. 
    Here ``y[0]`` is position and ``y[1]`` is velocity. The projectile starts 
    at position 0 with velocity +10. Note that the integration never reaches 
    t=100 because the event is terminal. 
 
    &gt;&gt;&gt; def upward_cannon(t, y): return [y[1], -0.5] 
    &gt;&gt;&gt; def hit_ground(t, y): return y[0] 
    &gt;&gt;&gt; hit_ground.terminal = True 
    &gt;&gt;&gt; hit_ground.direction = -1 
    &gt;&gt;&gt; sol = solve_ivp(upward_cannon, [0, 100], [0, 10], events=hit_ground) 
    &gt;&gt;&gt; print(sol.t_events) 
    [array([40.])] 
    &gt;&gt;&gt; print(sol.t) 
    [0.00000000e+00 9.99900010e-05 1.09989001e-03 1.10988901e-02 
     1.11088891e-01 1.11098890e+00 1.11099890e+01 4.00000000e+01] 
 
    Use `dense_output` and `events` to find position, which is 100, at the apex 
    of the cannonball's trajectory. Apex is not defined as terminal, so both 
    apex and hit_ground are found. There is no information at t=20, so the sol 
    attribute is used to evaluate the solution. The sol attribute is returned 
    by setting ``dense_output=True``. Alternatively, the `y_events` attribute 
    can be used to access the solution at the time of the event. 
 
    &gt;&gt;&gt; def apex(t, y): return y[1] 
    &gt;&gt;&gt; sol = solve_ivp(upward_cannon, [0, 100], [0, 10], 
    ...                 events=(hit_ground, apex), dense_output=True) 
    &gt;&gt;&gt; print(sol.t_events) 
    [array([40.]), array([20.])] 
    &gt;&gt;&gt; print(sol.t) 
    [0.00000000e+00 9.99900010e-05 1.09989001e-03 1.10988901e-02 
     1.11088891e-01 1.11098890e+00 1.11099890e+01 4.00000000e+01] 
    &gt;&gt;&gt; print(sol.sol(sol.t_events[1][0])) 
    [100.   0.] 
    &gt;&gt;&gt; print(sol.y_events) 
    [array([[-5.68434189e-14, -1.00000000e+01]]), array([[1.00000000e+02, 1.77635684e-15]])] 
 
    As an example of a system with additional parameters, we'll implement 
    the Lotka-Volterra equations [12]_. 
 
    &gt;&gt;&gt; def lotkavolterra(t, z, a, b, c, d): 
    ...     x, y = z 
    ...     return [a*x - b*x*y, -c*y + d*x*y] 
    ... 
 
    We pass in the parameter values a=1.5, b=1, c=3 and d=1 with the `args` 
    argument. 
 
    &gt;&gt;&gt; sol = solve_ivp(lotkavolterra, [0, 15], [10, 5], args=(1.5, 1, 3, 1), 
    ...                 dense_output=True) 
 
    Compute a dense solution and plot it. 
 
    &gt;&gt;&gt; t = np.linspace(0, 15, 300) 
    &gt;&gt;&gt; z = sol.sol(t) 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; plt.plot(t, z.T) 
    &gt;&gt;&gt; plt.xlabel('t') 
    &gt;&gt;&gt; plt.legend(['x', 'y'], shadow=True) 
    &gt;&gt;&gt; plt.title('Lotka-Volterra System') 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">method </span><span class="s0">not in </span><span class="s1">METHODS </span><span class="s0">and not </span><span class="s1">(</span>
            <span class="s1">inspect.isclass(method) </span><span class="s0">and </span><span class="s1">issubclass(method</span><span class="s0">, </span><span class="s1">OdeSolver)):</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;`method` must be one of {} or OdeSolver class.&quot;</span>
                         <span class="s1">.format(METHODS))</span>

    <span class="s1">t0</span><span class="s0">, </span><span class="s1">tf = map(float</span><span class="s0">, </span><span class="s1">t_span)</span>

    <span class="s0">if </span><span class="s1">args </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s5"># Wrap the user's fun (and jac, if given) in lambdas to hide the</span>
        <span class="s5"># additional parameters.  Pass in the original fun as a keyword</span>
        <span class="s5"># argument to keep it in the scope of the lambda.</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">_ = [*(args)]</span>
        <span class="s0">except </span><span class="s1">TypeError </span><span class="s0">as </span><span class="s1">exp:</span>
            <span class="s1">suggestion_tuple = (</span>
                <span class="s2">&quot;Supplied 'args' cannot be unpacked. Please supply `args`&quot;</span>
                <span class="s2">f&quot; as a tuple (e.g. `args=(</span><span class="s0">{</span><span class="s1">args</span><span class="s0">}</span><span class="s2">,)`)&quot;</span>
            <span class="s1">)</span>
            <span class="s0">raise </span><span class="s1">TypeError(suggestion_tuple) </span><span class="s0">from </span><span class="s1">exp</span>

        <span class="s0">def </span><span class="s1">fun(t</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">fun=fun):</span>
            <span class="s0">return </span><span class="s1">fun(t</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">*args)</span>
        <span class="s1">jac = options.get(</span><span class="s2">'jac'</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">callable(jac):</span>
            <span class="s1">options[</span><span class="s2">'jac'</span><span class="s1">] = </span><span class="s0">lambda </span><span class="s1">t</span><span class="s0">, </span><span class="s1">x: jac(t</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">*args)</span>

    <span class="s0">if </span><span class="s1">t_eval </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">t_eval = np.asarray(t_eval)</span>
        <span class="s0">if </span><span class="s1">t_eval.ndim != </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;`t_eval` must be 1-dimensional.&quot;</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">np.any(t_eval &lt; min(t0</span><span class="s0">, </span><span class="s1">tf)) </span><span class="s0">or </span><span class="s1">np.any(t_eval &gt; max(t0</span><span class="s0">, </span><span class="s1">tf)):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Values in `t_eval` are not within `t_span`.&quot;</span><span class="s1">)</span>

        <span class="s1">d = np.diff(t_eval)</span>
        <span class="s0">if </span><span class="s1">tf &gt; t0 </span><span class="s0">and </span><span class="s1">np.any(d &lt;= </span><span class="s3">0</span><span class="s1">) </span><span class="s0">or </span><span class="s1">tf &lt; t0 </span><span class="s0">and </span><span class="s1">np.any(d &gt;= </span><span class="s3">0</span><span class="s1">):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Values in `t_eval` are not properly sorted.&quot;</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">tf &gt; t0:</span>
            <span class="s1">t_eval_i = </span><span class="s3">0</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s5"># Make order of t_eval decreasing to use np.searchsorted.</span>
            <span class="s1">t_eval = t_eval[::-</span><span class="s3">1</span><span class="s1">]</span>
            <span class="s5"># This will be an upper bound for slices.</span>
            <span class="s1">t_eval_i = t_eval.shape[</span><span class="s3">0</span><span class="s1">]</span>

    <span class="s0">if </span><span class="s1">method </span><span class="s0">in </span><span class="s1">METHODS:</span>
        <span class="s1">method = METHODS[method]</span>

    <span class="s1">solver = method(fun</span><span class="s0">, </span><span class="s1">t0</span><span class="s0">, </span><span class="s1">y0</span><span class="s0">, </span><span class="s1">tf</span><span class="s0">, </span><span class="s1">vectorized=vectorized</span><span class="s0">, </span><span class="s1">**options)</span>

    <span class="s0">if </span><span class="s1">t_eval </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">ts = [t0]</span>
        <span class="s1">ys = [y0]</span>
    <span class="s0">elif </span><span class="s1">t_eval </span><span class="s0">is not None and </span><span class="s1">dense_output:</span>
        <span class="s1">ts = []</span>
        <span class="s1">ti = [t0]</span>
        <span class="s1">ys = []</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">ts = []</span>
        <span class="s1">ys = []</span>

    <span class="s1">interpolants = []</span>

    <span class="s1">events</span><span class="s0">, </span><span class="s1">is_terminal</span><span class="s0">, </span><span class="s1">event_dir = prepare_events(events)</span>

    <span class="s0">if </span><span class="s1">events </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">args </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s5"># Wrap user functions in lambdas to hide the additional parameters.</span>
            <span class="s5"># The original event function is passed as a keyword argument to the</span>
            <span class="s5"># lambda to keep the original function in scope (i.e., avoid the</span>
            <span class="s5"># late binding closure &quot;gotcha&quot;).</span>
            <span class="s1">events = [</span><span class="s0">lambda </span><span class="s1">t</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">event=event: event(t</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">*args)</span>
                      <span class="s0">for </span><span class="s1">event </span><span class="s0">in </span><span class="s1">events]</span>
        <span class="s1">g = [event(t0</span><span class="s0">, </span><span class="s1">y0) </span><span class="s0">for </span><span class="s1">event </span><span class="s0">in </span><span class="s1">events]</span>
        <span class="s1">t_events = [[] </span><span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(len(events))]</span>
        <span class="s1">y_events = [[] </span><span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(len(events))]</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">t_events = </span><span class="s0">None</span>
        <span class="s1">y_events = </span><span class="s0">None</span>

    <span class="s1">status = </span><span class="s0">None</span>
    <span class="s0">while </span><span class="s1">status </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">message = solver.step()</span>

        <span class="s0">if </span><span class="s1">solver.status == </span><span class="s2">'finished'</span><span class="s1">:</span>
            <span class="s1">status = </span><span class="s3">0</span>
        <span class="s0">elif </span><span class="s1">solver.status == </span><span class="s2">'failed'</span><span class="s1">:</span>
            <span class="s1">status = -</span><span class="s3">1</span>
            <span class="s0">break</span>

        <span class="s1">t_old = solver.t_old</span>
        <span class="s1">t = solver.t</span>
        <span class="s1">y = solver.y</span>

        <span class="s0">if </span><span class="s1">dense_output:</span>
            <span class="s1">sol = solver.dense_output()</span>
            <span class="s1">interpolants.append(sol)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">sol = </span><span class="s0">None</span>

        <span class="s0">if </span><span class="s1">events </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">g_new = [event(t</span><span class="s0">, </span><span class="s1">y) </span><span class="s0">for </span><span class="s1">event </span><span class="s0">in </span><span class="s1">events]</span>
            <span class="s1">active_events = find_active_events(g</span><span class="s0">, </span><span class="s1">g_new</span><span class="s0">, </span><span class="s1">event_dir)</span>
            <span class="s0">if </span><span class="s1">active_events.size &gt; </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">sol </span><span class="s0">is None</span><span class="s1">:</span>
                    <span class="s1">sol = solver.dense_output()</span>

                <span class="s1">root_indices</span><span class="s0">, </span><span class="s1">roots</span><span class="s0">, </span><span class="s1">terminate = handle_events(</span>
                    <span class="s1">sol</span><span class="s0">, </span><span class="s1">events</span><span class="s0">, </span><span class="s1">active_events</span><span class="s0">, </span><span class="s1">is_terminal</span><span class="s0">, </span><span class="s1">t_old</span><span class="s0">, </span><span class="s1">t)</span>

                <span class="s0">for </span><span class="s1">e</span><span class="s0">, </span><span class="s1">te </span><span class="s0">in </span><span class="s1">zip(root_indices</span><span class="s0">, </span><span class="s1">roots):</span>
                    <span class="s1">t_events[e].append(te)</span>
                    <span class="s1">y_events[e].append(sol(te))</span>

                <span class="s0">if </span><span class="s1">terminate:</span>
                    <span class="s1">status = </span><span class="s3">1</span>
                    <span class="s1">t = roots[-</span><span class="s3">1</span><span class="s1">]</span>
                    <span class="s1">y = sol(t)</span>

            <span class="s1">g = g_new</span>

        <span class="s0">if </span><span class="s1">t_eval </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">ts.append(t)</span>
            <span class="s1">ys.append(y)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s5"># The value in t_eval equal to t will be included.</span>
            <span class="s0">if </span><span class="s1">solver.direction &gt; </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s1">t_eval_i_new = np.searchsorted(t_eval</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">side=</span><span class="s2">'right'</span><span class="s1">)</span>
                <span class="s1">t_eval_step = t_eval[t_eval_i:t_eval_i_new]</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">t_eval_i_new = np.searchsorted(t_eval</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">side=</span><span class="s2">'left'</span><span class="s1">)</span>
                <span class="s5"># It has to be done with two slice operations, because</span>
                <span class="s5"># you can't slice to 0th element inclusive using backward</span>
                <span class="s5"># slicing.</span>
                <span class="s1">t_eval_step = t_eval[t_eval_i_new:t_eval_i][::-</span><span class="s3">1</span><span class="s1">]</span>

            <span class="s0">if </span><span class="s1">t_eval_step.size &gt; </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">sol </span><span class="s0">is None</span><span class="s1">:</span>
                    <span class="s1">sol = solver.dense_output()</span>
                <span class="s1">ts.append(t_eval_step)</span>
                <span class="s1">ys.append(sol(t_eval_step))</span>
                <span class="s1">t_eval_i = t_eval_i_new</span>

        <span class="s0">if </span><span class="s1">t_eval </span><span class="s0">is not None and </span><span class="s1">dense_output:</span>
            <span class="s1">ti.append(t)</span>

    <span class="s1">message = MESSAGES.get(status</span><span class="s0">, </span><span class="s1">message)</span>

    <span class="s0">if </span><span class="s1">t_events </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">t_events = [np.asarray(te) </span><span class="s0">for </span><span class="s1">te </span><span class="s0">in </span><span class="s1">t_events]</span>
        <span class="s1">y_events = [np.asarray(ye) </span><span class="s0">for </span><span class="s1">ye </span><span class="s0">in </span><span class="s1">y_events]</span>

    <span class="s0">if </span><span class="s1">t_eval </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">ts = np.array(ts)</span>
        <span class="s1">ys = np.vstack(ys).T</span>
    <span class="s0">elif </span><span class="s1">ts:</span>
        <span class="s1">ts = np.hstack(ts)</span>
        <span class="s1">ys = np.hstack(ys)</span>

    <span class="s0">if </span><span class="s1">dense_output:</span>
        <span class="s0">if </span><span class="s1">t_eval </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">sol = OdeSolution(ts</span><span class="s0">, </span><span class="s1">interpolants)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">sol = OdeSolution(ti</span><span class="s0">, </span><span class="s1">interpolants)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">sol = </span><span class="s0">None</span>

    <span class="s0">return </span><span class="s1">OdeResult(t=ts</span><span class="s0">, </span><span class="s1">y=ys</span><span class="s0">, </span><span class="s1">sol=sol</span><span class="s0">, </span><span class="s1">t_events=t_events</span><span class="s0">, </span><span class="s1">y_events=y_events</span><span class="s0">,</span>
                     <span class="s1">nfev=solver.nfev</span><span class="s0">, </span><span class="s1">njev=solver.njev</span><span class="s0">, </span><span class="s1">nlu=solver.nlu</span><span class="s0">,</span>
                     <span class="s1">status=status</span><span class="s0">, </span><span class="s1">message=message</span><span class="s0">, </span><span class="s1">success=status &gt;= </span><span class="s3">0</span><span class="s1">)</span>
</pre>
</body>
</html>