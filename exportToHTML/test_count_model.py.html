<html>
<head>
<title>test_count_model.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6897bb;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_count_model.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">statsmodels.compat.platform </span><span class="s0">import </span><span class="s1">PLATFORM_LINUX32</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">numpy.testing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">assert_</span><span class="s0">,</span>
    <span class="s1">assert_allclose</span><span class="s0">,</span>
    <span class="s1">assert_array_equal</span><span class="s0">,</span>
    <span class="s1">assert_equal</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">import </span><span class="s1">pandas </span><span class="s0">as </span><span class="s1">pd</span>
<span class="s0">import </span><span class="s1">pytest</span>

<span class="s0">import </span><span class="s1">statsmodels.api </span><span class="s0">as </span><span class="s1">sm</span>

<span class="s0">from </span><span class="s1">.results.results_discrete </span><span class="s0">import </span><span class="s1">RandHIE</span>
<span class="s0">from </span><span class="s1">.test_discrete </span><span class="s0">import </span><span class="s1">CheckModelMixin</span>


<span class="s0">class </span><span class="s1">CheckGeneric(CheckModelMixin):</span>
    <span class="s0">def </span><span class="s1">test_params(self):</span>
        <span class="s1">assert_allclose(self.res1.params</span><span class="s0">, </span><span class="s1">self.res2.params</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-5</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-5</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_llf(self):</span>
        <span class="s1">assert_allclose(self.res1.llf</span><span class="s0">, </span><span class="s1">self.res2.llf</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-5</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-5</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_conf_int(self):</span>
        <span class="s1">assert_allclose(self.res1.conf_int()</span><span class="s0">, </span><span class="s1">self.res2.conf_int</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-3</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-5</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_bse(self):</span>
        <span class="s1">assert_allclose(self.res1.bse</span><span class="s0">, </span><span class="s1">self.res2.bse</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-3</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-3</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_aic(self):</span>
        <span class="s1">assert_allclose(self.res1.aic</span><span class="s0">, </span><span class="s1">self.res2.aic</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-2</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-2</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_bic(self):</span>
        <span class="s1">assert_allclose(self.res1.aic</span><span class="s0">, </span><span class="s1">self.res2.aic</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-1</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_t(self):</span>
        <span class="s1">unit_matrix = np.identity(self.res1.params.size)</span>
        <span class="s1">t_test = self.res1.t_test(unit_matrix)</span>
        <span class="s1">assert_allclose(self.res1.tvalues</span><span class="s0">, </span><span class="s1">t_test.tvalue)</span>

    <span class="s0">def </span><span class="s1">test_fit_regularized(self):</span>
        <span class="s1">model = self.res1.model</span>

        <span class="s1">alpha = np.ones(len(self.res1.params))</span>
        <span class="s1">alpha[-</span><span class="s2">2</span><span class="s1">:] = </span><span class="s2">0</span>
        <span class="s1">res_reg = model.fit_regularized(alpha=alpha*</span><span class="s2">0.01</span><span class="s0">, </span><span class="s1">disp=</span><span class="s0">False, </span><span class="s1">maxiter=</span><span class="s2">500</span><span class="s1">)</span>

        <span class="s1">assert_allclose(res_reg.params[</span><span class="s2">2</span><span class="s1">:]</span><span class="s0">, </span><span class="s1">self.res1.params[</span><span class="s2">2</span><span class="s1">:]</span><span class="s0">,</span>
            <span class="s1">atol=</span><span class="s2">5e-2</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">5e-2</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_init_keys(self):</span>
        <span class="s1">init_kwds = self.res1.model._get_init_kwds()</span>
        <span class="s1">assert_equal(set(init_kwds.keys())</span><span class="s0">, </span><span class="s1">set(self.init_keys))</span>
        <span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value </span><span class="s0">in </span><span class="s1">self.init_kwds.items():</span>
            <span class="s1">assert_equal(init_kwds[key]</span><span class="s0">, </span><span class="s1">value)</span>

    <span class="s0">def </span><span class="s1">test_null(self):</span>
        <span class="s3"># call llnull, so null model is attached, side effect of cached attribute</span>
        <span class="s1">self.res1.llnull</span>
        <span class="s3"># check model instead of value</span>
        <span class="s1">exog_null = self.res1.res_null.model.exog</span>
        <span class="s1">exog_infl_null = self.res1.res_null.model.exog_infl</span>
        <span class="s1">assert_array_equal(exog_infl_null.shape</span><span class="s0">,</span>
                     <span class="s1">(len(self.res1.model.exog)</span><span class="s0">, </span><span class="s2">1</span><span class="s1">))</span>
        <span class="s1">assert_equal(np.ptp(exog_null)</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">assert_equal(np.ptp(exog_infl_null)</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.smoke</span>
    <span class="s0">def </span><span class="s1">test_summary(self):</span>
        <span class="s1">summ = self.res1.summary()</span>
        <span class="s3"># GH 4581</span>
        <span class="s0">assert </span><span class="s4">'Covariance Type:' </span><span class="s0">in </span><span class="s1">str(summ)</span>

<span class="s0">class </span><span class="s1">TestZeroInflatedModel_logit(CheckGeneric):</span>
    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">data = sm.datasets.randhie.load()</span>
        <span class="s1">cls.endog = np.asarray(data.endog)</span>
        <span class="s1">data.exog = np.asarray(data.exog)</span>
        <span class="s1">exog = sm.add_constant(data.exog[:</span><span class="s0">,</span><span class="s2">1</span><span class="s1">:</span><span class="s2">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">prepend=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">exog_infl = sm.add_constant(data.exog[:</span><span class="s0">,</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">prepend=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">cls.res1 = sm.ZeroInflatedPoisson(data.endog</span><span class="s0">, </span><span class="s1">exog</span><span class="s0">,</span>
            <span class="s1">exog_infl=exog_infl</span><span class="s0">, </span><span class="s1">inflation=</span><span class="s4">'logit'</span><span class="s1">).fit(method=</span><span class="s4">'newton'</span><span class="s0">, </span><span class="s1">maxiter=</span><span class="s2">500</span><span class="s0">,</span>
                                                        <span class="s1">disp=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s3"># for llnull test</span>
        <span class="s1">cls.res1._results._attach_nullmodel = </span><span class="s0">True</span>
        <span class="s1">cls.init_keys = [</span><span class="s4">'exog_infl'</span><span class="s0">, </span><span class="s4">'exposure'</span><span class="s0">, </span><span class="s4">'inflation'</span><span class="s0">, </span><span class="s4">'offset'</span><span class="s1">]</span>
        <span class="s1">cls.init_kwds = {</span><span class="s4">'inflation'</span><span class="s1">: </span><span class="s4">'logit'</span><span class="s1">}</span>
        <span class="s1">res2 = RandHIE.zero_inflated_poisson_logit</span>
        <span class="s1">cls.res2 = res2</span>

<span class="s0">class </span><span class="s1">TestZeroInflatedModel_probit(CheckGeneric):</span>
    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">data = sm.datasets.randhie.load()</span>
        <span class="s1">cls.endog = np.asarray(data.endog)</span>
        <span class="s1">data.exog = np.asarray(data.exog)</span>
        <span class="s1">exog = sm.add_constant(data.exog[:</span><span class="s0">,</span><span class="s2">1</span><span class="s1">:</span><span class="s2">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">prepend=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">exog_infl = sm.add_constant(data.exog[:</span><span class="s0">,</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">prepend=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">cls.res1 = sm.ZeroInflatedPoisson(data.endog</span><span class="s0">, </span><span class="s1">exog</span><span class="s0">,</span>
            <span class="s1">exog_infl=exog_infl</span><span class="s0">, </span><span class="s1">inflation=</span><span class="s4">'probit'</span><span class="s1">).fit(method=</span><span class="s4">'newton'</span><span class="s0">, </span><span class="s1">maxiter=</span><span class="s2">500</span><span class="s0">,</span>
                                                         <span class="s1">disp=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s3"># for llnull test</span>
        <span class="s1">cls.res1._results._attach_nullmodel = </span><span class="s0">True</span>
        <span class="s1">cls.init_keys = [</span><span class="s4">'exog_infl'</span><span class="s0">, </span><span class="s4">'exposure'</span><span class="s0">, </span><span class="s4">'inflation'</span><span class="s0">, </span><span class="s4">'offset'</span><span class="s1">]</span>
        <span class="s1">cls.init_kwds = {</span><span class="s4">'inflation'</span><span class="s1">: </span><span class="s4">'probit'</span><span class="s1">}</span>
        <span class="s1">res2 = RandHIE.zero_inflated_poisson_probit</span>
        <span class="s1">cls.res2 = res2</span>

    <span class="s1">@pytest.mark.skipif(PLATFORM_LINUX32</span><span class="s0">, </span><span class="s1">reason=</span><span class="s4">&quot;Fails on 32-bit Linux&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_fit_regularized(self):</span>
        <span class="s1">super().test_fit_regularized()</span>

<span class="s0">class </span><span class="s1">TestZeroInflatedModel_offset(CheckGeneric):</span>
    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">data = sm.datasets.randhie.load()</span>
        <span class="s1">cls.endog = np.asarray(data.endog)</span>
        <span class="s1">data.exog = np.asarray(data.exog)</span>
        <span class="s1">exog = sm.add_constant(data.exog[:</span><span class="s0">,</span><span class="s2">1</span><span class="s1">:</span><span class="s2">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">prepend=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">exog_infl = sm.add_constant(data.exog[:</span><span class="s0">,</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">prepend=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">cls.res1 = sm.ZeroInflatedPoisson(data.endog</span><span class="s0">, </span><span class="s1">exog</span><span class="s0">,</span>
            <span class="s1">exog_infl=exog_infl</span><span class="s0">, </span><span class="s1">offset=data.exog[:</span><span class="s0">,</span><span class="s2">7</span><span class="s1">]).fit(method=</span><span class="s4">'newton'</span><span class="s0">,</span>
                                                            <span class="s1">maxiter=</span><span class="s2">500</span><span class="s0">,</span>
                                                            <span class="s1">disp=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s3"># for llnull test</span>
        <span class="s1">cls.res1._results._attach_nullmodel = </span><span class="s0">True</span>
        <span class="s1">cls.init_keys = [</span><span class="s4">'exog_infl'</span><span class="s0">, </span><span class="s4">'exposure'</span><span class="s0">, </span><span class="s4">'inflation'</span><span class="s0">, </span><span class="s4">'offset'</span><span class="s1">]</span>
        <span class="s1">cls.init_kwds = {</span><span class="s4">'inflation'</span><span class="s1">: </span><span class="s4">'logit'</span><span class="s1">}</span>
        <span class="s1">res2 = RandHIE.zero_inflated_poisson_offset</span>
        <span class="s1">cls.res2 = res2</span>

    <span class="s0">def </span><span class="s1">test_exposure(self):</span>
        <span class="s3"># This test mostly the equivalence of offset and exposure = exp(offset)</span>
        <span class="s3"># use data arrays from class model</span>
        <span class="s1">model1 = self.res1.model</span>
        <span class="s1">offset = model1.offset</span>
        <span class="s1">model3 = sm.ZeroInflatedPoisson(model1.endog</span><span class="s0">, </span><span class="s1">model1.exog</span><span class="s0">,</span>
            <span class="s1">exog_infl=model1.exog_infl</span><span class="s0">, </span><span class="s1">exposure=np.exp(offset))</span>
        <span class="s1">res3 = model3.fit(start_params=self.res1.params</span><span class="s0">,</span>
                          <span class="s1">method=</span><span class="s4">'newton'</span><span class="s0">, </span><span class="s1">maxiter=</span><span class="s2">500</span><span class="s0">, </span><span class="s1">disp=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s1">assert_allclose(res3.params</span><span class="s0">, </span><span class="s1">self.res1.params</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-6</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-6</span><span class="s1">)</span>
        <span class="s1">fitted1 = self.res1.predict()</span>
        <span class="s1">fitted3 = res3.predict()</span>
        <span class="s1">assert_allclose(fitted3</span><span class="s0">, </span><span class="s1">fitted1</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-6</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-6</span><span class="s1">)</span>

        <span class="s1">ex = model1.exog</span>
        <span class="s1">ex_infl = model1.exog_infl</span>
        <span class="s1">offset = model1.offset</span>
        <span class="s1">fitted1_0 = self.res1.predict(exog=ex</span><span class="s0">, </span><span class="s1">exog_infl=ex_infl</span><span class="s0">,</span>
                                      <span class="s1">offset=offset.tolist())</span>
        <span class="s1">fitted3_0 = res3.predict(exog=ex</span><span class="s0">, </span><span class="s1">exog_infl=ex_infl</span><span class="s0">,</span>
                                 <span class="s1">exposure=np.exp(offset))</span>
        <span class="s1">assert_allclose(fitted3_0</span><span class="s0">, </span><span class="s1">fitted1_0</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-6</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-6</span><span class="s1">)</span>

        <span class="s1">ex = model1.exog[:</span><span class="s2">10</span><span class="s1">:</span><span class="s2">2</span><span class="s1">]</span>
        <span class="s1">ex_infl = model1.exog_infl[:</span><span class="s2">10</span><span class="s1">:</span><span class="s2">2</span><span class="s1">]</span>
        <span class="s1">offset = offset[:</span><span class="s2">10</span><span class="s1">:</span><span class="s2">2</span><span class="s1">]</span>
        <span class="s3"># # TODO: this raises with shape mismatch,</span>
        <span class="s3"># # i.e. uses offset or exposure from model -&gt; fix it or not?</span>
        <span class="s3"># GLM.predict to setting offset and exposure to zero</span>
        <span class="s3"># fitted1_1 = self.res1.predict(exog=ex, exog_infl=ex_infl)</span>
        <span class="s3"># fitted3_1 = res3.predict(exog=ex, exog_infl=ex_infl)</span>
        <span class="s3"># assert_allclose(fitted3_1, fitted1_1, atol=1e-6, rtol=1e-6)</span>

        <span class="s1">fitted1_2 = self.res1.predict(exog=ex</span><span class="s0">, </span><span class="s1">exog_infl=ex_infl</span><span class="s0">,</span>
                                      <span class="s1">offset=offset)</span>
        <span class="s1">fitted3_2 = res3.predict(exog=ex</span><span class="s0">, </span><span class="s1">exog_infl=ex_infl</span><span class="s0">,</span>
                                 <span class="s1">exposure=np.exp(offset))</span>
        <span class="s1">assert_allclose(fitted3_2</span><span class="s0">, </span><span class="s1">fitted1_2</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-6</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-6</span><span class="s1">)</span>
        <span class="s1">assert_allclose(fitted1_2</span><span class="s0">, </span><span class="s1">fitted1[:</span><span class="s2">10</span><span class="s1">:</span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-6</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-6</span><span class="s1">)</span>
        <span class="s1">assert_allclose(fitted3_2</span><span class="s0">, </span><span class="s1">fitted1[:</span><span class="s2">10</span><span class="s1">:</span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-6</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-6</span><span class="s1">)</span>

        <span class="s3"># without specifying offset and exposure</span>
        <span class="s1">fitted1_3 = self.res1.predict(exog=ex</span><span class="s0">, </span><span class="s1">exog_infl=ex_infl)</span>
        <span class="s1">fitted3_3 = res3.predict(exog=ex</span><span class="s0">, </span><span class="s1">exog_infl=ex_infl)</span>
        <span class="s1">assert_allclose(fitted3_3</span><span class="s0">, </span><span class="s1">fitted1_3</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-6</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-6</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestZeroInflatedModelPandas(CheckGeneric):</span>
    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">data = sm.datasets.randhie.load_pandas()</span>
        <span class="s1">cls.endog = data.endog</span>
        <span class="s1">cls.data = data</span>
        <span class="s1">exog = sm.add_constant(data.exog.iloc[:</span><span class="s0">,</span><span class="s2">1</span><span class="s1">:</span><span class="s2">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">prepend=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">exog_infl = sm.add_constant(data.exog.iloc[:</span><span class="s0">,</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">prepend=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s3"># we do not need to verify convergence here</span>
        <span class="s1">start_params = np.asarray([</span><span class="s2">0.10337834587498942</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1.0459825102508549</span><span class="s0">,</span>
                                   <span class="s1">-</span><span class="s2">0.08219794475894268</span><span class="s0">, </span><span class="s2">0.00856917434709146</span><span class="s0">,</span>
                                   <span class="s1">-</span><span class="s2">0.026795737379474334</span><span class="s0">, </span><span class="s2">1.4823632430107334</span><span class="s1">])</span>
        <span class="s1">model = sm.ZeroInflatedPoisson(data.endog</span><span class="s0">, </span><span class="s1">exog</span><span class="s0">,</span>
            <span class="s1">exog_infl=exog_infl</span><span class="s0">, </span><span class="s1">inflation=</span><span class="s4">'logit'</span><span class="s1">)</span>
        <span class="s1">cls.res1 = model.fit(start_params=start_params</span><span class="s0">, </span><span class="s1">method=</span><span class="s4">'newton'</span><span class="s0">,</span>
                             <span class="s1">maxiter=</span><span class="s2">500</span><span class="s0">, </span><span class="s1">disp=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s3"># for llnull test</span>
        <span class="s1">cls.res1._results._attach_nullmodel = </span><span class="s0">True</span>
        <span class="s1">cls.init_keys = [</span><span class="s4">'exog_infl'</span><span class="s0">, </span><span class="s4">'exposure'</span><span class="s0">, </span><span class="s4">'inflation'</span><span class="s0">, </span><span class="s4">'offset'</span><span class="s1">]</span>
        <span class="s1">cls.init_kwds = {</span><span class="s4">'inflation'</span><span class="s1">: </span><span class="s4">'logit'</span><span class="s1">}</span>
        <span class="s1">res2 = RandHIE.zero_inflated_poisson_logit</span>
        <span class="s1">cls.res2 = res2</span>

    <span class="s0">def </span><span class="s1">test_names(self):</span>
        <span class="s1">param_names = [</span><span class="s4">'inflate_lncoins'</span><span class="s0">, </span><span class="s4">'inflate_const'</span><span class="s0">, </span><span class="s4">'idp'</span><span class="s0">, </span><span class="s4">'lpi'</span><span class="s0">,</span>
                       <span class="s4">'fmde'</span><span class="s0">, </span><span class="s4">'const'</span><span class="s1">]</span>
        <span class="s1">assert_array_equal(self.res1.model.exog_names</span><span class="s0">, </span><span class="s1">param_names)</span>
        <span class="s1">assert_array_equal(self.res1.params.index.tolist()</span><span class="s0">, </span><span class="s1">param_names)</span>
        <span class="s1">assert_array_equal(self.res1.bse.index.tolist()</span><span class="s0">, </span><span class="s1">param_names)</span>

        <span class="s1">exog = sm.add_constant(self.data.exog.iloc[:</span><span class="s0">,</span><span class="s2">1</span><span class="s1">:</span><span class="s2">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">prepend=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">exog_infl = sm.add_constant(self.data.exog.iloc[:</span><span class="s0">,</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">prepend=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">param_names = [</span><span class="s4">'inflate_const'</span><span class="s0">, </span><span class="s4">'inflate_lncoins'</span><span class="s0">, </span><span class="s4">'const'</span><span class="s0">, </span><span class="s4">'idp'</span><span class="s0">,</span>
                       <span class="s4">'lpi'</span><span class="s0">, </span><span class="s4">'fmde'</span><span class="s1">]</span>
        <span class="s1">model = sm.ZeroInflatedPoisson(self.data.endog</span><span class="s0">, </span><span class="s1">exog</span><span class="s0">,</span>
            <span class="s1">exog_infl=exog_infl</span><span class="s0">, </span><span class="s1">inflation=</span><span class="s4">'logit'</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(model.exog_names</span><span class="s0">, </span><span class="s1">param_names)</span>


<span class="s0">class </span><span class="s1">TestZeroInflatedPoisson_predict:</span>
    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">expected_params = [</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">]</span>
        <span class="s1">np.random.seed(</span><span class="s2">999</span><span class="s1">)</span>
        <span class="s1">nobs = </span><span class="s2">2000</span>
        <span class="s1">exog = np.ones((nobs</span><span class="s0">, </span><span class="s2">2</span><span class="s1">))</span>
        <span class="s1">exog[:nobs//</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">] = </span><span class="s2">2</span>
        <span class="s1">mu_true = exog.dot(expected_params)</span>
        <span class="s1">cls.endog = sm.distributions.zipoisson.rvs(mu_true</span><span class="s0">, </span><span class="s2">0.05</span><span class="s0">,</span>
                                                   <span class="s1">size=mu_true.shape)</span>
        <span class="s1">model = sm.ZeroInflatedPoisson(cls.endog</span><span class="s0">, </span><span class="s1">exog)</span>
        <span class="s1">cls.res = model.fit(method=</span><span class="s4">'bfgs'</span><span class="s0">, </span><span class="s1">maxiter=</span><span class="s2">5000</span><span class="s0">, </span><span class="s1">disp=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s1">cls.params_true = [mu_true</span><span class="s0">,  </span><span class="s2">0.05</span><span class="s0">, </span><span class="s1">nobs]</span>

    <span class="s0">def </span><span class="s1">test_mean(self):</span>
        <span class="s0">def </span><span class="s1">compute_conf_interval_95(mu</span><span class="s0">, </span><span class="s1">prob_infl</span><span class="s0">, </span><span class="s1">nobs):</span>
            <span class="s1">dispersion_factor = </span><span class="s2">1 </span><span class="s1">+ prob_infl * mu</span>

            <span class="s3"># scalar variance of the mixture of zip</span>
            <span class="s1">var = (dispersion_factor*(</span><span class="s2">1</span><span class="s1">-prob_infl)*mu).mean()</span>
            <span class="s1">var += (((</span><span class="s2">1</span><span class="s1">-prob_infl)*mu)**</span><span class="s2">2</span><span class="s1">).mean()</span>
            <span class="s1">var -= (((</span><span class="s2">1</span><span class="s1">-prob_infl)*mu).mean())**</span><span class="s2">2</span>
            <span class="s1">std = np.sqrt(var)</span>
            <span class="s3"># Central limit theorem</span>
            <span class="s1">conf_intv_95 = </span><span class="s2">2 </span><span class="s1">* std / np.sqrt(nobs)</span>
            <span class="s0">return </span><span class="s1">conf_intv_95</span>

        <span class="s1">conf_interval_95 = compute_conf_interval_95(*self.params_true)</span>
        <span class="s1">assert_allclose(self.res.predict().mean()</span><span class="s0">, </span><span class="s1">self.endog.mean()</span><span class="s0">,</span>
                        <span class="s1">atol=conf_interval_95</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_var(self):</span>
        <span class="s0">def </span><span class="s1">compute_mixture_var(dispersion_factor</span><span class="s0">, </span><span class="s1">prob_main</span><span class="s0">, </span><span class="s1">mu):</span>
            <span class="s3"># the variance of the mixture is the mixture of the variances plus</span>
            <span class="s3"># a non-negative term accounting for the (weighted)</span>
            <span class="s3"># dispersion of the means, see stats.stackexchange #16609 and</span>
            <span class="s3">#  Casella &amp; Berger's Statistical Inference (Example 10.2.1)</span>
            <span class="s1">prob_infl = </span><span class="s2">1</span><span class="s1">-prob_main</span>
            <span class="s1">var = (dispersion_factor*(</span><span class="s2">1</span><span class="s1">-prob_infl)*mu).mean()</span>
            <span class="s1">var += (((</span><span class="s2">1</span><span class="s1">-prob_infl)*mu)**</span><span class="s2">2</span><span class="s1">).mean()</span>
            <span class="s1">var -= (((</span><span class="s2">1</span><span class="s1">-prob_infl)*mu).mean())**</span><span class="s2">2</span>
            <span class="s0">return </span><span class="s1">var</span>

        <span class="s1">res = self.res</span>
        <span class="s1">var_fitted = compute_mixture_var(res._dispersion_factor</span><span class="s0">,</span>
                                         <span class="s1">res.predict(which=</span><span class="s4">'prob-main'</span><span class="s1">)</span><span class="s0">,</span>
                                         <span class="s1">res.predict(which=</span><span class="s4">'mean-main'</span><span class="s1">))</span>

        <span class="s1">assert_allclose(var_fitted.mean()</span><span class="s0">,</span>
                        <span class="s1">self.endog.var()</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">5e-2</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">5e-2</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_predict_prob(self):</span>
        <span class="s1">res = self.res</span>

        <span class="s1">pr = res.predict(which=</span><span class="s4">'prob'</span><span class="s1">)</span>
        <span class="s1">pr2 = sm.distributions.zipoisson.pmf(np.arange(pr.shape[</span><span class="s2">1</span><span class="s1">])[:</span><span class="s0">, None</span><span class="s1">]</span><span class="s0">,</span>
                                             <span class="s1">res.predict()</span><span class="s0">, </span><span class="s2">0.05</span><span class="s1">).T</span>
        <span class="s1">assert_allclose(pr</span><span class="s0">, </span><span class="s1">pr2</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">0.05</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">0.05</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_predict_options(self):</span>
        <span class="s3"># check default exog_infl, see #4757</span>
        <span class="s1">res = self.res</span>
        <span class="s1">n = </span><span class="s2">5</span>
        <span class="s1">pr1 = res.predict(which=</span><span class="s4">'prob'</span><span class="s1">)</span>
        <span class="s1">pr0 = res.predict(exog=res.model.exog[:n]</span><span class="s0">, </span><span class="s1">which=</span><span class="s4">'prob'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(pr0</span><span class="s0">, </span><span class="s1">pr1[:n]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-10</span><span class="s1">)</span>

        <span class="s1">fitted1 = res.predict()</span>
        <span class="s1">fitted0 = res.predict(exog=res.model.exog[:n])</span>
        <span class="s1">assert_allclose(fitted0</span><span class="s0">, </span><span class="s1">fitted1[:n]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-10</span><span class="s1">)</span>


<span class="s1">@pytest.mark.slow</span>
<span class="s0">class </span><span class="s1">TestZeroInflatedGeneralizedPoisson(CheckGeneric):</span>
    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">data = sm.datasets.randhie.load()</span>
        <span class="s1">cls.endog = np.asarray(data.endog)</span>
        <span class="s1">data.exog = np.asarray(data.exog)</span>
        <span class="s1">exog = sm.add_constant(data.exog[:</span><span class="s0">,</span><span class="s2">1</span><span class="s1">:</span><span class="s2">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">prepend=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">exog_infl = sm.add_constant(data.exog[:</span><span class="s0">,</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">prepend=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">cls.res1 = sm.ZeroInflatedGeneralizedPoisson(data.endog</span><span class="s0">, </span><span class="s1">exog</span><span class="s0">,</span>
            <span class="s1">exog_infl=exog_infl</span><span class="s0">, </span><span class="s1">p=</span><span class="s2">1</span><span class="s1">).fit(method=</span><span class="s4">'newton'</span><span class="s0">, </span><span class="s1">maxiter=</span><span class="s2">500</span><span class="s0">, </span><span class="s1">disp=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s3"># for llnull test</span>
        <span class="s1">cls.res1._results._attach_nullmodel = </span><span class="s0">True</span>
        <span class="s1">cls.init_keys = [</span><span class="s4">'exog_infl'</span><span class="s0">, </span><span class="s4">'exposure'</span><span class="s0">, </span><span class="s4">'inflation'</span><span class="s0">, </span><span class="s4">'offset'</span><span class="s0">, </span><span class="s4">'p'</span><span class="s1">]</span>
        <span class="s1">cls.init_kwds = {</span><span class="s4">'inflation'</span><span class="s1">: </span><span class="s4">'logit'</span><span class="s0">, </span><span class="s4">'p'</span><span class="s1">: </span><span class="s2">1</span><span class="s1">}</span>
        <span class="s1">res2 = RandHIE.zero_inflated_generalized_poisson</span>
        <span class="s1">cls.res2 = res2</span>

    <span class="s0">def </span><span class="s1">test_bse(self):</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">test_conf_int(self):</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">test_bic(self):</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">test_t(self):</span>
        <span class="s1">unit_matrix = np.identity(self.res1.params.size)</span>
        <span class="s1">t_test = self.res1.t_test(unit_matrix)</span>
        <span class="s1">assert_allclose(self.res1.tvalues</span><span class="s0">, </span><span class="s1">t_test.tvalue)</span>

    <span class="s0">def </span><span class="s1">test_minimize(self</span><span class="s0">, </span><span class="s1">reset_randomstate):</span>
        <span class="s3"># check additional optimizers using the `minimize` option</span>
        <span class="s1">model = self.res1.model</span>
        <span class="s3"># use the same start_params, but avoid recomputing</span>
        <span class="s1">start_params = self.res1.mle_settings[</span><span class="s4">'start_params'</span><span class="s1">]</span>

        <span class="s1">res_ncg = model.fit(start_params=start_params</span><span class="s0">,</span>
                            <span class="s1">method=</span><span class="s4">'minimize'</span><span class="s0">, </span><span class="s1">min_method=</span><span class="s4">&quot;trust-ncg&quot;</span><span class="s0">,</span>
                            <span class="s1">maxiter=</span><span class="s2">500</span><span class="s0">, </span><span class="s1">disp=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s1">assert_allclose(res_ncg.params</span><span class="s0">, </span><span class="s1">self.res2.params</span><span class="s0">,</span>
                        <span class="s1">atol=</span><span class="s2">1e-3</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">0.04</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res_ncg.bse</span><span class="s0">, </span><span class="s1">self.res2.bse</span><span class="s0">,</span>
                        <span class="s1">atol=</span><span class="s2">1e-3</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">0.6</span><span class="s1">)</span>
        <span class="s1">assert_(res_ncg.mle_retvals[</span><span class="s4">'converged'</span><span class="s1">] </span><span class="s0">is True</span><span class="s1">)</span>

        <span class="s1">res_dog = model.fit(start_params=start_params</span><span class="s0">,</span>
                            <span class="s1">method=</span><span class="s4">'minimize'</span><span class="s0">, </span><span class="s1">min_method=</span><span class="s4">&quot;dogleg&quot;</span><span class="s0">,</span>
                            <span class="s1">maxiter=</span><span class="s2">500</span><span class="s0">, </span><span class="s1">disp=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s1">assert_allclose(res_dog.params</span><span class="s0">, </span><span class="s1">self.res2.params</span><span class="s0">,</span>
                        <span class="s1">atol=</span><span class="s2">1e-3</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">3e-3</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res_dog.bse</span><span class="s0">, </span><span class="s1">self.res2.bse</span><span class="s0">,</span>
                        <span class="s1">atol=</span><span class="s2">1e-3</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">0.6</span><span class="s1">)</span>
        <span class="s1">assert_(res_dog.mle_retvals[</span><span class="s4">'converged'</span><span class="s1">] </span><span class="s0">is True</span><span class="s1">)</span>

        <span class="s3"># Ser random_state here to improve reproducibility</span>
        <span class="s1">random_state = np.random.RandomState(</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s1">seed = {</span><span class="s4">'seed'</span><span class="s1">: random_state}</span>
        <span class="s1">res_bh = model.fit(start_params=start_params</span><span class="s0">,</span>
                           <span class="s1">method=</span><span class="s4">'basinhopping'</span><span class="s0">, </span><span class="s1">niter=</span><span class="s2">500</span><span class="s0">, </span><span class="s1">stepsize=</span><span class="s2">0.1</span><span class="s0">,</span>
                           <span class="s1">niter_success=</span><span class="s0">None, </span><span class="s1">disp=</span><span class="s0">False, </span><span class="s1">interval=</span><span class="s2">1</span><span class="s0">, </span><span class="s1">**seed)</span>

        <span class="s1">assert_allclose(res_bh.params</span><span class="s0">, </span><span class="s1">self.res2.params</span><span class="s0">,</span>
                        <span class="s1">atol=</span><span class="s2">1e-4</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-4</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res_bh.bse</span><span class="s0">, </span><span class="s1">self.res2.bse</span><span class="s0">,</span>
                        <span class="s1">atol=</span><span class="s2">1e-3</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">0.6</span><span class="s1">)</span>
        <span class="s3"># skip, res_bh reports converged is false but params agree</span>
        <span class="s3">#assert_(res_bh.mle_retvals['converged'] is True)</span>

<span class="s0">class </span><span class="s1">TestZeroInflatedGeneralizedPoisson_predict:</span>
    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">expected_params = [</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">]</span>
        <span class="s1">np.random.seed(</span><span class="s2">999</span><span class="s1">)</span>
        <span class="s1">nobs = </span><span class="s2">2000</span>
        <span class="s1">exog = np.ones((nobs</span><span class="s0">, </span><span class="s2">2</span><span class="s1">))</span>
        <span class="s1">exog[:nobs//</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">] = </span><span class="s2">2</span>
        <span class="s1">mu_true = exog.dot(expected_params[:-</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">cls.endog = sm.distributions.zigenpoisson.rvs(mu_true</span><span class="s0">, </span><span class="s1">expected_params[-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
                                                      <span class="s2">2</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s1">size=mu_true.shape)</span>
        <span class="s1">model = sm.ZeroInflatedGeneralizedPoisson(cls.endog</span><span class="s0">, </span><span class="s1">exog</span><span class="s0">, </span><span class="s1">p=</span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">cls.res = model.fit(method=</span><span class="s4">'bfgs'</span><span class="s0">, </span><span class="s1">maxiter=</span><span class="s2">5000</span><span class="s0">, </span><span class="s1">disp=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s1">cls.params_true = [mu_true</span><span class="s0">, </span><span class="s1">expected_params[-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s2">2</span><span class="s0">,  </span><span class="s2">0.5</span><span class="s0">, </span><span class="s1">nobs]</span>

    <span class="s0">def </span><span class="s1">test_mean(self):</span>
        <span class="s0">def </span><span class="s1">compute_conf_interval_95(mu</span><span class="s0">, </span><span class="s1">alpha</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">prob_infl</span><span class="s0">, </span><span class="s1">nobs):</span>
            <span class="s1">p = p-</span><span class="s2">1</span>
            <span class="s1">dispersion_factor = (</span><span class="s2">1 </span><span class="s1">+ alpha * mu**p)**</span><span class="s2">2 </span><span class="s1">+ prob_infl * mu</span>

            <span class="s3"># scalar variance of the mixture of zip</span>
            <span class="s1">var = (dispersion_factor*(</span><span class="s2">1</span><span class="s1">-prob_infl)*mu).mean()</span>
            <span class="s1">var += (((</span><span class="s2">1</span><span class="s1">-prob_infl)*mu)**</span><span class="s2">2</span><span class="s1">).mean()</span>
            <span class="s1">var -= (((</span><span class="s2">1</span><span class="s1">-prob_infl)*mu).mean())**</span><span class="s2">2</span>
            <span class="s1">std = np.sqrt(var)</span>
            <span class="s3"># Central limit theorem</span>
            <span class="s1">conf_intv_95 = </span><span class="s2">2 </span><span class="s1">* std / np.sqrt(nobs)</span>
            <span class="s0">return </span><span class="s1">conf_intv_95</span>

        <span class="s1">conf_interval_95 = compute_conf_interval_95(*self.params_true)</span>
        <span class="s1">assert_allclose(self.res.predict().mean()</span><span class="s0">, </span><span class="s1">self.endog.mean()</span><span class="s0">,</span>
                        <span class="s1">atol=conf_interval_95</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_var(self):</span>
        <span class="s0">def </span><span class="s1">compute_mixture_var(dispersion_factor</span><span class="s0">, </span><span class="s1">prob_main</span><span class="s0">, </span><span class="s1">mu):</span>
            <span class="s1">prob_infl = </span><span class="s2">1</span><span class="s1">-prob_main</span>
            <span class="s1">var = (dispersion_factor*(</span><span class="s2">1</span><span class="s1">-prob_infl)*mu).mean()</span>
            <span class="s1">var += (((</span><span class="s2">1</span><span class="s1">-prob_infl)*mu)**</span><span class="s2">2</span><span class="s1">).mean()</span>
            <span class="s1">var -= (((</span><span class="s2">1</span><span class="s1">-prob_infl)*mu).mean())**</span><span class="s2">2</span>
            <span class="s0">return </span><span class="s1">var</span>

        <span class="s1">res = self.res</span>
        <span class="s1">var_fitted = compute_mixture_var(res._dispersion_factor</span><span class="s0">,</span>
                                         <span class="s1">res.predict(which=</span><span class="s4">'prob-main'</span><span class="s1">)</span><span class="s0">,</span>
                                         <span class="s1">res.predict(which=</span><span class="s4">'mean-main'</span><span class="s1">))</span>

        <span class="s1">assert_allclose(var_fitted.mean()</span><span class="s0">,</span>
                        <span class="s1">self.endog.var()</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">0.05</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">0.1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_predict_prob(self):</span>
        <span class="s1">res = self.res</span>

        <span class="s1">pr = res.predict(which=</span><span class="s4">'prob'</span><span class="s1">)</span>
        <span class="s1">pr2 = sm.distributions.zinegbin.pmf(np.arange(pr.shape[</span><span class="s2">1</span><span class="s1">])[:</span><span class="s0">, None</span><span class="s1">]</span><span class="s0">,</span>
                                            <span class="s1">res.predict()</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">).T</span>
        <span class="s1">assert_allclose(pr</span><span class="s0">, </span><span class="s1">pr2</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">0.08</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">0.05</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestZeroInflatedNegativeBinomialP(CheckGeneric):</span>
    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">data = sm.datasets.randhie.load()</span>
        <span class="s1">cls.endog = np.asarray(data.endog)</span>
        <span class="s1">data.exog = np.asarray(data.exog)</span>
        <span class="s1">exog = sm.add_constant(data.exog[:</span><span class="s0">,</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">prepend=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">exog_infl = sm.add_constant(data.exog[:</span><span class="s0">,</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">prepend=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s3"># cheating for now, parameters are not well identified in this dataset</span>
        <span class="s3"># see https://github.com/statsmodels/statsmodels/pull/3928#issuecomment-331724022</span>
        <span class="s1">sp = np.array([</span><span class="s2">1.88</span><span class="s0">, </span><span class="s1">-</span><span class="s2">10.28</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.20</span><span class="s0">, </span><span class="s2">1.14</span><span class="s0">, </span><span class="s2">1.34</span><span class="s1">])</span>
        <span class="s1">cls.res1 = sm.ZeroInflatedNegativeBinomialP(data.endog</span><span class="s0">, </span><span class="s1">exog</span><span class="s0">,</span>
            <span class="s1">exog_infl=exog_infl</span><span class="s0">, </span><span class="s1">p=</span><span class="s2">2</span><span class="s1">).fit(start_params=sp</span><span class="s0">, </span><span class="s1">method=</span><span class="s4">'nm'</span><span class="s0">,</span>
                                          <span class="s1">xtol=</span><span class="s2">1e-6</span><span class="s0">, </span><span class="s1">maxiter=</span><span class="s2">5000</span><span class="s0">, </span><span class="s1">disp=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s3"># for llnull test</span>
        <span class="s1">cls.res1._results._attach_nullmodel = </span><span class="s0">True</span>
        <span class="s1">cls.init_keys = [</span><span class="s4">'exog_infl'</span><span class="s0">, </span><span class="s4">'exposure'</span><span class="s0">, </span><span class="s4">'inflation'</span><span class="s0">, </span><span class="s4">'offset'</span><span class="s0">, </span><span class="s4">'p'</span><span class="s1">]</span>
        <span class="s1">cls.init_kwds = {</span><span class="s4">'inflation'</span><span class="s1">: </span><span class="s4">'logit'</span><span class="s0">, </span><span class="s4">'p'</span><span class="s1">: </span><span class="s2">2</span><span class="s1">}</span>
        <span class="s1">res2 = RandHIE.zero_inflated_negative_binomial</span>
        <span class="s1">cls.res2 = res2</span>

    <span class="s0">def </span><span class="s1">test_params(self):</span>
        <span class="s1">assert_allclose(self.res1.params</span><span class="s0">, </span><span class="s1">self.res2.params</span><span class="s0">,</span>
                        <span class="s1">atol=</span><span class="s2">1e-3</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-3</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_conf_int(self):</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">test_bic(self):</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">test_fit_regularized(self):</span>
        <span class="s1">model = self.res1.model</span>

        <span class="s1">alpha = np.ones(len(self.res1.params))</span>
        <span class="s1">alpha[-</span><span class="s2">2</span><span class="s1">:] = </span><span class="s2">0</span>
        <span class="s1">res_reg = model.fit_regularized(alpha=alpha*</span><span class="s2">0.01</span><span class="s0">, </span><span class="s1">disp=</span><span class="s0">False, </span><span class="s1">maxiter=</span><span class="s2">500</span><span class="s1">)</span>

        <span class="s1">assert_allclose(res_reg.params[</span><span class="s2">2</span><span class="s1">:]</span><span class="s0">, </span><span class="s1">self.res1.params[</span><span class="s2">2</span><span class="s1">:]</span><span class="s0">,</span>
            <span class="s1">atol=</span><span class="s2">1e-1</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-1</span><span class="s1">)</span>

    <span class="s3"># possibly slow, adds 25 seconds</span>
    <span class="s0">def </span><span class="s1">test_minimize(self</span><span class="s0">, </span><span class="s1">reset_randomstate):</span>
        <span class="s3"># check additional optimizers using the `minimize` option</span>
        <span class="s1">model = self.res1.model</span>
        <span class="s3"># use the same start_params, but avoid recomputing</span>
        <span class="s1">start_params = self.res1.mle_settings[</span><span class="s4">'start_params'</span><span class="s1">]</span>

        <span class="s1">res_ncg = model.fit(start_params=start_params</span><span class="s0">,</span>
                            <span class="s1">method=</span><span class="s4">'minimize'</span><span class="s0">, </span><span class="s1">min_method=</span><span class="s4">&quot;trust-ncg&quot;</span><span class="s0">,</span>
                            <span class="s1">maxiter=</span><span class="s2">500</span><span class="s0">, </span><span class="s1">disp=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s1">assert_allclose(res_ncg.params</span><span class="s0">, </span><span class="s1">self.res2.params</span><span class="s0">,</span>
                        <span class="s1">atol=</span><span class="s2">1e-3</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">0.03</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res_ncg.bse</span><span class="s0">, </span><span class="s1">self.res2.bse</span><span class="s0">,</span>
                        <span class="s1">atol=</span><span class="s2">1e-3</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">0.06</span><span class="s1">)</span>
        <span class="s1">assert_(res_ncg.mle_retvals[</span><span class="s4">'converged'</span><span class="s1">] </span><span class="s0">is True</span><span class="s1">)</span>

        <span class="s1">res_dog = model.fit(start_params=start_params</span><span class="s0">,</span>
                            <span class="s1">method=</span><span class="s4">'minimize'</span><span class="s0">, </span><span class="s1">min_method=</span><span class="s4">&quot;dogleg&quot;</span><span class="s0">,</span>
                            <span class="s1">maxiter=</span><span class="s2">500</span><span class="s0">, </span><span class="s1">disp=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s1">assert_allclose(res_dog.params</span><span class="s0">, </span><span class="s1">self.res2.params</span><span class="s0">,</span>
                        <span class="s1">atol=</span><span class="s2">1e-3</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">3e-3</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res_dog.bse</span><span class="s0">, </span><span class="s1">self.res2.bse</span><span class="s0">,</span>
                        <span class="s1">atol=</span><span class="s2">1e-3</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">7e-3</span><span class="s1">)</span>
        <span class="s1">assert_(res_dog.mle_retvals[</span><span class="s4">'converged'</span><span class="s1">] </span><span class="s0">is True</span><span class="s1">)</span>

        <span class="s1">res_bh = model.fit(start_params=start_params</span><span class="s0">,</span>
                           <span class="s1">method=</span><span class="s4">'basinhopping'</span><span class="s0">, </span><span class="s1">maxiter=</span><span class="s2">500</span><span class="s0">,</span>
                           <span class="s1">niter_success=</span><span class="s2">3</span><span class="s0">, </span><span class="s1">disp=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s1">assert_allclose(res_bh.params</span><span class="s0">, </span><span class="s1">self.res2.params</span><span class="s0">,</span>
                        <span class="s1">atol=</span><span class="s2">1e-4</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">3e-4</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res_bh.bse</span><span class="s0">, </span><span class="s1">self.res2.bse</span><span class="s0">,</span>
                        <span class="s1">atol=</span><span class="s2">1e-3</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-3</span><span class="s1">)</span>
        <span class="s3"># skip, res_bh reports converged is false but params agree</span>
        <span class="s3">#assert_(res_bh.mle_retvals['converged'] is True)</span>


<span class="s0">class </span><span class="s1">TestZeroInflatedNegativeBinomialP_predict:</span>
    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">setup_class(cls):</span>

        <span class="s1">expected_params = [</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0.5</span><span class="s1">]</span>
        <span class="s1">np.random.seed(</span><span class="s2">999</span><span class="s1">)</span>
        <span class="s1">nobs = </span><span class="s2">5000</span>
        <span class="s1">exog = np.ones((nobs</span><span class="s0">, </span><span class="s2">2</span><span class="s1">))</span>
        <span class="s1">exog[:nobs//</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">] = </span><span class="s2">0</span>

        <span class="s1">prob_infl = </span><span class="s2">0.15</span>
        <span class="s1">mu_true = np.exp(exog.dot(expected_params[:-</span><span class="s2">1</span><span class="s1">]))</span>
        <span class="s1">cls.endog = sm.distributions.zinegbin.rvs(mu_true</span><span class="s0">,</span>
                    <span class="s1">expected_params[-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s1">prob_infl</span><span class="s0">, </span><span class="s1">size=mu_true.shape)</span>
        <span class="s1">model = sm.ZeroInflatedNegativeBinomialP(cls.endog</span><span class="s0">, </span><span class="s1">exog</span><span class="s0">, </span><span class="s1">p=</span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">cls.res = model.fit(method=</span><span class="s4">'bfgs'</span><span class="s0">, </span><span class="s1">maxiter=</span><span class="s2">5000</span><span class="s0">, </span><span class="s1">disp=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s3"># attach others</span>
        <span class="s1">cls.prob_infl = prob_infl</span>
        <span class="s1">cls.params_true = [mu_true</span><span class="s0">, </span><span class="s1">expected_params[-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s2">2</span><span class="s0">,  </span><span class="s1">prob_infl</span><span class="s0">, </span><span class="s1">nobs]</span>

    <span class="s0">def </span><span class="s1">test_mean(self):</span>
        <span class="s0">def </span><span class="s1">compute_conf_interval_95(mu</span><span class="s0">, </span><span class="s1">alpha</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">prob_infl</span><span class="s0">, </span><span class="s1">nobs):</span>
            <span class="s1">dispersion_factor = </span><span class="s2">1 </span><span class="s1">+ alpha * mu**(p-</span><span class="s2">1</span><span class="s1">) + prob_infl * mu</span>

            <span class="s3"># scalar variance of the mixture of zip</span>
            <span class="s1">var = (dispersion_factor*(</span><span class="s2">1</span><span class="s1">-prob_infl)*mu).mean()</span>
            <span class="s1">var += (((</span><span class="s2">1</span><span class="s1">-prob_infl)*mu)**</span><span class="s2">2</span><span class="s1">).mean()</span>
            <span class="s1">var -= (((</span><span class="s2">1</span><span class="s1">-prob_infl)*mu).mean())**</span><span class="s2">2</span>
            <span class="s1">std = np.sqrt(var)</span>
            <span class="s3"># Central limit theorem</span>
            <span class="s1">conf_intv_95 = </span><span class="s2">2 </span><span class="s1">* std / np.sqrt(nobs)</span>
            <span class="s0">return </span><span class="s1">conf_intv_95</span>

        <span class="s1">conf_interval_95 = compute_conf_interval_95(*self.params_true)</span>
        <span class="s1">mean_true = ((</span><span class="s2">1</span><span class="s1">-self.prob_infl)*self.params_true[</span><span class="s2">0</span><span class="s1">]).mean()</span>
        <span class="s1">assert_allclose(self.res.predict().mean()</span><span class="s0">,</span>
                        <span class="s1">mean_true</span><span class="s0">, </span><span class="s1">atol=conf_interval_95</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_var(self):</span>
        <span class="s3"># todo check precision</span>
        <span class="s0">def </span><span class="s1">compute_mixture_var(dispersion_factor</span><span class="s0">, </span><span class="s1">prob_main</span><span class="s0">, </span><span class="s1">mu):</span>
            <span class="s1">prob_infl = </span><span class="s2">1 </span><span class="s1">- prob_main</span>
            <span class="s1">var = (dispersion_factor * (</span><span class="s2">1 </span><span class="s1">- prob_infl) * mu).mean()</span>
            <span class="s1">var += (((</span><span class="s2">1 </span><span class="s1">- prob_infl) * mu) ** </span><span class="s2">2</span><span class="s1">).mean()</span>
            <span class="s1">var -= (((</span><span class="s2">1 </span><span class="s1">- prob_infl) * mu).mean()) ** </span><span class="s2">2</span>
            <span class="s0">return </span><span class="s1">var</span>

        <span class="s1">res = self.res</span>
        <span class="s1">var_fitted = compute_mixture_var(res._dispersion_factor</span><span class="s0">,</span>
                                         <span class="s1">res.predict(which=</span><span class="s4">'prob-main'</span><span class="s1">)</span><span class="s0">,</span>
                                         <span class="s1">res.predict(which=</span><span class="s4">'mean-main'</span><span class="s1">))</span>

        <span class="s1">assert_allclose(var_fitted.mean()</span><span class="s0">,</span>
                        <span class="s1">self.endog.var()</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">0.2</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_predict_prob(self):</span>
        <span class="s1">res = self.res</span>
        <span class="s1">endog = res.model.endog</span>

        <span class="s1">pr = res.predict(which=</span><span class="s4">'prob'</span><span class="s1">)</span>
        <span class="s1">pr2 = sm.distributions.zinegbin.pmf(np.arange(pr.shape[</span><span class="s2">1</span><span class="s1">])[:</span><span class="s0">,None</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">res.predict()</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s1">self.prob_infl).T</span>
        <span class="s1">assert_allclose(pr</span><span class="s0">, </span><span class="s1">pr2</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">0.1</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">0.1</span><span class="s1">)</span>
        <span class="s1">prm = pr.mean(</span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">pr2m = pr2.mean(</span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">freq = np.bincount(endog.astype(int)) / len(endog)</span>
        <span class="s1">assert_allclose(((pr2m - prm)**</span><span class="s2">2</span><span class="s1">).mean()</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-10</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">5e-4</span><span class="s1">)</span>
        <span class="s1">assert_allclose(((prm - freq)**</span><span class="s2">2</span><span class="s1">).mean()</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-10</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-4</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_predict_generic_zi(self):</span>
        <span class="s3"># These tests do not use numbers from other packages.</span>
        <span class="s3"># Tests are on closeness of estimated to true/DGP values</span>
        <span class="s3"># and theoretical relationship between quantities</span>
        <span class="s1">res = self.res</span>
        <span class="s1">endog = self.endog</span>
        <span class="s1">exog = self.res.model.exog</span>
        <span class="s1">prob_infl = self.prob_infl</span>
        <span class="s1">nobs = len(endog)</span>

        <span class="s1">freq = np.bincount(endog.astype(int)) / len(endog)</span>
        <span class="s1">probs = res.predict(which=</span><span class="s4">'prob'</span><span class="s1">)</span>
        <span class="s1">probsm = probs.mean(</span><span class="s2">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(freq</span><span class="s0">, </span><span class="s1">probsm</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">0.02</span><span class="s1">)</span>

        <span class="s1">probs_unique = res.predict(exog=[[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]]</span><span class="s0">,</span>
                                   <span class="s1">exog_infl=np.asarray([[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]])</span><span class="s0">,</span>
                                   <span class="s1">which=</span><span class="s4">'prob'</span><span class="s1">)</span>
        <span class="s3"># no default for exog_infl yet</span>
        <span class="s3">#probs_unique = res.predict(exog=[[1, 0], [1, 1]], which='prob')</span>

        <span class="s1">probs_unique2 = probs[[</span><span class="s2">1</span><span class="s0">, </span><span class="s1">nobs-</span><span class="s2">1</span><span class="s1">]]</span>

        <span class="s1">assert_allclose(probs_unique</span><span class="s0">, </span><span class="s1">probs_unique2</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-10</span><span class="s1">)</span>

        <span class="s1">probs0_unique = res.predict(exog=[[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]]</span><span class="s0">,</span>
                                    <span class="s1">exog_infl=np.asarray([[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]])</span><span class="s0">,</span>
                                    <span class="s1">which=</span><span class="s4">'prob-zero'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(probs0_unique</span><span class="s0">, </span><span class="s1">probs_unique2[:</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-10</span><span class="s1">)</span>

        <span class="s1">probs_main_unique = res.predict(exog=[[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]]</span><span class="s0">,</span>
                                        <span class="s1">exog_infl=np.asarray([[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]])</span><span class="s0">,</span>
                                        <span class="s1">which=</span><span class="s4">'prob-main'</span><span class="s1">)</span>
        <span class="s1">probs_main = res.predict(which=</span><span class="s4">'prob-main'</span><span class="s1">)</span>
        <span class="s1">probs_main[[</span><span class="s2">0</span><span class="s0">,</span><span class="s1">-</span><span class="s2">1</span><span class="s1">]]</span>
        <span class="s1">assert_allclose(probs_main_unique</span><span class="s0">, </span><span class="s1">probs_main[[</span><span class="s2">0</span><span class="s0">,</span><span class="s1">-</span><span class="s2">1</span><span class="s1">]]</span><span class="s0">,  </span><span class="s1">rtol=</span><span class="s2">1e-10</span><span class="s1">)</span>
        <span class="s1">assert_allclose(probs_main_unique</span><span class="s0">, </span><span class="s2">1 </span><span class="s1">- prob_infl</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">0.01</span><span class="s1">)</span>

        <span class="s1">pred = res.predict(exog=[[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]]</span><span class="s0">,</span>
                           <span class="s1">exog_infl=np.asarray([[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]]))</span>
        <span class="s1">pred1 = endog[exog[:</span><span class="s0">, </span><span class="s2">1</span><span class="s1">] == </span><span class="s2">0</span><span class="s1">].mean()</span><span class="s0">, </span><span class="s1">endog[exog[:</span><span class="s0">, </span><span class="s2">1</span><span class="s1">] == </span><span class="s2">1</span><span class="s1">].mean()</span>
        <span class="s1">assert_allclose(pred</span><span class="s0">, </span><span class="s1">pred1</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">0.05</span><span class="s1">)</span>

        <span class="s1">pred_main_unique = res.predict(exog=[[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]]</span><span class="s0">,</span>
                                       <span class="s1">exog_infl=np.asarray([[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]])</span><span class="s0">,</span>
                                       <span class="s1">which=</span><span class="s4">'mean-main'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(pred_main_unique</span><span class="s0">, </span><span class="s1">np.exp(np.cumsum(res.params[</span><span class="s2">1</span><span class="s1">:</span><span class="s2">3</span><span class="s1">]))</span><span class="s0">,</span>
                        <span class="s1">rtol=</span><span class="s2">1e-10</span><span class="s1">)</span>

        <span class="s3"># TODO: why does the following fail, params are not close enough to DGP</span>
        <span class="s3"># but results are close statistics of simulated data</span>
        <span class="s3"># what is mu_true in DGP sm.distributions.zinegbin.rvs</span>
        <span class="s3"># assert_allclose(pred_main_unique, mu_true[[1, -1]] * (1 - prob_infl), rtol=0.01)</span>

        <span class="s3"># mean-nonzero</span>
        <span class="s1">mean_nz = (endog[(exog[:</span><span class="s0">, </span><span class="s2">1</span><span class="s1">] == </span><span class="s2">0</span><span class="s1">) &amp; (endog &gt; </span><span class="s2">0</span><span class="s1">)].mean()</span><span class="s0">,</span>
                   <span class="s1">endog[(exog[:</span><span class="s0">, </span><span class="s2">1</span><span class="s1">] == </span><span class="s2">1</span><span class="s1">) &amp; (endog &gt; </span><span class="s2">0</span><span class="s1">)].mean())</span>
        <span class="s1">pred_nonzero_unique = res.predict(exog=[[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]]</span><span class="s0">,</span>
                                          <span class="s1">exog_infl=np.asarray([[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]])</span><span class="s0">, </span><span class="s1">which=</span><span class="s4">'mean-nonzero'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(pred_nonzero_unique</span><span class="s0">, </span><span class="s1">mean_nz</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">0.05</span><span class="s1">)</span>

        <span class="s1">pred_lin_unique = res.predict(exog=[[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]]</span><span class="s0">,</span>
                                      <span class="s1">exog_infl=np.asarray([[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s1">]])</span><span class="s0">,</span>
                                      <span class="s1">which=</span><span class="s4">'linear'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(pred_lin_unique</span><span class="s0">, </span><span class="s1">np.cumsum(res.params[</span><span class="s2">1</span><span class="s1">:</span><span class="s2">3</span><span class="s1">])</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s2">1e-10</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestZeroInflatedNegativeBinomialP_predict2:</span>
    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">data = sm.datasets.randhie.load()</span>

        <span class="s1">cls.endog = np.asarray(data.endog)</span>
        <span class="s1">data.exog = np.asarray(data.exog)</span>
        <span class="s1">exog = data.exog</span>
        <span class="s1">start_params = np.array([</span>
            <span class="s1">-</span><span class="s2">2.83983767</span><span class="s0">, </span><span class="s1">-</span><span class="s2">2.31595924</span><span class="s0">, </span><span class="s1">-</span><span class="s2">3.9263248</span><span class="s0">,  </span><span class="s1">-</span><span class="s2">4.01816431</span><span class="s0">, </span><span class="s1">-</span><span class="s2">5.52251843</span><span class="s0">,</span>
            <span class="s1">-</span><span class="s2">2.4351714</span><span class="s0">,  </span><span class="s1">-</span><span class="s2">4.61636366</span><span class="s0">, </span><span class="s1">-</span><span class="s2">4.17959785</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.12960256</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.05653484</span><span class="s0">,</span>
            <span class="s1">-</span><span class="s2">0.21206673</span><span class="s0">,  </span><span class="s2">0.08782572</span><span class="s0">, </span><span class="s1">-</span><span class="s2">0.02991995</span><span class="s0">,  </span><span class="s2">0.22901208</span><span class="s0">,  </span><span class="s2">0.0620983</span><span class="s0">,</span>
            <span class="s2">0.06809681</span><span class="s0">,  </span><span class="s2">0.0841814</span><span class="s0">,   </span><span class="s2">0.185506</span><span class="s0">,    </span><span class="s2">1.36527888</span><span class="s1">])</span>
        <span class="s1">mod = sm.ZeroInflatedNegativeBinomialP(</span>
            <span class="s1">cls.endog</span><span class="s0">, </span><span class="s1">exog</span><span class="s0">, </span><span class="s1">exog_infl=exog</span><span class="s0">, </span><span class="s1">p=</span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">res = mod.fit(start_params=start_params</span><span class="s0">, </span><span class="s1">method=</span><span class="s4">&quot;bfgs&quot;</span><span class="s0">,</span>
                      <span class="s1">maxiter=</span><span class="s2">1000</span><span class="s0">, </span><span class="s1">disp=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s1">cls.res = res</span>

    <span class="s0">def </span><span class="s1">test_mean(self):</span>
        <span class="s1">assert_allclose(self.res.predict().mean()</span><span class="s0">, </span><span class="s1">self.endog.mean()</span><span class="s0">,</span>
                        <span class="s1">atol=</span><span class="s2">0.02</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_zero_nonzero_mean(self):</span>
        <span class="s1">mean1 = self.endog.mean()</span>
        <span class="s1">mean2 = ((</span><span class="s2">1 </span><span class="s1">- self.res.predict(which=</span><span class="s4">'prob-zero'</span><span class="s1">).mean()) *</span>
                 <span class="s1">self.res.predict(which=</span><span class="s4">'mean-nonzero'</span><span class="s1">).mean())</span>
        <span class="s1">assert_allclose(mean1</span><span class="s0">, </span><span class="s1">mean2</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">0.2</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestPandasOffset:</span>

    <span class="s0">def </span><span class="s1">test_pd_offset_exposure(self):</span>
        <span class="s1">endog = pd.DataFrame({</span><span class="s4">'F'</span><span class="s1">: [</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]})</span>
        <span class="s1">exog = pd.DataFrame({</span><span class="s4">'I'</span><span class="s1">: [</span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s1">]</span><span class="s0">,</span>
                             <span class="s4">'C'</span><span class="s1">: [</span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">1.0</span><span class="s0">, </span><span class="s2">0.0</span><span class="s1">]})</span>
        <span class="s1">exposure = pd.Series([</span><span class="s2">1.</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">offset = pd.Series([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">sm.Poisson(endog=endog</span><span class="s0">, </span><span class="s1">exog=exog</span><span class="s0">, </span><span class="s1">offset=offset).fit()</span>
        <span class="s1">inflations = [</span><span class="s4">'logit'</span><span class="s0">, </span><span class="s4">'probit'</span><span class="s1">]</span>
        <span class="s0">for </span><span class="s1">inflation </span><span class="s0">in </span><span class="s1">inflations:</span>
            <span class="s1">sm.ZeroInflatedPoisson(endog=endog</span><span class="s0">, </span><span class="s1">exog=exog[</span><span class="s4">&quot;I&quot;</span><span class="s1">]</span><span class="s0">,</span>
                                   <span class="s1">exposure=exposure</span><span class="s0">,</span>
                                   <span class="s1">inflation=inflation).fit()</span>
</pre>
</body>
</html>