<html>
<head>
<title>news.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
news.py</font>
</center></td></tr></table>
<pre><span class="s0"># -*- coding: utf-8 -*-</span>
<span class="s2">&quot;&quot;&quot; 
News for state space models 
 
Author: Chad Fulton 
License: BSD-3 
&quot;&quot;&quot;</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">import </span><span class="s1">pandas </span><span class="s3">as </span><span class="s1">pd</span>

<span class="s3">from </span><span class="s1">statsmodels.iolib.table </span><span class="s3">import </span><span class="s1">SimpleTable</span>
<span class="s3">from </span><span class="s1">statsmodels.iolib.summary </span><span class="s3">import </span><span class="s1">Summary</span>
<span class="s3">from </span><span class="s1">statsmodels.iolib.tableformatting </span><span class="s3">import </span><span class="s1">fmt_params</span>


<span class="s3">class </span><span class="s1">NewsResults:</span>
    <span class="s2">&quot;&quot;&quot; 
    Impacts of data revisions and news on estimates of variables of interest 
 
    Parameters 
    ---------- 
    news_results : SimpleNamespace instance 
        Results from `KalmanSmoother.news`. 
    model : MLEResults 
        The results object associated with the model from which the NewsResults 
        was generated. 
    updated : MLEResults 
        The results object associated with the model containing the updated 
        dataset. 
    previous : MLEResults 
        The results object associated with the model containing the previous 
        dataset. 
    impacted_variable : str, list, array, or slice, optional 
        Observation variable label or slice of labels specifying particular 
        impacted variables to display in output. The impacted variable(s) 
        describe the variables that were *affected* by the news. If you do not 
        know the labels for the variables, check the `endog_names` attribute of 
        the model instance. 
    tolerance : float, optional 
        The numerical threshold for determining zero impact. Default is that 
        any impact less than 1e-10 is assumed to be zero. 
    row_labels : iterable 
        Row labels (often dates) for the impacts of the revisions and news. 
 
    Attributes 
    ---------- 
    total_impacts : pd.Series 
        Updates to forecasts of impacted variables from both news and data 
        revisions, E[y^i | post] - E[y^i | previous]. 
    update_impacts : pd.Series 
        Updates to forecasts of impacted variables from the news, 
        E[y^i | post] - E[y^i | revisions] where y^i are the impacted variables 
        of interest. 
    revision_impacts : pd.Series 
        Updates to forecasts of impacted variables from data revisions, 
        E[y^i | revisions] - E[y^i | previous]. 
    news : pd.Series 
        The unexpected component of the updated data, 
        E[y^u | post] - E[y^u | revisions] where y^u are the updated variables. 
    weights : pd.Series 
        Weights describing the effect of news on variables of interest. 
    revisions : pd.Series 
        The revisions betwen the current and previously observed data 
        y^r_{revised} - y^r_{previous} where y^r are the revised variables. 
    revision_weights : pd.Series 
        Weights describing the effect of revisions on variables of interest. 
    update_forecasts : pd.Series 
        Forecasts based on the previous dataset of the variables that were 
        updated, E[y^u | previous]. 
    update_realized : pd.Series 
        Actual observed data associated with the variables that were 
        updated, y^u 
    revised_prev : pd.Series 
        Previously observed data associated with the variables that were 
        revised, y^r_{previous} 
    revised : pd.Series 
        Currently observed data associated with the variables that were 
        revised, y^r_{revised} 
    prev_impacted_forecasts : pd.Series 
        Previous forecast of the variables of interest, E[y^i | previous]. 
    post_impacted_forecasts : pd.Series 
        Forecast of the variables of interest after taking into account both 
        revisions and updates, E[y^i | post]. 
    revisions_iloc : pd.DataFrame 
        The integer locations of the data revisions in the dataset. 
    revisions_ix : pd.DataFrame 
        The label-based locations of the data revisions in the dataset. 
    updates_iloc : pd.DataFrame 
        The integer locations of the updated data points. 
    updates_ix : pd.DataFrame 
        The label-based locations of updated data points. 
    state_index : array_like 
        Index of state variables used to compute impacts. 
 
    References 
    ---------- 
    .. [1] Bańbura, Marta, and Michele Modugno. 
           &quot;Maximum likelihood estimation of factor models on datasets with 
           arbitrary pattern of missing data.&quot; 
           Journal of Applied Econometrics 29, no. 1 (2014): 133-160. 
    .. [2] Bańbura, Marta, Domenico Giannone, and Lucrezia Reichlin. 
           &quot;Nowcasting.&quot; 
           The Oxford Handbook of Economic Forecasting. July 8, 2011. 
    .. [3] Bańbura, Marta, Domenico Giannone, Michele Modugno, and Lucrezia 
           Reichlin. 
           &quot;Now-casting and the real-time data flow.&quot; 
           In Handbook of economic forecasting, vol. 2, pp. 195-237. 
           Elsevier, 2013. 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">news_results</span><span class="s3">, </span><span class="s1">model</span><span class="s3">, </span><span class="s1">updated</span><span class="s3">, </span><span class="s1">previous</span><span class="s3">,</span>
                 <span class="s1">impacted_variable=</span><span class="s3">None, </span><span class="s1">tolerance=</span><span class="s4">1e-10</span><span class="s3">, </span><span class="s1">row_labels=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0"># Note: `model` will be the same as one of `revised` or `previous`, but</span>
        <span class="s0"># we need to save it as self.model so that the `predict_dates`, which</span>
        <span class="s0"># were generated by the `_get_prediction_index` call, will be available</span>
        <span class="s0"># for use by the base wrapping code.</span>
        <span class="s1">self.model = model</span>
        <span class="s1">self.updated = updated</span>
        <span class="s1">self.previous = previous</span>
        <span class="s1">self.news_results = news_results</span>
        <span class="s1">self._impacted_variable = impacted_variable</span>
        <span class="s1">self._tolerance = tolerance</span>
        <span class="s1">self.row_labels = row_labels</span>
        <span class="s1">self.params = []  </span><span class="s0"># required for `summary` to work</span>

        <span class="s1">self.endog_names = self.updated.model.endog_names</span>
        <span class="s1">self.k_endog = len(self.endog_names)</span>

        <span class="s1">index = self.updated.model._index</span>
        <span class="s1">columns = np.atleast_1d(self.endog_names)</span>

        <span class="s0"># E[y^i | post]</span>
        <span class="s1">self.post_impacted_forecasts = pd.DataFrame(</span>
            <span class="s1">news_results.post_impacted_forecasts.T</span><span class="s3">,</span>
            <span class="s1">index=self.row_labels</span><span class="s3">, </span><span class="s1">columns=columns)</span>
        <span class="s0"># E[y^i | previous]</span>
        <span class="s1">self.prev_impacted_forecasts = pd.DataFrame(</span>
            <span class="s1">news_results.prev_impacted_forecasts.T</span><span class="s3">,</span>
            <span class="s1">index=self.row_labels</span><span class="s3">, </span><span class="s1">columns=columns)</span>
        <span class="s0"># E[y^i | post] - E[y^i | revisions]</span>
        <span class="s1">self.update_impacts = pd.DataFrame(</span>
            <span class="s1">news_results.update_impacts</span><span class="s3">,</span>
            <span class="s1">index=self.row_labels</span><span class="s3">, </span><span class="s1">columns=columns)</span>
        <span class="s0"># E[y^i | revisions] - E[y^i | previous]</span>
        <span class="s1">self.revision_impacts = pd.DataFrame(</span>
            <span class="s1">news_results.revision_impacts</span><span class="s3">,</span>
            <span class="s1">index=self.row_labels</span><span class="s3">, </span><span class="s1">columns=columns)</span>
        <span class="s0"># E[y^i | post] - E[y^i | previous]</span>
        <span class="s1">self.total_impacts = (self.post_impacted_forecasts -</span>
                              <span class="s1">self.prev_impacted_forecasts)</span>

        <span class="s0"># Indices of revisions and updates</span>
        <span class="s1">self.revisions_iloc = pd.DataFrame(</span>
            <span class="s1">list(zip(*news_results.revisions_ix))</span><span class="s3">,</span>
            <span class="s1">index=[</span><span class="s5">'revision date'</span><span class="s3">, </span><span class="s5">'revised variable'</span><span class="s1">]).T</span>
        <span class="s1">iloc = self.revisions_iloc</span>
        <span class="s3">if </span><span class="s1">len(iloc) &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">self.revisions_ix = pd.DataFrame({</span>
                <span class="s5">'revision date'</span><span class="s1">: index[iloc[</span><span class="s5">'revision date'</span><span class="s1">]]</span><span class="s3">,</span>
                <span class="s5">'revised variable'</span><span class="s1">: columns[iloc[</span><span class="s5">'revised variable'</span><span class="s1">]]})</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.revisions_ix = iloc.copy()</span>

        <span class="s1">self.updates_iloc = pd.DataFrame(</span>
            <span class="s1">list(zip(*news_results.updates_ix))</span><span class="s3">,</span>
            <span class="s1">index=[</span><span class="s5">'update date'</span><span class="s3">, </span><span class="s5">'updated variable'</span><span class="s1">]).T</span>
        <span class="s1">iloc = self.updates_iloc</span>
        <span class="s3">if </span><span class="s1">len(iloc) &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">self.updates_ix = pd.DataFrame({</span>
                <span class="s5">'update date'</span><span class="s1">: index[iloc[</span><span class="s5">'update date'</span><span class="s1">]]</span><span class="s3">,</span>
                <span class="s5">'updated variable'</span><span class="s1">: columns[iloc[</span><span class="s5">'updated variable'</span><span class="s1">]]})</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.updates_ix = iloc.copy()</span>

        <span class="s0"># Index of the state variables used</span>
        <span class="s1">self.state_index = news_results.state_index</span>

        <span class="s0"># Wrap forecasts and forecasts errors</span>
        <span class="s1">r_ix = pd.MultiIndex.from_arrays([</span>
            <span class="s1">self.revisions_ix[</span><span class="s5">'revision date'</span><span class="s1">]</span><span class="s3">,</span>
            <span class="s1">self.revisions_ix[</span><span class="s5">'revised variable'</span><span class="s1">]])</span>
        <span class="s1">u_ix = pd.MultiIndex.from_arrays([</span>
            <span class="s1">self.updates_ix[</span><span class="s5">'update date'</span><span class="s1">]</span><span class="s3">,</span>
            <span class="s1">self.updates_ix[</span><span class="s5">'updated variable'</span><span class="s1">]])</span>

        <span class="s0"># E[y^u | post] - E[y^u | revisions]</span>
        <span class="s3">if </span><span class="s1">news_results.news </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">self.news = pd.Series([]</span><span class="s3">, </span><span class="s1">index=u_ix</span><span class="s3">, </span><span class="s1">name=</span><span class="s5">'news'</span><span class="s3">,</span>
                                  <span class="s1">dtype=model.params.dtype)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.news = pd.Series(news_results.news</span><span class="s3">, </span><span class="s1">index=u_ix</span><span class="s3">, </span><span class="s1">name=</span><span class="s5">'news'</span><span class="s1">)</span>
        <span class="s0"># E[y^u | revisions] - E[y^u | previous]</span>
        <span class="s3">if </span><span class="s1">news_results.revisions </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">self.revisions = pd.Series([]</span><span class="s3">, </span><span class="s1">index=r_ix</span><span class="s3">, </span><span class="s1">name=</span><span class="s5">'revision'</span><span class="s3">,</span>
                                       <span class="s1">dtype=model.params.dtype)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.revisions = pd.Series(news_results.revisions</span><span class="s3">, </span><span class="s1">index=r_ix</span><span class="s3">,</span>
                                       <span class="s1">name=</span><span class="s5">'revision'</span><span class="s1">)</span>
        <span class="s0"># E[y^u | revised]</span>
        <span class="s3">if </span><span class="s1">news_results.update_forecasts </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">self.update_forecasts = pd.Series([]</span><span class="s3">, </span><span class="s1">index=u_ix</span><span class="s3">,</span>
                                              <span class="s1">dtype=model.params.dtype)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.update_forecasts = pd.Series(</span>
                <span class="s1">news_results.update_forecasts</span><span class="s3">, </span><span class="s1">index=u_ix)</span>
        <span class="s0"># y^r_{revised}</span>
        <span class="s3">if </span><span class="s1">news_results.revised </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">self.revised = pd.Series([]</span><span class="s3">, </span><span class="s1">index=r_ix</span><span class="s3">, </span><span class="s1">dtype=model.params.dtype</span><span class="s3">,</span>
                                     <span class="s1">name=</span><span class="s5">'revised'</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.revised = pd.Series(news_results.revised</span><span class="s3">, </span><span class="s1">index=r_ix</span><span class="s3">,</span>
                                     <span class="s1">name=</span><span class="s5">'revised'</span><span class="s1">)</span>
        <span class="s0"># y^r_{previous}</span>
        <span class="s3">if </span><span class="s1">news_results.revised_prev </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">self.revised_prev = pd.Series([]</span><span class="s3">, </span><span class="s1">index=r_ix</span><span class="s3">,</span>
                                          <span class="s1">dtype=model.params.dtype)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.revised_prev = pd.Series(</span>
                <span class="s1">news_results.revised_prev</span><span class="s3">, </span><span class="s1">index=r_ix)</span>
        <span class="s0"># y^u</span>
        <span class="s3">if </span><span class="s1">news_results.update_realized </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">self.update_realized = pd.Series([]</span><span class="s3">, </span><span class="s1">index=u_ix</span><span class="s3">,</span>
                                             <span class="s1">dtype=model.params.dtype)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.update_realized = pd.Series(</span>
                <span class="s1">news_results.update_realized</span><span class="s3">, </span><span class="s1">index=u_ix)</span>
        <span class="s1">cols = pd.MultiIndex.from_product([self.row_labels</span><span class="s3">, </span><span class="s1">columns])</span>
        <span class="s0"># reshaped version of gain matrix E[y A'] E[A A']^{-1}</span>
        <span class="s3">if </span><span class="s1">len(self.updates_iloc):</span>
            <span class="s1">weights = news_results.gain.reshape(</span>
                <span class="s1">len(cols)</span><span class="s3">, </span><span class="s1">len(u_ix))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">weights = np.zeros((len(cols)</span><span class="s3">, </span><span class="s1">len(u_ix)))</span>
        <span class="s1">self.weights = pd.DataFrame(weights</span><span class="s3">, </span><span class="s1">index=cols</span><span class="s3">, </span><span class="s1">columns=u_ix).T</span>
        <span class="s1">self.weights.columns.names = [</span><span class="s5">'impact date'</span><span class="s3">, </span><span class="s5">'impacted variable'</span><span class="s1">]</span>

        <span class="s0"># reshaped version of revision_weights</span>
        <span class="s3">if </span><span class="s1">len(self.revisions_iloc):</span>
            <span class="s1">revision_weights = news_results.revision_weights.reshape(</span>
                <span class="s1">len(cols)</span><span class="s3">, </span><span class="s1">len(r_ix))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">revision_weights = np.zeros((len(cols)</span><span class="s3">, </span><span class="s1">len(r_ix)))</span>
        <span class="s1">self.revision_weights = pd.DataFrame(</span>
            <span class="s1">revision_weights</span><span class="s3">, </span><span class="s1">index=cols</span><span class="s3">, </span><span class="s1">columns=r_ix).T</span>
        <span class="s1">self.revision_weights.columns.names = [</span>
            <span class="s5">'impact date'</span><span class="s3">, </span><span class="s5">'impacted variable'</span><span class="s1">]</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">impacted_variable(self):</span>
        <span class="s3">return </span><span class="s1">self._impacted_variable</span>

    <span class="s1">@impacted_variable.setter</span>
    <span class="s3">def </span><span class="s1">impacted_variable(self</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s1">self._impacted_variable = value</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">tolerance(self):</span>
        <span class="s3">return </span><span class="s1">self._tolerance</span>

    <span class="s1">@tolerance.setter</span>
    <span class="s3">def </span><span class="s1">tolerance(self</span><span class="s3">, </span><span class="s1">value):</span>
        <span class="s1">self._tolerance = value</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">data_revisions(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Revisions to data points that existed in the previous dataset 
 
        Returns 
        ------- 
        data_revisions : pd.DataFrame 
            Index is as MultiIndex consisting of `revision date` and 
            `revised variable`. The columns are: 
 
            - `observed (prev)`: the value of the data as it was observed 
              in the previous dataset. 
            - `revised`: the revised value of the data, as it is observed 
              in the new dataset 
 
        See also 
        -------- 
        data_updates 
        &quot;&quot;&quot;</span>
        <span class="s0"># Save revisions data</span>
        <span class="s1">data = pd.concat([</span>
            <span class="s1">self.revised.rename(</span><span class="s5">'revised'</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">self.revised_prev.rename(</span><span class="s5">'observed (prev)'</span><span class="s1">)</span>
        <span class="s1">]</span><span class="s3">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">).sort_index()</span>
        <span class="s3">return </span><span class="s1">data</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">data_updates(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Updated data; new entries that did not exist in the previous dataset 
 
        Returns 
        ------- 
        data_updates : pd.DataFrame 
            Index is as MultiIndex consisting of `update date` and 
            `updated variable`. The columns are: 
 
            - `forecast (prev)`: the previous forecast of the new entry, 
              based on the information available in the previous dataset 
              (recall that for these updated data points, the previous dataset 
              had no observed value for them at all) 
            - `observed`: the value of the new entry, as it is observed in the 
              new dataset 
 
        See also 
        -------- 
        data_revisions 
        &quot;&quot;&quot;</span>
        <span class="s1">data = pd.concat([</span>
            <span class="s1">self.update_realized.rename(</span><span class="s5">'observed'</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">self.update_forecasts.rename(</span><span class="s5">'forecast (prev)'</span><span class="s1">)</span>
        <span class="s1">]</span><span class="s3">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">).sort_index()</span>
        <span class="s3">return </span><span class="s1">data</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">details_by_impact(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Details of forecast revisions from news, organized by impacts first 
 
        Returns 
        ------- 
        details : pd.DataFrame 
            Index is as MultiIndex consisting of: 
 
            - `impact date`: the date of the impact on the variable of interest 
            - `impacted variable`: the variable that is being impacted 
            - `update date`: the date of the data update, that results in 
              `news` that impacts the forecast of variables of interest 
            - `updated variable`: the variable being updated, that results in 
              `news` that impacts the forecast of variables of interest 
 
            The columns are: 
 
            - `forecast (prev)`: the previous forecast of the new entry, 
              based on the information available in the previous dataset 
            - `observed`: the value of the new entry, as it is observed in the 
              new dataset 
            - `news`: the news associated with the update (this is just the 
              forecast error: `observed` - `forecast (prev)`) 
            - `weight`: the weight describing how the `news` effects the 
              forecast of the variable of interest 
            - `impact`: the impact of the `news` on the forecast of the 
              variable of interest 
 
        Notes 
        ----- 
        This table decomposes updated forecasts of variables of interest from 
        the `news` associated with each updated datapoint from the new data 
        release. 
 
        This table does not summarize the impacts or show the effect of 
        revisions. That information can be found in the `impacts` or 
        `revision_details_by_impact` tables. 
 
        This form of the details table is organized so that the impacted 
        dates / variables are first in the index. This is convenient for 
        slicing by impacted variables / dates to view the details of data 
        updates for a particular variable or date. 
 
        However, since the `forecast (prev)` and `observed` columns have a lot 
        of duplication, printing the entire table gives a result that is less 
        easy to parse than that produced by the `details_by_update` property. 
        `details_by_update` contains the same information but is organized to 
        be more convenient for displaying the entire table of detailed updates. 
        At the same time, `details_by_update` is less convenient for 
        subsetting. 
 
        See Also 
        -------- 
        details_by_update 
        revision_details_by_update 
        impacts 
        &quot;&quot;&quot;</span>
        <span class="s1">df = self.weights.stack(level=[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s1">]).rename(</span><span class="s5">'weight'</span><span class="s1">).to_frame()</span>
        <span class="s3">if </span><span class="s1">len(self.updates_iloc):</span>
            <span class="s1">df[</span><span class="s5">'forecast (prev)'</span><span class="s1">] = self.update_forecasts</span>
            <span class="s1">df[</span><span class="s5">'observed'</span><span class="s1">] = self.update_realized</span>
            <span class="s1">df[</span><span class="s5">'news'</span><span class="s1">] = self.news</span>
            <span class="s1">df[</span><span class="s5">'impact'</span><span class="s1">] = df[</span><span class="s5">'news'</span><span class="s1">] * df[</span><span class="s5">'weight'</span><span class="s1">]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">df[</span><span class="s5">'forecast (prev)'</span><span class="s1">] = []</span>
            <span class="s1">df[</span><span class="s5">'observed'</span><span class="s1">] = []</span>
            <span class="s1">df[</span><span class="s5">'news'</span><span class="s1">] = []</span>
            <span class="s1">df[</span><span class="s5">'impact'</span><span class="s1">] = []</span>
        <span class="s1">df = df[[</span><span class="s5">'observed'</span><span class="s3">, </span><span class="s5">'forecast (prev)'</span><span class="s3">, </span><span class="s5">'news'</span><span class="s3">, </span><span class="s5">'weight'</span><span class="s3">, </span><span class="s5">'impact'</span><span class="s1">]]</span>
        <span class="s1">df = df.reorder_levels([</span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s1">]).sort_index()</span>

        <span class="s3">if </span><span class="s1">self.impacted_variable </span><span class="s3">is not None and </span><span class="s1">len(df) &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">df = df.loc[np.s_[:</span><span class="s3">, </span><span class="s1">self.impacted_variable]</span><span class="s3">, </span><span class="s1">:]</span>

        <span class="s1">mask = np.abs(df[</span><span class="s5">'weight'</span><span class="s1">]) &gt; self.tolerance</span>
        <span class="s3">return </span><span class="s1">df[mask]</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">revision_details_by_impact(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Details of forecast revisions from revised data, organized by impacts 
 
        Returns 
        ------- 
        details : pd.DataFrame 
            Index is as MultiIndex consisting of: 
 
            - `impact date`: the date of the impact on the variable of interest 
            - `impacted variable`: the variable that is being impacted 
            - `revision date`: the date of the data revision, that results in 
              `revision` that impacts the forecast of variables of interest 
            - `revised variable`: the variable being revised, that results in 
              `news` that impacts the forecast of variables of interest 
 
            The columns are: 
 
            - `observed (prev)`: the previous value of the observation, as it 
              was given in the previous dataset 
            - `revised`: the value of the revised entry, as it is observed in 
              the new dataset 
            - `revision`: the revision (this is `revised` - `observed (prev)`) 
            - `weight`: the weight describing how the `revision` effects the 
              forecast of the variable of interest 
            - `impact`: the impact of the `revision` on the forecast of the 
              variable of interest 
 
        Notes 
        ----- 
        This table decomposes updated forecasts of variables of interest from 
        the `revision` associated with each revised datapoint from the new data 
        release. 
 
        This table does not summarize the impacts or show the effect of 
        new datapoints. That information can be found in the 
        `impacts` or `details_by_impact` tables. 
 
        This form of the details table is organized so that the impacted 
        dates / variables are first in the index. This is convenient for 
        slicing by impacted variables / dates to view the details of data 
        updates for a particular variable or date. 
 
        However, since the `observed (prev)` and `revised` columns have a lot 
        of duplication, printing the entire table gives a result that is less 
        easy to parse than that produced by the `details_by_revision` property. 
        `details_by_revision` contains the same information but is organized to 
        be more convenient for displaying the entire table of detailed 
        revisions. At the same time, `details_by_revision` is less convenient 
        for subsetting. 
 
        See Also 
        -------- 
        details_by_revision 
        details_by_impact 
        impacts 
        &quot;&quot;&quot;</span>
        <span class="s1">weights = self.revision_weights.stack(level=[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s1">])</span>
        <span class="s1">df = pd.concat([</span>
            <span class="s1">self.revised.reindex(weights.index)</span><span class="s3">,</span>
            <span class="s1">self.revised_prev.rename(</span><span class="s5">'observed (prev)'</span><span class="s1">).reindex(weights.index)</span><span class="s3">,</span>
            <span class="s1">self.revisions.reindex(weights.index)</span><span class="s3">,</span>
            <span class="s1">weights.rename(</span><span class="s5">'weight'</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">(self.revisions * weights).rename(</span><span class="s5">'impact'</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">]</span><span class="s3">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>

        <span class="s1">df = df.reorder_levels([</span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s1">]).sort_index()</span>

        <span class="s3">if </span><span class="s1">self.impacted_variable </span><span class="s3">is not None and </span><span class="s1">len(df) &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">df = df.loc[np.s_[:</span><span class="s3">, </span><span class="s1">self.impacted_variable]</span><span class="s3">, </span><span class="s1">:]</span>

        <span class="s1">mask = np.abs(df[</span><span class="s5">'weight'</span><span class="s1">]) &gt; self.tolerance</span>
        <span class="s3">return </span><span class="s1">df[mask]</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">details_by_update(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Details of forecast revisions from news, organized by updates first 
 
        Returns 
        ------- 
        details : pd.DataFrame 
            Index is as MultiIndex consisting of: 
 
            - `update date`: the date of the data update, that results in 
              `news` that impacts the forecast of variables of interest 
            - `updated variable`: the variable being updated, that results in 
              `news` that impacts the forecast of variables of interest 
            - `forecast (prev)`: the previous forecast of the new entry, 
              based on the information available in the previous dataset 
            - `observed`: the value of the new entry, as it is observed in the 
              new dataset 
            - `impact date`: the date of the impact on the variable of interest 
            - `impacted variable`: the variable that is being impacted 
 
            The columns are: 
 
            - `news`: the news associated with the update (this is just the 
              forecast error: `observed` - `forecast (prev)`) 
            - `weight`: the weight describing how the `news` affects the 
              forecast of the variable of interest 
            - `impact`: the impact of the `news` on the forecast of the 
              variable of interest 
 
        Notes 
        ----- 
        This table decomposes updated forecasts of variables of interest from 
        the `news` associated with each updated datapoint from the new data 
        release. 
 
        This table does not summarize the impacts or show the effect of 
        revisions. That information can be found in the `impacts` table. 
 
        This form of the details table is organized so that the updated 
        dates / variables are first in the index, and in this table the index 
        also contains the forecasts and observed values of the updates. This is 
        convenient for displaying the entire table of detailed updates because 
        it allows sparsifying duplicate entries. 
 
        However, since it includes forecasts and observed values in the index 
        of the table, it is not convenient for subsetting by the variable of 
        interest. Instead, the `details_by_impact` property is organized to 
        make slicing by impacted variables / dates easy. This allows, for 
        example, viewing the details of data updates on a particular variable 
        or date of interest. 
 
        See Also 
        -------- 
        details_by_impact 
        impacts 
        &quot;&quot;&quot;</span>
        <span class="s1">df = self.weights.stack(level=[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s1">]).rename(</span><span class="s5">'weight'</span><span class="s1">).to_frame()</span>
        <span class="s3">if </span><span class="s1">len(self.updates_iloc):</span>
            <span class="s1">df[</span><span class="s5">'forecast (prev)'</span><span class="s1">] = self.update_forecasts</span>
            <span class="s1">df[</span><span class="s5">'observed'</span><span class="s1">] = self.update_realized</span>
            <span class="s1">df[</span><span class="s5">'news'</span><span class="s1">] = self.news</span>
            <span class="s1">df[</span><span class="s5">'impact'</span><span class="s1">] = df[</span><span class="s5">'news'</span><span class="s1">] * df[</span><span class="s5">'weight'</span><span class="s1">]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">df[</span><span class="s5">'forecast (prev)'</span><span class="s1">] = []</span>
            <span class="s1">df[</span><span class="s5">'observed'</span><span class="s1">] = []</span>
            <span class="s1">df[</span><span class="s5">'news'</span><span class="s1">] = []</span>
            <span class="s1">df[</span><span class="s5">'impact'</span><span class="s1">] = []</span>
        <span class="s1">df = df[[</span><span class="s5">'forecast (prev)'</span><span class="s3">, </span><span class="s5">'observed'</span><span class="s3">, </span><span class="s5">'news'</span><span class="s3">,</span>
                 <span class="s5">'weight'</span><span class="s3">, </span><span class="s5">'impact'</span><span class="s1">]]</span>
        <span class="s1">df = df.reset_index()</span>
        <span class="s1">keys = [</span><span class="s5">'update date'</span><span class="s3">, </span><span class="s5">'updated variable'</span><span class="s3">, </span><span class="s5">'observed'</span><span class="s3">,</span>
                <span class="s5">'forecast (prev)'</span><span class="s3">, </span><span class="s5">'impact date'</span><span class="s3">, </span><span class="s5">'impacted variable'</span><span class="s1">]</span>
        <span class="s1">df.index = pd.MultiIndex.from_arrays([df[key] </span><span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">keys])</span>
        <span class="s1">details = df.drop(keys</span><span class="s3">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">).sort_index()</span>

        <span class="s3">if </span><span class="s1">self.impacted_variable </span><span class="s3">is not None and </span><span class="s1">len(df) &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">details = details.loc[</span>
                <span class="s1">np.s_[:</span><span class="s3">, </span><span class="s1">:</span><span class="s3">, </span><span class="s1">:</span><span class="s3">, </span><span class="s1">:</span><span class="s3">, </span><span class="s1">:</span><span class="s3">, </span><span class="s1">self.impacted_variable]</span><span class="s3">, </span><span class="s1">:]</span>

        <span class="s1">mask = np.abs(details[</span><span class="s5">'weight'</span><span class="s1">]) &gt; self.tolerance</span>
        <span class="s3">return </span><span class="s1">details[mask]</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">revision_details_by_update(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Details of forecast revisions from revisions, organized by updates 
 
        Returns 
        ------- 
        details : pd.DataFrame 
            Index is as MultiIndex consisting of: 
 
            - `revision date`: the date of the data revision, that results in 
              `revision` that impacts the forecast of variables of interest 
            - `revised variable`: the variable being revised, that results in 
              `news` that impacts the forecast of variables of interest 
            - `observed (prev)`: the previous value of the observation, as it 
              was given in the previous dataset 
            - `revised`: the value of the revised entry, as it is observed in 
              the new dataset 
            - `impact date`: the date of the impact on the variable of interest 
            - `impacted variable`: the variable that is being impacted 
 
            The columns are: 
 
            - `revision`: the revision (this is `revised` - `observed (prev)`) 
            - `weight`: the weight describing how the `revision` affects the 
              forecast of the variable of interest 
            - `impact`: the impact of the `revision` on the forecast of the 
              variable of interest 
 
        Notes 
        ----- 
        This table decomposes updated forecasts of variables of interest from 
        the `revision` associated with each revised datapoint from the new data 
        release. 
 
        This table does not summarize the impacts or show the effect of 
        revisions. That information can be found in the `impacts` table. 
 
        This form of the details table is organized so that the revision 
        dates / variables are first in the index, and in this table the index 
        also contains the previously observed and revised values. This is 
        convenient for displaying the entire table of detailed revisions 
        because it allows sparsifying duplicate entries. 
 
        However, since it includes previous observations and revisions in the 
        index of the table, it is not convenient for subsetting by the variable 
        of interest. Instead, the `revision_details_by_impact` property is 
        organized to make slicing by impacted variables / dates easy. This 
        allows, for example, viewing the details of data revisions on a 
        particular variable or date of interest. 
 
        See Also 
        -------- 
        details_by_impact 
        impacts 
        &quot;&quot;&quot;</span>
        <span class="s1">weights = self.revision_weights.stack(level=[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s1">])</span>

        <span class="s1">df = pd.concat([</span>
            <span class="s1">self.revised_prev.rename(</span><span class="s5">'observed (prev)'</span><span class="s1">).reindex(weights.index)</span><span class="s3">,</span>
            <span class="s1">self.revised.reindex(weights.index)</span><span class="s3">,</span>
            <span class="s1">self.revisions.reindex(weights.index)</span><span class="s3">,</span>
            <span class="s1">weights.rename(</span><span class="s5">'weight'</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">(self.revisions * weights).rename(</span><span class="s5">'impact'</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">]</span><span class="s3">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>

        <span class="s1">details = (df.set_index([</span><span class="s5">'observed (prev)'</span><span class="s3">, </span><span class="s5">'revised'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">append=</span><span class="s3">True</span><span class="s1">)</span>
                     <span class="s1">.reorder_levels([</span>
                         <span class="s5">'revision date'</span><span class="s3">, </span><span class="s5">'revised variable'</span><span class="s3">, </span><span class="s5">'revised'</span><span class="s3">,</span>
                         <span class="s5">'observed (prev)'</span><span class="s3">, </span><span class="s5">'impact date'</span><span class="s3">,</span>
                         <span class="s5">'impacted variable'</span><span class="s1">])</span>
                     <span class="s1">.sort_index())</span>

        <span class="s3">if </span><span class="s1">self.impacted_variable </span><span class="s3">is not None and </span><span class="s1">len(df) &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">details = details.loc[</span>
                <span class="s1">np.s_[:</span><span class="s3">, </span><span class="s1">:</span><span class="s3">, </span><span class="s1">:</span><span class="s3">, </span><span class="s1">:</span><span class="s3">, </span><span class="s1">:</span><span class="s3">, </span><span class="s1">self.impacted_variable]</span><span class="s3">, </span><span class="s1">:]</span>

        <span class="s1">mask = np.abs(details[</span><span class="s5">'weight'</span><span class="s1">]) &gt; self.tolerance</span>
        <span class="s3">return </span><span class="s1">details[mask]</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">impacts(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Impacts from news and revisions on all dates / variables of interest 
 
        Returns 
        ------- 
        impacts : pd.DataFrame 
            Index is as MultiIndex consisting of: 
 
            - `impact date`: the date of the impact on the variable of interest 
            - `impacted variable`: the variable that is being impacted 
 
            The columns are: 
 
            - `estimate (prev)`: the previous estimate / forecast of the 
              date / variable of interest. 
            - `impact of revisions`: the impact of all data revisions on 
              the estimate of the date / variable of interest. 
            - `impact of news`: the impact of all news on the estimate of 
              the date / variable of interest. 
            - `total impact`: the total impact of both revisions and news on 
              the estimate of the date / variable of interest. 
            - `estimate (new)`: the new estimate / forecast of the 
              date / variable of interest after taking into account the effects 
              of the revisions and news. 
 
        Notes 
        ----- 
        This table decomposes updated forecasts of variables of interest into 
        the overall effect from revisions and news. 
 
        This table does not break down the detail by the updated 
        dates / variables. That information can be found in the 
        `details_by_impact` `details_by_update` tables. 
 
        See Also 
        -------- 
        details_by_impact 
        details_by_update 
        &quot;&quot;&quot;</span>
        <span class="s0"># Summary of impacts</span>
        <span class="s1">impacts = pd.concat([</span>
            <span class="s1">self.prev_impacted_forecasts.unstack().rename(</span><span class="s5">'estimate (prev)'</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">self.revision_impacts.unstack().rename(</span><span class="s5">'impact of revisions'</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">self.update_impacts.unstack().rename(</span><span class="s5">'impact of news'</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">self.post_impacted_forecasts.unstack().rename(</span><span class="s5">'estimate (new)'</span><span class="s1">)]</span><span class="s3">,</span>
            <span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">impacts[</span><span class="s5">'impact of revisions'</span><span class="s1">] = (</span>
            <span class="s1">impacts[</span><span class="s5">'impact of revisions'</span><span class="s1">].fillna(</span><span class="s4">0</span><span class="s1">))</span>
        <span class="s1">impacts[</span><span class="s5">'impact of news'</span><span class="s1">] = (</span>
            <span class="s1">impacts[</span><span class="s5">'impact of news'</span><span class="s1">].fillna(</span><span class="s4">0</span><span class="s1">))</span>
        <span class="s1">impacts[</span><span class="s5">'total impact'</span><span class="s1">] = (impacts[</span><span class="s5">'impact of revisions'</span><span class="s1">] +</span>
                                   <span class="s1">impacts[</span><span class="s5">'impact of news'</span><span class="s1">])</span>
        <span class="s1">impacts = impacts.reorder_levels([</span><span class="s4">1</span><span class="s3">, </span><span class="s4">0</span><span class="s1">]).sort_index()</span>
        <span class="s1">impacts.index.names = [</span><span class="s5">'impact date'</span><span class="s3">, </span><span class="s5">'impacted variable'</span><span class="s1">]</span>
        <span class="s1">impacts = impacts[[</span><span class="s5">'estimate (prev)'</span><span class="s3">, </span><span class="s5">'impact of revisions'</span><span class="s3">,</span>
                           <span class="s5">'impact of news'</span><span class="s3">, </span><span class="s5">'total impact'</span><span class="s3">, </span><span class="s5">'estimate (new)'</span><span class="s1">]]</span>

        <span class="s3">if </span><span class="s1">self.impacted_variable </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">impacts = impacts.loc[np.s_[:</span><span class="s3">, </span><span class="s1">self.impacted_variable]</span><span class="s3">, </span><span class="s1">:]</span>

        <span class="s1">tmp = np.abs(impacts[[</span><span class="s5">'impact of revisions'</span><span class="s3">, </span><span class="s5">'impact of news'</span><span class="s1">]])</span>
        <span class="s1">mask = (tmp &gt; self.tolerance).any(axis=</span><span class="s4">1</span><span class="s1">)</span>

        <span class="s3">return </span><span class="s1">impacts[mask]</span>

    <span class="s3">def </span><span class="s1">summary_impacts(self</span><span class="s3">, </span><span class="s1">impact_date=</span><span class="s3">None, </span><span class="s1">impacted_variable=</span><span class="s3">None,</span>
                        <span class="s1">groupby=</span><span class="s5">'impact date'</span><span class="s3">, </span><span class="s1">show_revisions_columns=</span><span class="s3">None,</span>
                        <span class="s1">sparsify=</span><span class="s3">True, </span><span class="s1">float_format=</span><span class="s5">'%.2f'</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Create summary table with detailed impacts from news; by date, variable 
 
        Parameters 
        ---------- 
        impact_date : int, str, datetime, list, array, or slice, optional 
            Observation index label or slice of labels specifying particular 
            impact periods to display. The impact date(s) describe the periods 
            in which impacted variables were *affected* by the news. If this 
            argument is given, the output table will only show this impact date 
            or dates. Note that this argument is passed to the Pandas `loc` 
            accessor, and so it should correspond to the labels of the model's 
            index. If the model was created with data in a list or numpy array, 
            then these labels will be zero-indexes observation integers. 
        impacted_variable : str, list, array, or slice, optional 
            Observation variable label or slice of labels specifying particular 
            impacted variables to display. The impacted variable(s) describe 
            the variables that were *affected* by the news. If you do not know 
            the labels for the variables, check the `endog_names` attribute of 
            the model instance. 
        groupby : {impact date, impacted date} 
            The primary variable for grouping results in the impacts table. The 
            default is to group by update date. 
        show_revisions_columns : bool, optional 
            If set to False, the impacts table will not show the impacts from 
            data revisions or the total impacts. Default is to show the 
            revisions and totals columns if any revisions were made and 
            otherwise to hide them. 
        sparsify : bool, optional, default True 
            Set to False for the table to include every one of the multiindex 
            keys at each row. 
        float_format : str, optional 
            Formatter format string syntax for converting numbers to strings. 
            Default is '%.2f'. 
 
        Returns 
        ------- 
        impacts_table : SimpleTable 
            Table describing total impacts from both revisions and news. See 
            the documentation for the `impacts` attribute for more details 
            about the index and columns. 
 
        See Also 
        -------- 
        impacts 
        &quot;&quot;&quot;</span>
        <span class="s0"># Squeeze for univariate models</span>
        <span class="s3">if </span><span class="s1">impacted_variable </span><span class="s3">is None and </span><span class="s1">self.k_endog == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">impacted_variable = self.endog_names[</span><span class="s4">0</span><span class="s1">]</span>

        <span class="s0"># Default is to only show the revisions columns if there were any</span>
        <span class="s0"># revisions (otherwise it would just be a column of zeros)</span>
        <span class="s3">if </span><span class="s1">show_revisions_columns </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">show_revisions_columns = len(self.revisions_iloc) &gt; </span><span class="s4">0</span>

        <span class="s0"># Select only the variables / dates of interest</span>
        <span class="s1">s = list(np.s_[:</span><span class="s3">, </span><span class="s1">:])</span>
        <span class="s3">if </span><span class="s1">impact_date </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">s[</span><span class="s4">0</span><span class="s1">] = np.s_[impact_date]</span>
        <span class="s3">if </span><span class="s1">impacted_variable </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">s[</span><span class="s4">1</span><span class="s1">] = np.s_[impacted_variable]</span>
        <span class="s1">s = tuple(s)</span>
        <span class="s1">impacts = self.impacts.loc[s</span><span class="s3">, </span><span class="s1">:]</span>

        <span class="s0"># Make the first index level the groupby level</span>
        <span class="s1">groupby = groupby.lower()</span>
        <span class="s3">if </span><span class="s1">groupby </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'impacted variable'</span><span class="s3">, </span><span class="s5">'impacted_variable'</span><span class="s1">]:</span>
            <span class="s1">impacts.index = impacts.index.swaplevel(</span><span class="s4">1</span><span class="s3">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s3">elif </span><span class="s1">groupby </span><span class="s3">not in </span><span class="s1">[</span><span class="s5">'impact date'</span><span class="s3">, </span><span class="s5">'impact_date'</span><span class="s1">]:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'Invalid groupby for impacts table. Valid options'</span>
                             <span class="s5">' are &quot;impact date&quot; or &quot;impacted variable&quot;.'</span>
                             <span class="s5">f'Got &quot;</span><span class="s3">{</span><span class="s1">groupby</span><span class="s3">}</span><span class="s5">&quot;.'</span><span class="s1">)</span>
        <span class="s1">impacts = impacts.sort_index()</span>

        <span class="s0"># Drop the non-groupby level if there's only one value</span>
        <span class="s1">tmp_index = impacts.index.remove_unused_levels()</span>
        <span class="s1">k_vars = len(tmp_index.levels[</span><span class="s4">1</span><span class="s1">])</span>
        <span class="s1">removed_level = </span><span class="s3">None</span>
        <span class="s3">if </span><span class="s1">sparsify </span><span class="s3">and </span><span class="s1">k_vars == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">name = tmp_index.names[</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s1">value = tmp_index.levels[</span><span class="s4">1</span><span class="s1">][</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">removed_level = </span><span class="s5">f'</span><span class="s3">{</span><span class="s1">name</span><span class="s3">} </span><span class="s5">= </span><span class="s3">{</span><span class="s1">value</span><span class="s3">}</span><span class="s5">'</span>
            <span class="s1">impacts.index = tmp_index.droplevel(</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">impacts = impacts.applymap(</span>
                <span class="s3">lambda </span><span class="s1">num: </span><span class="s5">'' </span><span class="s3">if </span><span class="s1">pd.isnull(num) </span><span class="s3">else </span><span class="s1">float_format % num)</span>
            <span class="s1">impacts = impacts.reset_index()</span>
            <span class="s1">impacts.iloc[:</span><span class="s3">, </span><span class="s4">0</span><span class="s1">] = impacts.iloc[:</span><span class="s3">, </span><span class="s4">0</span><span class="s1">].map(str)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">impacts = impacts.reset_index()</span>
            <span class="s1">impacts.iloc[:</span><span class="s3">, </span><span class="s1">:</span><span class="s4">2</span><span class="s1">] = impacts.iloc[:</span><span class="s3">, </span><span class="s1">:</span><span class="s4">2</span><span class="s1">].applymap(str)</span>
            <span class="s1">impacts.iloc[:</span><span class="s3">, </span><span class="s4">2</span><span class="s1">:] = impacts.iloc[:</span><span class="s3">, </span><span class="s4">2</span><span class="s1">:].applymap(</span>
                <span class="s3">lambda </span><span class="s1">num: </span><span class="s5">'' </span><span class="s3">if </span><span class="s1">pd.isnull(num) </span><span class="s3">else </span><span class="s1">float_format % num)</span>

        <span class="s0"># Sparsify the groupby column</span>
        <span class="s3">if </span><span class="s1">sparsify </span><span class="s3">and </span><span class="s1">groupby </span><span class="s3">in </span><span class="s1">impacts:</span>
            <span class="s1">mask = impacts[groupby] == impacts[groupby].shift(</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">tmp = impacts.loc[mask</span><span class="s3">, </span><span class="s1">groupby]</span>
            <span class="s3">if </span><span class="s1">len(tmp) &gt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">impacts.loc[mask</span><span class="s3">, </span><span class="s1">groupby] = </span><span class="s5">''</span>

        <span class="s0"># Drop revisions and totals columns if applicable</span>
        <span class="s3">if not </span><span class="s1">show_revisions_columns:</span>
            <span class="s1">impacts.drop([</span><span class="s5">'impact of revisions'</span><span class="s3">, </span><span class="s5">'total impact'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s3">,</span>
                         <span class="s1">inplace=</span><span class="s3">True</span><span class="s1">)</span>

        <span class="s1">params_data = impacts.values</span>
        <span class="s1">params_header = impacts.columns.tolist()</span>
        <span class="s1">params_stubs = </span><span class="s3">None</span>

        <span class="s1">title = </span><span class="s5">'Impacts'</span>
        <span class="s3">if </span><span class="s1">removed_level </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">join = </span><span class="s5">'on' </span><span class="s3">if </span><span class="s1">groupby == </span><span class="s5">'date' </span><span class="s3">else </span><span class="s5">'for'</span>
            <span class="s1">title += </span><span class="s5">f' </span><span class="s3">{</span><span class="s1">join</span><span class="s3">} </span><span class="s5">[</span><span class="s3">{</span><span class="s1">removed_level</span><span class="s3">}</span><span class="s5">]'</span>
        <span class="s1">impacts_table = SimpleTable(</span>
            <span class="s1">params_data</span><span class="s3">, </span><span class="s1">params_header</span><span class="s3">, </span><span class="s1">params_stubs</span><span class="s3">,</span>
            <span class="s1">txt_fmt=fmt_params</span><span class="s3">, </span><span class="s1">title=title)</span>

        <span class="s3">return </span><span class="s1">impacts_table</span>

    <span class="s3">def </span><span class="s1">summary_details(self</span><span class="s3">, </span><span class="s1">source=</span><span class="s5">'news'</span><span class="s3">, </span><span class="s1">impact_date=</span><span class="s3">None,</span>
                        <span class="s1">impacted_variable=</span><span class="s3">None, </span><span class="s1">update_date=</span><span class="s3">None,</span>
                        <span class="s1">updated_variable=</span><span class="s3">None, </span><span class="s1">groupby=</span><span class="s5">'update date'</span><span class="s3">,</span>
                        <span class="s1">sparsify=</span><span class="s3">True, </span><span class="s1">float_format=</span><span class="s5">'%.2f'</span><span class="s3">,</span>
                        <span class="s1">multiple_tables=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Create summary table with detailed impacts; by date, variable 
 
        Parameters 
        ---------- 
        source : {news, revisions} 
            The source of impacts to summarize. Default is &quot;news&quot;. 
        impact_date : int, str, datetime, list, array, or slice, optional 
            Observation index label or slice of labels specifying particular 
            impact periods to display. The impact date(s) describe the periods 
            in which impacted variables were *affected* by the news. If this 
            argument is given, the output table will only show this impact date 
            or dates. Note that this argument is passed to the Pandas `loc` 
            accessor, and so it should correspond to the labels of the model's 
            index. If the model was created with data in a list or numpy array, 
            then these labels will be zero-indexes observation integers. 
        impacted_variable : str, list, array, or slice, optional 
            Observation variable label or slice of labels specifying particular 
            impacted variables to display. The impacted variable(s) describe 
            the variables that were *affected* by the news. If you do not know 
            the labels for the variables, check the `endog_names` attribute of 
            the model instance. 
        update_date : int, str, datetime, list, array, or slice, optional 
            Observation index label or slice of labels specifying particular 
            updated periods to display. The updated date(s) describe the 
            periods in which the new data points were available that generated 
            the news). See the note on `impact_date` for details about what 
            these labels are. 
        updated_variable : str, list, array, or slice, optional 
            Observation variable label or slice of labels specifying particular 
            updated variables to display. The updated variable(s) describe the 
            variables that were *affected* by the news. If you do not know the 
            labels for the variables, check the `endog_names` attribute of the 
            model instance. 
        groupby : {update date, updated date, impact date, impacted date} 
            The primary variable for grouping results in the details table. The 
            default is to group by update date. 
        sparsify : bool, optional, default True 
            Set to False for the table to include every one of the multiindex 
            keys at each row. 
        float_format : str, optional 
            Formatter format string syntax for converting numbers to strings. 
            Default is '%.2f'. 
        multiple_tables : bool, optional 
            If set to True, this function will return a list of tables, one 
            table for each of the unique `groupby` levels. Default is False, 
            in which case this function returns a single table. 
 
        Returns 
        ------- 
        details_table : SimpleTable or list of SimpleTable 
            Table or list of tables describing how the news from each update 
            (i.e. news from a particular variable / date) translates into 
            changes to the forecasts of each impacted variable variable / date. 
 
            This table contains information about the updates and about the 
            impacts. Updates are newly observed datapoints that were not 
            available in the previous results set. Each update leads to news, 
            and the news may cause changes in the forecasts of the impacted 
            variables. The amount that a particular piece of news (from an 
            update to some variable at some date) impacts a variable at some 
            date depends on weights that can be computed from the model 
            results. 
 
            The data contained in this table that refer to updates are: 
 
            - `update date` : The date at which a new datapoint was added. 
            - `updated variable` : The variable for which a new datapoint was 
              added. 
            - `forecast (prev)` : The value that had been forecast by the 
              previous model for the given updated variable and date. 
            - `observed` : The observed value of the new datapoint. 
            - `news` : The news is the difference between the observed value 
              and the previously forecast value for a given updated variable 
              and date. 
 
            The data contained in this table that refer to impacts are: 
 
            - `impact date` : A date associated with an impact. 
            - `impacted variable` : A variable that was impacted by the news. 
            - `weight` : The weight of news from a given `update date` and 
              `update variable` on a given `impacted variable` at a given 
              `impact date`. 
            - `impact` : The revision to the smoothed estimate / forecast of 
              the impacted variable at the impact date based specifically on 
              the news generated by the `updated variable` at the 
              `update date`. 
 
        See Also 
        -------- 
        details_by_impact 
        details_by_update 
        &quot;&quot;&quot;</span>
        <span class="s0"># Squeeze for univariate models</span>
        <span class="s3">if </span><span class="s1">self.k_endog == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">impacted_variable </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s1">impacted_variable = self.endog_names[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s3">if </span><span class="s1">updated_variable </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s1">updated_variable = self.endog_names[</span><span class="s4">0</span><span class="s1">]</span>

        <span class="s0"># Select only the variables / dates of interest</span>
        <span class="s1">s = list(np.s_[:</span><span class="s3">, </span><span class="s1">:</span><span class="s3">, </span><span class="s1">:</span><span class="s3">, </span><span class="s1">:</span><span class="s3">, </span><span class="s1">:</span><span class="s3">, </span><span class="s1">:])</span>
        <span class="s3">if </span><span class="s1">impact_date </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">s[</span><span class="s4">0</span><span class="s1">] = np.s_[impact_date]</span>
        <span class="s3">if </span><span class="s1">impacted_variable </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">s[</span><span class="s4">1</span><span class="s1">] = np.s_[impacted_variable]</span>
        <span class="s3">if </span><span class="s1">update_date </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">s[</span><span class="s4">2</span><span class="s1">] = np.s_[update_date]</span>
        <span class="s3">if </span><span class="s1">updated_variable </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">s[</span><span class="s4">3</span><span class="s1">] = np.s_[updated_variable]</span>
        <span class="s1">s = tuple(s)</span>

        <span class="s3">if </span><span class="s1">source == </span><span class="s5">'news'</span><span class="s1">:</span>
            <span class="s1">details = self.details_by_impact.loc[s</span><span class="s3">, </span><span class="s1">:]</span>
            <span class="s1">columns = {</span>
                <span class="s5">'current'</span><span class="s1">: </span><span class="s5">'observed'</span><span class="s3">,</span>
                <span class="s5">'prev'</span><span class="s1">: </span><span class="s5">'forecast (prev)'</span><span class="s3">,</span>
                <span class="s5">'update date'</span><span class="s1">: </span><span class="s5">'update date'</span><span class="s3">,</span>
                <span class="s5">'updated variable'</span><span class="s1">: </span><span class="s5">'updated variable'</span><span class="s3">,</span>
                <span class="s5">'news'</span><span class="s1">: </span><span class="s5">'news'</span><span class="s3">,</span>
            <span class="s1">}</span>
        <span class="s3">elif </span><span class="s1">source == </span><span class="s5">'revisions'</span><span class="s1">:</span>
            <span class="s1">details = self.revision_details_by_impact.loc[s</span><span class="s3">, </span><span class="s1">:]</span>
            <span class="s1">columns = {</span>
                <span class="s5">'current'</span><span class="s1">: </span><span class="s5">'revised'</span><span class="s3">,</span>
                <span class="s5">'prev'</span><span class="s1">: </span><span class="s5">'observed (prev)'</span><span class="s3">,</span>
                <span class="s5">'update date'</span><span class="s1">: </span><span class="s5">'revision date'</span><span class="s3">,</span>
                <span class="s5">'updated variable'</span><span class="s1">: </span><span class="s5">'revised variable'</span><span class="s3">,</span>
                <span class="s5">'news'</span><span class="s1">: </span><span class="s5">'revision'</span><span class="s3">,</span>
            <span class="s1">}</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">f'Invalid `source`: </span><span class="s3">{</span><span class="s1">source</span><span class="s3">}</span><span class="s5">. Must be &quot;news&quot; or'</span>
                             <span class="s5">' &quot;impacts&quot;.'</span><span class="s1">)</span>

        <span class="s0"># Make the first index level the groupby level</span>
        <span class="s1">groupby = groupby.lower().replace(</span><span class="s5">'_'</span><span class="s3">, </span><span class="s5">' '</span><span class="s1">)</span>
        <span class="s1">groupby_overall = </span><span class="s5">'impact'</span>
        <span class="s1">levels_order = [</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s1">]</span>
        <span class="s3">if </span><span class="s1">groupby == </span><span class="s5">'update date'</span><span class="s1">:</span>
            <span class="s1">levels_order = [</span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s1">]</span>
            <span class="s1">groupby_overall = </span><span class="s5">'update'</span>
        <span class="s3">elif </span><span class="s1">groupby == </span><span class="s5">'updated variable'</span><span class="s1">:</span>
            <span class="s1">levels_order = [</span><span class="s4">3</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">groupby_overall = </span><span class="s5">'update'</span>
        <span class="s3">elif </span><span class="s1">groupby == </span><span class="s5">'impacted variable'</span><span class="s1">:</span>
            <span class="s1">levels_order = [</span><span class="s4">1</span><span class="s3">, </span><span class="s4">0</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s4">2</span><span class="s1">]</span>
        <span class="s3">elif </span><span class="s1">groupby != </span><span class="s5">'impact date'</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'Invalid groupby for details table. Valid options'</span>
                             <span class="s5">' are &quot;update date&quot;, &quot;updated variable&quot;,'</span>
                             <span class="s5">' &quot;impact date&quot;,or &quot;impacted variable&quot;.'</span>
                             <span class="s5">f' Got &quot;</span><span class="s3">{</span><span class="s1">groupby</span><span class="s3">}</span><span class="s5">&quot;.'</span><span class="s1">)</span>
        <span class="s1">details.index = (details.index.reorder_levels(levels_order)</span>
                                      <span class="s1">.remove_unused_levels())</span>
        <span class="s1">details = details.sort_index()</span>

        <span class="s0"># If our overall group-by is `update`, move forecast (prev) and</span>
        <span class="s0"># observed into the index</span>
        <span class="s1">base_levels = [</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s1">]</span>
        <span class="s3">if </span><span class="s1">groupby_overall == </span><span class="s5">'update'</span><span class="s1">:</span>
            <span class="s1">details.set_index([columns[</span><span class="s5">'current'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">columns[</span><span class="s5">'prev'</span><span class="s1">]]</span><span class="s3">,</span>
                              <span class="s1">append=</span><span class="s3">True, </span><span class="s1">inplace=</span><span class="s3">True</span><span class="s1">)</span>
            <span class="s1">details.index = details.index.reorder_levels([</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">4</span><span class="s3">, </span><span class="s4">5</span><span class="s3">, </span><span class="s4">2</span><span class="s3">, </span><span class="s4">3</span><span class="s1">])</span>
            <span class="s1">base_levels = [</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">4</span><span class="s3">, </span><span class="s4">5</span><span class="s1">]</span>

        <span class="s0"># Drop the non-groupby levels if there's only one value</span>
        <span class="s1">tmp_index = details.index.remove_unused_levels()</span>
        <span class="s1">n_levels = len(tmp_index.levels)</span>
        <span class="s1">k_level_values = [len(tmp_index.levels[i]) </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(n_levels)]</span>
        <span class="s1">removed_levels = []</span>
        <span class="s3">if </span><span class="s1">sparsify:</span>
            <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">sorted(base_levels)[::-</span><span class="s4">1</span><span class="s1">][:-</span><span class="s4">1</span><span class="s1">]:</span>
                <span class="s3">if </span><span class="s1">k_level_values[i] == </span><span class="s4">1</span><span class="s1">:</span>
                    <span class="s1">name = tmp_index.names[i]</span>
                    <span class="s1">value = tmp_index.levels[i][</span><span class="s4">0</span><span class="s1">]</span>
                    <span class="s1">can_drop = (</span>
                        <span class="s1">(name == columns[</span><span class="s5">'update date'</span><span class="s1">]</span>
                            <span class="s3">and </span><span class="s1">update_date </span><span class="s3">is not None</span><span class="s1">) </span><span class="s3">or</span>
                        <span class="s1">(name == columns[</span><span class="s5">'updated variable'</span><span class="s1">]</span>
                            <span class="s3">and </span><span class="s1">updated_variable </span><span class="s3">is not None</span><span class="s1">) </span><span class="s3">or</span>
                        <span class="s1">(name == </span><span class="s5">'impact date'</span>
                            <span class="s3">and </span><span class="s1">impact_date </span><span class="s3">is not None</span><span class="s1">) </span><span class="s3">or</span>
                        <span class="s1">(name == </span><span class="s5">'impacted variable'</span>
                            <span class="s3">and </span><span class="s1">(impacted_variable </span><span class="s3">is not None or</span>
                                 <span class="s1">self.impacted_variable </span><span class="s3">is not None</span><span class="s1">)))</span>
                    <span class="s3">if </span><span class="s1">can_drop </span><span class="s3">or not </span><span class="s1">multiple_tables:</span>
                        <span class="s1">removed_levels.insert(</span><span class="s4">0</span><span class="s3">, </span><span class="s5">f'</span><span class="s3">{</span><span class="s1">name</span><span class="s3">} </span><span class="s5">= </span><span class="s3">{</span><span class="s1">value</span><span class="s3">}</span><span class="s5">'</span><span class="s1">)</span>
                        <span class="s1">details.index = tmp_index = tmp_index.droplevel(i)</span>

        <span class="s0"># Move everything to columns</span>
        <span class="s1">details = details.reset_index()</span>

        <span class="s0"># Function for formatting numbers</span>
        <span class="s3">def </span><span class="s1">str_format(num</span><span class="s3">, </span><span class="s1">mark_ones=</span><span class="s3">False, </span><span class="s1">mark_zeroes=</span><span class="s3">False</span><span class="s1">):</span>
            <span class="s3">if </span><span class="s1">pd.isnull(num):</span>
                <span class="s1">out = </span><span class="s5">''</span>
            <span class="s3">elif </span><span class="s1">mark_ones </span><span class="s3">and </span><span class="s1">np.abs(</span><span class="s4">1 </span><span class="s1">- num) &lt; self.tolerance:</span>
                <span class="s1">out = </span><span class="s5">'1.0'</span>
            <span class="s3">elif </span><span class="s1">mark_zeroes </span><span class="s3">and </span><span class="s1">np.abs(num) &lt; self.tolerance:</span>
                <span class="s1">out = </span><span class="s5">'0'</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">out = float_format % num</span>
            <span class="s3">return </span><span class="s1">out</span>

        <span class="s0"># Function to create the table</span>
        <span class="s3">def </span><span class="s1">create_table(details</span><span class="s3">, </span><span class="s1">removed_levels):</span>
            <span class="s0"># Convert everything to strings</span>
            <span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">[columns[</span><span class="s5">'current'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">columns[</span><span class="s5">'prev'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">columns[</span><span class="s5">'news'</span><span class="s1">]</span><span class="s3">,</span>
                        <span class="s5">'weight'</span><span class="s3">, </span><span class="s5">'impact'</span><span class="s1">]:</span>
                <span class="s3">if </span><span class="s1">key </span><span class="s3">in </span><span class="s1">details:</span>
                    <span class="s1">args = (</span>
                        <span class="s0"># mark_ones</span>
                        <span class="s3">True if </span><span class="s1">key </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'weight'</span><span class="s1">] </span><span class="s3">else False,</span>
                        <span class="s0"># mark_zeroes</span>
                        <span class="s3">True if </span><span class="s1">key </span><span class="s3">in </span><span class="s1">[</span><span class="s5">'weight'</span><span class="s3">, </span><span class="s5">'impact'</span><span class="s1">] </span><span class="s3">else False</span><span class="s1">)</span>
                    <span class="s1">details[key] = details[key].apply(str_format</span><span class="s3">, </span><span class="s1">args=args)</span>
            <span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">[columns[</span><span class="s5">'update date'</span><span class="s1">]</span><span class="s3">, </span><span class="s5">'impact date'</span><span class="s1">]:</span>
                <span class="s3">if </span><span class="s1">key </span><span class="s3">in </span><span class="s1">details:</span>
                    <span class="s1">details[key] = details[key].apply(str)</span>

            <span class="s0"># Sparsify index columns</span>
            <span class="s3">if </span><span class="s1">sparsify:</span>
                <span class="s1">sparsify_cols = [columns[</span><span class="s5">'update date'</span><span class="s1">]</span><span class="s3">,</span>
                                 <span class="s1">columns[</span><span class="s5">'updated variable'</span><span class="s1">]</span><span class="s3">, </span><span class="s5">'impact date'</span><span class="s3">,</span>
                                 <span class="s5">'impacted variable'</span><span class="s1">]</span>
                <span class="s1">data_cols = [columns[</span><span class="s5">'current'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">columns[</span><span class="s5">'prev'</span><span class="s1">]]</span>
                <span class="s3">if </span><span class="s1">groupby_overall == </span><span class="s5">'update'</span><span class="s1">:</span>
                    <span class="s0"># Put data columns first, since we need to do an additional</span>
                    <span class="s0"># check based on the other columns before sparsifying</span>
                    <span class="s1">sparsify_cols = data_cols + sparsify_cols</span>

                <span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">sparsify_cols:</span>
                    <span class="s3">if </span><span class="s1">key </span><span class="s3">in </span><span class="s1">details:</span>
                        <span class="s1">mask = details[key] == details[key].shift(</span><span class="s4">1</span><span class="s1">)</span>
                        <span class="s3">if </span><span class="s1">key </span><span class="s3">in </span><span class="s1">data_cols:</span>
                            <span class="s3">if </span><span class="s1">columns[</span><span class="s5">'update date'</span><span class="s1">] </span><span class="s3">in </span><span class="s1">details:</span>
                                <span class="s1">tmp = details[columns[</span><span class="s5">'update date'</span><span class="s1">]]</span>
                                <span class="s1">mask &amp;= tmp == tmp.shift(</span><span class="s4">1</span><span class="s1">)</span>
                            <span class="s3">if </span><span class="s1">columns[</span><span class="s5">'updated variable'</span><span class="s1">] </span><span class="s3">in </span><span class="s1">details:</span>
                                <span class="s1">tmp = details[columns[</span><span class="s5">'updated variable'</span><span class="s1">]]</span>
                                <span class="s1">mask &amp;= tmp == tmp.shift(</span><span class="s4">1</span><span class="s1">)</span>
                        <span class="s1">details.loc[mask</span><span class="s3">, </span><span class="s1">key] = </span><span class="s5">''</span>

            <span class="s1">params_data = details.values</span>
            <span class="s1">params_header = [str(x) </span><span class="s3">for </span><span class="s1">x </span><span class="s3">in </span><span class="s1">details.columns.tolist()]</span>
            <span class="s1">params_stubs = </span><span class="s3">None</span>

            <span class="s1">title = </span><span class="s5">f&quot;Details of </span><span class="s3">{</span><span class="s1">source</span><span class="s3">}</span><span class="s5">&quot;</span>
            <span class="s3">if </span><span class="s1">len(removed_levels):</span>
                <span class="s1">title += </span><span class="s5">' for [' </span><span class="s1">+ </span><span class="s5">', '</span><span class="s1">.join(removed_levels) + </span><span class="s5">']'</span>
            <span class="s3">return </span><span class="s1">SimpleTable(params_data</span><span class="s3">, </span><span class="s1">params_header</span><span class="s3">, </span><span class="s1">params_stubs</span><span class="s3">,</span>
                               <span class="s1">txt_fmt=fmt_params</span><span class="s3">, </span><span class="s1">title=title)</span>

        <span class="s3">if </span><span class="s1">multiple_tables:</span>
            <span class="s1">details_table = []</span>
            <span class="s3">for </span><span class="s1">item </span><span class="s3">in </span><span class="s1">details[groupby].unique():</span>
                <span class="s1">mask = details[groupby] == item</span>
                <span class="s1">item_details = details[mask].drop(groupby</span><span class="s3">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>
                <span class="s1">item_removed_levels = [</span><span class="s5">f'</span><span class="s3">{</span><span class="s1">groupby</span><span class="s3">} </span><span class="s5">= </span><span class="s3">{</span><span class="s1">item</span><span class="s3">}</span><span class="s5">'</span><span class="s1">] + removed_levels</span>
                <span class="s1">details_table.append(create_table(item_details</span><span class="s3">,</span>
                                                  <span class="s1">item_removed_levels))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">details_table = create_table(details</span><span class="s3">, </span><span class="s1">removed_levels)</span>

        <span class="s3">return </span><span class="s1">details_table</span>

    <span class="s3">def </span><span class="s1">summary_revisions(self</span><span class="s3">, </span><span class="s1">sparsify=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Create summary table showing revisions to the previous results' data 
 
        Parameters 
        ---------- 
        sparsify : bool, optional, default True 
            Set to False for the table to include every one of the multiindex 
            keys at each row. 
 
        Returns 
        ------- 
        revisions_table : SimpleTable 
            Table showing revisions to the previous results' data. Columns are: 
 
            - `revision date` : date associated with a revised data point 
            - `revised variable` : variable that was revised at `revision date` 
            - `observed (prev)` : the observed value prior to the revision 
            - `revised` : the new value after the revision 
            - `revision` : the new value after the revision 
        &quot;&quot;&quot;</span>
        <span class="s1">data = pd.merge(</span>
            <span class="s1">self.data_revisions</span><span class="s3">, </span><span class="s1">self.revisions</span><span class="s3">, </span><span class="s1">left_index=</span><span class="s3">True,</span>
            <span class="s1">right_index=</span><span class="s3">True</span><span class="s1">).sort_index().reset_index()</span>
        <span class="s1">data[[</span><span class="s5">'revision date'</span><span class="s3">, </span><span class="s5">'revised variable'</span><span class="s1">]] = (</span>
            <span class="s1">data[[</span><span class="s5">'revision date'</span><span class="s3">, </span><span class="s5">'revised variable'</span><span class="s1">]].applymap(str))</span>
        <span class="s1">data.iloc[:</span><span class="s3">, </span><span class="s4">2</span><span class="s1">:] = data.iloc[:</span><span class="s3">, </span><span class="s4">2</span><span class="s1">:].applymap(</span>
            <span class="s3">lambda </span><span class="s1">num: </span><span class="s5">'' </span><span class="s3">if </span><span class="s1">pd.isnull(num) </span><span class="s3">else </span><span class="s5">'%.2f' </span><span class="s1">% num)</span>

        <span class="s0"># Sparsify the date column</span>
        <span class="s3">if </span><span class="s1">sparsify:</span>
            <span class="s1">mask = data[</span><span class="s5">'revision date'</span><span class="s1">] == data[</span><span class="s5">'revision date'</span><span class="s1">].shift(</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">data.loc[mask</span><span class="s3">, </span><span class="s5">'revision date'</span><span class="s1">] = </span><span class="s5">''</span>

        <span class="s1">params_data = data.values</span>
        <span class="s1">params_header = data.columns.tolist()</span>
        <span class="s1">params_stubs = </span><span class="s3">None</span>

        <span class="s1">title = </span><span class="s5">'Revisions to dataset:'</span>
        <span class="s1">revisions_table = SimpleTable(</span>
            <span class="s1">params_data</span><span class="s3">, </span><span class="s1">params_header</span><span class="s3">, </span><span class="s1">params_stubs</span><span class="s3">,</span>
            <span class="s1">txt_fmt=fmt_params</span><span class="s3">, </span><span class="s1">title=title)</span>

        <span class="s3">return </span><span class="s1">revisions_table</span>

    <span class="s3">def </span><span class="s1">summary_news(self</span><span class="s3">, </span><span class="s1">sparsify=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Create summary table showing news from new data since previous results 
 
        Parameters 
        ---------- 
        sparsify : bool, optional, default True 
            Set to False for the table to include every one of the multiindex 
            keys at each row. 
 
        Returns 
        ------- 
        updates_table : SimpleTable 
            Table showing new datapoints that were not in the previous results' 
            data. Columns are: 
 
            - `update date` : date associated with a new data point. 
            - `updated variable` : variable for which new data was added at 
              `update date`. 
            - `forecast (prev)` : the forecast value for the updated variable 
              at the update date in the previous results object (i.e. prior to 
              the data being available). 
            - `observed` : the observed value of the new datapoint. 
 
        See Also 
        -------- 
        data_updates 
        &quot;&quot;&quot;</span>
        <span class="s1">data = pd.merge(</span>
            <span class="s1">self.data_updates</span><span class="s3">, </span><span class="s1">self.news</span><span class="s3">, </span><span class="s1">left_index=</span><span class="s3">True,</span>
            <span class="s1">right_index=</span><span class="s3">True</span><span class="s1">).sort_index().reset_index()</span>
        <span class="s1">data[[</span><span class="s5">'update date'</span><span class="s3">, </span><span class="s5">'updated variable'</span><span class="s1">]] = (</span>
            <span class="s1">data[[</span><span class="s5">'update date'</span><span class="s3">, </span><span class="s5">'updated variable'</span><span class="s1">]].applymap(str))</span>
        <span class="s1">data.iloc[:</span><span class="s3">, </span><span class="s4">2</span><span class="s1">:] = data.iloc[:</span><span class="s3">, </span><span class="s4">2</span><span class="s1">:].applymap(</span>
            <span class="s3">lambda </span><span class="s1">num: </span><span class="s5">'' </span><span class="s3">if </span><span class="s1">pd.isnull(num) </span><span class="s3">else </span><span class="s5">'%.2f' </span><span class="s1">% num)</span>

        <span class="s0"># Sparsify the date column</span>
        <span class="s3">if </span><span class="s1">sparsify:</span>
            <span class="s1">mask = data[</span><span class="s5">'update date'</span><span class="s1">] == data[</span><span class="s5">'update date'</span><span class="s1">].shift(</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">data.loc[mask</span><span class="s3">, </span><span class="s5">'update date'</span><span class="s1">] = </span><span class="s5">''</span>

        <span class="s1">params_data = data.values</span>
        <span class="s1">params_header = data.columns.tolist()</span>
        <span class="s1">params_stubs = </span><span class="s3">None</span>

        <span class="s1">title = </span><span class="s5">'News from updated observations:'</span>
        <span class="s1">updates_table = SimpleTable(</span>
            <span class="s1">params_data</span><span class="s3">, </span><span class="s1">params_header</span><span class="s3">, </span><span class="s1">params_stubs</span><span class="s3">,</span>
            <span class="s1">txt_fmt=fmt_params</span><span class="s3">, </span><span class="s1">title=title)</span>

        <span class="s3">return </span><span class="s1">updates_table</span>

    <span class="s3">def </span><span class="s1">summary(self</span><span class="s3">, </span><span class="s1">impact_date=</span><span class="s3">None, </span><span class="s1">impacted_variable=</span><span class="s3">None,</span>
                <span class="s1">update_date=</span><span class="s3">None, </span><span class="s1">updated_variable=</span><span class="s3">None,</span>
                <span class="s1">revision_date=</span><span class="s3">None, </span><span class="s1">revised_variable=</span><span class="s3">None,</span>
                <span class="s1">impacts_groupby=</span><span class="s5">'impact date'</span><span class="s3">, </span><span class="s1">details_groupby=</span><span class="s5">'update date'</span><span class="s3">,</span>
                <span class="s1">show_revisions_columns=</span><span class="s3">None, </span><span class="s1">sparsify=</span><span class="s3">True,</span>
                <span class="s1">include_details_tables=</span><span class="s3">None, </span><span class="s1">include_revisions_tables=</span><span class="s3">False,</span>
                <span class="s1">float_format=</span><span class="s5">'%.2f'</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Create summary tables describing news and impacts 
 
        Parameters 
        ---------- 
        impact_date : int, str, datetime, list, array, or slice, optional 
            Observation index label or slice of labels specifying particular 
            impact periods to display. The impact date(s) describe the periods 
            in which impacted variables were *affected* by the news. If this 
            argument is given, the impact and details tables will only show 
            this impact date or dates. Note that this argument is passed to the 
            Pandas `loc` accessor, and so it should correspond to the labels of 
            the model's index. If the model was created with data in a list or 
            numpy array, then these labels will be zero-indexes observation 
            integers. 
        impacted_variable : str, list, array, or slice, optional 
            Observation variable label or slice of labels specifying particular 
            impacted variables to display. The impacted variable(s) describe 
            the variables that were *affected* by the news. If you do not know 
            the labels for the variables, check the `endog_names` attribute of 
            the model instance. 
        update_date : int, str, datetime, list, array, or slice, optional 
            Observation index label or slice of labels specifying particular 
            updated periods to display. The updated date(s) describe the 
            periods in which the new data points were available that generated 
            the news). See the note on `impact_date` for details about what 
            these labels are. 
        updated_variable : str, list, array, or slice, optional 
            Observation variable label or slice of labels specifying particular 
            updated variables to display. The updated variable(s) describe the 
            variables that newly added in the updated dataset and which 
            generated the news. If you do not know the labels for the 
            variables, check the `endog_names` attribute of the model instance. 
        revision_date : int, str, datetime, list, array, or slice, optional 
            Observation index label or slice of labels specifying particular 
            revision periods to display. The revision date(s) describe the 
            periods in which the data points were revised. See the note on 
            `impact_date` for details about what these labels are. 
        revised_variable : str, list, array, or slice, optional 
            Observation variable label or slice of labels specifying particular 
            revised variables to display. The updated variable(s) describe the 
            variables that were *revised*. If you do not know the labels for 
            the variables, check the `endog_names` attribute of the model 
            instance. 
        impacts_groupby : {impact date, impacted date} 
            The primary variable for grouping results in the impacts table. The 
            default is to group by update date. 
        details_groupby : str 
            One of &quot;update date&quot;, &quot;updated date&quot;, &quot;impact date&quot;, or 
            &quot;impacted date&quot;. The primary variable for grouping results in the 
            details table. Only used if the details tables are included. The 
            default is to group by update date. 
        show_revisions_columns : bool, optional 
            If set to False, the impacts table will not show the impacts from 
            data revisions or the total impacts. Default is to show the 
            revisions and totals columns if any revisions were made and 
            otherwise to hide them. 
        sparsify : bool, optional, default True 
            Set to False for the table to include every one of the multiindex 
            keys at each row. 
        include_details_tables : bool, optional 
            If set to True, the summary will show tables describing the details 
            of how news from specific updates translate into specific impacts. 
            These tables can be very long, particularly in cases where there 
            were many updates and in multivariate models. The default is to 
            show detailed tables only for univariate models. 
        include_revisions_tables : bool, optional 
            If set to True, the summary will show tables describing the 
            revisions and updates that lead to impacts on variables of 
            interest. 
        float_format : str, optional 
            Formatter format string syntax for converting numbers to strings. 
            Default is '%.2f'. 
 
        Returns 
        ------- 
        summary_tables : Summary 
            Summary tables describing news and impacts. Basic tables include: 
 
            - A table with general information about the sample. 
            - A table describing the impacts of revisions and news. 
            - Tables describing revisions in the dataset since the previous 
              results set (unless `include_revisions_tables=False`). 
 
            In univariate models or if `include_details_tables=True`, one or 
            more tables will additionally be included describing the details 
            of how news from specific updates translate into specific impacts. 
 
        See Also 
        -------- 
        summary_impacts 
        summary_details 
        summary_revisions 
        summary_updates 
        &quot;&quot;&quot;</span>
        <span class="s0"># Default for include_details_tables</span>
        <span class="s3">if </span><span class="s1">include_details_tables </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">include_details_tables = (self.k_endog == </span><span class="s4">1</span><span class="s1">)</span>

        <span class="s0"># Model specification results</span>
        <span class="s1">model = self.model.model</span>
        <span class="s1">title = </span><span class="s5">'News'</span>

        <span class="s3">def </span><span class="s1">get_sample(model):</span>
            <span class="s3">if </span><span class="s1">model._index_dates:</span>
                <span class="s1">mask = ~np.isnan(model.endog).all(axis=</span><span class="s4">1</span><span class="s1">)</span>
                <span class="s1">ix = model._index[mask]</span>
                <span class="s1">d = ix[</span><span class="s4">0</span><span class="s1">]</span>
                <span class="s1">sample = [</span><span class="s5">'%s' </span><span class="s1">% d]</span>
                <span class="s1">d = ix[-</span><span class="s4">1</span><span class="s1">]</span>
                <span class="s1">sample += [</span><span class="s5">'- ' </span><span class="s1">+ </span><span class="s5">'%s' </span><span class="s1">% d]</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">sample = [str(</span><span class="s4">0</span><span class="s1">)</span><span class="s3">, </span><span class="s5">' - ' </span><span class="s1">+ str(model.nobs)]</span>

            <span class="s3">return </span><span class="s1">sample</span>
        <span class="s1">previous_sample = get_sample(self.previous.model)</span>
        <span class="s1">revised_sample = get_sample(self.updated.model)</span>

        <span class="s0"># Standardize the model name as a list of str</span>
        <span class="s1">model_name = model.__class__.__name__</span>

        <span class="s0"># Top summary table</span>
        <span class="s1">top_left = [(</span><span class="s5">'Model:'</span><span class="s3">, </span><span class="s1">[model_name])</span><span class="s3">,</span>
                    <span class="s1">(</span><span class="s5">'Date:'</span><span class="s3">, None</span><span class="s1">)</span><span class="s3">,</span>
                    <span class="s1">(</span><span class="s5">'Time:'</span><span class="s3">, None</span><span class="s1">)]</span>
        <span class="s3">if </span><span class="s1">self.state_index </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">k_states_used = len(self.state_index)</span>
            <span class="s3">if </span><span class="s1">k_states_used != self.model.model.k_states:</span>
                <span class="s1">top_left.append((</span><span class="s5">'# of included states:'</span><span class="s3">, </span><span class="s1">[k_states_used]))</span>

        <span class="s1">top_right = [</span>
            <span class="s1">(</span><span class="s5">'Original sample:'</span><span class="s3">, </span><span class="s1">[previous_sample[</span><span class="s4">0</span><span class="s1">]])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s5">''</span><span class="s3">, </span><span class="s1">[previous_sample[</span><span class="s4">1</span><span class="s1">]])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s5">'Update through:'</span><span class="s3">, </span><span class="s1">[revised_sample[</span><span class="s4">1</span><span class="s1">][</span><span class="s4">2</span><span class="s1">:]])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s5">'# of revisions:'</span><span class="s3">, </span><span class="s1">[len(self.revisions_ix)])</span><span class="s3">,</span>
            <span class="s1">(</span><span class="s5">'# of new datapoints:'</span><span class="s3">, </span><span class="s1">[len(self.updates_ix)])]</span>

        <span class="s1">summary = Summary()</span>
        <span class="s1">self.model.endog_names = self.model.model.endog_names</span>
        <span class="s1">summary.add_table_2cols(self</span><span class="s3">, </span><span class="s1">gleft=top_left</span><span class="s3">, </span><span class="s1">gright=top_right</span><span class="s3">,</span>
                                <span class="s1">title=title)</span>
        <span class="s1">table_ix = </span><span class="s4">1</span>

        <span class="s0"># Impact table</span>
        <span class="s1">summary.tables.insert(table_ix</span><span class="s3">, </span><span class="s1">self.summary_impacts(</span>
            <span class="s1">impact_date=impact_date</span><span class="s3">, </span><span class="s1">impacted_variable=impacted_variable</span><span class="s3">,</span>
            <span class="s1">groupby=impacts_groupby</span><span class="s3">,</span>
            <span class="s1">show_revisions_columns=show_revisions_columns</span><span class="s3">, </span><span class="s1">sparsify=sparsify</span><span class="s3">,</span>
            <span class="s1">float_format=float_format))</span>
        <span class="s1">table_ix += </span><span class="s4">1</span>

        <span class="s0"># News table</span>
        <span class="s3">if </span><span class="s1">len(self.updates_iloc) &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">summary.tables.insert(</span>
                <span class="s1">table_ix</span><span class="s3">, </span><span class="s1">self.summary_news(sparsify=sparsify))</span>
            <span class="s1">table_ix += </span><span class="s4">1</span>

        <span class="s0"># Detail tables</span>
        <span class="s1">multiple_tables = (self.k_endog &gt; </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">details_tables = self.summary_details(</span>
            <span class="s1">source=</span><span class="s5">'news'</span><span class="s3">,</span>
            <span class="s1">impact_date=impact_date</span><span class="s3">, </span><span class="s1">impacted_variable=impacted_variable</span><span class="s3">,</span>
            <span class="s1">update_date=update_date</span><span class="s3">, </span><span class="s1">updated_variable=updated_variable</span><span class="s3">,</span>
            <span class="s1">groupby=details_groupby</span><span class="s3">, </span><span class="s1">sparsify=sparsify</span><span class="s3">,</span>
            <span class="s1">float_format=float_format</span><span class="s3">, </span><span class="s1">multiple_tables=multiple_tables)</span>
        <span class="s3">if not </span><span class="s1">multiple_tables:</span>
            <span class="s1">details_tables = [details_tables]</span>

        <span class="s3">if </span><span class="s1">include_details_tables:</span>
            <span class="s3">for </span><span class="s1">table </span><span class="s3">in </span><span class="s1">details_tables:</span>
                <span class="s1">summary.tables.insert(table_ix</span><span class="s3">, </span><span class="s1">table)</span>
                <span class="s1">table_ix += </span><span class="s4">1</span>

        <span class="s0"># Revisions</span>
        <span class="s3">if </span><span class="s1">include_revisions_tables </span><span class="s3">and </span><span class="s1">len(self.revisions_iloc) &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">summary.tables.insert(</span>
                <span class="s1">table_ix</span><span class="s3">, </span><span class="s1">self.summary_revisions(sparsify=sparsify))</span>
            <span class="s1">table_ix += </span><span class="s4">1</span>

            <span class="s0"># Revision detail tables</span>
            <span class="s1">revision_details_tables = self.summary_details(</span>
                <span class="s1">source=</span><span class="s5">'revisions'</span><span class="s3">,</span>
                <span class="s1">impact_date=impact_date</span><span class="s3">, </span><span class="s1">impacted_variable=impacted_variable</span><span class="s3">,</span>
                <span class="s1">update_date=revision_date</span><span class="s3">, </span><span class="s1">updated_variable=revised_variable</span><span class="s3">,</span>
                <span class="s1">groupby=details_groupby</span><span class="s3">, </span><span class="s1">sparsify=sparsify</span><span class="s3">,</span>
                <span class="s1">float_format=float_format</span><span class="s3">, </span><span class="s1">multiple_tables=multiple_tables)</span>
            <span class="s3">if not </span><span class="s1">multiple_tables:</span>
                <span class="s1">revision_details_tables = [revision_details_tables]</span>

            <span class="s3">if </span><span class="s1">include_details_tables:</span>
                <span class="s3">for </span><span class="s1">table </span><span class="s3">in </span><span class="s1">revision_details_tables:</span>
                    <span class="s1">summary.tables.insert(table_ix</span><span class="s3">, </span><span class="s1">table)</span>
                    <span class="s1">table_ix += </span><span class="s4">1</span>

        <span class="s3">return </span><span class="s1">summary</span>

    <span class="s3">def </span><span class="s1">get_details(self</span><span class="s3">, </span><span class="s1">include_revisions=</span><span class="s3">True, </span><span class="s1">include_updates=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s1">details = []</span>
        <span class="s3">if </span><span class="s1">include_updates:</span>
            <span class="s1">details.append(self.details_by_impact.rename(</span>
                <span class="s1">columns={</span><span class="s5">'forecast (prev)'</span><span class="s1">: </span><span class="s5">'previous'</span><span class="s1">}))</span>
        <span class="s3">if </span><span class="s1">include_revisions:</span>
            <span class="s1">tmp = self.revision_details_by_impact.rename_axis(</span>
                <span class="s1">index={</span><span class="s5">'revision date'</span><span class="s1">: </span><span class="s5">'update date'</span><span class="s3">,</span>
                       <span class="s5">'revised variable'</span><span class="s1">: </span><span class="s5">'updated variable'</span><span class="s1">})</span>
            <span class="s1">tmp = tmp.rename(columns={</span><span class="s5">'revised'</span><span class="s1">: </span><span class="s5">'observed'</span><span class="s3">,</span>
                                      <span class="s5">'observed (prev)'</span><span class="s1">: </span><span class="s5">'previous'</span><span class="s3">,</span>
                                      <span class="s5">'revision'</span><span class="s1">: </span><span class="s5">'news'</span><span class="s1">})</span>
            <span class="s1">details.append(tmp)</span>
        <span class="s3">if not </span><span class="s1">(include_updates </span><span class="s3">or </span><span class="s1">include_revisions):</span>
            <span class="s1">details.append(self.details_by_impact.rename(</span>
                <span class="s1">columns={</span><span class="s5">'forecast (prev)'</span><span class="s1">: </span><span class="s5">'previous'</span><span class="s1">}).iloc[:</span><span class="s4">0</span><span class="s1">])</span>

        <span class="s3">return </span><span class="s1">pd.concat(details)</span>

    <span class="s3">def </span><span class="s1">get_impacts(self</span><span class="s3">, </span><span class="s1">groupby=</span><span class="s3">None, </span><span class="s1">include_revisions=</span><span class="s3">True,</span>
                    <span class="s1">include_updates=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s1">details = self.get_details(include_revisions=include_revisions</span><span class="s3">,</span>
                                   <span class="s1">include_updates=include_updates)</span>

        <span class="s1">impacts = details[</span><span class="s5">'impact'</span><span class="s1">].unstack([</span><span class="s5">'impact date'</span><span class="s3">,</span>
                                             <span class="s5">'impacted variable'</span><span class="s1">])</span>

        <span class="s3">if </span><span class="s1">groupby </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">impacts = (impacts.unstack(</span><span class="s5">'update date'</span><span class="s1">)</span>
                              <span class="s1">.groupby(groupby).sum(min_count=</span><span class="s4">1</span><span class="s1">)</span>
                              <span class="s1">.stack(</span><span class="s5">'update date'</span><span class="s1">)</span>
                              <span class="s1">.swaplevel()</span>
                              <span class="s1">.sort_index())</span>

        <span class="s3">return </span><span class="s1">impacts</span>
</pre>
</body>
</html>