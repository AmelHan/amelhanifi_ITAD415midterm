<html>
<head>
<title>test_zeros.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6897bb;}
.s4 { color: #6a8759;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_zeros.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">pytest</span>

<span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">lru_cache</span>

<span class="s0">from </span><span class="s1">numpy.testing </span><span class="s0">import </span><span class="s1">(assert_warns</span><span class="s0">, </span><span class="s1">assert_</span><span class="s0">,</span>
                           <span class="s1">assert_allclose</span><span class="s0">,</span>
                           <span class="s1">assert_equal</span><span class="s0">,</span>
                           <span class="s1">assert_array_equal</span><span class="s0">,</span>
                           <span class="s1">suppress_warnings)</span>
<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">numpy </span><span class="s0">import </span><span class="s1">finfo</span><span class="s0">, </span><span class="s1">power</span><span class="s0">, </span><span class="s1">nan</span><span class="s0">, </span><span class="s1">isclose</span><span class="s0">, </span><span class="s1">sqrt</span><span class="s0">, </span><span class="s1">exp</span><span class="s0">, </span><span class="s1">sin</span><span class="s0">, </span><span class="s1">cos</span>


<span class="s0">from </span><span class="s1">scipy.optimize </span><span class="s0">import </span><span class="s1">(_zeros_py </span><span class="s0">as </span><span class="s1">zeros</span><span class="s0">, </span><span class="s1">newton</span><span class="s0">, </span><span class="s1">root_scalar</span><span class="s0">,</span>
                            <span class="s1">OptimizeResult)</span>

<span class="s0">from </span><span class="s1">scipy._lib._util </span><span class="s0">import </span><span class="s1">getfullargspec_no_self </span><span class="s0">as </span><span class="s1">_getfullargspec</span>

<span class="s2"># Import testing parameters</span>
<span class="s0">from </span><span class="s1">scipy.optimize._tstutils </span><span class="s0">import </span><span class="s1">get_tests</span><span class="s0">, </span><span class="s1">functions </span><span class="s0">as </span><span class="s1">tstutils_functions</span>

<span class="s1">TOL = </span><span class="s3">4</span><span class="s1">*np.finfo(float).eps  </span><span class="s2"># tolerance</span>

<span class="s1">_FLOAT_EPS = finfo(float).eps</span>

<span class="s1">bracket_methods = [zeros.bisect</span><span class="s0">, </span><span class="s1">zeros.ridder</span><span class="s0">, </span><span class="s1">zeros.brentq</span><span class="s0">, </span><span class="s1">zeros.brenth</span><span class="s0">,</span>
                   <span class="s1">zeros.toms748]</span>
<span class="s1">gradient_methods = [zeros.newton]</span>
<span class="s1">all_methods = bracket_methods + gradient_methods  </span><span class="s2"># noqa</span>

<span class="s2"># A few test functions used frequently:</span>
<span class="s2"># # A simple quadratic, (x-1)^2 - 1</span>
<span class="s0">def </span><span class="s1">f1(x):</span>
    <span class="s0">return </span><span class="s1">x ** </span><span class="s3">2 </span><span class="s1">- </span><span class="s3">2 </span><span class="s1">* x - </span><span class="s3">1</span>


<span class="s0">def </span><span class="s1">f1_1(x):</span>
    <span class="s0">return </span><span class="s3">2 </span><span class="s1">* x - </span><span class="s3">2</span>


<span class="s0">def </span><span class="s1">f1_2(x):</span>
    <span class="s0">return </span><span class="s3">2.0 </span><span class="s1">+ </span><span class="s3">0 </span><span class="s1">* x</span>


<span class="s0">def </span><span class="s1">f1_and_p_and_pp(x):</span>
    <span class="s0">return </span><span class="s1">f1(x)</span><span class="s0">, </span><span class="s1">f1_1(x)</span><span class="s0">, </span><span class="s1">f1_2(x)</span>


<span class="s2"># Simple transcendental function</span>
<span class="s0">def </span><span class="s1">f2(x):</span>
    <span class="s0">return </span><span class="s1">exp(x) - cos(x)</span>


<span class="s0">def </span><span class="s1">f2_1(x):</span>
    <span class="s0">return </span><span class="s1">exp(x) + sin(x)</span>


<span class="s0">def </span><span class="s1">f2_2(x):</span>
    <span class="s0">return </span><span class="s1">exp(x) + cos(x)</span>


<span class="s2"># lru cached function</span>
<span class="s1">@lru_cache</span>
<span class="s0">def </span><span class="s1">f_lrucached(x):</span>
    <span class="s0">return </span><span class="s1">x</span>


<span class="s0">class </span><span class="s1">TestScalarRootFinders:</span>
    <span class="s2"># Basic tests for all scalar root finders</span>

    <span class="s1">xtol = </span><span class="s3">4 </span><span class="s1">* np.finfo(float).eps</span>
    <span class="s1">rtol = </span><span class="s3">4 </span><span class="s1">* np.finfo(float).eps</span>

    <span class="s0">def </span><span class="s1">_run_one_test(self</span><span class="s0">, </span><span class="s1">tc</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">sig_args_keys=</span><span class="s0">None,</span>
                      <span class="s1">sig_kwargs_keys=</span><span class="s0">None, </span><span class="s1">**kwargs):</span>
        <span class="s1">method_args = []</span>
        <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">sig_args_keys </span><span class="s0">or </span><span class="s1">[]:</span>
            <span class="s0">if </span><span class="s1">k </span><span class="s0">not in </span><span class="s1">tc:</span>
                <span class="s2"># If a,b not present use x0, x1. Similarly for f and func</span>
                <span class="s1">k = {</span><span class="s4">'a'</span><span class="s1">: </span><span class="s4">'x0'</span><span class="s0">, </span><span class="s4">'b'</span><span class="s1">: </span><span class="s4">'x1'</span><span class="s0">, </span><span class="s4">'func'</span><span class="s1">: </span><span class="s4">'f'</span><span class="s1">}.get(k</span><span class="s0">, </span><span class="s1">k)</span>
            <span class="s1">method_args.append(tc[k])</span>

        <span class="s1">method_kwargs = dict(**kwargs)</span>
        <span class="s1">method_kwargs.update({</span><span class="s4">'full_output'</span><span class="s1">: </span><span class="s0">True, </span><span class="s4">'disp'</span><span class="s1">: </span><span class="s0">False</span><span class="s1">})</span>
        <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">sig_kwargs_keys </span><span class="s0">or </span><span class="s1">[]:</span>
            <span class="s1">method_kwargs[k] = tc[k]</span>

        <span class="s1">root = tc.get(</span><span class="s4">'root'</span><span class="s1">)</span>
        <span class="s1">func_args = tc.get(</span><span class="s4">'args'</span><span class="s0">, </span><span class="s1">())</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">r</span><span class="s0">, </span><span class="s1">rr = method(*method_args</span><span class="s0">, </span><span class="s1">args=func_args</span><span class="s0">, </span><span class="s1">**method_kwargs)</span>
            <span class="s0">return </span><span class="s1">root</span><span class="s0">, </span><span class="s1">rr</span><span class="s0">, </span><span class="s1">tc</span>
        <span class="s0">except </span><span class="s1">Exception:</span>
            <span class="s0">return </span><span class="s1">root</span><span class="s0">, </span><span class="s1">zeros.RootResults(nan</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">zeros._EVALUEERR)</span><span class="s0">, </span><span class="s1">tc</span>

    <span class="s0">def </span><span class="s1">run_tests(self</span><span class="s0">, </span><span class="s1">tests</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">known_fail=</span><span class="s0">None, </span><span class="s1">**kwargs):</span>
        <span class="s5">r&quot;&quot;&quot;Run test-cases using the specified method and the supplied signature. 
 
        Extract the arguments for the method call from the test case 
        dictionary using the supplied keys for the method's signature.&quot;&quot;&quot;</span>
        <span class="s2"># The methods have one of two base signatures:</span>
        <span class="s2"># (f, a, b, **kwargs)  # newton</span>
        <span class="s2"># (func, x0, **kwargs)  # bisect/brentq/...</span>
        <span class="s1">sig = _getfullargspec(method)  </span><span class="s2"># FullArgSpec with args, varargs, varkw, defaults, ...</span>
        <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">sig.kwonlyargs)</span>
        <span class="s1">nDefaults = len(sig.defaults)</span>
        <span class="s1">nRequired = len(sig.args) - nDefaults</span>
        <span class="s1">sig_args_keys = sig.args[:nRequired]</span>
        <span class="s1">sig_kwargs_keys = []</span>
        <span class="s0">if </span><span class="s1">name </span><span class="s0">in </span><span class="s1">[</span><span class="s4">'secant'</span><span class="s0">, </span><span class="s4">'newton'</span><span class="s0">, </span><span class="s4">'halley'</span><span class="s1">]:</span>
            <span class="s0">if </span><span class="s1">name </span><span class="s0">in </span><span class="s1">[</span><span class="s4">'newton'</span><span class="s0">, </span><span class="s4">'halley'</span><span class="s1">]:</span>
                <span class="s1">sig_kwargs_keys.append(</span><span class="s4">'fprime'</span><span class="s1">)</span>
                <span class="s0">if </span><span class="s1">name </span><span class="s0">in </span><span class="s1">[</span><span class="s4">'halley'</span><span class="s1">]:</span>
                    <span class="s1">sig_kwargs_keys.append(</span><span class="s4">'fprime2'</span><span class="s1">)</span>
            <span class="s1">kwargs[</span><span class="s4">'tol'</span><span class="s1">] = self.xtol</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">kwargs[</span><span class="s4">'xtol'</span><span class="s1">] = self.xtol</span>
            <span class="s1">kwargs[</span><span class="s4">'rtol'</span><span class="s1">] = self.rtol</span>

        <span class="s1">results = [list(self._run_one_test(</span>
            <span class="s1">tc</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">sig_args_keys=sig_args_keys</span><span class="s0">,</span>
            <span class="s1">sig_kwargs_keys=sig_kwargs_keys</span><span class="s0">, </span><span class="s1">**kwargs)) </span><span class="s0">for </span><span class="s1">tc </span><span class="s0">in </span><span class="s1">tests]</span>
        <span class="s2"># results= [[true root, full output, tc], ...]</span>

        <span class="s1">known_fail = known_fail </span><span class="s0">or </span><span class="s1">[]</span>
        <span class="s1">notcvgd = [elt </span><span class="s0">for </span><span class="s1">elt </span><span class="s0">in </span><span class="s1">results </span><span class="s0">if not </span><span class="s1">elt[</span><span class="s3">1</span><span class="s1">].converged]</span>
        <span class="s1">notcvgd = [elt </span><span class="s0">for </span><span class="s1">elt </span><span class="s0">in </span><span class="s1">notcvgd </span><span class="s0">if </span><span class="s1">elt[-</span><span class="s3">1</span><span class="s1">][</span><span class="s4">'ID'</span><span class="s1">] </span><span class="s0">not in </span><span class="s1">known_fail]</span>
        <span class="s1">notcvged_IDS = [elt[-</span><span class="s3">1</span><span class="s1">][</span><span class="s4">'ID'</span><span class="s1">] </span><span class="s0">for </span><span class="s1">elt </span><span class="s0">in </span><span class="s1">notcvgd]</span>
        <span class="s1">assert_equal([len(notcvged_IDS)</span><span class="s0">, </span><span class="s1">notcvged_IDS]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s1">[]])</span>

        <span class="s2"># The usable xtol and rtol depend on the test</span>
        <span class="s1">tols = {</span><span class="s4">'xtol'</span><span class="s1">: self.xtol</span><span class="s0">, </span><span class="s4">'rtol'</span><span class="s1">: self.rtol}</span>
        <span class="s1">tols.update(**kwargs)</span>
        <span class="s1">rtol = tols[</span><span class="s4">'rtol'</span><span class="s1">]</span>
        <span class="s1">atol = tols.get(</span><span class="s4">'tol'</span><span class="s0">, </span><span class="s1">tols[</span><span class="s4">'xtol'</span><span class="s1">])</span>

        <span class="s1">cvgd = [elt </span><span class="s0">for </span><span class="s1">elt </span><span class="s0">in </span><span class="s1">results </span><span class="s0">if </span><span class="s1">elt[</span><span class="s3">1</span><span class="s1">].converged]</span>
        <span class="s1">approx = [elt[</span><span class="s3">1</span><span class="s1">].root </span><span class="s0">for </span><span class="s1">elt </span><span class="s0">in </span><span class="s1">cvgd]</span>
        <span class="s1">correct = [elt[</span><span class="s3">0</span><span class="s1">] </span><span class="s0">for </span><span class="s1">elt </span><span class="s0">in </span><span class="s1">cvgd]</span>
        <span class="s2"># See if the root matches the reference value</span>
        <span class="s1">notclose = [[a] + elt </span><span class="s0">for </span><span class="s1">a</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">elt </span><span class="s0">in </span><span class="s1">zip(approx</span><span class="s0">, </span><span class="s1">correct</span><span class="s0">, </span><span class="s1">cvgd) </span><span class="s0">if</span>
                    <span class="s0">not </span><span class="s1">isclose(a</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">rtol=rtol</span><span class="s0">, </span><span class="s1">atol=atol)</span>
                    <span class="s0">and </span><span class="s1">elt[-</span><span class="s3">1</span><span class="s1">][</span><span class="s4">'ID'</span><span class="s1">] </span><span class="s0">not in </span><span class="s1">known_fail]</span>
        <span class="s2"># If not, evaluate the function and see if is 0 at the purported root</span>
        <span class="s1">fvs = [tc[</span><span class="s4">'f'</span><span class="s1">](aroot</span><span class="s0">, </span><span class="s1">*tc.get(</span><span class="s4">'args'</span><span class="s0">, </span><span class="s1">tuple()))</span>
               <span class="s0">for </span><span class="s1">aroot</span><span class="s0">, </span><span class="s1">c</span><span class="s0">, </span><span class="s1">fullout</span><span class="s0">, </span><span class="s1">tc </span><span class="s0">in </span><span class="s1">notclose]</span>
        <span class="s1">notclose = [[fv] + elt </span><span class="s0">for </span><span class="s1">fv</span><span class="s0">, </span><span class="s1">elt </span><span class="s0">in </span><span class="s1">zip(fvs</span><span class="s0">, </span><span class="s1">notclose) </span><span class="s0">if </span><span class="s1">fv != </span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">assert_equal([notclose</span><span class="s0">, </span><span class="s1">len(notclose)]</span><span class="s0">, </span><span class="s1">[[]</span><span class="s0">, </span><span class="s3">0</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">run_collection(self</span><span class="s0">, </span><span class="s1">collection</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">smoothness=</span><span class="s0">None,</span>
                       <span class="s1">known_fail=</span><span class="s0">None, </span><span class="s1">**kwargs):</span>
        <span class="s5">r&quot;&quot;&quot;Run a collection of tests using the specified method. 
 
        The name is used to determine some optional arguments.&quot;&quot;&quot;</span>
        <span class="s1">tests = get_tests(collection</span><span class="s0">, </span><span class="s1">smoothness=smoothness)</span>
        <span class="s1">self.run_tests(tests</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">known_fail=known_fail</span><span class="s0">, </span><span class="s1">**kwargs)</span>


<span class="s0">class </span><span class="s1">TestBracketMethods(TestScalarRootFinders):</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">'method'</span><span class="s0">, </span><span class="s1">bracket_methods)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">'function'</span><span class="s0">, </span><span class="s1">tstutils_functions)</span>
    <span class="s0">def </span><span class="s1">test_basic_root_scalar(self</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">function):</span>
        <span class="s2"># Tests bracketing root finders called via `root_scalar` on a small</span>
        <span class="s2"># set of simple problems, each of which has a root at `x=1`. Checks for</span>
        <span class="s2"># converged status and that the root was found.</span>
        <span class="s1">a</span><span class="s0">, </span><span class="s1">b = </span><span class="s3">.5</span><span class="s0">, </span><span class="s1">sqrt(</span><span class="s3">3</span><span class="s1">)</span>

        <span class="s1">r = root_scalar(function</span><span class="s0">, </span><span class="s1">method=method.__name__</span><span class="s0">, </span><span class="s1">bracket=[a</span><span class="s0">, </span><span class="s1">b]</span><span class="s0">, </span><span class="s1">x0=a</span><span class="s0">,</span>
                        <span class="s1">xtol=self.xtol</span><span class="s0">, </span><span class="s1">rtol=self.rtol)</span>
        <span class="s0">assert </span><span class="s1">r.converged</span>
        <span class="s1">assert_allclose(r.root</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">atol=self.xtol</span><span class="s0">, </span><span class="s1">rtol=self.rtol)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">'method'</span><span class="s0">, </span><span class="s1">bracket_methods)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">'function'</span><span class="s0">, </span><span class="s1">tstutils_functions)</span>
    <span class="s0">def </span><span class="s1">test_basic_individual(self</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">function):</span>
        <span class="s2"># Tests individual bracketing root finders on a small set of simple</span>
        <span class="s2"># problems, each of which has a root at `x=1`. Checks for converged</span>
        <span class="s2"># status and that the root was found.</span>
        <span class="s1">a</span><span class="s0">, </span><span class="s1">b = </span><span class="s3">.5</span><span class="s0">, </span><span class="s1">sqrt(</span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">root</span><span class="s0">, </span><span class="s1">r = method(function</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">xtol=self.xtol</span><span class="s0">, </span><span class="s1">rtol=self.rtol</span><span class="s0">,</span>
                         <span class="s1">full_output=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s0">assert </span><span class="s1">r.converged</span>
        <span class="s1">assert_allclose(root</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">atol=self.xtol</span><span class="s0">, </span><span class="s1">rtol=self.rtol)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">'method'</span><span class="s0">, </span><span class="s1">bracket_methods)</span>
    <span class="s0">def </span><span class="s1">test_aps_collection(self</span><span class="s0">, </span><span class="s1">method):</span>
        <span class="s1">self.run_collection(</span><span class="s4">'aps'</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">method.__name__</span><span class="s0">, </span><span class="s1">smoothness=</span><span class="s3">1</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">'method'</span><span class="s0">, </span><span class="s1">[zeros.bisect</span><span class="s0">, </span><span class="s1">zeros.ridder</span><span class="s0">,</span>
                                        <span class="s1">zeros.toms748])</span>
    <span class="s0">def </span><span class="s1">test_chandrupatla_collection(self</span><span class="s0">, </span><span class="s1">method):</span>
        <span class="s1">known_fail = {</span><span class="s4">'fun7.4'</span><span class="s1">} </span><span class="s0">if </span><span class="s1">method == zeros.ridder </span><span class="s0">else </span><span class="s1">{}</span>
        <span class="s1">self.run_collection(</span><span class="s4">'chandrupatla'</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">method.__name__</span><span class="s0">,</span>
                            <span class="s1">known_fail=known_fail)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">'method'</span><span class="s0">, </span><span class="s1">bracket_methods)</span>
    <span class="s0">def </span><span class="s1">test_lru_cached_individual(self</span><span class="s0">, </span><span class="s1">method):</span>
        <span class="s2"># check that https://github.com/scipy/scipy/issues/10846 is fixed</span>
        <span class="s2"># (`root_scalar` failed when passed a function that was `@lru_cache`d)</span>
        <span class="s1">a</span><span class="s0">, </span><span class="s1">b = -</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span>
        <span class="s1">root</span><span class="s0">, </span><span class="s1">r = method(f_lrucached</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">full_output=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">r.converged</span>
        <span class="s1">assert_allclose(root</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestNewton(TestScalarRootFinders):</span>
    <span class="s0">def </span><span class="s1">test_newton_collections(self):</span>
        <span class="s1">known_fail = [</span><span class="s4">'aps.13.00'</span><span class="s1">]</span>
        <span class="s1">known_fail += [</span><span class="s4">'aps.12.05'</span><span class="s0">, </span><span class="s4">'aps.12.17'</span><span class="s1">]  </span><span class="s2"># fails under Windows Py27</span>
        <span class="s0">for </span><span class="s1">collection </span><span class="s0">in </span><span class="s1">[</span><span class="s4">'aps'</span><span class="s0">, </span><span class="s4">'complex'</span><span class="s1">]:</span>
            <span class="s1">self.run_collection(collection</span><span class="s0">, </span><span class="s1">zeros.newton</span><span class="s0">, </span><span class="s4">'newton'</span><span class="s0">,</span>
                                <span class="s1">smoothness=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">known_fail=known_fail)</span>

    <span class="s0">def </span><span class="s1">test_halley_collections(self):</span>
        <span class="s1">known_fail = [</span><span class="s4">'aps.12.06'</span><span class="s0">, </span><span class="s4">'aps.12.07'</span><span class="s0">, </span><span class="s4">'aps.12.08'</span><span class="s0">, </span><span class="s4">'aps.12.09'</span><span class="s0">,</span>
                      <span class="s4">'aps.12.10'</span><span class="s0">, </span><span class="s4">'aps.12.11'</span><span class="s0">, </span><span class="s4">'aps.12.12'</span><span class="s0">, </span><span class="s4">'aps.12.13'</span><span class="s0">,</span>
                      <span class="s4">'aps.12.14'</span><span class="s0">, </span><span class="s4">'aps.12.15'</span><span class="s0">, </span><span class="s4">'aps.12.16'</span><span class="s0">, </span><span class="s4">'aps.12.17'</span><span class="s0">,</span>
                      <span class="s4">'aps.12.18'</span><span class="s0">, </span><span class="s4">'aps.13.00'</span><span class="s1">]</span>
        <span class="s0">for </span><span class="s1">collection </span><span class="s0">in </span><span class="s1">[</span><span class="s4">'aps'</span><span class="s0">, </span><span class="s4">'complex'</span><span class="s1">]:</span>
            <span class="s1">self.run_collection(collection</span><span class="s0">, </span><span class="s1">zeros.newton</span><span class="s0">, </span><span class="s4">'halley'</span><span class="s0">,</span>
                                <span class="s1">smoothness=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">known_fail=known_fail)</span>

    <span class="s0">def </span><span class="s1">test_newton(self):</span>
        <span class="s0">for </span><span class="s1">f</span><span class="s0">, </span><span class="s1">f_1</span><span class="s0">, </span><span class="s1">f_2 </span><span class="s0">in </span><span class="s1">[(f1</span><span class="s0">, </span><span class="s1">f1_1</span><span class="s0">, </span><span class="s1">f1_2)</span><span class="s0">, </span><span class="s1">(f2</span><span class="s0">, </span><span class="s1">f2_1</span><span class="s0">, </span><span class="s1">f2_2)]:</span>
            <span class="s1">x = zeros.newton(f</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s1">tol=</span><span class="s3">1e-6</span><span class="s1">)</span>
            <span class="s1">assert_allclose(f(x)</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-6</span><span class="s1">)</span>
            <span class="s1">x = zeros.newton(f</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s1">x1=</span><span class="s3">5</span><span class="s0">, </span><span class="s1">tol=</span><span class="s3">1e-6</span><span class="s1">)  </span><span class="s2"># secant, x0 and x1</span>
            <span class="s1">assert_allclose(f(x)</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-6</span><span class="s1">)</span>
            <span class="s1">x = zeros.newton(f</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s1">fprime=f_1</span><span class="s0">, </span><span class="s1">tol=</span><span class="s3">1e-6</span><span class="s1">)   </span><span class="s2"># newton</span>
            <span class="s1">assert_allclose(f(x)</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-6</span><span class="s1">)</span>
            <span class="s1">x = zeros.newton(f</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s1">fprime=f_1</span><span class="s0">, </span><span class="s1">fprime2=f_2</span><span class="s0">, </span><span class="s1">tol=</span><span class="s3">1e-6</span><span class="s1">)  </span><span class="s2"># halley</span>
            <span class="s1">assert_allclose(f(x)</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-6</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_newton_by_name(self):</span>
        <span class="s5">r&quot;&quot;&quot;Invoke newton through root_scalar()&quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">f</span><span class="s0">, </span><span class="s1">f_1</span><span class="s0">, </span><span class="s1">f_2 </span><span class="s0">in </span><span class="s1">[(f1</span><span class="s0">, </span><span class="s1">f1_1</span><span class="s0">, </span><span class="s1">f1_2)</span><span class="s0">, </span><span class="s1">(f2</span><span class="s0">, </span><span class="s1">f2_1</span><span class="s0">, </span><span class="s1">f2_2)]:</span>
            <span class="s1">r = root_scalar(f</span><span class="s0">, </span><span class="s1">method=</span><span class="s4">'newton'</span><span class="s0">, </span><span class="s1">x0=</span><span class="s3">3</span><span class="s0">, </span><span class="s1">fprime=f_1</span><span class="s0">, </span><span class="s1">xtol=</span><span class="s3">1e-6</span><span class="s1">)</span>
            <span class="s1">assert_allclose(f(r.root)</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-6</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">f</span><span class="s0">, </span><span class="s1">f_1</span><span class="s0">, </span><span class="s1">f_2 </span><span class="s0">in </span><span class="s1">[(f1</span><span class="s0">, </span><span class="s1">f1_1</span><span class="s0">, </span><span class="s1">f1_2)</span><span class="s0">, </span><span class="s1">(f2</span><span class="s0">, </span><span class="s1">f2_1</span><span class="s0">, </span><span class="s1">f2_2)]:</span>
            <span class="s1">r = root_scalar(f</span><span class="s0">, </span><span class="s1">method=</span><span class="s4">'newton'</span><span class="s0">, </span><span class="s1">x0=</span><span class="s3">3</span><span class="s0">, </span><span class="s1">xtol=</span><span class="s3">1e-6</span><span class="s1">)  </span><span class="s2"># without f'</span>
            <span class="s1">assert_allclose(f(r.root)</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-6</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_secant_by_name(self):</span>
        <span class="s5">r&quot;&quot;&quot;Invoke secant through root_scalar()&quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">f</span><span class="s0">, </span><span class="s1">f_1</span><span class="s0">, </span><span class="s1">f_2 </span><span class="s0">in </span><span class="s1">[(f1</span><span class="s0">, </span><span class="s1">f1_1</span><span class="s0">, </span><span class="s1">f1_2)</span><span class="s0">, </span><span class="s1">(f2</span><span class="s0">, </span><span class="s1">f2_1</span><span class="s0">, </span><span class="s1">f2_2)]:</span>
            <span class="s1">r = root_scalar(f</span><span class="s0">, </span><span class="s1">method=</span><span class="s4">'secant'</span><span class="s0">, </span><span class="s1">x0=</span><span class="s3">3</span><span class="s0">, </span><span class="s1">x1=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">xtol=</span><span class="s3">1e-6</span><span class="s1">)</span>
            <span class="s1">assert_allclose(f(r.root)</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-6</span><span class="s1">)</span>
            <span class="s1">r = root_scalar(f</span><span class="s0">, </span><span class="s1">method=</span><span class="s4">'secant'</span><span class="s0">, </span><span class="s1">x0=</span><span class="s3">3</span><span class="s0">, </span><span class="s1">x1=</span><span class="s3">5</span><span class="s0">, </span><span class="s1">xtol=</span><span class="s3">1e-6</span><span class="s1">)</span>
            <span class="s1">assert_allclose(f(r.root)</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-6</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">f</span><span class="s0">, </span><span class="s1">f_1</span><span class="s0">, </span><span class="s1">f_2 </span><span class="s0">in </span><span class="s1">[(f1</span><span class="s0">, </span><span class="s1">f1_1</span><span class="s0">, </span><span class="s1">f1_2)</span><span class="s0">, </span><span class="s1">(f2</span><span class="s0">, </span><span class="s1">f2_1</span><span class="s0">, </span><span class="s1">f2_2)]:</span>
            <span class="s1">r = root_scalar(f</span><span class="s0">, </span><span class="s1">method=</span><span class="s4">'secant'</span><span class="s0">, </span><span class="s1">x0=</span><span class="s3">3</span><span class="s0">, </span><span class="s1">xtol=</span><span class="s3">1e-6</span><span class="s1">)  </span><span class="s2"># without x1</span>
            <span class="s1">assert_allclose(f(r.root)</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-6</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_halley_by_name(self):</span>
        <span class="s5">r&quot;&quot;&quot;Invoke halley through root_scalar()&quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">f</span><span class="s0">, </span><span class="s1">f_1</span><span class="s0">, </span><span class="s1">f_2 </span><span class="s0">in </span><span class="s1">[(f1</span><span class="s0">, </span><span class="s1">f1_1</span><span class="s0">, </span><span class="s1">f1_2)</span><span class="s0">, </span><span class="s1">(f2</span><span class="s0">, </span><span class="s1">f2_1</span><span class="s0">, </span><span class="s1">f2_2)]:</span>
            <span class="s1">r = root_scalar(f</span><span class="s0">, </span><span class="s1">method=</span><span class="s4">'halley'</span><span class="s0">, </span><span class="s1">x0=</span><span class="s3">3</span><span class="s0">,</span>
                            <span class="s1">fprime=f_1</span><span class="s0">, </span><span class="s1">fprime2=f_2</span><span class="s0">, </span><span class="s1">xtol=</span><span class="s3">1e-6</span><span class="s1">)</span>
            <span class="s1">assert_allclose(f(r.root)</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-6</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_root_scalar_fail(self):</span>
        <span class="s1">message = </span><span class="s4">'fprime2 must be specified for halley'</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=message):</span>
            <span class="s1">root_scalar(f1</span><span class="s0">, </span><span class="s1">method=</span><span class="s4">'halley'</span><span class="s0">, </span><span class="s1">fprime=f1_1</span><span class="s0">, </span><span class="s1">x0=</span><span class="s3">3</span><span class="s0">, </span><span class="s1">xtol=</span><span class="s3">1e-6</span><span class="s1">)  </span><span class="s2"># no fprime2</span>
        <span class="s1">message = </span><span class="s4">'fprime must be specified for halley'</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=message):</span>
            <span class="s1">root_scalar(f1</span><span class="s0">, </span><span class="s1">method=</span><span class="s4">'halley'</span><span class="s0">, </span><span class="s1">fprime2=f1_2</span><span class="s0">, </span><span class="s1">x0=</span><span class="s3">3</span><span class="s0">, </span><span class="s1">xtol=</span><span class="s3">1e-6</span><span class="s1">)  </span><span class="s2"># no fprime</span>

    <span class="s0">def </span><span class="s1">test_array_newton(self):</span>
        <span class="s5">&quot;&quot;&quot;test newton with array&quot;&quot;&quot;</span>

        <span class="s0">def </span><span class="s1">f1(x</span><span class="s0">, </span><span class="s1">*a):</span>
            <span class="s1">b = a[</span><span class="s3">0</span><span class="s1">] + x * a[</span><span class="s3">3</span><span class="s1">]</span>
            <span class="s0">return </span><span class="s1">a[</span><span class="s3">1</span><span class="s1">] - a[</span><span class="s3">2</span><span class="s1">] * (np.exp(b / a[</span><span class="s3">5</span><span class="s1">]) - </span><span class="s3">1.0</span><span class="s1">) - b / a[</span><span class="s3">4</span><span class="s1">] - x</span>

        <span class="s0">def </span><span class="s1">f1_1(x</span><span class="s0">, </span><span class="s1">*a):</span>
            <span class="s1">b = a[</span><span class="s3">3</span><span class="s1">] / a[</span><span class="s3">5</span><span class="s1">]</span>
            <span class="s0">return </span><span class="s1">-a[</span><span class="s3">2</span><span class="s1">] * np.exp(a[</span><span class="s3">0</span><span class="s1">] / a[</span><span class="s3">5</span><span class="s1">] + x * b) * b - a[</span><span class="s3">3</span><span class="s1">] / a[</span><span class="s3">4</span><span class="s1">] - </span><span class="s3">1</span>

        <span class="s0">def </span><span class="s1">f1_2(x</span><span class="s0">, </span><span class="s1">*a):</span>
            <span class="s1">b = a[</span><span class="s3">3</span><span class="s1">] / a[</span><span class="s3">5</span><span class="s1">]</span>
            <span class="s0">return </span><span class="s1">-a[</span><span class="s3">2</span><span class="s1">] * np.exp(a[</span><span class="s3">0</span><span class="s1">] / a[</span><span class="s3">5</span><span class="s1">] + x * b) * b**</span><span class="s3">2</span>

        <span class="s1">a0 = np.array([</span>
            <span class="s3">5.32725221</span><span class="s0">, </span><span class="s3">5.48673747</span><span class="s0">, </span><span class="s3">5.49539973</span><span class="s0">,</span>
            <span class="s3">5.36387202</span><span class="s0">, </span><span class="s3">4.80237316</span><span class="s0">, </span><span class="s3">1.43764452</span><span class="s0">,</span>
            <span class="s3">5.23063958</span><span class="s0">, </span><span class="s3">5.46094772</span><span class="s0">, </span><span class="s3">5.50512718</span><span class="s0">,</span>
            <span class="s3">5.42046290</span>
        <span class="s1">])</span>
        <span class="s1">a1 = (np.sin(range(</span><span class="s3">10</span><span class="s1">)) + </span><span class="s3">1.0</span><span class="s1">) * </span><span class="s3">7.0</span>
        <span class="s1">args = (a0</span><span class="s0">, </span><span class="s1">a1</span><span class="s0">, </span><span class="s3">1e-09</span><span class="s0">, </span><span class="s3">0.004</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s3">0.27456</span><span class="s1">)</span>
        <span class="s1">x0 = [</span><span class="s3">7.0</span><span class="s1">] * </span><span class="s3">10</span>
        <span class="s1">x = zeros.newton(f1</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">, </span><span class="s1">f1_1</span><span class="s0">, </span><span class="s1">args)</span>
        <span class="s1">x_expected = (</span>
            <span class="s3">6.17264965</span><span class="s0">, </span><span class="s3">11.7702805</span><span class="s0">, </span><span class="s3">12.2219954</span><span class="s0">,</span>
            <span class="s3">7.11017681</span><span class="s0">, </span><span class="s3">1.18151293</span><span class="s0">, </span><span class="s3">0.143707955</span><span class="s0">,</span>
            <span class="s3">4.31928228</span><span class="s0">, </span><span class="s3">10.5419107</span><span class="s0">, </span><span class="s3">12.7552490</span><span class="s0">,</span>
            <span class="s3">8.91225749</span>
        <span class="s1">)</span>
        <span class="s1">assert_allclose(x</span><span class="s0">, </span><span class="s1">x_expected)</span>
        <span class="s2"># test halley's</span>
        <span class="s1">x = zeros.newton(f1</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">, </span><span class="s1">f1_1</span><span class="s0">, </span><span class="s1">args</span><span class="s0">, </span><span class="s1">fprime2=f1_2)</span>
        <span class="s1">assert_allclose(x</span><span class="s0">, </span><span class="s1">x_expected)</span>
        <span class="s2"># test secant</span>
        <span class="s1">x = zeros.newton(f1</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">, </span><span class="s1">args=args)</span>
        <span class="s1">assert_allclose(x</span><span class="s0">, </span><span class="s1">x_expected)</span>

    <span class="s0">def </span><span class="s1">test_array_newton_complex(self):</span>
        <span class="s0">def </span><span class="s1">f(x):</span>
            <span class="s0">return </span><span class="s1">x + </span><span class="s3">1</span><span class="s1">+</span><span class="s3">1j</span>

        <span class="s0">def </span><span class="s1">fprime(x):</span>
            <span class="s0">return </span><span class="s3">1.0</span>

        <span class="s1">t = np.full(</span><span class="s3">4</span><span class="s0">, </span><span class="s3">1j</span><span class="s1">)</span>
        <span class="s1">x = zeros.newton(f</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">fprime=fprime)</span>
        <span class="s1">assert_allclose(f(x)</span><span class="s0">, </span><span class="s3">0.</span><span class="s1">)</span>

        <span class="s2"># should work even if x0 is not complex</span>
        <span class="s1">t = np.ones(</span><span class="s3">4</span><span class="s1">)</span>
        <span class="s1">x = zeros.newton(f</span><span class="s0">, </span><span class="s1">t</span><span class="s0">, </span><span class="s1">fprime=fprime)</span>
        <span class="s1">assert_allclose(f(x)</span><span class="s0">, </span><span class="s3">0.</span><span class="s1">)</span>

        <span class="s1">x = zeros.newton(f</span><span class="s0">, </span><span class="s1">t)</span>
        <span class="s1">assert_allclose(f(x)</span><span class="s0">, </span><span class="s3">0.</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_array_secant_active_zero_der(self):</span>
        <span class="s5">&quot;&quot;&quot;test secant doesn't continue to iterate zero derivatives&quot;&quot;&quot;</span>
        <span class="s1">x = zeros.newton(</span><span class="s0">lambda </span><span class="s1">x</span><span class="s0">, </span><span class="s1">*a: x*x - a[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x0=[</span><span class="s3">4.123</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]</span><span class="s0">,</span>
                         <span class="s1">args=[np.array([</span><span class="s3">17</span><span class="s0">, </span><span class="s3">25</span><span class="s1">])])</span>
        <span class="s1">assert_allclose(x</span><span class="s0">, </span><span class="s1">(</span><span class="s3">4.123105625617661</span><span class="s0">, </span><span class="s3">5.0</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_array_newton_integers(self):</span>
        <span class="s2"># test secant with float</span>
        <span class="s1">x = zeros.newton(</span><span class="s0">lambda </span><span class="s1">y</span><span class="s0">, </span><span class="s1">z: z - y ** </span><span class="s3">2</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4.0</span><span class="s1">] * </span><span class="s3">2</span><span class="s0">,</span>
                         <span class="s1">args=([</span><span class="s3">15.0</span><span class="s0">, </span><span class="s3">17.0</span><span class="s1">]</span><span class="s0">,</span><span class="s1">))</span>
        <span class="s1">assert_allclose(x</span><span class="s0">, </span><span class="s1">(</span><span class="s3">3.872983346207417</span><span class="s0">, </span><span class="s3">4.123105625617661</span><span class="s1">))</span>
        <span class="s2"># test integer becomes float</span>
        <span class="s1">x = zeros.newton(</span><span class="s0">lambda </span><span class="s1">y</span><span class="s0">, </span><span class="s1">z: z - y ** </span><span class="s3">2</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4</span><span class="s1">] * </span><span class="s3">2</span><span class="s0">, </span><span class="s1">args=([</span><span class="s3">15</span><span class="s0">, </span><span class="s3">17</span><span class="s1">]</span><span class="s0">,</span><span class="s1">))</span>
        <span class="s1">assert_allclose(x</span><span class="s0">, </span><span class="s1">(</span><span class="s3">3.872983346207417</span><span class="s0">, </span><span class="s3">4.123105625617661</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_array_newton_zero_der_failures(self):</span>
        <span class="s2"># test derivative zero warning</span>
        <span class="s1">assert_warns(RuntimeWarning</span><span class="s0">, </span><span class="s1">zeros.newton</span><span class="s0">,</span>
                     <span class="s0">lambda </span><span class="s1">y: y**</span><span class="s3">2 </span><span class="s1">- </span><span class="s3">2</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0.</span><span class="s0">, </span><span class="s3">0.</span><span class="s1">]</span><span class="s0">, lambda </span><span class="s1">y: </span><span class="s3">2 </span><span class="s1">* y)</span>
        <span class="s2"># test failures and zero_der</span>
        <span class="s0">with </span><span class="s1">pytest.warns(RuntimeWarning):</span>
            <span class="s1">results = zeros.newton(</span><span class="s0">lambda </span><span class="s1">y: y**</span><span class="s3">2 </span><span class="s1">- </span><span class="s3">2</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0.</span><span class="s0">, </span><span class="s3">0.</span><span class="s1">]</span><span class="s0">,</span>
                                   <span class="s0">lambda </span><span class="s1">y: </span><span class="s3">2</span><span class="s1">*y</span><span class="s0">, </span><span class="s1">full_output=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s1">assert_allclose(results.root</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
            <span class="s0">assert </span><span class="s1">results.zero_der.all()</span>
            <span class="s0">assert not </span><span class="s1">results.converged.any()</span>

    <span class="s0">def </span><span class="s1">test_newton_combined(self):</span>
        <span class="s0">def </span><span class="s1">f1(x):</span>
            <span class="s0">return </span><span class="s1">x ** </span><span class="s3">2 </span><span class="s1">- </span><span class="s3">2 </span><span class="s1">* x - </span><span class="s3">1</span>
        <span class="s0">def </span><span class="s1">f1_1(x):</span>
            <span class="s0">return </span><span class="s3">2 </span><span class="s1">* x - </span><span class="s3">2</span>
        <span class="s0">def </span><span class="s1">f1_2(x):</span>
            <span class="s0">return </span><span class="s3">2.0 </span><span class="s1">+ </span><span class="s3">0 </span><span class="s1">* x</span>

        <span class="s0">def </span><span class="s1">f1_and_p_and_pp(x):</span>
            <span class="s0">return </span><span class="s1">x**</span><span class="s3">2 </span><span class="s1">- </span><span class="s3">2</span><span class="s1">*x-</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">*x-</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2.0</span>

        <span class="s1">sol0 = root_scalar(f1</span><span class="s0">, </span><span class="s1">method=</span><span class="s4">'newton'</span><span class="s0">, </span><span class="s1">x0=</span><span class="s3">3</span><span class="s0">, </span><span class="s1">fprime=f1_1)</span>
        <span class="s1">sol = root_scalar(f1_and_p_and_pp</span><span class="s0">, </span><span class="s1">method=</span><span class="s4">'newton'</span><span class="s0">, </span><span class="s1">x0=</span><span class="s3">3</span><span class="s0">, </span><span class="s1">fprime=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">assert_allclose(sol0.root</span><span class="s0">, </span><span class="s1">sol.root</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-8</span><span class="s1">)</span>
        <span class="s1">assert_equal(</span><span class="s3">2</span><span class="s1">*sol.function_calls</span><span class="s0">, </span><span class="s1">sol0.function_calls)</span>

        <span class="s1">sol0 = root_scalar(f1</span><span class="s0">, </span><span class="s1">method=</span><span class="s4">'halley'</span><span class="s0">, </span><span class="s1">x0=</span><span class="s3">3</span><span class="s0">, </span><span class="s1">fprime=f1_1</span><span class="s0">, </span><span class="s1">fprime2=f1_2)</span>
        <span class="s1">sol = root_scalar(f1_and_p_and_pp</span><span class="s0">, </span><span class="s1">method=</span><span class="s4">'halley'</span><span class="s0">, </span><span class="s1">x0=</span><span class="s3">3</span><span class="s0">, </span><span class="s1">fprime2=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">assert_allclose(sol0.root</span><span class="s0">, </span><span class="s1">sol.root</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-8</span><span class="s1">)</span>
        <span class="s1">assert_equal(</span><span class="s3">3</span><span class="s1">*sol.function_calls</span><span class="s0">, </span><span class="s1">sol0.function_calls)</span>

    <span class="s0">def </span><span class="s1">test_newton_full_output(self):</span>
        <span class="s2"># Test the full_output capability, both when converging and not.</span>
        <span class="s2"># Use simple polynomials, to avoid hitting platform dependencies</span>
        <span class="s2"># (e.g., exp &amp; trig) in number of iterations</span>

        <span class="s1">x0 = </span><span class="s3">3</span>
        <span class="s1">expected_counts = [(</span><span class="s3">6</span><span class="s0">, </span><span class="s3">7</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">3</span><span class="s0">, </span><span class="s3">9</span><span class="s1">)]</span>

        <span class="s0">for </span><span class="s1">derivs </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">3</span><span class="s1">):</span>
            <span class="s1">kwargs = {</span><span class="s4">'tol'</span><span class="s1">: </span><span class="s3">1e-6</span><span class="s0">, </span><span class="s4">'full_output'</span><span class="s1">: </span><span class="s0">True, </span><span class="s1">}</span>
            <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">[[</span><span class="s4">'fprime'</span><span class="s0">, </span><span class="s1">f1_1]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">'fprime2'</span><span class="s0">, </span><span class="s1">f1_2]][:derivs]:</span>
                <span class="s1">kwargs[k] = v</span>

            <span class="s1">x</span><span class="s0">, </span><span class="s1">r = zeros.newton(f1</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">, </span><span class="s1">disp=</span><span class="s0">False, </span><span class="s1">**kwargs)</span>
            <span class="s1">assert_(r.converged)</span>
            <span class="s1">assert_equal(x</span><span class="s0">, </span><span class="s1">r.root)</span>
            <span class="s1">assert_equal((r.iterations</span><span class="s0">, </span><span class="s1">r.function_calls)</span><span class="s0">, </span><span class="s1">expected_counts[derivs])</span>
            <span class="s0">if </span><span class="s1">derivs == </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s0">assert </span><span class="s1">r.function_calls &lt;= r.iterations + </span><span class="s3">1</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">assert_equal(r.function_calls</span><span class="s0">, </span><span class="s1">(derivs + </span><span class="s3">1</span><span class="s1">) * r.iterations)</span>

            <span class="s2"># Now repeat, allowing one fewer iteration to force convergence failure</span>
            <span class="s1">iters = r.iterations - </span><span class="s3">1</span>
            <span class="s1">x</span><span class="s0">, </span><span class="s1">r = zeros.newton(f1</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">, </span><span class="s1">maxiter=iters</span><span class="s0">, </span><span class="s1">disp=</span><span class="s0">False, </span><span class="s1">**kwargs)</span>
            <span class="s1">assert_(</span><span class="s0">not </span><span class="s1">r.converged)</span>
            <span class="s1">assert_equal(x</span><span class="s0">, </span><span class="s1">r.root)</span>
            <span class="s1">assert_equal(r.iterations</span><span class="s0">, </span><span class="s1">iters)</span>

            <span class="s0">if </span><span class="s1">derivs == </span><span class="s3">1</span><span class="s1">:</span>
                <span class="s2"># Check that the correct Exception is raised and</span>
                <span class="s2"># validate the start of the message.</span>
                <span class="s0">with </span><span class="s1">pytest.raises(</span>
                    <span class="s1">RuntimeError</span><span class="s0">,</span>
                    <span class="s1">match=</span><span class="s4">'Failed to converge after %d iterations, value is .*' </span><span class="s1">% (iters)):</span>
                    <span class="s1">x</span><span class="s0">, </span><span class="s1">r = zeros.newton(f1</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">, </span><span class="s1">maxiter=iters</span><span class="s0">, </span><span class="s1">disp=</span><span class="s0">True, </span><span class="s1">**kwargs)</span>

    <span class="s0">def </span><span class="s1">test_deriv_zero_warning(self):</span>
        <span class="s0">def </span><span class="s1">func(x):</span>
            <span class="s0">return </span><span class="s1">x ** </span><span class="s3">2 </span><span class="s1">- </span><span class="s3">2.0</span>
        <span class="s0">def </span><span class="s1">dfunc(x):</span>
            <span class="s0">return </span><span class="s3">2 </span><span class="s1">* x</span>
        <span class="s1">assert_warns(RuntimeWarning</span><span class="s0">, </span><span class="s1">zeros.newton</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s3">0.0</span><span class="s0">, </span><span class="s1">dfunc</span><span class="s0">, </span><span class="s1">disp=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(RuntimeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">'Derivative was zero'</span><span class="s1">):</span>
            <span class="s1">zeros.newton(func</span><span class="s0">, </span><span class="s3">0.0</span><span class="s0">, </span><span class="s1">dfunc)</span>

    <span class="s0">def </span><span class="s1">test_newton_does_not_modify_x0(self):</span>
        <span class="s2"># https://github.com/scipy/scipy/issues/9964</span>
        <span class="s1">x0 = np.array([</span><span class="s3">0.1</span><span class="s0">, </span><span class="s3">3</span><span class="s1">])</span>
        <span class="s1">x0_copy = x0.copy()  </span><span class="s2"># Copy to test for equality.</span>
        <span class="s1">newton(np.sin</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">, </span><span class="s1">np.cos)</span>
        <span class="s1">assert_array_equal(x0</span><span class="s0">, </span><span class="s1">x0_copy)</span>

    <span class="s0">def </span><span class="s1">test_gh17570_defaults(self):</span>
        <span class="s2"># Previously, when fprime was not specified, root_scalar would default</span>
        <span class="s2"># to secant. When x1 was not specified, secant failed.</span>
        <span class="s2"># Check that without fprime, the default is secant if x1 is specified</span>
        <span class="s2"># and newton otherwise.</span>
        <span class="s1">res_newton_default = root_scalar(f1</span><span class="s0">, </span><span class="s1">method=</span><span class="s4">'newton'</span><span class="s0">, </span><span class="s1">x0=</span><span class="s3">3</span><span class="s0">, </span><span class="s1">xtol=</span><span class="s3">1e-6</span><span class="s1">)</span>
        <span class="s1">res_secant_default = root_scalar(f1</span><span class="s0">, </span><span class="s1">method=</span><span class="s4">'secant'</span><span class="s0">, </span><span class="s1">x0=</span><span class="s3">3</span><span class="s0">, </span><span class="s1">x1=</span><span class="s3">2</span><span class="s0">,</span>
                                         <span class="s1">xtol=</span><span class="s3">1e-6</span><span class="s1">)</span>
        <span class="s2"># `newton` uses the secant method when `x1` and `x2` are specified</span>
        <span class="s1">res_secant = newton(f1</span><span class="s0">, </span><span class="s1">x0=</span><span class="s3">3</span><span class="s0">, </span><span class="s1">x1=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">tol=</span><span class="s3">1e-6</span><span class="s0">, </span><span class="s1">full_output=</span><span class="s0">True</span><span class="s1">)[</span><span class="s3">1</span><span class="s1">]</span>

        <span class="s2"># all three found a root</span>
        <span class="s1">assert_allclose(f1(res_newton_default.root)</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-6</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">res_newton_default.root.shape == tuple()</span>
        <span class="s1">assert_allclose(f1(res_secant_default.root)</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-6</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">res_secant_default.root.shape == tuple()</span>
        <span class="s1">assert_allclose(f1(res_secant.root)</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-6</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">res_secant.root.shape == tuple()</span>

        <span class="s2"># Defaults are correct</span>
        <span class="s0">assert </span><span class="s1">(res_secant_default.root</span>
                <span class="s1">== res_secant.root</span>
                <span class="s1">!= res_newton_default.iterations)</span>
        <span class="s0">assert </span><span class="s1">(res_secant_default.iterations</span>
                <span class="s1">== res_secant_default.function_calls - </span><span class="s3">1  </span><span class="s2"># true for secant</span>
                <span class="s1">== res_secant.iterations</span>
                <span class="s1">!= res_newton_default.iterations</span>
                <span class="s1">== res_newton_default.function_calls/</span><span class="s3">2</span><span class="s1">)  </span><span class="s2"># newton 2-point diff</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">'method'</span><span class="s0">, </span><span class="s1">[</span><span class="s4">'secant'</span><span class="s0">, </span><span class="s4">'newton'</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_int_x0_gh19280(self</span><span class="s0">, </span><span class="s1">method):</span>
        <span class="s2"># Originally, `newton` ensured that only floats were passed to the</span>
        <span class="s2"># callable. This was indadvertently changed by gh-17669. Check that</span>
        <span class="s2"># it has been changed back.</span>
        <span class="s0">def </span><span class="s1">f(x):</span>
            <span class="s2"># an integer raised to a negative integer power would fail</span>
            <span class="s0">return </span><span class="s1">x**-</span><span class="s3">2 </span><span class="s1">- </span><span class="s3">2</span>

        <span class="s1">res = root_scalar(f</span><span class="s0">, </span><span class="s1">x0=</span><span class="s3">1</span><span class="s0">, </span><span class="s1">method=method)</span>
        <span class="s0">assert </span><span class="s1">res.converged</span>
        <span class="s1">assert_allclose(abs(res.root)</span><span class="s0">, </span><span class="s3">2</span><span class="s1">**-</span><span class="s3">0.5</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">res.root.dtype == np.dtype(np.float64)</span>


<span class="s0">def </span><span class="s1">test_gh_5555():</span>
    <span class="s1">root = </span><span class="s3">0.1</span>

    <span class="s0">def </span><span class="s1">f(x):</span>
        <span class="s0">return </span><span class="s1">x - root</span>

    <span class="s1">methods = [zeros.bisect</span><span class="s0">, </span><span class="s1">zeros.ridder]</span>
    <span class="s1">xtol = rtol = TOL</span>
    <span class="s0">for </span><span class="s1">method </span><span class="s0">in </span><span class="s1">methods:</span>
        <span class="s1">res = method(f</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1e8</span><span class="s0">, </span><span class="s3">1e7</span><span class="s0">, </span><span class="s1">xtol=xtol</span><span class="s0">, </span><span class="s1">rtol=rtol)</span>
        <span class="s1">assert_allclose(root</span><span class="s0">, </span><span class="s1">res</span><span class="s0">, </span><span class="s1">atol=xtol</span><span class="s0">, </span><span class="s1">rtol=rtol</span><span class="s0">,</span>
                        <span class="s1">err_msg=</span><span class="s4">'method %s' </span><span class="s1">% method.__name__)</span>


<span class="s0">def </span><span class="s1">test_gh_5557():</span>
    <span class="s2"># Show that without the changes in 5557 brentq and brenth might</span>
    <span class="s2"># only achieve a tolerance of 2*(xtol + rtol*|res|).</span>

    <span class="s2"># f linearly interpolates (0, -0.1), (0.5, -0.1), and (1,</span>
    <span class="s2"># 0.4). The important parts are that |f(0)| &lt; |f(1)| (so that</span>
    <span class="s2"># brent takes 0 as the initial guess), |f(0)| &lt; atol (so that</span>
    <span class="s2"># brent accepts 0 as the root), and that the exact root of f lies</span>
    <span class="s2"># more than atol away from 0 (so that brent doesn't achieve the</span>
    <span class="s2"># desired tolerance).</span>
    <span class="s0">def </span><span class="s1">f(x):</span>
        <span class="s0">if </span><span class="s1">x &lt; </span><span class="s3">0.5</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">-</span><span class="s3">0.1</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">x - </span><span class="s3">0.6</span>

    <span class="s1">atol = </span><span class="s3">0.51</span>
    <span class="s1">rtol = </span><span class="s3">4 </span><span class="s1">* _FLOAT_EPS</span>
    <span class="s1">methods = [zeros.brentq</span><span class="s0">, </span><span class="s1">zeros.brenth]</span>
    <span class="s0">for </span><span class="s1">method </span><span class="s0">in </span><span class="s1">methods:</span>
        <span class="s1">res = method(f</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">xtol=atol</span><span class="s0">, </span><span class="s1">rtol=rtol)</span>
        <span class="s1">assert_allclose(</span><span class="s3">0.6</span><span class="s0">, </span><span class="s1">res</span><span class="s0">, </span><span class="s1">atol=atol</span><span class="s0">, </span><span class="s1">rtol=rtol)</span>


<span class="s0">def </span><span class="s1">test_brent_underflow_in_root_bracketing():</span>
    <span class="s2"># Tetsing if an interval [a,b] brackets a zero of a function</span>
    <span class="s2"># by checking f(a)*f(b) &lt; 0 is not reliable when the product</span>
    <span class="s2"># underflows/overflows. (reported in issue# 13737)</span>

    <span class="s1">underflow_scenario = (-</span><span class="s3">450.0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">350.0</span><span class="s0">, </span><span class="s1">-</span><span class="s3">400.0</span><span class="s1">)</span>
    <span class="s1">overflow_scenario = (</span><span class="s3">350.0</span><span class="s0">, </span><span class="s3">450.0</span><span class="s0">, </span><span class="s3">400.0</span><span class="s1">)</span>

    <span class="s0">for </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">root </span><span class="s0">in </span><span class="s1">[underflow_scenario</span><span class="s0">, </span><span class="s1">overflow_scenario]:</span>
        <span class="s1">c = np.exp(root)</span>
        <span class="s0">for </span><span class="s1">method </span><span class="s0">in </span><span class="s1">[zeros.brenth</span><span class="s0">, </span><span class="s1">zeros.brentq]:</span>
            <span class="s1">res = method(</span><span class="s0">lambda </span><span class="s1">x: np.exp(x)-c</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b)</span>
            <span class="s1">assert_allclose(root</span><span class="s0">, </span><span class="s1">res)</span>


<span class="s0">class </span><span class="s1">TestRootResults:</span>
    <span class="s1">r = zeros.RootResults(root=</span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">iterations=</span><span class="s3">44</span><span class="s0">, </span><span class="s1">function_calls=</span><span class="s3">46</span><span class="s0">, </span><span class="s1">flag=</span><span class="s3">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_repr(self):</span>
        <span class="s1">expected_repr = (</span><span class="s4">&quot;      converged: True</span><span class="s0">\n           </span><span class="s4">flag: converged&quot;</span>
                         <span class="s4">&quot;</span><span class="s0">\n </span><span class="s4">function_calls: 46</span><span class="s0">\n     </span><span class="s4">iterations: 44</span><span class="s0">\n</span><span class="s4">&quot;</span>
                         <span class="s4">&quot;           root: 1.0&quot;</span><span class="s1">)</span>
        <span class="s1">assert_equal(repr(self.r)</span><span class="s0">, </span><span class="s1">expected_repr)</span>

    <span class="s0">def </span><span class="s1">test_type(self):</span>
        <span class="s0">assert </span><span class="s1">isinstance(self.r</span><span class="s0">, </span><span class="s1">OptimizeResult)</span>


<span class="s0">def </span><span class="s1">test_complex_halley():</span>
    <span class="s5">&quot;&quot;&quot;Test Halley's works with complex roots&quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">f(x</span><span class="s0">, </span><span class="s1">*a):</span>
        <span class="s0">return </span><span class="s1">a[</span><span class="s3">0</span><span class="s1">] * x**</span><span class="s3">2 </span><span class="s1">+ a[</span><span class="s3">1</span><span class="s1">] * x + a[</span><span class="s3">2</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">f_1(x</span><span class="s0">, </span><span class="s1">*a):</span>
        <span class="s0">return </span><span class="s3">2 </span><span class="s1">* a[</span><span class="s3">0</span><span class="s1">] * x + a[</span><span class="s3">1</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">f_2(x</span><span class="s0">, </span><span class="s1">*a):</span>
        <span class="s1">retval = </span><span class="s3">2 </span><span class="s1">* a[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">size = len(x)</span>
        <span class="s0">except </span><span class="s1">TypeError:</span>
            <span class="s0">return </span><span class="s1">retval</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">[retval] * size</span>

    <span class="s1">z = complex(</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">2.0</span><span class="s1">)</span>
    <span class="s1">coeffs = (</span><span class="s3">2.0</span><span class="s0">, </span><span class="s3">3.0</span><span class="s0">, </span><span class="s3">4.0</span><span class="s1">)</span>
    <span class="s1">y = zeros.newton(f</span><span class="s0">, </span><span class="s1">z</span><span class="s0">, </span><span class="s1">args=coeffs</span><span class="s0">, </span><span class="s1">fprime=f_1</span><span class="s0">, </span><span class="s1">fprime2=f_2</span><span class="s0">, </span><span class="s1">tol=</span><span class="s3">1e-6</span><span class="s1">)</span>
    <span class="s2"># (-0.75000000000000078+1.1989578808281789j)</span>
    <span class="s1">assert_allclose(f(y</span><span class="s0">, </span><span class="s1">*coeffs)</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-6</span><span class="s1">)</span>
    <span class="s1">z = [z] * </span><span class="s3">10</span>
    <span class="s1">coeffs = (</span><span class="s3">2.0</span><span class="s0">, </span><span class="s3">3.0</span><span class="s0">, </span><span class="s3">4.0</span><span class="s1">)</span>
    <span class="s1">y = zeros.newton(f</span><span class="s0">, </span><span class="s1">z</span><span class="s0">, </span><span class="s1">args=coeffs</span><span class="s0">, </span><span class="s1">fprime=f_1</span><span class="s0">, </span><span class="s1">fprime2=f_2</span><span class="s0">, </span><span class="s1">tol=</span><span class="s3">1e-6</span><span class="s1">)</span>
    <span class="s1">assert_allclose(f(y</span><span class="s0">, </span><span class="s1">*coeffs)</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-6</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_zero_der_nz_dp():</span>
    <span class="s5">&quot;&quot;&quot;Test secant method with a non-zero dp, but an infinite newton step&quot;&quot;&quot;</span>
    <span class="s2"># pick a symmetrical functions and choose a point on the side that with dx</span>
    <span class="s2"># makes a secant that is a flat line with zero slope, EG: f = (x - 100)**2,</span>
    <span class="s2"># which has a root at x = 100 and is symmetrical around the line x = 100</span>
    <span class="s2"># we have to pick a really big number so that it is consistently true</span>
    <span class="s2"># now find a point on each side so that the secant has a zero slope</span>
    <span class="s1">dx = np.finfo(float).eps ** </span><span class="s3">0.33</span>
    <span class="s2"># 100 - p0 = p1 - 100 = p0 * (1 + dx) + dx - 100</span>
    <span class="s2"># -&gt; 200 = p0 * (2 + dx) + dx</span>
    <span class="s1">p0 = (</span><span class="s3">200.0 </span><span class="s1">- dx) / (</span><span class="s3">2.0 </span><span class="s1">+ dx)</span>
    <span class="s0">with </span><span class="s1">suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
        <span class="s1">sup.filter(RuntimeWarning</span><span class="s0">, </span><span class="s4">&quot;RMS of&quot;</span><span class="s1">)</span>
        <span class="s1">x = zeros.newton(</span><span class="s0">lambda </span><span class="s1">y: (y - </span><span class="s3">100.0</span><span class="s1">)**</span><span class="s3">2</span><span class="s0">, </span><span class="s1">x0=[p0] * </span><span class="s3">10</span><span class="s1">)</span>
    <span class="s1">assert_allclose(x</span><span class="s0">, </span><span class="s1">[</span><span class="s3">100</span><span class="s1">] * </span><span class="s3">10</span><span class="s1">)</span>
    <span class="s2"># test scalar cases too</span>
    <span class="s1">p0 = (</span><span class="s3">2.0 </span><span class="s1">- </span><span class="s3">1e-4</span><span class="s1">) / (</span><span class="s3">2.0 </span><span class="s1">+ </span><span class="s3">1e-4</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
        <span class="s1">sup.filter(RuntimeWarning</span><span class="s0">, </span><span class="s4">&quot;Tolerance of&quot;</span><span class="s1">)</span>
        <span class="s1">x = zeros.newton(</span><span class="s0">lambda </span><span class="s1">y: (y - </span><span class="s3">1.0</span><span class="s1">) ** </span><span class="s3">2</span><span class="s0">, </span><span class="s1">x0=p0</span><span class="s0">, </span><span class="s1">disp=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">assert_allclose(x</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(RuntimeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">'Tolerance of'</span><span class="s1">):</span>
        <span class="s1">x = zeros.newton(</span><span class="s0">lambda </span><span class="s1">y: (y - </span><span class="s3">1.0</span><span class="s1">) ** </span><span class="s3">2</span><span class="s0">, </span><span class="s1">x0=p0</span><span class="s0">, </span><span class="s1">disp=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">p0 = (-</span><span class="s3">2.0 </span><span class="s1">+ </span><span class="s3">1e-4</span><span class="s1">) / (</span><span class="s3">2.0 </span><span class="s1">+ </span><span class="s3">1e-4</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">suppress_warnings() </span><span class="s0">as </span><span class="s1">sup:</span>
        <span class="s1">sup.filter(RuntimeWarning</span><span class="s0">, </span><span class="s4">&quot;Tolerance of&quot;</span><span class="s1">)</span>
        <span class="s1">x = zeros.newton(</span><span class="s0">lambda </span><span class="s1">y: (y + </span><span class="s3">1.0</span><span class="s1">) ** </span><span class="s3">2</span><span class="s0">, </span><span class="s1">x0=p0</span><span class="s0">, </span><span class="s1">disp=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">assert_allclose(x</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(RuntimeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">'Tolerance of'</span><span class="s1">):</span>
        <span class="s1">x = zeros.newton(</span><span class="s0">lambda </span><span class="s1">y: (y + </span><span class="s3">1.0</span><span class="s1">) ** </span><span class="s3">2</span><span class="s0">, </span><span class="s1">x0=p0</span><span class="s0">, </span><span class="s1">disp=</span><span class="s0">True</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_array_newton_failures():</span>
    <span class="s5">&quot;&quot;&quot;Test that array newton fails as expected&quot;&quot;&quot;</span>
    <span class="s2"># p = 0.68  # [MPa]</span>
    <span class="s2"># dp = -0.068 * 1e6  # [Pa]</span>
    <span class="s2"># T = 323  # [K]</span>
    <span class="s1">diameter = </span><span class="s3">0.10  </span><span class="s2"># [m]</span>
    <span class="s2"># L = 100  # [m]</span>
    <span class="s1">roughness = </span><span class="s3">0.00015  </span><span class="s2"># [m]</span>
    <span class="s1">rho = </span><span class="s3">988.1  </span><span class="s2"># [kg/m**3]</span>
    <span class="s1">mu = </span><span class="s3">5.4790e-04  </span><span class="s2"># [Pa*s]</span>
    <span class="s1">u = </span><span class="s3">2.488  </span><span class="s2"># [m/s]</span>
    <span class="s1">reynolds_number = rho * u * diameter / mu  </span><span class="s2"># Reynolds number</span>

    <span class="s0">def </span><span class="s1">colebrook_eqn(darcy_friction</span><span class="s0">, </span><span class="s1">re</span><span class="s0">, </span><span class="s1">dia):</span>
        <span class="s0">return </span><span class="s1">(</span><span class="s3">1 </span><span class="s1">/ np.sqrt(darcy_friction) +</span>
                <span class="s3">2 </span><span class="s1">* np.log10(roughness / </span><span class="s3">3.7 </span><span class="s1">/ dia +</span>
                             <span class="s3">2.51 </span><span class="s1">/ re / np.sqrt(darcy_friction)))</span>

    <span class="s2"># only some failures</span>
    <span class="s0">with </span><span class="s1">pytest.warns(RuntimeWarning):</span>
        <span class="s1">result = zeros.newton(</span>
            <span class="s1">colebrook_eqn</span><span class="s0">, </span><span class="s1">x0=[</span><span class="s3">0.01</span><span class="s0">, </span><span class="s3">0.2</span><span class="s0">, </span><span class="s3">0.02223</span><span class="s0">, </span><span class="s3">0.3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">maxiter=</span><span class="s3">2</span><span class="s0">,</span>
            <span class="s1">args=[reynolds_number</span><span class="s0">, </span><span class="s1">diameter]</span><span class="s0">, </span><span class="s1">full_output=</span><span class="s0">True</span>
        <span class="s1">)</span>
        <span class="s0">assert not </span><span class="s1">result.converged.all()</span>
    <span class="s2"># they all fail</span>
    <span class="s0">with </span><span class="s1">pytest.raises(RuntimeError):</span>
        <span class="s1">result = zeros.newton(</span>
            <span class="s1">colebrook_eqn</span><span class="s0">, </span><span class="s1">x0=[</span><span class="s3">0.01</span><span class="s1">] * </span><span class="s3">2</span><span class="s0">, </span><span class="s1">maxiter=</span><span class="s3">2</span><span class="s0">,</span>
            <span class="s1">args=[reynolds_number</span><span class="s0">, </span><span class="s1">diameter]</span><span class="s0">, </span><span class="s1">full_output=</span><span class="s0">True</span>
        <span class="s1">)</span>


<span class="s2"># this test should **not** raise a RuntimeWarning</span>
<span class="s0">def </span><span class="s1">test_gh8904_zeroder_at_root_fails():</span>
    <span class="s5">&quot;&quot;&quot;Test that Newton or Halley don't warn if zero derivative at root&quot;&quot;&quot;</span>

    <span class="s2"># a function that has a zero derivative at it's root</span>
    <span class="s0">def </span><span class="s1">f_zeroder_root(x):</span>
        <span class="s0">return </span><span class="s1">x**</span><span class="s3">3 </span><span class="s1">- x**</span><span class="s3">2</span>

    <span class="s2"># should work with secant</span>
    <span class="s1">r = zeros.newton(f_zeroder_root</span><span class="s0">, </span><span class="s1">x0=</span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">assert_allclose(r</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">atol=zeros._xtol</span><span class="s0">, </span><span class="s1">rtol=zeros._rtol)</span>
    <span class="s2"># test again with array</span>
    <span class="s1">r = zeros.newton(f_zeroder_root</span><span class="s0">, </span><span class="s1">x0=[</span><span class="s3">0</span><span class="s1">]*</span><span class="s3">10</span><span class="s1">)</span>
    <span class="s1">assert_allclose(r</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">atol=zeros._xtol</span><span class="s0">, </span><span class="s1">rtol=zeros._rtol)</span>

    <span class="s2"># 1st derivative</span>
    <span class="s0">def </span><span class="s1">fder(x):</span>
        <span class="s0">return </span><span class="s3">3 </span><span class="s1">* x**</span><span class="s3">2 </span><span class="s1">- </span><span class="s3">2 </span><span class="s1">* x</span>

    <span class="s2"># 2nd derivative</span>
    <span class="s0">def </span><span class="s1">fder2(x):</span>
        <span class="s0">return </span><span class="s3">6</span><span class="s1">*x - </span><span class="s3">2</span>

    <span class="s2"># should work with newton and halley</span>
    <span class="s1">r = zeros.newton(f_zeroder_root</span><span class="s0">, </span><span class="s1">x0=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">fprime=fder)</span>
    <span class="s1">assert_allclose(r</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">atol=zeros._xtol</span><span class="s0">, </span><span class="s1">rtol=zeros._rtol)</span>
    <span class="s1">r = zeros.newton(f_zeroder_root</span><span class="s0">, </span><span class="s1">x0=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">fprime=fder</span><span class="s0">,</span>
                     <span class="s1">fprime2=fder2)</span>
    <span class="s1">assert_allclose(r</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">atol=zeros._xtol</span><span class="s0">, </span><span class="s1">rtol=zeros._rtol)</span>
    <span class="s2"># test again with array</span>
    <span class="s1">r = zeros.newton(f_zeroder_root</span><span class="s0">, </span><span class="s1">x0=[</span><span class="s3">0</span><span class="s1">]*</span><span class="s3">10</span><span class="s0">, </span><span class="s1">fprime=fder)</span>
    <span class="s1">assert_allclose(r</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">atol=zeros._xtol</span><span class="s0">, </span><span class="s1">rtol=zeros._rtol)</span>
    <span class="s1">r = zeros.newton(f_zeroder_root</span><span class="s0">, </span><span class="s1">x0=[</span><span class="s3">0</span><span class="s1">]*</span><span class="s3">10</span><span class="s0">, </span><span class="s1">fprime=fder</span><span class="s0">,</span>
                     <span class="s1">fprime2=fder2)</span>
    <span class="s1">assert_allclose(r</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">atol=zeros._xtol</span><span class="s0">, </span><span class="s1">rtol=zeros._rtol)</span>

    <span class="s2"># also test that if a root is found we do not raise RuntimeWarning even if</span>
    <span class="s2"># the derivative is zero, EG: at x = 0.5, then fval = -0.125 and</span>
    <span class="s2"># fder = -0.25 so the next guess is 0.5 - (-0.125/-0.5) = 0 which is the</span>
    <span class="s2"># root, but if the solver continued with that guess, then it will calculate</span>
    <span class="s2"># a zero derivative, so it should return the root w/o RuntimeWarning</span>
    <span class="s1">r = zeros.newton(f_zeroder_root</span><span class="s0">, </span><span class="s1">x0=</span><span class="s3">0.5</span><span class="s0">, </span><span class="s1">fprime=fder)</span>
    <span class="s1">assert_allclose(r</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">atol=zeros._xtol</span><span class="s0">, </span><span class="s1">rtol=zeros._rtol)</span>
    <span class="s2"># test again with array</span>
    <span class="s1">r = zeros.newton(f_zeroder_root</span><span class="s0">, </span><span class="s1">x0=[</span><span class="s3">0.5</span><span class="s1">]*</span><span class="s3">10</span><span class="s0">, </span><span class="s1">fprime=fder)</span>
    <span class="s1">assert_allclose(r</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">atol=zeros._xtol</span><span class="s0">, </span><span class="s1">rtol=zeros._rtol)</span>
    <span class="s2"># doesn't apply to halley</span>


<span class="s0">def </span><span class="s1">test_gh_8881():</span>
    <span class="s5">r&quot;&quot;&quot;Test that Halley's method realizes that the 2nd order adjustment 
    is too big and drops off to the 1st order adjustment.&quot;&quot;&quot;</span>
    <span class="s1">n = </span><span class="s3">9</span>

    <span class="s0">def </span><span class="s1">f(x):</span>
        <span class="s0">return </span><span class="s1">power(x</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">/n) - power(n</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">/n)</span>

    <span class="s0">def </span><span class="s1">fp(x):</span>
        <span class="s0">return </span><span class="s1">power(x</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1.0</span><span class="s1">-n)/n)/n</span>

    <span class="s0">def </span><span class="s1">fpp(x):</span>
        <span class="s0">return </span><span class="s1">power(x</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1.0</span><span class="s1">-</span><span class="s3">2</span><span class="s1">*n)/n) * (</span><span class="s3">1.0</span><span class="s1">/n) * (</span><span class="s3">1.0</span><span class="s1">-n)/n</span>

    <span class="s1">x0 = </span><span class="s3">0.1</span>
    <span class="s2"># The root is at x=9.</span>
    <span class="s2"># The function has positive slope, x0 &lt; root.</span>
    <span class="s2"># Newton succeeds in 8 iterations</span>
    <span class="s1">rt</span><span class="s0">, </span><span class="s1">r = newton(f</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">, </span><span class="s1">fprime=fp</span><span class="s0">, </span><span class="s1">full_output=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">r.converged</span>
    <span class="s2"># Before the Issue 8881/PR 8882, halley would send x in the wrong direction.</span>
    <span class="s2"># Check that it now succeeds.</span>
    <span class="s1">rt</span><span class="s0">, </span><span class="s1">r = newton(f</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">, </span><span class="s1">fprime=fp</span><span class="s0">, </span><span class="s1">fprime2=fpp</span><span class="s0">, </span><span class="s1">full_output=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">r.converged</span>


<span class="s0">def </span><span class="s1">test_gh_9608_preserve_array_shape():</span>
    <span class="s5">&quot;&quot;&quot; 
    Test that shape is preserved for array inputs even if fprime or fprime2 is 
    scalar 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">f(x):</span>
        <span class="s0">return </span><span class="s1">x**</span><span class="s3">2</span>

    <span class="s0">def </span><span class="s1">fp(x):</span>
        <span class="s0">return </span><span class="s3">2 </span><span class="s1">* x</span>

    <span class="s0">def </span><span class="s1">fpp(x):</span>
        <span class="s0">return </span><span class="s3">2</span>

    <span class="s1">x0 = np.array([-</span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.float32)</span>
    <span class="s1">rt</span><span class="s0">, </span><span class="s1">r = newton(f</span><span class="s0">, </span><span class="s1">x0</span><span class="s0">, </span><span class="s1">fprime=fp</span><span class="s0">, </span><span class="s1">fprime2=fpp</span><span class="s0">, </span><span class="s1">full_output=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">r.converged</span>

    <span class="s1">x0_array = np.array([-</span><span class="s3">2</span><span class="s0">, </span><span class="s1">-</span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.float32)</span>
    <span class="s2"># This next invocation should fail</span>
    <span class="s0">with </span><span class="s1">pytest.raises(IndexError):</span>
        <span class="s1">result = zeros.newton(</span>
            <span class="s1">f</span><span class="s0">, </span><span class="s1">x0_array</span><span class="s0">, </span><span class="s1">fprime=fp</span><span class="s0">, </span><span class="s1">fprime2=fpp</span><span class="s0">, </span><span class="s1">full_output=</span><span class="s0">True</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">fpp_array(x):</span>
        <span class="s0">return </span><span class="s1">np.full(np.shape(x)</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s1">dtype=np.float32)</span>

    <span class="s1">result = zeros.newton(</span>
        <span class="s1">f</span><span class="s0">, </span><span class="s1">x0_array</span><span class="s0">, </span><span class="s1">fprime=fp</span><span class="s0">, </span><span class="s1">fprime2=fpp_array</span><span class="s0">, </span><span class="s1">full_output=</span><span class="s0">True</span>
    <span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">result.converged.all()</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s4">&quot;maximum_iterations,flag_expected&quot;</span><span class="s0">,</span>
    <span class="s1">[(</span><span class="s3">10</span><span class="s0">, </span><span class="s1">zeros.CONVERR)</span><span class="s0">, </span><span class="s1">(</span><span class="s3">100</span><span class="s0">, </span><span class="s1">zeros.CONVERGED)])</span>
<span class="s0">def </span><span class="s1">test_gh9254_flag_if_maxiter_exceeded(maximum_iterations</span><span class="s0">, </span><span class="s1">flag_expected):</span>
    <span class="s5">&quot;&quot;&quot; 
    Test that if the maximum iterations is exceeded that the flag is not 
    converged. 
    &quot;&quot;&quot;</span>
    <span class="s1">result = zeros.brentq(</span>
        <span class="s0">lambda </span><span class="s1">x: ((</span><span class="s3">1.2</span><span class="s1">*x - </span><span class="s3">2.3</span><span class="s1">)*x + </span><span class="s3">3.4</span><span class="s1">)*x - </span><span class="s3">4.5</span><span class="s0">,</span>
        <span class="s1">-</span><span class="s3">30</span><span class="s0">, </span><span class="s3">30</span><span class="s0">, </span><span class="s1">()</span><span class="s0">, </span><span class="s3">1e-6</span><span class="s0">, </span><span class="s3">1e-6</span><span class="s0">, </span><span class="s1">maximum_iterations</span><span class="s0">,</span>
        <span class="s1">full_output=</span><span class="s0">True, </span><span class="s1">disp=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">result[</span><span class="s3">1</span><span class="s1">].flag == flag_expected</span>
    <span class="s0">if </span><span class="s1">flag_expected == zeros.CONVERR:</span>
        <span class="s2"># didn't converge because exceeded maximum iterations</span>
        <span class="s0">assert </span><span class="s1">result[</span><span class="s3">1</span><span class="s1">].iterations == maximum_iterations</span>
    <span class="s0">elif </span><span class="s1">flag_expected == zeros.CONVERGED:</span>
        <span class="s2"># converged before maximum iterations</span>
        <span class="s0">assert </span><span class="s1">result[</span><span class="s3">1</span><span class="s1">].iterations &lt; maximum_iterations</span>


<span class="s0">def </span><span class="s1">test_gh9551_raise_error_if_disp_true():</span>
    <span class="s5">&quot;&quot;&quot;Test that if disp is true then zero derivative raises RuntimeError&quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">f(x):</span>
        <span class="s0">return </span><span class="s1">x*x + </span><span class="s3">1</span>

    <span class="s0">def </span><span class="s1">f_p(x):</span>
        <span class="s0">return </span><span class="s3">2</span><span class="s1">*x</span>

    <span class="s1">assert_warns(RuntimeWarning</span><span class="s0">, </span><span class="s1">zeros.newton</span><span class="s0">, </span><span class="s1">f</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">f_p</span><span class="s0">, </span><span class="s1">disp=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(</span>
            <span class="s1">RuntimeError</span><span class="s0">,</span>
            <span class="s1">match=</span><span class="s4">r'^Derivative was zero\. Failed to converge after \d+ iterations, value is [+-]?\d*\.\d+\.$'</span><span class="s1">):</span>
        <span class="s1">zeros.newton(f</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">f_p)</span>
    <span class="s1">root = zeros.newton(f</span><span class="s0">, </span><span class="s1">complex(</span><span class="s3">10.0</span><span class="s0">, </span><span class="s3">10.0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">f_p)</span>
    <span class="s1">assert_allclose(root</span><span class="s0">, </span><span class="s1">complex(</span><span class="s3">0.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">))</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">'solver_name'</span><span class="s0">,</span>
                         <span class="s1">[</span><span class="s4">'brentq'</span><span class="s0">, </span><span class="s4">'brenth'</span><span class="s0">, </span><span class="s4">'bisect'</span><span class="s0">, </span><span class="s4">'ridder'</span><span class="s0">, </span><span class="s4">'toms748'</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_gh3089_8394(solver_name):</span>
    <span class="s2"># gh-3089 and gh-8394 reported that bracketing solvers returned incorrect</span>
    <span class="s2"># results when they encountered NaNs. Check that this is resolved.</span>
    <span class="s0">def </span><span class="s1">f(x):</span>
        <span class="s0">return </span><span class="s1">np.nan</span>

    <span class="s1">solver = getattr(zeros</span><span class="s0">, </span><span class="s1">solver_name)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;The function value at x...&quot;</span><span class="s1">):</span>
        <span class="s1">solver(f</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">'method'</span><span class="s0">,</span>
                         <span class="s1">[</span><span class="s4">'brentq'</span><span class="s0">, </span><span class="s4">'brenth'</span><span class="s0">, </span><span class="s4">'bisect'</span><span class="s0">, </span><span class="s4">'ridder'</span><span class="s0">, </span><span class="s4">'toms748'</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_gh18171(method):</span>
    <span class="s2"># gh-3089 and gh-8394 reported that bracketing solvers returned incorrect</span>
    <span class="s2"># results when they encountered NaNs. Check that `root_scalar` returns</span>
    <span class="s2"># normally but indicates that convergence was unsuccessful. See gh-18171.</span>
    <span class="s0">def </span><span class="s1">f(x):</span>
        <span class="s1">f._count += </span><span class="s3">1</span>
        <span class="s0">return </span><span class="s1">np.nan</span>
    <span class="s1">f._count = </span><span class="s3">0</span>

    <span class="s1">res = root_scalar(f</span><span class="s0">, </span><span class="s1">bracket=(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">method=method)</span>
    <span class="s0">assert </span><span class="s1">res.converged </span><span class="s0">is False</span>
    <span class="s0">assert </span><span class="s1">res.flag.startswith(</span><span class="s4">&quot;The function value at x&quot;</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">res.function_calls == f._count</span>
    <span class="s0">assert </span><span class="s1">str(res.root) </span><span class="s0">in </span><span class="s1">res.flag</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">'solver_name'</span><span class="s0">,</span>
                         <span class="s1">[</span><span class="s4">'brentq'</span><span class="s0">, </span><span class="s4">'brenth'</span><span class="s0">, </span><span class="s4">'bisect'</span><span class="s0">, </span><span class="s4">'ridder'</span><span class="s0">, </span><span class="s4">'toms748'</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">'rs_interface'</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_function_calls(solver_name</span><span class="s0">, </span><span class="s1">rs_interface):</span>
    <span class="s2"># There do not appear to be checks that the bracketing solvers report the</span>
    <span class="s2"># correct number of function evaluations. Check that this is the case.</span>
    <span class="s1">solver = ((</span><span class="s0">lambda </span><span class="s1">f</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">**kwargs: root_scalar(f</span><span class="s0">, </span><span class="s1">bracket=(a</span><span class="s0">, </span><span class="s1">b)))</span>
              <span class="s0">if </span><span class="s1">rs_interface </span><span class="s0">else </span><span class="s1">getattr(zeros</span><span class="s0">, </span><span class="s1">solver_name))</span>

    <span class="s0">def </span><span class="s1">f(x):</span>
        <span class="s1">f.calls += </span><span class="s3">1</span>
        <span class="s0">return </span><span class="s1">x**</span><span class="s3">2 </span><span class="s1">- </span><span class="s3">1</span>
    <span class="s1">f.calls = </span><span class="s3">0</span>

    <span class="s1">res = solver(f</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">10</span><span class="s0">, </span><span class="s1">full_output=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">rs_interface:</span>
        <span class="s0">assert </span><span class="s1">res.function_calls == f.calls</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">assert </span><span class="s1">res[</span><span class="s3">1</span><span class="s1">].function_calls == f.calls</span>


<span class="s0">def </span><span class="s1">test_gh_14486_converged_false():</span>
    <span class="s5">&quot;&quot;&quot;Test that zero slope with secant method results in a converged=False&quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">lhs(x):</span>
        <span class="s0">return </span><span class="s1">x * np.exp(-x*x) - </span><span class="s3">0.07</span>

    <span class="s0">with </span><span class="s1">pytest.warns(RuntimeWarning</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">'Tolerance of'</span><span class="s1">):</span>
        <span class="s1">res = root_scalar(lhs</span><span class="s0">, </span><span class="s1">method=</span><span class="s4">'secant'</span><span class="s0">, </span><span class="s1">x0=-</span><span class="s3">0.15</span><span class="s0">, </span><span class="s1">x1=</span><span class="s3">1.0</span><span class="s1">)</span>
    <span class="s0">assert not </span><span class="s1">res.converged</span>
    <span class="s0">assert </span><span class="s1">res.flag == </span><span class="s4">'convergence error'</span>

    <span class="s0">with </span><span class="s1">pytest.warns(RuntimeWarning</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">'Tolerance of'</span><span class="s1">):</span>
        <span class="s1">res = newton(lhs</span><span class="s0">, </span><span class="s1">x0=-</span><span class="s3">0.15</span><span class="s0">, </span><span class="s1">x1=</span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">disp=</span><span class="s0">False, </span><span class="s1">full_output=</span><span class="s0">True</span><span class="s1">)[</span><span class="s3">1</span><span class="s1">]</span>
    <span class="s0">assert not </span><span class="s1">res.converged</span>
    <span class="s0">assert </span><span class="s1">res.flag == </span><span class="s4">'convergence error'</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">'solver_name'</span><span class="s0">,</span>
                         <span class="s1">[</span><span class="s4">'brentq'</span><span class="s0">, </span><span class="s4">'brenth'</span><span class="s0">, </span><span class="s4">'bisect'</span><span class="s0">, </span><span class="s4">'ridder'</span><span class="s0">, </span><span class="s4">'toms748'</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">'rs_interface'</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_gh5584(solver_name</span><span class="s0">, </span><span class="s1">rs_interface):</span>
    <span class="s2"># gh-5584 reported that an underflow can cause sign checks in the algorithm</span>
    <span class="s2"># to fail. Check that this is resolved.</span>
    <span class="s1">solver = ((</span><span class="s0">lambda </span><span class="s1">f</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">**kwargs: root_scalar(f</span><span class="s0">, </span><span class="s1">bracket=(a</span><span class="s0">, </span><span class="s1">b)))</span>
              <span class="s0">if </span><span class="s1">rs_interface </span><span class="s0">else </span><span class="s1">getattr(zeros</span><span class="s0">, </span><span class="s1">solver_name))</span>

    <span class="s0">def </span><span class="s1">f(x):</span>
        <span class="s0">return </span><span class="s3">1e-200</span><span class="s1">*x</span>

    <span class="s2"># Report failure when signs are the same</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">'...must have different signs'</span><span class="s1">):</span>
        <span class="s1">solver(f</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.5</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.4</span><span class="s0">, </span><span class="s1">full_output=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s2"># Solve successfully when signs are different</span>
    <span class="s1">res = solver(f</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">0.4</span><span class="s0">, </span><span class="s1">full_output=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">res = res </span><span class="s0">if </span><span class="s1">rs_interface </span><span class="s0">else </span><span class="s1">res[</span><span class="s3">1</span><span class="s1">]</span>
    <span class="s0">assert </span><span class="s1">res.converged</span>
    <span class="s1">assert_allclose(res.root</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-8</span><span class="s1">)</span>

    <span class="s2"># Solve successfully when one side is negative zero</span>
    <span class="s1">res = solver(f</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.5</span><span class="s0">, </span><span class="s1">float(</span><span class="s4">'-0.0'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">full_output=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">res = res </span><span class="s0">if </span><span class="s1">rs_interface </span><span class="s0">else </span><span class="s1">res[</span><span class="s3">1</span><span class="s1">]</span>
    <span class="s0">assert </span><span class="s1">res.converged</span>
    <span class="s1">assert_allclose(res.root</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-8</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_gh13407():</span>
    <span class="s2"># gh-13407 reported that the message produced by `scipy.optimize.toms748`</span>
    <span class="s2"># when `rtol &lt; eps` is incorrect, and also that toms748 is unusual in</span>
    <span class="s2"># accepting `rtol` as low as eps while other solvers raise at 4*eps. Check</span>
    <span class="s2"># that the error message has been corrected and that `rtol=eps` can produce</span>
    <span class="s2"># a lower function value than `rtol=4*eps`.</span>
    <span class="s0">def </span><span class="s1">f(x):</span>
        <span class="s0">return </span><span class="s1">x**</span><span class="s3">3 </span><span class="s1">- </span><span class="s3">2</span><span class="s1">*x - </span><span class="s3">5</span>

    <span class="s1">xtol = </span><span class="s3">1e-300</span>
    <span class="s1">eps = np.finfo(float).eps</span>
    <span class="s1">x1 = zeros.toms748(f</span><span class="s0">, </span><span class="s3">1e-10</span><span class="s0">, </span><span class="s3">1e10</span><span class="s0">, </span><span class="s1">xtol=xtol</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1</span><span class="s1">*eps)</span>
    <span class="s1">f1 = f(x1)</span>
    <span class="s1">x4 = zeros.toms748(f</span><span class="s0">, </span><span class="s3">1e-10</span><span class="s0">, </span><span class="s3">1e10</span><span class="s0">, </span><span class="s1">xtol=xtol</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">4</span><span class="s1">*eps)</span>
    <span class="s1">f4 = f(x4)</span>
    <span class="s0">assert </span><span class="s1">f1 &lt; f4</span>

    <span class="s2"># using old-style syntax to get exactly the same message</span>
    <span class="s1">message = </span><span class="s4">fr&quot;rtol too small \(</span><span class="s0">{</span><span class="s1">eps/</span><span class="s3">2</span><span class="s0">:</span><span class="s4">g</span><span class="s0">} </span><span class="s4">&lt; </span><span class="s0">{</span><span class="s1">eps</span><span class="s0">:</span><span class="s4">g</span><span class="s0">}</span><span class="s4">\)&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=message):</span>
        <span class="s1">zeros.toms748(f</span><span class="s0">, </span><span class="s3">1e-10</span><span class="s0">, </span><span class="s3">1e10</span><span class="s0">, </span><span class="s1">xtol=xtol</span><span class="s0">, </span><span class="s1">rtol=eps/</span><span class="s3">2</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_newton_complex_gh10103():</span>
    <span class="s2"># gh-10103 reported a problem when `newton` is pass a Python complex x0,</span>
    <span class="s2"># no `fprime` (secant method), and no `x1` (`x1` must be constructed).</span>
    <span class="s2"># Check that this is resolved.</span>
    <span class="s0">def </span><span class="s1">f(z):</span>
        <span class="s0">return </span><span class="s1">z - </span><span class="s3">1</span>
    <span class="s1">res = newton(f</span><span class="s0">, </span><span class="s3">1</span><span class="s1">+</span><span class="s3">1j</span><span class="s1">)</span>
    <span class="s1">assert_allclose(res</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-12</span><span class="s1">)</span>

    <span class="s1">res = root_scalar(f</span><span class="s0">, </span><span class="s1">x0=</span><span class="s3">1</span><span class="s1">+</span><span class="s3">1j</span><span class="s0">, </span><span class="s1">x1=</span><span class="s3">2</span><span class="s1">+</span><span class="s3">1.5j</span><span class="s0">, </span><span class="s1">method=</span><span class="s4">'secant'</span><span class="s1">)</span>
    <span class="s1">assert_allclose(res.root</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-12</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">'method'</span><span class="s0">, </span><span class="s1">all_methods)</span>
<span class="s0">def </span><span class="s1">test_maxiter_int_check_gh10236(method):</span>
    <span class="s2"># gh-10236 reported that the error message when `maxiter` is not an integer</span>
    <span class="s2"># was difficult to interpret. Check that this was resolved (by gh-10907).</span>
    <span class="s1">message = </span><span class="s4">&quot;'float' object cannot be interpreted as an integer&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=message):</span>
        <span class="s1">method(f1</span><span class="s0">, </span><span class="s3">0.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">maxiter=</span><span class="s3">72.45</span><span class="s1">)</span>
</pre>
</body>
</html>