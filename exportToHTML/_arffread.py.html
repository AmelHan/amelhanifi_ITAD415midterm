<html>
<head>
<title>_arffread.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_arffread.py</font>
</center></td></tr></table>
<pre><span class="s0"># Last Change: Mon Aug 20 08:00 PM 2007 J</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">datetime</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">import </span><span class="s1">csv</span>
<span class="s2">import </span><span class="s1">ctypes</span>

<span class="s3">&quot;&quot;&quot;A module to read arff files.&quot;&quot;&quot;</span>

<span class="s1">__all__ = [</span><span class="s3">'MetaData'</span><span class="s2">, </span><span class="s3">'loadarff'</span><span class="s2">, </span><span class="s3">'ArffError'</span><span class="s2">, </span><span class="s3">'ParseArffError'</span><span class="s1">]</span>

<span class="s0"># An Arff file is basically two parts:</span>
<span class="s0">#   - header</span>
<span class="s0">#   - data</span>
<span class="s0">#</span>
<span class="s0"># A header has each of its components starting by @META where META is one of</span>
<span class="s0"># the keyword (attribute of relation, for now).</span>

<span class="s0"># TODO:</span>
<span class="s0">#   - both integer and reals are treated as numeric -&gt; the integer info</span>
<span class="s0">#    is lost!</span>
<span class="s0">#   - Replace ValueError by ParseError or something</span>

<span class="s0"># We know can handle the following:</span>
<span class="s0">#   - numeric and nominal attributes</span>
<span class="s0">#   - missing values for numeric attributes</span>

<span class="s1">r_meta = re.compile(</span><span class="s3">r'^\s*@'</span><span class="s1">)</span>
<span class="s0"># Match a comment</span>
<span class="s1">r_comment = re.compile(</span><span class="s3">r'^%'</span><span class="s1">)</span>
<span class="s0"># Match an empty line</span>
<span class="s1">r_empty = re.compile(</span><span class="s3">r'^\s+$'</span><span class="s1">)</span>
<span class="s0"># Match a header line, that is a line which starts by @ + a word</span>
<span class="s1">r_headerline = re.compile(</span><span class="s3">r'^\s*@\S*'</span><span class="s1">)</span>
<span class="s1">r_datameta = re.compile(</span><span class="s3">r'^@[Dd][Aa][Tt][Aa]'</span><span class="s1">)</span>
<span class="s1">r_relation = re.compile(</span><span class="s3">r'^@[Rr][Ee][Ll][Aa][Tt][Ii][Oo][Nn]\s*(\S*)'</span><span class="s1">)</span>
<span class="s1">r_attribute = re.compile(</span><span class="s3">r'^\s*@[Aa][Tt][Tt][Rr][Ii][Bb][Uu][Tt][Ee]\s*(..*$)'</span><span class="s1">)</span>

<span class="s1">r_nominal = re.compile(</span><span class="s3">r'{(.+)}'</span><span class="s1">)</span>
<span class="s1">r_date = re.compile(</span><span class="s3">r&quot;[Dd][Aa][Tt][Ee]\s+[\&quot;']?(.+?)[\&quot;']?$&quot;</span><span class="s1">)</span>

<span class="s0"># To get attributes name enclosed with ''</span>
<span class="s1">r_comattrval = re.compile(</span><span class="s3">r&quot;'(..+)'\s+(..+$)&quot;</span><span class="s1">)</span>
<span class="s0"># To get normal attributes</span>
<span class="s1">r_wcomattrval = re.compile(</span><span class="s3">r&quot;(\S+)\s+(..+$)&quot;</span><span class="s1">)</span>

<span class="s0"># ------------------------</span>
<span class="s0"># Module defined exception</span>
<span class="s0"># ------------------------</span>


<span class="s2">class </span><span class="s1">ArffError(OSError):</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">ParseArffError(ArffError):</span>
    <span class="s2">pass</span>


<span class="s0"># ----------</span>
<span class="s0"># Attributes</span>
<span class="s0"># ----------</span>
<span class="s2">class </span><span class="s1">Attribute:</span>

    <span class="s1">type_name = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s1">self.name = name</span>
        <span class="s1">self.range = </span><span class="s2">None</span>
        <span class="s1">self.dtype = np.object_</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">parse_attribute(cls</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">attr_string):</span>
        <span class="s4">&quot;&quot;&quot; 
        Parse the attribute line if it knows how. Returns the parsed 
        attribute, or None. 
        &quot;&quot;&quot;</span>
        <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">parse_data(self</span><span class="s2">, </span><span class="s1">data_str):</span>
        <span class="s4">&quot;&quot;&quot; 
        Parse a value of this type. 
        &quot;&quot;&quot;</span>
        <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s4">&quot;&quot;&quot; 
        Parse a value of this type. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.name + </span><span class="s3">',' </span><span class="s1">+ self.type_name</span>


<span class="s2">class </span><span class="s1">NominalAttribute(Attribute):</span>

    <span class="s1">type_name = </span><span class="s3">'nominal'</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">values):</span>
        <span class="s1">super().__init__(name)</span>
        <span class="s1">self.values = values</span>
        <span class="s1">self.range = values</span>
        <span class="s1">self.dtype = (np.string_</span><span class="s2">, </span><span class="s1">max(len(i) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">values))</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_get_nom_val(atrv):</span>
        <span class="s4">&quot;&quot;&quot;Given a string containing a nominal type, returns a tuple of the 
        possible values. 
 
        A nominal type is defined as something framed between braces ({}). 
 
        Parameters 
        ---------- 
        atrv : str 
           Nominal type definition 
 
        Returns 
        ------- 
        poss_vals : tuple 
           possible values 
 
        Examples 
        -------- 
        &gt;&gt;&gt; get_nom_val(&quot;{floup, bouga, fl, ratata}&quot;) 
        ('floup', 'bouga', 'fl', 'ratata') 
        &quot;&quot;&quot;</span>
        <span class="s1">m = r_nominal.match(atrv)</span>
        <span class="s2">if </span><span class="s1">m:</span>
            <span class="s1">attrs</span><span class="s2">, </span><span class="s1">_ = split_data_line(m.group(</span><span class="s5">1</span><span class="s1">))</span>
            <span class="s2">return </span><span class="s1">tuple(attrs)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;This does not look like a nominal string&quot;</span><span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">parse_attribute(cls</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">attr_string):</span>
        <span class="s4">&quot;&quot;&quot; 
        Parse the attribute line if it knows how. Returns the parsed 
        attribute, or None. 
 
        For nominal attributes, the attribute string would be like '{&lt;attr_1&gt;, 
         &lt;attr2&gt;, &lt;attr_3&gt;}'. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">attr_string[</span><span class="s5">0</span><span class="s1">] == </span><span class="s3">'{'</span><span class="s1">:</span>
            <span class="s1">values = cls._get_nom_val(attr_string)</span>
            <span class="s2">return </span><span class="s1">cls(name</span><span class="s2">, </span><span class="s1">values)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">parse_data(self</span><span class="s2">, </span><span class="s1">data_str):</span>
        <span class="s4">&quot;&quot;&quot; 
        Parse a value of this type. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">data_str </span><span class="s2">in </span><span class="s1">self.values:</span>
            <span class="s2">return </span><span class="s1">data_str</span>
        <span class="s2">elif </span><span class="s1">data_str == </span><span class="s3">'?'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">data_str</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;{} value not in {}&quot;</span><span class="s1">.format(str(data_str)</span><span class="s2">,</span>
                                                     <span class="s1">str(self.values)))</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s1">msg = self.name + </span><span class="s3">&quot;,{&quot;</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(self.values)-</span><span class="s5">1</span><span class="s1">):</span>
            <span class="s1">msg += self.values[i] + </span><span class="s3">&quot;,&quot;</span>
        <span class="s1">msg += self.values[-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">msg += </span><span class="s3">&quot;}&quot;</span>
        <span class="s2">return </span><span class="s1">msg</span>


<span class="s2">class </span><span class="s1">NumericAttribute(Attribute):</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s1">super().__init__(name)</span>
        <span class="s1">self.type_name = </span><span class="s3">'numeric'</span>
        <span class="s1">self.dtype = np.float_</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">parse_attribute(cls</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">attr_string):</span>
        <span class="s4">&quot;&quot;&quot; 
        Parse the attribute line if it knows how. Returns the parsed 
        attribute, or None. 
 
        For numeric attributes, the attribute string would be like 
        'numeric' or 'int' or 'real'. 
        &quot;&quot;&quot;</span>

        <span class="s1">attr_string = attr_string.lower().strip()</span>

        <span class="s2">if </span><span class="s1">(attr_string[:len(</span><span class="s3">'numeric'</span><span class="s1">)] == </span><span class="s3">'numeric' </span><span class="s2">or</span>
           <span class="s1">attr_string[:len(</span><span class="s3">'int'</span><span class="s1">)] == </span><span class="s3">'int' </span><span class="s2">or</span>
           <span class="s1">attr_string[:len(</span><span class="s3">'real'</span><span class="s1">)] == </span><span class="s3">'real'</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s1">cls(name)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">parse_data(self</span><span class="s2">, </span><span class="s1">data_str):</span>
        <span class="s4">&quot;&quot;&quot; 
        Parse a value of this type. 
 
        Parameters 
        ---------- 
        data_str : str 
           string to convert 
 
        Returns 
        ------- 
        f : float 
           where float can be nan 
 
        Examples 
        -------- 
        &gt;&gt;&gt; atr = NumericAttribute('atr') 
        &gt;&gt;&gt; atr.parse_data('1') 
        1.0 
        &gt;&gt;&gt; atr.parse_data('1\\n') 
        1.0 
        &gt;&gt;&gt; atr.parse_data('?\\n') 
        nan 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s3">'?' </span><span class="s2">in </span><span class="s1">data_str:</span>
            <span class="s2">return </span><span class="s1">np.nan</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">float(data_str)</span>

    <span class="s2">def </span><span class="s1">_basic_stats(self</span><span class="s2">, </span><span class="s1">data):</span>
        <span class="s1">nbfac = data.size * </span><span class="s5">1. </span><span class="s1">/ (data.size - </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">(np.nanmin(data)</span><span class="s2">, </span><span class="s1">np.nanmax(data)</span><span class="s2">,</span>
                <span class="s1">np.mean(data)</span><span class="s2">, </span><span class="s1">np.std(data) * nbfac)</span>


<span class="s2">class </span><span class="s1">StringAttribute(Attribute):</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s1">super().__init__(name)</span>
        <span class="s1">self.type_name = </span><span class="s3">'string'</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">parse_attribute(cls</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">attr_string):</span>
        <span class="s4">&quot;&quot;&quot; 
        Parse the attribute line if it knows how. Returns the parsed 
        attribute, or None. 
 
        For string attributes, the attribute string would be like 
        'string'. 
        &quot;&quot;&quot;</span>

        <span class="s1">attr_string = attr_string.lower().strip()</span>

        <span class="s2">if </span><span class="s1">attr_string[:len(</span><span class="s3">'string'</span><span class="s1">)] == </span><span class="s3">'string'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">cls(name)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return None</span>


<span class="s2">class </span><span class="s1">DateAttribute(Attribute):</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">date_format</span><span class="s2">, </span><span class="s1">datetime_unit):</span>
        <span class="s1">super().__init__(name)</span>
        <span class="s1">self.date_format = date_format</span>
        <span class="s1">self.datetime_unit = datetime_unit</span>
        <span class="s1">self.type_name = </span><span class="s3">'date'</span>
        <span class="s1">self.range = date_format</span>
        <span class="s1">self.dtype = np.datetime64(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">self.datetime_unit)</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_get_date_format(atrv):</span>
        <span class="s1">m = r_date.match(atrv)</span>
        <span class="s2">if </span><span class="s1">m:</span>
            <span class="s1">pattern = m.group(</span><span class="s5">1</span><span class="s1">).strip()</span>
            <span class="s0"># convert time pattern from Java's SimpleDateFormat to C's format</span>
            <span class="s1">datetime_unit = </span><span class="s2">None</span>
            <span class="s2">if </span><span class="s3">&quot;yyyy&quot; </span><span class="s2">in </span><span class="s1">pattern:</span>
                <span class="s1">pattern = pattern.replace(</span><span class="s3">&quot;yyyy&quot;</span><span class="s2">, </span><span class="s3">&quot;%Y&quot;</span><span class="s1">)</span>
                <span class="s1">datetime_unit = </span><span class="s3">&quot;Y&quot;</span>
            <span class="s2">elif </span><span class="s3">&quot;yy&quot;</span><span class="s1">:</span>
                <span class="s1">pattern = pattern.replace(</span><span class="s3">&quot;yy&quot;</span><span class="s2">, </span><span class="s3">&quot;%y&quot;</span><span class="s1">)</span>
                <span class="s1">datetime_unit = </span><span class="s3">&quot;Y&quot;</span>
            <span class="s2">if </span><span class="s3">&quot;MM&quot; </span><span class="s2">in </span><span class="s1">pattern:</span>
                <span class="s1">pattern = pattern.replace(</span><span class="s3">&quot;MM&quot;</span><span class="s2">, </span><span class="s3">&quot;%m&quot;</span><span class="s1">)</span>
                <span class="s1">datetime_unit = </span><span class="s3">&quot;M&quot;</span>
            <span class="s2">if </span><span class="s3">&quot;dd&quot; </span><span class="s2">in </span><span class="s1">pattern:</span>
                <span class="s1">pattern = pattern.replace(</span><span class="s3">&quot;dd&quot;</span><span class="s2">, </span><span class="s3">&quot;%d&quot;</span><span class="s1">)</span>
                <span class="s1">datetime_unit = </span><span class="s3">&quot;D&quot;</span>
            <span class="s2">if </span><span class="s3">&quot;HH&quot; </span><span class="s2">in </span><span class="s1">pattern:</span>
                <span class="s1">pattern = pattern.replace(</span><span class="s3">&quot;HH&quot;</span><span class="s2">, </span><span class="s3">&quot;%H&quot;</span><span class="s1">)</span>
                <span class="s1">datetime_unit = </span><span class="s3">&quot;h&quot;</span>
            <span class="s2">if </span><span class="s3">&quot;mm&quot; </span><span class="s2">in </span><span class="s1">pattern:</span>
                <span class="s1">pattern = pattern.replace(</span><span class="s3">&quot;mm&quot;</span><span class="s2">, </span><span class="s3">&quot;%M&quot;</span><span class="s1">)</span>
                <span class="s1">datetime_unit = </span><span class="s3">&quot;m&quot;</span>
            <span class="s2">if </span><span class="s3">&quot;ss&quot; </span><span class="s2">in </span><span class="s1">pattern:</span>
                <span class="s1">pattern = pattern.replace(</span><span class="s3">&quot;ss&quot;</span><span class="s2">, </span><span class="s3">&quot;%S&quot;</span><span class="s1">)</span>
                <span class="s1">datetime_unit = </span><span class="s3">&quot;s&quot;</span>
            <span class="s2">if </span><span class="s3">&quot;z&quot; </span><span class="s2">in </span><span class="s1">pattern </span><span class="s2">or </span><span class="s3">&quot;Z&quot; </span><span class="s2">in </span><span class="s1">pattern:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Date type attributes with time zone not &quot;</span>
                                 <span class="s3">&quot;supported, yet&quot;</span><span class="s1">)</span>

            <span class="s2">if </span><span class="s1">datetime_unit </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Invalid or unsupported date format&quot;</span><span class="s1">)</span>

            <span class="s2">return </span><span class="s1">pattern</span><span class="s2">, </span><span class="s1">datetime_unit</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Invalid or no date format&quot;</span><span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">parse_attribute(cls</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">attr_string):</span>
        <span class="s4">&quot;&quot;&quot; 
        Parse the attribute line if it knows how. Returns the parsed 
        attribute, or None. 
 
        For date attributes, the attribute string would be like 
        'date &lt;format&gt;'. 
        &quot;&quot;&quot;</span>

        <span class="s1">attr_string_lower = attr_string.lower().strip()</span>

        <span class="s2">if </span><span class="s1">attr_string_lower[:len(</span><span class="s3">'date'</span><span class="s1">)] == </span><span class="s3">'date'</span><span class="s1">:</span>
            <span class="s1">date_format</span><span class="s2">, </span><span class="s1">datetime_unit = cls._get_date_format(attr_string)</span>
            <span class="s2">return </span><span class="s1">cls(name</span><span class="s2">, </span><span class="s1">date_format</span><span class="s2">, </span><span class="s1">datetime_unit)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">parse_data(self</span><span class="s2">, </span><span class="s1">data_str):</span>
        <span class="s4">&quot;&quot;&quot; 
        Parse a value of this type. 
        &quot;&quot;&quot;</span>
        <span class="s1">date_str = data_str.strip().strip(</span><span class="s3">&quot;'&quot;</span><span class="s1">).strip(</span><span class="s3">'&quot;'</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">date_str == </span><span class="s3">'?'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">np.datetime64(</span><span class="s3">'NaT'</span><span class="s2">, </span><span class="s1">self.datetime_unit)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">dt = datetime.datetime.strptime(date_str</span><span class="s2">, </span><span class="s1">self.date_format)</span>
            <span class="s2">return </span><span class="s1">np.datetime64(dt).astype(</span>
                <span class="s3">&quot;datetime64[%s]&quot; </span><span class="s1">% self.datetime_unit)</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s2">return </span><span class="s1">super().__str__() + </span><span class="s3">',' </span><span class="s1">+ self.date_format</span>


<span class="s2">class </span><span class="s1">RelationalAttribute(Attribute):</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s1">super().__init__(name)</span>
        <span class="s1">self.type_name = </span><span class="s3">'relational'</span>
        <span class="s1">self.dtype = np.object_</span>
        <span class="s1">self.attributes = []</span>
        <span class="s1">self.dialect = </span><span class="s2">None</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">parse_attribute(cls</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">attr_string):</span>
        <span class="s4">&quot;&quot;&quot; 
        Parse the attribute line if it knows how. Returns the parsed 
        attribute, or None. 
 
        For date attributes, the attribute string would be like 
        'date &lt;format&gt;'. 
        &quot;&quot;&quot;</span>

        <span class="s1">attr_string_lower = attr_string.lower().strip()</span>

        <span class="s2">if </span><span class="s1">attr_string_lower[:len(</span><span class="s3">'relational'</span><span class="s1">)] == </span><span class="s3">'relational'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">cls(name)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">parse_data(self</span><span class="s2">, </span><span class="s1">data_str):</span>
        <span class="s0"># Copy-pasted</span>
        <span class="s1">elems = list(range(len(self.attributes)))</span>

        <span class="s1">escaped_string = data_str.encode().decode(</span><span class="s3">&quot;unicode-escape&quot;</span><span class="s1">)</span>

        <span class="s1">row_tuples = []</span>

        <span class="s2">for </span><span class="s1">raw </span><span class="s2">in </span><span class="s1">escaped_string.split(</span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">):</span>
            <span class="s1">row</span><span class="s2">, </span><span class="s1">self.dialect = split_data_line(raw</span><span class="s2">, </span><span class="s1">self.dialect)</span>

            <span class="s1">row_tuples.append(tuple(</span>
                <span class="s1">[self.attributes[i].parse_data(row[i]) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">elems]))</span>

        <span class="s2">return </span><span class="s1">np.array(row_tuples</span><span class="s2">,</span>
                        <span class="s1">[(a.name</span><span class="s2">, </span><span class="s1">a.dtype) </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">self.attributes])</span>

    <span class="s2">def </span><span class="s1">__str__(self):</span>
        <span class="s2">return </span><span class="s1">(super().__str__() + </span><span class="s3">'</span><span class="s2">\n\t</span><span class="s3">' </span><span class="s1">+</span>
                <span class="s3">'</span><span class="s2">\n\t</span><span class="s3">'</span><span class="s1">.join(str(a) </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">self.attributes))</span>


<span class="s0"># -----------------</span>
<span class="s0"># Various utilities</span>
<span class="s0"># -----------------</span>
<span class="s2">def </span><span class="s1">to_attribute(name</span><span class="s2">, </span><span class="s1">attr_string):</span>
    <span class="s1">attr_classes = (NominalAttribute</span><span class="s2">, </span><span class="s1">NumericAttribute</span><span class="s2">, </span><span class="s1">DateAttribute</span><span class="s2">,</span>
                    <span class="s1">StringAttribute</span><span class="s2">, </span><span class="s1">RelationalAttribute)</span>

    <span class="s2">for </span><span class="s1">cls </span><span class="s2">in </span><span class="s1">attr_classes:</span>
        <span class="s1">attr = cls.parse_attribute(name</span><span class="s2">, </span><span class="s1">attr_string)</span>
        <span class="s2">if </span><span class="s1">attr </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">attr</span>

    <span class="s2">raise </span><span class="s1">ParseArffError(</span><span class="s3">&quot;unknown attribute %s&quot; </span><span class="s1">% attr_string)</span>


<span class="s2">def </span><span class="s1">csv_sniffer_has_bug_last_field():</span>
    <span class="s4">&quot;&quot;&quot; 
    Checks if the bug https://bugs.python.org/issue30157 is unpatched. 
    &quot;&quot;&quot;</span>

    <span class="s0"># We only compute this once.</span>
    <span class="s1">has_bug = getattr(csv_sniffer_has_bug_last_field</span><span class="s2">, </span><span class="s3">&quot;has_bug&quot;</span><span class="s2">, None</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">has_bug </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">dialect = csv.Sniffer().sniff(</span><span class="s3">&quot;3, 'a'&quot;</span><span class="s1">)</span>
        <span class="s1">csv_sniffer_has_bug_last_field.has_bug = dialect.quotechar != </span><span class="s3">&quot;'&quot;</span>
        <span class="s1">has_bug = csv_sniffer_has_bug_last_field.has_bug</span>

    <span class="s2">return </span><span class="s1">has_bug</span>


<span class="s2">def </span><span class="s1">workaround_csv_sniffer_bug_last_field(sniff_line</span><span class="s2">, </span><span class="s1">dialect</span><span class="s2">, </span><span class="s1">delimiters):</span>
    <span class="s4">&quot;&quot;&quot; 
    Workaround for the bug https://bugs.python.org/issue30157 if is unpatched. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">csv_sniffer_has_bug_last_field():</span>
        <span class="s0"># Reuses code from the csv module</span>
        <span class="s1">right_regex = </span><span class="s3">r'(?P&lt;delim&gt;[^\w\n&quot;\'])(?P&lt;space&gt; ?)(?P&lt;quote&gt;[&quot;\']).*?(?P=quote)(?:$|\n)'</span>

        <span class="s2">for </span><span class="s1">restr </span><span class="s2">in </span><span class="s1">(</span><span class="s3">r'(?P&lt;delim&gt;[^\w\n&quot;\'])(?P&lt;space&gt; ?)(?P&lt;quote&gt;[&quot;\']).*?(?P=quote)(?P=delim)'</span><span class="s2">,  </span><span class="s0"># ,&quot;.*?&quot;,</span>
                      <span class="s3">r'(?:^|\n)(?P&lt;quote&gt;[&quot;\']).*?(?P=quote)(?P&lt;delim&gt;[^\w\n&quot;\'])(?P&lt;space&gt; ?)'</span><span class="s2">,  </span><span class="s0"># .*?&quot;,</span>
                      <span class="s1">right_regex</span><span class="s2">,  </span><span class="s0"># ,&quot;.*?&quot;</span>
                      <span class="s3">r'(?:^|\n)(?P&lt;quote&gt;[&quot;\']).*?(?P=quote)(?:$|\n)'</span><span class="s1">):  </span><span class="s0"># &quot;.*?&quot; (no delim, no space)</span>
            <span class="s1">regexp = re.compile(restr</span><span class="s2">, </span><span class="s1">re.DOTALL | re.MULTILINE)</span>
            <span class="s1">matches = regexp.findall(sniff_line)</span>
            <span class="s2">if </span><span class="s1">matches:</span>
                <span class="s2">break</span>

        <span class="s0"># If it does not match the expression that was bugged, then this bug does not apply</span>
        <span class="s2">if </span><span class="s1">restr != right_regex:</span>
            <span class="s2">return</span>

        <span class="s1">groupindex = regexp.groupindex</span>

        <span class="s0"># There is only one end of the string</span>
        <span class="s2">assert </span><span class="s1">len(matches) == </span><span class="s5">1</span>
        <span class="s1">m = matches[</span><span class="s5">0</span><span class="s1">]</span>

        <span class="s1">n = groupindex[</span><span class="s3">'quote'</span><span class="s1">] - </span><span class="s5">1</span>
        <span class="s1">quote = m[n]</span>

        <span class="s1">n = groupindex[</span><span class="s3">'delim'</span><span class="s1">] - </span><span class="s5">1</span>
        <span class="s1">delim = m[n]</span>

        <span class="s1">n = groupindex[</span><span class="s3">'space'</span><span class="s1">] - </span><span class="s5">1</span>
        <span class="s1">space = bool(m[n])</span>

        <span class="s1">dq_regexp = re.compile(</span>
            <span class="s3">r&quot;((%(delim)s)|^)\W*%(quote)s[^%(delim)s\n]*%(quote)s[^%(delim)s\n]*%(quote)s\W*((%(delim)s)|$)&quot; </span><span class="s1">%</span>
            <span class="s1">{</span><span class="s3">'delim'</span><span class="s1">: re.escape(delim)</span><span class="s2">, </span><span class="s3">'quote'</span><span class="s1">: quote}</span><span class="s2">, </span><span class="s1">re.MULTILINE</span>
        <span class="s1">)</span>

        <span class="s1">doublequote = bool(dq_regexp.search(sniff_line))</span>

        <span class="s1">dialect.quotechar = quote</span>
        <span class="s2">if </span><span class="s1">delim </span><span class="s2">in </span><span class="s1">delimiters:</span>
            <span class="s1">dialect.delimiter = delim</span>
        <span class="s1">dialect.doublequote = doublequote</span>
        <span class="s1">dialect.skipinitialspace = space</span>


<span class="s2">def </span><span class="s1">split_data_line(line</span><span class="s2">, </span><span class="s1">dialect=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s1">delimiters = </span><span class="s3">&quot;,</span><span class="s2">\t</span><span class="s3">&quot;</span>

    <span class="s0"># This can not be done in a per reader basis, and relational fields</span>
    <span class="s0"># can be HUGE</span>
    <span class="s1">csv.field_size_limit(int(ctypes.c_ulong(-</span><span class="s5">1</span><span class="s1">).value // </span><span class="s5">2</span><span class="s1">))</span>

    <span class="s0"># Remove the line end if any</span>
    <span class="s2">if </span><span class="s1">line[-</span><span class="s5">1</span><span class="s1">] == </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">:</span>
        <span class="s1">line = line[:-</span><span class="s5">1</span><span class="s1">]</span>
    
    <span class="s0"># Remove potential trailing whitespace</span>
    <span class="s1">line = line.strip()</span>
    
    <span class="s1">sniff_line = line</span>

    <span class="s0"># Add a delimiter if none is present, so that the csv.Sniffer</span>
    <span class="s0"># does not complain for a single-field CSV.</span>
    <span class="s2">if not </span><span class="s1">any(d </span><span class="s2">in </span><span class="s1">line </span><span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">delimiters):</span>
        <span class="s1">sniff_line += </span><span class="s3">&quot;,&quot;</span>

    <span class="s2">if </span><span class="s1">dialect </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">dialect = csv.Sniffer().sniff(sniff_line</span><span class="s2">, </span><span class="s1">delimiters=delimiters)</span>
        <span class="s1">workaround_csv_sniffer_bug_last_field(sniff_line=sniff_line</span><span class="s2">,</span>
                                              <span class="s1">dialect=dialect</span><span class="s2">,</span>
                                              <span class="s1">delimiters=delimiters)</span>

    <span class="s1">row = next(csv.reader([line]</span><span class="s2">, </span><span class="s1">dialect))</span>

    <span class="s2">return </span><span class="s1">row</span><span class="s2">, </span><span class="s1">dialect</span>


<span class="s0"># --------------</span>
<span class="s0"># Parsing header</span>
<span class="s0"># --------------</span>
<span class="s2">def </span><span class="s1">tokenize_attribute(iterable</span><span class="s2">, </span><span class="s1">attribute):</span>
    <span class="s4">&quot;&quot;&quot;Parse a raw string in header (e.g., starts by @attribute). 
 
    Given a raw string attribute, try to get the name and type of the 
    attribute. Constraints: 
 
    * The first line must start with @attribute (case insensitive, and 
      space like characters before @attribute are allowed) 
    * Works also if the attribute is spread on multilines. 
    * Works if empty lines or comments are in between 
 
    Parameters 
    ---------- 
    attribute : str 
       the attribute string. 
 
    Returns 
    ------- 
    name : str 
       name of the attribute 
    value : str 
       value of the attribute 
    next : str 
       next line to be parsed 
 
    Examples 
    -------- 
    If attribute is a string defined in python as r&quot;floupi real&quot;, will 
    return floupi as name, and real as value. 
 
    &gt;&gt;&gt; iterable = iter([0] * 10) # dummy iterator 
    &gt;&gt;&gt; tokenize_attribute(iterable, r&quot;@attribute floupi real&quot;) 
    ('floupi', 'real', 0) 
 
    If attribute is r&quot;'floupi 2' real&quot;, will return 'floupi 2' as name, 
    and real as value. 
 
    &gt;&gt;&gt; tokenize_attribute(iterable, r&quot;  @attribute 'floupi 2' real   &quot;) 
    ('floupi 2', 'real', 0) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">sattr = attribute.strip()</span>
    <span class="s1">mattr = r_attribute.match(sattr)</span>
    <span class="s2">if </span><span class="s1">mattr:</span>
        <span class="s0"># atrv is everything after @attribute</span>
        <span class="s1">atrv = mattr.group(</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">r_comattrval.match(atrv):</span>
            <span class="s1">name</span><span class="s2">, </span><span class="s1">type = tokenize_single_comma(atrv)</span>
            <span class="s1">next_item = next(iterable)</span>
        <span class="s2">elif </span><span class="s1">r_wcomattrval.match(atrv):</span>
            <span class="s1">name</span><span class="s2">, </span><span class="s1">type = tokenize_single_wcomma(atrv)</span>
            <span class="s1">next_item = next(iterable)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># Not sure we should support this, as it does not seem supported by</span>
            <span class="s0"># weka.</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;multi line not supported yet&quot;</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;First line unparsable: %s&quot; </span><span class="s1">% sattr)</span>

    <span class="s1">attribute = to_attribute(name</span><span class="s2">, </span><span class="s1">type)</span>

    <span class="s2">if </span><span class="s1">type.lower() == </span><span class="s3">'relational'</span><span class="s1">:</span>
        <span class="s1">next_item = read_relational_attribute(iterable</span><span class="s2">, </span><span class="s1">attribute</span><span class="s2">, </span><span class="s1">next_item)</span>
    <span class="s0">#    raise ValueError(&quot;relational attributes not supported yet&quot;)</span>

    <span class="s2">return </span><span class="s1">attribute</span><span class="s2">, </span><span class="s1">next_item</span>


<span class="s2">def </span><span class="s1">tokenize_single_comma(val):</span>
    <span class="s0"># XXX we match twice the same string (here and at the caller level). It is</span>
    <span class="s0"># stupid, but it is easier for now...</span>
    <span class="s1">m = r_comattrval.match(val)</span>
    <span class="s2">if </span><span class="s1">m:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">name = m.group(</span><span class="s5">1</span><span class="s1">).strip()</span>
            <span class="s1">type = m.group(</span><span class="s5">2</span><span class="s1">).strip()</span>
        <span class="s2">except </span><span class="s1">IndexError </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Error while tokenizing attribute&quot;</span><span class="s1">) </span><span class="s2">from </span><span class="s1">e</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Error while tokenizing single %s&quot; </span><span class="s1">% val)</span>
    <span class="s2">return </span><span class="s1">name</span><span class="s2">, </span><span class="s1">type</span>


<span class="s2">def </span><span class="s1">tokenize_single_wcomma(val):</span>
    <span class="s0"># XXX we match twice the same string (here and at the caller level). It is</span>
    <span class="s0"># stupid, but it is easier for now...</span>
    <span class="s1">m = r_wcomattrval.match(val)</span>
    <span class="s2">if </span><span class="s1">m:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">name = m.group(</span><span class="s5">1</span><span class="s1">).strip()</span>
            <span class="s1">type = m.group(</span><span class="s5">2</span><span class="s1">).strip()</span>
        <span class="s2">except </span><span class="s1">IndexError </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Error while tokenizing attribute&quot;</span><span class="s1">) </span><span class="s2">from </span><span class="s1">e</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Error while tokenizing single %s&quot; </span><span class="s1">% val)</span>
    <span class="s2">return </span><span class="s1">name</span><span class="s2">, </span><span class="s1">type</span>


<span class="s2">def </span><span class="s1">read_relational_attribute(ofile</span><span class="s2">, </span><span class="s1">relational_attribute</span><span class="s2">, </span><span class="s1">i):</span>
    <span class="s4">&quot;&quot;&quot;Read the nested attributes of a relational attribute&quot;&quot;&quot;</span>

    <span class="s1">r_end_relational = re.compile(</span><span class="s3">r'^@[Ee][Nn][Dd]\s*' </span><span class="s1">+</span>
                                  <span class="s1">relational_attribute.name + </span><span class="s3">r'\s*$'</span><span class="s1">)</span>

    <span class="s2">while not </span><span class="s1">r_end_relational.match(i):</span>
        <span class="s1">m = r_headerline.match(i)</span>
        <span class="s2">if </span><span class="s1">m:</span>
            <span class="s1">isattr = r_attribute.match(i)</span>
            <span class="s2">if </span><span class="s1">isattr:</span>
                <span class="s1">attr</span><span class="s2">, </span><span class="s1">i = tokenize_attribute(ofile</span><span class="s2">, </span><span class="s1">i)</span>
                <span class="s1">relational_attribute.attributes.append(attr)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Error parsing line %s&quot; </span><span class="s1">% i)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">i = next(ofile)</span>

    <span class="s1">i = next(ofile)</span>
    <span class="s2">return </span><span class="s1">i</span>


<span class="s2">def </span><span class="s1">read_header(ofile):</span>
    <span class="s4">&quot;&quot;&quot;Read the header of the iterable ofile.&quot;&quot;&quot;</span>
    <span class="s1">i = next(ofile)</span>

    <span class="s0"># Pass first comments</span>
    <span class="s2">while </span><span class="s1">r_comment.match(i):</span>
        <span class="s1">i = next(ofile)</span>

    <span class="s0"># Header is everything up to DATA attribute ?</span>
    <span class="s1">relation = </span><span class="s2">None</span>
    <span class="s1">attributes = []</span>
    <span class="s2">while not </span><span class="s1">r_datameta.match(i):</span>
        <span class="s1">m = r_headerline.match(i)</span>
        <span class="s2">if </span><span class="s1">m:</span>
            <span class="s1">isattr = r_attribute.match(i)</span>
            <span class="s2">if </span><span class="s1">isattr:</span>
                <span class="s1">attr</span><span class="s2">, </span><span class="s1">i = tokenize_attribute(ofile</span><span class="s2">, </span><span class="s1">i)</span>
                <span class="s1">attributes.append(attr)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">isrel = r_relation.match(i)</span>
                <span class="s2">if </span><span class="s1">isrel:</span>
                    <span class="s1">relation = isrel.group(</span><span class="s5">1</span><span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;Error parsing line %s&quot; </span><span class="s1">% i)</span>
                <span class="s1">i = next(ofile)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">i = next(ofile)</span>

    <span class="s2">return </span><span class="s1">relation</span><span class="s2">, </span><span class="s1">attributes</span>


<span class="s2">class </span><span class="s1">MetaData:</span>
    <span class="s4">&quot;&quot;&quot;Small container to keep useful information on a ARFF dataset. 
 
    Knows about attributes names and types. 
 
    Examples 
    -------- 
    :: 
 
        data, meta = loadarff('iris.arff') 
        # This will print the attributes names of the iris.arff dataset 
        for i in meta: 
            print(i) 
        # This works too 
        meta.names() 
        # Getting attribute type 
        types = meta.types() 
 
    Methods 
    ------- 
    names 
    types 
 
    Notes 
    ----- 
    Also maintains the list of attributes in order, i.e., doing for i in 
    meta, where meta is an instance of MetaData, will return the 
    different attribute names in the order they were defined. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">rel</span><span class="s2">, </span><span class="s1">attr):</span>
        <span class="s1">self.name = rel</span>
        <span class="s1">self._attributes = {a.name: a </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">attr}</span>

    <span class="s2">def </span><span class="s1">__repr__(self):</span>
        <span class="s1">msg = </span><span class="s3">&quot;&quot;</span>
        <span class="s1">msg += </span><span class="s3">&quot;Dataset: %s</span><span class="s2">\n</span><span class="s3">&quot; </span><span class="s1">% self.name</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self._attributes:</span>
            <span class="s1">msg += </span><span class="s3">f&quot;</span><span class="s2">\t{</span><span class="s1">i</span><span class="s2">}</span><span class="s3">'s type is </span><span class="s2">{</span><span class="s1">self._attributes[i].type_name</span><span class="s2">}</span><span class="s3">&quot;</span>
            <span class="s2">if </span><span class="s1">self._attributes[i].range:</span>
                <span class="s1">msg += </span><span class="s3">&quot;, range is %s&quot; </span><span class="s1">% str(self._attributes[i].range)</span>
            <span class="s1">msg += </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span>
        <span class="s2">return </span><span class="s1">msg</span>

    <span class="s2">def </span><span class="s1">__iter__(self):</span>
        <span class="s2">return </span><span class="s1">iter(self._attributes)</span>

    <span class="s2">def </span><span class="s1">__getitem__(self</span><span class="s2">, </span><span class="s1">key):</span>
        <span class="s1">attr = self._attributes[key]</span>

        <span class="s2">return </span><span class="s1">(attr.type_name</span><span class="s2">, </span><span class="s1">attr.range)</span>

    <span class="s2">def </span><span class="s1">names(self):</span>
        <span class="s4">&quot;&quot;&quot;Return the list of attribute names. 
 
        Returns 
        ------- 
        attrnames : list of str 
            The attribute names. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">list(self._attributes)</span>

    <span class="s2">def </span><span class="s1">types(self):</span>
        <span class="s4">&quot;&quot;&quot;Return the list of attribute types. 
 
        Returns 
        ------- 
        attr_types : list of str 
            The attribute types. 
        &quot;&quot;&quot;</span>
        <span class="s1">attr_types = [self._attributes[name].type_name</span>
                      <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self._attributes]</span>
        <span class="s2">return </span><span class="s1">attr_types</span>


<span class="s2">def </span><span class="s1">loadarff(f):</span>
    <span class="s4">&quot;&quot;&quot; 
    Read an arff file. 
 
    The data is returned as a record array, which can be accessed much like 
    a dictionary of NumPy arrays. For example, if one of the attributes is 
    called 'pressure', then its first 10 data points can be accessed from the 
    ``data`` record array like so: ``data['pressure'][0:10]`` 
 
 
    Parameters 
    ---------- 
    f : file-like or str 
       File-like object to read from, or filename to open. 
 
    Returns 
    ------- 
    data : record array 
       The data of the arff file, accessible by attribute names. 
    meta : `MetaData` 
       Contains information about the arff file such as name and 
       type of attributes, the relation (name of the dataset), etc. 
 
    Raises 
    ------ 
    ParseArffError 
        This is raised if the given file is not ARFF-formatted. 
    NotImplementedError 
        The ARFF file has an attribute which is not supported yet. 
 
    Notes 
    ----- 
 
    This function should be able to read most arff files. Not 
    implemented functionality include: 
 
    * date type attributes 
    * string type attributes 
 
    It can read files with numeric and nominal attributes. It cannot read 
    files with sparse data ({} in the file). However, this function can 
    read files with missing data (? in the file), representing the data 
    points as NaNs. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.io import arff 
    &gt;&gt;&gt; from io import StringIO 
    &gt;&gt;&gt; content = \&quot;\&quot;\&quot; 
    ... @relation foo 
    ... @attribute width  numeric 
    ... @attribute height numeric 
    ... @attribute color  {red,green,blue,yellow,black} 
    ... @data 
    ... 5.0,3.25,blue 
    ... 4.5,3.75,green 
    ... 3.0,4.00,red 
    ... \&quot;\&quot;\&quot; 
    &gt;&gt;&gt; f = StringIO(content) 
    &gt;&gt;&gt; data, meta = arff.loadarff(f) 
    &gt;&gt;&gt; data 
    array([(5.0, 3.25, 'blue'), (4.5, 3.75, 'green'), (3.0, 4.0, 'red')], 
          dtype=[('width', '&lt;f8'), ('height', '&lt;f8'), ('color', '|S6')]) 
    &gt;&gt;&gt; meta 
    Dataset: foo 
    \twidth's type is numeric 
    \theight's type is numeric 
    \tcolor's type is nominal, range is ('red', 'green', 'blue', 'yellow', 'black') 
 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">hasattr(f</span><span class="s2">, </span><span class="s3">'read'</span><span class="s1">):</span>
        <span class="s1">ofile = f</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">ofile = open(f)</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">_loadarff(ofile)</span>
    <span class="s2">finally</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">ofile </span><span class="s2">is not </span><span class="s1">f:  </span><span class="s0"># only close what we opened</span>
            <span class="s1">ofile.close()</span>


<span class="s2">def </span><span class="s1">_loadarff(ofile):</span>
    <span class="s0"># Parse the header file</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s1">rel</span><span class="s2">, </span><span class="s1">attr = read_header(ofile)</span>
    <span class="s2">except </span><span class="s1">ValueError </span><span class="s2">as </span><span class="s1">e:</span>
        <span class="s1">msg = </span><span class="s3">&quot;Error while parsing header, error was: &quot; </span><span class="s1">+ str(e)</span>
        <span class="s2">raise </span><span class="s1">ParseArffError(msg) </span><span class="s2">from </span><span class="s1">e</span>

    <span class="s0"># Check whether we have a string attribute (not supported yet)</span>
    <span class="s1">hasstr = </span><span class="s2">False</span>
    <span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">attr:</span>
        <span class="s2">if </span><span class="s1">isinstance(a</span><span class="s2">, </span><span class="s1">StringAttribute):</span>
            <span class="s1">hasstr = </span><span class="s2">True</span>

    <span class="s1">meta = MetaData(rel</span><span class="s2">, </span><span class="s1">attr)</span>

    <span class="s0"># XXX The following code is not great</span>
    <span class="s0"># Build the type descriptor descr and the list of convertors to convert</span>
    <span class="s0"># each attribute to the suitable type (which should match the one in</span>
    <span class="s0"># descr).</span>

    <span class="s0"># This can be used once we want to support integer as integer values and</span>
    <span class="s0"># not as numeric anymore (using masked arrays ?).</span>

    <span class="s2">if </span><span class="s1">hasstr:</span>
        <span class="s0"># How to support string efficiently ? Ideally, we should know the max</span>
        <span class="s0"># size of the string before allocating the numpy array.</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError(</span><span class="s3">&quot;String attributes not supported yet, sorry&quot;</span><span class="s1">)</span>

    <span class="s1">ni = len(attr)</span>

    <span class="s2">def </span><span class="s1">generator(row_iter</span><span class="s2">, </span><span class="s1">delim=</span><span class="s3">','</span><span class="s1">):</span>
        <span class="s0"># TODO: this is where we are spending time (~80%). I think things</span>
        <span class="s0"># could be made more efficiently:</span>
        <span class="s0">#   - We could for example &quot;compile&quot; the function, because some values</span>
        <span class="s0">#   do not change here.</span>
        <span class="s0">#   - The function to convert a line to dtyped values could also be</span>
        <span class="s0">#   generated on the fly from a string and be executed instead of</span>
        <span class="s0">#   looping.</span>
        <span class="s0">#   - The regex are overkill: for comments, checking that a line starts</span>
        <span class="s0">#   by % should be enough and faster, and for empty lines, same thing</span>
        <span class="s0">#   --&gt; this does not seem to change anything.</span>

        <span class="s0"># 'compiling' the range since it does not change</span>
        <span class="s0"># Note, I have already tried zipping the converters and</span>
        <span class="s0"># row elements and got slightly worse performance.</span>
        <span class="s1">elems = list(range(ni))</span>

        <span class="s1">dialect = </span><span class="s2">None</span>
        <span class="s2">for </span><span class="s1">raw </span><span class="s2">in </span><span class="s1">row_iter:</span>
            <span class="s0"># We do not abstract skipping comments and empty lines for</span>
            <span class="s0"># performance reasons.</span>
            <span class="s2">if </span><span class="s1">r_comment.match(raw) </span><span class="s2">or </span><span class="s1">r_empty.match(raw):</span>
                <span class="s2">continue</span>

            <span class="s1">row</span><span class="s2">, </span><span class="s1">dialect = split_data_line(raw</span><span class="s2">, </span><span class="s1">dialect)</span>

            <span class="s2">yield </span><span class="s1">tuple([attr[i].parse_data(row[i]) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">elems])</span>

    <span class="s1">a = list(generator(ofile))</span>
    <span class="s0"># No error should happen here: it is a bug otherwise</span>
    <span class="s1">data = np.array(a</span><span class="s2">, </span><span class="s1">[(a.name</span><span class="s2">, </span><span class="s1">a.dtype) </span><span class="s2">for </span><span class="s1">a </span><span class="s2">in </span><span class="s1">attr])</span>
    <span class="s2">return </span><span class="s1">data</span><span class="s2">, </span><span class="s1">meta</span>


<span class="s0"># ----</span>
<span class="s0"># Misc</span>
<span class="s0"># ----</span>
<span class="s2">def </span><span class="s1">basic_stats(data):</span>
    <span class="s1">nbfac = data.size * </span><span class="s5">1. </span><span class="s1">/ (data.size - </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">np.nanmin(data)</span><span class="s2">, </span><span class="s1">np.nanmax(data)</span><span class="s2">, </span><span class="s1">np.mean(data)</span><span class="s2">, </span><span class="s1">np.std(data) * nbfac</span>


<span class="s2">def </span><span class="s1">print_attribute(name</span><span class="s2">, </span><span class="s1">tp</span><span class="s2">, </span><span class="s1">data):</span>
    <span class="s1">type = tp.type_name</span>
    <span class="s2">if </span><span class="s1">type == </span><span class="s3">'numeric' </span><span class="s2">or </span><span class="s1">type == </span><span class="s3">'real' </span><span class="s2">or </span><span class="s1">type == </span><span class="s3">'integer'</span><span class="s1">:</span>
        <span class="s1">min</span><span class="s2">, </span><span class="s1">max</span><span class="s2">, </span><span class="s1">mean</span><span class="s2">, </span><span class="s1">std = basic_stats(data)</span>
        <span class="s1">print(</span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s3">,</span><span class="s2">{</span><span class="s1">type</span><span class="s2">}</span><span class="s3">,</span><span class="s2">{</span><span class="s1">min</span><span class="s2">:</span><span class="s3">f</span><span class="s2">}</span><span class="s3">,</span><span class="s2">{</span><span class="s1">max</span><span class="s2">:</span><span class="s3">f</span><span class="s2">}</span><span class="s3">,</span><span class="s2">{</span><span class="s1">mean</span><span class="s2">:</span><span class="s3">f</span><span class="s2">}</span><span class="s3">,</span><span class="s2">{</span><span class="s1">std</span><span class="s2">:</span><span class="s3">f</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">print(str(tp))</span>


<span class="s2">def </span><span class="s1">test_weka(filename):</span>
    <span class="s1">data</span><span class="s2">, </span><span class="s1">meta = loadarff(filename)</span>
    <span class="s1">print(len(data.dtype))</span>
    <span class="s1">print(data.size)</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">meta:</span>
        <span class="s1">print_attribute(i</span><span class="s2">, </span><span class="s1">meta[i]</span><span class="s2">, </span><span class="s1">data[i])</span>


<span class="s0"># make sure nose does not find this as a test</span>
<span class="s1">test_weka.__test__ = </span><span class="s2">False</span>


<span class="s2">if </span><span class="s1">__name__ == </span><span class="s3">'__main__'</span><span class="s1">:</span>
    <span class="s2">import </span><span class="s1">sys</span>
    <span class="s1">filename = sys.argv[</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">test_weka(filename)</span>
</pre>
</body>
</html>