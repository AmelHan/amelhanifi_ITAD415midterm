<html>
<head>
<title>_bsr.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_bsr.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Compressed Block Sparse Row format&quot;&quot;&quot;</span>

<span class="s1">__docformat__ = </span><span class="s2">&quot;restructuredtext en&quot;</span>

<span class="s1">__all__ = [</span><span class="s2">'bsr_array'</span><span class="s3">, </span><span class="s2">'bsr_matrix'</span><span class="s3">, </span><span class="s2">'isspmatrix_bsr'</span><span class="s1">]</span>

<span class="s3">from </span><span class="s1">warnings </span><span class="s3">import </span><span class="s1">warn</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>

<span class="s3">from </span><span class="s1">._matrix </span><span class="s3">import </span><span class="s1">spmatrix</span><span class="s3">, </span><span class="s1">_array_doc_to_matrix</span>
<span class="s3">from </span><span class="s1">._data </span><span class="s3">import </span><span class="s1">_data_matrix</span><span class="s3">, </span><span class="s1">_minmax_mixin</span>
<span class="s3">from </span><span class="s1">._compressed </span><span class="s3">import </span><span class="s1">_cs_matrix</span>
<span class="s3">from </span><span class="s1">._base </span><span class="s3">import </span><span class="s1">issparse</span><span class="s3">, </span><span class="s1">_formats</span><span class="s3">, </span><span class="s1">_spbase</span><span class="s3">, </span><span class="s1">sparray</span>
<span class="s3">from </span><span class="s1">._sputils </span><span class="s3">import </span><span class="s1">(isshape</span><span class="s3">, </span><span class="s1">getdtype</span><span class="s3">, </span><span class="s1">getdata</span><span class="s3">, </span><span class="s1">to_native</span><span class="s3">, </span><span class="s1">upcast</span><span class="s3">,</span>
                       <span class="s1">check_shape)</span>
<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">_sparsetools</span>
<span class="s3">from </span><span class="s1">._sparsetools </span><span class="s3">import </span><span class="s1">(bsr_matvec</span><span class="s3">, </span><span class="s1">bsr_matvecs</span><span class="s3">, </span><span class="s1">csr_matmat_maxnnz</span><span class="s3">,</span>
                           <span class="s1">bsr_matmat</span><span class="s3">, </span><span class="s1">bsr_transpose</span><span class="s3">, </span><span class="s1">bsr_sort_indices</span><span class="s3">,</span>
                           <span class="s1">bsr_tocsr)</span>


<span class="s3">class </span><span class="s1">_bsr_base(_cs_matrix</span><span class="s3">, </span><span class="s1">_minmax_mixin):</span>
    <span class="s0">&quot;&quot;&quot;Block Sparse Row format sparse array. 
 
    This can be instantiated in several ways: 
        bsr_array(D, [blocksize=(R,C)]) 
            where D is a dense matrix or 2-D ndarray. 
 
        bsr_array(S, [blocksize=(R,C)]) 
            with another sparse array S (equivalent to S.tobsr()) 
 
        bsr_array((M, N), [blocksize=(R,C), dtype]) 
            to construct an empty sparse array with shape (M, N) 
            dtype is optional, defaulting to dtype='d'. 
 
        bsr_array((data, ij), [blocksize=(R,C), shape=(M, N)]) 
            where ``data`` and ``ij`` satisfy ``a[ij[0, k], ij[1, k]] = data[k]`` 
 
        bsr_array((data, indices, indptr), [shape=(M, N)]) 
            is the standard BSR representation where the block column 
            indices for row i are stored in ``indices[indptr[i]:indptr[i+1]]`` 
            and their corresponding block values are stored in 
            ``data[ indptr[i]: indptr[i+1] ]``. If the shape parameter is not 
            supplied, the array dimensions are inferred from the index arrays. 
 
    Attributes 
    ---------- 
    dtype : dtype 
        Data type of the array 
    shape : 2-tuple 
        Shape of the array 
    ndim : int 
        Number of dimensions (this is always 2) 
    nnz 
        Number of stored values, including explicit zeros 
    data 
        Data array 
    indices 
        BSR format index array 
    indptr 
        BSR format index pointer array 
    blocksize 
        Block size 
    has_sorted_indices 
        Whether indices are sorted 
 
    Notes 
    ----- 
    Sparse arrays can be used in arithmetic operations: they support 
    addition, subtraction, multiplication, division, and matrix power. 
 
    **Summary of BSR format** 
 
    The Block Compressed Row (BSR) format is very similar to the Compressed 
    Sparse Row (CSR) format. BSR is appropriate for sparse matrices with dense 
    sub matrices like the last example below.  Block matrices often arise in 
    vector-valued finite element discretizations. In such cases, BSR is 
    considerably more efficient than CSR and CSC for many sparse arithmetic 
    operations. 
 
    **Blocksize** 
 
    The blocksize (R,C) must evenly divide the shape of the sparse array (M,N). 
    That is, R and C must satisfy the relationship ``M % R = 0`` and 
    ``N % C = 0``. 
 
    If no blocksize is specified, a simple heuristic is applied to determine 
    an appropriate blocksize. 
 
    **Canonical Format** 
 
    In canonical format, there are no duplicate blocks and indices are sorted 
    per row. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.sparse import bsr_array 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; bsr_array((3, 4), dtype=np.int8).toarray() 
    array([[0, 0, 0, 0], 
           [0, 0, 0, 0], 
           [0, 0, 0, 0]], dtype=int8) 
 
    &gt;&gt;&gt; row = np.array([0, 0, 1, 2, 2, 2]) 
    &gt;&gt;&gt; col = np.array([0, 2, 2, 0, 1, 2]) 
    &gt;&gt;&gt; data = np.array([1, 2, 3 ,4, 5, 6]) 
    &gt;&gt;&gt; bsr_array((data, (row, col)), shape=(3, 3)).toarray() 
    array([[1, 0, 2], 
           [0, 0, 3], 
           [4, 5, 6]]) 
 
    &gt;&gt;&gt; indptr = np.array([0, 2, 3, 6]) 
    &gt;&gt;&gt; indices = np.array([0, 2, 2, 0, 1, 2]) 
    &gt;&gt;&gt; data = np.array([1, 2, 3, 4, 5, 6]).repeat(4).reshape(6, 2, 2) 
    &gt;&gt;&gt; bsr_array((data,indices,indptr), shape=(6, 6)).toarray() 
    array([[1, 1, 0, 0, 2, 2], 
           [1, 1, 0, 0, 2, 2], 
           [0, 0, 0, 0, 3, 3], 
           [0, 0, 0, 0, 3, 3], 
           [4, 4, 5, 5, 6, 6], 
           [4, 4, 5, 5, 6, 6]]) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">_format = </span><span class="s2">'bsr'</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">arg1</span><span class="s3">, </span><span class="s1">shape=</span><span class="s3">None, </span><span class="s1">dtype=</span><span class="s3">None, </span><span class="s1">copy=</span><span class="s3">False, </span><span class="s1">blocksize=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">_data_matrix.__init__(self)</span>

        <span class="s3">if </span><span class="s1">issparse(arg1):</span>
            <span class="s3">if </span><span class="s1">arg1.format == self.format </span><span class="s3">and </span><span class="s1">copy:</span>
                <span class="s1">arg1 = arg1.copy()</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">arg1 = arg1.tobsr(blocksize=blocksize)</span>
            <span class="s1">self._set_self(arg1)</span>

        <span class="s3">elif </span><span class="s1">isinstance(arg1</span><span class="s3">,</span><span class="s1">tuple):</span>
            <span class="s3">if </span><span class="s1">isshape(arg1):</span>
                <span class="s4"># it's a tuple of matrix dimensions (M,N)</span>
                <span class="s1">self._shape = check_shape(arg1)</span>
                <span class="s1">M</span><span class="s3">,</span><span class="s1">N = self.shape</span>
                <span class="s4"># process blocksize</span>
                <span class="s3">if </span><span class="s1">blocksize </span><span class="s3">is None</span><span class="s1">:</span>
                    <span class="s1">blocksize = (</span><span class="s5">1</span><span class="s3">,</span><span class="s5">1</span><span class="s1">)</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s3">if not </span><span class="s1">isshape(blocksize):</span>
                        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">'invalid blocksize=%s' </span><span class="s1">% blocksize)</span>
                    <span class="s1">blocksize = tuple(blocksize)</span>
                <span class="s1">self.data = np.zeros((</span><span class="s5">0</span><span class="s3">,</span><span class="s1">) + blocksize</span><span class="s3">, </span><span class="s1">getdtype(dtype</span><span class="s3">, </span><span class="s1">default=float))</span>

                <span class="s1">R</span><span class="s3">,</span><span class="s1">C = blocksize</span>
                <span class="s3">if </span><span class="s1">(M % R) != </span><span class="s5">0 </span><span class="s3">or </span><span class="s1">(N % C) != </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">'shape must be multiple of blocksize'</span><span class="s1">)</span>

                <span class="s4"># Select index dtype large enough to pass array and</span>
                <span class="s4"># scalar parameters to sparsetools</span>
                <span class="s1">idx_dtype = self._get_index_dtype(maxval=max(M//R</span><span class="s3">, </span><span class="s1">N//C</span><span class="s3">, </span><span class="s1">R</span><span class="s3">, </span><span class="s1">C))</span>
                <span class="s1">self.indices = np.zeros(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">dtype=idx_dtype)</span>
                <span class="s1">self.indptr = np.zeros(M//R + </span><span class="s5">1</span><span class="s3">, </span><span class="s1">dtype=idx_dtype)</span>

            <span class="s3">elif </span><span class="s1">len(arg1) == </span><span class="s5">2</span><span class="s1">:</span>
                <span class="s4"># (data,(row,col)) format</span>
                <span class="s1">self._set_self(</span>
                    <span class="s1">self._coo_container(arg1</span><span class="s3">, </span><span class="s1">dtype=dtype</span><span class="s3">, </span><span class="s1">shape=shape).tobsr(</span>
                        <span class="s1">blocksize=blocksize</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>

            <span class="s3">elif </span><span class="s1">len(arg1) == </span><span class="s5">3</span><span class="s1">:</span>
                <span class="s4"># (data,indices,indptr) format</span>
                <span class="s1">(data</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">indptr) = arg1</span>

                <span class="s4"># Select index dtype large enough to pass array and</span>
                <span class="s4"># scalar parameters to sparsetools</span>
                <span class="s1">maxval = </span><span class="s5">1</span>
                <span class="s3">if </span><span class="s1">shape </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s1">maxval = max(shape)</span>
                <span class="s3">if </span><span class="s1">blocksize </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s1">maxval = max(maxval</span><span class="s3">, </span><span class="s1">max(blocksize))</span>
                <span class="s1">idx_dtype = self._get_index_dtype((indices</span><span class="s3">, </span><span class="s1">indptr)</span><span class="s3">, </span><span class="s1">maxval=maxval</span><span class="s3">,</span>
                                                  <span class="s1">check_contents=</span><span class="s3">True</span><span class="s1">)</span>
                <span class="s1">self.indices = np.array(indices</span><span class="s3">, </span><span class="s1">copy=copy</span><span class="s3">, </span><span class="s1">dtype=idx_dtype)</span>
                <span class="s1">self.indptr = np.array(indptr</span><span class="s3">, </span><span class="s1">copy=copy</span><span class="s3">, </span><span class="s1">dtype=idx_dtype)</span>
                <span class="s1">self.data = getdata(data</span><span class="s3">, </span><span class="s1">copy=copy</span><span class="s3">, </span><span class="s1">dtype=dtype)</span>
                <span class="s3">if </span><span class="s1">self.data.ndim != </span><span class="s5">3</span><span class="s1">:</span>
                    <span class="s3">raise </span><span class="s1">ValueError(</span>
                        <span class="s2">'BSR data must be 3-dimensional, got shape={}'</span><span class="s1">.format(</span>
                            <span class="s1">self.data.shape</span><span class="s3">,</span><span class="s1">))</span>
                <span class="s3">if </span><span class="s1">blocksize </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s3">if not </span><span class="s1">isshape(blocksize):</span>
                        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">f'invalid blocksize=</span><span class="s3">{</span><span class="s1">blocksize</span><span class="s3">}</span><span class="s2">'</span><span class="s1">)</span>
                    <span class="s3">if </span><span class="s1">tuple(blocksize) != self.data.shape[</span><span class="s5">1</span><span class="s1">:]:</span>
                        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">'mismatching blocksize={} vs {}'</span><span class="s1">.format(</span>
                            <span class="s1">blocksize</span><span class="s3">, </span><span class="s1">self.data.shape[</span><span class="s5">1</span><span class="s1">:]))</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">'unrecognized bsr_array constructor usage'</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s4"># must be dense</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">arg1 = np.asarray(arg1)</span>
            <span class="s3">except </span><span class="s1">Exception </span><span class="s3">as </span><span class="s1">e:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;unrecognized form for&quot;</span>
                        <span class="s2">&quot; %s_matrix constructor&quot; </span><span class="s1">% self.format) </span><span class="s3">from </span><span class="s1">e</span>
            <span class="s1">arg1 = self._coo_container(</span>
                <span class="s1">arg1</span><span class="s3">, </span><span class="s1">dtype=dtype</span>
            <span class="s1">).tobsr(blocksize=blocksize)</span>
            <span class="s1">self._set_self(arg1)</span>

        <span class="s3">if </span><span class="s1">shape </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self._shape = check_shape(shape)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">self.shape </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s4"># shape not already set, try to infer dimensions</span>
                <span class="s3">try</span><span class="s1">:</span>
                    <span class="s1">M = len(self.indptr) - </span><span class="s5">1</span>
                    <span class="s1">N = self.indices.max() + </span><span class="s5">1</span>
                <span class="s3">except </span><span class="s1">Exception </span><span class="s3">as </span><span class="s1">e:</span>
                    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">'unable to infer matrix dimensions'</span><span class="s1">) </span><span class="s3">from </span><span class="s1">e</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">R</span><span class="s3">,</span><span class="s1">C = self.blocksize</span>
                    <span class="s1">self._shape = check_shape((M*R</span><span class="s3">,</span><span class="s1">N*C))</span>

        <span class="s3">if </span><span class="s1">self.shape </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">shape </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s4"># TODO infer shape here</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">'need to infer shape'</span><span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">self._shape = check_shape(shape)</span>

        <span class="s3">if </span><span class="s1">dtype </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">self.data = self.data.astype(dtype</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">)</span>

        <span class="s1">self.check_format(full_check=</span><span class="s3">False</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">check_format(self</span><span class="s3">, </span><span class="s1">full_check=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;check whether the matrix format is valid 
 
            *Parameters*: 
                full_check: 
                    True  - rigorous check, O(N) operations : default 
                    False - basic check, O(1) operations 
 
        &quot;&quot;&quot;</span>
        <span class="s1">M</span><span class="s3">,</span><span class="s1">N = self.shape</span>
        <span class="s1">R</span><span class="s3">,</span><span class="s1">C = self.blocksize</span>

        <span class="s4"># index arrays should have integer data types</span>
        <span class="s3">if </span><span class="s1">self.indptr.dtype.kind != </span><span class="s2">'i'</span><span class="s1">:</span>
            <span class="s1">warn(</span><span class="s2">&quot;indptr array has non-integer dtype (%s)&quot;</span>
                    <span class="s1">% self.indptr.dtype.name)</span>
        <span class="s3">if </span><span class="s1">self.indices.dtype.kind != </span><span class="s2">'i'</span><span class="s1">:</span>
            <span class="s1">warn(</span><span class="s2">&quot;indices array has non-integer dtype (%s)&quot;</span>
                    <span class="s1">% self.indices.dtype.name)</span>

        <span class="s1">idx_dtype = self._get_index_dtype((self.indices</span><span class="s3">, </span><span class="s1">self.indptr))</span>
        <span class="s1">self.indptr = np.asarray(self.indptr</span><span class="s3">, </span><span class="s1">dtype=idx_dtype)</span>
        <span class="s1">self.indices = np.asarray(self.indices</span><span class="s3">, </span><span class="s1">dtype=idx_dtype)</span>
        <span class="s1">self.data = to_native(self.data)</span>

        <span class="s4"># check array shapes</span>
        <span class="s3">if </span><span class="s1">self.indices.ndim != </span><span class="s5">1 </span><span class="s3">or </span><span class="s1">self.indptr.ndim != </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;indices, and indptr should be 1-D&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">self.data.ndim != </span><span class="s5">3</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;data should be 3-D&quot;</span><span class="s1">)</span>

        <span class="s4"># check index pointer</span>
        <span class="s3">if </span><span class="s1">(len(self.indptr) != M//R + </span><span class="s5">1</span><span class="s1">):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;index pointer size (%d) should be (%d)&quot; </span><span class="s1">%</span>
                                <span class="s1">(len(self.indptr)</span><span class="s3">, </span><span class="s1">M//R + </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s3">if </span><span class="s1">(self.indptr[</span><span class="s5">0</span><span class="s1">] != </span><span class="s5">0</span><span class="s1">):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;index pointer should start with 0&quot;</span><span class="s1">)</span>

        <span class="s4"># check index and data arrays</span>
        <span class="s3">if </span><span class="s1">(len(self.indices) != len(self.data)):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;indices and data should have the same size&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">(self.indptr[-</span><span class="s5">1</span><span class="s1">] &gt; len(self.indices)):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Last value of index pointer should be less than &quot;</span>
                                <span class="s2">&quot;the size of index and data arrays&quot;</span><span class="s1">)</span>

        <span class="s1">self.prune()</span>

        <span class="s3">if </span><span class="s1">full_check:</span>
            <span class="s4"># check format validity (more expensive)</span>
            <span class="s3">if </span><span class="s1">self.nnz &gt; </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">self.indices.max() &gt;= N//C:</span>
                    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;column index values must be &lt; %d (now max %d)&quot; </span><span class="s1">% (N//C</span><span class="s3">, </span><span class="s1">self.indices.max()))</span>
                <span class="s3">if </span><span class="s1">self.indices.min() &lt; </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;column index values must be &gt;= 0&quot;</span><span class="s1">)</span>
                <span class="s3">if </span><span class="s1">np.diff(self.indptr).min() &lt; </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;index pointer values must form a &quot;</span>
                                        <span class="s2">&quot;non-decreasing sequence&quot;</span><span class="s1">)</span>

        <span class="s4"># if not self.has_sorted_indices():</span>
        <span class="s4">#    warn('Indices were not in sorted order. Sorting indices.')</span>
        <span class="s4">#    self.sort_indices(check_first=False)</span>

    <span class="s3">def </span><span class="s1">_get_blocksize(self):</span>
        <span class="s3">return </span><span class="s1">self.data.shape[</span><span class="s5">1</span><span class="s1">:]</span>
    <span class="s1">blocksize = property(fget=_get_blocksize)</span>

    <span class="s3">def </span><span class="s1">_getnnz(self</span><span class="s3">, </span><span class="s1">axis=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">axis </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s2">&quot;_getnnz over an axis is not implemented &quot;</span>
                                      <span class="s2">&quot;for BSR format&quot;</span><span class="s1">)</span>
        <span class="s1">R</span><span class="s3">,</span><span class="s1">C = self.blocksize</span>
        <span class="s3">return </span><span class="s1">int(self.indptr[-</span><span class="s5">1</span><span class="s1">] * R * C)</span>

    <span class="s1">_getnnz.__doc__ = _spbase._getnnz.__doc__</span>

    <span class="s3">def </span><span class="s1">__repr__(self):</span>
        <span class="s1">format = _formats[self.format][</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s3">return </span><span class="s1">(</span><span class="s2">&quot;&lt;%dx%d sparse matrix of type '%s'</span><span class="s3">\n</span><span class="s2">&quot;</span>
                <span class="s2">&quot;</span><span class="s3">\t</span><span class="s2">with %d stored elements (blocksize = %dx%d) in %s format&gt;&quot; </span><span class="s1">%</span>
                <span class="s1">(self.shape + (self.dtype.type</span><span class="s3">, </span><span class="s1">self.nnz) + self.blocksize +</span>
                 <span class="s1">(format</span><span class="s3">,</span><span class="s1">)))</span>

    <span class="s3">def </span><span class="s1">diagonal(self</span><span class="s3">, </span><span class="s1">k=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s1">rows</span><span class="s3">, </span><span class="s1">cols = self.shape</span>
        <span class="s3">if </span><span class="s1">k &lt;= -rows </span><span class="s3">or </span><span class="s1">k &gt;= cols:</span>
            <span class="s3">return </span><span class="s1">np.empty(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">dtype=self.data.dtype)</span>
        <span class="s1">R</span><span class="s3">, </span><span class="s1">C = self.blocksize</span>
        <span class="s1">y = np.zeros(min(rows + min(k</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span><span class="s3">, </span><span class="s1">cols - max(k</span><span class="s3">, </span><span class="s5">0</span><span class="s1">))</span><span class="s3">,</span>
                     <span class="s1">dtype=upcast(self.dtype))</span>
        <span class="s1">_sparsetools.bsr_diagonal(k</span><span class="s3">, </span><span class="s1">rows // R</span><span class="s3">, </span><span class="s1">cols // C</span><span class="s3">, </span><span class="s1">R</span><span class="s3">, </span><span class="s1">C</span><span class="s3">,</span>
                                  <span class="s1">self.indptr</span><span class="s3">, </span><span class="s1">self.indices</span><span class="s3">,</span>
                                  <span class="s1">np.ravel(self.data)</span><span class="s3">, </span><span class="s1">y)</span>
        <span class="s3">return </span><span class="s1">y</span>

    <span class="s1">diagonal.__doc__ = _spbase.diagonal.__doc__</span>

    <span class="s4">##########################</span>
    <span class="s4"># NotImplemented methods #</span>
    <span class="s4">##########################</span>

    <span class="s3">def </span><span class="s1">__getitem__(self</span><span class="s3">,</span><span class="s1">key):</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span>

    <span class="s3">def </span><span class="s1">__setitem__(self</span><span class="s3">,</span><span class="s1">key</span><span class="s3">,</span><span class="s1">val):</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span>

    <span class="s4">######################</span>
    <span class="s4"># Arithmetic methods #</span>
    <span class="s4">######################</span>

    <span class="s3">def </span><span class="s1">_add_dense(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">return </span><span class="s1">self.tocoo(copy=</span><span class="s3">False</span><span class="s1">)._add_dense(other)</span>

    <span class="s3">def </span><span class="s1">_mul_vector(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s1">M</span><span class="s3">,</span><span class="s1">N = self.shape</span>
        <span class="s1">R</span><span class="s3">,</span><span class="s1">C = self.blocksize</span>

        <span class="s1">result = np.zeros(self.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dtype=upcast(self.dtype</span><span class="s3">, </span><span class="s1">other.dtype))</span>

        <span class="s1">bsr_matvec(M//R</span><span class="s3">, </span><span class="s1">N//C</span><span class="s3">, </span><span class="s1">R</span><span class="s3">, </span><span class="s1">C</span><span class="s3">,</span>
            <span class="s1">self.indptr</span><span class="s3">, </span><span class="s1">self.indices</span><span class="s3">, </span><span class="s1">self.data.ravel()</span><span class="s3">,</span>
            <span class="s1">other</span><span class="s3">, </span><span class="s1">result)</span>

        <span class="s3">return </span><span class="s1">result</span>

    <span class="s3">def </span><span class="s1">_mul_multivector(self</span><span class="s3">,</span><span class="s1">other):</span>
        <span class="s1">R</span><span class="s3">,</span><span class="s1">C = self.blocksize</span>
        <span class="s1">M</span><span class="s3">,</span><span class="s1">N = self.shape</span>
        <span class="s1">n_vecs = other.shape[</span><span class="s5">1</span><span class="s1">]  </span><span class="s4"># number of column vectors</span>

        <span class="s1">result = np.zeros((M</span><span class="s3">,</span><span class="s1">n_vecs)</span><span class="s3">, </span><span class="s1">dtype=upcast(self.dtype</span><span class="s3">,</span><span class="s1">other.dtype))</span>

        <span class="s1">bsr_matvecs(M//R</span><span class="s3">, </span><span class="s1">N//C</span><span class="s3">, </span><span class="s1">n_vecs</span><span class="s3">, </span><span class="s1">R</span><span class="s3">, </span><span class="s1">C</span><span class="s3">,</span>
                <span class="s1">self.indptr</span><span class="s3">, </span><span class="s1">self.indices</span><span class="s3">, </span><span class="s1">self.data.ravel()</span><span class="s3">,</span>
                <span class="s1">other.ravel()</span><span class="s3">, </span><span class="s1">result.ravel())</span>

        <span class="s3">return </span><span class="s1">result</span>

    <span class="s3">def </span><span class="s1">_mul_sparse_matrix(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s1">M</span><span class="s3">, </span><span class="s1">K1 = self.shape</span>
        <span class="s1">K2</span><span class="s3">, </span><span class="s1">N = other.shape</span>

        <span class="s1">R</span><span class="s3">,</span><span class="s1">n = self.blocksize</span>

        <span class="s4"># convert to this format</span>
        <span class="s3">if </span><span class="s1">other.format == </span><span class="s2">&quot;bsr&quot;</span><span class="s1">:</span>
            <span class="s1">C = other.blocksize[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">C = </span><span class="s5">1</span>

        <span class="s3">if </span><span class="s1">other.format == </span><span class="s2">&quot;csr&quot; </span><span class="s3">and </span><span class="s1">n == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">other = other.tobsr(blocksize=(n</span><span class="s3">,</span><span class="s1">C)</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">)  </span><span class="s4"># lightweight conversion</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">other = other.tobsr(blocksize=(n</span><span class="s3">,</span><span class="s1">C))</span>

        <span class="s1">idx_dtype = self._get_index_dtype((self.indptr</span><span class="s3">, </span><span class="s1">self.indices</span><span class="s3">,</span>
                                           <span class="s1">other.indptr</span><span class="s3">, </span><span class="s1">other.indices))</span>

        <span class="s1">bnnz = csr_matmat_maxnnz(M//R</span><span class="s3">, </span><span class="s1">N//C</span><span class="s3">,</span>
                                 <span class="s1">self.indptr.astype(idx_dtype)</span><span class="s3">,</span>
                                 <span class="s1">self.indices.astype(idx_dtype)</span><span class="s3">,</span>
                                 <span class="s1">other.indptr.astype(idx_dtype)</span><span class="s3">,</span>
                                 <span class="s1">other.indices.astype(idx_dtype))</span>

        <span class="s1">idx_dtype = self._get_index_dtype((self.indptr</span><span class="s3">, </span><span class="s1">self.indices</span><span class="s3">,</span>
                                           <span class="s1">other.indptr</span><span class="s3">, </span><span class="s1">other.indices)</span><span class="s3">,</span>
                                          <span class="s1">maxval=bnnz)</span>
        <span class="s1">indptr = np.empty(self.indptr.shape</span><span class="s3">, </span><span class="s1">dtype=idx_dtype)</span>
        <span class="s1">indices = np.empty(bnnz</span><span class="s3">, </span><span class="s1">dtype=idx_dtype)</span>
        <span class="s1">data = np.empty(R*C*bnnz</span><span class="s3">, </span><span class="s1">dtype=upcast(self.dtype</span><span class="s3">,</span><span class="s1">other.dtype))</span>

        <span class="s1">bsr_matmat(bnnz</span><span class="s3">, </span><span class="s1">M//R</span><span class="s3">, </span><span class="s1">N//C</span><span class="s3">, </span><span class="s1">R</span><span class="s3">, </span><span class="s1">C</span><span class="s3">, </span><span class="s1">n</span><span class="s3">,</span>
                   <span class="s1">self.indptr.astype(idx_dtype)</span><span class="s3">,</span>
                   <span class="s1">self.indices.astype(idx_dtype)</span><span class="s3">,</span>
                   <span class="s1">np.ravel(self.data)</span><span class="s3">,</span>
                   <span class="s1">other.indptr.astype(idx_dtype)</span><span class="s3">,</span>
                   <span class="s1">other.indices.astype(idx_dtype)</span><span class="s3">,</span>
                   <span class="s1">np.ravel(other.data)</span><span class="s3">,</span>
                   <span class="s1">indptr</span><span class="s3">,</span>
                   <span class="s1">indices</span><span class="s3">,</span>
                   <span class="s1">data)</span>

        <span class="s1">data = data.reshape(-</span><span class="s5">1</span><span class="s3">,</span><span class="s1">R</span><span class="s3">,</span><span class="s1">C)</span>

        <span class="s4"># TODO eliminate zeros</span>

        <span class="s3">return </span><span class="s1">self._bsr_container(</span>
            <span class="s1">(data</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">indptr)</span><span class="s3">, </span><span class="s1">shape=(M</span><span class="s3">, </span><span class="s1">N)</span><span class="s3">, </span><span class="s1">blocksize=(R</span><span class="s3">, </span><span class="s1">C)</span>
        <span class="s1">)</span>

    <span class="s4">######################</span>
    <span class="s4"># Conversion methods #</span>
    <span class="s4">######################</span>

    <span class="s3">def </span><span class="s1">tobsr(self</span><span class="s3">, </span><span class="s1">blocksize=</span><span class="s3">None, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Convert this matrix into Block Sparse Row Format. 
 
        With copy=False, the data/indices may be shared between this 
        matrix and the resultant bsr_array. 
 
        If blocksize=(R, C) is provided, it will be used for determining 
        block size of the bsr_array. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">blocksize </span><span class="s3">not in </span><span class="s1">[</span><span class="s3">None, </span><span class="s1">self.blocksize]:</span>
            <span class="s3">return </span><span class="s1">self.tocsr().tobsr(blocksize=blocksize)</span>
        <span class="s3">if </span><span class="s1">copy:</span>
            <span class="s3">return </span><span class="s1">self.copy()</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">tocsr(self</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s1">M</span><span class="s3">, </span><span class="s1">N = self.shape</span>
        <span class="s1">R</span><span class="s3">, </span><span class="s1">C = self.blocksize</span>
        <span class="s1">nnz = self.nnz</span>
        <span class="s1">idx_dtype = self._get_index_dtype((self.indptr</span><span class="s3">, </span><span class="s1">self.indices)</span><span class="s3">,</span>
                                          <span class="s1">maxval=max(nnz</span><span class="s3">, </span><span class="s1">N))</span>
        <span class="s1">indptr = np.empty(M + </span><span class="s5">1</span><span class="s3">, </span><span class="s1">dtype=idx_dtype)</span>
        <span class="s1">indices = np.empty(nnz</span><span class="s3">, </span><span class="s1">dtype=idx_dtype)</span>
        <span class="s1">data = np.empty(nnz</span><span class="s3">, </span><span class="s1">dtype=upcast(self.dtype))</span>

        <span class="s1">bsr_tocsr(M // R</span><span class="s3">,  </span><span class="s4"># n_brow</span>
                  <span class="s1">N // C</span><span class="s3">,  </span><span class="s4"># n_bcol</span>
                  <span class="s1">R</span><span class="s3">, </span><span class="s1">C</span><span class="s3">,</span>
                  <span class="s1">self.indptr.astype(idx_dtype</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">)</span><span class="s3">,</span>
                  <span class="s1">self.indices.astype(idx_dtype</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">)</span><span class="s3">,</span>
                  <span class="s1">self.data</span><span class="s3">,</span>
                  <span class="s1">indptr</span><span class="s3">,</span>
                  <span class="s1">indices</span><span class="s3">,</span>
                  <span class="s1">data)</span>
        <span class="s3">return </span><span class="s1">self._csr_container((data</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">indptr)</span><span class="s3">, </span><span class="s1">shape=self.shape)</span>

    <span class="s1">tocsr.__doc__ = _spbase.tocsr.__doc__</span>

    <span class="s3">def </span><span class="s1">tocsc(self</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s3">return </span><span class="s1">self.tocsr(copy=</span><span class="s3">False</span><span class="s1">).tocsc(copy=copy)</span>

    <span class="s1">tocsc.__doc__ = _spbase.tocsc.__doc__</span>

    <span class="s3">def </span><span class="s1">tocoo(self</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Convert this matrix to COOrdinate format. 
 
        When copy=False the data array will be shared between 
        this matrix and the resultant coo_matrix. 
        &quot;&quot;&quot;</span>

        <span class="s1">M</span><span class="s3">,</span><span class="s1">N = self.shape</span>
        <span class="s1">R</span><span class="s3">,</span><span class="s1">C = self.blocksize</span>

        <span class="s1">indptr_diff = np.diff(self.indptr)</span>
        <span class="s3">if </span><span class="s1">indptr_diff.dtype.itemsize &gt; np.dtype(np.intp).itemsize:</span>
            <span class="s4"># Check for potential overflow</span>
            <span class="s1">indptr_diff_limited = indptr_diff.astype(np.intp)</span>
            <span class="s3">if </span><span class="s1">np.any(indptr_diff_limited != indptr_diff):</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Matrix too big to convert&quot;</span><span class="s1">)</span>
            <span class="s1">indptr_diff = indptr_diff_limited</span>

        <span class="s1">idx_dtype = self._get_index_dtype(maxval=max(M</span><span class="s3">, </span><span class="s1">N))</span>
        <span class="s1">row = (R * np.arange(M//R</span><span class="s3">, </span><span class="s1">dtype=idx_dtype)).repeat(indptr_diff)</span>
        <span class="s1">row = row.repeat(R*C).reshape(-</span><span class="s5">1</span><span class="s3">,</span><span class="s1">R</span><span class="s3">,</span><span class="s1">C)</span>
        <span class="s1">row += np.tile(np.arange(R</span><span class="s3">, </span><span class="s1">dtype=idx_dtype).reshape(-</span><span class="s5">1</span><span class="s3">,</span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">1</span><span class="s3">,</span><span class="s1">C))</span>
        <span class="s1">row = row.reshape(-</span><span class="s5">1</span><span class="s1">)</span>

        <span class="s1">col = (C * self.indices).astype(idx_dtype</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">).repeat(R*C).reshape(-</span><span class="s5">1</span><span class="s3">,</span><span class="s1">R</span><span class="s3">,</span><span class="s1">C)</span>
        <span class="s1">col += np.tile(np.arange(C</span><span class="s3">, </span><span class="s1">dtype=idx_dtype)</span><span class="s3">, </span><span class="s1">(R</span><span class="s3">,</span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">col = col.reshape(-</span><span class="s5">1</span><span class="s1">)</span>

        <span class="s1">data = self.data.reshape(-</span><span class="s5">1</span><span class="s1">)</span>

        <span class="s3">if </span><span class="s1">copy:</span>
            <span class="s1">data = data.copy()</span>

        <span class="s3">return </span><span class="s1">self._coo_container(</span>
            <span class="s1">(data</span><span class="s3">, </span><span class="s1">(row</span><span class="s3">, </span><span class="s1">col))</span><span class="s3">, </span><span class="s1">shape=self.shape</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">toarray(self</span><span class="s3">, </span><span class="s1">order=</span><span class="s3">None, </span><span class="s1">out=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s3">return </span><span class="s1">self.tocoo(copy=</span><span class="s3">False</span><span class="s1">).toarray(order=order</span><span class="s3">, </span><span class="s1">out=out)</span>

    <span class="s1">toarray.__doc__ = _spbase.toarray.__doc__</span>

    <span class="s3">def </span><span class="s1">transpose(self</span><span class="s3">, </span><span class="s1">axes=</span><span class="s3">None, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">axes </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Sparse matrices do not support &quot;</span>
                              <span class="s2">&quot;an 'axes' parameter because swapping &quot;</span>
                              <span class="s2">&quot;dimensions is the only logical permutation.&quot;</span><span class="s1">)</span>

        <span class="s1">R</span><span class="s3">, </span><span class="s1">C = self.blocksize</span>
        <span class="s1">M</span><span class="s3">, </span><span class="s1">N = self.shape</span>
        <span class="s1">NBLK = self.nnz//(R*C)</span>

        <span class="s3">if </span><span class="s1">self.nnz == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self._bsr_container((N</span><span class="s3">, </span><span class="s1">M)</span><span class="s3">, </span><span class="s1">blocksize=(C</span><span class="s3">, </span><span class="s1">R)</span><span class="s3">,</span>
                                       <span class="s1">dtype=self.dtype</span><span class="s3">, </span><span class="s1">copy=copy)</span>

        <span class="s1">indptr = np.empty(N//C + </span><span class="s5">1</span><span class="s3">, </span><span class="s1">dtype=self.indptr.dtype)</span>
        <span class="s1">indices = np.empty(NBLK</span><span class="s3">, </span><span class="s1">dtype=self.indices.dtype)</span>
        <span class="s1">data = np.empty((NBLK</span><span class="s3">, </span><span class="s1">C</span><span class="s3">, </span><span class="s1">R)</span><span class="s3">, </span><span class="s1">dtype=self.data.dtype)</span>

        <span class="s1">bsr_transpose(M//R</span><span class="s3">, </span><span class="s1">N//C</span><span class="s3">, </span><span class="s1">R</span><span class="s3">, </span><span class="s1">C</span><span class="s3">,</span>
                      <span class="s1">self.indptr</span><span class="s3">, </span><span class="s1">self.indices</span><span class="s3">, </span><span class="s1">self.data.ravel()</span><span class="s3">,</span>
                      <span class="s1">indptr</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">data.ravel())</span>

        <span class="s3">return </span><span class="s1">self._bsr_container((data</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">indptr)</span><span class="s3">,</span>
                                   <span class="s1">shape=(N</span><span class="s3">, </span><span class="s1">M)</span><span class="s3">, </span><span class="s1">copy=copy)</span>

    <span class="s1">transpose.__doc__ = _spbase.transpose.__doc__</span>

    <span class="s4">##############################################################</span>
    <span class="s4"># methods that examine or modify the internal data structure #</span>
    <span class="s4">##############################################################</span>

    <span class="s3">def </span><span class="s1">eliminate_zeros(self):</span>
        <span class="s0">&quot;&quot;&quot;Remove zero elements in-place.&quot;&quot;&quot;</span>

        <span class="s3">if not </span><span class="s1">self.nnz:</span>
            <span class="s3">return  </span><span class="s4"># nothing to do</span>

        <span class="s1">R</span><span class="s3">,</span><span class="s1">C = self.blocksize</span>
        <span class="s1">M</span><span class="s3">,</span><span class="s1">N = self.shape</span>

        <span class="s1">mask = (self.data != </span><span class="s5">0</span><span class="s1">).reshape(-</span><span class="s5">1</span><span class="s3">,</span><span class="s1">R*C).sum(axis=</span><span class="s5">1</span><span class="s1">)  </span><span class="s4"># nonzero blocks</span>

        <span class="s1">nonzero_blocks = mask.nonzero()[</span><span class="s5">0</span><span class="s1">]</span>

        <span class="s1">self.data[:len(nonzero_blocks)] = self.data[nonzero_blocks]</span>

        <span class="s4"># modifies self.indptr and self.indices *in place*</span>
        <span class="s1">_sparsetools.csr_eliminate_zeros(M//R</span><span class="s3">, </span><span class="s1">N//C</span><span class="s3">, </span><span class="s1">self.indptr</span><span class="s3">,</span>
                                         <span class="s1">self.indices</span><span class="s3">, </span><span class="s1">mask)</span>
        <span class="s1">self.prune()</span>

    <span class="s3">def </span><span class="s1">sum_duplicates(self):</span>
        <span class="s0">&quot;&quot;&quot;Eliminate duplicate matrix entries by adding them together 
 
        The is an *in place* operation 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self.has_canonical_format:</span>
            <span class="s3">return</span>
        <span class="s1">self.sort_indices()</span>
        <span class="s1">R</span><span class="s3">, </span><span class="s1">C = self.blocksize</span>
        <span class="s1">M</span><span class="s3">, </span><span class="s1">N = self.shape</span>

        <span class="s4"># port of _sparsetools.csr_sum_duplicates</span>
        <span class="s1">n_row = M // R</span>
        <span class="s1">nnz = </span><span class="s5">0</span>
        <span class="s1">row_end = </span><span class="s5">0</span>
        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(n_row):</span>
            <span class="s1">jj = row_end</span>
            <span class="s1">row_end = self.indptr[i+</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s3">while </span><span class="s1">jj &lt; row_end:</span>
                <span class="s1">j = self.indices[jj]</span>
                <span class="s1">x = self.data[jj]</span>
                <span class="s1">jj += </span><span class="s5">1</span>
                <span class="s3">while </span><span class="s1">jj &lt; row_end </span><span class="s3">and </span><span class="s1">self.indices[jj] == j:</span>
                    <span class="s1">x += self.data[jj]</span>
                    <span class="s1">jj += </span><span class="s5">1</span>
                <span class="s1">self.indices[nnz] = j</span>
                <span class="s1">self.data[nnz] = x</span>
                <span class="s1">nnz += </span><span class="s5">1</span>
            <span class="s1">self.indptr[i+</span><span class="s5">1</span><span class="s1">] = nnz</span>

        <span class="s1">self.prune()  </span><span class="s4"># nnz may have changed</span>
        <span class="s1">self.has_canonical_format = </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">sort_indices(self):</span>
        <span class="s0">&quot;&quot;&quot;Sort the indices of this matrix *in place* 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">self.has_sorted_indices:</span>
            <span class="s3">return</span>

        <span class="s1">R</span><span class="s3">,</span><span class="s1">C = self.blocksize</span>
        <span class="s1">M</span><span class="s3">,</span><span class="s1">N = self.shape</span>

        <span class="s1">bsr_sort_indices(M//R</span><span class="s3">, </span><span class="s1">N//C</span><span class="s3">, </span><span class="s1">R</span><span class="s3">, </span><span class="s1">C</span><span class="s3">, </span><span class="s1">self.indptr</span><span class="s3">, </span><span class="s1">self.indices</span><span class="s3">, </span><span class="s1">self.data.ravel())</span>

        <span class="s1">self.has_sorted_indices = </span><span class="s3">True</span>

    <span class="s3">def </span><span class="s1">prune(self):</span>
        <span class="s0">&quot;&quot;&quot; Remove empty space after all non-zero elements. 
        &quot;&quot;&quot;</span>

        <span class="s1">R</span><span class="s3">,</span><span class="s1">C = self.blocksize</span>
        <span class="s1">M</span><span class="s3">,</span><span class="s1">N = self.shape</span>

        <span class="s3">if </span><span class="s1">len(self.indptr) != M//R + </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;index pointer has invalid length&quot;</span><span class="s1">)</span>

        <span class="s1">bnnz = self.indptr[-</span><span class="s5">1</span><span class="s1">]</span>

        <span class="s3">if </span><span class="s1">len(self.indices) &lt; bnnz:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;indices array has too few elements&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">len(self.data) &lt; bnnz:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;data array has too few elements&quot;</span><span class="s1">)</span>

        <span class="s1">self.data = self.data[:bnnz]</span>
        <span class="s1">self.indices = self.indices[:bnnz]</span>

    <span class="s4"># utility functions</span>
    <span class="s3">def </span><span class="s1">_binopt(self</span><span class="s3">, </span><span class="s1">other</span><span class="s3">, </span><span class="s1">op</span><span class="s3">, </span><span class="s1">in_shape=</span><span class="s3">None, </span><span class="s1">out_shape=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Apply the binary operation fn to two sparse matrices.&quot;&quot;&quot;</span>

        <span class="s4"># Ideally we'd take the GCDs of the blocksize dimensions</span>
        <span class="s4"># and explode self and other to match.</span>
        <span class="s1">other = self.__class__(other</span><span class="s3">, </span><span class="s1">blocksize=self.blocksize)</span>

        <span class="s4"># e.g. bsr_plus_bsr, etc.</span>
        <span class="s1">fn = getattr(_sparsetools</span><span class="s3">, </span><span class="s1">self.format + op + self.format)</span>

        <span class="s1">R</span><span class="s3">,</span><span class="s1">C = self.blocksize</span>

        <span class="s1">max_bnnz = len(self.data) + len(other.data)</span>
        <span class="s1">idx_dtype = self._get_index_dtype((self.indptr</span><span class="s3">, </span><span class="s1">self.indices</span><span class="s3">,</span>
                                           <span class="s1">other.indptr</span><span class="s3">, </span><span class="s1">other.indices)</span><span class="s3">,</span>
                                          <span class="s1">maxval=max_bnnz)</span>
        <span class="s1">indptr = np.empty(self.indptr.shape</span><span class="s3">, </span><span class="s1">dtype=idx_dtype)</span>
        <span class="s1">indices = np.empty(max_bnnz</span><span class="s3">, </span><span class="s1">dtype=idx_dtype)</span>

        <span class="s1">bool_ops = [</span><span class="s2">'_ne_'</span><span class="s3">, </span><span class="s2">'_lt_'</span><span class="s3">, </span><span class="s2">'_gt_'</span><span class="s3">, </span><span class="s2">'_le_'</span><span class="s3">, </span><span class="s2">'_ge_'</span><span class="s1">]</span>
        <span class="s3">if </span><span class="s1">op </span><span class="s3">in </span><span class="s1">bool_ops:</span>
            <span class="s1">data = np.empty(R*C*max_bnnz</span><span class="s3">, </span><span class="s1">dtype=np.bool_)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">data = np.empty(R*C*max_bnnz</span><span class="s3">, </span><span class="s1">dtype=upcast(self.dtype</span><span class="s3">,</span><span class="s1">other.dtype))</span>

        <span class="s1">fn(self.shape[</span><span class="s5">0</span><span class="s1">]//R</span><span class="s3">, </span><span class="s1">self.shape[</span><span class="s5">1</span><span class="s1">]//C</span><span class="s3">, </span><span class="s1">R</span><span class="s3">, </span><span class="s1">C</span><span class="s3">,</span>
           <span class="s1">self.indptr.astype(idx_dtype)</span><span class="s3">,</span>
           <span class="s1">self.indices.astype(idx_dtype)</span><span class="s3">,</span>
           <span class="s1">self.data</span><span class="s3">,</span>
           <span class="s1">other.indptr.astype(idx_dtype)</span><span class="s3">,</span>
           <span class="s1">other.indices.astype(idx_dtype)</span><span class="s3">,</span>
           <span class="s1">np.ravel(other.data)</span><span class="s3">,</span>
           <span class="s1">indptr</span><span class="s3">,</span>
           <span class="s1">indices</span><span class="s3">,</span>
           <span class="s1">data)</span>

        <span class="s1">actual_bnnz = indptr[-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">indices = indices[:actual_bnnz]</span>
        <span class="s1">data = data[:R*C*actual_bnnz]</span>

        <span class="s3">if </span><span class="s1">actual_bnnz &lt; max_bnnz/</span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">indices = indices.copy()</span>
            <span class="s1">data = data.copy()</span>

        <span class="s1">data = data.reshape(-</span><span class="s5">1</span><span class="s3">,</span><span class="s1">R</span><span class="s3">,</span><span class="s1">C)</span>

        <span class="s3">return </span><span class="s1">self.__class__((data</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">indptr)</span><span class="s3">, </span><span class="s1">shape=self.shape)</span>

    <span class="s4"># needed by _data_matrix</span>
    <span class="s3">def </span><span class="s1">_with_data(self</span><span class="s3">,</span><span class="s1">data</span><span class="s3">,</span><span class="s1">copy=</span><span class="s3">True</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Returns a matrix with the same sparsity structure as self, 
        but with different data.  By default the structure arrays 
        (i.e. .indptr and .indices) are copied. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">copy:</span>
            <span class="s3">return </span><span class="s1">self.__class__((data</span><span class="s3">,</span><span class="s1">self.indices.copy()</span><span class="s3">,</span><span class="s1">self.indptr.copy())</span><span class="s3">,</span>
                                   <span class="s1">shape=self.shape</span><span class="s3">,</span><span class="s1">dtype=data.dtype)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.__class__((data</span><span class="s3">,</span><span class="s1">self.indices</span><span class="s3">,</span><span class="s1">self.indptr)</span><span class="s3">,</span>
                                   <span class="s1">shape=self.shape</span><span class="s3">,</span><span class="s1">dtype=data.dtype)</span>

<span class="s4">#    # these functions are used by the parent class</span>
<span class="s4">#    # to remove redudancy between bsc_matrix and bsr_matrix</span>
<span class="s4">#    def _swap(self,x):</span>
<span class="s4">#        &quot;&quot;&quot;swap the members of x if this is a column-oriented matrix</span>
<span class="s4">#        &quot;&quot;&quot;</span>
<span class="s4">#        return (x[0],x[1])</span>


<span class="s3">def </span><span class="s1">isspmatrix_bsr(x):</span>
    <span class="s0">&quot;&quot;&quot;Is `x` of a bsr_matrix type? 
 
    Parameters 
    ---------- 
    x 
        object to check for being a bsr matrix 
 
    Returns 
    ------- 
    bool 
        True if `x` is a bsr matrix, False otherwise 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.sparse import bsr_array, bsr_matrix, csr_matrix, isspmatrix_bsr 
    &gt;&gt;&gt; isspmatrix_bsr(bsr_matrix([[5]])) 
    True 
    &gt;&gt;&gt; isspmatrix_bsr(bsr_array([[5]])) 
    False 
    &gt;&gt;&gt; isspmatrix_bsr(csr_matrix([[5]])) 
    False 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">isinstance(x</span><span class="s3">, </span><span class="s1">bsr_matrix)</span>


<span class="s4"># This namespace class separates array from matrix with isinstance</span>
<span class="s3">class </span><span class="s1">bsr_array(_bsr_base</span><span class="s3">, </span><span class="s1">sparray):</span>
    <span class="s3">pass</span>

<span class="s1">bsr_array.__doc__ = _bsr_base.__doc__</span>

<span class="s3">class </span><span class="s1">bsr_matrix(spmatrix</span><span class="s3">, </span><span class="s1">_bsr_base):</span>
    <span class="s3">pass</span>

<span class="s1">bsr_matrix.__doc__ = _array_doc_to_matrix(_bsr_base.__doc__)</span>
</pre>
</body>
</html>