<html>
<head>
<title>masked.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
masked.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">TYPE_CHECKING</span><span class="s0">,</span>
    <span class="s1">Any</span><span class="s0">,</span>
    <span class="s1">Callable</span><span class="s0">,</span>
    <span class="s1">Literal</span><span class="s0">,</span>
    <span class="s1">overload</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>

<span class="s0">from </span><span class="s1">pandas._libs </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">lib</span><span class="s0">,</span>
    <span class="s1">missing </span><span class="s0">as </span><span class="s1">libmissing</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas._libs.tslibs </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">get_unit_from_dtype</span><span class="s0">,</span>
    <span class="s1">is_supported_unit</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas._typing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">ArrayLike</span><span class="s0">,</span>
    <span class="s1">AstypeArg</span><span class="s0">,</span>
    <span class="s1">AxisInt</span><span class="s0">,</span>
    <span class="s1">DtypeObj</span><span class="s0">,</span>
    <span class="s1">FillnaOptions</span><span class="s0">,</span>
    <span class="s1">NpDtype</span><span class="s0">,</span>
    <span class="s1">PositionalIndexer</span><span class="s0">,</span>
    <span class="s1">Scalar</span><span class="s0">,</span>
    <span class="s1">ScalarIndexer</span><span class="s0">,</span>
    <span class="s1">Self</span><span class="s0">,</span>
    <span class="s1">SequenceIndexer</span><span class="s0">,</span>
    <span class="s1">Shape</span><span class="s0">,</span>
    <span class="s1">npt</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.compat </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">IS64</span><span class="s0">,</span>
    <span class="s1">is_platform_windows</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.errors </span><span class="s0">import </span><span class="s1">AbstractMethodError</span>
<span class="s0">from </span><span class="s1">pandas.util._decorators </span><span class="s0">import </span><span class="s1">doc</span>
<span class="s0">from </span><span class="s1">pandas.util._validators </span><span class="s0">import </span><span class="s1">validate_fillna_kwargs</span>

<span class="s0">from </span><span class="s1">pandas.core.dtypes.base </span><span class="s0">import </span><span class="s1">ExtensionDtype</span>
<span class="s0">from </span><span class="s1">pandas.core.dtypes.common </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">is_bool</span><span class="s0">,</span>
    <span class="s1">is_integer_dtype</span><span class="s0">,</span>
    <span class="s1">is_list_like</span><span class="s0">,</span>
    <span class="s1">is_scalar</span><span class="s0">,</span>
    <span class="s1">is_string_dtype</span><span class="s0">,</span>
    <span class="s1">pandas_dtype</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.dtypes.dtypes </span><span class="s0">import </span><span class="s1">BaseMaskedDtype</span>
<span class="s0">from </span><span class="s1">pandas.core.dtypes.missing </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">array_equivalent</span><span class="s0">,</span>
    <span class="s1">is_valid_na_for_dtype</span><span class="s0">,</span>
    <span class="s1">isna</span><span class="s0">,</span>
    <span class="s1">notna</span><span class="s0">,</span>
<span class="s1">)</span>

<span class="s0">from </span><span class="s1">pandas.core </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">algorithms </span><span class="s0">as </span><span class="s1">algos</span><span class="s0">,</span>
    <span class="s1">arraylike</span><span class="s0">,</span>
    <span class="s1">missing</span><span class="s0">,</span>
    <span class="s1">nanops</span><span class="s0">,</span>
    <span class="s1">ops</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.algorithms </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">factorize_array</span><span class="s0">,</span>
    <span class="s1">isin</span><span class="s0">,</span>
    <span class="s1">take</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.array_algos </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">masked_accumulations</span><span class="s0">,</span>
    <span class="s1">masked_reductions</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.array_algos.quantile </span><span class="s0">import </span><span class="s1">quantile_with_mask</span>
<span class="s0">from </span><span class="s1">pandas.core.arraylike </span><span class="s0">import </span><span class="s1">OpsMixin</span>
<span class="s0">from </span><span class="s1">pandas.core.arrays.base </span><span class="s0">import </span><span class="s1">ExtensionArray</span>
<span class="s0">from </span><span class="s1">pandas.core.construction </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">array </span><span class="s0">as </span><span class="s1">pd_array</span><span class="s0">,</span>
    <span class="s1">ensure_wrapped_if_datetimelike</span><span class="s0">,</span>
    <span class="s1">extract_array</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.indexers </span><span class="s0">import </span><span class="s1">check_array_indexer</span>
<span class="s0">from </span><span class="s1">pandas.core.ops </span><span class="s0">import </span><span class="s1">invalid_comparison</span>

<span class="s0">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s0">from </span><span class="s1">collections.abc </span><span class="s0">import </span><span class="s1">(</span>
        <span class="s1">Iterator</span><span class="s0">,</span>
        <span class="s1">Sequence</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">Series</span>
    <span class="s0">from </span><span class="s1">pandas.core.arrays </span><span class="s0">import </span><span class="s1">BooleanArray</span>
    <span class="s0">from </span><span class="s1">pandas._typing </span><span class="s0">import </span><span class="s1">(</span>
        <span class="s1">NumpySorter</span><span class="s0">,</span>
        <span class="s1">NumpyValueArrayLike</span><span class="s0">,</span>
    <span class="s1">)</span>

<span class="s0">from </span><span class="s1">pandas.compat.numpy </span><span class="s0">import </span><span class="s1">function </span><span class="s0">as </span><span class="s1">nv</span>


<span class="s0">class </span><span class="s1">BaseMaskedArray(OpsMixin</span><span class="s0">, </span><span class="s1">ExtensionArray):</span>
    <span class="s2">&quot;&quot;&quot; 
    Base class for masked arrays (which use _data and _mask to store the data). 
 
    numpy based 
    &quot;&quot;&quot;</span>

    <span class="s3"># The value used to fill '_data' to avoid upcasting</span>
    <span class="s1">_internal_fill_value: Scalar</span>
    <span class="s3"># our underlying data and mask are each ndarrays</span>
    <span class="s1">_data: np.ndarray</span>
    <span class="s1">_mask: npt.NDArray[np.bool_]</span>

    <span class="s3"># Fill values used for any/all</span>
    <span class="s1">_truthy_value = Scalar  </span><span class="s3"># bool(_truthy_value) = True</span>
    <span class="s1">_falsey_value = Scalar  </span><span class="s3"># bool(_falsey_value) = False</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">_simple_new(cls</span><span class="s0">, </span><span class="s1">values: np.ndarray</span><span class="s0">, </span><span class="s1">mask: npt.NDArray[np.bool_]) -&gt; Self:</span>
        <span class="s1">result = BaseMaskedArray.__new__(cls)</span>
        <span class="s1">result._data = values</span>
        <span class="s1">result._mask = mask</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">values: np.ndarray</span><span class="s0">, </span><span class="s1">mask: npt.NDArray[np.bool_]</span><span class="s0">, </span><span class="s1">copy: bool = </span><span class="s0">False</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s3"># values is supposed to already be validated in the subclass</span>
        <span class="s0">if not </span><span class="s1">(isinstance(mask</span><span class="s0">, </span><span class="s1">np.ndarray) </span><span class="s0">and </span><span class="s1">mask.dtype == np.bool_):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span>
                <span class="s4">&quot;mask should be boolean numpy array. Use &quot;</span>
                <span class="s4">&quot;the 'pd.array' function instead&quot;</span>
            <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">values.shape != mask.shape:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;values.shape must match mask.shape&quot;</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">copy:</span>
            <span class="s1">values = values.copy()</span>
            <span class="s1">mask = mask.copy()</span>

        <span class="s1">self._data = values</span>
        <span class="s1">self._mask = mask</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">_from_sequence(cls</span><span class="s0">, </span><span class="s1">scalars</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s0">None, </span><span class="s1">copy: bool = </span><span class="s0">False</span><span class="s1">) -&gt; Self:</span>
        <span class="s1">values</span><span class="s0">, </span><span class="s1">mask = cls._coerce_to_array(scalars</span><span class="s0">, </span><span class="s1">dtype=dtype</span><span class="s0">, </span><span class="s1">copy=copy)</span>
        <span class="s0">return </span><span class="s1">cls(values</span><span class="s0">, </span><span class="s1">mask)</span>

    <span class="s1">@classmethod</span>
    <span class="s1">@doc(ExtensionArray._empty)</span>
    <span class="s0">def </span><span class="s1">_empty(cls</span><span class="s0">, </span><span class="s1">shape: Shape</span><span class="s0">, </span><span class="s1">dtype: ExtensionDtype):</span>
        <span class="s1">values = np.empty(shape</span><span class="s0">, </span><span class="s1">dtype=dtype.type)</span>
        <span class="s1">values.fill(cls._internal_fill_value)</span>
        <span class="s1">mask = np.ones(shape</span><span class="s0">, </span><span class="s1">dtype=bool)</span>
        <span class="s1">result = cls(values</span><span class="s0">, </span><span class="s1">mask)</span>
        <span class="s0">if not </span><span class="s1">isinstance(result</span><span class="s0">, </span><span class="s1">cls) </span><span class="s0">or </span><span class="s1">dtype != result.dtype:</span>
            <span class="s0">raise </span><span class="s1">NotImplementedError(</span>
                <span class="s4">f&quot;Default 'empty' implementation is invalid for dtype='</span><span class="s0">{</span><span class="s1">dtype</span><span class="s0">}</span><span class="s4">'&quot;</span>
            <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">_formatter(self</span><span class="s0">, </span><span class="s1">boxed: bool = </span><span class="s0">False</span><span class="s1">) -&gt; Callable[[Any]</span><span class="s0">, </span><span class="s1">str | </span><span class="s0">None</span><span class="s1">]:</span>
        <span class="s3"># NEP 51: https://github.com/numpy/numpy/pull/22449</span>
        <span class="s0">return </span><span class="s1">str</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">dtype(self) -&gt; BaseMaskedDtype:</span>
        <span class="s0">raise </span><span class="s1">AbstractMethodError(self)</span>

    <span class="s1">@overload</span>
    <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">item: ScalarIndexer) -&gt; Any:</span>
        <span class="s1">...</span>

    <span class="s1">@overload</span>
    <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">item: SequenceIndexer) -&gt; Self:</span>
        <span class="s1">...</span>

    <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">item: PositionalIndexer) -&gt; Self | Any:</span>
        <span class="s1">item = check_array_indexer(self</span><span class="s0">, </span><span class="s1">item)</span>

        <span class="s1">newmask = self._mask[item]</span>
        <span class="s0">if </span><span class="s1">is_bool(newmask):</span>
            <span class="s3"># This is a scalar indexing</span>
            <span class="s0">if </span><span class="s1">newmask:</span>
                <span class="s0">return </span><span class="s1">self.dtype.na_value</span>
            <span class="s0">return </span><span class="s1">self._data[item]</span>

        <span class="s0">return </span><span class="s1">self._simple_new(self._data[item]</span><span class="s0">, </span><span class="s1">newmask)</span>

    <span class="s0">def </span><span class="s1">_pad_or_backfill(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">method: FillnaOptions</span><span class="s0">, </span><span class="s1">limit: int | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None, </span><span class="s1">copy: bool = </span><span class="s0">True</span>
    <span class="s1">) -&gt; Self:</span>
        <span class="s1">mask = self._mask</span>

        <span class="s0">if </span><span class="s1">mask.any():</span>
            <span class="s1">func = missing.get_fill_func(method</span><span class="s0">, </span><span class="s1">ndim=self.ndim)</span>

            <span class="s1">npvalues = self._data.T</span>
            <span class="s1">new_mask = mask.T</span>
            <span class="s0">if </span><span class="s1">copy:</span>
                <span class="s1">npvalues = npvalues.copy()</span>
                <span class="s1">new_mask = new_mask.copy()</span>
            <span class="s1">func(npvalues</span><span class="s0">, </span><span class="s1">limit=limit</span><span class="s0">, </span><span class="s1">mask=new_mask)</span>
            <span class="s0">if </span><span class="s1">copy:</span>
                <span class="s0">return </span><span class="s1">self._simple_new(npvalues.T</span><span class="s0">, </span><span class="s1">new_mask.T)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">self</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">copy:</span>
                <span class="s1">new_values = self.copy()</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">new_values = self</span>
        <span class="s0">return </span><span class="s1">new_values</span>

    <span class="s1">@doc(ExtensionArray.fillna)</span>
    <span class="s0">def </span><span class="s1">fillna(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">value=</span><span class="s0">None, </span><span class="s1">method=</span><span class="s0">None, </span><span class="s1">limit: int | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None, </span><span class="s1">copy: bool = </span><span class="s0">True</span>
    <span class="s1">) -&gt; Self:</span>
        <span class="s1">value</span><span class="s0">, </span><span class="s1">method = validate_fillna_kwargs(value</span><span class="s0">, </span><span class="s1">method)</span>

        <span class="s1">mask = self._mask</span>

        <span class="s1">value = missing.check_value_size(value</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">len(self))</span>

        <span class="s0">if </span><span class="s1">mask.any():</span>
            <span class="s0">if </span><span class="s1">method </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">func = missing.get_fill_func(method</span><span class="s0">, </span><span class="s1">ndim=self.ndim)</span>
                <span class="s1">npvalues = self._data.T</span>
                <span class="s1">new_mask = mask.T</span>
                <span class="s0">if </span><span class="s1">copy:</span>
                    <span class="s1">npvalues = npvalues.copy()</span>
                    <span class="s1">new_mask = new_mask.copy()</span>
                <span class="s1">func(npvalues</span><span class="s0">, </span><span class="s1">limit=limit</span><span class="s0">, </span><span class="s1">mask=new_mask)</span>
                <span class="s0">return </span><span class="s1">self._simple_new(npvalues.T</span><span class="s0">, </span><span class="s1">new_mask.T)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s3"># fill with value</span>
                <span class="s0">if </span><span class="s1">copy:</span>
                    <span class="s1">new_values = self.copy()</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">new_values = self[:]</span>
                <span class="s1">new_values[mask] = value</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">copy:</span>
                <span class="s1">new_values = self.copy()</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">new_values = self[:]</span>
        <span class="s0">return </span><span class="s1">new_values</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">_coerce_to_array(</span>
        <span class="s1">cls</span><span class="s0">, </span><span class="s1">values</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">dtype: DtypeObj</span><span class="s0">, </span><span class="s1">copy: bool = </span><span class="s0">False</span>
    <span class="s1">) -&gt; tuple[np.ndarray</span><span class="s0">, </span><span class="s1">np.ndarray]:</span>
        <span class="s0">raise </span><span class="s1">AbstractMethodError(cls)</span>

    <span class="s0">def </span><span class="s1">_validate_setitem_value(self</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s2">&quot;&quot;&quot; 
        Check if we have a scalar that we can cast losslessly. 
 
        Raises 
        ------ 
        TypeError 
        &quot;&quot;&quot;</span>
        <span class="s1">kind = self.dtype.kind</span>
        <span class="s3"># TODO: get this all from np_can_hold_element?</span>
        <span class="s0">if </span><span class="s1">kind == </span><span class="s4">&quot;b&quot;</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">lib.is_bool(value):</span>
                <span class="s0">return </span><span class="s1">value</span>

        <span class="s0">elif </span><span class="s1">kind == </span><span class="s4">&quot;f&quot;</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">lib.is_integer(value) </span><span class="s0">or </span><span class="s1">lib.is_float(value):</span>
                <span class="s0">return </span><span class="s1">value</span>

        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">lib.is_integer(value) </span><span class="s0">or </span><span class="s1">(lib.is_float(value) </span><span class="s0">and </span><span class="s1">value.is_integer()):</span>
                <span class="s0">return </span><span class="s1">value</span>
            <span class="s3"># TODO: unsigned checks</span>

        <span class="s3"># Note: without the &quot;str&quot; here, the f-string rendering raises in</span>
        <span class="s3">#  py38 builds.</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">f&quot;Invalid value '</span><span class="s0">{</span><span class="s1">str(value)</span><span class="s0">}</span><span class="s4">' for dtype </span><span class="s0">{</span><span class="s1">self.dtype</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__setitem__(self</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">value) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">key = check_array_indexer(self</span><span class="s0">, </span><span class="s1">key)</span>

        <span class="s0">if </span><span class="s1">is_scalar(value):</span>
            <span class="s0">if </span><span class="s1">is_valid_na_for_dtype(value</span><span class="s0">, </span><span class="s1">self.dtype):</span>
                <span class="s1">self._mask[key] = </span><span class="s0">True</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">value = self._validate_setitem_value(value)</span>
                <span class="s1">self._data[key] = value</span>
                <span class="s1">self._mask[key] = </span><span class="s0">False</span>
            <span class="s0">return</span>

        <span class="s1">value</span><span class="s0">, </span><span class="s1">mask = self._coerce_to_array(value</span><span class="s0">, </span><span class="s1">dtype=self.dtype)</span>

        <span class="s1">self._data[key] = value</span>
        <span class="s1">self._mask[key] = mask</span>

    <span class="s0">def </span><span class="s1">__contains__(self</span><span class="s0">, </span><span class="s1">key) -&gt; bool:</span>
        <span class="s0">if </span><span class="s1">isna(key) </span><span class="s0">and </span><span class="s1">key </span><span class="s0">is not </span><span class="s1">self.dtype.na_value:</span>
            <span class="s3"># GH#52840</span>
            <span class="s0">if </span><span class="s1">self._data.dtype.kind == </span><span class="s4">&quot;f&quot; </span><span class="s0">and </span><span class="s1">lib.is_float(key):</span>
                <span class="s0">return </span><span class="s1">bool((np.isnan(self._data) &amp; ~self._mask).any())</span>

        <span class="s0">return </span><span class="s1">bool(super().__contains__(key))</span>

    <span class="s0">def </span><span class="s1">__iter__(self) -&gt; Iterator:</span>
        <span class="s0">if </span><span class="s1">self.ndim == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s0">if not </span><span class="s1">self._hasna:</span>
                <span class="s0">for </span><span class="s1">val </span><span class="s0">in </span><span class="s1">self._data:</span>
                    <span class="s0">yield </span><span class="s1">val</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">na_value = self.dtype.na_value</span>
                <span class="s0">for </span><span class="s1">isna_</span><span class="s0">, </span><span class="s1">val </span><span class="s0">in </span><span class="s1">zip(self._mask</span><span class="s0">, </span><span class="s1">self._data):</span>
                    <span class="s0">if </span><span class="s1">isna_:</span>
                        <span class="s0">yield </span><span class="s1">na_value</span>
                    <span class="s0">else</span><span class="s1">:</span>
                        <span class="s0">yield </span><span class="s1">val</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(self)):</span>
                <span class="s0">yield </span><span class="s1">self[i]</span>

    <span class="s0">def </span><span class="s1">__len__(self) -&gt; int:</span>
        <span class="s0">return </span><span class="s1">len(self._data)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">shape(self) -&gt; Shape:</span>
        <span class="s0">return </span><span class="s1">self._data.shape</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">ndim(self) -&gt; int:</span>
        <span class="s0">return </span><span class="s1">self._data.ndim</span>

    <span class="s0">def </span><span class="s1">swapaxes(self</span><span class="s0">, </span><span class="s1">axis1</span><span class="s0">, </span><span class="s1">axis2) -&gt; Self:</span>
        <span class="s1">data = self._data.swapaxes(axis1</span><span class="s0">, </span><span class="s1">axis2)</span>
        <span class="s1">mask = self._mask.swapaxes(axis1</span><span class="s0">, </span><span class="s1">axis2)</span>
        <span class="s0">return </span><span class="s1">self._simple_new(data</span><span class="s0">, </span><span class="s1">mask)</span>

    <span class="s0">def </span><span class="s1">delete(self</span><span class="s0">, </span><span class="s1">loc</span><span class="s0">, </span><span class="s1">axis: AxisInt = </span><span class="s5">0</span><span class="s1">) -&gt; Self:</span>
        <span class="s1">data = np.delete(self._data</span><span class="s0">, </span><span class="s1">loc</span><span class="s0">, </span><span class="s1">axis=axis)</span>
        <span class="s1">mask = np.delete(self._mask</span><span class="s0">, </span><span class="s1">loc</span><span class="s0">, </span><span class="s1">axis=axis)</span>
        <span class="s0">return </span><span class="s1">self._simple_new(data</span><span class="s0">, </span><span class="s1">mask)</span>

    <span class="s0">def </span><span class="s1">reshape(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs) -&gt; Self:</span>
        <span class="s1">data = self._data.reshape(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s1">mask = self._mask.reshape(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">return </span><span class="s1">self._simple_new(data</span><span class="s0">, </span><span class="s1">mask)</span>

    <span class="s0">def </span><span class="s1">ravel(self</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs) -&gt; Self:</span>
        <span class="s3"># TODO: need to make sure we have the same order for data/mask</span>
        <span class="s1">data = self._data.ravel(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s1">mask = self._mask.ravel(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">return </span><span class="s1">type(self)(data</span><span class="s0">, </span><span class="s1">mask)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">T(self) -&gt; Self:</span>
        <span class="s0">return </span><span class="s1">self._simple_new(self._data.T</span><span class="s0">, </span><span class="s1">self._mask.T)</span>

    <span class="s0">def </span><span class="s1">round(self</span><span class="s0">, </span><span class="s1">decimals: int = </span><span class="s5">0</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s2">&quot;&quot;&quot; 
        Round each value in the array a to the given number of decimals. 
 
        Parameters 
        ---------- 
        decimals : int, default 0 
            Number of decimal places to round to. If decimals is negative, 
            it specifies the number of positions to the left of the decimal point. 
        *args, **kwargs 
            Additional arguments and keywords have no effect but might be 
            accepted for compatibility with NumPy. 
 
        Returns 
        ------- 
        NumericArray 
            Rounded values of the NumericArray. 
 
        See Also 
        -------- 
        numpy.around : Round values of an np.array. 
        DataFrame.round : Round values of a DataFrame. 
        Series.round : Round values of a Series. 
        &quot;&quot;&quot;</span>
        <span class="s1">nv.validate_round(args</span><span class="s0">, </span><span class="s1">kwargs)</span>
        <span class="s1">values = np.round(self._data</span><span class="s0">, </span><span class="s1">decimals=decimals</span><span class="s0">, </span><span class="s1">**kwargs)</span>

        <span class="s3"># Usually we'll get same type as self, but ndarray[bool] casts to float</span>
        <span class="s0">return </span><span class="s1">self._maybe_mask_result(values</span><span class="s0">, </span><span class="s1">self._mask.copy())</span>

    <span class="s3"># ------------------------------------------------------------------</span>
    <span class="s3"># Unary Methods</span>

    <span class="s0">def </span><span class="s1">__invert__(self) -&gt; Self:</span>
        <span class="s0">return </span><span class="s1">self._simple_new(~self._data</span><span class="s0">, </span><span class="s1">self._mask.copy())</span>

    <span class="s0">def </span><span class="s1">__neg__(self) -&gt; Self:</span>
        <span class="s0">return </span><span class="s1">self._simple_new(-self._data</span><span class="s0">, </span><span class="s1">self._mask.copy())</span>

    <span class="s0">def </span><span class="s1">__pos__(self) -&gt; Self:</span>
        <span class="s0">return </span><span class="s1">self.copy()</span>

    <span class="s0">def </span><span class="s1">__abs__(self) -&gt; Self:</span>
        <span class="s0">return </span><span class="s1">self._simple_new(abs(self._data)</span><span class="s0">, </span><span class="s1">self._mask.copy())</span>

    <span class="s3"># ------------------------------------------------------------------</span>

    <span class="s0">def </span><span class="s1">to_numpy(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">dtype: npt.DTypeLike | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">copy: bool = </span><span class="s0">False,</span>
        <span class="s1">na_value: object = lib.no_default</span><span class="s0">,</span>
    <span class="s1">) -&gt; np.ndarray:</span>
        <span class="s2">&quot;&quot;&quot; 
        Convert to a NumPy Array. 
 
        By default converts to an object-dtype NumPy array. Specify the `dtype` and 
        `na_value` keywords to customize the conversion. 
 
        Parameters 
        ---------- 
        dtype : dtype, default object 
            The numpy dtype to convert to. 
        copy : bool, default False 
            Whether to ensure that the returned value is a not a view on 
            the array. Note that ``copy=False`` does not *ensure* that 
            ``to_numpy()`` is no-copy. Rather, ``copy=True`` ensure that 
            a copy is made, even if not strictly necessary. This is typically 
            only possible when no missing values are present and `dtype` 
            is the equivalent numpy dtype. 
        na_value : scalar, optional 
             Scalar missing value indicator to use in numpy array. Defaults 
             to the native missing value indicator of this array (pd.NA). 
 
        Returns 
        ------- 
        numpy.ndarray 
 
        Examples 
        -------- 
        An object-dtype is the default result 
 
        &gt;&gt;&gt; a = pd.array([True, False, pd.NA], dtype=&quot;boolean&quot;) 
        &gt;&gt;&gt; a.to_numpy() 
        array([True, False, &lt;NA&gt;], dtype=object) 
 
        When no missing values are present, an equivalent dtype can be used. 
 
        &gt;&gt;&gt; pd.array([True, False], dtype=&quot;boolean&quot;).to_numpy(dtype=&quot;bool&quot;) 
        array([ True, False]) 
        &gt;&gt;&gt; pd.array([1, 2], dtype=&quot;Int64&quot;).to_numpy(&quot;int64&quot;) 
        array([1, 2]) 
 
        However, requesting such dtype will raise a ValueError if 
        missing values are present and the default missing value :attr:`NA` 
        is used. 
 
        &gt;&gt;&gt; a = pd.array([True, False, pd.NA], dtype=&quot;boolean&quot;) 
        &gt;&gt;&gt; a 
        &lt;BooleanArray&gt; 
        [True, False, &lt;NA&gt;] 
        Length: 3, dtype: boolean 
 
        &gt;&gt;&gt; a.to_numpy(dtype=&quot;bool&quot;) 
        Traceback (most recent call last): 
        ... 
        ValueError: cannot convert to bool numpy array in presence of missing values 
 
        Specify a valid `na_value` instead 
 
        &gt;&gt;&gt; a.to_numpy(dtype=&quot;bool&quot;, na_value=False) 
        array([ True, False, False]) 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">na_value </span><span class="s0">is </span><span class="s1">lib.no_default:</span>
            <span class="s1">na_value = libmissing.NA</span>
        <span class="s0">if </span><span class="s1">dtype </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">dtype = object</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">dtype = np.dtype(dtype)</span>
        <span class="s0">if </span><span class="s1">self._hasna:</span>
            <span class="s0">if </span><span class="s1">(</span>
                <span class="s1">dtype != object</span>
                <span class="s0">and not </span><span class="s1">is_string_dtype(dtype)</span>
                <span class="s0">and </span><span class="s1">na_value </span><span class="s0">is </span><span class="s1">libmissing.NA</span>
            <span class="s1">):</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">f&quot;cannot convert to '</span><span class="s0">{</span><span class="s1">dtype</span><span class="s0">}</span><span class="s4">'-dtype NumPy array &quot;</span>
                    <span class="s4">&quot;with missing values. Specify an appropriate 'na_value' &quot;</span>
                    <span class="s4">&quot;for this dtype.&quot;</span>
                <span class="s1">)</span>
            <span class="s3"># don't pass copy to astype -&gt; always need a copy since we are mutating</span>
            <span class="s0">with </span><span class="s1">warnings.catch_warnings():</span>
                <span class="s1">warnings.filterwarnings(</span><span class="s4">&quot;ignore&quot;</span><span class="s0">, </span><span class="s1">category=RuntimeWarning)</span>
                <span class="s1">data = self._data.astype(dtype)</span>
            <span class="s1">data[self._mask] = na_value</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">with </span><span class="s1">warnings.catch_warnings():</span>
                <span class="s1">warnings.filterwarnings(</span><span class="s4">&quot;ignore&quot;</span><span class="s0">, </span><span class="s1">category=RuntimeWarning)</span>
                <span class="s1">data = self._data.astype(dtype</span><span class="s0">, </span><span class="s1">copy=copy)</span>
        <span class="s0">return </span><span class="s1">data</span>

    <span class="s1">@doc(ExtensionArray.tolist)</span>
    <span class="s0">def </span><span class="s1">tolist(self):</span>
        <span class="s0">if </span><span class="s1">self.ndim &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">[x.tolist() </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">self]</span>
        <span class="s1">dtype = </span><span class="s0">None if </span><span class="s1">self._hasna </span><span class="s0">else </span><span class="s1">self._data.dtype</span>
        <span class="s0">return </span><span class="s1">self.to_numpy(dtype=dtype).tolist()</span>

    <span class="s1">@overload</span>
    <span class="s0">def </span><span class="s1">astype(self</span><span class="s0">, </span><span class="s1">dtype: npt.DTypeLike</span><span class="s0">, </span><span class="s1">copy: bool = ...) -&gt; np.ndarray:</span>
        <span class="s1">...</span>

    <span class="s1">@overload</span>
    <span class="s0">def </span><span class="s1">astype(self</span><span class="s0">, </span><span class="s1">dtype: ExtensionDtype</span><span class="s0">, </span><span class="s1">copy: bool = ...) -&gt; ExtensionArray:</span>
        <span class="s1">...</span>

    <span class="s1">@overload</span>
    <span class="s0">def </span><span class="s1">astype(self</span><span class="s0">, </span><span class="s1">dtype: AstypeArg</span><span class="s0">, </span><span class="s1">copy: bool = ...) -&gt; ArrayLike:</span>
        <span class="s1">...</span>

    <span class="s0">def </span><span class="s1">astype(self</span><span class="s0">, </span><span class="s1">dtype: AstypeArg</span><span class="s0">, </span><span class="s1">copy: bool = </span><span class="s0">True</span><span class="s1">) -&gt; ArrayLike:</span>
        <span class="s1">dtype = pandas_dtype(dtype)</span>

        <span class="s0">if </span><span class="s1">dtype == self.dtype:</span>
            <span class="s0">if </span><span class="s1">copy:</span>
                <span class="s0">return </span><span class="s1">self.copy()</span>
            <span class="s0">return </span><span class="s1">self</span>

        <span class="s3"># if we are astyping to another nullable masked dtype, we can fastpath</span>
        <span class="s0">if </span><span class="s1">isinstance(dtype</span><span class="s0">, </span><span class="s1">BaseMaskedDtype):</span>
            <span class="s3"># TODO deal with NaNs for FloatingArray case</span>
            <span class="s0">with </span><span class="s1">warnings.catch_warnings():</span>
                <span class="s1">warnings.filterwarnings(</span><span class="s4">&quot;ignore&quot;</span><span class="s0">, </span><span class="s1">category=RuntimeWarning)</span>
                <span class="s3"># TODO: Is rounding what we want long term?</span>
                <span class="s1">data = self._data.astype(dtype.numpy_dtype</span><span class="s0">, </span><span class="s1">copy=copy)</span>
            <span class="s3"># mask is copied depending on whether the data was copied, and</span>
            <span class="s3"># not directly depending on the `copy` keyword</span>
            <span class="s1">mask = self._mask </span><span class="s0">if </span><span class="s1">data </span><span class="s0">is </span><span class="s1">self._data </span><span class="s0">else </span><span class="s1">self._mask.copy()</span>
            <span class="s1">cls = dtype.construct_array_type()</span>
            <span class="s0">return </span><span class="s1">cls(data</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">isinstance(dtype</span><span class="s0">, </span><span class="s1">ExtensionDtype):</span>
            <span class="s1">eacls = dtype.construct_array_type()</span>
            <span class="s0">return </span><span class="s1">eacls._from_sequence(self</span><span class="s0">, </span><span class="s1">dtype=dtype</span><span class="s0">, </span><span class="s1">copy=copy)</span>

        <span class="s1">na_value: float | np.datetime64 | lib.NoDefault</span>

        <span class="s3"># coerce</span>
        <span class="s0">if </span><span class="s1">dtype.kind == </span><span class="s4">&quot;f&quot;</span><span class="s1">:</span>
            <span class="s3"># In astype, we consider dtype=float to also mean na_value=np.nan</span>
            <span class="s1">na_value = np.nan</span>
        <span class="s0">elif </span><span class="s1">dtype.kind == </span><span class="s4">&quot;M&quot;</span><span class="s1">:</span>
            <span class="s1">na_value = np.datetime64(</span><span class="s4">&quot;NaT&quot;</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">na_value = lib.no_default</span>

        <span class="s3"># to_numpy will also raise, but we get somewhat nicer exception messages here</span>
        <span class="s0">if </span><span class="s1">dtype.kind </span><span class="s0">in </span><span class="s4">&quot;iu&quot; </span><span class="s0">and </span><span class="s1">self._hasna:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;cannot convert NA to integer&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">dtype.kind == </span><span class="s4">&quot;b&quot; </span><span class="s0">and </span><span class="s1">self._hasna:</span>
            <span class="s3"># careful: astype_nansafe converts np.nan to True</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;cannot convert float NaN to bool&quot;</span><span class="s1">)</span>

        <span class="s1">data = self.to_numpy(dtype=dtype</span><span class="s0">, </span><span class="s1">na_value=na_value</span><span class="s0">, </span><span class="s1">copy=copy)</span>
        <span class="s0">return </span><span class="s1">data</span>

    <span class="s1">__array_priority__ = </span><span class="s5">1000  </span><span class="s3"># higher than ndarray so ops dispatch to us</span>

    <span class="s0">def </span><span class="s1">__array__(self</span><span class="s0">, </span><span class="s1">dtype: NpDtype | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None</span><span class="s1">) -&gt; np.ndarray:</span>
        <span class="s2">&quot;&quot;&quot; 
        the array interface, return my values 
        We return an object array here to preserve our scalar values 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.to_numpy(dtype=dtype)</span>

    <span class="s1">_HANDLED_TYPES: tuple[type</span><span class="s0">, </span><span class="s1">...]</span>

    <span class="s0">def </span><span class="s1">__array_ufunc__(self</span><span class="s0">, </span><span class="s1">ufunc: np.ufunc</span><span class="s0">, </span><span class="s1">method: str</span><span class="s0">, </span><span class="s1">*inputs</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s3"># For MaskedArray inputs, we apply the ufunc to ._data</span>
        <span class="s3"># and mask the result.</span>

        <span class="s1">out = kwargs.get(</span><span class="s4">&quot;out&quot;</span><span class="s0">, </span><span class="s1">())</span>

        <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">inputs + out:</span>
            <span class="s0">if not </span><span class="s1">isinstance(x</span><span class="s0">, </span><span class="s1">self._HANDLED_TYPES + (BaseMaskedArray</span><span class="s0">,</span><span class="s1">)):</span>
                <span class="s0">return </span><span class="s1">NotImplemented</span>

        <span class="s3"># for binary ops, use our custom dunder methods</span>
        <span class="s1">result = arraylike.maybe_dispatch_ufunc_to_dunder_op(</span>
            <span class="s1">self</span><span class="s0">, </span><span class="s1">ufunc</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">*inputs</span><span class="s0">, </span><span class="s1">**kwargs</span>
        <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">result </span><span class="s0">is not </span><span class="s1">NotImplemented:</span>
            <span class="s0">return </span><span class="s1">result</span>

        <span class="s0">if </span><span class="s4">&quot;out&quot; </span><span class="s0">in </span><span class="s1">kwargs:</span>
            <span class="s3"># e.g. test_ufunc_with_out</span>
            <span class="s0">return </span><span class="s1">arraylike.dispatch_ufunc_with_out(</span>
                <span class="s1">self</span><span class="s0">, </span><span class="s1">ufunc</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">*inputs</span><span class="s0">, </span><span class="s1">**kwargs</span>
            <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">method == </span><span class="s4">&quot;reduce&quot;</span><span class="s1">:</span>
            <span class="s1">result = arraylike.dispatch_reduction_ufunc(</span>
                <span class="s1">self</span><span class="s0">, </span><span class="s1">ufunc</span><span class="s0">, </span><span class="s1">method</span><span class="s0">, </span><span class="s1">*inputs</span><span class="s0">, </span><span class="s1">**kwargs</span>
            <span class="s1">)</span>
            <span class="s0">if </span><span class="s1">result </span><span class="s0">is not </span><span class="s1">NotImplemented:</span>
                <span class="s0">return </span><span class="s1">result</span>

        <span class="s1">mask = np.zeros(len(self)</span><span class="s0">, </span><span class="s1">dtype=bool)</span>
        <span class="s1">inputs2 = []</span>
        <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">inputs:</span>
            <span class="s0">if </span><span class="s1">isinstance(x</span><span class="s0">, </span><span class="s1">BaseMaskedArray):</span>
                <span class="s1">mask |= x._mask</span>
                <span class="s1">inputs2.append(x._data)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">inputs2.append(x)</span>

        <span class="s0">def </span><span class="s1">reconstruct(x: np.ndarray):</span>
            <span class="s3"># we don't worry about scalar `x` here, since we</span>
            <span class="s3"># raise for reduce up above.</span>
            <span class="s0">from </span><span class="s1">pandas.core.arrays </span><span class="s0">import </span><span class="s1">(</span>
                <span class="s1">BooleanArray</span><span class="s0">,</span>
                <span class="s1">FloatingArray</span><span class="s0">,</span>
                <span class="s1">IntegerArray</span><span class="s0">,</span>
            <span class="s1">)</span>

            <span class="s0">if </span><span class="s1">x.dtype.kind == </span><span class="s4">&quot;b&quot;</span><span class="s1">:</span>
                <span class="s1">m = mask.copy()</span>
                <span class="s0">return </span><span class="s1">BooleanArray(x</span><span class="s0">, </span><span class="s1">m)</span>
            <span class="s0">elif </span><span class="s1">x.dtype.kind </span><span class="s0">in </span><span class="s4">&quot;iu&quot;</span><span class="s1">:</span>
                <span class="s1">m = mask.copy()</span>
                <span class="s0">return </span><span class="s1">IntegerArray(x</span><span class="s0">, </span><span class="s1">m)</span>
            <span class="s0">elif </span><span class="s1">x.dtype.kind == </span><span class="s4">&quot;f&quot;</span><span class="s1">:</span>
                <span class="s1">m = mask.copy()</span>
                <span class="s0">if </span><span class="s1">x.dtype == np.float16:</span>
                    <span class="s3"># reached in e.g. np.sqrt on BooleanArray</span>
                    <span class="s3"># we don't support float16</span>
                    <span class="s1">x = x.astype(np.float32)</span>
                <span class="s0">return </span><span class="s1">FloatingArray(x</span><span class="s0">, </span><span class="s1">m)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">x[mask] = np.nan</span>
            <span class="s0">return </span><span class="s1">x</span>

        <span class="s1">result = getattr(ufunc</span><span class="s0">, </span><span class="s1">method)(*inputs2</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">if </span><span class="s1">ufunc.nout &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s3"># e.g. np.divmod</span>
            <span class="s0">return </span><span class="s1">tuple(reconstruct(x) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">result)</span>
        <span class="s0">elif </span><span class="s1">method == </span><span class="s4">&quot;reduce&quot;</span><span class="s1">:</span>
            <span class="s3"># e.g. np.add.reduce; test_ufunc_reduce_raises</span>
            <span class="s0">if </span><span class="s1">self._mask.any():</span>
                <span class="s0">return </span><span class="s1">self._na_value</span>
            <span class="s0">return </span><span class="s1">result</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">reconstruct(result)</span>

    <span class="s0">def </span><span class="s1">__arrow_array__(self</span><span class="s0">, </span><span class="s1">type=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Convert myself into a pyarrow Array. 
        &quot;&quot;&quot;</span>
        <span class="s0">import </span><span class="s1">pyarrow </span><span class="s0">as </span><span class="s1">pa</span>

        <span class="s0">return </span><span class="s1">pa.array(self._data</span><span class="s0">, </span><span class="s1">mask=self._mask</span><span class="s0">, </span><span class="s1">type=type)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">_hasna(self) -&gt; bool:</span>
        <span class="s3"># Note: this is expensive right now! The hope is that we can</span>
        <span class="s3"># make this faster by having an optional mask, but not have to change</span>
        <span class="s3"># source code using it..</span>

        <span class="s3"># error: Incompatible return value type (got &quot;bool_&quot;, expected &quot;bool&quot;)</span>
        <span class="s0">return </span><span class="s1">self._mask.any()  </span><span class="s3"># type: ignore[return-value]</span>

    <span class="s0">def </span><span class="s1">_propagate_mask(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">mask: npt.NDArray[np.bool_] | </span><span class="s0">None, </span><span class="s1">other</span>
    <span class="s1">) -&gt; npt.NDArray[np.bool_]:</span>
        <span class="s0">if </span><span class="s1">mask </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">mask = self._mask.copy()  </span><span class="s3"># TODO: need test for BooleanArray needing a copy</span>
            <span class="s0">if </span><span class="s1">other </span><span class="s0">is </span><span class="s1">libmissing.NA:</span>
                <span class="s3"># GH#45421 don't alter inplace</span>
                <span class="s1">mask = mask | </span><span class="s0">True</span>
            <span class="s0">elif </span><span class="s1">is_list_like(other) </span><span class="s0">and </span><span class="s1">len(other) == len(mask):</span>
                <span class="s1">mask = mask | isna(other)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">mask = self._mask | mask</span>
        <span class="s3"># Incompatible return value type (got &quot;Optional[ndarray[Any, dtype[bool_]]]&quot;,</span>
        <span class="s3"># expected &quot;ndarray[Any, dtype[bool_]]&quot;)</span>
        <span class="s0">return </span><span class="s1">mask  </span><span class="s3"># type: ignore[return-value]</span>

    <span class="s0">def </span><span class="s1">_arith_method(self</span><span class="s0">, </span><span class="s1">other</span><span class="s0">, </span><span class="s1">op):</span>
        <span class="s1">op_name = op.__name__</span>
        <span class="s1">omask = </span><span class="s0">None</span>

        <span class="s0">if </span><span class="s1">(</span>
            <span class="s0">not </span><span class="s1">hasattr(other</span><span class="s0">, </span><span class="s4">&quot;dtype&quot;</span><span class="s1">)</span>
            <span class="s0">and </span><span class="s1">is_list_like(other)</span>
            <span class="s0">and </span><span class="s1">len(other) == len(self)</span>
        <span class="s1">):</span>
            <span class="s3"># Try inferring masked dtype instead of casting to object</span>
            <span class="s1">other = pd_array(other)</span>
            <span class="s1">other = extract_array(other</span><span class="s0">, </span><span class="s1">extract_numpy=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">BaseMaskedArray):</span>
            <span class="s1">other</span><span class="s0">, </span><span class="s1">omask = other._data</span><span class="s0">, </span><span class="s1">other._mask</span>

        <span class="s0">elif </span><span class="s1">is_list_like(other):</span>
            <span class="s0">if not </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">ExtensionArray):</span>
                <span class="s1">other = np.asarray(other)</span>
            <span class="s0">if </span><span class="s1">other.ndim &gt; </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;can only perform ops with 1-d structures&quot;</span><span class="s1">)</span>

        <span class="s3"># We wrap the non-masked arithmetic logic used for numpy dtypes</span>
        <span class="s3">#  in Series/Index arithmetic ops.</span>
        <span class="s1">other = ops.maybe_prepare_scalar_for_op(other</span><span class="s0">, </span><span class="s1">(len(self)</span><span class="s0">,</span><span class="s1">))</span>
        <span class="s1">pd_op = ops.get_array_op(op)</span>
        <span class="s1">other = ensure_wrapped_if_datetimelike(other)</span>

        <span class="s0">if </span><span class="s1">op_name </span><span class="s0">in </span><span class="s1">{</span><span class="s4">&quot;pow&quot;</span><span class="s0">, </span><span class="s4">&quot;rpow&quot;</span><span class="s1">} </span><span class="s0">and </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">np.bool_):</span>
            <span class="s3"># Avoid DeprecationWarning: In future, it will be an error</span>
            <span class="s3">#  for 'np.bool_' scalars to be interpreted as an index</span>
            <span class="s3">#  e.g. test_array_scalar_like_equivalence</span>
            <span class="s1">other = bool(other)</span>

        <span class="s1">mask = self._propagate_mask(omask</span><span class="s0">, </span><span class="s1">other)</span>

        <span class="s0">if </span><span class="s1">other </span><span class="s0">is </span><span class="s1">libmissing.NA:</span>
            <span class="s1">result = np.ones_like(self._data)</span>
            <span class="s0">if </span><span class="s1">self.dtype.kind == </span><span class="s4">&quot;b&quot;</span><span class="s1">:</span>
                <span class="s0">if </span><span class="s1">op_name </span><span class="s0">in </span><span class="s1">{</span>
                    <span class="s4">&quot;floordiv&quot;</span><span class="s0">,</span>
                    <span class="s4">&quot;rfloordiv&quot;</span><span class="s0">,</span>
                    <span class="s4">&quot;pow&quot;</span><span class="s0">,</span>
                    <span class="s4">&quot;rpow&quot;</span><span class="s0">,</span>
                    <span class="s4">&quot;truediv&quot;</span><span class="s0">,</span>
                    <span class="s4">&quot;rtruediv&quot;</span><span class="s0">,</span>
                <span class="s1">}:</span>
                    <span class="s3"># GH#41165 Try to match non-masked Series behavior</span>
                    <span class="s3">#  This is still imperfect GH#46043</span>
                    <span class="s0">raise </span><span class="s1">NotImplementedError(</span>
                        <span class="s4">f&quot;operator '</span><span class="s0">{</span><span class="s1">op_name</span><span class="s0">}</span><span class="s4">' not implemented for bool dtypes&quot;</span>
                    <span class="s1">)</span>
                <span class="s0">if </span><span class="s1">op_name </span><span class="s0">in </span><span class="s1">{</span><span class="s4">&quot;mod&quot;</span><span class="s0">, </span><span class="s4">&quot;rmod&quot;</span><span class="s1">}:</span>
                    <span class="s1">dtype = </span><span class="s4">&quot;int8&quot;</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">dtype = </span><span class="s4">&quot;bool&quot;</span>
                <span class="s1">result = result.astype(dtype)</span>
            <span class="s0">elif </span><span class="s4">&quot;truediv&quot; </span><span class="s0">in </span><span class="s1">op_name </span><span class="s0">and </span><span class="s1">self.dtype.kind != </span><span class="s4">&quot;f&quot;</span><span class="s1">:</span>
                <span class="s3"># The actual data here doesn't matter since the mask</span>
                <span class="s3">#  will be all-True, but since this is division, we want</span>
                <span class="s3">#  to end up with floating dtype.</span>
                <span class="s1">result = result.astype(np.float64)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s3"># Make sure we do this before the &quot;pow&quot; mask checks</span>
            <span class="s3">#  to get an expected exception message on shape mismatch.</span>
            <span class="s0">if </span><span class="s1">self.dtype.kind </span><span class="s0">in </span><span class="s4">&quot;iu&quot; </span><span class="s0">and </span><span class="s1">op_name </span><span class="s0">in </span><span class="s1">[</span><span class="s4">&quot;floordiv&quot;</span><span class="s0">, </span><span class="s4">&quot;mod&quot;</span><span class="s1">]:</span>
                <span class="s3"># TODO(GH#30188) ATM we don't match the behavior of non-masked</span>
                <span class="s3">#  types with respect to floordiv-by-zero</span>
                <span class="s1">pd_op = op</span>

            <span class="s0">with </span><span class="s1">np.errstate(all=</span><span class="s4">&quot;ignore&quot;</span><span class="s1">):</span>
                <span class="s1">result = pd_op(self._data</span><span class="s0">, </span><span class="s1">other)</span>

        <span class="s0">if </span><span class="s1">op_name == </span><span class="s4">&quot;pow&quot;</span><span class="s1">:</span>
            <span class="s3"># 1 ** x is 1.</span>
            <span class="s1">mask = np.where((self._data == </span><span class="s5">1</span><span class="s1">) &amp; ~self._mask</span><span class="s0">, False, </span><span class="s1">mask)</span>
            <span class="s3"># x ** 0 is 1.</span>
            <span class="s0">if </span><span class="s1">omask </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">mask = np.where((other == </span><span class="s5">0</span><span class="s1">) &amp; ~omask</span><span class="s0">, False, </span><span class="s1">mask)</span>
            <span class="s0">elif </span><span class="s1">other </span><span class="s0">is not </span><span class="s1">libmissing.NA:</span>
                <span class="s1">mask = np.where(other == </span><span class="s5">0</span><span class="s0">, False, </span><span class="s1">mask)</span>

        <span class="s0">elif </span><span class="s1">op_name == </span><span class="s4">&quot;rpow&quot;</span><span class="s1">:</span>
            <span class="s3"># 1 ** x is 1.</span>
            <span class="s0">if </span><span class="s1">omask </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">mask = np.where((other == </span><span class="s5">1</span><span class="s1">) &amp; ~omask</span><span class="s0">, False, </span><span class="s1">mask)</span>
            <span class="s0">elif </span><span class="s1">other </span><span class="s0">is not </span><span class="s1">libmissing.NA:</span>
                <span class="s1">mask = np.where(other == </span><span class="s5">1</span><span class="s0">, False, </span><span class="s1">mask)</span>
            <span class="s3"># x ** 0 is 1.</span>
            <span class="s1">mask = np.where((self._data == </span><span class="s5">0</span><span class="s1">) &amp; ~self._mask</span><span class="s0">, False, </span><span class="s1">mask)</span>

        <span class="s0">return </span><span class="s1">self._maybe_mask_result(result</span><span class="s0">, </span><span class="s1">mask)</span>

    <span class="s1">_logical_method = _arith_method</span>

    <span class="s0">def </span><span class="s1">_cmp_method(self</span><span class="s0">, </span><span class="s1">other</span><span class="s0">, </span><span class="s1">op) -&gt; BooleanArray:</span>
        <span class="s0">from </span><span class="s1">pandas.core.arrays </span><span class="s0">import </span><span class="s1">BooleanArray</span>

        <span class="s1">mask = </span><span class="s0">None</span>

        <span class="s0">if </span><span class="s1">isinstance(other</span><span class="s0">, </span><span class="s1">BaseMaskedArray):</span>
            <span class="s1">other</span><span class="s0">, </span><span class="s1">mask = other._data</span><span class="s0">, </span><span class="s1">other._mask</span>

        <span class="s0">elif </span><span class="s1">is_list_like(other):</span>
            <span class="s1">other = np.asarray(other)</span>
            <span class="s0">if </span><span class="s1">other.ndim &gt; </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;can only perform ops with 1-d structures&quot;</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">len(self) != len(other):</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Lengths must match to compare&quot;</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">other </span><span class="s0">is </span><span class="s1">libmissing.NA:</span>
            <span class="s3"># numpy does not handle pd.NA well as &quot;other&quot; scalar (it returns</span>
            <span class="s3"># a scalar False instead of an array)</span>
            <span class="s3"># This may be fixed by NA.__array_ufunc__. Revisit this check</span>
            <span class="s3"># once that's implemented.</span>
            <span class="s1">result = np.zeros(self._data.shape</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s4">&quot;bool&quot;</span><span class="s1">)</span>
            <span class="s1">mask = np.ones(self._data.shape</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s4">&quot;bool&quot;</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">with </span><span class="s1">warnings.catch_warnings():</span>
                <span class="s3"># numpy may show a FutureWarning or DeprecationWarning:</span>
                <span class="s3">#     elementwise comparison failed; returning scalar instead,</span>
                <span class="s3">#     but in the future will perform elementwise comparison</span>
                <span class="s3"># before returning NotImplemented. We fall back to the correct</span>
                <span class="s3"># behavior today, so that should be fine to ignore.</span>
                <span class="s1">warnings.filterwarnings(</span><span class="s4">&quot;ignore&quot;</span><span class="s0">, </span><span class="s4">&quot;elementwise&quot;</span><span class="s0">, </span><span class="s1">FutureWarning)</span>
                <span class="s1">warnings.filterwarnings(</span><span class="s4">&quot;ignore&quot;</span><span class="s0">, </span><span class="s4">&quot;elementwise&quot;</span><span class="s0">, </span><span class="s1">DeprecationWarning)</span>
                <span class="s1">method = getattr(self._data</span><span class="s0">, </span><span class="s4">f&quot;__</span><span class="s0">{</span><span class="s1">op.__name__</span><span class="s0">}</span><span class="s4">__&quot;</span><span class="s1">)</span>
                <span class="s1">result = method(other)</span>

                <span class="s0">if </span><span class="s1">result </span><span class="s0">is </span><span class="s1">NotImplemented:</span>
                    <span class="s1">result = invalid_comparison(self._data</span><span class="s0">, </span><span class="s1">other</span><span class="s0">, </span><span class="s1">op)</span>

        <span class="s1">mask = self._propagate_mask(mask</span><span class="s0">, </span><span class="s1">other)</span>
        <span class="s0">return </span><span class="s1">BooleanArray(result</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_maybe_mask_result(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">result: np.ndarray | tuple[np.ndarray</span><span class="s0">, </span><span class="s1">np.ndarray]</span><span class="s0">, </span><span class="s1">mask: np.ndarray</span>
    <span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Parameters 
        ---------- 
        result : array-like or tuple[array-like] 
        mask : array-like bool 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance(result</span><span class="s0">, </span><span class="s1">tuple):</span>
            <span class="s3"># i.e. divmod</span>
            <span class="s1">div</span><span class="s0">, </span><span class="s1">mod = result</span>
            <span class="s0">return </span><span class="s1">(</span>
                <span class="s1">self._maybe_mask_result(div</span><span class="s0">, </span><span class="s1">mask)</span><span class="s0">,</span>
                <span class="s1">self._maybe_mask_result(mod</span><span class="s0">, </span><span class="s1">mask)</span><span class="s0">,</span>
            <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">result.dtype.kind == </span><span class="s4">&quot;f&quot;</span><span class="s1">:</span>
            <span class="s0">from </span><span class="s1">pandas.core.arrays </span><span class="s0">import </span><span class="s1">FloatingArray</span>

            <span class="s0">return </span><span class="s1">FloatingArray(result</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s0">elif </span><span class="s1">result.dtype.kind == </span><span class="s4">&quot;b&quot;</span><span class="s1">:</span>
            <span class="s0">from </span><span class="s1">pandas.core.arrays </span><span class="s0">import </span><span class="s1">BooleanArray</span>

            <span class="s0">return </span><span class="s1">BooleanArray(result</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s0">elif </span><span class="s1">lib.is_np_dtype(result.dtype</span><span class="s0">, </span><span class="s4">&quot;m&quot;</span><span class="s1">) </span><span class="s0">and </span><span class="s1">is_supported_unit(</span>
            <span class="s1">get_unit_from_dtype(result.dtype)</span>
        <span class="s1">):</span>
            <span class="s3"># e.g. test_numeric_arr_mul_tdscalar_numexpr_path</span>
            <span class="s0">from </span><span class="s1">pandas.core.arrays </span><span class="s0">import </span><span class="s1">TimedeltaArray</span>

            <span class="s1">result[mask] = result.dtype.type(</span><span class="s4">&quot;NaT&quot;</span><span class="s1">)</span>

            <span class="s0">if not </span><span class="s1">isinstance(result</span><span class="s0">, </span><span class="s1">TimedeltaArray):</span>
                <span class="s0">return </span><span class="s1">TimedeltaArray._simple_new(result</span><span class="s0">, </span><span class="s1">dtype=result.dtype)</span>

            <span class="s0">return </span><span class="s1">result</span>

        <span class="s0">elif </span><span class="s1">result.dtype.kind </span><span class="s0">in </span><span class="s4">&quot;iu&quot;</span><span class="s1">:</span>
            <span class="s0">from </span><span class="s1">pandas.core.arrays </span><span class="s0">import </span><span class="s1">IntegerArray</span>

            <span class="s0">return </span><span class="s1">IntegerArray(result</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">result[mask] = np.nan</span>
            <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">isna(self) -&gt; np.ndarray:</span>
        <span class="s0">return </span><span class="s1">self._mask.copy()</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">_na_value(self):</span>
        <span class="s0">return </span><span class="s1">self.dtype.na_value</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">nbytes(self) -&gt; int:</span>
        <span class="s0">return </span><span class="s1">self._data.nbytes + self._mask.nbytes</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">_concat_same_type(</span>
        <span class="s1">cls</span><span class="s0">,</span>
        <span class="s1">to_concat: Sequence[Self]</span><span class="s0">,</span>
        <span class="s1">axis: AxisInt = </span><span class="s5">0</span><span class="s0">,</span>
    <span class="s1">) -&gt; Self:</span>
        <span class="s1">data = np.concatenate([x._data </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">to_concat]</span><span class="s0">, </span><span class="s1">axis=axis)</span>
        <span class="s1">mask = np.concatenate([x._mask </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">to_concat]</span><span class="s0">, </span><span class="s1">axis=axis)</span>
        <span class="s0">return </span><span class="s1">cls(data</span><span class="s0">, </span><span class="s1">mask)</span>

    <span class="s0">def </span><span class="s1">take(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">indexer</span><span class="s0">,</span>
        <span class="s1">*</span><span class="s0">,</span>
        <span class="s1">allow_fill: bool = </span><span class="s0">False,</span>
        <span class="s1">fill_value: Scalar | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">axis: AxisInt = </span><span class="s5">0</span><span class="s0">,</span>
    <span class="s1">) -&gt; Self:</span>
        <span class="s3"># we always fill with 1 internally</span>
        <span class="s3"># to avoid upcasting</span>
        <span class="s1">data_fill_value = self._internal_fill_value </span><span class="s0">if </span><span class="s1">isna(fill_value) </span><span class="s0">else </span><span class="s1">fill_value</span>
        <span class="s1">result = take(</span>
            <span class="s1">self._data</span><span class="s0">,</span>
            <span class="s1">indexer</span><span class="s0">,</span>
            <span class="s1">fill_value=data_fill_value</span><span class="s0">,</span>
            <span class="s1">allow_fill=allow_fill</span><span class="s0">,</span>
            <span class="s1">axis=axis</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s1">mask = take(</span>
            <span class="s1">self._mask</span><span class="s0">, </span><span class="s1">indexer</span><span class="s0">, </span><span class="s1">fill_value=</span><span class="s0">True, </span><span class="s1">allow_fill=allow_fill</span><span class="s0">, </span><span class="s1">axis=axis</span>
        <span class="s1">)</span>

        <span class="s3"># if we are filling</span>
        <span class="s3"># we only fill where the indexer is null</span>
        <span class="s3"># not existing missing values</span>
        <span class="s3"># TODO(jreback) what if we have a non-na float as a fill value?</span>
        <span class="s0">if </span><span class="s1">allow_fill </span><span class="s0">and </span><span class="s1">notna(fill_value):</span>
            <span class="s1">fill_mask = np.asarray(indexer) == -</span><span class="s5">1</span>
            <span class="s1">result[fill_mask] = fill_value</span>
            <span class="s1">mask = mask ^ fill_mask</span>

        <span class="s0">return </span><span class="s1">self._simple_new(result</span><span class="s0">, </span><span class="s1">mask)</span>

    <span class="s3"># error: Return type &quot;BooleanArray&quot; of &quot;isin&quot; incompatible with return type</span>
    <span class="s3"># &quot;ndarray&quot; in supertype &quot;ExtensionArray&quot;</span>
    <span class="s0">def </span><span class="s1">isin(self</span><span class="s0">, </span><span class="s1">values) -&gt; BooleanArray:  </span><span class="s3"># type: ignore[override]</span>
        <span class="s0">from </span><span class="s1">pandas.core.arrays </span><span class="s0">import </span><span class="s1">BooleanArray</span>

        <span class="s3"># algorithms.isin will eventually convert values to an ndarray, so no extra</span>
        <span class="s3"># cost to doing it here first</span>
        <span class="s1">values_arr = np.asarray(values)</span>
        <span class="s1">result = isin(self._data</span><span class="s0">, </span><span class="s1">values_arr)</span>

        <span class="s0">if </span><span class="s1">self._hasna:</span>
            <span class="s1">values_have_NA = values_arr.dtype == object </span><span class="s0">and </span><span class="s1">any(</span>
                <span class="s1">val </span><span class="s0">is </span><span class="s1">self.dtype.na_value </span><span class="s0">for </span><span class="s1">val </span><span class="s0">in </span><span class="s1">values_arr</span>
            <span class="s1">)</span>

            <span class="s3"># For now, NA does not propagate so set result according to presence of NA,</span>
            <span class="s3"># see https://github.com/pandas-dev/pandas/pull/38379 for some discussion</span>
            <span class="s1">result[self._mask] = values_have_NA</span>

        <span class="s1">mask = np.zeros(self._data.shape</span><span class="s0">, </span><span class="s1">dtype=bool)</span>
        <span class="s0">return </span><span class="s1">BooleanArray(result</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">copy(self) -&gt; Self:</span>
        <span class="s1">data = self._data.copy()</span>
        <span class="s1">mask = self._mask.copy()</span>
        <span class="s0">return </span><span class="s1">self._simple_new(data</span><span class="s0">, </span><span class="s1">mask)</span>

    <span class="s0">def </span><span class="s1">unique(self) -&gt; Self:</span>
        <span class="s2">&quot;&quot;&quot; 
        Compute the BaseMaskedArray of unique values. 
 
        Returns 
        ------- 
        uniques : BaseMaskedArray 
        &quot;&quot;&quot;</span>
        <span class="s1">uniques</span><span class="s0">, </span><span class="s1">mask = algos.unique_with_mask(self._data</span><span class="s0">, </span><span class="s1">self._mask)</span>
        <span class="s0">return </span><span class="s1">self._simple_new(uniques</span><span class="s0">, </span><span class="s1">mask)</span>

    <span class="s1">@doc(ExtensionArray.searchsorted)</span>
    <span class="s0">def </span><span class="s1">searchsorted(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">value: NumpyValueArrayLike | ExtensionArray</span><span class="s0">,</span>
        <span class="s1">side: Literal[</span><span class="s4">&quot;left&quot;</span><span class="s0">, </span><span class="s4">&quot;right&quot;</span><span class="s1">] = </span><span class="s4">&quot;left&quot;</span><span class="s0">,</span>
        <span class="s1">sorter: NumpySorter | </span><span class="s0">None </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">) -&gt; npt.NDArray[np.intp] | np.intp:</span>
        <span class="s0">if </span><span class="s1">self._hasna:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;searchsorted requires array to be sorted, which is impossible &quot;</span>
                <span class="s4">&quot;with NAs present.&quot;</span>
            <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">isinstance(value</span><span class="s0">, </span><span class="s1">ExtensionArray):</span>
            <span class="s1">value = value.astype(object)</span>
        <span class="s3"># Base class searchsorted would cast to object, which is *much* slower.</span>
        <span class="s0">return </span><span class="s1">self._data.searchsorted(value</span><span class="s0">, </span><span class="s1">side=side</span><span class="s0">, </span><span class="s1">sorter=sorter)</span>

    <span class="s1">@doc(ExtensionArray.factorize)</span>
    <span class="s0">def </span><span class="s1">factorize(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">use_na_sentinel: bool = </span><span class="s0">True,</span>
    <span class="s1">) -&gt; tuple[np.ndarray</span><span class="s0">, </span><span class="s1">ExtensionArray]:</span>
        <span class="s1">arr = self._data</span>
        <span class="s1">mask = self._mask</span>

        <span class="s3"># Use a sentinel for na; recode and add NA to uniques if necessary below</span>
        <span class="s1">codes</span><span class="s0">, </span><span class="s1">uniques = factorize_array(arr</span><span class="s0">, </span><span class="s1">use_na_sentinel=</span><span class="s0">True, </span><span class="s1">mask=mask)</span>

        <span class="s3"># check that factorize_array correctly preserves dtype.</span>
        <span class="s0">assert </span><span class="s1">uniques.dtype == self.dtype.numpy_dtype</span><span class="s0">, </span><span class="s1">(uniques.dtype</span><span class="s0">, </span><span class="s1">self.dtype)</span>

        <span class="s1">has_na = mask.any()</span>
        <span class="s0">if </span><span class="s1">use_na_sentinel </span><span class="s0">or not </span><span class="s1">has_na:</span>
            <span class="s1">size = len(uniques)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s3"># Make room for an NA value</span>
            <span class="s1">size = len(uniques) + </span><span class="s5">1</span>
        <span class="s1">uniques_mask = np.zeros(size</span><span class="s0">, </span><span class="s1">dtype=bool)</span>
        <span class="s0">if not </span><span class="s1">use_na_sentinel </span><span class="s0">and </span><span class="s1">has_na:</span>
            <span class="s1">na_index = mask.argmax()</span>
            <span class="s3"># Insert na with the proper code</span>
            <span class="s0">if </span><span class="s1">na_index == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">na_code = np.intp(</span><span class="s5">0</span><span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">na_code = codes[:na_index].max() + </span><span class="s5">1</span>
            <span class="s1">codes[codes &gt;= na_code] += </span><span class="s5">1</span>
            <span class="s1">codes[codes == -</span><span class="s5">1</span><span class="s1">] = na_code</span>
            <span class="s3"># dummy value for uniques; not used since uniques_mask will be True</span>
            <span class="s1">uniques = np.insert(uniques</span><span class="s0">, </span><span class="s1">na_code</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
            <span class="s1">uniques_mask[na_code] = </span><span class="s0">True</span>
        <span class="s1">uniques_ea = self._simple_new(uniques</span><span class="s0">, </span><span class="s1">uniques_mask)</span>

        <span class="s0">return </span><span class="s1">codes</span><span class="s0">, </span><span class="s1">uniques_ea</span>

    <span class="s1">@doc(ExtensionArray._values_for_argsort)</span>
    <span class="s0">def </span><span class="s1">_values_for_argsort(self) -&gt; np.ndarray:</span>
        <span class="s0">return </span><span class="s1">self._data</span>

    <span class="s0">def </span><span class="s1">value_counts(self</span><span class="s0">, </span><span class="s1">dropna: bool = </span><span class="s0">True</span><span class="s1">) -&gt; Series:</span>
        <span class="s2">&quot;&quot;&quot; 
        Returns a Series containing counts of each unique value. 
 
        Parameters 
        ---------- 
        dropna : bool, default True 
            Don't include counts of missing values. 
 
        Returns 
        ------- 
        counts : Series 
 
        See Also 
        -------- 
        Series.value_counts 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">(</span>
            <span class="s1">Index</span><span class="s0">,</span>
            <span class="s1">Series</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s0">from </span><span class="s1">pandas.arrays </span><span class="s0">import </span><span class="s1">IntegerArray</span>

        <span class="s1">keys</span><span class="s0">, </span><span class="s1">value_counts = algos.value_counts_arraylike(</span>
            <span class="s1">self._data</span><span class="s0">, </span><span class="s1">dropna=</span><span class="s0">True, </span><span class="s1">mask=self._mask</span>
        <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">dropna:</span>
            <span class="s1">res = Series(value_counts</span><span class="s0">, </span><span class="s1">index=keys</span><span class="s0">, </span><span class="s1">name=</span><span class="s4">&quot;count&quot;</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s1">res.index = res.index.astype(self.dtype)</span>
            <span class="s1">res = res.astype(</span><span class="s4">&quot;Int64&quot;</span><span class="s1">)</span>
            <span class="s0">return </span><span class="s1">res</span>

        <span class="s3"># if we want nans, count the mask</span>
        <span class="s1">counts = np.empty(len(value_counts) + </span><span class="s5">1</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s4">&quot;int64&quot;</span><span class="s1">)</span>
        <span class="s1">counts[:-</span><span class="s5">1</span><span class="s1">] = value_counts</span>
        <span class="s1">counts[-</span><span class="s5">1</span><span class="s1">] = self._mask.sum()</span>

        <span class="s1">index = Index(keys</span><span class="s0">, </span><span class="s1">dtype=self.dtype).insert(len(keys)</span><span class="s0">, </span><span class="s1">self.dtype.na_value)</span>
        <span class="s1">index = index.astype(self.dtype)</span>

        <span class="s1">mask = np.zeros(len(counts)</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s4">&quot;bool&quot;</span><span class="s1">)</span>
        <span class="s1">counts_array = IntegerArray(counts</span><span class="s0">, </span><span class="s1">mask)</span>

        <span class="s0">return </span><span class="s1">Series(counts_array</span><span class="s0">, </span><span class="s1">index=index</span><span class="s0">, </span><span class="s1">name=</span><span class="s4">&quot;count&quot;</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s1">@doc(ExtensionArray.equals)</span>
    <span class="s0">def </span><span class="s1">equals(self</span><span class="s0">, </span><span class="s1">other) -&gt; bool:</span>
        <span class="s0">if </span><span class="s1">type(self) != type(other):</span>
            <span class="s0">return False</span>
        <span class="s0">if </span><span class="s1">other.dtype != self.dtype:</span>
            <span class="s0">return False</span>

        <span class="s3"># GH#44382 if e.g. self[1] is np.nan and other[1] is pd.NA, we are NOT</span>
        <span class="s3">#  equal.</span>
        <span class="s0">if not </span><span class="s1">np.array_equal(self._mask</span><span class="s0">, </span><span class="s1">other._mask):</span>
            <span class="s0">return False</span>

        <span class="s1">left = self._data[~self._mask]</span>
        <span class="s1">right = other._data[~other._mask]</span>
        <span class="s0">return </span><span class="s1">array_equivalent(left</span><span class="s0">, </span><span class="s1">right</span><span class="s0">, </span><span class="s1">strict_nan=</span><span class="s0">True, </span><span class="s1">dtype_equal=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_quantile(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">qs: npt.NDArray[np.float64]</span><span class="s0">, </span><span class="s1">interpolation: str</span>
    <span class="s1">) -&gt; BaseMaskedArray:</span>
        <span class="s2">&quot;&quot;&quot; 
        Dispatch to quantile_with_mask, needed because we do not have 
        _from_factorized. 
 
        Notes 
        ----- 
        We assume that all impacted cases are 1D-only. 
        &quot;&quot;&quot;</span>
        <span class="s1">res = quantile_with_mask(</span>
            <span class="s1">self._data</span><span class="s0">,</span>
            <span class="s1">mask=self._mask</span><span class="s0">,</span>
            <span class="s3"># TODO(GH#40932): na_value_for_dtype(self.dtype.numpy_dtype)</span>
            <span class="s3">#  instead of np.nan</span>
            <span class="s1">fill_value=np.nan</span><span class="s0">,</span>
            <span class="s1">qs=qs</span><span class="s0">,</span>
            <span class="s1">interpolation=interpolation</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">self._hasna:</span>
            <span class="s3"># Our result mask is all-False unless we are all-NA, in which</span>
            <span class="s3">#  case it is all-True.</span>
            <span class="s0">if </span><span class="s1">self.ndim == </span><span class="s5">2</span><span class="s1">:</span>
                <span class="s3"># I think this should be out_mask=self.isna().all(axis=1)</span>
                <span class="s3">#  but am holding off until we have tests</span>
                <span class="s0">raise </span><span class="s1">NotImplementedError</span>
            <span class="s0">if </span><span class="s1">self.isna().all():</span>
                <span class="s1">out_mask = np.ones(res.shape</span><span class="s0">, </span><span class="s1">dtype=bool)</span>

                <span class="s0">if </span><span class="s1">is_integer_dtype(self.dtype):</span>
                    <span class="s3"># We try to maintain int dtype if possible for not all-na case</span>
                    <span class="s3"># as well</span>
                    <span class="s1">res = np.zeros(res.shape</span><span class="s0">, </span><span class="s1">dtype=self.dtype.numpy_dtype)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">out_mask = np.zeros(res.shape</span><span class="s0">, </span><span class="s1">dtype=bool)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">out_mask = np.zeros(res.shape</span><span class="s0">, </span><span class="s1">dtype=bool)</span>
        <span class="s0">return </span><span class="s1">self._maybe_mask_result(res</span><span class="s0">, </span><span class="s1">mask=out_mask)</span>

    <span class="s3"># ------------------------------------------------------------------</span>
    <span class="s3"># Reductions</span>

    <span class="s0">def </span><span class="s1">_reduce(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">name: str</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">skipna: bool = </span><span class="s0">True, </span><span class="s1">keepdims: bool = </span><span class="s0">False, </span><span class="s1">**kwargs</span>
    <span class="s1">):</span>
        <span class="s0">if </span><span class="s1">name </span><span class="s0">in </span><span class="s1">{</span><span class="s4">&quot;any&quot;</span><span class="s0">, </span><span class="s4">&quot;all&quot;</span><span class="s0">, </span><span class="s4">&quot;min&quot;</span><span class="s0">, </span><span class="s4">&quot;max&quot;</span><span class="s0">, </span><span class="s4">&quot;sum&quot;</span><span class="s0">, </span><span class="s4">&quot;prod&quot;</span><span class="s0">, </span><span class="s4">&quot;mean&quot;</span><span class="s0">, </span><span class="s4">&quot;var&quot;</span><span class="s0">, </span><span class="s4">&quot;std&quot;</span><span class="s1">}:</span>
            <span class="s1">result = getattr(self</span><span class="s0">, </span><span class="s1">name)(skipna=skipna</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s3"># median, skew, kurt, sem</span>
            <span class="s1">data = self._data</span>
            <span class="s1">mask = self._mask</span>
            <span class="s1">op = getattr(nanops</span><span class="s0">, </span><span class="s4">f&quot;nan</span><span class="s0">{</span><span class="s1">name</span><span class="s0">}</span><span class="s4">&quot;</span><span class="s1">)</span>
            <span class="s1">axis = kwargs.pop(</span><span class="s4">&quot;axis&quot;</span><span class="s0">, None</span><span class="s1">)</span>
            <span class="s1">result = op(data</span><span class="s0">, </span><span class="s1">axis=axis</span><span class="s0">, </span><span class="s1">skipna=skipna</span><span class="s0">, </span><span class="s1">mask=mask</span><span class="s0">, </span><span class="s1">**kwargs)</span>

        <span class="s0">if </span><span class="s1">keepdims:</span>
            <span class="s0">if </span><span class="s1">isna(result):</span>
                <span class="s0">return </span><span class="s1">self._wrap_na_result(name=name</span><span class="s0">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s0">, </span><span class="s1">mask_size=(</span><span class="s5">1</span><span class="s0">,</span><span class="s1">))</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">result = result.reshape(</span><span class="s5">1</span><span class="s1">)</span>
                <span class="s1">mask = np.zeros(</span><span class="s5">1</span><span class="s0">, </span><span class="s1">dtype=bool)</span>
                <span class="s0">return </span><span class="s1">self._maybe_mask_result(result</span><span class="s0">, </span><span class="s1">mask)</span>

        <span class="s0">if </span><span class="s1">isna(result):</span>
            <span class="s0">return </span><span class="s1">libmissing.NA</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">_wrap_reduction_result(self</span><span class="s0">, </span><span class="s1">name: str</span><span class="s0">, </span><span class="s1">result</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">skipna</span><span class="s0">, </span><span class="s1">axis):</span>
        <span class="s0">if </span><span class="s1">isinstance(result</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
            <span class="s0">if </span><span class="s1">skipna:</span>
                <span class="s3"># we only retain mask for all-NA rows/columns</span>
                <span class="s1">mask = self._mask.all(axis=axis)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">mask = self._mask.any(axis=axis)</span>

            <span class="s0">return </span><span class="s1">self._maybe_mask_result(result</span><span class="s0">, </span><span class="s1">mask)</span>
        <span class="s0">return </span><span class="s1">result</span>

    <span class="s0">def </span><span class="s1">_wrap_na_result(self</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">mask_size):</span>
        <span class="s1">mask = np.ones(mask_size</span><span class="s0">, </span><span class="s1">dtype=bool)</span>

        <span class="s1">float_dtyp = </span><span class="s4">&quot;float32&quot; </span><span class="s0">if </span><span class="s1">self.dtype == </span><span class="s4">&quot;Float32&quot; </span><span class="s0">else </span><span class="s4">&quot;float64&quot;</span>
        <span class="s0">if </span><span class="s1">name </span><span class="s0">in </span><span class="s1">[</span><span class="s4">&quot;mean&quot;</span><span class="s0">, </span><span class="s4">&quot;median&quot;</span><span class="s0">, </span><span class="s4">&quot;var&quot;</span><span class="s0">, </span><span class="s4">&quot;std&quot;</span><span class="s0">, </span><span class="s4">&quot;skew&quot;</span><span class="s0">, </span><span class="s4">&quot;kurt&quot;</span><span class="s1">]:</span>
            <span class="s1">np_dtype = float_dtyp</span>
        <span class="s0">elif </span><span class="s1">name </span><span class="s0">in </span><span class="s1">[</span><span class="s4">&quot;min&quot;</span><span class="s0">, </span><span class="s4">&quot;max&quot;</span><span class="s1">] </span><span class="s0">or </span><span class="s1">self.dtype.itemsize == </span><span class="s5">8</span><span class="s1">:</span>
            <span class="s1">np_dtype = self.dtype.numpy_dtype.name</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">is_windows_or_32bit = is_platform_windows() </span><span class="s0">or not </span><span class="s1">IS64</span>
            <span class="s1">int_dtyp = </span><span class="s4">&quot;int32&quot; </span><span class="s0">if </span><span class="s1">is_windows_or_32bit </span><span class="s0">else </span><span class="s4">&quot;int64&quot;</span>
            <span class="s1">uint_dtyp = </span><span class="s4">&quot;uint32&quot; </span><span class="s0">if </span><span class="s1">is_windows_or_32bit </span><span class="s0">else </span><span class="s4">&quot;uint64&quot;</span>
            <span class="s1">np_dtype = {</span><span class="s4">&quot;b&quot;</span><span class="s1">: int_dtyp</span><span class="s0">, </span><span class="s4">&quot;i&quot;</span><span class="s1">: int_dtyp</span><span class="s0">, </span><span class="s4">&quot;u&quot;</span><span class="s1">: uint_dtyp</span><span class="s0">, </span><span class="s4">&quot;f&quot;</span><span class="s1">: float_dtyp}[</span>
                <span class="s1">self.dtype.kind</span>
            <span class="s1">]</span>

        <span class="s1">value = np.array([</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np_dtype)</span>
        <span class="s0">return </span><span class="s1">self._maybe_mask_result(value</span><span class="s0">, </span><span class="s1">mask=mask)</span>

    <span class="s0">def </span><span class="s1">_wrap_min_count_reduction_result(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">name: str</span><span class="s0">, </span><span class="s1">result</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">skipna</span><span class="s0">, </span><span class="s1">min_count</span><span class="s0">, </span><span class="s1">axis</span>
    <span class="s1">):</span>
        <span class="s0">if </span><span class="s1">min_count == </span><span class="s5">0 </span><span class="s0">and </span><span class="s1">isinstance(result</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
            <span class="s0">return </span><span class="s1">self._maybe_mask_result(result</span><span class="s0">, </span><span class="s1">np.zeros(result.shape</span><span class="s0">, </span><span class="s1">dtype=bool))</span>
        <span class="s0">return </span><span class="s1">self._wrap_reduction_result(name</span><span class="s0">, </span><span class="s1">result</span><span class="s0">, </span><span class="s1">skipna=skipna</span><span class="s0">, </span><span class="s1">axis=axis)</span>

    <span class="s0">def </span><span class="s1">sum(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">*</span><span class="s0">,</span>
        <span class="s1">skipna: bool = </span><span class="s0">True,</span>
        <span class="s1">min_count: int = </span><span class="s5">0</span><span class="s0">,</span>
        <span class="s1">axis: AxisInt | </span><span class="s0">None </span><span class="s1">= </span><span class="s5">0</span><span class="s0">,</span>
        <span class="s1">**kwargs</span><span class="s0">,</span>
    <span class="s1">):</span>
        <span class="s1">nv.validate_sum(()</span><span class="s0">, </span><span class="s1">kwargs)</span>

        <span class="s1">result = masked_reductions.sum(</span>
            <span class="s1">self._data</span><span class="s0">,</span>
            <span class="s1">self._mask</span><span class="s0">,</span>
            <span class="s1">skipna=skipna</span><span class="s0">,</span>
            <span class="s1">min_count=min_count</span><span class="s0">,</span>
            <span class="s1">axis=axis</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">self._wrap_min_count_reduction_result(</span>
            <span class="s4">&quot;sum&quot;</span><span class="s0">, </span><span class="s1">result</span><span class="s0">, </span><span class="s1">skipna=skipna</span><span class="s0">, </span><span class="s1">min_count=min_count</span><span class="s0">, </span><span class="s1">axis=axis</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">prod(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">*</span><span class="s0">,</span>
        <span class="s1">skipna: bool = </span><span class="s0">True,</span>
        <span class="s1">min_count: int = </span><span class="s5">0</span><span class="s0">,</span>
        <span class="s1">axis: AxisInt | </span><span class="s0">None </span><span class="s1">= </span><span class="s5">0</span><span class="s0">,</span>
        <span class="s1">**kwargs</span><span class="s0">,</span>
    <span class="s1">):</span>
        <span class="s1">nv.validate_prod(()</span><span class="s0">, </span><span class="s1">kwargs)</span>

        <span class="s1">result = masked_reductions.prod(</span>
            <span class="s1">self._data</span><span class="s0">,</span>
            <span class="s1">self._mask</span><span class="s0">,</span>
            <span class="s1">skipna=skipna</span><span class="s0">,</span>
            <span class="s1">min_count=min_count</span><span class="s0">,</span>
            <span class="s1">axis=axis</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">self._wrap_min_count_reduction_result(</span>
            <span class="s4">&quot;prod&quot;</span><span class="s0">, </span><span class="s1">result</span><span class="s0">, </span><span class="s1">skipna=skipna</span><span class="s0">, </span><span class="s1">min_count=min_count</span><span class="s0">, </span><span class="s1">axis=axis</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">mean(self</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">skipna: bool = </span><span class="s0">True, </span><span class="s1">axis: AxisInt | </span><span class="s0">None </span><span class="s1">= </span><span class="s5">0</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">nv.validate_mean(()</span><span class="s0">, </span><span class="s1">kwargs)</span>
        <span class="s1">result = masked_reductions.mean(</span>
            <span class="s1">self._data</span><span class="s0">,</span>
            <span class="s1">self._mask</span><span class="s0">,</span>
            <span class="s1">skipna=skipna</span><span class="s0">,</span>
            <span class="s1">axis=axis</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">self._wrap_reduction_result(</span><span class="s4">&quot;mean&quot;</span><span class="s0">, </span><span class="s1">result</span><span class="s0">, </span><span class="s1">skipna=skipna</span><span class="s0">, </span><span class="s1">axis=axis)</span>

    <span class="s0">def </span><span class="s1">var(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">skipna: bool = </span><span class="s0">True, </span><span class="s1">axis: AxisInt | </span><span class="s0">None </span><span class="s1">= </span><span class="s5">0</span><span class="s0">, </span><span class="s1">ddof: int = </span><span class="s5">1</span><span class="s0">, </span><span class="s1">**kwargs</span>
    <span class="s1">):</span>
        <span class="s1">nv.validate_stat_ddof_func(()</span><span class="s0">, </span><span class="s1">kwargs</span><span class="s0">, </span><span class="s1">fname=</span><span class="s4">&quot;var&quot;</span><span class="s1">)</span>
        <span class="s1">result = masked_reductions.var(</span>
            <span class="s1">self._data</span><span class="s0">,</span>
            <span class="s1">self._mask</span><span class="s0">,</span>
            <span class="s1">skipna=skipna</span><span class="s0">,</span>
            <span class="s1">axis=axis</span><span class="s0">,</span>
            <span class="s1">ddof=ddof</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">self._wrap_reduction_result(</span><span class="s4">&quot;var&quot;</span><span class="s0">, </span><span class="s1">result</span><span class="s0">, </span><span class="s1">skipna=skipna</span><span class="s0">, </span><span class="s1">axis=axis)</span>

    <span class="s0">def </span><span class="s1">std(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">skipna: bool = </span><span class="s0">True, </span><span class="s1">axis: AxisInt | </span><span class="s0">None </span><span class="s1">= </span><span class="s5">0</span><span class="s0">, </span><span class="s1">ddof: int = </span><span class="s5">1</span><span class="s0">, </span><span class="s1">**kwargs</span>
    <span class="s1">):</span>
        <span class="s1">nv.validate_stat_ddof_func(()</span><span class="s0">, </span><span class="s1">kwargs</span><span class="s0">, </span><span class="s1">fname=</span><span class="s4">&quot;std&quot;</span><span class="s1">)</span>
        <span class="s1">result = masked_reductions.std(</span>
            <span class="s1">self._data</span><span class="s0">,</span>
            <span class="s1">self._mask</span><span class="s0">,</span>
            <span class="s1">skipna=skipna</span><span class="s0">,</span>
            <span class="s1">axis=axis</span><span class="s0">,</span>
            <span class="s1">ddof=ddof</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">self._wrap_reduction_result(</span><span class="s4">&quot;std&quot;</span><span class="s0">, </span><span class="s1">result</span><span class="s0">, </span><span class="s1">skipna=skipna</span><span class="s0">, </span><span class="s1">axis=axis)</span>

    <span class="s0">def </span><span class="s1">min(self</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">skipna: bool = </span><span class="s0">True, </span><span class="s1">axis: AxisInt | </span><span class="s0">None </span><span class="s1">= </span><span class="s5">0</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">nv.validate_min(()</span><span class="s0">, </span><span class="s1">kwargs)</span>
        <span class="s1">result = masked_reductions.min(</span>
            <span class="s1">self._data</span><span class="s0">,</span>
            <span class="s1">self._mask</span><span class="s0">,</span>
            <span class="s1">skipna=skipna</span><span class="s0">,</span>
            <span class="s1">axis=axis</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">self._wrap_reduction_result(</span><span class="s4">&quot;min&quot;</span><span class="s0">, </span><span class="s1">result</span><span class="s0">, </span><span class="s1">skipna=skipna</span><span class="s0">, </span><span class="s1">axis=axis)</span>

    <span class="s0">def </span><span class="s1">max(self</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">skipna: bool = </span><span class="s0">True, </span><span class="s1">axis: AxisInt | </span><span class="s0">None </span><span class="s1">= </span><span class="s5">0</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s1">nv.validate_max(()</span><span class="s0">, </span><span class="s1">kwargs)</span>
        <span class="s1">result = masked_reductions.max(</span>
            <span class="s1">self._data</span><span class="s0">,</span>
            <span class="s1">self._mask</span><span class="s0">,</span>
            <span class="s1">skipna=skipna</span><span class="s0">,</span>
            <span class="s1">axis=axis</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">self._wrap_reduction_result(</span><span class="s4">&quot;max&quot;</span><span class="s0">, </span><span class="s1">result</span><span class="s0">, </span><span class="s1">skipna=skipna</span><span class="s0">, </span><span class="s1">axis=axis)</span>

    <span class="s0">def </span><span class="s1">any(self</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">skipna: bool = </span><span class="s0">True, </span><span class="s1">axis: AxisInt | </span><span class="s0">None </span><span class="s1">= </span><span class="s5">0</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s2">&quot;&quot;&quot; 
        Return whether any element is truthy. 
 
        Returns False unless there is at least one element that is truthy. 
        By default, NAs are skipped. If ``skipna=False`` is specified and 
        missing values are present, similar :ref:`Kleene logic &lt;boolean.kleene&gt;` 
        is used as for logical operations. 
 
        .. versionchanged:: 1.4.0 
 
        Parameters 
        ---------- 
        skipna : bool, default True 
            Exclude NA values. If the entire array is NA and `skipna` is 
            True, then the result will be False, as for an empty array. 
            If `skipna` is False, the result will still be True if there is 
            at least one element that is truthy, otherwise NA will be returned 
            if there are NA's present. 
        axis : int, optional, default 0 
        **kwargs : any, default None 
            Additional keywords have no effect but might be accepted for 
            compatibility with NumPy. 
 
        Returns 
        ------- 
        bool or :attr:`pandas.NA` 
 
        See Also 
        -------- 
        numpy.any : Numpy version of this method. 
        BaseMaskedArray.all : Return whether all elements are truthy. 
 
        Examples 
        -------- 
        The result indicates whether any element is truthy (and by default 
        skips NAs): 
 
        &gt;&gt;&gt; pd.array([True, False, True]).any() 
        True 
        &gt;&gt;&gt; pd.array([True, False, pd.NA]).any() 
        True 
        &gt;&gt;&gt; pd.array([False, False, pd.NA]).any() 
        False 
        &gt;&gt;&gt; pd.array([], dtype=&quot;boolean&quot;).any() 
        False 
        &gt;&gt;&gt; pd.array([pd.NA], dtype=&quot;boolean&quot;).any() 
        False 
        &gt;&gt;&gt; pd.array([pd.NA], dtype=&quot;Float64&quot;).any() 
        False 
 
        With ``skipna=False``, the result can be NA if this is logically 
        required (whether ``pd.NA`` is True or False influences the result): 
 
        &gt;&gt;&gt; pd.array([True, False, pd.NA]).any(skipna=False) 
        True 
        &gt;&gt;&gt; pd.array([1, 0, pd.NA]).any(skipna=False) 
        True 
        &gt;&gt;&gt; pd.array([False, False, pd.NA]).any(skipna=False) 
        &lt;NA&gt; 
        &gt;&gt;&gt; pd.array([0, 0, pd.NA]).any(skipna=False) 
        &lt;NA&gt; 
        &quot;&quot;&quot;</span>
        <span class="s1">nv.validate_any(()</span><span class="s0">, </span><span class="s1">kwargs)</span>

        <span class="s1">values = self._data.copy()</span>
        <span class="s3"># error: Argument 3 to &quot;putmask&quot; has incompatible type &quot;object&quot;;</span>
        <span class="s3"># expected &quot;Union[_SupportsArray[dtype[Any]],</span>
        <span class="s3"># _NestedSequence[_SupportsArray[dtype[Any]]],</span>
        <span class="s3"># bool, int, float, complex, str, bytes,</span>
        <span class="s3"># _NestedSequence[Union[bool, int, float, complex, str, bytes]]]&quot;</span>
        <span class="s1">np.putmask(values</span><span class="s0">, </span><span class="s1">self._mask</span><span class="s0">, </span><span class="s1">self._falsey_value)  </span><span class="s3"># type: ignore[arg-type]</span>
        <span class="s1">result = values.any()</span>
        <span class="s0">if </span><span class="s1">skipna:</span>
            <span class="s0">return </span><span class="s1">result</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">result </span><span class="s0">or </span><span class="s1">len(self) == </span><span class="s5">0 </span><span class="s0">or not </span><span class="s1">self._mask.any():</span>
                <span class="s0">return </span><span class="s1">result</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">self.dtype.na_value</span>

    <span class="s0">def </span><span class="s1">all(self</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">skipna: bool = </span><span class="s0">True, </span><span class="s1">axis: AxisInt | </span><span class="s0">None </span><span class="s1">= </span><span class="s5">0</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s2">&quot;&quot;&quot; 
        Return whether all elements are truthy. 
 
        Returns True unless there is at least one element that is falsey. 
        By default, NAs are skipped. If ``skipna=False`` is specified and 
        missing values are present, similar :ref:`Kleene logic &lt;boolean.kleene&gt;` 
        is used as for logical operations. 
 
        .. versionchanged:: 1.4.0 
 
        Parameters 
        ---------- 
        skipna : bool, default True 
            Exclude NA values. If the entire array is NA and `skipna` is 
            True, then the result will be True, as for an empty array. 
            If `skipna` is False, the result will still be False if there is 
            at least one element that is falsey, otherwise NA will be returned 
            if there are NA's present. 
        axis : int, optional, default 0 
        **kwargs : any, default None 
            Additional keywords have no effect but might be accepted for 
            compatibility with NumPy. 
 
        Returns 
        ------- 
        bool or :attr:`pandas.NA` 
 
        See Also 
        -------- 
        numpy.all : Numpy version of this method. 
        BooleanArray.any : Return whether any element is truthy. 
 
        Examples 
        -------- 
        The result indicates whether all elements are truthy (and by default 
        skips NAs): 
 
        &gt;&gt;&gt; pd.array([True, True, pd.NA]).all() 
        True 
        &gt;&gt;&gt; pd.array([1, 1, pd.NA]).all() 
        True 
        &gt;&gt;&gt; pd.array([True, False, pd.NA]).all() 
        False 
        &gt;&gt;&gt; pd.array([], dtype=&quot;boolean&quot;).all() 
        True 
        &gt;&gt;&gt; pd.array([pd.NA], dtype=&quot;boolean&quot;).all() 
        True 
        &gt;&gt;&gt; pd.array([pd.NA], dtype=&quot;Float64&quot;).all() 
        True 
 
        With ``skipna=False``, the result can be NA if this is logically 
        required (whether ``pd.NA`` is True or False influences the result): 
 
        &gt;&gt;&gt; pd.array([True, True, pd.NA]).all(skipna=False) 
        &lt;NA&gt; 
        &gt;&gt;&gt; pd.array([1, 1, pd.NA]).all(skipna=False) 
        &lt;NA&gt; 
        &gt;&gt;&gt; pd.array([True, False, pd.NA]).all(skipna=False) 
        False 
        &gt;&gt;&gt; pd.array([1, 0, pd.NA]).all(skipna=False) 
        False 
        &quot;&quot;&quot;</span>
        <span class="s1">nv.validate_all(()</span><span class="s0">, </span><span class="s1">kwargs)</span>

        <span class="s1">values = self._data.copy()</span>
        <span class="s3"># error: Argument 3 to &quot;putmask&quot; has incompatible type &quot;object&quot;;</span>
        <span class="s3"># expected &quot;Union[_SupportsArray[dtype[Any]],</span>
        <span class="s3"># _NestedSequence[_SupportsArray[dtype[Any]]],</span>
        <span class="s3"># bool, int, float, complex, str, bytes,</span>
        <span class="s3"># _NestedSequence[Union[bool, int, float, complex, str, bytes]]]&quot;</span>
        <span class="s1">np.putmask(values</span><span class="s0">, </span><span class="s1">self._mask</span><span class="s0">, </span><span class="s1">self._truthy_value)  </span><span class="s3"># type: ignore[arg-type]</span>
        <span class="s1">result = values.all(axis=axis)</span>

        <span class="s0">if </span><span class="s1">skipna:</span>
            <span class="s0">return </span><span class="s1">result</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if not </span><span class="s1">result </span><span class="s0">or </span><span class="s1">len(self) == </span><span class="s5">0 </span><span class="s0">or not </span><span class="s1">self._mask.any():</span>
                <span class="s0">return </span><span class="s1">result</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">self.dtype.na_value</span>

    <span class="s0">def </span><span class="s1">_accumulate(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">name: str</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">skipna: bool = </span><span class="s0">True, </span><span class="s1">**kwargs</span>
    <span class="s1">) -&gt; BaseMaskedArray:</span>
        <span class="s1">data = self._data</span>
        <span class="s1">mask = self._mask</span>

        <span class="s1">op = getattr(masked_accumulations</span><span class="s0">, </span><span class="s1">name)</span>
        <span class="s1">data</span><span class="s0">, </span><span class="s1">mask = op(data</span><span class="s0">, </span><span class="s1">mask</span><span class="s0">, </span><span class="s1">skipna=skipna</span><span class="s0">, </span><span class="s1">**kwargs)</span>

        <span class="s0">return </span><span class="s1">self._simple_new(data</span><span class="s0">, </span><span class="s1">mask)</span>

    <span class="s3"># ------------------------------------------------------------------</span>
    <span class="s3"># GroupBy Methods</span>

    <span class="s0">def </span><span class="s1">_groupby_op(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">*</span><span class="s0">,</span>
        <span class="s1">how: str</span><span class="s0">,</span>
        <span class="s1">has_dropped_na: bool</span><span class="s0">,</span>
        <span class="s1">min_count: int</span><span class="s0">,</span>
        <span class="s1">ngroups: int</span><span class="s0">,</span>
        <span class="s1">ids: npt.NDArray[np.intp]</span><span class="s0">,</span>
        <span class="s1">**kwargs</span><span class="s0">,</span>
    <span class="s1">):</span>
        <span class="s0">from </span><span class="s1">pandas.core.groupby.ops </span><span class="s0">import </span><span class="s1">WrappedCythonOp</span>

        <span class="s1">kind = WrappedCythonOp.get_kind_from_how(how)</span>
        <span class="s1">op = WrappedCythonOp(how=how</span><span class="s0">, </span><span class="s1">kind=kind</span><span class="s0">, </span><span class="s1">has_dropped_na=has_dropped_na)</span>

        <span class="s3"># libgroupby functions are responsible for NOT altering mask</span>
        <span class="s1">mask = self._mask</span>
        <span class="s0">if </span><span class="s1">op.kind != </span><span class="s4">&quot;aggregate&quot;</span><span class="s1">:</span>
            <span class="s1">result_mask = mask.copy()</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">result_mask = np.zeros(ngroups</span><span class="s0">, </span><span class="s1">dtype=bool)</span>

        <span class="s1">res_values = op._cython_op_ndim_compat(</span>
            <span class="s1">self._data</span><span class="s0">,</span>
            <span class="s1">min_count=min_count</span><span class="s0">,</span>
            <span class="s1">ngroups=ngroups</span><span class="s0">,</span>
            <span class="s1">comp_ids=ids</span><span class="s0">,</span>
            <span class="s1">mask=mask</span><span class="s0">,</span>
            <span class="s1">result_mask=result_mask</span><span class="s0">,</span>
            <span class="s1">**kwargs</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">op.how == </span><span class="s4">&quot;ohlc&quot;</span><span class="s1">:</span>
            <span class="s1">arity = op._cython_arity.get(op.how</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">result_mask = np.tile(result_mask</span><span class="s0">, </span><span class="s1">(arity</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)).T</span>

        <span class="s3"># res_values should already have the correct dtype, we just need to</span>
        <span class="s3">#  wrap in a MaskedArray</span>
        <span class="s0">return </span><span class="s1">self._maybe_mask_result(res_values</span><span class="s0">, </span><span class="s1">result_mask)</span>


<span class="s0">def </span><span class="s1">transpose_homogeneous_masked_arrays(</span>
    <span class="s1">masked_arrays: Sequence[BaseMaskedArray]</span><span class="s0">,</span>
<span class="s1">) -&gt; list[BaseMaskedArray]:</span>
    <span class="s2">&quot;&quot;&quot;Transpose masked arrays in a list, but faster. 
 
    Input should be a list of 1-dim masked arrays of equal length and all have the 
    same dtype. The caller is responsible for ensuring validity of input data. 
    &quot;&quot;&quot;</span>
    <span class="s1">masked_arrays = list(masked_arrays)</span>
    <span class="s1">values = [arr._data.reshape(</span><span class="s5">1</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">) </span><span class="s0">for </span><span class="s1">arr </span><span class="s0">in </span><span class="s1">masked_arrays]</span>
    <span class="s1">transposed_values = np.concatenate(values</span><span class="s0">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">)</span>

    <span class="s1">masks = [arr._mask.reshape(</span><span class="s5">1</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">) </span><span class="s0">for </span><span class="s1">arr </span><span class="s0">in </span><span class="s1">masked_arrays]</span>
    <span class="s1">transposed_masks = np.concatenate(masks</span><span class="s0">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">)</span>

    <span class="s1">dtype = masked_arrays[</span><span class="s5">0</span><span class="s1">].dtype</span>
    <span class="s1">arr_type = dtype.construct_array_type()</span>
    <span class="s1">transposed_arrays: list[BaseMaskedArray] = []</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(transposed_values.shape[</span><span class="s5">1</span><span class="s1">]):</span>
        <span class="s1">transposed_arr = arr_type(transposed_values[:</span><span class="s0">, </span><span class="s1">i]</span><span class="s0">, </span><span class="s1">mask=transposed_masks[:</span><span class="s0">, </span><span class="s1">i])</span>
        <span class="s1">transposed_arrays.append(transposed_arr)</span>

    <span class="s0">return </span><span class="s1">transposed_arrays</span>
</pre>
</body>
</html>