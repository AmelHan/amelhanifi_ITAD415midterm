<html>
<head>
<title>test_utils_dataframe.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #6897bb;}
.s4 { color: #808080;}
.s5 { color: #629755; font-style: italic;}
.s6 { color: #a5c261;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_utils_dataframe.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">import </span><span class="s1">re</span>
<span class="s0">import </span><span class="s1">warnings</span>
<span class="s0">from </span><span class="s1">collections.abc </span><span class="s0">import </span><span class="s1">Iterable</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">pandas </span><span class="s0">as </span><span class="s1">pd</span>
<span class="s0">import </span><span class="s1">pytest</span>
<span class="s0">from </span><span class="s1">packaging.version </span><span class="s0">import </span><span class="s1">Version</span>

<span class="s0">import </span><span class="s1">dask</span>
<span class="s0">import </span><span class="s1">dask.dataframe </span><span class="s0">as </span><span class="s1">dd</span>
<span class="s0">from </span><span class="s1">dask.dataframe._compat </span><span class="s0">import </span><span class="s1">PANDAS_GE_200</span><span class="s0">, </span><span class="s1">tm</span>
<span class="s0">from </span><span class="s1">dask.dataframe.core </span><span class="s0">import </span><span class="s1">apply_and_enforce</span>
<span class="s0">from </span><span class="s1">dask.dataframe.utils </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">UNKNOWN_CATEGORIES</span><span class="s0">,</span>
    <span class="s1">assert_eq</span><span class="s0">,</span>
    <span class="s1">check_matching_columns</span><span class="s0">,</span>
    <span class="s1">check_meta</span><span class="s0">,</span>
    <span class="s1">is_dataframe_like</span><span class="s0">,</span>
    <span class="s1">is_index_like</span><span class="s0">,</span>
    <span class="s1">is_series_like</span><span class="s0">,</span>
    <span class="s1">make_meta</span><span class="s0">,</span>
    <span class="s1">meta_frame_constructor</span><span class="s0">,</span>
    <span class="s1">meta_nonempty</span><span class="s0">,</span>
    <span class="s1">meta_series_constructor</span><span class="s0">,</span>
    <span class="s1">pyarrow_strings_enabled</span><span class="s0">,</span>
    <span class="s1">raise_on_meta_error</span><span class="s0">,</span>
    <span class="s1">shard_df_on_index</span><span class="s0">,</span>
    <span class="s1">valid_divisions</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">dask.local </span><span class="s0">import </span><span class="s1">get_sync</span>


<span class="s0">def </span><span class="s1">test_shard_df_on_index():</span>
    <span class="s1">df = pd.DataFrame(</span>
        <span class="s1">{</span><span class="s2">&quot;x&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">6</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: list(</span><span class="s2">&quot;abdabd&quot;</span><span class="s1">)}</span><span class="s0">, </span><span class="s1">index=[</span><span class="s3">10</span><span class="s0">, </span><span class="s3">20</span><span class="s0">, </span><span class="s3">30</span><span class="s0">, </span><span class="s3">40</span><span class="s0">, </span><span class="s3">50</span><span class="s0">, </span><span class="s3">60</span><span class="s1">]</span>
    <span class="s1">)</span>

    <span class="s1">result = list(shard_df_on_index(df</span><span class="s0">, </span><span class="s1">[</span><span class="s3">20</span><span class="s0">, </span><span class="s3">50</span><span class="s1">]))</span>
    <span class="s0">assert </span><span class="s1">list(result[</span><span class="s3">0</span><span class="s1">].index) == [</span><span class="s3">10</span><span class="s1">]</span>
    <span class="s0">assert </span><span class="s1">list(result[</span><span class="s3">1</span><span class="s1">].index) == [</span><span class="s3">20</span><span class="s0">, </span><span class="s3">30</span><span class="s0">, </span><span class="s3">40</span><span class="s1">]</span>
    <span class="s0">assert </span><span class="s1">list(result[</span><span class="s3">2</span><span class="s1">].index) == [</span><span class="s3">50</span><span class="s0">, </span><span class="s3">60</span><span class="s1">]</span>


<span class="s0">def </span><span class="s1">test_make_meta():</span>
    <span class="s1">df = pd.DataFrame(</span>
        <span class="s1">{</span><span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: list(</span><span class="s2">&quot;abc&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">: [</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">2.0</span><span class="s0">, </span><span class="s3">3.0</span><span class="s1">]}</span><span class="s0">, </span><span class="s1">index=[</span><span class="s3">10</span><span class="s0">, </span><span class="s3">20</span><span class="s0">, </span><span class="s3">30</span><span class="s1">]</span>
    <span class="s1">)</span>

    <span class="s4"># Pandas dataframe</span>
    <span class="s1">meta = make_meta(df)</span>
    <span class="s0">assert </span><span class="s1">len(meta) == </span><span class="s3">0</span>
    <span class="s0">assert </span><span class="s1">(meta.dtypes == df.dtypes).all()</span>
    <span class="s0">assert </span><span class="s1">isinstance(meta.index</span><span class="s0">, </span><span class="s1">type(df.index))</span>
    <span class="s4"># - ensure no references to original data arrays are kept</span>
    <span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s2">&quot;abc&quot;</span><span class="s1">:</span>
        <span class="s1">meta_pointer = meta[col].values.__array_interface__[</span><span class="s2">&quot;data&quot;</span><span class="s1">][</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">df_pointer = df[col].values.__array_interface__[</span><span class="s2">&quot;data&quot;</span><span class="s1">][</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s1">meta_pointer != df_pointer</span>
    <span class="s1">meta_pointer = meta.index.values.__array_interface__[</span><span class="s2">&quot;data&quot;</span><span class="s1">][</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s1">df_pointer = df.index.values.__array_interface__[</span><span class="s2">&quot;data&quot;</span><span class="s1">][</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s0">assert </span><span class="s1">meta_pointer != df_pointer</span>

    <span class="s4"># Pandas series</span>
    <span class="s1">meta = make_meta(df.a)</span>
    <span class="s0">assert </span><span class="s1">len(meta) == </span><span class="s3">0</span>
    <span class="s0">assert </span><span class="s1">meta.dtype == df.a.dtype</span>
    <span class="s0">assert </span><span class="s1">isinstance(meta.index</span><span class="s0">, </span><span class="s1">type(df.index))</span>
    <span class="s4"># - ensure no references to original data arrays are kept</span>
    <span class="s1">meta_pointer = meta.values.__array_interface__[</span><span class="s2">&quot;data&quot;</span><span class="s1">][</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s1">df_pointer = df.a.values.__array_interface__[</span><span class="s2">&quot;data&quot;</span><span class="s1">][</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s0">assert </span><span class="s1">meta_pointer != df_pointer</span>
    <span class="s1">meta_pointer = meta.index.values.__array_interface__[</span><span class="s2">&quot;data&quot;</span><span class="s1">][</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s1">df_pointer = df.index.values.__array_interface__[</span><span class="s2">&quot;data&quot;</span><span class="s1">][</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s0">assert </span><span class="s1">meta_pointer != df_pointer</span>

    <span class="s4"># Pandas index</span>
    <span class="s1">meta = make_meta(df.index)</span>
    <span class="s0">assert </span><span class="s1">isinstance(meta</span><span class="s0">, </span><span class="s1">type(df.index))</span>
    <span class="s0">assert </span><span class="s1">len(meta) == </span><span class="s3">0</span>
    <span class="s4"># - ensure no references to original data arrays are kept</span>
    <span class="s1">meta_pointer = meta.values.__array_interface__[</span><span class="s2">&quot;data&quot;</span><span class="s1">][</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s1">df_pointer = df.index.values.__array_interface__[</span><span class="s2">&quot;data&quot;</span><span class="s1">][</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s0">assert </span><span class="s1">meta_pointer != df_pointer</span>

    <span class="s4"># Dask object</span>
    <span class="s1">ddf = dd.from_pandas(df</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">make_meta(ddf) </span><span class="s0">is </span><span class="s1">ddf._meta</span>

    <span class="s4"># Dict</span>
    <span class="s1">meta = make_meta({</span><span class="s2">&quot;a&quot;</span><span class="s1">: </span><span class="s2">&quot;i8&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: </span><span class="s2">&quot;O&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">: </span><span class="s2">&quot;f8&quot;</span><span class="s1">})</span>
    <span class="s0">assert </span><span class="s1">isinstance(meta</span><span class="s0">, </span><span class="s1">pd.DataFrame)</span>
    <span class="s0">assert </span><span class="s1">len(meta) == </span><span class="s3">0</span>
    <span class="s0">assert </span><span class="s1">(meta.dtypes == df.dtypes).all()</span>
    <span class="s0">assert </span><span class="s1">isinstance(meta.index</span><span class="s0">, </span><span class="s1">pd.RangeIndex)</span>

    <span class="s4"># List</span>
    <span class="s1">meta = make_meta([(</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;i8&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;f8&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;O&quot;</span><span class="s1">)])</span>
    <span class="s0">assert </span><span class="s1">(meta.columns == [</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">]).all()</span>
    <span class="s0">assert </span><span class="s1">len(meta) == </span><span class="s3">0</span>
    <span class="s0">assert </span><span class="s1">(meta.dtypes == df.dtypes[meta.dtypes.index]).all()</span>
    <span class="s0">assert </span><span class="s1">isinstance(meta.index</span><span class="s0">, </span><span class="s1">pd.RangeIndex)</span>

    <span class="s4"># Tuple</span>
    <span class="s1">meta = make_meta((</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;i8&quot;</span><span class="s1">))</span>
    <span class="s0">assert </span><span class="s1">isinstance(meta</span><span class="s0">, </span><span class="s1">pd.Series)</span>
    <span class="s0">assert </span><span class="s1">len(meta) == </span><span class="s3">0</span>
    <span class="s0">assert </span><span class="s1">meta.dtype == </span><span class="s2">&quot;i8&quot;</span>
    <span class="s0">assert </span><span class="s1">meta.name == </span><span class="s2">&quot;a&quot;</span>

    <span class="s4"># Iterable</span>
    <span class="s0">class </span><span class="s1">CustomMetadata(Iterable):</span>
        <span class="s5">&quot;&quot;&quot;Custom class iterator returning pandas types.&quot;&quot;&quot;</span>

        <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">max=</span><span class="s3">0</span><span class="s1">):</span>
            <span class="s1">self.types = [(</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;i8&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;f8&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;O&quot;</span><span class="s1">)]</span>

        <span class="s0">def </span><span class="s1">__iter__(self):</span>
            <span class="s1">self.n = </span><span class="s3">0</span>
            <span class="s0">return </span><span class="s1">self</span>

        <span class="s0">def </span><span class="s1">__next__(self):</span>
            <span class="s0">if </span><span class="s1">self.n &lt; len(self.types):</span>
                <span class="s1">ret = self.types[self.n]</span>
                <span class="s1">self.n += </span><span class="s3">1</span>
                <span class="s0">return </span><span class="s1">ret</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">StopIteration</span>

    <span class="s1">meta = make_meta(CustomMetadata())</span>
    <span class="s0">assert </span><span class="s1">(meta.columns == [</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">]).all()</span>
    <span class="s0">assert </span><span class="s1">len(meta) == </span><span class="s3">0</span>
    <span class="s0">assert </span><span class="s1">(meta.dtypes == df.dtypes[meta.dtypes.index]).all()</span>
    <span class="s0">assert </span><span class="s1">isinstance(meta.index</span><span class="s0">, </span><span class="s1">pd.RangeIndex)</span>

    <span class="s4"># With index</span>
    <span class="s1">idx = pd.Index([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;foo&quot;</span><span class="s1">)</span>
    <span class="s1">meta = make_meta(</span>
        <span class="s1">{</span><span class="s2">&quot;a&quot;</span><span class="s1">: </span><span class="s2">&quot;i8&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: </span><span class="s2">&quot;i4&quot;</span><span class="s1">}</span><span class="s0">,</span>
        <span class="s1">index=idx</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">type(meta.index) </span><span class="s0">is </span><span class="s1">type(idx)</span>
    <span class="s0">assert </span><span class="s1">meta.index.dtype == </span><span class="s2">&quot;int64&quot;</span>
    <span class="s0">assert </span><span class="s1">len(meta.index) == </span><span class="s3">0</span>

    <span class="s1">meta = make_meta((</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;i8&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">index=idx)</span>
    <span class="s0">assert </span><span class="s1">type(meta.index) </span><span class="s0">is </span><span class="s1">type(idx)</span>
    <span class="s0">assert </span><span class="s1">meta.index.dtype == </span><span class="s2">&quot;int64&quot;</span>
    <span class="s0">assert </span><span class="s1">len(meta.index) == </span><span class="s3">0</span>

    <span class="s4"># Categoricals</span>
    <span class="s1">meta = make_meta({</span><span class="s2">&quot;a&quot;</span><span class="s1">: </span><span class="s2">&quot;category&quot;</span><span class="s1">}</span><span class="s0">, </span><span class="s1">parent_meta=df)</span>
    <span class="s0">assert </span><span class="s1">len(meta.a.cat.categories) == </span><span class="s3">1</span>
    <span class="s0">assert </span><span class="s1">meta.a.cat.categories[</span><span class="s3">0</span><span class="s1">] == UNKNOWN_CATEGORIES</span>
    <span class="s1">meta = make_meta((</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;category&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">parent_meta=df)</span>
    <span class="s0">assert </span><span class="s1">len(meta.cat.categories) == </span><span class="s3">1</span>
    <span class="s0">assert </span><span class="s1">meta.cat.categories[</span><span class="s3">0</span><span class="s1">] == UNKNOWN_CATEGORIES</span>

    <span class="s4"># Categorials with Index</span>
    <span class="s1">meta = make_meta({</span><span class="s2">&quot;a&quot;</span><span class="s1">: </span><span class="s2">&quot;category&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: </span><span class="s2">&quot;int64&quot;</span><span class="s1">}</span><span class="s0">, </span><span class="s1">index=idx)</span>
    <span class="s0">assert </span><span class="s1">len(meta.a.cat.categories) == </span><span class="s3">1</span>
    <span class="s0">assert </span><span class="s1">meta.index.dtype == </span><span class="s2">&quot;int64&quot;</span>
    <span class="s0">assert </span><span class="s1">meta.index.empty</span>

    <span class="s4"># Numpy scalar</span>
    <span class="s1">meta = make_meta(np.float64(</span><span class="s3">1.0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">parent_meta=df)</span>
    <span class="s0">assert </span><span class="s1">isinstance(meta</span><span class="s0">, </span><span class="s1">np.float64)</span>

    <span class="s4"># Python scalar</span>
    <span class="s1">meta = make_meta(</span><span class="s3">1.0</span><span class="s0">, </span><span class="s1">parent_meta=df)</span>
    <span class="s0">assert </span><span class="s1">isinstance(meta</span><span class="s0">, </span><span class="s1">np.float64)</span>

    <span class="s4"># Timestamp</span>
    <span class="s1">x = pd.Timestamp(</span><span class="s3">2000</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">meta = make_meta(x</span><span class="s0">, </span><span class="s1">parent_meta=df)</span>
    <span class="s0">assert </span><span class="s1">meta </span><span class="s0">is </span><span class="s1">x</span>

    <span class="s4"># DatetimeTZDtype</span>
    <span class="s1">x = pd.DatetimeTZDtype(tz=</span><span class="s2">&quot;UTC&quot;</span><span class="s1">)</span>
    <span class="s1">meta = make_meta(x)</span>
    <span class="s0">assert </span><span class="s1">meta == pd.Timestamp(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">tz=x.tz</span><span class="s0">, </span><span class="s1">unit=x.unit)</span>

    <span class="s4"># Dtype expressions</span>
    <span class="s1">meta = make_meta(</span><span class="s2">&quot;i8&quot;</span><span class="s0">, </span><span class="s1">parent_meta=df)</span>
    <span class="s0">assert </span><span class="s1">isinstance(meta</span><span class="s0">, </span><span class="s1">np.int64)</span>
    <span class="s1">meta = make_meta(float</span><span class="s0">, </span><span class="s1">parent_meta=df)</span>
    <span class="s0">assert </span><span class="s1">isinstance(meta</span><span class="s0">, </span><span class="s1">np.dtype(float).type)</span>
    <span class="s1">meta = make_meta(np.dtype(</span><span class="s2">&quot;bool&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">parent_meta=df)</span>
    <span class="s0">assert </span><span class="s1">isinstance(meta</span><span class="s0">, </span><span class="s1">np.bool_)</span>
    <span class="s0">assert </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, lambda</span><span class="s1">: make_meta(</span><span class="s0">None</span><span class="s1">))</span>


<span class="s0">def </span><span class="s1">test_meta_nonempty():</span>
    <span class="s1">df1 = pd.DataFrame(</span>
        <span class="s1">{</span>
            <span class="s2">&quot;A&quot;</span><span class="s1">: pd.Categorical([</span><span class="s2">&quot;Alice&quot;</span><span class="s0">, </span><span class="s2">&quot;Bob&quot;</span><span class="s0">, </span><span class="s2">&quot;Carol&quot;</span><span class="s1">])</span><span class="s0">,</span>
            <span class="s2">&quot;B&quot;</span><span class="s1">: list(</span><span class="s2">&quot;abc&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;C&quot;</span><span class="s1">: </span><span class="s2">&quot;bar&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;D&quot;</span><span class="s1">: np.float32(</span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;E&quot;</span><span class="s1">: np.int32(</span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;F&quot;</span><span class="s1">: pd.Timestamp(</span><span class="s2">&quot;2016-01-01&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;G&quot;</span><span class="s1">: pd.date_range(</span><span class="s2">&quot;2016-01-01&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s3">3</span><span class="s0">, </span><span class="s1">tz=</span><span class="s2">&quot;America/New_York&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;H&quot;</span><span class="s1">: pd.Timedelta(</span><span class="s2">&quot;1 hours&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;I&quot;</span><span class="s1">: np.void(</span><span class="s6">b&quot; &quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;J&quot;</span><span class="s1">: pd.Categorical([UNKNOWN_CATEGORIES] * </span><span class="s3">3</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;K&quot;</span><span class="s1">: pd.Categorical([</span><span class="s0">None, None, None</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">columns=list(</span><span class="s2">&quot;DCBAHGFEIJK&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">df2 = df1.iloc[</span><span class="s3">0</span><span class="s1">:</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s1">df3 = meta_nonempty(df2)</span>
    <span class="s0">assert </span><span class="s1">(df3.dtypes == df2.dtypes).all()</span>
    <span class="s0">assert </span><span class="s1">df3[</span><span class="s2">&quot;A&quot;</span><span class="s1">][</span><span class="s3">0</span><span class="s1">] == </span><span class="s2">&quot;Alice&quot;</span>
    <span class="s0">assert </span><span class="s1">df3[</span><span class="s2">&quot;B&quot;</span><span class="s1">][</span><span class="s3">0</span><span class="s1">] == </span><span class="s2">&quot;foo&quot;</span>
    <span class="s0">assert </span><span class="s1">df3[</span><span class="s2">&quot;C&quot;</span><span class="s1">][</span><span class="s3">0</span><span class="s1">] == </span><span class="s2">&quot;foo&quot;</span>
    <span class="s0">assert </span><span class="s1">df3[</span><span class="s2">&quot;D&quot;</span><span class="s1">][</span><span class="s3">0</span><span class="s1">] == np.float32(</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">df3[</span><span class="s2">&quot;D&quot;</span><span class="s1">][</span><span class="s3">0</span><span class="s1">].dtype == </span><span class="s2">&quot;f4&quot;</span>
    <span class="s0">assert </span><span class="s1">df3[</span><span class="s2">&quot;E&quot;</span><span class="s1">][</span><span class="s3">0</span><span class="s1">] == np.int32(</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">df3[</span><span class="s2">&quot;E&quot;</span><span class="s1">][</span><span class="s3">0</span><span class="s1">].dtype == </span><span class="s2">&quot;i4&quot;</span>
    <span class="s0">assert </span><span class="s1">df3[</span><span class="s2">&quot;F&quot;</span><span class="s1">][</span><span class="s3">0</span><span class="s1">] == pd.Timestamp(</span><span class="s2">&quot;1970-01-01 00:00:00&quot;</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">df3[</span><span class="s2">&quot;G&quot;</span><span class="s1">][</span><span class="s3">0</span><span class="s1">] == pd.Timestamp(</span><span class="s2">&quot;1970-01-01 00:00:00&quot;</span><span class="s0">, </span><span class="s1">tz=</span><span class="s2">&quot;America/New_York&quot;</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">df3[</span><span class="s2">&quot;H&quot;</span><span class="s1">][</span><span class="s3">0</span><span class="s1">] == pd.Timedelta(</span><span class="s2">&quot;1&quot;</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">df3[</span><span class="s2">&quot;I&quot;</span><span class="s1">][</span><span class="s3">0</span><span class="s1">] == </span><span class="s2">&quot;foo&quot;</span>
    <span class="s0">assert </span><span class="s1">df3[</span><span class="s2">&quot;J&quot;</span><span class="s1">][</span><span class="s3">0</span><span class="s1">] == UNKNOWN_CATEGORIES</span>
    <span class="s0">assert </span><span class="s1">len(df3[</span><span class="s2">&quot;K&quot;</span><span class="s1">].cat.categories) == </span><span class="s3">0</span>

    <span class="s1">s = meta_nonempty(df2[</span><span class="s2">&quot;A&quot;</span><span class="s1">])</span>
    <span class="s0">assert </span><span class="s1">s.dtype == df2[</span><span class="s2">&quot;A&quot;</span><span class="s1">].dtype</span>
    <span class="s0">assert </span><span class="s1">(df3[</span><span class="s2">&quot;A&quot;</span><span class="s1">] == s).all()</span>


<span class="s0">def </span><span class="s1">test_meta_duplicated():</span>
    <span class="s1">df = pd.DataFrame(columns=[</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">])</span>
    <span class="s1">res = meta_nonempty(df)</span>

    <span class="s1">exp = pd.DataFrame(</span>
        <span class="s1">[[</span><span class="s2">&quot;foo&quot;</span><span class="s0">, </span><span class="s2">&quot;foo&quot;</span><span class="s0">, </span><span class="s2">&quot;foo&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;foo&quot;</span><span class="s0">, </span><span class="s2">&quot;foo&quot;</span><span class="s0">, </span><span class="s2">&quot;foo&quot;</span><span class="s1">]]</span><span class="s0">,</span>
        <span class="s1">index=meta_nonempty(df.index)</span><span class="s0">,</span>
        <span class="s1">columns=[</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(res</span><span class="s0">, </span><span class="s1">exp)</span>


<span class="s0">def </span><span class="s1">test_meta_nonempty_empty_categories():</span>
    <span class="s0">for </span><span class="s1">dtype </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;O&quot;</span><span class="s0">, </span><span class="s2">&quot;f8&quot;</span><span class="s0">, </span><span class="s2">&quot;M8[ns]&quot;</span><span class="s1">]:</span>
        <span class="s4"># Index</span>
        <span class="s1">idx = pd.CategoricalIndex(</span>
            <span class="s1">[]</span><span class="s0">, </span><span class="s1">pd.Index([]</span><span class="s0">, </span><span class="s1">dtype=dtype)</span><span class="s0">, </span><span class="s1">ordered=</span><span class="s0">True, </span><span class="s1">name=</span><span class="s2">&quot;foo&quot;</span>
        <span class="s1">)</span>
        <span class="s1">res = meta_nonempty(idx)</span>
        <span class="s0">assert </span><span class="s1">type(res) </span><span class="s0">is </span><span class="s1">pd.CategoricalIndex</span>
        <span class="s0">assert </span><span class="s1">type(res.categories) </span><span class="s0">is </span><span class="s1">type(idx.categories)</span>
        <span class="s0">assert </span><span class="s1">res.ordered == idx.ordered</span>
        <span class="s0">assert </span><span class="s1">res.name == idx.name</span>
        <span class="s4"># Series</span>
        <span class="s1">s = idx.to_series()</span>
        <span class="s1">res = meta_nonempty(s)</span>
        <span class="s0">assert </span><span class="s1">res.dtype == </span><span class="s2">&quot;category&quot;</span>
        <span class="s0">assert </span><span class="s1">s.dtype == </span><span class="s2">&quot;category&quot;</span>
        <span class="s0">assert </span><span class="s1">type(res.cat.categories) </span><span class="s0">is </span><span class="s1">type(s.cat.categories)</span>
        <span class="s0">assert </span><span class="s1">res.cat.ordered == s.cat.ordered</span>
        <span class="s0">assert </span><span class="s1">res.name == s.name</span>


<span class="s0">def </span><span class="s1">test_meta_nonempty_index():</span>
    <span class="s1">idx = pd.RangeIndex(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;foo&quot;</span><span class="s1">)</span>
    <span class="s1">res = meta_nonempty(idx)</span>
    <span class="s0">assert </span><span class="s1">type(res) </span><span class="s0">is </span><span class="s1">pd.RangeIndex</span>
    <span class="s0">assert </span><span class="s1">res.name == idx.name</span>

    <span class="s1">idx = pd.Index([</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;foo&quot;</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;int&quot;</span><span class="s1">)</span>
    <span class="s1">res = meta_nonempty(idx)</span>
    <span class="s0">assert </span><span class="s1">type(res) </span><span class="s0">is </span><span class="s1">type(idx)</span>
    <span class="s0">if </span><span class="s1">PANDAS_GE_200:</span>
        <span class="s0">assert </span><span class="s1">res.dtype == np.int_</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s4"># before pandas 2.0, index dtypes were only x64</span>
        <span class="s0">assert </span><span class="s1">res.dtype == </span><span class="s2">&quot;int64&quot;</span>
    <span class="s0">assert </span><span class="s1">res.name == idx.name</span>

    <span class="s1">idx = pd.Index([</span><span class="s2">&quot;a&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;foo&quot;</span><span class="s1">)</span>
    <span class="s1">res = meta_nonempty(idx)</span>
    <span class="s0">assert </span><span class="s1">type(res) </span><span class="s0">is </span><span class="s1">pd.Index</span>
    <span class="s0">assert </span><span class="s1">res.name == idx.name</span>

    <span class="s1">idx = pd.DatetimeIndex([</span><span class="s2">&quot;1970-01-01&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">freq=</span><span class="s2">&quot;d&quot;</span><span class="s0">, </span><span class="s1">tz=</span><span class="s2">&quot;America/New_York&quot;</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;foo&quot;</span><span class="s1">)</span>
    <span class="s1">res = meta_nonempty(idx)</span>
    <span class="s0">assert </span><span class="s1">type(res) </span><span class="s0">is </span><span class="s1">pd.DatetimeIndex</span>
    <span class="s0">assert </span><span class="s1">res.tz == idx.tz</span>
    <span class="s0">assert </span><span class="s1">res.freq == idx.freq</span>
    <span class="s0">assert </span><span class="s1">res.name == idx.name</span>

    <span class="s1">idx = pd.PeriodIndex([</span><span class="s2">&quot;1970-01-01&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">freq=</span><span class="s2">&quot;d&quot;</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;foo&quot;</span><span class="s1">)</span>
    <span class="s1">res = meta_nonempty(idx)</span>
    <span class="s0">assert </span><span class="s1">type(res) </span><span class="s0">is </span><span class="s1">pd.PeriodIndex</span>
    <span class="s0">assert </span><span class="s1">res.freq == idx.freq</span>
    <span class="s0">assert </span><span class="s1">res.name == idx.name</span>

    <span class="s1">idx = pd.TimedeltaIndex([pd.Timedelta(</span><span class="s3">1</span><span class="s0">, </span><span class="s2">&quot;D&quot;</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">freq=</span><span class="s2">&quot;d&quot;</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;foo&quot;</span><span class="s1">)</span>
    <span class="s1">res = meta_nonempty(idx)</span>
    <span class="s0">assert </span><span class="s1">type(res) </span><span class="s0">is </span><span class="s1">pd.TimedeltaIndex</span>
    <span class="s0">assert </span><span class="s1">res.freq == idx.freq</span>
    <span class="s0">assert </span><span class="s1">res.name == idx.name</span>

    <span class="s1">idx = pd.CategoricalIndex([</span><span class="s2">&quot;xyx&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;xyx&quot;</span><span class="s0">, </span><span class="s2">&quot;zzz&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">ordered=</span><span class="s0">True, </span><span class="s1">name=</span><span class="s2">&quot;foo&quot;</span><span class="s1">)</span>
    <span class="s1">res = meta_nonempty(idx)</span>
    <span class="s0">assert </span><span class="s1">type(res) </span><span class="s0">is </span><span class="s1">pd.CategoricalIndex</span>
    <span class="s0">assert </span><span class="s1">(res.categories == idx.categories).all()</span>
    <span class="s0">assert </span><span class="s1">res.ordered == idx.ordered</span>
    <span class="s0">assert </span><span class="s1">res.name == idx.name</span>

    <span class="s1">idx = pd.CategoricalIndex([]</span><span class="s0">, </span><span class="s1">[UNKNOWN_CATEGORIES]</span><span class="s0">, </span><span class="s1">ordered=</span><span class="s0">True, </span><span class="s1">name=</span><span class="s2">&quot;foo&quot;</span><span class="s1">)</span>
    <span class="s1">res = meta_nonempty(idx)</span>
    <span class="s0">assert </span><span class="s1">type(res) </span><span class="s0">is </span><span class="s1">pd.CategoricalIndex</span>
    <span class="s0">assert </span><span class="s1">res.ordered == idx.ordered</span>
    <span class="s0">assert </span><span class="s1">res.name == idx.name</span>

    <span class="s1">levels = [pd.Index([</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;a&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pd.Index([</span><span class="s3">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;b&quot;</span><span class="s1">)]</span>
    <span class="s1">codes = [[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s1">]]</span>
    <span class="s1">idx = pd.MultiIndex(levels=levels</span><span class="s0">, </span><span class="s1">names=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">codes=codes)</span>
    <span class="s1">res = meta_nonempty(idx)</span>
    <span class="s0">assert </span><span class="s1">type(res) </span><span class="s0">is </span><span class="s1">pd.MultiIndex</span>
    <span class="s0">for </span><span class="s1">idx1</span><span class="s0">, </span><span class="s1">idx2 </span><span class="s0">in </span><span class="s1">zip(idx.levels</span><span class="s0">, </span><span class="s1">res.levels):</span>
        <span class="s0">assert </span><span class="s1">type(idx1) </span><span class="s0">is </span><span class="s1">type(idx2)</span>
        <span class="s0">assert </span><span class="s1">idx1.name == idx2.name</span>
    <span class="s0">assert </span><span class="s1">res.names == idx.names</span>

    <span class="s1">levels = [</span>
        <span class="s1">pd.Index([</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;a&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">pd.CategoricalIndex(data=[</span><span class="s2">&quot;xyx&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">categories=[</span><span class="s2">&quot;xyx&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;b&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">pd.TimedeltaIndex([np.timedelta64(</span><span class="s3">1</span><span class="s0">, </span><span class="s2">&quot;D&quot;</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;timedelta&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span>

    <span class="s1">codes = [[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s1">]]</span>

    <span class="s1">idx = pd.MultiIndex(levels=levels</span><span class="s0">, </span><span class="s1">names=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;timedelta&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">codes=codes)</span>
    <span class="s1">res = meta_nonempty(idx)</span>
    <span class="s0">assert </span><span class="s1">type(res) </span><span class="s0">is </span><span class="s1">pd.MultiIndex</span>
    <span class="s0">for </span><span class="s1">idx1</span><span class="s0">, </span><span class="s1">idx2 </span><span class="s0">in </span><span class="s1">zip(idx.levels</span><span class="s0">, </span><span class="s1">res.levels):</span>
        <span class="s0">assert </span><span class="s1">type(idx1) </span><span class="s0">is </span><span class="s1">type(idx2)</span>
        <span class="s0">assert </span><span class="s1">idx1.name == idx2.name</span>
    <span class="s0">assert </span><span class="s1">res.names == idx.names</span>


<span class="s0">def </span><span class="s1">test_meta_nonempty_uint64index():</span>
    <span class="s1">idx = pd.Index([</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;foo&quot;</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;uint64&quot;</span><span class="s1">)</span>
    <span class="s1">res = meta_nonempty(idx)</span>
    <span class="s0">assert </span><span class="s1">type(res) </span><span class="s0">is </span><span class="s1">type(idx)</span>
    <span class="s0">assert </span><span class="s1">res.dtype == </span><span class="s2">&quot;uint64&quot;</span>
    <span class="s0">assert </span><span class="s1">res.name == idx.name</span>


<span class="s0">def </span><span class="s1">test_meta_nonempty_scalar():</span>
    <span class="s1">meta = meta_nonempty(np.float64(</span><span class="s3">1.0</span><span class="s1">))</span>
    <span class="s0">assert </span><span class="s1">isinstance(meta</span><span class="s0">, </span><span class="s1">np.float64)</span>

    <span class="s1">x = pd.Timestamp(</span><span class="s3">2000</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">meta = meta_nonempty(x)</span>
    <span class="s0">assert </span><span class="s1">meta </span><span class="s0">is </span><span class="s1">x</span>

    <span class="s4"># DatetimeTZDtype</span>
    <span class="s1">x = pd.DatetimeTZDtype(tz=</span><span class="s2">&quot;UTC&quot;</span><span class="s1">)</span>
    <span class="s1">meta = meta_nonempty(x)</span>
    <span class="s0">assert </span><span class="s1">meta == pd.Timestamp(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">tz=x.tz</span><span class="s0">, </span><span class="s1">unit=x.unit)</span>


<span class="s0">def </span><span class="s1">test_raise_on_meta_error():</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">with </span><span class="s1">raise_on_meta_error():</span>
            <span class="s0">raise </span><span class="s1">RuntimeError(</span><span class="s2">&quot;Bad stuff&quot;</span><span class="s1">)</span>
    <span class="s0">except </span><span class="s1">Exception </span><span class="s0">as </span><span class="s1">e:</span>
        <span class="s0">assert </span><span class="s1">e.args[</span><span class="s3">0</span><span class="s1">].startswith(</span><span class="s2">&quot;Metadata inference failed.</span><span class="s0">\n</span><span class="s2">&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s2">&quot;RuntimeError&quot; </span><span class="s0">in </span><span class="s1">e.args[</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">assert False, </span><span class="s2">&quot;should have errored&quot;</span>

    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">with </span><span class="s1">raise_on_meta_error(</span><span class="s2">&quot;myfunc&quot;</span><span class="s1">):</span>
            <span class="s0">raise </span><span class="s1">RuntimeError(</span><span class="s2">&quot;Bad stuff&quot;</span><span class="s1">)</span>
    <span class="s0">except </span><span class="s1">Exception </span><span class="s0">as </span><span class="s1">e:</span>
        <span class="s0">assert </span><span class="s1">e.args[</span><span class="s3">0</span><span class="s1">].startswith(</span><span class="s2">&quot;Metadata inference failed in `myfunc`.</span><span class="s0">\n</span><span class="s2">&quot;</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s2">&quot;RuntimeError&quot; </span><span class="s0">in </span><span class="s1">e.args[</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">assert False, </span><span class="s2">&quot;should have errored&quot;</span>


<span class="s0">def </span><span class="s1">test_check_meta():</span>
    <span class="s1">df = pd.DataFrame(</span>
        <span class="s1">{</span>
            <span class="s2">&quot;a&quot;</span><span class="s1">: [</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s0">, </span><span class="s2">&quot;z&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s2">&quot;b&quot;</span><span class="s1">: [</span><span class="s0">True, False, True</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s2">&quot;c&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2.5</span><span class="s0">, </span><span class="s3">3.5</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s2">&quot;d&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s2">&quot;e&quot;</span><span class="s1">: pd.Categorical([</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s0">, </span><span class="s2">&quot;z&quot;</span><span class="s1">])</span><span class="s0">,</span>
            <span class="s2">&quot;f&quot;</span><span class="s1">: pd.Series([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.uint64)</span><span class="s0">,</span>
        <span class="s1">}</span>
    <span class="s1">)</span>
    <span class="s1">meta = df.iloc[:</span><span class="s3">0</span><span class="s1">]</span>

    <span class="s4"># DataFrame metadata passthrough if correct</span>
    <span class="s0">assert </span><span class="s1">check_meta(df</span><span class="s0">, </span><span class="s1">meta) </span><span class="s0">is </span><span class="s1">df</span>
    <span class="s4"># Series metadata passthrough if correct</span>
    <span class="s1">e = df.e</span>
    <span class="s0">assert </span><span class="s1">check_meta(e</span><span class="s0">, </span><span class="s1">meta.e) </span><span class="s0">is </span><span class="s1">e</span>
    <span class="s4"># numeric_equal means floats and ints are equivalent</span>
    <span class="s1">d = df.d</span>
    <span class="s1">f = df.f</span>
    <span class="s0">assert </span><span class="s1">check_meta(d</span><span class="s0">, </span><span class="s1">meta.d.astype(</span><span class="s2">&quot;f8&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">numeric_equal=</span><span class="s0">True</span><span class="s1">) </span><span class="s0">is </span><span class="s1">d</span>
    <span class="s0">assert </span><span class="s1">check_meta(f</span><span class="s0">, </span><span class="s1">meta.f.astype(</span><span class="s2">&quot;f8&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">numeric_equal=</span><span class="s0">True</span><span class="s1">) </span><span class="s0">is </span><span class="s1">f</span>
    <span class="s0">assert </span><span class="s1">check_meta(f</span><span class="s0">, </span><span class="s1">meta.f.astype(</span><span class="s2">&quot;i8&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">numeric_equal=</span><span class="s0">True</span><span class="s1">) </span><span class="s0">is </span><span class="s1">f</span>

    <span class="s4"># Series metadata error</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError) </span><span class="s0">as </span><span class="s1">err:</span>
        <span class="s1">check_meta(d</span><span class="s0">, </span><span class="s1">meta.d.astype(</span><span class="s2">&quot;f8&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">numeric_equal=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">str(err.value) == (</span>
        <span class="s2">&quot;Metadata mismatch found.</span><span class="s0">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;</span><span class="s0">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;Partition type: `pandas.core.series.Series`</span><span class="s0">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;+----------+---------+</span><span class="s0">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;|          | dtype   |</span><span class="s0">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;+----------+---------+</span><span class="s0">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;| Found    | int64   |</span><span class="s0">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;| Expected | float64 |</span><span class="s0">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;+----------+---------+&quot;</span>
    <span class="s1">)</span>

    <span class="s4"># DataFrame metadata error</span>
    <span class="s1">meta2 = meta.astype({</span><span class="s2">&quot;a&quot;</span><span class="s1">: </span><span class="s2">&quot;category&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s1">: </span><span class="s2">&quot;f8&quot;</span><span class="s1">})[[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s1">]]</span>
    <span class="s1">df2 = df[[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s0">, </span><span class="s2">&quot;e&quot;</span><span class="s1">]]</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError) </span><span class="s0">as </span><span class="s1">err:</span>
        <span class="s1">check_meta(df2</span><span class="s0">, </span><span class="s1">meta2</span><span class="s0">, </span><span class="s1">funcname=</span><span class="s2">&quot;from_delayed&quot;</span><span class="s1">)</span>

    <span class="s1">exp = (</span>
        <span class="s2">&quot;Metadata mismatch found in `from_delayed`.</span><span class="s0">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;</span><span class="s0">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;Partition type: `pandas.core.frame.DataFrame`</span><span class="s0">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;+--------+----------+----------+</span><span class="s0">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;| Column | Found    | Expected |</span><span class="s0">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;+--------+----------+----------+</span><span class="s0">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;| 'a'    | object   | category |</span><span class="s0">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;| 'c'    | -        | float64  |</span><span class="s0">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;| 'e'    | category | -        |</span><span class="s0">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;+--------+----------+----------+&quot;</span>
    <span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">str(err.value) == exp</span>

    <span class="s4"># pandas dtype metadata error</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError) </span><span class="s0">as </span><span class="s1">err:</span>
        <span class="s1">check_meta(df.a</span><span class="s0">, </span><span class="s1">pd.Series([]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;string&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">numeric_equal=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">str(err.value) == (</span>
        <span class="s2">&quot;Metadata mismatch found.</span><span class="s0">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;</span><span class="s0">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;Partition type: `pandas.core.series.Series`</span><span class="s0">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;+----------+--------+</span><span class="s0">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;|          | dtype  |</span><span class="s0">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;+----------+--------+</span><span class="s0">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;| Found    | object |</span><span class="s0">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;| Expected | string |</span><span class="s0">\n</span><span class="s2">&quot;</span>
        <span class="s2">&quot;+----------+--------+&quot;</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_check_matching_columns_raises_appropriate_errors():</span>
    <span class="s1">df = pd.DataFrame(columns=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">])</span>

    <span class="s1">meta = pd.DataFrame(columns=[</span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">])</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;Order of columns does not match&quot;</span><span class="s1">):</span>
        <span class="s0">assert </span><span class="s1">check_matching_columns(meta</span><span class="s0">, </span><span class="s1">df)</span>

    <span class="s1">meta = pd.DataFrame(columns=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s0">, </span><span class="s2">&quot;d&quot;</span><span class="s1">])</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;Missing: </span><span class="s0">\\</span><span class="s2">['d'</span><span class="s0">\\</span><span class="s2">]&quot;</span><span class="s1">):</span>
        <span class="s0">assert </span><span class="s1">check_matching_columns(meta</span><span class="s0">, </span><span class="s1">df)</span>

    <span class="s1">meta = pd.DataFrame(columns=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">])</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;Extra:   </span><span class="s0">\\</span><span class="s2">['c'</span><span class="s0">\\</span><span class="s2">]&quot;</span><span class="s1">):</span>
        <span class="s0">assert </span><span class="s1">check_matching_columns(meta</span><span class="s0">, </span><span class="s1">df)</span>


<span class="s0">def </span><span class="s1">test_check_meta_typename():</span>
    <span class="s1">df = pd.DataFrame({</span><span class="s2">&quot;x&quot;</span><span class="s1">: []})</span>
    <span class="s1">ddf = dd.from_pandas(df</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">check_meta(df</span><span class="s0">, </span><span class="s1">df)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(Exception) </span><span class="s0">as </span><span class="s1">info:</span>
        <span class="s1">check_meta(ddf</span><span class="s0">, </span><span class="s1">df)</span>

    <span class="s0">assert </span><span class="s2">&quot;dask&quot; </span><span class="s0">in </span><span class="s1">str(info.value)</span>
    <span class="s0">assert </span><span class="s2">&quot;pandas&quot; </span><span class="s0">in </span><span class="s1">str(info.value)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;frame_value_counts&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_is_dataframe_like(monkeypatch</span><span class="s0">, </span><span class="s1">frame_value_counts):</span>
    <span class="s4"># When we drop support for pandas 1.0, this compat check can</span>
    <span class="s4"># be dropped</span>
    <span class="s0">if </span><span class="s1">frame_value_counts:</span>
        <span class="s1">monkeypatch.setattr(pd.DataFrame</span><span class="s0">, </span><span class="s2">&quot;value_counts&quot;</span><span class="s0">, lambda </span><span class="s1">x: </span><span class="s0">None, </span><span class="s1">raising=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s1">df = pd.DataFrame({</span><span class="s2">&quot;x&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]})</span>
    <span class="s1">ddf = dd.from_pandas(df</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">1</span><span class="s1">)</span>

    <span class="s0">assert </span><span class="s1">is_dataframe_like(df)</span>
    <span class="s0">assert </span><span class="s1">is_dataframe_like(ddf)</span>
    <span class="s0">assert not </span><span class="s1">is_dataframe_like(df.x)</span>
    <span class="s0">assert not </span><span class="s1">is_dataframe_like(ddf.x)</span>
    <span class="s0">assert not </span><span class="s1">is_dataframe_like(df.index)</span>
    <span class="s0">assert not </span><span class="s1">is_dataframe_like(ddf.index)</span>
    <span class="s0">assert not </span><span class="s1">is_dataframe_like(pd.DataFrame)</span>

    <span class="s0">assert not </span><span class="s1">is_series_like(df)</span>
    <span class="s0">assert not </span><span class="s1">is_series_like(ddf)</span>
    <span class="s0">assert </span><span class="s1">is_series_like(df.x)</span>
    <span class="s0">assert </span><span class="s1">is_series_like(ddf.x)</span>
    <span class="s0">assert not </span><span class="s1">is_series_like(df.index)</span>
    <span class="s0">assert not </span><span class="s1">is_series_like(ddf.index)</span>
    <span class="s0">assert not </span><span class="s1">is_series_like(pd.Series)</span>

    <span class="s0">assert not </span><span class="s1">is_index_like(df)</span>
    <span class="s0">assert not </span><span class="s1">is_index_like(ddf)</span>
    <span class="s0">assert not </span><span class="s1">is_index_like(df.x)</span>
    <span class="s0">assert not </span><span class="s1">is_index_like(ddf.x)</span>
    <span class="s0">assert </span><span class="s1">is_index_like(df.index)</span>
    <span class="s0">assert </span><span class="s1">is_index_like(ddf.index)</span>
    <span class="s0">assert not </span><span class="s1">is_index_like(pd.Index)</span>

    <span class="s4"># The following checks support of class wrappers, which</span>
    <span class="s4"># requires the comparions of `x.__class__` instead of `type(x)`</span>
    <span class="s0">class </span><span class="s1">DataFrameWrapper:</span>
        <span class="s1">__class__ = pd.DataFrame</span>

    <span class="s1">wrap = DataFrameWrapper()</span>
    <span class="s1">wrap.dtypes = </span><span class="s0">None</span>
    <span class="s1">wrap.columns = </span><span class="s0">None</span>
    <span class="s0">assert </span><span class="s1">is_dataframe_like(wrap)</span>

    <span class="s0">class </span><span class="s1">SeriesWrapper:</span>
        <span class="s1">__class__ = pd.Series</span>

    <span class="s1">wrap = SeriesWrapper()</span>
    <span class="s1">wrap.dtype = </span><span class="s0">None</span>
    <span class="s1">wrap.name = </span><span class="s0">None</span>
    <span class="s0">assert </span><span class="s1">is_series_like(wrap)</span>

    <span class="s0">class </span><span class="s1">IndexWrapper:</span>
        <span class="s1">__class__ = pd.Index</span>

    <span class="s1">wrap = IndexWrapper()</span>
    <span class="s1">wrap.dtype = </span><span class="s0">None</span>
    <span class="s1">wrap.name = </span><span class="s0">None</span>
    <span class="s0">assert </span><span class="s1">is_index_like(wrap)</span>


<span class="s0">def </span><span class="s1">test_apply_and_enforce_message():</span>
    <span class="s0">def </span><span class="s1">func():</span>
        <span class="s0">return </span><span class="s1">pd.DataFrame(columns=[</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s0">, </span><span class="s2">&quot;C&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=[</span><span class="s3">0</span><span class="s1">])</span>

    <span class="s1">meta = pd.DataFrame(columns=[</span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s2">&quot;D&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=[</span><span class="s3">0</span><span class="s1">])</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;Extra: *['B', 'C']&quot;</span><span class="s1">):</span>
        <span class="s1">apply_and_enforce(_func=func</span><span class="s0">, </span><span class="s1">_meta=meta)</span>

    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=re.escape(</span><span class="s2">&quot;Missing: ['D']&quot;</span><span class="s1">)):</span>
        <span class="s1">apply_and_enforce(_func=func</span><span class="s0">, </span><span class="s1">_meta=meta)</span>


<span class="s0">def </span><span class="s1">test_nonempty_series_sparse():</span>
    <span class="s1">ser = pd.Series(pd.array([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;Sparse&quot;</span><span class="s1">))</span>
    <span class="s0">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s0">True</span><span class="s1">) </span><span class="s0">as </span><span class="s1">record:</span>
        <span class="s1">meta_nonempty(ser)</span>
    <span class="s0">assert not </span><span class="s1">record</span>


<span class="s0">def </span><span class="s1">test_nonempty_series_nullable_float():</span>
    <span class="s1">ser = pd.Series([]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;Float64&quot;</span><span class="s1">)</span>
    <span class="s1">non_empty = meta_nonempty(ser)</span>
    <span class="s0">assert </span><span class="s1">non_empty.dtype == </span><span class="s2">&quot;Float64&quot;</span>


<span class="s0">def </span><span class="s1">test_assert_eq_sorts():</span>
    <span class="s1">df = pd.DataFrame({</span><span class="s2">&quot;A&quot;</span><span class="s1">: np.linspace(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">10</span><span class="s1">)</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">: np.random.random(</span><span class="s3">10</span><span class="s1">)})</span>
    <span class="s1">df_s = df.sort_values(</span><span class="s2">&quot;B&quot;</span><span class="s1">)</span>
    <span class="s1">assert_eq(df</span><span class="s0">, </span><span class="s1">df_s)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(AssertionError):</span>
        <span class="s1">assert_eq(df</span><span class="s0">, </span><span class="s1">df_s</span><span class="s0">, </span><span class="s1">sort_results=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s1">df_sr = df_s.reset_index(drop=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">assert_eq(df</span><span class="s0">, </span><span class="s1">df_sr</span><span class="s0">, </span><span class="s1">check_index=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(AssertionError):</span>
        <span class="s1">assert_eq(df</span><span class="s0">, </span><span class="s1">df_sr)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(AssertionError):</span>
        <span class="s1">assert_eq(df</span><span class="s0">, </span><span class="s1">df_sr</span><span class="s0">, </span><span class="s1">check_index=</span><span class="s0">False, </span><span class="s1">sort_results=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s1">ddf = dd.from_pandas(df</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">ddf_s = ddf.sort_values([</span><span class="s2">&quot;B&quot;</span><span class="s1">])</span>
    <span class="s1">assert_eq(df</span><span class="s0">, </span><span class="s1">ddf_s)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(AssertionError):</span>
        <span class="s1">assert_eq(df</span><span class="s0">, </span><span class="s1">ddf_s</span><span class="s0">, </span><span class="s1">sort_results=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s1">ddf_sr = ddf_s.reset_index(drop=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">assert_eq(df</span><span class="s0">, </span><span class="s1">ddf_sr</span><span class="s0">, </span><span class="s1">check_index=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(AssertionError):</span>
        <span class="s1">assert_eq(df</span><span class="s0">, </span><span class="s1">ddf_sr</span><span class="s0">, </span><span class="s1">check_index=</span><span class="s0">False, </span><span class="s1">sort_results=</span><span class="s0">False</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_assert_eq_scheduler():</span>
    <span class="s1">using_custom_scheduler = </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">custom_scheduler(*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
        <span class="s0">nonlocal </span><span class="s1">using_custom_scheduler</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">using_custom_scheduler = </span><span class="s0">True</span>
            <span class="s0">return </span><span class="s1">get_sync(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">finally</span><span class="s1">:</span>
            <span class="s1">using_custom_scheduler = </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">check_custom_scheduler(part: pd.DataFrame) -&gt; pd.DataFrame:</span>
        <span class="s0">assert </span><span class="s1">using_custom_scheduler</span><span class="s0">, </span><span class="s2">&quot;not using custom scheduler&quot;</span>
        <span class="s0">return </span><span class="s1">part + </span><span class="s3">1</span>

    <span class="s1">df = pd.DataFrame({</span><span class="s2">&quot;x&quot;</span><span class="s1">: [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">]})</span>
    <span class="s1">ddf = dd.from_pandas(df</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s1">ddf2 = ddf.map_partitions(check_custom_scheduler</span><span class="s0">, </span><span class="s1">meta=ddf)</span>

    <span class="s0">with </span><span class="s1">pytest.raises(AssertionError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;not using custom scheduler&quot;</span><span class="s1">):</span>
        <span class="s4"># NOTE: we compare `ddf2` to itself in order to test both sides of the `assert_eq` logic.</span>
        <span class="s1">assert_eq(ddf2</span><span class="s0">, </span><span class="s1">ddf2)</span>

    <span class="s1">assert_eq(ddf2</span><span class="s0">, </span><span class="s1">ddf2</span><span class="s0">, </span><span class="s1">scheduler=custom_scheduler)</span>
    <span class="s0">with </span><span class="s1">dask.config.set(scheduler=custom_scheduler):</span>
        <span class="s1">assert_eq(ddf2</span><span class="s0">, </span><span class="s1">ddf2</span><span class="s0">, </span><span class="s1">scheduler=</span><span class="s0">None</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;data&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">pd.DataFrame([</span><span class="s3">0</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">pd.Series([</span><span class="s3">0</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">pd.Index([</span><span class="s3">0</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">dd.from_dict({</span><span class="s2">&quot;x&quot;</span><span class="s1">: [</span><span class="s3">0</span><span class="s1">]}</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">dd.from_dict({</span><span class="s2">&quot;x&quot;</span><span class="s1">: [</span><span class="s3">0</span><span class="s1">]}</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">1</span><span class="s1">).x</span><span class="s0">,</span>
        <span class="s1">dd.from_dict({</span><span class="s2">&quot;x&quot;</span><span class="s1">: [</span><span class="s3">0</span><span class="s1">]}</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">1</span><span class="s1">).index</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_meta_constructor_utilities(data):</span>
    <span class="s0">assert </span><span class="s1">meta_series_constructor(data) </span><span class="s0">is </span><span class="s1">pd.Series</span>
    <span class="s0">assert </span><span class="s1">meta_frame_constructor(data) </span><span class="s0">is </span><span class="s1">pd.DataFrame</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;data&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">dd.from_dict({</span><span class="s2">&quot;x&quot;</span><span class="s1">: [</span><span class="s3">0</span><span class="s1">]}</span><span class="s0">, </span><span class="s1">npartitions=</span><span class="s3">1</span><span class="s1">).x.values</span><span class="s0">,</span>
        <span class="s1">np.array([</span><span class="s3">0</span><span class="s1">])</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_meta_constructor_utilities_raise(data):</span>
    <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;not supported by meta_series&quot;</span><span class="s1">):</span>
        <span class="s1">meta_series_constructor(data)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s2">&quot;not supported by meta_frame&quot;</span><span class="s1">):</span>
        <span class="s1">meta_frame_constructor(data)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;divisions, valid&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">([</span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, False</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, False</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">((</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span><span class="s0">, True</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s3">123</span><span class="s0">, False</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">([</span><span class="s3">0</span><span class="s0">, </span><span class="s1">float(</span><span class="s2">&quot;nan&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, False</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_valid_divisions(divisions</span><span class="s0">, </span><span class="s1">valid):</span>
    <span class="s0">assert </span><span class="s1">valid_divisions(divisions) == valid</span>


<span class="s0">def </span><span class="s1">test_pyarrow_strings_enabled():</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">import </span><span class="s1">pyarrow </span><span class="s0">as </span><span class="s1">pa</span>
    <span class="s0">except </span><span class="s1">ImportError:</span>
        <span class="s1">pa = </span><span class="s0">None</span>

    <span class="s4"># If `pandas&gt;=2` and `pyarrow&gt;=12` are installed, then default to using pyarrow strings</span>
    <span class="s0">if </span><span class="s1">(</span>
        <span class="s1">PANDAS_GE_200</span>
        <span class="s0">and </span><span class="s1">pa </span><span class="s0">is not None</span>
        <span class="s0">and </span><span class="s1">Version(pa.__version__) &gt;= Version(</span><span class="s2">&quot;12.0.0&quot;</span><span class="s1">)</span>
    <span class="s1">):</span>
        <span class="s0">assert </span><span class="s1">pyarrow_strings_enabled() </span><span class="s0">is True</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">assert </span><span class="s1">pyarrow_strings_enabled() </span><span class="s0">is False</span>

    <span class="s4"># Regardless of dependencies that are installed, always obey</span>
    <span class="s4"># the `dataframe.convert-string` config value if it's specified</span>
    <span class="s0">with </span><span class="s1">dask.config.set({</span><span class="s2">&quot;dataframe.convert-string&quot;</span><span class="s1">: </span><span class="s0">False</span><span class="s1">}):</span>
        <span class="s0">assert </span><span class="s1">pyarrow_strings_enabled() </span><span class="s0">is False</span>

    <span class="s0">with </span><span class="s1">dask.config.set({</span><span class="s2">&quot;dataframe.convert-string&quot;</span><span class="s1">: </span><span class="s0">True</span><span class="s1">}):</span>
        <span class="s0">assert </span><span class="s1">pyarrow_strings_enabled() </span><span class="s0">is True</span>
</pre>
</body>
</html>