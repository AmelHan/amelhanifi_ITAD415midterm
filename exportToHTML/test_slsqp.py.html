<html>
<head>
<title>test_slsqp.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #6a8759;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_slsqp.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Unit test for SLSQP optimization. 
&quot;&quot;&quot;</span>
<span class="s2">from </span><span class="s1">numpy.testing </span><span class="s2">import </span><span class="s1">(assert_</span><span class="s2">, </span><span class="s1">assert_array_almost_equal</span><span class="s2">,</span>
                           <span class="s1">assert_allclose</span><span class="s2">, </span><span class="s1">assert_equal)</span>
<span class="s2">from </span><span class="s1">pytest </span><span class="s2">import </span><span class="s1">raises </span><span class="s2">as </span><span class="s1">assert_raises</span>
<span class="s2">import </span><span class="s1">pytest</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">from </span><span class="s1">scipy.optimize </span><span class="s2">import </span><span class="s1">fmin_slsqp</span><span class="s2">, </span><span class="s1">minimize</span><span class="s2">, </span><span class="s1">Bounds</span><span class="s2">, </span><span class="s1">NonlinearConstraint</span>


<span class="s2">class </span><span class="s1">MyCallBack:</span>
    <span class="s0">&quot;&quot;&quot;pass a custom callback function 
 
    This makes sure it's being used. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s1">self.been_called = </span><span class="s2">False</span>
        <span class="s1">self.ncalls = </span><span class="s3">0</span>

    <span class="s2">def </span><span class="s1">__call__(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s1">self.been_called = </span><span class="s2">True</span>
        <span class="s1">self.ncalls += </span><span class="s3">1</span>


<span class="s2">class </span><span class="s1">TestSLSQP:</span>
    <span class="s0">&quot;&quot;&quot; 
    Test SLSQP algorithm using Example 14.4 from Numerical Methods for 
    Engineers by Steven Chapra and Raymond Canale. 
    This example maximizes the function f(x) = 2*x*y + 2*x - x**2 - 2*y**2, 
    which has a maximum at x=2, y=1. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.opts = {</span><span class="s4">'disp'</span><span class="s1">: </span><span class="s2">False</span><span class="s1">}</span>

    <span class="s2">def </span><span class="s1">fun(self</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">sign=</span><span class="s3">1.0</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Arguments: 
        d     - A list of two elements, where d[0] represents x and d[1] represents y 
                 in the following equation. 
        sign - A multiplier for f. Since we want to optimize it, and the SciPy 
               optimizers can only minimize functions, we need to multiply it by 
               -1 to achieve the desired solution 
        Returns: 
        2*x*y + 2*x - x**2 - 2*y**2 
 
        &quot;&quot;&quot;</span>
        <span class="s1">x = d[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">y = d[</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s1">sign*(</span><span class="s3">2</span><span class="s1">*x*y + </span><span class="s3">2</span><span class="s1">*x - x**</span><span class="s3">2 </span><span class="s1">- </span><span class="s3">2</span><span class="s1">*y**</span><span class="s3">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">jac(self</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">sign=</span><span class="s3">1.0</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        This is the derivative of fun, returning a NumPy array 
        representing df/dx and df/dy. 
 
        &quot;&quot;&quot;</span>
        <span class="s1">x = d[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">y = d[</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s1">dfdx = sign*(-</span><span class="s3">2</span><span class="s1">*x + </span><span class="s3">2</span><span class="s1">*y + </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">dfdy = sign*(</span><span class="s3">2</span><span class="s1">*x - </span><span class="s3">4</span><span class="s1">*y)</span>
        <span class="s2">return </span><span class="s1">np.array([dfdx</span><span class="s2">, </span><span class="s1">dfdy]</span><span class="s2">, </span><span class="s1">float)</span>

    <span class="s2">def </span><span class="s1">fun_and_jac(self</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">sign=</span><span class="s3">1.0</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s1">self.fun(d</span><span class="s2">, </span><span class="s1">sign)</span><span class="s2">, </span><span class="s1">self.jac(d</span><span class="s2">, </span><span class="s1">sign)</span>

    <span class="s2">def </span><span class="s1">f_eqcon(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">sign=</span><span class="s3">1.0</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; Equality constraint &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">np.array([x[</span><span class="s3">0</span><span class="s1">] - x[</span><span class="s3">1</span><span class="s1">]])</span>

    <span class="s2">def </span><span class="s1">fprime_eqcon(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">sign=</span><span class="s3">1.0</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; Equality constraint, derivative &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">np.array([[</span><span class="s3">1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">]])</span>

    <span class="s2">def </span><span class="s1">f_eqcon_scalar(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">sign=</span><span class="s3">1.0</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; Scalar equality constraint &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.f_eqcon(x</span><span class="s2">, </span><span class="s1">sign)[</span><span class="s3">0</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">fprime_eqcon_scalar(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">sign=</span><span class="s3">1.0</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; Scalar equality constraint, derivative &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self.fprime_eqcon(x</span><span class="s2">, </span><span class="s1">sign)[</span><span class="s3">0</span><span class="s1">].tolist()</span>

    <span class="s2">def </span><span class="s1">f_ieqcon(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">sign=</span><span class="s3">1.0</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; Inequality constraint &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">np.array([x[</span><span class="s3">0</span><span class="s1">] - x[</span><span class="s3">1</span><span class="s1">] - </span><span class="s3">1.0</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">fprime_ieqcon(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">sign=</span><span class="s3">1.0</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; Inequality constraint, derivative &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">np.array([[</span><span class="s3">1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">]])</span>

    <span class="s2">def </span><span class="s1">f_ieqcon2(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s0">&quot;&quot;&quot; Vector inequality constraint &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">np.asarray(x)</span>

    <span class="s2">def </span><span class="s1">fprime_ieqcon2(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s0">&quot;&quot;&quot; Vector inequality constraint, derivative &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">np.identity(x.shape[</span><span class="s3">0</span><span class="s1">])</span>

    <span class="s5"># minimize</span>
    <span class="s2">def </span><span class="s1">test_minimize_unbounded_approximated(self):</span>
        <span class="s5"># Minimize, method='SLSQP': unbounded, approximated jacobian.</span>
        <span class="s1">jacs = [</span><span class="s2">None, False, </span><span class="s4">'2-point'</span><span class="s2">, </span><span class="s4">'3-point'</span><span class="s1">]</span>
        <span class="s2">for </span><span class="s1">jac </span><span class="s2">in </span><span class="s1">jacs:</span>
            <span class="s1">res = minimize(self.fun</span><span class="s2">, </span><span class="s1">[-</span><span class="s3">1.0</span><span class="s2">, </span><span class="s3">1.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">args=(-</span><span class="s3">1.0</span><span class="s2">, </span><span class="s1">)</span><span class="s2">,</span>
                           <span class="s1">jac=jac</span><span class="s2">, </span><span class="s1">method=</span><span class="s4">'SLSQP'</span><span class="s2">,</span>
                           <span class="s1">options=self.opts)</span>
            <span class="s1">assert_(res[</span><span class="s4">'success'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">res[</span><span class="s4">'message'</span><span class="s1">])</span>
            <span class="s1">assert_allclose(res.x</span><span class="s2">, </span><span class="s1">[</span><span class="s3">2</span><span class="s2">, </span><span class="s3">1</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_minimize_unbounded_given(self):</span>
        <span class="s5"># Minimize, method='SLSQP': unbounded, given Jacobian.</span>
        <span class="s1">res = minimize(self.fun</span><span class="s2">, </span><span class="s1">[-</span><span class="s3">1.0</span><span class="s2">, </span><span class="s3">1.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">args=(-</span><span class="s3">1.0</span><span class="s2">, </span><span class="s1">)</span><span class="s2">,</span>
                       <span class="s1">jac=self.jac</span><span class="s2">, </span><span class="s1">method=</span><span class="s4">'SLSQP'</span><span class="s2">, </span><span class="s1">options=self.opts)</span>
        <span class="s1">assert_(res[</span><span class="s4">'success'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">res[</span><span class="s4">'message'</span><span class="s1">])</span>
        <span class="s1">assert_allclose(res.x</span><span class="s2">, </span><span class="s1">[</span><span class="s3">2</span><span class="s2">, </span><span class="s3">1</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_minimize_bounded_approximated(self):</span>
        <span class="s5"># Minimize, method='SLSQP': bounded, approximated jacobian.</span>
        <span class="s1">jacs = [</span><span class="s2">None, False, </span><span class="s4">'2-point'</span><span class="s2">, </span><span class="s4">'3-point'</span><span class="s1">]</span>
        <span class="s2">for </span><span class="s1">jac </span><span class="s2">in </span><span class="s1">jacs:</span>
            <span class="s2">with </span><span class="s1">np.errstate(invalid=</span><span class="s4">'ignore'</span><span class="s1">):</span>
                <span class="s1">res = minimize(self.fun</span><span class="s2">, </span><span class="s1">[-</span><span class="s3">1.0</span><span class="s2">, </span><span class="s3">1.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">args=(-</span><span class="s3">1.0</span><span class="s2">, </span><span class="s1">)</span><span class="s2">,</span>
                               <span class="s1">jac=jac</span><span class="s2">,</span>
                               <span class="s1">bounds=((</span><span class="s3">2.5</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s2">None, </span><span class="s3">0.5</span><span class="s1">))</span><span class="s2">,</span>
                               <span class="s1">method=</span><span class="s4">'SLSQP'</span><span class="s2">, </span><span class="s1">options=self.opts)</span>
            <span class="s1">assert_(res[</span><span class="s4">'success'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">res[</span><span class="s4">'message'</span><span class="s1">])</span>
            <span class="s1">assert_allclose(res.x</span><span class="s2">, </span><span class="s1">[</span><span class="s3">2.5</span><span class="s2">, </span><span class="s3">0.5</span><span class="s1">])</span>
            <span class="s1">assert_(</span><span class="s3">2.5 </span><span class="s1">&lt;= res.x[</span><span class="s3">0</span><span class="s1">])</span>
            <span class="s1">assert_(res.x[</span><span class="s3">1</span><span class="s1">] &lt;= </span><span class="s3">0.5</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_minimize_unbounded_combined(self):</span>
        <span class="s5"># Minimize, method='SLSQP': unbounded, combined function and Jacobian.</span>
        <span class="s1">res = minimize(self.fun_and_jac</span><span class="s2">, </span><span class="s1">[-</span><span class="s3">1.0</span><span class="s2">, </span><span class="s3">1.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">args=(-</span><span class="s3">1.0</span><span class="s2">, </span><span class="s1">)</span><span class="s2">,</span>
                       <span class="s1">jac=</span><span class="s2">True, </span><span class="s1">method=</span><span class="s4">'SLSQP'</span><span class="s2">, </span><span class="s1">options=self.opts)</span>
        <span class="s1">assert_(res[</span><span class="s4">'success'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">res[</span><span class="s4">'message'</span><span class="s1">])</span>
        <span class="s1">assert_allclose(res.x</span><span class="s2">, </span><span class="s1">[</span><span class="s3">2</span><span class="s2">, </span><span class="s3">1</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_minimize_equality_approximated(self):</span>
        <span class="s5"># Minimize with method='SLSQP': equality constraint, approx. jacobian.</span>
        <span class="s1">jacs = [</span><span class="s2">None, False, </span><span class="s4">'2-point'</span><span class="s2">, </span><span class="s4">'3-point'</span><span class="s1">]</span>
        <span class="s2">for </span><span class="s1">jac </span><span class="s2">in </span><span class="s1">jacs:</span>
            <span class="s1">res = minimize(self.fun</span><span class="s2">, </span><span class="s1">[-</span><span class="s3">1.0</span><span class="s2">, </span><span class="s3">1.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">args=(-</span><span class="s3">1.0</span><span class="s2">, </span><span class="s1">)</span><span class="s2">,</span>
                           <span class="s1">jac=jac</span><span class="s2">,</span>
                           <span class="s1">constraints={</span><span class="s4">'type'</span><span class="s1">: </span><span class="s4">'eq'</span><span class="s2">,</span>
                                        <span class="s4">'fun'</span><span class="s1">: self.f_eqcon</span><span class="s2">,</span>
                                        <span class="s4">'args'</span><span class="s1">: (-</span><span class="s3">1.0</span><span class="s2">, </span><span class="s1">)}</span><span class="s2">,</span>
                           <span class="s1">method=</span><span class="s4">'SLSQP'</span><span class="s2">, </span><span class="s1">options=self.opts)</span>
            <span class="s1">assert_(res[</span><span class="s4">'success'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">res[</span><span class="s4">'message'</span><span class="s1">])</span>
            <span class="s1">assert_allclose(res.x</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_minimize_equality_given(self):</span>
        <span class="s5"># Minimize with method='SLSQP': equality constraint, given Jacobian.</span>
        <span class="s1">res = minimize(self.fun</span><span class="s2">, </span><span class="s1">[-</span><span class="s3">1.0</span><span class="s2">, </span><span class="s3">1.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">jac=self.jac</span><span class="s2">,</span>
                       <span class="s1">method=</span><span class="s4">'SLSQP'</span><span class="s2">, </span><span class="s1">args=(-</span><span class="s3">1.0</span><span class="s2">,</span><span class="s1">)</span><span class="s2">,</span>
                       <span class="s1">constraints={</span><span class="s4">'type'</span><span class="s1">: </span><span class="s4">'eq'</span><span class="s2">, </span><span class="s4">'fun'</span><span class="s1">:self.f_eqcon</span><span class="s2">,</span>
                                    <span class="s4">'args'</span><span class="s1">: (-</span><span class="s3">1.0</span><span class="s2">, </span><span class="s1">)}</span><span class="s2">,</span>
                       <span class="s1">options=self.opts)</span>
        <span class="s1">assert_(res[</span><span class="s4">'success'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">res[</span><span class="s4">'message'</span><span class="s1">])</span>
        <span class="s1">assert_allclose(res.x</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_minimize_equality_given2(self):</span>
        <span class="s5"># Minimize with method='SLSQP': equality constraint, given Jacobian</span>
        <span class="s5"># for fun and const.</span>
        <span class="s1">res = minimize(self.fun</span><span class="s2">, </span><span class="s1">[-</span><span class="s3">1.0</span><span class="s2">, </span><span class="s3">1.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">method=</span><span class="s4">'SLSQP'</span><span class="s2">,</span>
                       <span class="s1">jac=self.jac</span><span class="s2">, </span><span class="s1">args=(-</span><span class="s3">1.0</span><span class="s2">,</span><span class="s1">)</span><span class="s2">,</span>
                       <span class="s1">constraints={</span><span class="s4">'type'</span><span class="s1">: </span><span class="s4">'eq'</span><span class="s2">,</span>
                                    <span class="s4">'fun'</span><span class="s1">: self.f_eqcon</span><span class="s2">,</span>
                                    <span class="s4">'args'</span><span class="s1">: (-</span><span class="s3">1.0</span><span class="s2">, </span><span class="s1">)</span><span class="s2">,</span>
                                    <span class="s4">'jac'</span><span class="s1">: self.fprime_eqcon}</span><span class="s2">,</span>
                       <span class="s1">options=self.opts)</span>
        <span class="s1">assert_(res[</span><span class="s4">'success'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">res[</span><span class="s4">'message'</span><span class="s1">])</span>
        <span class="s1">assert_allclose(res.x</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_minimize_equality_given_cons_scalar(self):</span>
        <span class="s5"># Minimize with method='SLSQP': scalar equality constraint, given</span>
        <span class="s5"># Jacobian for fun and const.</span>
        <span class="s1">res = minimize(self.fun</span><span class="s2">, </span><span class="s1">[-</span><span class="s3">1.0</span><span class="s2">, </span><span class="s3">1.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">method=</span><span class="s4">'SLSQP'</span><span class="s2">,</span>
                       <span class="s1">jac=self.jac</span><span class="s2">, </span><span class="s1">args=(-</span><span class="s3">1.0</span><span class="s2">,</span><span class="s1">)</span><span class="s2">,</span>
                       <span class="s1">constraints={</span><span class="s4">'type'</span><span class="s1">: </span><span class="s4">'eq'</span><span class="s2">,</span>
                                    <span class="s4">'fun'</span><span class="s1">: self.f_eqcon_scalar</span><span class="s2">,</span>
                                    <span class="s4">'args'</span><span class="s1">: (-</span><span class="s3">1.0</span><span class="s2">, </span><span class="s1">)</span><span class="s2">,</span>
                                    <span class="s4">'jac'</span><span class="s1">: self.fprime_eqcon_scalar}</span><span class="s2">,</span>
                       <span class="s1">options=self.opts)</span>
        <span class="s1">assert_(res[</span><span class="s4">'success'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">res[</span><span class="s4">'message'</span><span class="s1">])</span>
        <span class="s1">assert_allclose(res.x</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_minimize_inequality_given(self):</span>
        <span class="s5"># Minimize with method='SLSQP': inequality constraint, given Jacobian.</span>
        <span class="s1">res = minimize(self.fun</span><span class="s2">, </span><span class="s1">[-</span><span class="s3">1.0</span><span class="s2">, </span><span class="s3">1.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">method=</span><span class="s4">'SLSQP'</span><span class="s2">,</span>
                       <span class="s1">jac=self.jac</span><span class="s2">, </span><span class="s1">args=(-</span><span class="s3">1.0</span><span class="s2">, </span><span class="s1">)</span><span class="s2">,</span>
                       <span class="s1">constraints={</span><span class="s4">'type'</span><span class="s1">: </span><span class="s4">'ineq'</span><span class="s2">,</span>
                                    <span class="s4">'fun'</span><span class="s1">: self.f_ieqcon</span><span class="s2">,</span>
                                    <span class="s4">'args'</span><span class="s1">: (-</span><span class="s3">1.0</span><span class="s2">, </span><span class="s1">)}</span><span class="s2">,</span>
                       <span class="s1">options=self.opts)</span>
        <span class="s1">assert_(res[</span><span class="s4">'success'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">res[</span><span class="s4">'message'</span><span class="s1">])</span>
        <span class="s1">assert_allclose(res.x</span><span class="s2">, </span><span class="s1">[</span><span class="s3">2</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s3">1e-3</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_minimize_inequality_given_vector_constraints(self):</span>
        <span class="s5"># Minimize with method='SLSQP': vector inequality constraint, given</span>
        <span class="s5"># Jacobian.</span>
        <span class="s1">res = minimize(self.fun</span><span class="s2">, </span><span class="s1">[-</span><span class="s3">1.0</span><span class="s2">, </span><span class="s3">1.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">jac=self.jac</span><span class="s2">,</span>
                       <span class="s1">method=</span><span class="s4">'SLSQP'</span><span class="s2">, </span><span class="s1">args=(-</span><span class="s3">1.0</span><span class="s2">,</span><span class="s1">)</span><span class="s2">,</span>
                       <span class="s1">constraints={</span><span class="s4">'type'</span><span class="s1">: </span><span class="s4">'ineq'</span><span class="s2">,</span>
                                    <span class="s4">'fun'</span><span class="s1">: self.f_ieqcon2</span><span class="s2">,</span>
                                    <span class="s4">'jac'</span><span class="s1">: self.fprime_ieqcon2}</span><span class="s2">,</span>
                       <span class="s1">options=self.opts)</span>
        <span class="s1">assert_(res[</span><span class="s4">'success'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">res[</span><span class="s4">'message'</span><span class="s1">])</span>
        <span class="s1">assert_allclose(res.x</span><span class="s2">, </span><span class="s1">[</span><span class="s3">2</span><span class="s2">, </span><span class="s3">1</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_minimize_bounded_constraint(self):</span>
        <span class="s5"># when the constraint makes the solver go up against a parameter</span>
        <span class="s5"># bound make sure that the numerical differentiation of the</span>
        <span class="s5"># jacobian doesn't try to exceed that bound using a finite difference.</span>
        <span class="s5"># gh11403</span>
        <span class="s2">def </span><span class="s1">c(x):</span>
            <span class="s2">assert </span><span class="s3">0 </span><span class="s1">&lt;= x[</span><span class="s3">0</span><span class="s1">] &lt;= </span><span class="s3">1 </span><span class="s2">and </span><span class="s3">0 </span><span class="s1">&lt;= x[</span><span class="s3">1</span><span class="s1">] &lt;= </span><span class="s3">1</span><span class="s2">, </span><span class="s1">x</span>
            <span class="s2">return </span><span class="s1">x[</span><span class="s3">0</span><span class="s1">] ** </span><span class="s3">0.5 </span><span class="s1">+ x[</span><span class="s3">1</span><span class="s1">]</span>

        <span class="s2">def </span><span class="s1">f(x):</span>
            <span class="s2">assert </span><span class="s3">0 </span><span class="s1">&lt;= x[</span><span class="s3">0</span><span class="s1">] &lt;= </span><span class="s3">1 </span><span class="s2">and </span><span class="s3">0 </span><span class="s1">&lt;= x[</span><span class="s3">1</span><span class="s1">] &lt;= </span><span class="s3">1</span><span class="s2">, </span><span class="s1">x</span>
            <span class="s2">return </span><span class="s1">-x[</span><span class="s3">0</span><span class="s1">] ** </span><span class="s3">2 </span><span class="s1">+ x[</span><span class="s3">1</span><span class="s1">] ** </span><span class="s3">2</span>

        <span class="s1">cns = [NonlinearConstraint(c</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1.5</span><span class="s1">)]</span>
        <span class="s1">x0 = np.asarray([</span><span class="s3">0.9</span><span class="s2">, </span><span class="s3">0.5</span><span class="s1">])</span>
        <span class="s1">bnd = Bounds([</span><span class="s3">0.</span><span class="s2">, </span><span class="s3">0.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1.0</span><span class="s2">, </span><span class="s3">1.0</span><span class="s1">])</span>
        <span class="s1">minimize(f</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">method=</span><span class="s4">'SLSQP'</span><span class="s2">, </span><span class="s1">bounds=bnd</span><span class="s2">, </span><span class="s1">constraints=cns)</span>

    <span class="s2">def </span><span class="s1">test_minimize_bound_equality_given2(self):</span>
        <span class="s5"># Minimize with method='SLSQP': bounds, eq. const., given jac. for</span>
        <span class="s5"># fun. and const.</span>
        <span class="s1">res = minimize(self.fun</span><span class="s2">, </span><span class="s1">[-</span><span class="s3">1.0</span><span class="s2">, </span><span class="s3">1.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">method=</span><span class="s4">'SLSQP'</span><span class="s2">,</span>
                       <span class="s1">jac=self.jac</span><span class="s2">, </span><span class="s1">args=(-</span><span class="s3">1.0</span><span class="s2">, </span><span class="s1">)</span><span class="s2">,</span>
                       <span class="s1">bounds=[(-</span><span class="s3">0.8</span><span class="s2">, </span><span class="s3">1.</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(-</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0.8</span><span class="s1">)]</span><span class="s2">,</span>
                       <span class="s1">constraints={</span><span class="s4">'type'</span><span class="s1">: </span><span class="s4">'eq'</span><span class="s2">,</span>
                                    <span class="s4">'fun'</span><span class="s1">: self.f_eqcon</span><span class="s2">,</span>
                                    <span class="s4">'args'</span><span class="s1">: (-</span><span class="s3">1.0</span><span class="s2">, </span><span class="s1">)</span><span class="s2">,</span>
                                    <span class="s4">'jac'</span><span class="s1">: self.fprime_eqcon}</span><span class="s2">,</span>
                       <span class="s1">options=self.opts)</span>
        <span class="s1">assert_(res[</span><span class="s4">'success'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">res[</span><span class="s4">'message'</span><span class="s1">])</span>
        <span class="s1">assert_allclose(res.x</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0.8</span><span class="s2">, </span><span class="s3">0.8</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s3">1e-3</span><span class="s1">)</span>
        <span class="s1">assert_(-</span><span class="s3">0.8 </span><span class="s1">&lt;= res.x[</span><span class="s3">0</span><span class="s1">] &lt;= </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_(-</span><span class="s3">1 </span><span class="s1">&lt;= res.x[</span><span class="s3">1</span><span class="s1">] &lt;= </span><span class="s3">0.8</span><span class="s1">)</span>

    <span class="s5"># fmin_slsqp</span>
    <span class="s2">def </span><span class="s1">test_unbounded_approximated(self):</span>
        <span class="s5"># SLSQP: unbounded, approximated Jacobian.</span>
        <span class="s1">res = fmin_slsqp(self.fun</span><span class="s2">, </span><span class="s1">[-</span><span class="s3">1.0</span><span class="s2">, </span><span class="s3">1.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">args=(-</span><span class="s3">1.0</span><span class="s2">, </span><span class="s1">)</span><span class="s2">,</span>
                         <span class="s1">iprint = </span><span class="s3">0</span><span class="s2">, </span><span class="s1">full_output = </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">fx</span><span class="s2">, </span><span class="s1">its</span><span class="s2">, </span><span class="s1">imode</span><span class="s2">, </span><span class="s1">smode = res</span>
        <span class="s1">assert_(imode == </span><span class="s3">0</span><span class="s2">, </span><span class="s1">imode)</span>
        <span class="s1">assert_array_almost_equal(x</span><span class="s2">, </span><span class="s1">[</span><span class="s3">2</span><span class="s2">, </span><span class="s3">1</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_unbounded_given(self):</span>
        <span class="s5"># SLSQP: unbounded, given Jacobian.</span>
        <span class="s1">res = fmin_slsqp(self.fun</span><span class="s2">, </span><span class="s1">[-</span><span class="s3">1.0</span><span class="s2">, </span><span class="s3">1.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">args=(-</span><span class="s3">1.0</span><span class="s2">, </span><span class="s1">)</span><span class="s2">,</span>
                         <span class="s1">fprime = self.jac</span><span class="s2">, </span><span class="s1">iprint = </span><span class="s3">0</span><span class="s2">,</span>
                         <span class="s1">full_output = </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">fx</span><span class="s2">, </span><span class="s1">its</span><span class="s2">, </span><span class="s1">imode</span><span class="s2">, </span><span class="s1">smode = res</span>
        <span class="s1">assert_(imode == </span><span class="s3">0</span><span class="s2">, </span><span class="s1">imode)</span>
        <span class="s1">assert_array_almost_equal(x</span><span class="s2">, </span><span class="s1">[</span><span class="s3">2</span><span class="s2">, </span><span class="s3">1</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_equality_approximated(self):</span>
        <span class="s5"># SLSQP: equality constraint, approximated Jacobian.</span>
        <span class="s1">res = fmin_slsqp(self.fun</span><span class="s2">,</span><span class="s1">[-</span><span class="s3">1.0</span><span class="s2">,</span><span class="s3">1.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">args=(-</span><span class="s3">1.0</span><span class="s2">,</span><span class="s1">)</span><span class="s2">,</span>
                         <span class="s1">eqcons = [self.f_eqcon]</span><span class="s2">,</span>
                         <span class="s1">iprint = </span><span class="s3">0</span><span class="s2">, </span><span class="s1">full_output = </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">fx</span><span class="s2">, </span><span class="s1">its</span><span class="s2">, </span><span class="s1">imode</span><span class="s2">, </span><span class="s1">smode = res</span>
        <span class="s1">assert_(imode == </span><span class="s3">0</span><span class="s2">, </span><span class="s1">imode)</span>
        <span class="s1">assert_array_almost_equal(x</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_equality_given(self):</span>
        <span class="s5"># SLSQP: equality constraint, given Jacobian.</span>
        <span class="s1">res = fmin_slsqp(self.fun</span><span class="s2">, </span><span class="s1">[-</span><span class="s3">1.0</span><span class="s2">, </span><span class="s3">1.0</span><span class="s1">]</span><span class="s2">,</span>
                         <span class="s1">fprime=self.jac</span><span class="s2">, </span><span class="s1">args=(-</span><span class="s3">1.0</span><span class="s2">,</span><span class="s1">)</span><span class="s2">,</span>
                         <span class="s1">eqcons = [self.f_eqcon]</span><span class="s2">, </span><span class="s1">iprint = </span><span class="s3">0</span><span class="s2">,</span>
                         <span class="s1">full_output = </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">fx</span><span class="s2">, </span><span class="s1">its</span><span class="s2">, </span><span class="s1">imode</span><span class="s2">, </span><span class="s1">smode = res</span>
        <span class="s1">assert_(imode == </span><span class="s3">0</span><span class="s2">, </span><span class="s1">imode)</span>
        <span class="s1">assert_array_almost_equal(x</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_equality_given2(self):</span>
        <span class="s5"># SLSQP: equality constraint, given Jacobian for fun and const.</span>
        <span class="s1">res = fmin_slsqp(self.fun</span><span class="s2">, </span><span class="s1">[-</span><span class="s3">1.0</span><span class="s2">, </span><span class="s3">1.0</span><span class="s1">]</span><span class="s2">,</span>
                         <span class="s1">fprime=self.jac</span><span class="s2">, </span><span class="s1">args=(-</span><span class="s3">1.0</span><span class="s2">,</span><span class="s1">)</span><span class="s2">,</span>
                         <span class="s1">f_eqcons = self.f_eqcon</span><span class="s2">,</span>
                         <span class="s1">fprime_eqcons = self.fprime_eqcon</span><span class="s2">,</span>
                         <span class="s1">iprint = </span><span class="s3">0</span><span class="s2">,</span>
                         <span class="s1">full_output = </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">fx</span><span class="s2">, </span><span class="s1">its</span><span class="s2">, </span><span class="s1">imode</span><span class="s2">, </span><span class="s1">smode = res</span>
        <span class="s1">assert_(imode == </span><span class="s3">0</span><span class="s2">, </span><span class="s1">imode)</span>
        <span class="s1">assert_array_almost_equal(x</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_inequality_given(self):</span>
        <span class="s5"># SLSQP: inequality constraint, given Jacobian.</span>
        <span class="s1">res = fmin_slsqp(self.fun</span><span class="s2">, </span><span class="s1">[-</span><span class="s3">1.0</span><span class="s2">, </span><span class="s3">1.0</span><span class="s1">]</span><span class="s2">,</span>
                         <span class="s1">fprime=self.jac</span><span class="s2">, </span><span class="s1">args=(-</span><span class="s3">1.0</span><span class="s2">, </span><span class="s1">)</span><span class="s2">,</span>
                         <span class="s1">ieqcons = [self.f_ieqcon]</span><span class="s2">,</span>
                         <span class="s1">iprint = </span><span class="s3">0</span><span class="s2">, </span><span class="s1">full_output = </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">fx</span><span class="s2">, </span><span class="s1">its</span><span class="s2">, </span><span class="s1">imode</span><span class="s2">, </span><span class="s1">smode = res</span>
        <span class="s1">assert_(imode == </span><span class="s3">0</span><span class="s2">, </span><span class="s1">imode)</span>
        <span class="s1">assert_array_almost_equal(x</span><span class="s2">, </span><span class="s1">[</span><span class="s3">2</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s3">3</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bound_equality_given2(self):</span>
        <span class="s5"># SLSQP: bounds, eq. const., given jac. for fun. and const.</span>
        <span class="s1">res = fmin_slsqp(self.fun</span><span class="s2">, </span><span class="s1">[-</span><span class="s3">1.0</span><span class="s2">, </span><span class="s3">1.0</span><span class="s1">]</span><span class="s2">,</span>
                         <span class="s1">fprime=self.jac</span><span class="s2">, </span><span class="s1">args=(-</span><span class="s3">1.0</span><span class="s2">, </span><span class="s1">)</span><span class="s2">,</span>
                         <span class="s1">bounds = [(-</span><span class="s3">0.8</span><span class="s2">, </span><span class="s3">1.</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(-</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0.8</span><span class="s1">)]</span><span class="s2">,</span>
                         <span class="s1">f_eqcons = self.f_eqcon</span><span class="s2">,</span>
                         <span class="s1">fprime_eqcons = self.fprime_eqcon</span><span class="s2">,</span>
                         <span class="s1">iprint = </span><span class="s3">0</span><span class="s2">, </span><span class="s1">full_output = </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">fx</span><span class="s2">, </span><span class="s1">its</span><span class="s2">, </span><span class="s1">imode</span><span class="s2">, </span><span class="s1">smode = res</span>
        <span class="s1">assert_(imode == </span><span class="s3">0</span><span class="s2">, </span><span class="s1">imode)</span>
        <span class="s1">assert_array_almost_equal(x</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0.8</span><span class="s2">, </span><span class="s3">0.8</span><span class="s1">]</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">assert_(-</span><span class="s3">0.8 </span><span class="s1">&lt;= x[</span><span class="s3">0</span><span class="s1">] &lt;= </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_(-</span><span class="s3">1 </span><span class="s1">&lt;= x[</span><span class="s3">1</span><span class="s1">] &lt;= </span><span class="s3">0.8</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_scalar_constraints(self):</span>
        <span class="s5"># Regression test for gh-2182</span>
        <span class="s1">x = fmin_slsqp(</span><span class="s2">lambda </span><span class="s1">z: z**</span><span class="s3">2</span><span class="s2">, </span><span class="s1">[</span><span class="s3">3.</span><span class="s1">]</span><span class="s2">,</span>
                       <span class="s1">ieqcons=[</span><span class="s2">lambda </span><span class="s1">z: z[</span><span class="s3">0</span><span class="s1">] - </span><span class="s3">1</span><span class="s1">]</span><span class="s2">,</span>
                       <span class="s1">iprint=</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(x</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1.</span><span class="s1">])</span>

        <span class="s1">x = fmin_slsqp(</span><span class="s2">lambda </span><span class="s1">z: z**</span><span class="s3">2</span><span class="s2">, </span><span class="s1">[</span><span class="s3">3.</span><span class="s1">]</span><span class="s2">,</span>
                       <span class="s1">f_ieqcons=</span><span class="s2">lambda </span><span class="s1">z: [z[</span><span class="s3">0</span><span class="s1">] - </span><span class="s3">1</span><span class="s1">]</span><span class="s2">,</span>
                       <span class="s1">iprint=</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(x</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1.</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_integer_bounds(self):</span>
        <span class="s5"># This should not raise an exception</span>
        <span class="s1">fmin_slsqp(</span><span class="s2">lambda </span><span class="s1">z: z**</span><span class="s3">2 </span><span class="s1">- </span><span class="s3">1</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">bounds=[[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">iprint=</span><span class="s3">0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_array_bounds(self):</span>
        <span class="s5"># NumPy used to treat n-dimensional 1-element arrays as scalars</span>
        <span class="s5"># in some cases.  The handling of `bounds` by `fmin_slsqp` still</span>
        <span class="s5"># supports this behavior.</span>
        <span class="s1">bounds = [(-np.inf</span><span class="s2">, </span><span class="s1">np.inf)</span><span class="s2">, </span><span class="s1">(np.array([</span><span class="s3">2</span><span class="s1">])</span><span class="s2">, </span><span class="s1">np.array([</span><span class="s3">3</span><span class="s1">]))]</span>
        <span class="s1">x = fmin_slsqp(</span><span class="s2">lambda </span><span class="s1">z: np.sum(z**</span><span class="s3">2 </span><span class="s1">- </span><span class="s3">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">[</span><span class="s3">2.5</span><span class="s2">, </span><span class="s3">2.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">bounds=bounds</span><span class="s2">,</span>
                       <span class="s1">iprint=</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(x</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">2</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_obj_must_return_scalar(self):</span>
        <span class="s5"># Regression test for Github Issue #5433</span>
        <span class="s5"># If objective function does not return a scalar, raises ValueError</span>
        <span class="s2">with </span><span class="s1">assert_raises(ValueError):</span>
            <span class="s1">fmin_slsqp(</span><span class="s2">lambda </span><span class="s1">x: [</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_obj_returns_scalar_in_list(self):</span>
        <span class="s5"># Test for Github Issue #5433 and PR #6691</span>
        <span class="s5"># Objective function should be able to return length-1 Python list</span>
        <span class="s5">#  containing the scalar</span>
        <span class="s1">fmin_slsqp(</span><span class="s2">lambda </span><span class="s1">x: [</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">iprint=</span><span class="s3">0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_callback(self):</span>
        <span class="s5"># Minimize, method='SLSQP': unbounded, approximated jacobian. Check for callback</span>
        <span class="s1">callback = MyCallBack()</span>
        <span class="s1">res = minimize(self.fun</span><span class="s2">, </span><span class="s1">[-</span><span class="s3">1.0</span><span class="s2">, </span><span class="s3">1.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">args=(-</span><span class="s3">1.0</span><span class="s2">, </span><span class="s1">)</span><span class="s2">,</span>
                       <span class="s1">method=</span><span class="s4">'SLSQP'</span><span class="s2">, </span><span class="s1">callback=callback</span><span class="s2">, </span><span class="s1">options=self.opts)</span>
        <span class="s1">assert_(res[</span><span class="s4">'success'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">res[</span><span class="s4">'message'</span><span class="s1">])</span>
        <span class="s1">assert_(callback.been_called)</span>
        <span class="s1">assert_equal(callback.ncalls</span><span class="s2">, </span><span class="s1">res[</span><span class="s4">'nit'</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_inconsistent_linearization(self):</span>
        <span class="s5"># SLSQP must be able to solve this problem, even if the</span>
        <span class="s5"># linearized problem at the starting point is infeasible.</span>

        <span class="s5"># Linearized constraints are</span>
        <span class="s5">#</span>
        <span class="s5">#    2*x0[0]*x[0] &gt;= 1</span>
        <span class="s5">#</span>
        <span class="s5"># At x0 = [0, 1], the second constraint is clearly infeasible.</span>
        <span class="s5"># This triggers a call with n2==1 in the LSQ subroutine.</span>
        <span class="s1">x = [</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]</span>
        <span class="s2">def </span><span class="s1">f1(x):</span>
            <span class="s2">return </span><span class="s1">x[</span><span class="s3">0</span><span class="s1">] + x[</span><span class="s3">1</span><span class="s1">] - </span><span class="s3">2</span>
        <span class="s2">def </span><span class="s1">f2(x):</span>
            <span class="s2">return </span><span class="s1">x[</span><span class="s3">0</span><span class="s1">] ** </span><span class="s3">2 </span><span class="s1">- </span><span class="s3">1</span>
        <span class="s1">sol = minimize(</span>
            <span class="s2">lambda </span><span class="s1">x: x[</span><span class="s3">0</span><span class="s1">]**</span><span class="s3">2 </span><span class="s1">+ x[</span><span class="s3">1</span><span class="s1">]**</span><span class="s3">2</span><span class="s2">,</span>
            <span class="s1">x</span><span class="s2">,</span>
            <span class="s1">constraints=({</span><span class="s4">'type'</span><span class="s1">:</span><span class="s4">'eq'</span><span class="s2">,</span><span class="s4">'fun'</span><span class="s1">: f1}</span><span class="s2">,</span>
                         <span class="s1">{</span><span class="s4">'type'</span><span class="s1">:</span><span class="s4">'ineq'</span><span class="s2">,</span><span class="s4">'fun'</span><span class="s1">: f2})</span><span class="s2">,</span>
            <span class="s1">bounds=((</span><span class="s3">0</span><span class="s2">,None</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">0</span><span class="s2">,None</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">method=</span><span class="s4">'SLSQP'</span><span class="s1">)</span>
        <span class="s1">x = sol.x</span>

        <span class="s1">assert_allclose(f1(x)</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s3">1e-8</span><span class="s1">)</span>
        <span class="s1">assert_(f2(x) &gt;= -</span><span class="s3">1e-8</span><span class="s1">)</span>
        <span class="s1">assert_(sol.success</span><span class="s2">, </span><span class="s1">sol)</span>

    <span class="s2">def </span><span class="s1">test_regression_5743(self):</span>
        <span class="s5"># SLSQP must not indicate success for this problem,</span>
        <span class="s5"># which is infeasible.</span>
        <span class="s1">x = [</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s1">]</span>
        <span class="s1">sol = minimize(</span>
            <span class="s2">lambda </span><span class="s1">x: x[</span><span class="s3">0</span><span class="s1">]**</span><span class="s3">2 </span><span class="s1">+ x[</span><span class="s3">1</span><span class="s1">]**</span><span class="s3">2</span><span class="s2">,</span>
            <span class="s1">x</span><span class="s2">,</span>
            <span class="s1">constraints=({</span><span class="s4">'type'</span><span class="s1">:</span><span class="s4">'eq'</span><span class="s2">,</span><span class="s4">'fun'</span><span class="s1">: </span><span class="s2">lambda </span><span class="s1">x: x[</span><span class="s3">0</span><span class="s1">]+x[</span><span class="s3">1</span><span class="s1">]-</span><span class="s3">1</span><span class="s1">}</span><span class="s2">,</span>
                         <span class="s1">{</span><span class="s4">'type'</span><span class="s1">:</span><span class="s4">'ineq'</span><span class="s2">,</span><span class="s4">'fun'</span><span class="s1">: </span><span class="s2">lambda </span><span class="s1">x: x[</span><span class="s3">0</span><span class="s1">]-</span><span class="s3">2</span><span class="s1">})</span><span class="s2">,</span>
            <span class="s1">bounds=((</span><span class="s3">0</span><span class="s2">,None</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">0</span><span class="s2">,None</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">method=</span><span class="s4">'SLSQP'</span><span class="s1">)</span>
        <span class="s1">assert_(</span><span class="s2">not </span><span class="s1">sol.success</span><span class="s2">, </span><span class="s1">sol)</span>

    <span class="s2">def </span><span class="s1">test_gh_6676(self):</span>
        <span class="s2">def </span><span class="s1">func(x):</span>
            <span class="s2">return </span><span class="s1">(x[</span><span class="s3">0</span><span class="s1">] - </span><span class="s3">1</span><span class="s1">)**</span><span class="s3">2 </span><span class="s1">+ </span><span class="s3">2</span><span class="s1">*(x[</span><span class="s3">1</span><span class="s1">] - </span><span class="s3">1</span><span class="s1">)**</span><span class="s3">2 </span><span class="s1">+ </span><span class="s3">0.5</span><span class="s1">*(x[</span><span class="s3">2</span><span class="s1">] - </span><span class="s3">1</span><span class="s1">)**</span><span class="s3">2</span>

        <span class="s1">sol = minimize(func</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">method=</span><span class="s4">'SLSQP'</span><span class="s1">)</span>
        <span class="s1">assert_(sol.jac.shape == (</span><span class="s3">3</span><span class="s2">,</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_invalid_bounds(self):</span>
        <span class="s5"># Raise correct error when lower bound is greater than upper bound.</span>
        <span class="s5"># See Github issue 6875.</span>
        <span class="s1">bounds_list = [</span>
            <span class="s1">((</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">2</span><span class="s2">, </span><span class="s3">1</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">((</span><span class="s3">2</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">((</span><span class="s3">2</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">2</span><span class="s2">, </span><span class="s3">1</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">((np.inf</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(np.inf</span><span class="s2">, </span><span class="s3">0</span><span class="s1">))</span><span class="s2">,</span>
            <span class="s1">((</span><span class="s3">1</span><span class="s2">, </span><span class="s1">-np.inf)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s1">))</span><span class="s2">,</span>
        <span class="s1">]</span>
        <span class="s2">for </span><span class="s1">bounds </span><span class="s2">in </span><span class="s1">bounds_list:</span>
            <span class="s2">with </span><span class="s1">assert_raises(ValueError):</span>
                <span class="s1">minimize(self.fun</span><span class="s2">, </span><span class="s1">[-</span><span class="s3">1.0</span><span class="s2">, </span><span class="s3">1.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">bounds=bounds</span><span class="s2">, </span><span class="s1">method=</span><span class="s4">'SLSQP'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bounds_clipping(self):</span>
        <span class="s5">#</span>
        <span class="s5"># SLSQP returns bogus results for initial guess out of bounds, gh-6859</span>
        <span class="s5">#</span>
        <span class="s2">def </span><span class="s1">f(x):</span>
            <span class="s2">return </span><span class="s1">(x[</span><span class="s3">0</span><span class="s1">] - </span><span class="s3">1</span><span class="s1">)**</span><span class="s3">2</span>

        <span class="s1">sol = minimize(f</span><span class="s2">, </span><span class="s1">[</span><span class="s3">10</span><span class="s1">]</span><span class="s2">, </span><span class="s1">method=</span><span class="s4">'slsqp'</span><span class="s2">, </span><span class="s1">bounds=[(</span><span class="s2">None, </span><span class="s3">0</span><span class="s1">)])</span>
        <span class="s1">assert_(sol.success)</span>
        <span class="s1">assert_allclose(sol.x</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s3">1e-10</span><span class="s1">)</span>

        <span class="s1">sol = minimize(f</span><span class="s2">, </span><span class="s1">[-</span><span class="s3">10</span><span class="s1">]</span><span class="s2">, </span><span class="s1">method=</span><span class="s4">'slsqp'</span><span class="s2">, </span><span class="s1">bounds=[(</span><span class="s3">2</span><span class="s2">, None</span><span class="s1">)])</span>
        <span class="s1">assert_(sol.success)</span>
        <span class="s1">assert_allclose(sol.x</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s1">atol=</span><span class="s3">1e-10</span><span class="s1">)</span>

        <span class="s1">sol = minimize(f</span><span class="s2">, </span><span class="s1">[-</span><span class="s3">10</span><span class="s1">]</span><span class="s2">, </span><span class="s1">method=</span><span class="s4">'slsqp'</span><span class="s2">, </span><span class="s1">bounds=[(</span><span class="s2">None, </span><span class="s3">0</span><span class="s1">)])</span>
        <span class="s1">assert_(sol.success)</span>
        <span class="s1">assert_allclose(sol.x</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s3">1e-10</span><span class="s1">)</span>

        <span class="s1">sol = minimize(f</span><span class="s2">, </span><span class="s1">[</span><span class="s3">10</span><span class="s1">]</span><span class="s2">, </span><span class="s1">method=</span><span class="s4">'slsqp'</span><span class="s2">, </span><span class="s1">bounds=[(</span><span class="s3">2</span><span class="s2">, None</span><span class="s1">)])</span>
        <span class="s1">assert_(sol.success)</span>
        <span class="s1">assert_allclose(sol.x</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s1">atol=</span><span class="s3">1e-10</span><span class="s1">)</span>

        <span class="s1">sol = minimize(f</span><span class="s2">, </span><span class="s1">[-</span><span class="s3">0.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">method=</span><span class="s4">'slsqp'</span><span class="s2">, </span><span class="s1">bounds=[(-</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)])</span>
        <span class="s1">assert_(sol.success)</span>
        <span class="s1">assert_allclose(sol.x</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s3">1e-10</span><span class="s1">)</span>

        <span class="s1">sol = minimize(f</span><span class="s2">, </span><span class="s1">[</span><span class="s3">10</span><span class="s1">]</span><span class="s2">, </span><span class="s1">method=</span><span class="s4">'slsqp'</span><span class="s2">, </span><span class="s1">bounds=[(-</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)])</span>
        <span class="s1">assert_(sol.success)</span>
        <span class="s1">assert_allclose(sol.x</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s3">1e-10</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_infeasible_initial(self):</span>
        <span class="s5"># Check SLSQP behavior with infeasible initial point</span>
        <span class="s2">def </span><span class="s1">f(x):</span>
            <span class="s1">x</span><span class="s2">, </span><span class="s1">= x</span>
            <span class="s2">return </span><span class="s1">x*x - </span><span class="s3">2</span><span class="s1">*x + </span><span class="s3">1</span>

        <span class="s1">cons_u = [{</span><span class="s4">'type'</span><span class="s1">: </span><span class="s4">'ineq'</span><span class="s2">, </span><span class="s4">'fun'</span><span class="s1">: </span><span class="s2">lambda </span><span class="s1">x: </span><span class="s3">0 </span><span class="s1">- x}]</span>
        <span class="s1">cons_l = [{</span><span class="s4">'type'</span><span class="s1">: </span><span class="s4">'ineq'</span><span class="s2">, </span><span class="s4">'fun'</span><span class="s1">: </span><span class="s2">lambda </span><span class="s1">x: x - </span><span class="s3">2</span><span class="s1">}]</span>
        <span class="s1">cons_ul = [{</span><span class="s4">'type'</span><span class="s1">: </span><span class="s4">'ineq'</span><span class="s2">, </span><span class="s4">'fun'</span><span class="s1">: </span><span class="s2">lambda </span><span class="s1">x: </span><span class="s3">0 </span><span class="s1">- x}</span><span class="s2">,</span>
                   <span class="s1">{</span><span class="s4">'type'</span><span class="s1">: </span><span class="s4">'ineq'</span><span class="s2">, </span><span class="s4">'fun'</span><span class="s1">: </span><span class="s2">lambda </span><span class="s1">x: x + </span><span class="s3">1</span><span class="s1">}]</span>

        <span class="s1">sol = minimize(f</span><span class="s2">, </span><span class="s1">[</span><span class="s3">10</span><span class="s1">]</span><span class="s2">, </span><span class="s1">method=</span><span class="s4">'slsqp'</span><span class="s2">, </span><span class="s1">constraints=cons_u)</span>
        <span class="s1">assert_(sol.success)</span>
        <span class="s1">assert_allclose(sol.x</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s3">1e-10</span><span class="s1">)</span>

        <span class="s1">sol = minimize(f</span><span class="s2">, </span><span class="s1">[-</span><span class="s3">10</span><span class="s1">]</span><span class="s2">, </span><span class="s1">method=</span><span class="s4">'slsqp'</span><span class="s2">, </span><span class="s1">constraints=cons_l)</span>
        <span class="s1">assert_(sol.success)</span>
        <span class="s1">assert_allclose(sol.x</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s1">atol=</span><span class="s3">1e-10</span><span class="s1">)</span>

        <span class="s1">sol = minimize(f</span><span class="s2">, </span><span class="s1">[-</span><span class="s3">10</span><span class="s1">]</span><span class="s2">, </span><span class="s1">method=</span><span class="s4">'slsqp'</span><span class="s2">, </span><span class="s1">constraints=cons_u)</span>
        <span class="s1">assert_(sol.success)</span>
        <span class="s1">assert_allclose(sol.x</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s3">1e-10</span><span class="s1">)</span>

        <span class="s1">sol = minimize(f</span><span class="s2">, </span><span class="s1">[</span><span class="s3">10</span><span class="s1">]</span><span class="s2">, </span><span class="s1">method=</span><span class="s4">'slsqp'</span><span class="s2">, </span><span class="s1">constraints=cons_l)</span>
        <span class="s1">assert_(sol.success)</span>
        <span class="s1">assert_allclose(sol.x</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s1">atol=</span><span class="s3">1e-10</span><span class="s1">)</span>

        <span class="s1">sol = minimize(f</span><span class="s2">, </span><span class="s1">[-</span><span class="s3">0.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">method=</span><span class="s4">'slsqp'</span><span class="s2">, </span><span class="s1">constraints=cons_ul)</span>
        <span class="s1">assert_(sol.success)</span>
        <span class="s1">assert_allclose(sol.x</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s3">1e-10</span><span class="s1">)</span>

        <span class="s1">sol = minimize(f</span><span class="s2">, </span><span class="s1">[</span><span class="s3">10</span><span class="s1">]</span><span class="s2">, </span><span class="s1">method=</span><span class="s4">'slsqp'</span><span class="s2">, </span><span class="s1">constraints=cons_ul)</span>
        <span class="s1">assert_(sol.success)</span>
        <span class="s1">assert_allclose(sol.x</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s3">1e-10</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_inconsistent_inequalities(self):</span>
        <span class="s5"># gh-7618</span>

        <span class="s2">def </span><span class="s1">cost(x):</span>
            <span class="s2">return </span><span class="s1">-</span><span class="s3">1 </span><span class="s1">* x[</span><span class="s3">0</span><span class="s1">] + </span><span class="s3">4 </span><span class="s1">* x[</span><span class="s3">1</span><span class="s1">]</span>

        <span class="s2">def </span><span class="s1">ineqcons1(x):</span>
            <span class="s2">return </span><span class="s1">x[</span><span class="s3">1</span><span class="s1">] - x[</span><span class="s3">0</span><span class="s1">] - </span><span class="s3">1</span>

        <span class="s2">def </span><span class="s1">ineqcons2(x):</span>
            <span class="s2">return </span><span class="s1">x[</span><span class="s3">0</span><span class="s1">] - x[</span><span class="s3">1</span><span class="s1">]</span>

        <span class="s5"># The inequalities are inconsistent, so no solution can exist:</span>
        <span class="s5">#</span>
        <span class="s5"># x1 &gt;= x0 + 1</span>
        <span class="s5"># x0 &gt;= x1</span>

        <span class="s1">x0 = (</span><span class="s3">1</span><span class="s2">,</span><span class="s3">5</span><span class="s1">)</span>
        <span class="s1">bounds = ((-</span><span class="s3">5</span><span class="s2">, </span><span class="s3">5</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(-</span><span class="s3">5</span><span class="s2">, </span><span class="s3">5</span><span class="s1">))</span>
        <span class="s1">cons = (dict(type=</span><span class="s4">'ineq'</span><span class="s2">, </span><span class="s1">fun=ineqcons1)</span><span class="s2">, </span><span class="s1">dict(type=</span><span class="s4">'ineq'</span><span class="s2">, </span><span class="s1">fun=ineqcons2))</span>
        <span class="s1">res = minimize(cost</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">method=</span><span class="s4">'SLSQP'</span><span class="s2">, </span><span class="s1">bounds=bounds</span><span class="s2">, </span><span class="s1">constraints=cons)</span>

        <span class="s1">assert_(</span><span class="s2">not </span><span class="s1">res.success)</span>

    <span class="s2">def </span><span class="s1">test_new_bounds_type(self):</span>
        <span class="s2">def </span><span class="s1">f(x):</span>
            <span class="s2">return </span><span class="s1">x[</span><span class="s3">0</span><span class="s1">] ** </span><span class="s3">2 </span><span class="s1">+ x[</span><span class="s3">1</span><span class="s1">] ** </span><span class="s3">2</span>
        <span class="s1">bounds = Bounds([</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[np.inf</span><span class="s2">, </span><span class="s1">np.inf])</span>
        <span class="s1">sol = minimize(f</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">method=</span><span class="s4">'slsqp'</span><span class="s2">, </span><span class="s1">bounds=bounds)</span>
        <span class="s1">assert_(sol.success)</span>
        <span class="s1">assert_allclose(sol.x</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_nested_minimization(self):</span>

        <span class="s2">class </span><span class="s1">NestedProblem():</span>

            <span class="s2">def </span><span class="s1">__init__(self):</span>
                <span class="s1">self.F_outer_count = </span><span class="s3">0</span>

            <span class="s2">def </span><span class="s1">F_outer(self</span><span class="s2">, </span><span class="s1">x):</span>
                <span class="s1">self.F_outer_count += </span><span class="s3">1</span>
                <span class="s2">if </span><span class="s1">self.F_outer_count &gt; </span><span class="s3">1000</span><span class="s1">:</span>
                    <span class="s2">raise </span><span class="s1">Exception(</span><span class="s4">&quot;Nested minimization failed to terminate.&quot;</span><span class="s1">)</span>
                <span class="s1">inner_res = minimize(self.F_inner</span><span class="s2">, </span><span class="s1">(</span><span class="s3">3</span><span class="s2">, </span><span class="s3">4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">method=</span><span class="s4">&quot;SLSQP&quot;</span><span class="s1">)</span>
                <span class="s1">assert_(inner_res.success)</span>
                <span class="s1">assert_allclose(inner_res.x</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s1">])</span>
                <span class="s2">return </span><span class="s1">x[</span><span class="s3">0</span><span class="s1">]**</span><span class="s3">2 </span><span class="s1">+ x[</span><span class="s3">1</span><span class="s1">]**</span><span class="s3">2 </span><span class="s1">+ x[</span><span class="s3">2</span><span class="s1">]**</span><span class="s3">2</span>

            <span class="s2">def </span><span class="s1">F_inner(self</span><span class="s2">, </span><span class="s1">x):</span>
                <span class="s2">return </span><span class="s1">(x[</span><span class="s3">0</span><span class="s1">] - </span><span class="s3">1</span><span class="s1">)**</span><span class="s3">2 </span><span class="s1">+ (x[</span><span class="s3">1</span><span class="s1">] - </span><span class="s3">1</span><span class="s1">)**</span><span class="s3">2</span>

            <span class="s2">def </span><span class="s1">solve(self):</span>
                <span class="s1">outer_res = minimize(self.F_outer</span><span class="s2">, </span><span class="s1">(</span><span class="s3">5</span><span class="s2">, </span><span class="s3">5</span><span class="s2">, </span><span class="s3">5</span><span class="s1">)</span><span class="s2">, </span><span class="s1">method=</span><span class="s4">&quot;SLSQP&quot;</span><span class="s1">)</span>
                <span class="s1">assert_(outer_res.success)</span>
                <span class="s1">assert_allclose(outer_res.x</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">])</span>

        <span class="s1">problem = NestedProblem()</span>
        <span class="s1">problem.solve()</span>

    <span class="s2">def </span><span class="s1">test_gh1758(self):</span>
        <span class="s5"># the test suggested in gh1758</span>
        <span class="s5"># https://nlopt.readthedocs.io/en/latest/NLopt_Tutorial/</span>
        <span class="s5"># implement two equality constraints, in R^2.</span>
        <span class="s2">def </span><span class="s1">fun(x):</span>
            <span class="s2">return </span><span class="s1">np.sqrt(x[</span><span class="s3">1</span><span class="s1">])</span>

        <span class="s2">def </span><span class="s1">f_eqcon(x):</span>
            <span class="s0">&quot;&quot;&quot; Equality constraint &quot;&quot;&quot;</span>
            <span class="s2">return </span><span class="s1">x[</span><span class="s3">1</span><span class="s1">] - (</span><span class="s3">2 </span><span class="s1">* x[</span><span class="s3">0</span><span class="s1">]) ** </span><span class="s3">3</span>

        <span class="s2">def </span><span class="s1">f_eqcon2(x):</span>
            <span class="s0">&quot;&quot;&quot; Equality constraint &quot;&quot;&quot;</span>
            <span class="s2">return </span><span class="s1">x[</span><span class="s3">1</span><span class="s1">] - (-x[</span><span class="s3">0</span><span class="s1">] + </span><span class="s3">1</span><span class="s1">) ** </span><span class="s3">3</span>

        <span class="s1">c1 = {</span><span class="s4">'type'</span><span class="s1">: </span><span class="s4">'eq'</span><span class="s2">, </span><span class="s4">'fun'</span><span class="s1">: f_eqcon}</span>
        <span class="s1">c2 = {</span><span class="s4">'type'</span><span class="s1">: </span><span class="s4">'eq'</span><span class="s2">, </span><span class="s4">'fun'</span><span class="s1">: f_eqcon2}</span>

        <span class="s1">res = minimize(fun</span><span class="s2">, </span><span class="s1">[</span><span class="s3">8</span><span class="s2">, </span><span class="s3">0.25</span><span class="s1">]</span><span class="s2">, </span><span class="s1">method=</span><span class="s4">'SLSQP'</span><span class="s2">,</span>
                       <span class="s1">constraints=[c1</span><span class="s2">, </span><span class="s1">c2]</span><span class="s2">, </span><span class="s1">bounds=[(-</span><span class="s3">0.5</span><span class="s2">, </span><span class="s3">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">8</span><span class="s1">)])</span>

        <span class="s1">np.testing.assert_allclose(res.fun</span><span class="s2">, </span><span class="s3">0.5443310539518</span><span class="s1">)</span>
        <span class="s1">np.testing.assert_allclose(res.x</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0.33333333</span><span class="s2">, </span><span class="s3">0.2962963</span><span class="s1">])</span>
        <span class="s2">assert </span><span class="s1">res.success</span>

    <span class="s2">def </span><span class="s1">test_gh9640(self):</span>
        <span class="s1">np.random.seed(</span><span class="s3">10</span><span class="s1">)</span>
        <span class="s1">cons = ({</span><span class="s4">'type'</span><span class="s1">: </span><span class="s4">'ineq'</span><span class="s2">, </span><span class="s4">'fun'</span><span class="s1">: </span><span class="s2">lambda </span><span class="s1">x: -x[</span><span class="s3">0</span><span class="s1">] - x[</span><span class="s3">1</span><span class="s1">] - </span><span class="s3">3</span><span class="s1">}</span><span class="s2">,</span>
                <span class="s1">{</span><span class="s4">'type'</span><span class="s1">: </span><span class="s4">'ineq'</span><span class="s2">, </span><span class="s4">'fun'</span><span class="s1">: </span><span class="s2">lambda </span><span class="s1">x: x[</span><span class="s3">1</span><span class="s1">] + x[</span><span class="s3">2</span><span class="s1">] - </span><span class="s3">2</span><span class="s1">})</span>
        <span class="s1">bnds = ((-</span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(-</span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(-</span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s1">))</span>

        <span class="s2">def </span><span class="s1">target(x):</span>
            <span class="s2">return </span><span class="s3">1</span>
        <span class="s1">x0 = [-</span><span class="s3">1.8869783504471584</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.640096352696244</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.8174212253407696</span><span class="s1">]</span>
        <span class="s1">res = minimize(target</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">method=</span><span class="s4">'SLSQP'</span><span class="s2">, </span><span class="s1">bounds=bnds</span><span class="s2">, </span><span class="s1">constraints=cons</span><span class="s2">,</span>
                       <span class="s1">options={</span><span class="s4">'disp'</span><span class="s1">:</span><span class="s2">False, </span><span class="s4">'maxiter'</span><span class="s1">:</span><span class="s3">10000</span><span class="s1">})</span>

        <span class="s5"># The problem is infeasible, so it cannot succeed</span>
        <span class="s2">assert not </span><span class="s1">res.success</span>

    <span class="s2">def </span><span class="s1">test_parameters_stay_within_bounds(self):</span>
        <span class="s5"># gh11403. For some problems the SLSQP Fortran code suggests a step</span>
        <span class="s5"># outside one of the lower/upper bounds. When this happens</span>
        <span class="s5"># approx_derivative complains because it's being asked to evaluate</span>
        <span class="s5"># a gradient outside its domain.</span>
        <span class="s1">np.random.seed(</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">bounds = Bounds(np.array([</span><span class="s3">0.1</span><span class="s1">])</span><span class="s2">, </span><span class="s1">np.array([</span><span class="s3">1.0</span><span class="s1">]))</span>
        <span class="s1">n_inputs = len(bounds.lb)</span>
        <span class="s1">x0 = np.array(bounds.lb + (bounds.ub - bounds.lb) *</span>
                      <span class="s1">np.random.random(n_inputs))</span>

        <span class="s2">def </span><span class="s1">f(x):</span>
            <span class="s2">assert </span><span class="s1">(x &gt;= bounds.lb).all()</span>
            <span class="s2">return </span><span class="s1">np.linalg.norm(x)</span>

        <span class="s2">with </span><span class="s1">pytest.warns(RuntimeWarning</span><span class="s2">, </span><span class="s1">match=</span><span class="s4">'x were outside bounds'</span><span class="s1">):</span>
            <span class="s1">res = minimize(f</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">method=</span><span class="s4">'SLSQP'</span><span class="s2">, </span><span class="s1">bounds=bounds)</span>
            <span class="s2">assert </span><span class="s1">res.success</span>
</pre>
</body>
</html>