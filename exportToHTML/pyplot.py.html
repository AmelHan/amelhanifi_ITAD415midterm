<html>
<head>
<title>pyplot.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
pyplot.py</font>
</center></td></tr></table>
<pre><span class="s0"># Note: The first part of this file can be modified in place, but the latter</span>
<span class="s0"># part is autogenerated by the boilerplate.py script.</span>

<span class="s2">&quot;&quot;&quot; 
`matplotlib.pyplot` is a state-based interface to matplotlib. It provides 
an implicit,  MATLAB-like, way of plotting.  It also opens figures on your 
screen, and acts as the figure GUI manager. 
 
pyplot is mainly intended for interactive plots and simple cases of 
programmatic plot generation:: 
 
    import numpy as np 
    import matplotlib.pyplot as plt 
 
    x = np.arange(0, 5, 0.1) 
    y = np.sin(x) 
    plt.plot(x, y) 
 
The explicit object-oriented API is recommended for complex plots, though 
pyplot is still usually used to create the figure and often the axes in the 
figure. See `.pyplot.figure`, `.pyplot.subplots`, and 
`.pyplot.subplot_mosaic` to create figures, and 
:doc:`Axes API &lt;/api/axes_api&gt;` for the plotting methods on an Axes:: 
 
    import numpy as np 
    import matplotlib.pyplot as plt 
 
    x = np.arange(0, 5, 0.1) 
    y = np.sin(x) 
    fig, ax = plt.subplots() 
    ax.plot(x, y) 
 
 
See :ref:`api_interfaces` for an explanation of the tradeoffs between the 
implicit and explicit interfaces. 
&quot;&quot;&quot;</span>

<span class="s0"># fmt: off</span>

<span class="s3">from </span><span class="s1">__future__ </span><span class="s3">import </span><span class="s1">annotations</span>

<span class="s3">from </span><span class="s1">contextlib </span><span class="s3">import </span><span class="s1">AbstractContextManager</span><span class="s3">, </span><span class="s1">ExitStack</span>
<span class="s3">from </span><span class="s1">enum </span><span class="s3">import </span><span class="s1">Enum</span>
<span class="s3">import </span><span class="s1">functools</span>
<span class="s3">import </span><span class="s1">importlib</span>
<span class="s3">import </span><span class="s1">inspect</span>
<span class="s3">import </span><span class="s1">logging</span>
<span class="s3">import </span><span class="s1">re</span>
<span class="s3">import </span><span class="s1">sys</span>
<span class="s3">import </span><span class="s1">threading</span>
<span class="s3">import </span><span class="s1">time</span>
<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">cast</span><span class="s3">, </span><span class="s1">overload</span>

<span class="s3">from </span><span class="s1">cycler </span><span class="s3">import </span><span class="s1">cycler</span>
<span class="s3">import </span><span class="s1">matplotlib</span>
<span class="s3">import </span><span class="s1">matplotlib.colorbar</span>
<span class="s3">import </span><span class="s1">matplotlib.image</span>
<span class="s3">from </span><span class="s1">matplotlib </span><span class="s3">import </span><span class="s1">_api</span>
<span class="s3">from </span><span class="s1">matplotlib </span><span class="s3">import </span><span class="s1">(  </span><span class="s0"># Re-exported for typing.</span>
    <span class="s1">cm </span><span class="s3">as </span><span class="s1">cm</span><span class="s3">, </span><span class="s1">get_backend </span><span class="s3">as </span><span class="s1">get_backend</span><span class="s3">, </span><span class="s1">rcParams </span><span class="s3">as </span><span class="s1">rcParams</span><span class="s3">, </span><span class="s1">style </span><span class="s3">as </span><span class="s1">style)</span>
<span class="s3">from </span><span class="s1">matplotlib </span><span class="s3">import </span><span class="s1">_pylab_helpers</span><span class="s3">, </span><span class="s1">interactive</span>
<span class="s3">from </span><span class="s1">matplotlib </span><span class="s3">import </span><span class="s1">cbook</span>
<span class="s3">from </span><span class="s1">matplotlib </span><span class="s3">import </span><span class="s1">_docstring</span>
<span class="s3">from </span><span class="s1">matplotlib.backend_bases </span><span class="s3">import </span><span class="s1">(</span>
    <span class="s1">FigureCanvasBase</span><span class="s3">, </span><span class="s1">FigureManagerBase</span><span class="s3">, </span><span class="s1">MouseButton)</span>
<span class="s3">from </span><span class="s1">matplotlib.figure </span><span class="s3">import </span><span class="s1">Figure</span><span class="s3">, </span><span class="s1">FigureBase</span><span class="s3">, </span><span class="s1">figaspect</span>
<span class="s3">from </span><span class="s1">matplotlib.gridspec </span><span class="s3">import </span><span class="s1">GridSpec</span><span class="s3">, </span><span class="s1">SubplotSpec</span>
<span class="s3">from </span><span class="s1">matplotlib </span><span class="s3">import </span><span class="s1">rcsetup</span><span class="s3">, </span><span class="s1">rcParamsDefault</span><span class="s3">, </span><span class="s1">rcParamsOrig</span>
<span class="s3">from </span><span class="s1">matplotlib.artist </span><span class="s3">import </span><span class="s1">Artist</span>
<span class="s3">from </span><span class="s1">matplotlib.axes </span><span class="s3">import </span><span class="s1">Axes</span><span class="s3">, </span><span class="s1">Subplot  </span><span class="s0"># type: ignore</span>
<span class="s3">from </span><span class="s1">matplotlib.projections </span><span class="s3">import </span><span class="s1">PolarAxes  </span><span class="s0"># type: ignore</span>
<span class="s3">from </span><span class="s1">matplotlib </span><span class="s3">import </span><span class="s1">mlab  </span><span class="s0"># for detrend_none, window_hanning</span>
<span class="s3">from </span><span class="s1">matplotlib.scale </span><span class="s3">import </span><span class="s1">get_scale_names</span>

<span class="s3">from </span><span class="s1">matplotlib.cm </span><span class="s3">import </span><span class="s1">_colormaps</span>
<span class="s3">from </span><span class="s1">matplotlib.cm </span><span class="s3">import </span><span class="s1">register_cmap  </span><span class="s0"># type: ignore</span>
<span class="s3">from </span><span class="s1">matplotlib.colors </span><span class="s3">import </span><span class="s1">_color_sequences</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>

<span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">TYPE_CHECKING</span><span class="s3">, </span><span class="s1">cast</span>

<span class="s3">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s3">from </span><span class="s1">collections.abc </span><span class="s3">import </span><span class="s1">Callable</span><span class="s3">, </span><span class="s1">Hashable</span><span class="s3">, </span><span class="s1">Iterable</span><span class="s3">, </span><span class="s1">Sequence</span>
    <span class="s3">import </span><span class="s1">datetime</span>
    <span class="s3">import </span><span class="s1">pathlib</span>
    <span class="s3">import </span><span class="s1">os</span>
    <span class="s3">from </span><span class="s1">typing </span><span class="s3">import </span><span class="s1">Any</span><span class="s3">, </span><span class="s1">BinaryIO</span><span class="s3">, </span><span class="s1">Literal</span><span class="s3">, </span><span class="s1">TypeVar</span>
    <span class="s3">from </span><span class="s1">typing_extensions </span><span class="s3">import </span><span class="s1">ParamSpec</span>

    <span class="s3">import </span><span class="s1">PIL.Image</span>
    <span class="s3">from </span><span class="s1">numpy.typing </span><span class="s3">import </span><span class="s1">ArrayLike</span>

    <span class="s3">from </span><span class="s1">matplotlib.axis </span><span class="s3">import </span><span class="s1">Tick</span>
    <span class="s3">from </span><span class="s1">matplotlib.axes._base </span><span class="s3">import </span><span class="s1">_AxesBase</span>
    <span class="s3">from </span><span class="s1">matplotlib.backend_bases </span><span class="s3">import </span><span class="s1">RendererBase</span><span class="s3">, </span><span class="s1">Event</span>
    <span class="s3">from </span><span class="s1">matplotlib.cm </span><span class="s3">import </span><span class="s1">ScalarMappable</span>
    <span class="s3">from </span><span class="s1">matplotlib.contour </span><span class="s3">import </span><span class="s1">ContourSet</span><span class="s3">, </span><span class="s1">QuadContourSet</span>
    <span class="s3">from </span><span class="s1">matplotlib.collections </span><span class="s3">import </span><span class="s1">(</span>
        <span class="s1">Collection</span><span class="s3">,</span>
        <span class="s1">LineCollection</span><span class="s3">,</span>
        <span class="s1">BrokenBarHCollection</span><span class="s3">,</span>
        <span class="s1">PolyCollection</span><span class="s3">,</span>
        <span class="s1">PathCollection</span><span class="s3">,</span>
        <span class="s1">EventCollection</span><span class="s3">,</span>
        <span class="s1">QuadMesh</span><span class="s3">,</span>
    <span class="s1">)</span>
    <span class="s3">from </span><span class="s1">matplotlib.colorbar </span><span class="s3">import </span><span class="s1">Colorbar</span>
    <span class="s3">from </span><span class="s1">matplotlib.colors </span><span class="s3">import </span><span class="s1">Colormap</span>
    <span class="s3">from </span><span class="s1">matplotlib.container </span><span class="s3">import </span><span class="s1">(</span>
        <span class="s1">BarContainer</span><span class="s3">,</span>
        <span class="s1">ErrorbarContainer</span><span class="s3">,</span>
        <span class="s1">StemContainer</span><span class="s3">,</span>
    <span class="s1">)</span>
    <span class="s3">from </span><span class="s1">matplotlib.figure </span><span class="s3">import </span><span class="s1">SubFigure</span>
    <span class="s3">from </span><span class="s1">matplotlib.legend </span><span class="s3">import </span><span class="s1">Legend</span>
    <span class="s3">from </span><span class="s1">matplotlib.mlab </span><span class="s3">import </span><span class="s1">GaussianKDE</span>
    <span class="s3">from </span><span class="s1">matplotlib.image </span><span class="s3">import </span><span class="s1">AxesImage</span><span class="s3">, </span><span class="s1">FigureImage</span>
    <span class="s3">from </span><span class="s1">matplotlib.patches </span><span class="s3">import </span><span class="s1">FancyArrow</span><span class="s3">, </span><span class="s1">StepPatch</span><span class="s3">, </span><span class="s1">Wedge</span>
    <span class="s3">from </span><span class="s1">matplotlib.quiver </span><span class="s3">import </span><span class="s1">Barbs</span><span class="s3">, </span><span class="s1">Quiver</span><span class="s3">, </span><span class="s1">QuiverKey</span>
    <span class="s3">from </span><span class="s1">matplotlib.scale </span><span class="s3">import </span><span class="s1">ScaleBase</span>
    <span class="s3">from </span><span class="s1">matplotlib.transforms </span><span class="s3">import </span><span class="s1">Transform</span><span class="s3">, </span><span class="s1">Bbox</span>
    <span class="s3">from </span><span class="s1">matplotlib.typing </span><span class="s3">import </span><span class="s1">ColorType</span><span class="s3">, </span><span class="s1">LineStyleType</span><span class="s3">, </span><span class="s1">MarkerType</span><span class="s3">, </span><span class="s1">HashableList</span>
    <span class="s3">from </span><span class="s1">matplotlib.widgets </span><span class="s3">import </span><span class="s1">SubplotTool</span>

    <span class="s1">_P = ParamSpec(</span><span class="s4">'_P'</span><span class="s1">)</span>
    <span class="s1">_R = TypeVar(</span><span class="s4">'_R'</span><span class="s1">)</span>
    <span class="s1">_T = TypeVar(</span><span class="s4">'_T'</span><span class="s1">)</span>


<span class="s0"># We may not need the following imports here:</span>
<span class="s3">from </span><span class="s1">matplotlib.colors </span><span class="s3">import </span><span class="s1">Normalize</span>
<span class="s3">from </span><span class="s1">matplotlib.lines </span><span class="s3">import </span><span class="s1">Line2D</span>
<span class="s3">from </span><span class="s1">matplotlib.text </span><span class="s3">import </span><span class="s1">Text</span><span class="s3">, </span><span class="s1">Annotation</span>
<span class="s3">from </span><span class="s1">matplotlib.patches </span><span class="s3">import </span><span class="s1">Polygon</span><span class="s3">, </span><span class="s1">Rectangle</span><span class="s3">, </span><span class="s1">Circle</span><span class="s3">, </span><span class="s1">Arrow</span>
<span class="s3">from </span><span class="s1">matplotlib.widgets </span><span class="s3">import </span><span class="s1">Button</span><span class="s3">, </span><span class="s1">Slider</span><span class="s3">, </span><span class="s1">Widget</span>

<span class="s3">from </span><span class="s1">.ticker </span><span class="s3">import </span><span class="s1">(</span>
    <span class="s1">TickHelper</span><span class="s3">, </span><span class="s1">Formatter</span><span class="s3">, </span><span class="s1">FixedFormatter</span><span class="s3">, </span><span class="s1">NullFormatter</span><span class="s3">, </span><span class="s1">FuncFormatter</span><span class="s3">,</span>
    <span class="s1">FormatStrFormatter</span><span class="s3">, </span><span class="s1">ScalarFormatter</span><span class="s3">, </span><span class="s1">LogFormatter</span><span class="s3">, </span><span class="s1">LogFormatterExponent</span><span class="s3">,</span>
    <span class="s1">LogFormatterMathtext</span><span class="s3">, </span><span class="s1">Locator</span><span class="s3">, </span><span class="s1">IndexLocator</span><span class="s3">, </span><span class="s1">FixedLocator</span><span class="s3">, </span><span class="s1">NullLocator</span><span class="s3">,</span>
    <span class="s1">LinearLocator</span><span class="s3">, </span><span class="s1">LogLocator</span><span class="s3">, </span><span class="s1">AutoLocator</span><span class="s3">, </span><span class="s1">MultipleLocator</span><span class="s3">, </span><span class="s1">MaxNLocator)</span>

<span class="s1">_log = logging.getLogger(__name__)</span>


<span class="s0"># Explicit rename instead of import-as for typing's sake.</span>
<span class="s1">colormaps = _colormaps</span>
<span class="s1">color_sequences = _color_sequences</span>


<span class="s1">@overload</span>
<span class="s3">def </span><span class="s1">_copy_docstring_and_deprecators(</span>
    <span class="s1">method: Any</span><span class="s3">,</span>
    <span class="s1">func: Literal[</span><span class="s3">None</span><span class="s1">] = </span><span class="s3">None</span>
<span class="s1">) -&gt; Callable[[Callable[_P</span><span class="s3">, </span><span class="s1">_R]]</span><span class="s3">, </span><span class="s1">Callable[_P</span><span class="s3">, </span><span class="s1">_R]]: ...</span>


<span class="s1">@overload</span>
<span class="s3">def </span><span class="s1">_copy_docstring_and_deprecators(</span>
    <span class="s1">method: Any</span><span class="s3">, </span><span class="s1">func: Callable[_P</span><span class="s3">, </span><span class="s1">_R]) -&gt; Callable[_P</span><span class="s3">, </span><span class="s1">_R]: ...</span>


<span class="s3">def </span><span class="s1">_copy_docstring_and_deprecators(</span>
    <span class="s1">method: Any</span><span class="s3">,</span>
    <span class="s1">func: Callable[_P</span><span class="s3">, </span><span class="s1">_R] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None</span>
<span class="s1">) -&gt; Callable[[Callable[_P</span><span class="s3">, </span><span class="s1">_R]]</span><span class="s3">, </span><span class="s1">Callable[_P</span><span class="s3">, </span><span class="s1">_R]] | Callable[_P</span><span class="s3">, </span><span class="s1">_R]:</span>
    <span class="s3">if </span><span class="s1">func </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">cast(</span><span class="s4">'Callable[[Callable[_P, _R]], Callable[_P, _R]]'</span><span class="s3">,</span>
                    <span class="s1">functools.partial(_copy_docstring_and_deprecators</span><span class="s3">, </span><span class="s1">method))</span>
    <span class="s1">decorators: list[Callable[[Callable[_P</span><span class="s3">, </span><span class="s1">_R]]</span><span class="s3">, </span><span class="s1">Callable[_P</span><span class="s3">, </span><span class="s1">_R]]] = [</span>
        <span class="s1">_docstring.copy(method)</span>
    <span class="s1">]</span>
    <span class="s0"># Check whether the definition of *method* includes @_api.rename_parameter</span>
    <span class="s0"># or @_api.make_keyword_only decorators; if so, propagate them to the</span>
    <span class="s0"># pyplot wrapper as well.</span>
    <span class="s3">while </span><span class="s1">hasattr(method</span><span class="s3">, </span><span class="s4">&quot;__wrapped__&quot;</span><span class="s1">):</span>
        <span class="s1">potential_decorator = _api.deprecation.DECORATORS.get(method)</span>
        <span class="s3">if </span><span class="s1">potential_decorator:</span>
            <span class="s1">decorators.append(potential_decorator)</span>
        <span class="s1">method = method.__wrapped__</span>
    <span class="s3">for </span><span class="s1">decorator </span><span class="s3">in </span><span class="s1">decorators[::-</span><span class="s5">1</span><span class="s1">]:</span>
        <span class="s1">func = decorator(func)</span>
    <span class="s3">return </span><span class="s1">func</span>


<span class="s0">## Global ##</span>


<span class="s0"># The state controlled by {,un}install_repl_displayhook().</span>
<span class="s1">_ReplDisplayHook = Enum(</span><span class="s4">&quot;_ReplDisplayHook&quot;</span><span class="s3">, </span><span class="s1">[</span><span class="s4">&quot;NONE&quot;</span><span class="s3">, </span><span class="s4">&quot;PLAIN&quot;</span><span class="s3">, </span><span class="s4">&quot;IPYTHON&quot;</span><span class="s1">])</span>
<span class="s1">_REPL_DISPLAYHOOK = _ReplDisplayHook.NONE</span>


<span class="s3">def </span><span class="s1">_draw_all_if_interactive() -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s3">if </span><span class="s1">matplotlib.is_interactive():</span>
        <span class="s1">draw_all()</span>


<span class="s3">def </span><span class="s1">install_repl_displayhook() -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot; 
    Connect to the display hook of the current shell. 
 
    The display hook gets called when the read-evaluate-print-loop (REPL) of 
    the shell has finished the execution of a command. We use this callback 
    to be able to automatically update a figure in interactive mode. 
 
    This works both with IPython and with vanilla python shells. 
    &quot;&quot;&quot;</span>
    <span class="s3">global </span><span class="s1">_REPL_DISPLAYHOOK</span>

    <span class="s3">if </span><span class="s1">_REPL_DISPLAYHOOK </span><span class="s3">is </span><span class="s1">_ReplDisplayHook.IPYTHON:</span>
        <span class="s3">return</span>

    <span class="s0"># See if we have IPython hooks around, if so use them.</span>
    <span class="s0"># Use ``sys.modules.get(name)`` rather than ``name in sys.modules`` as</span>
    <span class="s0"># entries can also have been explicitly set to None.</span>
    <span class="s1">mod_ipython = sys.modules.get(</span><span class="s4">&quot;IPython&quot;</span><span class="s1">)</span>
    <span class="s3">if not </span><span class="s1">mod_ipython:</span>
        <span class="s1">_REPL_DISPLAYHOOK = _ReplDisplayHook.PLAIN</span>
        <span class="s3">return</span>
    <span class="s1">ip = mod_ipython.get_ipython()</span>
    <span class="s3">if not </span><span class="s1">ip:</span>
        <span class="s1">_REPL_DISPLAYHOOK = _ReplDisplayHook.PLAIN</span>
        <span class="s3">return</span>

    <span class="s1">ip.events.register(</span><span class="s4">&quot;post_execute&quot;</span><span class="s3">, </span><span class="s1">_draw_all_if_interactive)</span>
    <span class="s1">_REPL_DISPLAYHOOK = _ReplDisplayHook.IPYTHON</span>

    <span class="s3">from </span><span class="s1">IPython.core.pylabtools </span><span class="s3">import </span><span class="s1">backend2gui  </span><span class="s0"># type: ignore</span>
    <span class="s0"># trigger IPython's eventloop integration, if available</span>
    <span class="s1">ipython_gui_name = backend2gui.get(get_backend())</span>
    <span class="s3">if </span><span class="s1">ipython_gui_name:</span>
        <span class="s1">ip.enable_gui(ipython_gui_name)</span>


<span class="s3">def </span><span class="s1">uninstall_repl_displayhook() -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot;Disconnect from the display hook of the current shell.&quot;&quot;&quot;</span>
    <span class="s3">global </span><span class="s1">_REPL_DISPLAYHOOK</span>
    <span class="s3">if </span><span class="s1">_REPL_DISPLAYHOOK </span><span class="s3">is </span><span class="s1">_ReplDisplayHook.IPYTHON:</span>
        <span class="s3">from </span><span class="s1">IPython </span><span class="s3">import </span><span class="s1">get_ipython  </span><span class="s0"># type: ignore</span>
        <span class="s1">ip = get_ipython()</span>
        <span class="s1">ip.events.unregister(</span><span class="s4">&quot;post_execute&quot;</span><span class="s3">, </span><span class="s1">_draw_all_if_interactive)</span>
    <span class="s1">_REPL_DISPLAYHOOK = _ReplDisplayHook.NONE</span>


<span class="s1">draw_all = _pylab_helpers.Gcf.draw_all</span>


<span class="s0"># Ensure this appears in the pyplot docs.</span>
<span class="s1">@_copy_docstring_and_deprecators(matplotlib.set_loglevel)</span>
<span class="s3">def </span><span class="s1">set_loglevel(*args</span><span class="s3">, </span><span class="s1">**kwargs) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">matplotlib.set_loglevel(*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>


<span class="s1">@_copy_docstring_and_deprecators(Artist.findobj)</span>
<span class="s3">def </span><span class="s1">findobj(</span>
    <span class="s1">o: Artist | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">match: Callable[[Artist]</span><span class="s3">, </span><span class="s1">bool] | type[Artist] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">include_self: bool = </span><span class="s3">True</span>
<span class="s1">) -&gt; list[Artist]:</span>
    <span class="s3">if </span><span class="s1">o </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">o = gcf()</span>
    <span class="s3">return </span><span class="s1">o.findobj(match</span><span class="s3">, </span><span class="s1">include_self=include_self)</span>


<span class="s1">_backend_mod: type[matplotlib.backend_bases._Backend] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None</span>


<span class="s3">def </span><span class="s1">_get_backend_mod() -&gt; type[matplotlib.backend_bases._Backend]:</span>
    <span class="s2">&quot;&quot;&quot; 
    Ensure that a backend is selected and return it. 
 
    This is currently private, but may be made public in the future. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">_backend_mod </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s0"># Use rcParams._get(&quot;backend&quot;) to avoid going through the fallback</span>
        <span class="s0"># logic (which will (re)import pyplot and then call switch_backend if</span>
        <span class="s0"># we need to resolve the auto sentinel)</span>
        <span class="s1">switch_backend(rcParams._get(</span><span class="s4">&quot;backend&quot;</span><span class="s1">))  </span><span class="s0"># type: ignore[attr-defined]</span>
    <span class="s3">return </span><span class="s1">cast(type[matplotlib.backend_bases._Backend]</span><span class="s3">, </span><span class="s1">_backend_mod)</span>


<span class="s3">def </span><span class="s1">switch_backend(newbackend: str) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot; 
    Set the pyplot backend. 
 
    Switching to an interactive backend is possible only if no event loop for 
    another interactive backend has started.  Switching to and from 
    non-interactive backends is always possible. 
 
    If the new backend is different than the current backend then all open 
    Figures will be closed via ``plt.close('all')``. 
 
    Parameters 
    ---------- 
    newbackend : str 
        The case-insensitive name of the backend to use. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">global </span><span class="s1">_backend_mod</span>
    <span class="s0"># make sure the init is pulled up so we can assign to it later</span>
    <span class="s3">import </span><span class="s1">matplotlib.backends</span>

    <span class="s3">if </span><span class="s1">newbackend </span><span class="s3">is </span><span class="s1">rcsetup._auto_backend_sentinel:</span>
        <span class="s1">current_framework = cbook._get_running_interactive_framework()</span>
        <span class="s1">mapping = {</span><span class="s4">'qt'</span><span class="s1">: </span><span class="s4">'qtagg'</span><span class="s3">,</span>
                   <span class="s4">'gtk3'</span><span class="s1">: </span><span class="s4">'gtk3agg'</span><span class="s3">,</span>
                   <span class="s4">'gtk4'</span><span class="s1">: </span><span class="s4">'gtk4agg'</span><span class="s3">,</span>
                   <span class="s4">'wx'</span><span class="s1">: </span><span class="s4">'wxagg'</span><span class="s3">,</span>
                   <span class="s4">'tk'</span><span class="s1">: </span><span class="s4">'tkagg'</span><span class="s3">,</span>
                   <span class="s4">'macosx'</span><span class="s1">: </span><span class="s4">'macosx'</span><span class="s3">,</span>
                   <span class="s4">'headless'</span><span class="s1">: </span><span class="s4">'agg'</span><span class="s1">}</span>

        <span class="s3">if </span><span class="s1">current_framework </span><span class="s3">in </span><span class="s1">mapping:</span>
            <span class="s1">candidates = [mapping[current_framework]]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">candidates = []</span>
        <span class="s1">candidates += [</span>
            <span class="s4">&quot;macosx&quot;</span><span class="s3">, </span><span class="s4">&quot;qtagg&quot;</span><span class="s3">, </span><span class="s4">&quot;gtk4agg&quot;</span><span class="s3">, </span><span class="s4">&quot;gtk3agg&quot;</span><span class="s3">, </span><span class="s4">&quot;tkagg&quot;</span><span class="s3">, </span><span class="s4">&quot;wxagg&quot;</span><span class="s1">]</span>

        <span class="s0"># Don't try to fallback on the cairo-based backends as they each have</span>
        <span class="s0"># an additional dependency (pycairo) over the agg-based backend, and</span>
        <span class="s0"># are of worse quality.</span>
        <span class="s3">for </span><span class="s1">candidate </span><span class="s3">in </span><span class="s1">candidates:</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">switch_backend(candidate)</span>
            <span class="s3">except </span><span class="s1">ImportError:</span>
                <span class="s3">continue</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">rcParamsOrig[</span><span class="s4">'backend'</span><span class="s1">] = candidate</span>
                <span class="s3">return</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s0"># Switching to Agg should always succeed; if it doesn't, let the</span>
            <span class="s0"># exception propagate out.</span>
            <span class="s1">switch_backend(</span><span class="s4">&quot;agg&quot;</span><span class="s1">)</span>
            <span class="s1">rcParamsOrig[</span><span class="s4">&quot;backend&quot;</span><span class="s1">] = </span><span class="s4">&quot;agg&quot;</span>
            <span class="s3">return</span>
    <span class="s0"># have to escape the switch on access logic</span>
    <span class="s1">old_backend = dict.__getitem__(rcParams</span><span class="s3">, </span><span class="s4">'backend'</span><span class="s1">)</span>

    <span class="s1">module = importlib.import_module(cbook._backend_module_name(newbackend))</span>
    <span class="s1">canvas_class = module.FigureCanvas</span>

    <span class="s1">required_framework = canvas_class.required_interactive_framework</span>
    <span class="s3">if </span><span class="s1">required_framework </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">current_framework = cbook._get_running_interactive_framework()</span>
        <span class="s3">if </span><span class="s1">(current_framework </span><span class="s3">and </span><span class="s1">required_framework</span>
                <span class="s3">and </span><span class="s1">current_framework != required_framework):</span>
            <span class="s3">raise </span><span class="s1">ImportError(</span>
                <span class="s4">&quot;Cannot load backend {!r} which requires the {!r} interactive &quot;</span>
                <span class="s4">&quot;framework, as {!r} is currently running&quot;</span><span class="s1">.format(</span>
                    <span class="s1">newbackend</span><span class="s3">, </span><span class="s1">required_framework</span><span class="s3">, </span><span class="s1">current_framework))</span>

    <span class="s0"># Load the new_figure_manager() and show() functions from the backend.</span>

    <span class="s0"># Classically, backends can directly export these functions.  This should</span>
    <span class="s0"># keep working for backcompat.</span>
    <span class="s1">new_figure_manager = getattr(module</span><span class="s3">, </span><span class="s4">&quot;new_figure_manager&quot;</span><span class="s3">, None</span><span class="s1">)</span>
    <span class="s1">show = getattr(module</span><span class="s3">, </span><span class="s4">&quot;show&quot;</span><span class="s3">, None</span><span class="s1">)</span>

    <span class="s0"># In that classical approach, backends are implemented as modules, but</span>
    <span class="s0"># &quot;inherit&quot; default method implementations from backend_bases._Backend.</span>
    <span class="s0"># This is achieved by creating a &quot;class&quot; that inherits from</span>
    <span class="s0"># backend_bases._Backend and whose body is filled with the module globals.</span>
    <span class="s3">class </span><span class="s1">backend_mod(matplotlib.backend_bases._Backend):</span>
        <span class="s1">locals().update(vars(module))</span>

    <span class="s0"># However, the newer approach for defining new_figure_manager and</span>
    <span class="s0"># show is to derive them from canvas methods.  In that case, also</span>
    <span class="s0"># update backend_mod accordingly; also, per-backend customization of</span>
    <span class="s0"># draw_if_interactive is disabled.</span>
    <span class="s3">if </span><span class="s1">new_figure_manager </span><span class="s3">is None</span><span class="s1">:</span>

        <span class="s3">def </span><span class="s1">new_figure_manager_given_figure(num</span><span class="s3">, </span><span class="s1">figure):</span>
            <span class="s3">return </span><span class="s1">canvas_class.new_manager(figure</span><span class="s3">, </span><span class="s1">num)</span>

        <span class="s3">def </span><span class="s1">new_figure_manager(num</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">FigureClass=Figure</span><span class="s3">, </span><span class="s1">**kwargs):</span>
            <span class="s1">fig = FigureClass(*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>
            <span class="s3">return </span><span class="s1">new_figure_manager_given_figure(num</span><span class="s3">, </span><span class="s1">fig)</span>

        <span class="s3">def </span><span class="s1">draw_if_interactive() -&gt; </span><span class="s3">None</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">matplotlib.is_interactive():</span>
                <span class="s1">manager = _pylab_helpers.Gcf.get_active()</span>
                <span class="s3">if </span><span class="s1">manager:</span>
                    <span class="s1">manager.canvas.draw_idle()</span>

        <span class="s1">backend_mod.new_figure_manager_given_figure = (  </span><span class="s0"># type: ignore[method-assign]</span>
            <span class="s1">new_figure_manager_given_figure)</span>
        <span class="s1">backend_mod.new_figure_manager = (  </span><span class="s0"># type: ignore[method-assign]</span>
            <span class="s1">new_figure_manager)</span>
        <span class="s1">backend_mod.draw_if_interactive = (  </span><span class="s0"># type: ignore[method-assign]</span>
            <span class="s1">draw_if_interactive)</span>

    <span class="s0"># If the manager explicitly overrides pyplot_show, use it even if a global</span>
    <span class="s0"># show is already present, as the latter may be here for backcompat.</span>
    <span class="s1">manager_class = getattr(canvas_class</span><span class="s3">, </span><span class="s4">&quot;manager_class&quot;</span><span class="s3">, None</span><span class="s1">)</span>
    <span class="s0"># We can't compare directly manager_class.pyplot_show and FMB.pyplot_show because</span>
    <span class="s0"># pyplot_show is a classmethod so the above constructs are bound classmethods, and</span>
    <span class="s0"># thus always different (being bound to different classes).  We also have to use</span>
    <span class="s0"># getattr_static instead of vars as manager_class could have no __dict__.</span>
    <span class="s1">manager_pyplot_show = inspect.getattr_static(manager_class</span><span class="s3">, </span><span class="s4">&quot;pyplot_show&quot;</span><span class="s3">, None</span><span class="s1">)</span>
    <span class="s1">base_pyplot_show = inspect.getattr_static(FigureManagerBase</span><span class="s3">, </span><span class="s4">&quot;pyplot_show&quot;</span><span class="s3">, None</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">(show </span><span class="s3">is None</span>
            <span class="s3">or </span><span class="s1">(manager_pyplot_show </span><span class="s3">is not None</span>
                <span class="s3">and </span><span class="s1">manager_pyplot_show != base_pyplot_show)):</span>
        <span class="s3">if not </span><span class="s1">manager_pyplot_show:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span>
                <span class="s4">f&quot;Backend </span><span class="s3">{</span><span class="s1">newbackend</span><span class="s3">} </span><span class="s4">defines neither FigureCanvas.manager_class nor &quot;</span>
                <span class="s4">f&quot;a toplevel show function&quot;</span><span class="s1">)</span>
        <span class="s1">_pyplot_show = cast(</span><span class="s4">'Any'</span><span class="s3">, </span><span class="s1">manager_class).pyplot_show</span>
        <span class="s1">backend_mod.show = _pyplot_show  </span><span class="s0"># type: ignore[method-assign]</span>

    <span class="s1">_log.debug(</span><span class="s4">&quot;Loaded backend %s version %s.&quot;</span><span class="s3">,</span>
               <span class="s1">newbackend</span><span class="s3">, </span><span class="s1">backend_mod.backend_version)</span>

    <span class="s1">rcParams[</span><span class="s4">'backend'</span><span class="s1">] = rcParamsDefault[</span><span class="s4">'backend'</span><span class="s1">] = newbackend</span>
    <span class="s1">_backend_mod = backend_mod</span>
    <span class="s3">for </span><span class="s1">func_name </span><span class="s3">in </span><span class="s1">[</span><span class="s4">&quot;new_figure_manager&quot;</span><span class="s3">, </span><span class="s4">&quot;draw_if_interactive&quot;</span><span class="s3">, </span><span class="s4">&quot;show&quot;</span><span class="s1">]:</span>
        <span class="s1">globals()[func_name].__signature__ = inspect.signature(</span>
            <span class="s1">getattr(backend_mod</span><span class="s3">, </span><span class="s1">func_name))</span>

    <span class="s0"># Need to keep a global reference to the backend for compatibility reasons.</span>
    <span class="s0"># See https://github.com/matplotlib/matplotlib/issues/6092</span>
    <span class="s1">matplotlib.backends.backend = newbackend  </span><span class="s0"># type: ignore[attr-defined]</span>

    <span class="s3">if not </span><span class="s1">cbook._str_equal(old_backend</span><span class="s3">, </span><span class="s1">newbackend):</span>
        <span class="s3">if </span><span class="s1">get_fignums():</span>
            <span class="s1">_api.warn_deprecated(</span><span class="s4">&quot;3.8&quot;</span><span class="s3">, </span><span class="s1">message=(</span>
                <span class="s4">&quot;Auto-close()ing of figures upon backend switching is deprecated since &quot;</span>
                <span class="s4">&quot;%(since)s and will be removed %(removal)s.  To suppress this warning, &quot;</span>
                <span class="s4">&quot;explicitly call plt.close('all') first.&quot;</span><span class="s1">))</span>
        <span class="s1">close(</span><span class="s4">&quot;all&quot;</span><span class="s1">)</span>

    <span class="s0"># Make sure the repl display hook is installed in case we become interactive.</span>
    <span class="s1">install_repl_displayhook()</span>


<span class="s3">def </span><span class="s1">_warn_if_gui_out_of_main_thread() -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s1">warn = </span><span class="s3">False</span>
    <span class="s1">canvas_class = cast(type[FigureCanvasBase]</span><span class="s3">, </span><span class="s1">_get_backend_mod().FigureCanvas)</span>
    <span class="s3">if </span><span class="s1">canvas_class.required_interactive_framework:</span>
        <span class="s3">if </span><span class="s1">hasattr(threading</span><span class="s3">, </span><span class="s4">'get_native_id'</span><span class="s1">):</span>
            <span class="s0"># This compares native thread ids because even if Python-level</span>
            <span class="s0"># Thread objects match, the underlying OS thread (which is what</span>
            <span class="s0"># really matters) may be different on Python implementations with</span>
            <span class="s0"># green threads.</span>
            <span class="s3">if </span><span class="s1">threading.get_native_id() != threading.main_thread().native_id:</span>
                <span class="s1">warn = </span><span class="s3">True</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s0"># Fall back to Python-level Thread if native IDs are unavailable,</span>
            <span class="s0"># mainly for PyPy.</span>
            <span class="s3">if </span><span class="s1">threading.current_thread() </span><span class="s3">is not </span><span class="s1">threading.main_thread():</span>
                <span class="s1">warn = </span><span class="s3">True</span>
    <span class="s3">if </span><span class="s1">warn:</span>
        <span class="s1">_api.warn_external(</span>
            <span class="s4">&quot;Starting a Matplotlib GUI outside of the main thread will likely &quot;</span>
            <span class="s4">&quot;fail.&quot;</span><span class="s1">)</span>


<span class="s0"># This function's signature is rewritten upon backend-load by switch_backend.</span>
<span class="s3">def </span><span class="s1">new_figure_manager(*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
    <span class="s2">&quot;&quot;&quot;Create a new figure manager instance.&quot;&quot;&quot;</span>
    <span class="s1">_warn_if_gui_out_of_main_thread()</span>
    <span class="s3">return </span><span class="s1">_get_backend_mod().new_figure_manager(*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>


<span class="s0"># This function's signature is rewritten upon backend-load by switch_backend.</span>
<span class="s3">def </span><span class="s1">draw_if_interactive(*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
    <span class="s2">&quot;&quot;&quot; 
    Redraw the current figure if in interactive mode. 
 
    .. warning:: 
 
        End users will typically not have to call this function because the 
        the interactive mode takes care of this. 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">_get_backend_mod().draw_if_interactive(*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>


<span class="s0"># This function's signature is rewritten upon backend-load by switch_backend.</span>
<span class="s3">def </span><span class="s1">show(*args</span><span class="s3">, </span><span class="s1">**kwargs) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot; 
    Display all open figures. 
 
    Parameters 
    ---------- 
    block : bool, optional 
        Whether to wait for all figures to be closed before returning. 
 
        If `True` block and run the GUI main loop until all figure windows 
        are closed. 
 
        If `False` ensure that all figure windows are displayed and return 
        immediately.  In this case, you are responsible for ensuring 
        that the event loop is running to have responsive figures. 
 
        Defaults to True in non-interactive mode and to False in interactive 
        mode (see `.pyplot.isinteractive`). 
 
    See Also 
    -------- 
    ion : Enable interactive mode, which shows / updates the figure after 
          every plotting command, so that calling ``show()`` is not necessary. 
    ioff : Disable interactive mode. 
    savefig : Save the figure to an image file instead of showing it on screen. 
 
    Notes 
    ----- 
    **Saving figures to file and showing a window at the same time** 
 
    If you want an image file as well as a user interface window, use 
    `.pyplot.savefig` before `.pyplot.show`. At the end of (a blocking) 
    ``show()`` the figure is closed and thus unregistered from pyplot. Calling 
    `.pyplot.savefig` afterwards would save a new and thus empty figure. This 
    limitation of command order does not apply if the show is non-blocking or 
    if you keep a reference to the figure and use `.Figure.savefig`. 
 
    **Auto-show in jupyter notebooks** 
 
    The jupyter backends (activated via ``%matplotlib inline``, 
    ``%matplotlib notebook``, or ``%matplotlib widget``), call ``show()`` at 
    the end of every cell by default. Thus, you usually don't have to call it 
    explicitly there. 
    &quot;&quot;&quot;</span>
    <span class="s1">_warn_if_gui_out_of_main_thread()</span>
    <span class="s3">return </span><span class="s1">_get_backend_mod().show(*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>


<span class="s3">def </span><span class="s1">isinteractive() -&gt; bool:</span>
    <span class="s2">&quot;&quot;&quot; 
    Return whether plots are updated after every plotting command. 
 
    The interactive mode is mainly useful if you build plots from the command 
    line and want to see the effect of each command while you are building the 
    figure. 
 
    In interactive mode: 
 
    - newly created figures will be shown immediately; 
    - figures will automatically redraw on change; 
    - `.pyplot.show` will not block by default. 
 
    In non-interactive mode: 
 
    - newly created figures and changes to figures will not be reflected until 
      explicitly asked to be; 
    - `.pyplot.show` will block by default. 
 
    See Also 
    -------- 
    ion : Enable interactive mode. 
    ioff : Disable interactive mode. 
    show : Show all figures (and maybe block). 
    pause : Show all figures, and block for a time. 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">matplotlib.is_interactive()</span>


<span class="s3">def </span><span class="s1">ioff() -&gt; ExitStack:</span>
    <span class="s2">&quot;&quot;&quot; 
    Disable interactive mode. 
 
    See `.pyplot.isinteractive` for more details. 
 
    See Also 
    -------- 
    ion : Enable interactive mode. 
    isinteractive : Whether interactive mode is enabled. 
    show : Show all figures (and maybe block). 
    pause : Show all figures, and block for a time. 
 
    Notes 
    ----- 
    For a temporary change, this can be used as a context manager:: 
 
        # if interactive mode is on 
        # then figures will be shown on creation 
        plt.ion() 
        # This figure will be shown immediately 
        fig = plt.figure() 
 
        with plt.ioff(): 
            # interactive mode will be off 
            # figures will not automatically be shown 
            fig2 = plt.figure() 
            # ... 
 
    To enable optional usage as a context manager, this function returns a 
    `~contextlib.ExitStack` object, which is not intended to be stored or 
    accessed by the user. 
    &quot;&quot;&quot;</span>
    <span class="s1">stack = ExitStack()</span>
    <span class="s1">stack.callback(ion </span><span class="s3">if </span><span class="s1">isinteractive() </span><span class="s3">else </span><span class="s1">ioff)</span>
    <span class="s1">matplotlib.interactive(</span><span class="s3">False</span><span class="s1">)</span>
    <span class="s1">uninstall_repl_displayhook()</span>
    <span class="s3">return </span><span class="s1">stack</span>


<span class="s3">def </span><span class="s1">ion() -&gt; ExitStack:</span>
    <span class="s2">&quot;&quot;&quot; 
    Enable interactive mode. 
 
    See `.pyplot.isinteractive` for more details. 
 
    See Also 
    -------- 
    ioff : Disable interactive mode. 
    isinteractive : Whether interactive mode is enabled. 
    show : Show all figures (and maybe block). 
    pause : Show all figures, and block for a time. 
 
    Notes 
    ----- 
    For a temporary change, this can be used as a context manager:: 
 
        # if interactive mode is off 
        # then figures will not be shown on creation 
        plt.ioff() 
        # This figure will not be shown immediately 
        fig = plt.figure() 
 
        with plt.ion(): 
            # interactive mode will be on 
            # figures will automatically be shown 
            fig2 = plt.figure() 
            # ... 
 
    To enable optional usage as a context manager, this function returns a 
    `~contextlib.ExitStack` object, which is not intended to be stored or 
    accessed by the user. 
    &quot;&quot;&quot;</span>
    <span class="s1">stack = ExitStack()</span>
    <span class="s1">stack.callback(ion </span><span class="s3">if </span><span class="s1">isinteractive() </span><span class="s3">else </span><span class="s1">ioff)</span>
    <span class="s1">matplotlib.interactive(</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s1">install_repl_displayhook()</span>
    <span class="s3">return </span><span class="s1">stack</span>


<span class="s3">def </span><span class="s1">pause(interval: float) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot; 
    Run the GUI event loop for *interval* seconds. 
 
    If there is an active figure, it will be updated and displayed before the 
    pause, and the GUI event loop (if any) will run during the pause. 
 
    This can be used for crude animation.  For more complex animation use 
    :mod:`matplotlib.animation`. 
 
    If there is no active figure, sleep for *interval* seconds instead. 
 
    See Also 
    -------- 
    matplotlib.animation : Proper animations 
    show : Show all figures and optional block until all figures are closed. 
    &quot;&quot;&quot;</span>
    <span class="s1">manager = _pylab_helpers.Gcf.get_active()</span>
    <span class="s3">if </span><span class="s1">manager </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">canvas = manager.canvas</span>
        <span class="s3">if </span><span class="s1">canvas.figure.stale:</span>
            <span class="s1">canvas.draw_idle()</span>
        <span class="s1">show(block=</span><span class="s3">False</span><span class="s1">)</span>
        <span class="s1">canvas.start_event_loop(interval)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">time.sleep(interval)</span>


<span class="s1">@_copy_docstring_and_deprecators(matplotlib.rc)</span>
<span class="s3">def </span><span class="s1">rc(group: str</span><span class="s3">, </span><span class="s1">**kwargs) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s1">matplotlib.rc(group</span><span class="s3">, </span><span class="s1">**kwargs)</span>


<span class="s1">@_copy_docstring_and_deprecators(matplotlib.rc_context)</span>
<span class="s3">def </span><span class="s1">rc_context(</span>
    <span class="s1">rc: dict[str</span><span class="s3">, </span><span class="s1">Any] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">fname: str | pathlib.Path | os.PathLike | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
<span class="s1">) -&gt; AbstractContextManager[</span><span class="s3">None</span><span class="s1">]:</span>
    <span class="s3">return </span><span class="s1">matplotlib.rc_context(rc</span><span class="s3">, </span><span class="s1">fname)</span>


<span class="s1">@_copy_docstring_and_deprecators(matplotlib.rcdefaults)</span>
<span class="s3">def </span><span class="s1">rcdefaults() -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s1">matplotlib.rcdefaults()</span>
    <span class="s3">if </span><span class="s1">matplotlib.is_interactive():</span>
        <span class="s1">draw_all()</span>


<span class="s0"># getp/get/setp are explicitly reexported so that they show up in pyplot docs.</span>


<span class="s1">@_copy_docstring_and_deprecators(matplotlib.artist.getp)</span>
<span class="s3">def </span><span class="s1">getp(obj</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
    <span class="s3">return </span><span class="s1">matplotlib.artist.getp(obj</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>


<span class="s1">@_copy_docstring_and_deprecators(matplotlib.artist.get)</span>
<span class="s3">def </span><span class="s1">get(obj</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
    <span class="s3">return </span><span class="s1">matplotlib.artist.get(obj</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>


<span class="s1">@_copy_docstring_and_deprecators(matplotlib.artist.setp)</span>
<span class="s3">def </span><span class="s1">setp(obj</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
    <span class="s3">return </span><span class="s1">matplotlib.artist.setp(obj</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>


<span class="s3">def </span><span class="s1">xkcd(</span>
    <span class="s1">scale: float = </span><span class="s5">1</span><span class="s3">, </span><span class="s1">length: float = </span><span class="s5">100</span><span class="s3">, </span><span class="s1">randomness: float = </span><span class="s5">2</span>
<span class="s1">) -&gt; ExitStack:</span>
    <span class="s2">&quot;&quot;&quot; 
    Turn on `xkcd &lt;https://xkcd.com/&gt;`_ sketch-style drawing mode.  This will 
    only have effect on things drawn after this function is called. 
 
    For best results, the &quot;Humor Sans&quot; font should be installed: it is 
    not included with Matplotlib. 
 
    Parameters 
    ---------- 
    scale : float, optional 
        The amplitude of the wiggle perpendicular to the source line. 
    length : float, optional 
        The length of the wiggle along the line. 
    randomness : float, optional 
        The scale factor by which the length is shrunken or expanded. 
 
    Notes 
    ----- 
    This function works by a number of rcParams, so it will probably 
    override others you have set before. 
 
    If you want the effects of this function to be temporary, it can 
    be used as a context manager, for example:: 
 
        with plt.xkcd(): 
            # This figure will be in XKCD-style 
            fig1 = plt.figure() 
            # ... 
 
        # This figure will be in regular style 
        fig2 = plt.figure() 
    &quot;&quot;&quot;</span>
    <span class="s0"># This cannot be implemented in terms of contextmanager() or rc_context()</span>
    <span class="s0"># because this needs to work as a non-contextmanager too.</span>

    <span class="s3">if </span><span class="s1">rcParams[</span><span class="s4">'text.usetex'</span><span class="s1">]:</span>
        <span class="s3">raise </span><span class="s1">RuntimeError(</span>
            <span class="s4">&quot;xkcd mode is not compatible with text.usetex = True&quot;</span><span class="s1">)</span>

    <span class="s1">stack = ExitStack()</span>
    <span class="s1">stack.callback(dict.update</span><span class="s3">, </span><span class="s1">rcParams</span><span class="s3">, </span><span class="s1">rcParams.copy())  </span><span class="s0"># type: ignore</span>

    <span class="s3">from </span><span class="s1">matplotlib </span><span class="s3">import </span><span class="s1">patheffects</span>
    <span class="s1">rcParams.update({</span>
        <span class="s4">'font.family'</span><span class="s1">: [</span><span class="s4">'xkcd'</span><span class="s3">, </span><span class="s4">'xkcd Script'</span><span class="s3">, </span><span class="s4">'Humor Sans'</span><span class="s3">, </span><span class="s4">'Comic Neue'</span><span class="s3">,</span>
                        <span class="s4">'Comic Sans MS'</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">'font.size'</span><span class="s1">: </span><span class="s5">14.0</span><span class="s3">,</span>
        <span class="s4">'path.sketch'</span><span class="s1">: (scale</span><span class="s3">, </span><span class="s1">length</span><span class="s3">, </span><span class="s1">randomness)</span><span class="s3">,</span>
        <span class="s4">'path.effects'</span><span class="s1">: [</span>
            <span class="s1">patheffects.withStroke(linewidth=</span><span class="s5">4</span><span class="s3">, </span><span class="s1">foreground=</span><span class="s4">&quot;w&quot;</span><span class="s1">)]</span><span class="s3">,</span>
        <span class="s4">'axes.linewidth'</span><span class="s1">: </span><span class="s5">1.5</span><span class="s3">,</span>
        <span class="s4">'lines.linewidth'</span><span class="s1">: </span><span class="s5">2.0</span><span class="s3">,</span>
        <span class="s4">'figure.facecolor'</span><span class="s1">: </span><span class="s4">'white'</span><span class="s3">,</span>
        <span class="s4">'grid.linewidth'</span><span class="s1">: </span><span class="s5">0.0</span><span class="s3">,</span>
        <span class="s4">'axes.grid'</span><span class="s1">: </span><span class="s3">False,</span>
        <span class="s4">'axes.unicode_minus'</span><span class="s1">: </span><span class="s3">False,</span>
        <span class="s4">'axes.edgecolor'</span><span class="s1">: </span><span class="s4">'black'</span><span class="s3">,</span>
        <span class="s4">'xtick.major.size'</span><span class="s1">: </span><span class="s5">8</span><span class="s3">,</span>
        <span class="s4">'xtick.major.width'</span><span class="s1">: </span><span class="s5">3</span><span class="s3">,</span>
        <span class="s4">'ytick.major.size'</span><span class="s1">: </span><span class="s5">8</span><span class="s3">,</span>
        <span class="s4">'ytick.major.width'</span><span class="s1">: </span><span class="s5">3</span><span class="s3">,</span>
    <span class="s1">})</span>

    <span class="s3">return </span><span class="s1">stack</span>


<span class="s0">## Figures ##</span>

<span class="s3">def </span><span class="s1">figure(</span>
    <span class="s0"># autoincrement if None, else integer from 1-N</span>
    <span class="s1">num: int | str | Figure | SubFigure | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s0"># defaults to rc figure.figsize</span>
    <span class="s1">figsize: tuple[float</span><span class="s3">, </span><span class="s1">float] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s0"># defaults to rc figure.dpi</span>
    <span class="s1">dpi: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s0"># defaults to rc figure.facecolor</span>
    <span class="s1">facecolor: ColorType | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s0"># defaults to rc figure.edgecolor</span>
    <span class="s1">edgecolor: ColorType | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">frameon: bool = </span><span class="s3">True,</span>
    <span class="s1">FigureClass: type[Figure] = Figure</span><span class="s3">,</span>
    <span class="s1">clear: bool = </span><span class="s3">False,</span>
    <span class="s1">**kwargs</span>
<span class="s1">) -&gt; Figure:</span>
    <span class="s2">&quot;&quot;&quot; 
    Create a new figure, or activate an existing figure. 
 
    Parameters 
    ---------- 
    num : int or str or `.Figure` or `.SubFigure`, optional 
        A unique identifier for the figure. 
 
        If a figure with that identifier already exists, this figure is made 
        active and returned. An integer refers to the ``Figure.number`` 
        attribute, a string refers to the figure label. 
 
        If there is no figure with the identifier or *num* is not given, a new 
        figure is created, made active and returned.  If *num* is an int, it 
        will be used for the ``Figure.number`` attribute, otherwise, an 
        auto-generated integer value is used (starting at 1 and incremented 
        for each new figure). If *num* is a string, the figure label and the 
        window title is set to this value.  If num is a ``SubFigure``, its 
        parent ``Figure`` is activated. 
 
    figsize : (float, float), default: :rc:`figure.figsize` 
        Width, height in inches. 
 
    dpi : float, default: :rc:`figure.dpi` 
        The resolution of the figure in dots-per-inch. 
 
    facecolor : color, default: :rc:`figure.facecolor` 
        The background color. 
 
    edgecolor : color, default: :rc:`figure.edgecolor` 
        The border color. 
 
    frameon : bool, default: True 
        If False, suppress drawing the figure frame. 
 
    FigureClass : subclass of `~matplotlib.figure.Figure` 
        If set, an instance of this subclass will be created, rather than a 
        plain `.Figure`. 
 
    clear : bool, default: False 
        If True and the figure already exists, then it is cleared. 
 
    layout : {'constrained', 'compressed', 'tight', 'none', `.LayoutEngine`, None}, \ 
default: None 
        The layout mechanism for positioning of plot elements to avoid 
        overlapping Axes decorations (labels, ticks, etc). Note that layout 
        managers can measurably slow down figure display. 
 
        - 'constrained': The constrained layout solver adjusts axes sizes 
          to avoid overlapping axes decorations.  Can handle complex plot 
          layouts and colorbars, and is thus recommended. 
 
          See :ref:`constrainedlayout_guide` 
          for examples. 
 
        - 'compressed': uses the same algorithm as 'constrained', but 
          removes extra space between fixed-aspect-ratio Axes.  Best for 
          simple grids of axes. 
 
        - 'tight': Use the tight layout mechanism. This is a relatively 
          simple algorithm that adjusts the subplot parameters so that 
          decorations do not overlap. See `.Figure.set_tight_layout` for 
          further details. 
 
        - 'none': Do not use a layout engine. 
 
        - A `.LayoutEngine` instance. Builtin layout classes are 
          `.ConstrainedLayoutEngine` and `.TightLayoutEngine`, more easily 
          accessible by 'constrained' and 'tight'.  Passing an instance 
          allows third parties to provide their own layout engine. 
 
        If not given, fall back to using the parameters *tight_layout* and 
        *constrained_layout*, including their config defaults 
        :rc:`figure.autolayout` and :rc:`figure.constrained_layout.use`. 
 
    **kwargs 
        Additional keyword arguments are passed to the `.Figure` constructor. 
 
    Returns 
    ------- 
    `~matplotlib.figure.Figure` 
 
    Notes 
    ----- 
    A newly created figure is passed to the `~.FigureCanvasBase.new_manager` 
    method or the `new_figure_manager` function provided by the current 
    backend, which install a canvas and a manager on the figure. 
 
    Once this is done, :rc:`figure.hooks` are called, one at a time, on the 
    figure; these hooks allow arbitrary customization of the figure (e.g., 
    attaching callbacks) or of associated elements (e.g., modifying the 
    toolbar).  See :doc:`/gallery/user_interfaces/mplcvd` for an example of 
    toolbar customization. 
 
    If you are creating many figures, make sure you explicitly call 
    `.pyplot.close` on the figures you are not using, because this will 
    enable pyplot to properly clean up the memory. 
 
    `~matplotlib.rcParams` defines the default values, which can be modified 
    in the matplotlibrc file. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">isinstance(num</span><span class="s3">, </span><span class="s1">FigureBase):</span>
        <span class="s0"># type narrowed to `Figure | SubFigure` by combination of input and isinstance</span>
        <span class="s3">if </span><span class="s1">num.canvas.manager </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;The passed figure is not managed by pyplot&quot;</span><span class="s1">)</span>
        <span class="s1">_pylab_helpers.Gcf.set_active(num.canvas.manager)</span>
        <span class="s3">return </span><span class="s1">num.figure</span>

    <span class="s1">allnums = get_fignums()</span>
    <span class="s1">next_num = max(allnums) + </span><span class="s5">1 </span><span class="s3">if </span><span class="s1">allnums </span><span class="s3">else </span><span class="s5">1</span>
    <span class="s1">fig_label = </span><span class="s4">''</span>
    <span class="s3">if </span><span class="s1">num </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">num = next_num</span>
    <span class="s3">elif </span><span class="s1">isinstance(num</span><span class="s3">, </span><span class="s1">str):</span>
        <span class="s1">fig_label = num</span>
        <span class="s1">all_labels = get_figlabels()</span>
        <span class="s3">if </span><span class="s1">fig_label </span><span class="s3">not in </span><span class="s1">all_labels:</span>
            <span class="s3">if </span><span class="s1">fig_label == </span><span class="s4">'all'</span><span class="s1">:</span>
                <span class="s1">_api.warn_external(</span><span class="s4">&quot;close('all') closes all existing figures.&quot;</span><span class="s1">)</span>
            <span class="s1">num = next_num</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">inum = all_labels.index(fig_label)</span>
            <span class="s1">num = allnums[inum]</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">num = int(num)  </span><span class="s0"># crude validation of num argument</span>

    <span class="s0"># Type of &quot;num&quot; has narrowed to int, but mypy can't quite see it</span>
    <span class="s1">manager = _pylab_helpers.Gcf.get_fig_manager(num)  </span><span class="s0"># type: ignore[arg-type]</span>
    <span class="s3">if </span><span class="s1">manager </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">max_open_warning = rcParams[</span><span class="s4">'figure.max_open_warning'</span><span class="s1">]</span>
        <span class="s3">if </span><span class="s1">len(allnums) == max_open_warning &gt;= </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">_api.warn_external(</span>
                <span class="s4">f&quot;More than </span><span class="s3">{</span><span class="s1">max_open_warning</span><span class="s3">} </span><span class="s4">figures have been opened. &quot;</span>
                <span class="s4">f&quot;Figures created through the pyplot interface &quot;</span>
                <span class="s4">f&quot;(`matplotlib.pyplot.figure`) are retained until explicitly &quot;</span>
                <span class="s4">f&quot;closed and may consume too much memory. (To control this &quot;</span>
                <span class="s4">f&quot;warning, see the rcParam `figure.max_open_warning`). &quot;</span>
                <span class="s4">f&quot;Consider using `matplotlib.pyplot.close()`.&quot;</span><span class="s3">,</span>
                <span class="s1">RuntimeWarning)</span>

        <span class="s1">manager = new_figure_manager(</span>
            <span class="s1">num</span><span class="s3">, </span><span class="s1">figsize=figsize</span><span class="s3">, </span><span class="s1">dpi=dpi</span><span class="s3">,</span>
            <span class="s1">facecolor=facecolor</span><span class="s3">, </span><span class="s1">edgecolor=edgecolor</span><span class="s3">, </span><span class="s1">frameon=frameon</span><span class="s3">,</span>
            <span class="s1">FigureClass=FigureClass</span><span class="s3">, </span><span class="s1">**kwargs)</span>
        <span class="s1">fig = manager.canvas.figure</span>
        <span class="s3">if </span><span class="s1">fig_label:</span>
            <span class="s1">fig.set_label(fig_label)</span>

        <span class="s3">for </span><span class="s1">hookspecs </span><span class="s3">in </span><span class="s1">rcParams[</span><span class="s4">&quot;figure.hooks&quot;</span><span class="s1">]:</span>
            <span class="s1">module_name</span><span class="s3">, </span><span class="s1">dotted_name = hookspecs.split(</span><span class="s4">&quot;:&quot;</span><span class="s1">)</span>
            <span class="s1">obj: Any = importlib.import_module(module_name)</span>
            <span class="s3">for </span><span class="s1">part </span><span class="s3">in </span><span class="s1">dotted_name.split(</span><span class="s4">&quot;.&quot;</span><span class="s1">):</span>
                <span class="s1">obj = getattr(obj</span><span class="s3">, </span><span class="s1">part)</span>
            <span class="s1">obj(fig)</span>

        <span class="s1">_pylab_helpers.Gcf._set_new_active_manager(manager)</span>

        <span class="s0"># make sure backends (inline) that we don't ship that expect this</span>
        <span class="s0"># to be called in plotting commands to make the figure call show</span>
        <span class="s0"># still work.  There is probably a better way to do this in the</span>
        <span class="s0"># FigureManager base class.</span>
        <span class="s1">draw_if_interactive()</span>

        <span class="s3">if </span><span class="s1">_REPL_DISPLAYHOOK </span><span class="s3">is </span><span class="s1">_ReplDisplayHook.PLAIN:</span>
            <span class="s1">fig.stale_callback = _auto_draw_if_interactive</span>

    <span class="s3">if </span><span class="s1">clear:</span>
        <span class="s1">manager.canvas.figure.clear()</span>

    <span class="s3">return </span><span class="s1">manager.canvas.figure</span>


<span class="s3">def </span><span class="s1">_auto_draw_if_interactive(fig</span><span class="s3">, </span><span class="s1">val):</span>
    <span class="s2">&quot;&quot;&quot; 
    An internal helper function for making sure that auto-redrawing 
    works as intended in the plain python repl. 
 
    Parameters 
    ---------- 
    fig : Figure 
        A figure object which is assumed to be associated with a canvas 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">(val </span><span class="s3">and </span><span class="s1">matplotlib.is_interactive()</span>
            <span class="s3">and not </span><span class="s1">fig.canvas.is_saving()</span>
            <span class="s3">and not </span><span class="s1">fig.canvas._is_idle_drawing):</span>
        <span class="s0"># Some artists can mark themselves as stale in the middle of drawing</span>
        <span class="s0"># (e.g. axes position &amp; tick labels being computed at draw time), but</span>
        <span class="s0"># this shouldn't trigger a redraw because the current redraw will</span>
        <span class="s0"># already take them into account.</span>
        <span class="s3">with </span><span class="s1">fig.canvas._idle_draw_cntx():</span>
            <span class="s1">fig.canvas.draw_idle()</span>


<span class="s3">def </span><span class="s1">gcf() -&gt; Figure:</span>
    <span class="s2">&quot;&quot;&quot; 
    Get the current figure. 
 
    If there is currently no figure on the pyplot figure stack, a new one is 
    created using `~.pyplot.figure()`.  (To test whether there is currently a 
    figure on the pyplot figure stack, check whether `~.pyplot.get_fignums()` 
    is empty.) 
    &quot;&quot;&quot;</span>
    <span class="s1">manager = _pylab_helpers.Gcf.get_active()</span>
    <span class="s3">if </span><span class="s1">manager </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">manager.canvas.figure</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">figure()</span>


<span class="s3">def </span><span class="s1">fignum_exists(num: int) -&gt; bool:</span>
    <span class="s2">&quot;&quot;&quot;Return whether the figure with the given id exists.&quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">_pylab_helpers.Gcf.has_fignum(num) </span><span class="s3">or </span><span class="s1">num </span><span class="s3">in </span><span class="s1">get_figlabels()</span>


<span class="s3">def </span><span class="s1">get_fignums() -&gt; list[int]:</span>
    <span class="s2">&quot;&quot;&quot;Return a list of existing figure numbers.&quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">sorted(_pylab_helpers.Gcf.figs)</span>


<span class="s3">def </span><span class="s1">get_figlabels() -&gt; list[Any]:</span>
    <span class="s2">&quot;&quot;&quot;Return a list of existing figure labels.&quot;&quot;&quot;</span>
    <span class="s1">managers = _pylab_helpers.Gcf.get_all_fig_managers()</span>
    <span class="s1">managers.sort(key=</span><span class="s3">lambda </span><span class="s1">m: m.num)</span>
    <span class="s3">return </span><span class="s1">[m.canvas.figure.get_label() </span><span class="s3">for </span><span class="s1">m </span><span class="s3">in </span><span class="s1">managers]</span>


<span class="s3">def </span><span class="s1">get_current_fig_manager() -&gt; FigureManagerBase | </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot; 
    Return the figure manager of the current figure. 
 
    The figure manager is a container for the actual backend-depended window 
    that displays the figure on screen. 
 
    If no current figure exists, a new one is created, and its figure 
    manager is returned. 
 
    Returns 
    ------- 
    `.FigureManagerBase` or backend-dependent subclass thereof 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">gcf().canvas.manager</span>


<span class="s1">@_copy_docstring_and_deprecators(FigureCanvasBase.mpl_connect)</span>
<span class="s3">def </span><span class="s1">connect(s: str</span><span class="s3">, </span><span class="s1">func: Callable[[Event]</span><span class="s3">, </span><span class="s1">Any]) -&gt; int:</span>
    <span class="s3">return </span><span class="s1">gcf().canvas.mpl_connect(s</span><span class="s3">, </span><span class="s1">func)</span>


<span class="s1">@_copy_docstring_and_deprecators(FigureCanvasBase.mpl_disconnect)</span>
<span class="s3">def </span><span class="s1">disconnect(cid: int) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s1">gcf().canvas.mpl_disconnect(cid)</span>


<span class="s3">def </span><span class="s1">close(fig: </span><span class="s3">None </span><span class="s1">| int | str | Figure | Literal[</span><span class="s4">&quot;all&quot;</span><span class="s1">] = </span><span class="s3">None</span><span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot; 
    Close a figure window. 
 
    Parameters 
    ---------- 
    fig : None or int or str or `.Figure` 
        The figure to close. There are a number of ways to specify this: 
 
        - *None*: the current figure 
        - `.Figure`: the given `.Figure` instance 
        - ``int``: a figure number 
        - ``str``: a figure name 
        - 'all': all figures 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">fig </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">manager = _pylab_helpers.Gcf.get_active()</span>
        <span class="s3">if </span><span class="s1">manager </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">_pylab_helpers.Gcf.destroy(manager)</span>
    <span class="s3">elif </span><span class="s1">fig == </span><span class="s4">'all'</span><span class="s1">:</span>
        <span class="s1">_pylab_helpers.Gcf.destroy_all()</span>
    <span class="s3">elif </span><span class="s1">isinstance(fig</span><span class="s3">, </span><span class="s1">int):</span>
        <span class="s1">_pylab_helpers.Gcf.destroy(fig)</span>
    <span class="s3">elif </span><span class="s1">hasattr(fig</span><span class="s3">, </span><span class="s4">'int'</span><span class="s1">):</span>
        <span class="s0"># if we are dealing with a type UUID, we</span>
        <span class="s0"># can use its integer representation</span>
        <span class="s1">_pylab_helpers.Gcf.destroy(fig.int)</span>
    <span class="s3">elif </span><span class="s1">isinstance(fig</span><span class="s3">, </span><span class="s1">str):</span>
        <span class="s1">all_labels = get_figlabels()</span>
        <span class="s3">if </span><span class="s1">fig </span><span class="s3">in </span><span class="s1">all_labels:</span>
            <span class="s1">num = get_fignums()[all_labels.index(fig)]</span>
            <span class="s1">_pylab_helpers.Gcf.destroy(num)</span>
    <span class="s3">elif </span><span class="s1">isinstance(fig</span><span class="s3">, </span><span class="s1">Figure):</span>
        <span class="s1">_pylab_helpers.Gcf.destroy_fig(fig)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;close() argument must be a Figure, an int, a string, &quot;</span>
                        <span class="s4">&quot;or None, not %s&quot; </span><span class="s1">% type(fig))</span>


<span class="s3">def </span><span class="s1">clf() -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot;Clear the current figure.&quot;&quot;&quot;</span>
    <span class="s1">gcf().clear()</span>


<span class="s3">def </span><span class="s1">draw() -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot; 
    Redraw the current figure. 
 
    This is used to update a figure that has been altered, but not 
    automatically re-drawn.  If interactive mode is on (via `.ion()`), this 
    should be only rarely needed, but there may be ways to modify the state of 
    a figure without marking it as &quot;stale&quot;.  Please report these cases as bugs. 
 
    This is equivalent to calling ``fig.canvas.draw_idle()``, where ``fig`` is 
    the current figure. 
 
    See Also 
    -------- 
    .FigureCanvasBase.draw_idle 
    .FigureCanvasBase.draw 
    &quot;&quot;&quot;</span>
    <span class="s1">gcf().canvas.draw_idle()</span>


<span class="s1">@_copy_docstring_and_deprecators(Figure.savefig)</span>
<span class="s3">def </span><span class="s1">savefig(*args</span><span class="s3">, </span><span class="s1">**kwargs) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s1">fig = gcf()</span>
    <span class="s0"># savefig default implementation has no return, so mypy is unhappy</span>
    <span class="s0"># presumably this is here because subclasses can return?</span>
    <span class="s1">res = fig.savefig(*args</span><span class="s3">, </span><span class="s1">**kwargs)  </span><span class="s0"># type: ignore[func-returns-value]</span>
    <span class="s1">fig.canvas.draw_idle()  </span><span class="s0"># Need this if 'transparent=True', to reset colors.</span>
    <span class="s3">return </span><span class="s1">res</span>


<span class="s0">## Putting things in figures ##</span>


<span class="s3">def </span><span class="s1">figlegend(*args</span><span class="s3">, </span><span class="s1">**kwargs) -&gt; Legend:</span>
    <span class="s3">return </span><span class="s1">gcf().legend(*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>
<span class="s3">if </span><span class="s1">Figure.legend.__doc__:</span>
    <span class="s1">figlegend.__doc__ = Figure.legend.__doc__ \</span>
        <span class="s1">.replace(</span><span class="s4">&quot; legend(&quot;</span><span class="s3">, </span><span class="s4">&quot; figlegend(&quot;</span><span class="s1">) \</span>
        <span class="s1">.replace(</span><span class="s4">&quot;fig.legend(&quot;</span><span class="s3">, </span><span class="s4">&quot;plt.figlegend(&quot;</span><span class="s1">) \</span>
        <span class="s1">.replace(</span><span class="s4">&quot;ax.plot(&quot;</span><span class="s3">, </span><span class="s4">&quot;plt.plot(&quot;</span><span class="s1">)</span>


<span class="s0">## Axes ##</span>

<span class="s1">@_docstring.dedent_interpd</span>
<span class="s3">def </span><span class="s1">axes(</span>
    <span class="s1">arg: </span><span class="s3">None </span><span class="s1">| tuple[float</span><span class="s3">, </span><span class="s1">float</span><span class="s3">, </span><span class="s1">float</span><span class="s3">, </span><span class="s1">float] = </span><span class="s3">None,</span>
    <span class="s1">**kwargs</span>
<span class="s1">) -&gt; matplotlib.axes.Axes:</span>
    <span class="s2">&quot;&quot;&quot; 
    Add an Axes to the current figure and make it the current Axes. 
 
    Call signatures:: 
 
        plt.axes() 
        plt.axes(rect, projection=None, polar=False, **kwargs) 
        plt.axes(ax) 
 
    Parameters 
    ---------- 
    arg : None or 4-tuple 
        The exact behavior of this function depends on the type: 
 
        - *None*: A new full window Axes is added using 
          ``subplot(**kwargs)``. 
        - 4-tuple of floats *rect* = ``(left, bottom, width, height)``. 
          A new Axes is added with dimensions *rect* in normalized 
          (0, 1) units using `~.Figure.add_axes` on the current figure. 
 
    projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \ 
'polar', 'rectilinear', str}, optional 
        The projection type of the `~.axes.Axes`. *str* is the name of 
        a custom projection, see `~matplotlib.projections`. The default 
        None results in a 'rectilinear' projection. 
 
    polar : bool, default: False 
        If True, equivalent to projection='polar'. 
 
    sharex, sharey : `~matplotlib.axes.Axes`, optional 
        Share the x or y `~matplotlib.axis` with sharex and/or sharey. 
        The axis will have the same limits, ticks, and scale as the axis 
        of the shared Axes. 
 
    label : str 
        A label for the returned Axes. 
 
    Returns 
    ------- 
    `~.axes.Axes`, or a subclass of `~.axes.Axes` 
        The returned axes class depends on the projection used. It is 
        `~.axes.Axes` if rectilinear projection is used and 
        `.projections.polar.PolarAxes` if polar projection is used. 
 
    Other Parameters 
    ---------------- 
    **kwargs 
        This method also takes the keyword arguments for 
        the returned Axes class. The keyword arguments for the 
        rectilinear Axes class `~.axes.Axes` can be found in 
        the following table but there might also be other keyword 
        arguments if another projection is used, see the actual Axes 
        class. 
 
        %(Axes:kwdoc)s 
 
    See Also 
    -------- 
    .Figure.add_axes 
    .pyplot.subplot 
    .Figure.add_subplot 
    .Figure.subplots 
    .pyplot.subplots 
 
    Examples 
    -------- 
    :: 
 
        # Creating a new full window Axes 
        plt.axes() 
 
        # Creating a new Axes with specified dimensions and a grey background 
        plt.axes((left, bottom, width, height), facecolor='grey') 
    &quot;&quot;&quot;</span>
    <span class="s1">fig = gcf()</span>
    <span class="s1">pos = kwargs.pop(</span><span class="s4">'position'</span><span class="s3">, None</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">arg </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">pos </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">fig.add_subplot(**kwargs)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">fig.add_axes(pos</span><span class="s3">, </span><span class="s1">**kwargs)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">fig.add_axes(arg</span><span class="s3">, </span><span class="s1">**kwargs)</span>


<span class="s3">def </span><span class="s1">delaxes(ax: matplotlib.axes.Axes | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None</span><span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot; 
    Remove an `~.axes.Axes` (defaulting to the current axes) from its figure. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">ax </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">ax = gca()</span>
    <span class="s1">ax.remove()</span>


<span class="s3">def </span><span class="s1">sca(ax: Axes) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot; 
    Set the current Axes to *ax* and the current Figure to the parent of *ax*. 
    &quot;&quot;&quot;</span>
    <span class="s0"># Mypy sees ax.figure as potentially None,</span>
    <span class="s0"># but if you are calling this, it won't be None</span>
    <span class="s0"># Additionally the slight difference between `Figure` and `FigureBase` mypy catches</span>
    <span class="s1">figure(ax.figure)  </span><span class="s0"># type: ignore[arg-type]</span>
    <span class="s1">ax.figure.sca(ax)  </span><span class="s0"># type: ignore[union-attr]</span>


<span class="s3">def </span><span class="s1">cla() -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot;Clear the current axes.&quot;&quot;&quot;</span>
    <span class="s0"># Not generated via boilerplate.py to allow a different docstring.</span>
    <span class="s3">return </span><span class="s1">gca().cla()</span>


<span class="s0">## More ways of creating axes ##</span>

<span class="s1">@_docstring.dedent_interpd</span>
<span class="s3">def </span><span class="s1">subplot(*args</span><span class="s3">, </span><span class="s1">**kwargs) -&gt; Axes:</span>
    <span class="s2">&quot;&quot;&quot; 
    Add an Axes to the current figure or retrieve an existing Axes. 
 
    This is a wrapper of `.Figure.add_subplot` which provides additional 
    behavior when working with the implicit API (see the notes section). 
 
    Call signatures:: 
 
       subplot(nrows, ncols, index, **kwargs) 
       subplot(pos, **kwargs) 
       subplot(**kwargs) 
       subplot(ax) 
 
    Parameters 
    ---------- 
    *args : int, (int, int, *index*), or `.SubplotSpec`, default: (1, 1, 1) 
        The position of the subplot described by one of 
 
        - Three integers (*nrows*, *ncols*, *index*). The subplot will take the 
          *index* position on a grid with *nrows* rows and *ncols* columns. 
          *index* starts at 1 in the upper left corner and increases to the 
          right. *index* can also be a two-tuple specifying the (*first*, 
          *last*) indices (1-based, and including *last*) of the subplot, e.g., 
          ``fig.add_subplot(3, 1, (1, 2))`` makes a subplot that spans the 
          upper 2/3 of the figure. 
        - A 3-digit integer. The digits are interpreted as if given separately 
          as three single-digit integers, i.e. ``fig.add_subplot(235)`` is the 
          same as ``fig.add_subplot(2, 3, 5)``. Note that this can only be used 
          if there are no more than 9 subplots. 
        - A `.SubplotSpec`. 
 
    projection : {None, 'aitoff', 'hammer', 'lambert', 'mollweide', \ 
'polar', 'rectilinear', str}, optional 
        The projection type of the subplot (`~.axes.Axes`). *str* is the name 
        of a custom projection, see `~matplotlib.projections`. The default 
        None results in a 'rectilinear' projection. 
 
    polar : bool, default: False 
        If True, equivalent to projection='polar'. 
 
    sharex, sharey : `~matplotlib.axes.Axes`, optional 
        Share the x or y `~matplotlib.axis` with sharex and/or sharey. The 
        axis will have the same limits, ticks, and scale as the axis of the 
        shared axes. 
 
    label : str 
        A label for the returned axes. 
 
    Returns 
    ------- 
    `~.axes.Axes` 
 
        The Axes of the subplot. The returned Axes can actually be an instance 
        of a subclass, such as `.projections.polar.PolarAxes` for polar 
        projections. 
 
    Other Parameters 
    ---------------- 
    **kwargs 
        This method also takes the keyword arguments for the returned axes 
        base class; except for the *figure* argument. The keyword arguments 
        for the rectilinear base class `~.axes.Axes` can be found in 
        the following table but there might also be other keyword 
        arguments if another projection is used. 
 
        %(Axes:kwdoc)s 
 
    Notes 
    ----- 
    Creating a new Axes will delete any preexisting Axes that 
    overlaps with it beyond sharing a boundary:: 
 
        import matplotlib.pyplot as plt 
        # plot a line, implicitly creating a subplot(111) 
        plt.plot([1, 2, 3]) 
        # now create a subplot which represents the top plot of a grid 
        # with 2 rows and 1 column. Since this subplot will overlap the 
        # first, the plot (and its axes) previously created, will be removed 
        plt.subplot(211) 
 
    If you do not want this behavior, use the `.Figure.add_subplot` method 
    or the `.pyplot.axes` function instead. 
 
    If no *kwargs* are passed and there exists an Axes in the location 
    specified by *args* then that Axes will be returned rather than a new 
    Axes being created. 
 
    If *kwargs* are passed and there exists an Axes in the location 
    specified by *args*, the projection type is the same, and the 
    *kwargs* match with the existing Axes, then the existing Axes is 
    returned.  Otherwise a new Axes is created with the specified 
    parameters.  We save a reference to the *kwargs* which we use 
    for this comparison.  If any of the values in *kwargs* are 
    mutable we will not detect the case where they are mutated. 
    In these cases we suggest using `.Figure.add_subplot` and the 
    explicit Axes API rather than the implicit pyplot API. 
 
    See Also 
    -------- 
    .Figure.add_subplot 
    .pyplot.subplots 
    .pyplot.axes 
    .Figure.subplots 
 
    Examples 
    -------- 
    :: 
 
        plt.subplot(221) 
 
        # equivalent but more general 
        ax1 = plt.subplot(2, 2, 1) 
 
        # add a subplot with no frame 
        ax2 = plt.subplot(222, frameon=False) 
 
        # add a polar subplot 
        plt.subplot(223, projection='polar') 
 
        # add a red subplot that shares the x-axis with ax1 
        plt.subplot(224, sharex=ax1, facecolor='red') 
 
        # delete ax2 from the figure 
        plt.delaxes(ax2) 
 
        # add ax2 to the figure again 
        plt.subplot(ax2) 
 
        # make the first axes &quot;current&quot; again 
        plt.subplot(221) 
 
    &quot;&quot;&quot;</span>
    <span class="s0"># Here we will only normalize `polar=True` vs `projection='polar'` and let</span>
    <span class="s0"># downstream code deal with the rest.</span>
    <span class="s1">unset = object()</span>
    <span class="s1">projection = kwargs.get(</span><span class="s4">'projection'</span><span class="s3">, </span><span class="s1">unset)</span>
    <span class="s1">polar = kwargs.pop(</span><span class="s4">'polar'</span><span class="s3">, </span><span class="s1">unset)</span>
    <span class="s3">if </span><span class="s1">polar </span><span class="s3">is not </span><span class="s1">unset </span><span class="s3">and </span><span class="s1">polar:</span>
        <span class="s0"># if we got mixed messages from the user, raise</span>
        <span class="s3">if </span><span class="s1">projection </span><span class="s3">is not </span><span class="s1">unset </span><span class="s3">and </span><span class="s1">projection != </span><span class="s4">'polar'</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span>
                <span class="s4">f&quot;polar=</span><span class="s3">{</span><span class="s1">polar</span><span class="s3">}</span><span class="s4">, yet projection=</span><span class="s3">{</span><span class="s1">projection</span><span class="s3">!r}</span><span class="s4">. &quot;</span>
                <span class="s4">&quot;Only one of these arguments should be supplied.&quot;</span>
            <span class="s1">)</span>
        <span class="s1">kwargs[</span><span class="s4">'projection'</span><span class="s1">] = projection = </span><span class="s4">'polar'</span>

    <span class="s0"># if subplot called without arguments, create subplot(1, 1, 1)</span>
    <span class="s3">if </span><span class="s1">len(args) == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">args = (</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span>

    <span class="s0"># This check was added because it is very easy to type subplot(1, 2, False)</span>
    <span class="s0"># when subplots(1, 2, False) was intended (sharex=False, that is). In most</span>
    <span class="s0"># cases, no error will ever occur, but mysterious behavior can result</span>
    <span class="s0"># because what was intended to be the sharex argument is instead treated as</span>
    <span class="s0"># a subplot index for subplot()</span>
    <span class="s3">if </span><span class="s1">len(args) &gt;= </span><span class="s5">3 </span><span class="s3">and </span><span class="s1">isinstance(args[</span><span class="s5">2</span><span class="s1">]</span><span class="s3">, </span><span class="s1">bool):</span>
        <span class="s1">_api.warn_external(</span><span class="s4">&quot;The subplot index argument to subplot() appears &quot;</span>
                           <span class="s4">&quot;to be a boolean. Did you intend to use &quot;</span>
                           <span class="s4">&quot;subplots()?&quot;</span><span class="s1">)</span>
    <span class="s0"># Check for nrows and ncols, which are not valid subplot args:</span>
    <span class="s3">if </span><span class="s4">'nrows' </span><span class="s3">in </span><span class="s1">kwargs </span><span class="s3">or </span><span class="s4">'ncols' </span><span class="s3">in </span><span class="s1">kwargs:</span>
        <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;subplot() got an unexpected keyword argument 'ncols' &quot;</span>
                        <span class="s4">&quot;and/or 'nrows'.  Did you intend to call subplots()?&quot;</span><span class="s1">)</span>

    <span class="s1">fig = gcf()</span>

    <span class="s0"># First, search for an existing subplot with a matching spec.</span>
    <span class="s1">key = SubplotSpec._from_subplot_args(fig</span><span class="s3">, </span><span class="s1">args)</span>

    <span class="s3">for </span><span class="s1">ax </span><span class="s3">in </span><span class="s1">fig.axes:</span>
        <span class="s0"># If we found an Axes at the position, we can re-use it if the user passed no</span>
        <span class="s0"># kwargs or if the axes class and kwargs are identical.</span>
        <span class="s3">if </span><span class="s1">(ax.get_subplotspec() == key</span>
            <span class="s3">and </span><span class="s1">(kwargs == {}</span>
                 <span class="s3">or </span><span class="s1">(ax._projection_init</span>
                     <span class="s1">== fig._process_projection_requirements(**kwargs)))):</span>
            <span class="s3">break</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s0"># we have exhausted the known Axes and none match, make a new one!</span>
        <span class="s1">ax = fig.add_subplot(*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>

    <span class="s1">fig.sca(ax)</span>

    <span class="s3">return </span><span class="s1">ax</span>


<span class="s3">def </span><span class="s1">subplots(</span>
    <span class="s1">nrows: int = </span><span class="s5">1</span><span class="s3">, </span><span class="s1">ncols: int = </span><span class="s5">1</span><span class="s3">, </span><span class="s1">*</span><span class="s3">,</span>
    <span class="s1">sharex: bool | Literal[</span><span class="s4">&quot;none&quot;</span><span class="s3">, </span><span class="s4">&quot;all&quot;</span><span class="s3">, </span><span class="s4">&quot;row&quot;</span><span class="s3">, </span><span class="s4">&quot;col&quot;</span><span class="s1">] = </span><span class="s3">False,</span>
    <span class="s1">sharey: bool | Literal[</span><span class="s4">&quot;none&quot;</span><span class="s3">, </span><span class="s4">&quot;all&quot;</span><span class="s3">, </span><span class="s4">&quot;row&quot;</span><span class="s3">, </span><span class="s4">&quot;col&quot;</span><span class="s1">] = </span><span class="s3">False,</span>
    <span class="s1">squeeze: bool = </span><span class="s3">True,</span>
    <span class="s1">width_ratios: Sequence[float] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">height_ratios: Sequence[float] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">subplot_kw: dict[str</span><span class="s3">, </span><span class="s1">Any] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">gridspec_kw: dict[str</span><span class="s3">, </span><span class="s1">Any] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">**fig_kw</span>
<span class="s1">) -&gt; tuple[Figure</span><span class="s3">, </span><span class="s1">Any]:</span>
    <span class="s2">&quot;&quot;&quot; 
    Create a figure and a set of subplots. 
 
    This utility wrapper makes it convenient to create common layouts of 
    subplots, including the enclosing figure object, in a single call. 
 
    Parameters 
    ---------- 
    nrows, ncols : int, default: 1 
        Number of rows/columns of the subplot grid. 
 
    sharex, sharey : bool or {'none', 'all', 'row', 'col'}, default: False 
        Controls sharing of properties among x (*sharex*) or y (*sharey*) 
        axes: 
 
        - True or 'all': x- or y-axis will be shared among all subplots. 
        - False or 'none': each subplot x- or y-axis will be independent. 
        - 'row': each subplot row will share an x- or y-axis. 
        - 'col': each subplot column will share an x- or y-axis. 
 
        When subplots have a shared x-axis along a column, only the x tick 
        labels of the bottom subplot are created. Similarly, when subplots 
        have a shared y-axis along a row, only the y tick labels of the first 
        column subplot are created. To later turn other subplots' ticklabels 
        on, use `~matplotlib.axes.Axes.tick_params`. 
 
        When subplots have a shared axis that has units, calling 
        `~matplotlib.axis.Axis.set_units` will update each axis with the 
        new units. 
 
    squeeze : bool, default: True 
        - If True, extra dimensions are squeezed out from the returned 
          array of `~matplotlib.axes.Axes`: 
 
          - if only one subplot is constructed (nrows=ncols=1), the 
            resulting single Axes object is returned as a scalar. 
          - for Nx1 or 1xM subplots, the returned object is a 1D numpy 
            object array of Axes objects. 
          - for NxM, subplots with N&gt;1 and M&gt;1 are returned as a 2D array. 
 
        - If False, no squeezing at all is done: the returned Axes object is 
          always a 2D array containing Axes instances, even if it ends up 
          being 1x1. 
 
    width_ratios : array-like of length *ncols*, optional 
        Defines the relative widths of the columns. Each column gets a 
        relative width of ``width_ratios[i] / sum(width_ratios)``. 
        If not given, all columns will have the same width.  Equivalent 
        to ``gridspec_kw={'width_ratios': [...]}``. 
 
    height_ratios : array-like of length *nrows*, optional 
        Defines the relative heights of the rows. Each row gets a 
        relative height of ``height_ratios[i] / sum(height_ratios)``. 
        If not given, all rows will have the same height. Convenience 
        for ``gridspec_kw={'height_ratios': [...]}``. 
 
    subplot_kw : dict, optional 
        Dict with keywords passed to the 
        `~matplotlib.figure.Figure.add_subplot` call used to create each 
        subplot. 
 
    gridspec_kw : dict, optional 
        Dict with keywords passed to the `~matplotlib.gridspec.GridSpec` 
        constructor used to create the grid the subplots are placed on. 
 
    **fig_kw 
        All additional keyword arguments are passed to the 
        `.pyplot.figure` call. 
 
    Returns 
    ------- 
    fig : `.Figure` 
 
    ax : `~matplotlib.axes.Axes` or array of Axes 
        *ax* can be either a single `~.axes.Axes` object, or an array of Axes 
        objects if more than one subplot was created.  The dimensions of the 
        resulting array can be controlled with the squeeze keyword, see above. 
 
        Typical idioms for handling the return value are:: 
 
            # using the variable ax for single a Axes 
            fig, ax = plt.subplots() 
 
            # using the variable axs for multiple Axes 
            fig, axs = plt.subplots(2, 2) 
 
            # using tuple unpacking for multiple Axes 
            fig, (ax1, ax2) = plt.subplots(1, 2) 
            fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2) 
 
        The names ``ax`` and pluralized ``axs`` are preferred over ``axes`` 
        because for the latter it's not clear if it refers to a single 
        `~.axes.Axes` instance or a collection of these. 
 
    See Also 
    -------- 
    .pyplot.figure 
    .pyplot.subplot 
    .pyplot.axes 
    .Figure.subplots 
    .Figure.add_subplot 
 
    Examples 
    -------- 
    :: 
 
        # First create some toy data: 
        x = np.linspace(0, 2*np.pi, 400) 
        y = np.sin(x**2) 
 
        # Create just a figure and only one subplot 
        fig, ax = plt.subplots() 
        ax.plot(x, y) 
        ax.set_title('Simple plot') 
 
        # Create two subplots and unpack the output array immediately 
        f, (ax1, ax2) = plt.subplots(1, 2, sharey=True) 
        ax1.plot(x, y) 
        ax1.set_title('Sharing Y axis') 
        ax2.scatter(x, y) 
 
        # Create four polar axes and access them through the returned array 
        fig, axs = plt.subplots(2, 2, subplot_kw=dict(projection=&quot;polar&quot;)) 
        axs[0, 0].plot(x, y) 
        axs[1, 1].scatter(x, y) 
 
        # Share a X axis with each column of subplots 
        plt.subplots(2, 2, sharex='col') 
 
        # Share a Y axis with each row of subplots 
        plt.subplots(2, 2, sharey='row') 
 
        # Share both X and Y axes with all subplots 
        plt.subplots(2, 2, sharex='all', sharey='all') 
 
        # Note that this is the same as 
        plt.subplots(2, 2, sharex=True, sharey=True) 
 
        # Create figure number 10 with a single subplot 
        # and clears it if it already exists. 
        fig, ax = plt.subplots(num=10, clear=True) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">fig = figure(**fig_kw)</span>
    <span class="s1">axs = fig.subplots(nrows=nrows</span><span class="s3">, </span><span class="s1">ncols=ncols</span><span class="s3">, </span><span class="s1">sharex=sharex</span><span class="s3">, </span><span class="s1">sharey=sharey</span><span class="s3">,</span>
                       <span class="s1">squeeze=squeeze</span><span class="s3">, </span><span class="s1">subplot_kw=subplot_kw</span><span class="s3">,</span>
                       <span class="s1">gridspec_kw=gridspec_kw</span><span class="s3">, </span><span class="s1">height_ratios=height_ratios</span><span class="s3">,</span>
                       <span class="s1">width_ratios=width_ratios)</span>
    <span class="s3">return </span><span class="s1">fig</span><span class="s3">, </span><span class="s1">axs</span>


<span class="s1">@overload</span>
<span class="s3">def </span><span class="s1">subplot_mosaic(</span>
    <span class="s1">mosaic: str</span><span class="s3">,</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">sharex: bool = ...</span><span class="s3">,</span>
    <span class="s1">sharey: bool = ...</span><span class="s3">,</span>
    <span class="s1">width_ratios: ArrayLike | </span><span class="s3">None </span><span class="s1">= ...</span><span class="s3">,</span>
    <span class="s1">height_ratios: ArrayLike | </span><span class="s3">None </span><span class="s1">= ...</span><span class="s3">,</span>
    <span class="s1">empty_sentinel: str = ...</span><span class="s3">,</span>
    <span class="s1">subplot_kw: dict[str</span><span class="s3">, </span><span class="s1">Any] | </span><span class="s3">None </span><span class="s1">= ...</span><span class="s3">,</span>
    <span class="s1">gridspec_kw: dict[str</span><span class="s3">, </span><span class="s1">Any] | </span><span class="s3">None </span><span class="s1">= ...</span><span class="s3">,</span>
    <span class="s1">per_subplot_kw: dict[str | tuple[str</span><span class="s3">, </span><span class="s1">...]</span><span class="s3">, </span><span class="s1">dict[str</span><span class="s3">, </span><span class="s1">Any]] | </span><span class="s3">None </span><span class="s1">= ...</span><span class="s3">,</span>
    <span class="s1">**fig_kw: Any</span>
<span class="s1">) -&gt; tuple[Figure</span><span class="s3">, </span><span class="s1">dict[str</span><span class="s3">, </span><span class="s1">matplotlib.axes.Axes]]: ...</span>


<span class="s1">@overload</span>
<span class="s3">def </span><span class="s1">subplot_mosaic(</span>
    <span class="s1">mosaic: list[HashableList[_T]]</span><span class="s3">,</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">sharex: bool = ...</span><span class="s3">,</span>
    <span class="s1">sharey: bool = ...</span><span class="s3">,</span>
    <span class="s1">width_ratios: ArrayLike | </span><span class="s3">None </span><span class="s1">= ...</span><span class="s3">,</span>
    <span class="s1">height_ratios: ArrayLike | </span><span class="s3">None </span><span class="s1">= ...</span><span class="s3">,</span>
    <span class="s1">empty_sentinel: _T = ...</span><span class="s3">,</span>
    <span class="s1">subplot_kw: dict[str</span><span class="s3">, </span><span class="s1">Any] | </span><span class="s3">None </span><span class="s1">= ...</span><span class="s3">,</span>
    <span class="s1">gridspec_kw: dict[str</span><span class="s3">, </span><span class="s1">Any] | </span><span class="s3">None </span><span class="s1">= ...</span><span class="s3">,</span>
    <span class="s1">per_subplot_kw: dict[_T | tuple[_T</span><span class="s3">, </span><span class="s1">...]</span><span class="s3">, </span><span class="s1">dict[str</span><span class="s3">, </span><span class="s1">Any]] | </span><span class="s3">None </span><span class="s1">= ...</span><span class="s3">,</span>
    <span class="s1">**fig_kw: Any</span>
<span class="s1">) -&gt; tuple[Figure</span><span class="s3">, </span><span class="s1">dict[_T</span><span class="s3">, </span><span class="s1">matplotlib.axes.Axes]]: ...</span>


<span class="s1">@overload</span>
<span class="s3">def </span><span class="s1">subplot_mosaic(</span>
    <span class="s1">mosaic: list[HashableList[Hashable]]</span><span class="s3">,</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">sharex: bool = ...</span><span class="s3">,</span>
    <span class="s1">sharey: bool = ...</span><span class="s3">,</span>
    <span class="s1">width_ratios: ArrayLike | </span><span class="s3">None </span><span class="s1">= ...</span><span class="s3">,</span>
    <span class="s1">height_ratios: ArrayLike | </span><span class="s3">None </span><span class="s1">= ...</span><span class="s3">,</span>
    <span class="s1">empty_sentinel: Any = ...</span><span class="s3">,</span>
    <span class="s1">subplot_kw: dict[str</span><span class="s3">, </span><span class="s1">Any] | </span><span class="s3">None </span><span class="s1">= ...</span><span class="s3">,</span>
    <span class="s1">gridspec_kw: dict[str</span><span class="s3">, </span><span class="s1">Any] | </span><span class="s3">None </span><span class="s1">= ...</span><span class="s3">,</span>
    <span class="s1">per_subplot_kw: dict[Hashable | tuple[Hashable</span><span class="s3">, </span><span class="s1">...]</span><span class="s3">, </span><span class="s1">dict[str</span><span class="s3">, </span><span class="s1">Any]] | </span><span class="s3">None </span><span class="s1">= ...</span><span class="s3">,</span>
    <span class="s1">**fig_kw: Any</span>
<span class="s1">) -&gt; tuple[Figure</span><span class="s3">, </span><span class="s1">dict[Hashable</span><span class="s3">, </span><span class="s1">matplotlib.axes.Axes]]: ...</span>


<span class="s3">def </span><span class="s1">subplot_mosaic(</span>
    <span class="s1">mosaic: str | list[HashableList[_T]] | list[HashableList[Hashable]]</span><span class="s3">,</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">sharex: bool = </span><span class="s3">False,</span>
    <span class="s1">sharey: bool = </span><span class="s3">False,</span>
    <span class="s1">width_ratios: ArrayLike | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">height_ratios: ArrayLike | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">empty_sentinel: Any = </span><span class="s4">'.'</span><span class="s3">,</span>
    <span class="s1">subplot_kw: dict[str</span><span class="s3">, </span><span class="s1">Any] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">gridspec_kw: dict[str</span><span class="s3">, </span><span class="s1">Any] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">per_subplot_kw: dict[str | tuple[str</span><span class="s3">, </span><span class="s1">...]</span><span class="s3">, </span><span class="s1">dict[str</span><span class="s3">, </span><span class="s1">Any]] |</span>
                    <span class="s1">dict[_T | tuple[_T</span><span class="s3">, </span><span class="s1">...]</span><span class="s3">, </span><span class="s1">dict[str</span><span class="s3">, </span><span class="s1">Any]] |</span>
                    <span class="s1">dict[Hashable | tuple[Hashable</span><span class="s3">, </span><span class="s1">...]</span><span class="s3">, </span><span class="s1">dict[str</span><span class="s3">, </span><span class="s1">Any]] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">**fig_kw: Any</span>
<span class="s1">) -&gt; tuple[Figure</span><span class="s3">, </span><span class="s1">dict[str</span><span class="s3">, </span><span class="s1">matplotlib.axes.Axes]] | \</span>
     <span class="s1">tuple[Figure</span><span class="s3">, </span><span class="s1">dict[_T</span><span class="s3">, </span><span class="s1">matplotlib.axes.Axes]] | \</span>
     <span class="s1">tuple[Figure</span><span class="s3">, </span><span class="s1">dict[Hashable</span><span class="s3">, </span><span class="s1">matplotlib.axes.Axes]]:</span>
    <span class="s2">&quot;&quot;&quot; 
    Build a layout of Axes based on ASCII art or nested lists. 
 
    This is a helper function to build complex GridSpec layouts visually. 
 
    See :ref:`mosaic` 
    for an example and full API documentation 
 
    Parameters 
    ---------- 
    mosaic : list of list of {hashable or nested} or str 
 
        A visual layout of how you want your Axes to be arranged 
        labeled as strings.  For example :: 
 
           x = [['A panel', 'A panel', 'edge'], 
                ['C panel', '.',       'edge']] 
 
        produces 4 axes: 
 
        - 'A panel' which is 1 row high and spans the first two columns 
        - 'edge' which is 2 rows high and is on the right edge 
        - 'C panel' which in 1 row and 1 column wide in the bottom left 
        - a blank space 1 row and 1 column wide in the bottom center 
 
        Any of the entries in the layout can be a list of lists 
        of the same form to create nested layouts. 
 
        If input is a str, then it must be of the form :: 
 
          ''' 
          AAE 
          C.E 
          ''' 
 
        where each character is a column and each line is a row. 
        This only allows only single character Axes labels and does 
        not allow nesting but is very terse. 
 
    sharex, sharey : bool, default: False 
        If True, the x-axis (*sharex*) or y-axis (*sharey*) will be shared 
        among all subplots.  In that case, tick label visibility and axis units 
        behave as for `subplots`.  If False, each subplot's x- or y-axis will 
        be independent. 
 
    width_ratios : array-like of length *ncols*, optional 
        Defines the relative widths of the columns. Each column gets a 
        relative width of ``width_ratios[i] / sum(width_ratios)``. 
        If not given, all columns will have the same width.  Convenience 
        for ``gridspec_kw={'width_ratios': [...]}``. 
 
    height_ratios : array-like of length *nrows*, optional 
        Defines the relative heights of the rows. Each row gets a 
        relative height of ``height_ratios[i] / sum(height_ratios)``. 
        If not given, all rows will have the same height. Convenience 
        for ``gridspec_kw={'height_ratios': [...]}``. 
 
    empty_sentinel : object, optional 
        Entry in the layout to mean &quot;leave this space empty&quot;.  Defaults 
        to ``'.'``. Note, if *layout* is a string, it is processed via 
        `inspect.cleandoc` to remove leading white space, which may 
        interfere with using white-space as the empty sentinel. 
 
    subplot_kw : dict, optional 
        Dictionary with keywords passed to the `.Figure.add_subplot` call 
        used to create each subplot.  These values may be overridden by 
        values in *per_subplot_kw*. 
 
    per_subplot_kw : dict, optional 
        A dictionary mapping the Axes identifiers or tuples of identifiers 
        to a dictionary of keyword arguments to be passed to the 
        `.Figure.add_subplot` call used to create each subplot.  The values 
        in these dictionaries have precedence over the values in 
        *subplot_kw*. 
 
        If *mosaic* is a string, and thus all keys are single characters, 
        it is possible to use a single string instead of a tuple as keys; 
        i.e. ``&quot;AB&quot;`` is equivalent to ``(&quot;A&quot;, &quot;B&quot;)``. 
 
        .. versionadded:: 3.7 
 
    gridspec_kw : dict, optional 
        Dictionary with keywords passed to the `.GridSpec` constructor used 
        to create the grid the subplots are placed on. 
 
    **fig_kw 
        All additional keyword arguments are passed to the 
        `.pyplot.figure` call. 
 
    Returns 
    ------- 
    fig : `.Figure` 
       The new figure 
 
    dict[label, Axes] 
       A dictionary mapping the labels to the Axes objects.  The order of 
       the axes is left-to-right and top-to-bottom of their position in the 
       total layout. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">fig = figure(**fig_kw)</span>
    <span class="s1">ax_dict = fig.subplot_mosaic(  </span><span class="s0"># type: ignore[misc]</span>
        <span class="s1">mosaic</span><span class="s3">,  </span><span class="s0"># type: ignore[arg-type]</span>
        <span class="s1">sharex=sharex</span><span class="s3">, </span><span class="s1">sharey=sharey</span><span class="s3">,</span>
        <span class="s1">height_ratios=height_ratios</span><span class="s3">, </span><span class="s1">width_ratios=width_ratios</span><span class="s3">,</span>
        <span class="s1">subplot_kw=subplot_kw</span><span class="s3">, </span><span class="s1">gridspec_kw=gridspec_kw</span><span class="s3">,</span>
        <span class="s1">empty_sentinel=empty_sentinel</span><span class="s3">,</span>
        <span class="s1">per_subplot_kw=per_subplot_kw</span><span class="s3">,  </span><span class="s0"># type: ignore[arg-type]</span>
    <span class="s1">)</span>
    <span class="s3">return </span><span class="s1">fig</span><span class="s3">, </span><span class="s1">ax_dict</span>


<span class="s3">def </span><span class="s1">subplot2grid(</span>
    <span class="s1">shape: tuple[int</span><span class="s3">, </span><span class="s1">int]</span><span class="s3">, </span><span class="s1">loc: tuple[int</span><span class="s3">, </span><span class="s1">int]</span><span class="s3">,</span>
    <span class="s1">rowspan: int = </span><span class="s5">1</span><span class="s3">, </span><span class="s1">colspan: int = </span><span class="s5">1</span><span class="s3">,</span>
    <span class="s1">fig: Figure | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">**kwargs</span>
<span class="s1">) -&gt; matplotlib.axes.Axes:</span>
    <span class="s2">&quot;&quot;&quot; 
    Create a subplot at a specific location inside a regular grid. 
 
    Parameters 
    ---------- 
    shape : (int, int) 
        Number of rows and of columns of the grid in which to place axis. 
    loc : (int, int) 
        Row number and column number of the axis location within the grid. 
    rowspan : int, default: 1 
        Number of rows for the axis to span downwards. 
    colspan : int, default: 1 
        Number of columns for the axis to span to the right. 
    fig : `.Figure`, optional 
        Figure to place the subplot in. Defaults to the current figure. 
    **kwargs 
        Additional keyword arguments are handed to `~.Figure.add_subplot`. 
 
    Returns 
    ------- 
    `~.axes.Axes` 
 
        The Axes of the subplot. The returned Axes can actually be an instance 
        of a subclass, such as `.projections.polar.PolarAxes` for polar 
        projections. 
 
    Notes 
    ----- 
    The following call :: 
 
        ax = subplot2grid((nrows, ncols), (row, col), rowspan, colspan) 
 
    is identical to :: 
 
        fig = gcf() 
        gs = fig.add_gridspec(nrows, ncols) 
        ax = fig.add_subplot(gs[row:row+rowspan, col:col+colspan]) 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">fig </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">fig = gcf()</span>
    <span class="s1">rows</span><span class="s3">, </span><span class="s1">cols = shape</span>
    <span class="s1">gs = GridSpec._check_gridspec_exists(fig</span><span class="s3">, </span><span class="s1">rows</span><span class="s3">, </span><span class="s1">cols)</span>
    <span class="s1">subplotspec = gs.new_subplotspec(loc</span><span class="s3">, </span><span class="s1">rowspan=rowspan</span><span class="s3">, </span><span class="s1">colspan=colspan)</span>
    <span class="s3">return </span><span class="s1">fig.add_subplot(subplotspec</span><span class="s3">, </span><span class="s1">**kwargs)</span>


<span class="s3">def </span><span class="s1">twinx(ax: matplotlib.axes.Axes | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None</span><span class="s1">) -&gt; _AxesBase:</span>
    <span class="s2">&quot;&quot;&quot; 
    Make and return a second axes that shares the *x*-axis.  The new axes will 
    overlay *ax* (or the current axes if *ax* is *None*), and its ticks will be 
    on the right. 
 
    Examples 
    -------- 
    :doc:`/gallery/subplots_axes_and_figures/two_scales` 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">ax </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">ax = gca()</span>
    <span class="s1">ax1 = ax.twinx()</span>
    <span class="s3">return </span><span class="s1">ax1</span>


<span class="s3">def </span><span class="s1">twiny(ax: matplotlib.axes.Axes | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None</span><span class="s1">) -&gt; _AxesBase:</span>
    <span class="s2">&quot;&quot;&quot; 
    Make and return a second axes that shares the *y*-axis.  The new axes will 
    overlay *ax* (or the current axes if *ax* is *None*), and its ticks will be 
    on the top. 
 
    Examples 
    -------- 
    :doc:`/gallery/subplots_axes_and_figures/two_scales` 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">ax </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">ax = gca()</span>
    <span class="s1">ax1 = ax.twiny()</span>
    <span class="s3">return </span><span class="s1">ax1</span>


<span class="s3">def </span><span class="s1">subplot_tool(targetfig: Figure | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None</span><span class="s1">) -&gt; SubplotTool | </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot; 
    Launch a subplot tool window for a figure. 
 
    Returns 
    ------- 
    `matplotlib.widgets.SubplotTool` 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">targetfig </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">targetfig = gcf()</span>
    <span class="s1">tb = targetfig.canvas.manager.toolbar  </span><span class="s0"># type: ignore[union-attr]</span>
    <span class="s3">if </span><span class="s1">hasattr(tb</span><span class="s3">, </span><span class="s4">&quot;configure_subplots&quot;</span><span class="s1">):  </span><span class="s0"># toolbar2</span>
        <span class="s3">from </span><span class="s1">matplotlib.backend_bases </span><span class="s3">import </span><span class="s1">NavigationToolbar2</span>
        <span class="s3">return </span><span class="s1">cast(NavigationToolbar2</span><span class="s3">, </span><span class="s1">tb).configure_subplots()</span>
    <span class="s3">elif </span><span class="s1">hasattr(tb</span><span class="s3">, </span><span class="s4">&quot;trigger_tool&quot;</span><span class="s1">):  </span><span class="s0"># toolmanager</span>
        <span class="s3">from </span><span class="s1">matplotlib.backend_bases </span><span class="s3">import </span><span class="s1">ToolContainerBase</span>
        <span class="s1">cast(ToolContainerBase</span><span class="s3">, </span><span class="s1">tb).trigger_tool(</span><span class="s4">&quot;subplots&quot;</span><span class="s1">)</span>
        <span class="s3">return None</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;subplot_tool can only be launched for figures with &quot;</span>
                         <span class="s4">&quot;an associated toolbar&quot;</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">box(on: bool | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None</span><span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot; 
    Turn the axes box on or off on the current axes. 
 
    Parameters 
    ---------- 
    on : bool or None 
        The new `~matplotlib.axes.Axes` box state. If ``None``, toggle 
        the state. 
 
    See Also 
    -------- 
    :meth:`matplotlib.axes.Axes.set_frame_on` 
    :meth:`matplotlib.axes.Axes.get_frame_on` 
    &quot;&quot;&quot;</span>
    <span class="s1">ax = gca()</span>
    <span class="s3">if </span><span class="s1">on </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">on = </span><span class="s3">not </span><span class="s1">ax.get_frame_on()</span>
    <span class="s1">ax.set_frame_on(on)</span>

<span class="s0">## Axis ##</span>


<span class="s3">def </span><span class="s1">xlim(*args</span><span class="s3">, </span><span class="s1">**kwargs) -&gt; tuple[float</span><span class="s3">, </span><span class="s1">float]:</span>
    <span class="s2">&quot;&quot;&quot; 
    Get or set the x limits of the current axes. 
 
    Call signatures:: 
 
        left, right = xlim()  # return the current xlim 
        xlim((left, right))   # set the xlim to left, right 
        xlim(left, right)     # set the xlim to left, right 
 
    If you do not specify args, you can pass *left* or *right* as kwargs, 
    i.e.:: 
 
        xlim(right=3)  # adjust the right leaving left unchanged 
        xlim(left=1)  # adjust the left leaving right unchanged 
 
    Setting limits turns autoscaling off for the x-axis. 
 
    Returns 
    ------- 
    left, right 
        A tuple of the new x-axis limits. 
 
    Notes 
    ----- 
    Calling this function with no arguments (e.g. ``xlim()``) is the pyplot 
    equivalent of calling `~.Axes.get_xlim` on the current axes. 
    Calling this function with arguments is the pyplot equivalent of calling 
    `~.Axes.set_xlim` on the current axes. All arguments are passed though. 
    &quot;&quot;&quot;</span>
    <span class="s1">ax = gca()</span>
    <span class="s3">if not </span><span class="s1">args </span><span class="s3">and not </span><span class="s1">kwargs:</span>
        <span class="s3">return </span><span class="s1">ax.get_xlim()</span>
    <span class="s1">ret = ax.set_xlim(*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>
    <span class="s3">return </span><span class="s1">ret</span>


<span class="s3">def </span><span class="s1">ylim(*args</span><span class="s3">, </span><span class="s1">**kwargs) -&gt; tuple[float</span><span class="s3">, </span><span class="s1">float]:</span>
    <span class="s2">&quot;&quot;&quot; 
    Get or set the y-limits of the current axes. 
 
    Call signatures:: 
 
        bottom, top = ylim()  # return the current ylim 
        ylim((bottom, top))   # set the ylim to bottom, top 
        ylim(bottom, top)     # set the ylim to bottom, top 
 
    If you do not specify args, you can alternatively pass *bottom* or 
    *top* as kwargs, i.e.:: 
 
        ylim(top=3)  # adjust the top leaving bottom unchanged 
        ylim(bottom=1)  # adjust the bottom leaving top unchanged 
 
    Setting limits turns autoscaling off for the y-axis. 
 
    Returns 
    ------- 
    bottom, top 
        A tuple of the new y-axis limits. 
 
    Notes 
    ----- 
    Calling this function with no arguments (e.g. ``ylim()``) is the pyplot 
    equivalent of calling `~.Axes.get_ylim` on the current axes. 
    Calling this function with arguments is the pyplot equivalent of calling 
    `~.Axes.set_ylim` on the current axes. All arguments are passed though. 
    &quot;&quot;&quot;</span>
    <span class="s1">ax = gca()</span>
    <span class="s3">if not </span><span class="s1">args </span><span class="s3">and not </span><span class="s1">kwargs:</span>
        <span class="s3">return </span><span class="s1">ax.get_ylim()</span>
    <span class="s1">ret = ax.set_ylim(*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>
    <span class="s3">return </span><span class="s1">ret</span>


<span class="s3">def </span><span class="s1">xticks(</span>
    <span class="s1">ticks: ArrayLike | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">labels: Sequence[str] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">minor: bool = </span><span class="s3">False,</span>
    <span class="s1">**kwargs</span>
<span class="s1">) -&gt; tuple[list[Tick] | np.ndarray</span><span class="s3">, </span><span class="s1">list[Text]]:</span>
    <span class="s2">&quot;&quot;&quot; 
    Get or set the current tick locations and labels of the x-axis. 
 
    Pass no arguments to return the current values without modifying them. 
 
    Parameters 
    ---------- 
    ticks : array-like, optional 
        The list of xtick locations.  Passing an empty list removes all xticks. 
    labels : array-like, optional 
        The labels to place at the given *ticks* locations.  This argument can 
        only be passed if *ticks* is passed as well. 
    minor : bool, default: False 
        If ``False``, get/set the major ticks/labels; if ``True``, the minor 
        ticks/labels. 
    **kwargs 
        `.Text` properties can be used to control the appearance of the labels. 
 
    Returns 
    ------- 
    locs 
        The list of xtick locations. 
    labels 
        The list of xlabel `.Text` objects. 
 
    Notes 
    ----- 
    Calling this function with no arguments (e.g. ``xticks()``) is the pyplot 
    equivalent of calling `~.Axes.get_xticks` and `~.Axes.get_xticklabels` on 
    the current axes. 
    Calling this function with arguments is the pyplot equivalent of calling 
    `~.Axes.set_xticks` and `~.Axes.set_xticklabels` on the current axes. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; locs, labels = xticks()  # Get the current locations and labels. 
    &gt;&gt;&gt; xticks(np.arange(0, 1, step=0.2))  # Set label locations. 
    &gt;&gt;&gt; xticks(np.arange(3), ['Tom', 'Dick', 'Sue'])  # Set text labels. 
    &gt;&gt;&gt; xticks([0, 1, 2], ['January', 'February', 'March'], 
    ...        rotation=20)  # Set text labels and properties. 
    &gt;&gt;&gt; xticks([])  # Disable xticks. 
    &quot;&quot;&quot;</span>
    <span class="s1">ax = gca()</span>

    <span class="s1">locs: list[Tick] | np.ndarray</span>
    <span class="s3">if </span><span class="s1">ticks </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">locs = ax.get_xticks(minor=minor)</span>
        <span class="s3">if </span><span class="s1">labels </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;xticks(): Parameter 'labels' can't be set &quot;</span>
                            <span class="s4">&quot;without setting 'ticks'&quot;</span><span class="s1">)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">locs = ax.set_xticks(ticks</span><span class="s3">, </span><span class="s1">minor=minor)</span>

    <span class="s1">labels_out: list[Text] = []</span>
    <span class="s3">if </span><span class="s1">labels </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">labels_out = ax.get_xticklabels(minor=minor)</span>
        <span class="s3">for </span><span class="s1">l </span><span class="s3">in </span><span class="s1">labels_out:</span>
            <span class="s1">l._internal_update(kwargs)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">labels_out = ax.set_xticklabels(labels</span><span class="s3">, </span><span class="s1">minor=minor</span><span class="s3">, </span><span class="s1">**kwargs)</span>

    <span class="s3">return </span><span class="s1">locs</span><span class="s3">, </span><span class="s1">labels_out</span>


<span class="s3">def </span><span class="s1">yticks(</span>
    <span class="s1">ticks: ArrayLike | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">labels: Sequence[str] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">minor: bool = </span><span class="s3">False,</span>
    <span class="s1">**kwargs</span>
<span class="s1">) -&gt; tuple[list[Tick] | np.ndarray</span><span class="s3">, </span><span class="s1">list[Text]]:</span>
    <span class="s2">&quot;&quot;&quot; 
    Get or set the current tick locations and labels of the y-axis. 
 
    Pass no arguments to return the current values without modifying them. 
 
    Parameters 
    ---------- 
    ticks : array-like, optional 
        The list of ytick locations.  Passing an empty list removes all yticks. 
    labels : array-like, optional 
        The labels to place at the given *ticks* locations.  This argument can 
        only be passed if *ticks* is passed as well. 
    minor : bool, default: False 
        If ``False``, get/set the major ticks/labels; if ``True``, the minor 
        ticks/labels. 
    **kwargs 
        `.Text` properties can be used to control the appearance of the labels. 
 
    Returns 
    ------- 
    locs 
        The list of ytick locations. 
    labels 
        The list of ylabel `.Text` objects. 
 
    Notes 
    ----- 
    Calling this function with no arguments (e.g. ``yticks()``) is the pyplot 
    equivalent of calling `~.Axes.get_yticks` and `~.Axes.get_yticklabels` on 
    the current axes. 
    Calling this function with arguments is the pyplot equivalent of calling 
    `~.Axes.set_yticks` and `~.Axes.set_yticklabels` on the current axes. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; locs, labels = yticks()  # Get the current locations and labels. 
    &gt;&gt;&gt; yticks(np.arange(0, 1, step=0.2))  # Set label locations. 
    &gt;&gt;&gt; yticks(np.arange(3), ['Tom', 'Dick', 'Sue'])  # Set text labels. 
    &gt;&gt;&gt; yticks([0, 1, 2], ['January', 'February', 'March'], 
    ...        rotation=45)  # Set text labels and properties. 
    &gt;&gt;&gt; yticks([])  # Disable yticks. 
    &quot;&quot;&quot;</span>
    <span class="s1">ax = gca()</span>

    <span class="s1">locs: list[Tick] | np.ndarray</span>
    <span class="s3">if </span><span class="s1">ticks </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">locs = ax.get_yticks(minor=minor)</span>
        <span class="s3">if </span><span class="s1">labels </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;yticks(): Parameter 'labels' can't be set &quot;</span>
                            <span class="s4">&quot;without setting 'ticks'&quot;</span><span class="s1">)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">locs = ax.set_yticks(ticks</span><span class="s3">, </span><span class="s1">minor=minor)</span>

    <span class="s1">labels_out: list[Text] = []</span>
    <span class="s3">if </span><span class="s1">labels </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">labels_out = ax.get_yticklabels(minor=minor)</span>
        <span class="s3">for </span><span class="s1">l </span><span class="s3">in </span><span class="s1">labels_out:</span>
            <span class="s1">l._internal_update(kwargs)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">labels_out = ax.set_yticklabels(labels</span><span class="s3">, </span><span class="s1">minor=minor</span><span class="s3">, </span><span class="s1">**kwargs)</span>

    <span class="s3">return </span><span class="s1">locs</span><span class="s3">, </span><span class="s1">labels_out</span>


<span class="s3">def </span><span class="s1">rgrids(</span>
    <span class="s1">radii: ArrayLike | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">labels: Sequence[str | Text] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">angle: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">fmt: str | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">**kwargs</span>
<span class="s1">) -&gt; tuple[list[Line2D]</span><span class="s3">, </span><span class="s1">list[Text]]:</span>
    <span class="s2">&quot;&quot;&quot; 
    Get or set the radial gridlines on the current polar plot. 
 
    Call signatures:: 
 
     lines, labels = rgrids() 
     lines, labels = rgrids(radii, labels=None, angle=22.5, fmt=None, **kwargs) 
 
    When called with no arguments, `.rgrids` simply returns the tuple 
    (*lines*, *labels*). When called with arguments, the labels will 
    appear at the specified radial distances and angle. 
 
    Parameters 
    ---------- 
    radii : tuple with floats 
        The radii for the radial gridlines 
 
    labels : tuple with strings or None 
        The labels to use at each radial gridline. The 
        `matplotlib.ticker.ScalarFormatter` will be used if None. 
 
    angle : float 
        The angular position of the radius labels in degrees. 
 
    fmt : str or None 
        Format string used in `matplotlib.ticker.FormatStrFormatter`. 
        For example '%f'. 
 
    Returns 
    ------- 
    lines : list of `.lines.Line2D` 
        The radial gridlines. 
 
    labels : list of `.text.Text` 
        The tick labels. 
 
    Other Parameters 
    ---------------- 
    **kwargs 
        *kwargs* are optional `.Text` properties for the labels. 
 
    See Also 
    -------- 
    .pyplot.thetagrids 
    .projections.polar.PolarAxes.set_rgrids 
    .Axis.get_gridlines 
    .Axis.get_ticklabels 
 
    Examples 
    -------- 
    :: 
 
      # set the locations of the radial gridlines 
      lines, labels = rgrids( (0.25, 0.5, 1.0) ) 
 
      # set the locations and labels of the radial gridlines 
      lines, labels = rgrids( (0.25, 0.5, 1.0), ('Tom', 'Dick', 'Harry' )) 
    &quot;&quot;&quot;</span>
    <span class="s1">ax = gca()</span>
    <span class="s3">if not </span><span class="s1">isinstance(ax</span><span class="s3">, </span><span class="s1">PolarAxes):</span>
        <span class="s3">raise </span><span class="s1">RuntimeError(</span><span class="s4">'rgrids only defined for polar axes'</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">all(p </span><span class="s3">is None for </span><span class="s1">p </span><span class="s3">in </span><span class="s1">[radii</span><span class="s3">, </span><span class="s1">labels</span><span class="s3">, </span><span class="s1">angle</span><span class="s3">, </span><span class="s1">fmt]) </span><span class="s3">and not </span><span class="s1">kwargs:</span>
        <span class="s1">lines_out: list[Line2D] = ax.yaxis.get_gridlines()</span>
        <span class="s1">labels_out: list[Text] = ax.yaxis.get_ticklabels()</span>
    <span class="s3">elif </span><span class="s1">radii </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;'radii' cannot be None when other parameters are passed&quot;</span><span class="s1">)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">lines_out</span><span class="s3">, </span><span class="s1">labels_out = ax.set_rgrids(</span>
            <span class="s1">radii</span><span class="s3">, </span><span class="s1">labels=labels</span><span class="s3">, </span><span class="s1">angle=angle</span><span class="s3">, </span><span class="s1">fmt=fmt</span><span class="s3">, </span><span class="s1">**kwargs)</span>
    <span class="s3">return </span><span class="s1">lines_out</span><span class="s3">, </span><span class="s1">labels_out</span>


<span class="s3">def </span><span class="s1">thetagrids(</span>
    <span class="s1">angles: ArrayLike | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">labels: Sequence[str | Text] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">fmt: str | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">**kwargs</span>
<span class="s1">) -&gt; tuple[list[Line2D]</span><span class="s3">, </span><span class="s1">list[Text]]:</span>
    <span class="s2">&quot;&quot;&quot; 
    Get or set the theta gridlines on the current polar plot. 
 
    Call signatures:: 
 
     lines, labels = thetagrids() 
     lines, labels = thetagrids(angles, labels=None, fmt=None, **kwargs) 
 
    When called with no arguments, `.thetagrids` simply returns the tuple 
    (*lines*, *labels*). When called with arguments, the labels will 
    appear at the specified angles. 
 
    Parameters 
    ---------- 
    angles : tuple with floats, degrees 
        The angles of the theta gridlines. 
 
    labels : tuple with strings or None 
        The labels to use at each radial gridline. The 
        `.projections.polar.ThetaFormatter` will be used if None. 
 
    fmt : str or None 
        Format string used in `matplotlib.ticker.FormatStrFormatter`. 
        For example '%f'. Note that the angle in radians will be used. 
 
    Returns 
    ------- 
    lines : list of `.lines.Line2D` 
        The theta gridlines. 
 
    labels : list of `.text.Text` 
        The tick labels. 
 
    Other Parameters 
    ---------------- 
    **kwargs 
        *kwargs* are optional `.Text` properties for the labels. 
 
    See Also 
    -------- 
    .pyplot.rgrids 
    .projections.polar.PolarAxes.set_thetagrids 
    .Axis.get_gridlines 
    .Axis.get_ticklabels 
 
    Examples 
    -------- 
    :: 
 
      # set the locations of the angular gridlines 
      lines, labels = thetagrids(range(45, 360, 90)) 
 
      # set the locations and labels of the angular gridlines 
      lines, labels = thetagrids(range(45, 360, 90), ('NE', 'NW', 'SW', 'SE')) 
    &quot;&quot;&quot;</span>
    <span class="s1">ax = gca()</span>
    <span class="s3">if not </span><span class="s1">isinstance(ax</span><span class="s3">, </span><span class="s1">PolarAxes):</span>
        <span class="s3">raise </span><span class="s1">RuntimeError(</span><span class="s4">'thetagrids only defined for polar axes'</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">all(param </span><span class="s3">is None for </span><span class="s1">param </span><span class="s3">in </span><span class="s1">[angles</span><span class="s3">, </span><span class="s1">labels</span><span class="s3">, </span><span class="s1">fmt]) </span><span class="s3">and not </span><span class="s1">kwargs:</span>
        <span class="s1">lines_out: list[Line2D] = ax.xaxis.get_ticklines()</span>
        <span class="s1">labels_out: list[Text] = ax.xaxis.get_ticklabels()</span>
    <span class="s3">elif </span><span class="s1">angles </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;'angles' cannot be None when other parameters are passed&quot;</span><span class="s1">)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">lines_out</span><span class="s3">, </span><span class="s1">labels_out = ax.set_thetagrids(angles</span><span class="s3">,</span>
                                                  <span class="s1">labels=labels</span><span class="s3">, </span><span class="s1">fmt=fmt</span><span class="s3">,</span>
                                                  <span class="s1">**kwargs)</span>
    <span class="s3">return </span><span class="s1">lines_out</span><span class="s3">, </span><span class="s1">labels_out</span>


<span class="s1">@_api.deprecated(</span><span class="s4">&quot;3.7&quot;</span><span class="s3">, </span><span class="s1">pending=</span><span class="s3">True</span><span class="s1">)</span>
<span class="s3">def </span><span class="s1">get_plot_commands() -&gt; list[str]:</span>
    <span class="s2">&quot;&quot;&quot; 
    Get a sorted list of all of the plotting commands. 
    &quot;&quot;&quot;</span>
    <span class="s1">NON_PLOT_COMMANDS = {</span>
        <span class="s4">'connect'</span><span class="s3">, </span><span class="s4">'disconnect'</span><span class="s3">, </span><span class="s4">'get_current_fig_manager'</span><span class="s3">, </span><span class="s4">'ginput'</span><span class="s3">,</span>
        <span class="s4">'new_figure_manager'</span><span class="s3">, </span><span class="s4">'waitforbuttonpress'</span><span class="s1">}</span>
    <span class="s3">return </span><span class="s1">[name </span><span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">_get_pyplot_commands()</span>
            <span class="s3">if </span><span class="s1">name </span><span class="s3">not in </span><span class="s1">NON_PLOT_COMMANDS]</span>


<span class="s3">def </span><span class="s1">_get_pyplot_commands() -&gt; list[str]:</span>
    <span class="s0"># This works by searching for all functions in this module and removing</span>
    <span class="s0"># a few hard-coded exclusions, as well as all of the colormap-setting</span>
    <span class="s0"># functions, and anything marked as private with a preceding underscore.</span>
    <span class="s1">exclude = {</span><span class="s4">'colormaps'</span><span class="s3">, </span><span class="s4">'colors'</span><span class="s3">, </span><span class="s4">'get_plot_commands'</span><span class="s3">, </span><span class="s1">*colormaps}</span>
    <span class="s1">this_module = inspect.getmodule(get_plot_commands)</span>
    <span class="s3">return </span><span class="s1">sorted(</span>
        <span class="s1">name </span><span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">obj </span><span class="s3">in </span><span class="s1">globals().items()</span>
        <span class="s3">if not </span><span class="s1">name.startswith(</span><span class="s4">'_'</span><span class="s1">) </span><span class="s3">and </span><span class="s1">name </span><span class="s3">not in </span><span class="s1">exclude</span>
           <span class="s3">and </span><span class="s1">inspect.isfunction(obj)</span>
           <span class="s3">and </span><span class="s1">inspect.getmodule(obj) </span><span class="s3">is </span><span class="s1">this_module)</span>


<span class="s0">## Plotting part 1: manually generated functions and wrappers ##</span>


<span class="s1">@_copy_docstring_and_deprecators(Figure.colorbar)</span>
<span class="s3">def </span><span class="s1">colorbar(</span>
    <span class="s1">mappable: ScalarMappable | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">cax: matplotlib.axes.Axes | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">ax: matplotlib.axes.Axes | Iterable[matplotlib.axes.Axes] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">**kwargs</span>
<span class="s1">) -&gt; Colorbar:</span>
    <span class="s3">if </span><span class="s1">mappable </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">mappable = gci()</span>
        <span class="s3">if </span><span class="s1">mappable </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">RuntimeError(</span><span class="s4">'No mappable was found to use for colorbar '</span>
                               <span class="s4">'creation. First define a mappable such as '</span>
                               <span class="s4">'an image (with imshow) or a contour set ('</span>
                               <span class="s4">'with contourf).'</span><span class="s1">)</span>
    <span class="s1">ret = gcf().colorbar(mappable</span><span class="s3">, </span><span class="s1">cax=cax</span><span class="s3">, </span><span class="s1">ax=ax</span><span class="s3">, </span><span class="s1">**kwargs)</span>
    <span class="s3">return </span><span class="s1">ret</span>


<span class="s3">def </span><span class="s1">clim(vmin: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None, </span><span class="s1">vmax: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None</span><span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot; 
    Set the color limits of the current image. 
 
    If either *vmin* or *vmax* is None, the image min/max respectively 
    will be used for color scaling. 
 
    If you want to set the clim of multiple images, use 
    `~.ScalarMappable.set_clim` on every image, for example:: 
 
      for im in gca().get_images(): 
          im.set_clim(0, 0.5) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">im = gci()</span>
    <span class="s3">if </span><span class="s1">im </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">RuntimeError(</span><span class="s4">'You must first define an image, e.g., with imshow'</span><span class="s1">)</span>

    <span class="s1">im.set_clim(vmin</span><span class="s3">, </span><span class="s1">vmax)</span>


<span class="s0"># eventually this implementation should move here, use indirection for now to</span>
<span class="s0"># avoid having two copies of the code floating around.</span>
<span class="s3">def </span><span class="s1">get_cmap(</span>
    <span class="s1">name: Colormap | str | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">lut: int | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None</span>
<span class="s1">) -&gt; Colormap:</span>
    <span class="s3">return </span><span class="s1">cm._get_cmap(name=name</span><span class="s3">, </span><span class="s1">lut=lut)  </span><span class="s0"># type: ignore</span>
<span class="s1">get_cmap.__doc__ = cm._get_cmap.__doc__  </span><span class="s0"># type: ignore</span>


<span class="s3">def </span><span class="s1">set_cmap(cmap: Colormap | str) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot; 
    Set the default colormap, and applies it to the current image if any. 
 
    Parameters 
    ---------- 
    cmap : `~matplotlib.colors.Colormap` or str 
        A colormap instance or the name of a registered colormap. 
 
    See Also 
    -------- 
    colormaps 
    matplotlib.cm.register_cmap 
    matplotlib.cm.get_cmap 
    &quot;&quot;&quot;</span>
    <span class="s1">cmap = get_cmap(cmap)</span>

    <span class="s1">rc(</span><span class="s4">'image'</span><span class="s3">, </span><span class="s1">cmap=cmap.name)</span>
    <span class="s1">im = gci()</span>

    <span class="s3">if </span><span class="s1">im </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">im.set_cmap(cmap)</span>


<span class="s1">@_copy_docstring_and_deprecators(matplotlib.image.imread)</span>
<span class="s3">def </span><span class="s1">imread(</span>
        <span class="s1">fname: str | pathlib.Path | BinaryIO</span><span class="s3">, </span><span class="s1">format: str | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None</span>
<span class="s1">) -&gt; np.ndarray:</span>
    <span class="s3">return </span><span class="s1">matplotlib.image.imread(fname</span><span class="s3">, </span><span class="s1">format)</span>


<span class="s1">@_copy_docstring_and_deprecators(matplotlib.image.imsave)</span>
<span class="s3">def </span><span class="s1">imsave(</span>
    <span class="s1">fname: str | os.PathLike | BinaryIO</span><span class="s3">, </span><span class="s1">arr: ArrayLike</span><span class="s3">, </span><span class="s1">**kwargs</span>
<span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s1">matplotlib.image.imsave(fname</span><span class="s3">, </span><span class="s1">arr</span><span class="s3">, </span><span class="s1">**kwargs)</span>


<span class="s3">def </span><span class="s1">matshow(A: ArrayLike</span><span class="s3">, </span><span class="s1">fignum: </span><span class="s3">None </span><span class="s1">| int = </span><span class="s3">None, </span><span class="s1">**kwargs) -&gt; AxesImage:</span>
    <span class="s2">&quot;&quot;&quot; 
    Display an array as a matrix in a new figure window. 
 
    The origin is set at the upper left hand corner and rows (first 
    dimension of the array) are displayed horizontally.  The aspect 
    ratio of the figure window is that of the array, unless this would 
    make an excessively short or narrow figure. 
 
    Tick labels for the xaxis are placed on top. 
 
    Parameters 
    ---------- 
    A : 2D array-like 
        The matrix to be displayed. 
 
    fignum : None or int 
        If *None*, create a new figure window with automatic numbering. 
 
        If a nonzero integer, draw into the figure with the given number 
        (create it if it does not exist). 
 
        If 0, use the current axes (or create one if it does not exist). 
 
        .. note:: 
 
           Because of how `.Axes.matshow` tries to set the figure aspect 
           ratio to be the one of the array, strange things may happen if you 
           reuse an existing figure. 
 
    Returns 
    ------- 
    `~matplotlib.image.AxesImage` 
 
    Other Parameters 
    ---------------- 
    **kwargs : `~matplotlib.axes.Axes.imshow` arguments 
 
    &quot;&quot;&quot;</span>
    <span class="s1">A = np.asanyarray(A)</span>
    <span class="s3">if </span><span class="s1">fignum == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">ax = gca()</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s0"># Extract actual aspect ratio of array and make appropriately sized</span>
        <span class="s0"># figure.</span>
        <span class="s1">fig = figure(fignum</span><span class="s3">, </span><span class="s1">figsize=figaspect(A))</span>
        <span class="s1">ax = fig.add_axes((</span><span class="s5">0.15</span><span class="s3">, </span><span class="s5">0.09</span><span class="s3">, </span><span class="s5">0.775</span><span class="s3">, </span><span class="s5">0.775</span><span class="s1">))</span>
    <span class="s1">im = ax.matshow(A</span><span class="s3">, </span><span class="s1">**kwargs)</span>
    <span class="s1">sci(im)</span>
    <span class="s3">return </span><span class="s1">im</span>


<span class="s3">def </span><span class="s1">polar(*args</span><span class="s3">, </span><span class="s1">**kwargs) -&gt; list[Line2D]:</span>
    <span class="s2">&quot;&quot;&quot; 
    Make a polar plot. 
 
    call signature:: 
 
      polar(theta, r, **kwargs) 
 
    Multiple *theta*, *r* arguments are supported, with format strings, as in 
    `plot`. 
    &quot;&quot;&quot;</span>
    <span class="s0"># If an axis already exists, check if it has a polar projection</span>
    <span class="s3">if </span><span class="s1">gcf().get_axes():</span>
        <span class="s1">ax = gca()</span>
        <span class="s3">if not </span><span class="s1">isinstance(ax</span><span class="s3">, </span><span class="s1">PolarAxes):</span>
            <span class="s1">_api.warn_external(</span><span class="s4">'Trying to create polar plot on an Axes '</span>
                               <span class="s4">'that does not have a polar projection.'</span><span class="s1">)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">ax = axes(projection=</span><span class="s4">&quot;polar&quot;</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">ax.plot(*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>


<span class="s0"># If rcParams['backend_fallback'] is true, and an interactive backend is</span>
<span class="s0"># requested, ignore rcParams['backend'] and force selection of a backend that</span>
<span class="s0"># is compatible with the current running interactive framework.</span>
<span class="s3">if </span><span class="s1">(rcParams[</span><span class="s4">&quot;backend_fallback&quot;</span><span class="s1">]</span>
        <span class="s3">and </span><span class="s1">rcParams._get_backend_or_none() </span><span class="s3">in </span><span class="s1">(  </span><span class="s0"># type: ignore</span>
            <span class="s1">set(rcsetup.interactive_bk) - {</span><span class="s4">'WebAgg'</span><span class="s3">, </span><span class="s4">'nbAgg'</span><span class="s1">})</span>
        <span class="s3">and </span><span class="s1">cbook._get_running_interactive_framework()):  </span><span class="s0"># type: ignore</span>
    <span class="s1">rcParams._set(</span><span class="s4">&quot;backend&quot;</span><span class="s3">, </span><span class="s1">rcsetup._auto_backend_sentinel)  </span><span class="s0"># type: ignore</span>

<span class="s0"># fmt: on</span>

<span class="s0">################# REMAINING CONTENT GENERATED BY boilerplate.py ##############</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Figure.figimage)</span>
<span class="s3">def </span><span class="s1">figimage(</span>
    <span class="s1">X: ArrayLike</span><span class="s3">,</span>
    <span class="s1">xo: int = </span><span class="s5">0</span><span class="s3">,</span>
    <span class="s1">yo: int = </span><span class="s5">0</span><span class="s3">,</span>
    <span class="s1">alpha: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">norm: str | Normalize | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">cmap: str | Colormap | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">vmin: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">vmax: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">origin: Literal[</span><span class="s4">&quot;upper&quot;</span><span class="s3">, </span><span class="s4">&quot;lower&quot;</span><span class="s1">] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">resize: bool = </span><span class="s3">False,</span>
    <span class="s1">**kwargs</span><span class="s3">,</span>
<span class="s1">) -&gt; FigureImage:</span>
    <span class="s3">return </span><span class="s1">gcf().figimage(</span>
        <span class="s1">X</span><span class="s3">,</span>
        <span class="s1">xo=xo</span><span class="s3">,</span>
        <span class="s1">yo=yo</span><span class="s3">,</span>
        <span class="s1">alpha=alpha</span><span class="s3">,</span>
        <span class="s1">norm=norm</span><span class="s3">,</span>
        <span class="s1">cmap=cmap</span><span class="s3">,</span>
        <span class="s1">vmin=vmin</span><span class="s3">,</span>
        <span class="s1">vmax=vmax</span><span class="s3">,</span>
        <span class="s1">origin=origin</span><span class="s3">,</span>
        <span class="s1">resize=resize</span><span class="s3">,</span>
        <span class="s1">**kwargs</span><span class="s3">,</span>
    <span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Figure.text)</span>
<span class="s3">def </span><span class="s1">figtext(</span>
    <span class="s1">x: float</span><span class="s3">, </span><span class="s1">y: float</span><span class="s3">, </span><span class="s1">s: str</span><span class="s3">, </span><span class="s1">fontdict: dict[str</span><span class="s3">, </span><span class="s1">Any] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None, </span><span class="s1">**kwargs</span>
<span class="s1">) -&gt; Text:</span>
    <span class="s3">return </span><span class="s1">gcf().text(x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">s</span><span class="s3">, </span><span class="s1">fontdict=fontdict</span><span class="s3">, </span><span class="s1">**kwargs)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Figure.gca)</span>
<span class="s3">def </span><span class="s1">gca() -&gt; Axes:</span>
    <span class="s3">return </span><span class="s1">gcf().gca()</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Figure._gci)</span>
<span class="s3">def </span><span class="s1">gci() -&gt; ScalarMappable | </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">gcf()._gci()</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Figure.ginput)</span>
<span class="s3">def </span><span class="s1">ginput(</span>
    <span class="s1">n: int = </span><span class="s5">1</span><span class="s3">,</span>
    <span class="s1">timeout: float = </span><span class="s5">30</span><span class="s3">,</span>
    <span class="s1">show_clicks: bool = </span><span class="s3">True,</span>
    <span class="s1">mouse_add: MouseButton = MouseButton.LEFT</span><span class="s3">,</span>
    <span class="s1">mouse_pop: MouseButton = MouseButton.RIGHT</span><span class="s3">,</span>
    <span class="s1">mouse_stop: MouseButton = MouseButton.MIDDLE</span><span class="s3">,</span>
<span class="s1">) -&gt; list[tuple[int</span><span class="s3">, </span><span class="s1">int]]:</span>
    <span class="s3">return </span><span class="s1">gcf().ginput(</span>
        <span class="s1">n=n</span><span class="s3">,</span>
        <span class="s1">timeout=timeout</span><span class="s3">,</span>
        <span class="s1">show_clicks=show_clicks</span><span class="s3">,</span>
        <span class="s1">mouse_add=mouse_add</span><span class="s3">,</span>
        <span class="s1">mouse_pop=mouse_pop</span><span class="s3">,</span>
        <span class="s1">mouse_stop=mouse_stop</span><span class="s3">,</span>
    <span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Figure.subplots_adjust)</span>
<span class="s3">def </span><span class="s1">subplots_adjust(</span>
    <span class="s1">left: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">bottom: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">right: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">top: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">wspace: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">hspace: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
<span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s1">gcf().subplots_adjust(</span>
        <span class="s1">left=left</span><span class="s3">, </span><span class="s1">bottom=bottom</span><span class="s3">, </span><span class="s1">right=right</span><span class="s3">, </span><span class="s1">top=top</span><span class="s3">, </span><span class="s1">wspace=wspace</span><span class="s3">, </span><span class="s1">hspace=hspace</span>
    <span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Figure.suptitle)</span>
<span class="s3">def </span><span class="s1">suptitle(t: str</span><span class="s3">, </span><span class="s1">**kwargs) -&gt; Text:</span>
    <span class="s3">return </span><span class="s1">gcf().suptitle(t</span><span class="s3">, </span><span class="s1">**kwargs)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Figure.tight_layout)</span>
<span class="s3">def </span><span class="s1">tight_layout(</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">pad: float = </span><span class="s5">1.08</span><span class="s3">,</span>
    <span class="s1">h_pad: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">w_pad: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">rect: tuple[float</span><span class="s3">, </span><span class="s1">float</span><span class="s3">, </span><span class="s1">float</span><span class="s3">, </span><span class="s1">float] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
<span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s1">gcf().tight_layout(pad=pad</span><span class="s3">, </span><span class="s1">h_pad=h_pad</span><span class="s3">, </span><span class="s1">w_pad=w_pad</span><span class="s3">, </span><span class="s1">rect=rect)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Figure.waitforbuttonpress)</span>
<span class="s3">def </span><span class="s1">waitforbuttonpress(timeout: float = -</span><span class="s5">1</span><span class="s1">) -&gt; </span><span class="s3">None </span><span class="s1">| bool:</span>
    <span class="s3">return </span><span class="s1">gcf().waitforbuttonpress(timeout=timeout)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.acorr)</span>
<span class="s3">def </span><span class="s1">acorr(</span>
    <span class="s1">x: ArrayLike</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">data=</span><span class="s3">None, </span><span class="s1">**kwargs</span>
<span class="s1">) -&gt; tuple[np.ndarray</span><span class="s3">, </span><span class="s1">np.ndarray</span><span class="s3">, </span><span class="s1">LineCollection | Line2D</span><span class="s3">, </span><span class="s1">Line2D | </span><span class="s3">None</span><span class="s1">]:</span>
    <span class="s3">return </span><span class="s1">gca().acorr(x</span><span class="s3">, </span><span class="s1">**({</span><span class="s4">&quot;data&quot;</span><span class="s1">: data} </span><span class="s3">if </span><span class="s1">data </span><span class="s3">is not None else </span><span class="s1">{})</span><span class="s3">, </span><span class="s1">**kwargs)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.angle_spectrum)</span>
<span class="s3">def </span><span class="s1">angle_spectrum(</span>
    <span class="s1">x: ArrayLike</span><span class="s3">,</span>
    <span class="s1">Fs: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">Fc: int | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">window: Callable[[ArrayLike]</span><span class="s3">, </span><span class="s1">ArrayLike] | ArrayLike | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">pad_to: int | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">sides: Literal[</span><span class="s4">&quot;default&quot;</span><span class="s3">, </span><span class="s4">&quot;onesided&quot;</span><span class="s3">, </span><span class="s4">&quot;twosided&quot;</span><span class="s1">] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">data=</span><span class="s3">None,</span>
    <span class="s1">**kwargs</span><span class="s3">,</span>
<span class="s1">) -&gt; tuple[np.ndarray</span><span class="s3">, </span><span class="s1">np.ndarray</span><span class="s3">, </span><span class="s1">Line2D]:</span>
    <span class="s3">return </span><span class="s1">gca().angle_spectrum(</span>
        <span class="s1">x</span><span class="s3">,</span>
        <span class="s1">Fs=Fs</span><span class="s3">,</span>
        <span class="s1">Fc=Fc</span><span class="s3">,</span>
        <span class="s1">window=window</span><span class="s3">,</span>
        <span class="s1">pad_to=pad_to</span><span class="s3">,</span>
        <span class="s1">sides=sides</span><span class="s3">,</span>
        <span class="s1">**({</span><span class="s4">&quot;data&quot;</span><span class="s1">: data} </span><span class="s3">if </span><span class="s1">data </span><span class="s3">is not None else </span><span class="s1">{})</span><span class="s3">,</span>
        <span class="s1">**kwargs</span><span class="s3">,</span>
    <span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.annotate)</span>
<span class="s3">def </span><span class="s1">annotate(</span>
    <span class="s1">text: str</span><span class="s3">,</span>
    <span class="s1">xy: tuple[float</span><span class="s3">, </span><span class="s1">float]</span><span class="s3">,</span>
    <span class="s1">xytext: tuple[float</span><span class="s3">, </span><span class="s1">float] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">xycoords: str</span>
    <span class="s1">| Artist</span>
    <span class="s1">| Transform</span>
    <span class="s1">| Callable[[RendererBase]</span><span class="s3">, </span><span class="s1">Bbox | Transform]</span>
    <span class="s1">| tuple[float</span><span class="s3">, </span><span class="s1">float] = </span><span class="s4">&quot;data&quot;</span><span class="s3">,</span>
    <span class="s1">textcoords: str</span>
    <span class="s1">| Artist</span>
    <span class="s1">| Transform</span>
    <span class="s1">| Callable[[RendererBase]</span><span class="s3">, </span><span class="s1">Bbox | Transform]</span>
    <span class="s1">| tuple[float</span><span class="s3">, </span><span class="s1">float]</span>
    <span class="s1">| </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">arrowprops: dict[str</span><span class="s3">, </span><span class="s1">Any] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">annotation_clip: bool | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">**kwargs</span><span class="s3">,</span>
<span class="s1">) -&gt; Annotation:</span>
    <span class="s3">return </span><span class="s1">gca().annotate(</span>
        <span class="s1">text</span><span class="s3">,</span>
        <span class="s1">xy</span><span class="s3">,</span>
        <span class="s1">xytext=xytext</span><span class="s3">,</span>
        <span class="s1">xycoords=xycoords</span><span class="s3">,</span>
        <span class="s1">textcoords=textcoords</span><span class="s3">,</span>
        <span class="s1">arrowprops=arrowprops</span><span class="s3">,</span>
        <span class="s1">annotation_clip=annotation_clip</span><span class="s3">,</span>
        <span class="s1">**kwargs</span><span class="s3">,</span>
    <span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.arrow)</span>
<span class="s3">def </span><span class="s1">arrow(x: float</span><span class="s3">, </span><span class="s1">y: float</span><span class="s3">, </span><span class="s1">dx: float</span><span class="s3">, </span><span class="s1">dy: float</span><span class="s3">, </span><span class="s1">**kwargs) -&gt; FancyArrow:</span>
    <span class="s3">return </span><span class="s1">gca().arrow(x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">dx</span><span class="s3">, </span><span class="s1">dy</span><span class="s3">, </span><span class="s1">**kwargs)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.autoscale)</span>
<span class="s3">def </span><span class="s1">autoscale(</span>
    <span class="s1">enable: bool = </span><span class="s3">True,</span>
    <span class="s1">axis: Literal[</span><span class="s4">&quot;both&quot;</span><span class="s3">, </span><span class="s4">&quot;x&quot;</span><span class="s3">, </span><span class="s4">&quot;y&quot;</span><span class="s1">] = </span><span class="s4">&quot;both&quot;</span><span class="s3">,</span>
    <span class="s1">tight: bool | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
<span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s1">gca().autoscale(enable=enable</span><span class="s3">, </span><span class="s1">axis=axis</span><span class="s3">, </span><span class="s1">tight=tight)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.axhline)</span>
<span class="s3">def </span><span class="s1">axhline(y: float = </span><span class="s5">0</span><span class="s3">, </span><span class="s1">xmin: float = </span><span class="s5">0</span><span class="s3">, </span><span class="s1">xmax: float = </span><span class="s5">1</span><span class="s3">, </span><span class="s1">**kwargs) -&gt; Line2D:</span>
    <span class="s3">return </span><span class="s1">gca().axhline(y=y</span><span class="s3">, </span><span class="s1">xmin=xmin</span><span class="s3">, </span><span class="s1">xmax=xmax</span><span class="s3">, </span><span class="s1">**kwargs)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.axhspan)</span>
<span class="s3">def </span><span class="s1">axhspan(</span>
    <span class="s1">ymin: float</span><span class="s3">, </span><span class="s1">ymax: float</span><span class="s3">, </span><span class="s1">xmin: float = </span><span class="s5">0</span><span class="s3">, </span><span class="s1">xmax: float = </span><span class="s5">1</span><span class="s3">, </span><span class="s1">**kwargs</span>
<span class="s1">) -&gt; Polygon:</span>
    <span class="s3">return </span><span class="s1">gca().axhspan(ymin</span><span class="s3">, </span><span class="s1">ymax</span><span class="s3">, </span><span class="s1">xmin=xmin</span><span class="s3">, </span><span class="s1">xmax=xmax</span><span class="s3">, </span><span class="s1">**kwargs)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.axis)</span>
<span class="s3">def </span><span class="s1">axis(</span>
    <span class="s1">arg: tuple[float</span><span class="s3">, </span><span class="s1">float</span><span class="s3">, </span><span class="s1">float</span><span class="s3">, </span><span class="s1">float] | bool | str | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">/</span><span class="s3">,</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">emit: bool = </span><span class="s3">True,</span>
    <span class="s1">**kwargs</span><span class="s3">,</span>
<span class="s1">) -&gt; tuple[float</span><span class="s3">, </span><span class="s1">float</span><span class="s3">, </span><span class="s1">float</span><span class="s3">, </span><span class="s1">float]:</span>
    <span class="s3">return </span><span class="s1">gca().axis(arg</span><span class="s3">, </span><span class="s1">emit=emit</span><span class="s3">, </span><span class="s1">**kwargs)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.axline)</span>
<span class="s3">def </span><span class="s1">axline(</span>
    <span class="s1">xy1: tuple[float</span><span class="s3">, </span><span class="s1">float]</span><span class="s3">,</span>
    <span class="s1">xy2: tuple[float</span><span class="s3">, </span><span class="s1">float] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">slope: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">**kwargs</span><span class="s3">,</span>
<span class="s1">) -&gt; Line2D:</span>
    <span class="s3">return </span><span class="s1">gca().axline(xy1</span><span class="s3">, </span><span class="s1">xy2=xy2</span><span class="s3">, </span><span class="s1">slope=slope</span><span class="s3">, </span><span class="s1">**kwargs)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.axvline)</span>
<span class="s3">def </span><span class="s1">axvline(x: float = </span><span class="s5">0</span><span class="s3">, </span><span class="s1">ymin: float = </span><span class="s5">0</span><span class="s3">, </span><span class="s1">ymax: float = </span><span class="s5">1</span><span class="s3">, </span><span class="s1">**kwargs) -&gt; Line2D:</span>
    <span class="s3">return </span><span class="s1">gca().axvline(x=x</span><span class="s3">, </span><span class="s1">ymin=ymin</span><span class="s3">, </span><span class="s1">ymax=ymax</span><span class="s3">, </span><span class="s1">**kwargs)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.axvspan)</span>
<span class="s3">def </span><span class="s1">axvspan(</span>
    <span class="s1">xmin: float</span><span class="s3">, </span><span class="s1">xmax: float</span><span class="s3">, </span><span class="s1">ymin: float = </span><span class="s5">0</span><span class="s3">, </span><span class="s1">ymax: float = </span><span class="s5">1</span><span class="s3">, </span><span class="s1">**kwargs</span>
<span class="s1">) -&gt; Polygon:</span>
    <span class="s3">return </span><span class="s1">gca().axvspan(xmin</span><span class="s3">, </span><span class="s1">xmax</span><span class="s3">, </span><span class="s1">ymin=ymin</span><span class="s3">, </span><span class="s1">ymax=ymax</span><span class="s3">, </span><span class="s1">**kwargs)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.bar)</span>
<span class="s3">def </span><span class="s1">bar(</span>
    <span class="s1">x: float | ArrayLike</span><span class="s3">,</span>
    <span class="s1">height: float | ArrayLike</span><span class="s3">,</span>
    <span class="s1">width: float | ArrayLike = </span><span class="s5">0.8</span><span class="s3">,</span>
    <span class="s1">bottom: float | ArrayLike | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">align: Literal[</span><span class="s4">&quot;center&quot;</span><span class="s3">, </span><span class="s4">&quot;edge&quot;</span><span class="s1">] = </span><span class="s4">&quot;center&quot;</span><span class="s3">,</span>
    <span class="s1">data=</span><span class="s3">None,</span>
    <span class="s1">**kwargs</span><span class="s3">,</span>
<span class="s1">) -&gt; BarContainer:</span>
    <span class="s3">return </span><span class="s1">gca().bar(</span>
        <span class="s1">x</span><span class="s3">,</span>
        <span class="s1">height</span><span class="s3">,</span>
        <span class="s1">width=width</span><span class="s3">,</span>
        <span class="s1">bottom=bottom</span><span class="s3">,</span>
        <span class="s1">align=align</span><span class="s3">,</span>
        <span class="s1">**({</span><span class="s4">&quot;data&quot;</span><span class="s1">: data} </span><span class="s3">if </span><span class="s1">data </span><span class="s3">is not None else </span><span class="s1">{})</span><span class="s3">,</span>
        <span class="s1">**kwargs</span><span class="s3">,</span>
    <span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.barbs)</span>
<span class="s3">def </span><span class="s1">barbs(*args</span><span class="s3">, </span><span class="s1">data=</span><span class="s3">None, </span><span class="s1">**kwargs) -&gt; Barbs:</span>
    <span class="s3">return </span><span class="s1">gca().barbs(*args</span><span class="s3">, </span><span class="s1">**({</span><span class="s4">&quot;data&quot;</span><span class="s1">: data} </span><span class="s3">if </span><span class="s1">data </span><span class="s3">is not None else </span><span class="s1">{})</span><span class="s3">, </span><span class="s1">**kwargs)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.barh)</span>
<span class="s3">def </span><span class="s1">barh(</span>
    <span class="s1">y: float | ArrayLike</span><span class="s3">,</span>
    <span class="s1">width: float | ArrayLike</span><span class="s3">,</span>
    <span class="s1">height: float | ArrayLike = </span><span class="s5">0.8</span><span class="s3">,</span>
    <span class="s1">left: float | ArrayLike | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">align: Literal[</span><span class="s4">&quot;center&quot;</span><span class="s3">, </span><span class="s4">&quot;edge&quot;</span><span class="s1">] = </span><span class="s4">&quot;center&quot;</span><span class="s3">,</span>
    <span class="s1">data=</span><span class="s3">None,</span>
    <span class="s1">**kwargs</span><span class="s3">,</span>
<span class="s1">) -&gt; BarContainer:</span>
    <span class="s3">return </span><span class="s1">gca().barh(</span>
        <span class="s1">y</span><span class="s3">,</span>
        <span class="s1">width</span><span class="s3">,</span>
        <span class="s1">height=height</span><span class="s3">,</span>
        <span class="s1">left=left</span><span class="s3">,</span>
        <span class="s1">align=align</span><span class="s3">,</span>
        <span class="s1">**({</span><span class="s4">&quot;data&quot;</span><span class="s1">: data} </span><span class="s3">if </span><span class="s1">data </span><span class="s3">is not None else </span><span class="s1">{})</span><span class="s3">,</span>
        <span class="s1">**kwargs</span><span class="s3">,</span>
    <span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.bar_label)</span>
<span class="s3">def </span><span class="s1">bar_label(</span>
    <span class="s1">container: BarContainer</span><span class="s3">,</span>
    <span class="s1">labels: ArrayLike | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">fmt: str | Callable[[float]</span><span class="s3">, </span><span class="s1">str] = </span><span class="s4">&quot;%g&quot;</span><span class="s3">,</span>
    <span class="s1">label_type: Literal[</span><span class="s4">&quot;center&quot;</span><span class="s3">, </span><span class="s4">&quot;edge&quot;</span><span class="s1">] = </span><span class="s4">&quot;edge&quot;</span><span class="s3">,</span>
    <span class="s1">padding: float = </span><span class="s5">0</span><span class="s3">,</span>
    <span class="s1">**kwargs</span><span class="s3">,</span>
<span class="s1">) -&gt; list[Annotation]:</span>
    <span class="s3">return </span><span class="s1">gca().bar_label(</span>
        <span class="s1">container</span><span class="s3">,</span>
        <span class="s1">labels=labels</span><span class="s3">,</span>
        <span class="s1">fmt=fmt</span><span class="s3">,</span>
        <span class="s1">label_type=label_type</span><span class="s3">,</span>
        <span class="s1">padding=padding</span><span class="s3">,</span>
        <span class="s1">**kwargs</span><span class="s3">,</span>
    <span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.boxplot)</span>
<span class="s3">def </span><span class="s1">boxplot(</span>
    <span class="s1">x: ArrayLike | Sequence[ArrayLike]</span><span class="s3">,</span>
    <span class="s1">notch: bool | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">sym: str | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">vert: bool | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">whis: float | tuple[float</span><span class="s3">, </span><span class="s1">float] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">positions: ArrayLike | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">widths: float | ArrayLike | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">patch_artist: bool | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">bootstrap: int | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">usermedians: ArrayLike | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">conf_intervals: ArrayLike | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">meanline: bool | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">showmeans: bool | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">showcaps: bool | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">showbox: bool | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">showfliers: bool | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">boxprops: dict[str</span><span class="s3">, </span><span class="s1">Any] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">labels: Sequence[str] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">flierprops: dict[str</span><span class="s3">, </span><span class="s1">Any] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">medianprops: dict[str</span><span class="s3">, </span><span class="s1">Any] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">meanprops: dict[str</span><span class="s3">, </span><span class="s1">Any] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">capprops: dict[str</span><span class="s3">, </span><span class="s1">Any] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">whiskerprops: dict[str</span><span class="s3">, </span><span class="s1">Any] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">manage_ticks: bool = </span><span class="s3">True,</span>
    <span class="s1">autorange: bool = </span><span class="s3">False,</span>
    <span class="s1">zorder: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">capwidths: float | ArrayLike | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">data=</span><span class="s3">None,</span>
<span class="s1">) -&gt; dict[str</span><span class="s3">, </span><span class="s1">Any]:</span>
    <span class="s3">return </span><span class="s1">gca().boxplot(</span>
        <span class="s1">x</span><span class="s3">,</span>
        <span class="s1">notch=notch</span><span class="s3">,</span>
        <span class="s1">sym=sym</span><span class="s3">,</span>
        <span class="s1">vert=vert</span><span class="s3">,</span>
        <span class="s1">whis=whis</span><span class="s3">,</span>
        <span class="s1">positions=positions</span><span class="s3">,</span>
        <span class="s1">widths=widths</span><span class="s3">,</span>
        <span class="s1">patch_artist=patch_artist</span><span class="s3">,</span>
        <span class="s1">bootstrap=bootstrap</span><span class="s3">,</span>
        <span class="s1">usermedians=usermedians</span><span class="s3">,</span>
        <span class="s1">conf_intervals=conf_intervals</span><span class="s3">,</span>
        <span class="s1">meanline=meanline</span><span class="s3">,</span>
        <span class="s1">showmeans=showmeans</span><span class="s3">,</span>
        <span class="s1">showcaps=showcaps</span><span class="s3">,</span>
        <span class="s1">showbox=showbox</span><span class="s3">,</span>
        <span class="s1">showfliers=showfliers</span><span class="s3">,</span>
        <span class="s1">boxprops=boxprops</span><span class="s3">,</span>
        <span class="s1">labels=labels</span><span class="s3">,</span>
        <span class="s1">flierprops=flierprops</span><span class="s3">,</span>
        <span class="s1">medianprops=medianprops</span><span class="s3">,</span>
        <span class="s1">meanprops=meanprops</span><span class="s3">,</span>
        <span class="s1">capprops=capprops</span><span class="s3">,</span>
        <span class="s1">whiskerprops=whiskerprops</span><span class="s3">,</span>
        <span class="s1">manage_ticks=manage_ticks</span><span class="s3">,</span>
        <span class="s1">autorange=autorange</span><span class="s3">,</span>
        <span class="s1">zorder=zorder</span><span class="s3">,</span>
        <span class="s1">capwidths=capwidths</span><span class="s3">,</span>
        <span class="s1">**({</span><span class="s4">&quot;data&quot;</span><span class="s1">: data} </span><span class="s3">if </span><span class="s1">data </span><span class="s3">is not None else </span><span class="s1">{})</span><span class="s3">,</span>
    <span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.broken_barh)</span>
<span class="s3">def </span><span class="s1">broken_barh(</span>
    <span class="s1">xranges: Sequence[tuple[float</span><span class="s3">, </span><span class="s1">float]]</span><span class="s3">,</span>
    <span class="s1">yrange: tuple[float</span><span class="s3">, </span><span class="s1">float]</span><span class="s3">,</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">data=</span><span class="s3">None,</span>
    <span class="s1">**kwargs</span><span class="s3">,</span>
<span class="s1">) -&gt; BrokenBarHCollection:</span>
    <span class="s3">return </span><span class="s1">gca().broken_barh(</span>
        <span class="s1">xranges</span><span class="s3">, </span><span class="s1">yrange</span><span class="s3">, </span><span class="s1">**({</span><span class="s4">&quot;data&quot;</span><span class="s1">: data} </span><span class="s3">if </span><span class="s1">data </span><span class="s3">is not None else </span><span class="s1">{})</span><span class="s3">, </span><span class="s1">**kwargs</span>
    <span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.clabel)</span>
<span class="s3">def </span><span class="s1">clabel(CS: ContourSet</span><span class="s3">, </span><span class="s1">levels: ArrayLike | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None, </span><span class="s1">**kwargs) -&gt; list[Text]:</span>
    <span class="s3">return </span><span class="s1">gca().clabel(CS</span><span class="s3">, </span><span class="s1">levels=levels</span><span class="s3">, </span><span class="s1">**kwargs)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.cohere)</span>
<span class="s3">def </span><span class="s1">cohere(</span>
    <span class="s1">x: ArrayLike</span><span class="s3">,</span>
    <span class="s1">y: ArrayLike</span><span class="s3">,</span>
    <span class="s1">NFFT: int = </span><span class="s5">256</span><span class="s3">,</span>
    <span class="s1">Fs: float = </span><span class="s5">2</span><span class="s3">,</span>
    <span class="s1">Fc: int = </span><span class="s5">0</span><span class="s3">,</span>
    <span class="s1">detrend: Literal[</span><span class="s4">&quot;none&quot;</span><span class="s3">, </span><span class="s4">&quot;mean&quot;</span><span class="s3">, </span><span class="s4">&quot;linear&quot;</span><span class="s1">]</span>
    <span class="s1">| Callable[[ArrayLike]</span><span class="s3">, </span><span class="s1">ArrayLike] = mlab.detrend_none</span><span class="s3">,</span>
    <span class="s1">window: Callable[[ArrayLike]</span><span class="s3">, </span><span class="s1">ArrayLike] | ArrayLike = mlab.window_hanning</span><span class="s3">,</span>
    <span class="s1">noverlap: int = </span><span class="s5">0</span><span class="s3">,</span>
    <span class="s1">pad_to: int | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">sides: Literal[</span><span class="s4">&quot;default&quot;</span><span class="s3">, </span><span class="s4">&quot;onesided&quot;</span><span class="s3">, </span><span class="s4">&quot;twosided&quot;</span><span class="s1">] = </span><span class="s4">&quot;default&quot;</span><span class="s3">,</span>
    <span class="s1">scale_by_freq: bool | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">data=</span><span class="s3">None,</span>
    <span class="s1">**kwargs</span><span class="s3">,</span>
<span class="s1">) -&gt; tuple[np.ndarray</span><span class="s3">, </span><span class="s1">np.ndarray]:</span>
    <span class="s3">return </span><span class="s1">gca().cohere(</span>
        <span class="s1">x</span><span class="s3">,</span>
        <span class="s1">y</span><span class="s3">,</span>
        <span class="s1">NFFT=NFFT</span><span class="s3">,</span>
        <span class="s1">Fs=Fs</span><span class="s3">,</span>
        <span class="s1">Fc=Fc</span><span class="s3">,</span>
        <span class="s1">detrend=detrend</span><span class="s3">,</span>
        <span class="s1">window=window</span><span class="s3">,</span>
        <span class="s1">noverlap=noverlap</span><span class="s3">,</span>
        <span class="s1">pad_to=pad_to</span><span class="s3">,</span>
        <span class="s1">sides=sides</span><span class="s3">,</span>
        <span class="s1">scale_by_freq=scale_by_freq</span><span class="s3">,</span>
        <span class="s1">**({</span><span class="s4">&quot;data&quot;</span><span class="s1">: data} </span><span class="s3">if </span><span class="s1">data </span><span class="s3">is not None else </span><span class="s1">{})</span><span class="s3">,</span>
        <span class="s1">**kwargs</span><span class="s3">,</span>
    <span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.contour)</span>
<span class="s3">def </span><span class="s1">contour(*args</span><span class="s3">, </span><span class="s1">data=</span><span class="s3">None, </span><span class="s1">**kwargs) -&gt; QuadContourSet:</span>
    <span class="s1">__ret = gca().contour(</span>
        <span class="s1">*args</span><span class="s3">, </span><span class="s1">**({</span><span class="s4">&quot;data&quot;</span><span class="s1">: data} </span><span class="s3">if </span><span class="s1">data </span><span class="s3">is not None else </span><span class="s1">{})</span><span class="s3">, </span><span class="s1">**kwargs</span>
    <span class="s1">)</span>
    <span class="s3">if </span><span class="s1">__ret._A </span><span class="s3">is not None</span><span class="s1">:  </span><span class="s0"># type: ignore[attr-defined]</span>
        <span class="s1">sci(__ret)</span>
    <span class="s3">return </span><span class="s1">__ret</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.contourf)</span>
<span class="s3">def </span><span class="s1">contourf(*args</span><span class="s3">, </span><span class="s1">data=</span><span class="s3">None, </span><span class="s1">**kwargs) -&gt; QuadContourSet:</span>
    <span class="s1">__ret = gca().contourf(</span>
        <span class="s1">*args</span><span class="s3">, </span><span class="s1">**({</span><span class="s4">&quot;data&quot;</span><span class="s1">: data} </span><span class="s3">if </span><span class="s1">data </span><span class="s3">is not None else </span><span class="s1">{})</span><span class="s3">, </span><span class="s1">**kwargs</span>
    <span class="s1">)</span>
    <span class="s3">if </span><span class="s1">__ret._A </span><span class="s3">is not None</span><span class="s1">:  </span><span class="s0"># type: ignore[attr-defined]</span>
        <span class="s1">sci(__ret)</span>
    <span class="s3">return </span><span class="s1">__ret</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.csd)</span>
<span class="s3">def </span><span class="s1">csd(</span>
    <span class="s1">x: ArrayLike</span><span class="s3">,</span>
    <span class="s1">y: ArrayLike</span><span class="s3">,</span>
    <span class="s1">NFFT: int | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">Fs: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">Fc: int | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">detrend: Literal[</span><span class="s4">&quot;none&quot;</span><span class="s3">, </span><span class="s4">&quot;mean&quot;</span><span class="s3">, </span><span class="s4">&quot;linear&quot;</span><span class="s1">]</span>
    <span class="s1">| Callable[[ArrayLike]</span><span class="s3">, </span><span class="s1">ArrayLike]</span>
    <span class="s1">| </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">window: Callable[[ArrayLike]</span><span class="s3">, </span><span class="s1">ArrayLike] | ArrayLike | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">noverlap: int | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">pad_to: int | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">sides: Literal[</span><span class="s4">&quot;default&quot;</span><span class="s3">, </span><span class="s4">&quot;onesided&quot;</span><span class="s3">, </span><span class="s4">&quot;twosided&quot;</span><span class="s1">] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">scale_by_freq: bool | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">return_line: bool | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">data=</span><span class="s3">None,</span>
    <span class="s1">**kwargs</span><span class="s3">,</span>
<span class="s1">) -&gt; tuple[np.ndarray</span><span class="s3">, </span><span class="s1">np.ndarray] | tuple[np.ndarray</span><span class="s3">, </span><span class="s1">np.ndarray</span><span class="s3">, </span><span class="s1">Line2D]:</span>
    <span class="s3">return </span><span class="s1">gca().csd(</span>
        <span class="s1">x</span><span class="s3">,</span>
        <span class="s1">y</span><span class="s3">,</span>
        <span class="s1">NFFT=NFFT</span><span class="s3">,</span>
        <span class="s1">Fs=Fs</span><span class="s3">,</span>
        <span class="s1">Fc=Fc</span><span class="s3">,</span>
        <span class="s1">detrend=detrend</span><span class="s3">,</span>
        <span class="s1">window=window</span><span class="s3">,</span>
        <span class="s1">noverlap=noverlap</span><span class="s3">,</span>
        <span class="s1">pad_to=pad_to</span><span class="s3">,</span>
        <span class="s1">sides=sides</span><span class="s3">,</span>
        <span class="s1">scale_by_freq=scale_by_freq</span><span class="s3">,</span>
        <span class="s1">return_line=return_line</span><span class="s3">,</span>
        <span class="s1">**({</span><span class="s4">&quot;data&quot;</span><span class="s1">: data} </span><span class="s3">if </span><span class="s1">data </span><span class="s3">is not None else </span><span class="s1">{})</span><span class="s3">,</span>
        <span class="s1">**kwargs</span><span class="s3">,</span>
    <span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.ecdf)</span>
<span class="s3">def </span><span class="s1">ecdf(</span>
    <span class="s1">x: ArrayLike</span><span class="s3">,</span>
    <span class="s1">weights: ArrayLike | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">complementary: bool = </span><span class="s3">False,</span>
    <span class="s1">orientation: Literal[</span><span class="s4">&quot;vertical&quot;</span><span class="s3">, </span><span class="s4">&quot;horizonatal&quot;</span><span class="s1">] = </span><span class="s4">&quot;vertical&quot;</span><span class="s3">,</span>
    <span class="s1">compress: bool = </span><span class="s3">False,</span>
    <span class="s1">data=</span><span class="s3">None,</span>
    <span class="s1">**kwargs</span><span class="s3">,</span>
<span class="s1">) -&gt; Line2D:</span>
    <span class="s3">return </span><span class="s1">gca().ecdf(</span>
        <span class="s1">x</span><span class="s3">,</span>
        <span class="s1">weights=weights</span><span class="s3">,</span>
        <span class="s1">complementary=complementary</span><span class="s3">,</span>
        <span class="s1">orientation=orientation</span><span class="s3">,</span>
        <span class="s1">compress=compress</span><span class="s3">,</span>
        <span class="s1">**({</span><span class="s4">&quot;data&quot;</span><span class="s1">: data} </span><span class="s3">if </span><span class="s1">data </span><span class="s3">is not None else </span><span class="s1">{})</span><span class="s3">,</span>
        <span class="s1">**kwargs</span><span class="s3">,</span>
    <span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.errorbar)</span>
<span class="s3">def </span><span class="s1">errorbar(</span>
    <span class="s1">x: float | ArrayLike</span><span class="s3">,</span>
    <span class="s1">y: float | ArrayLike</span><span class="s3">,</span>
    <span class="s1">yerr: float | ArrayLike | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">xerr: float | ArrayLike | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">fmt: str = </span><span class="s4">&quot;&quot;</span><span class="s3">,</span>
    <span class="s1">ecolor: ColorType | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">elinewidth: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">capsize: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">barsabove: bool = </span><span class="s3">False,</span>
    <span class="s1">lolims: bool | ArrayLike = </span><span class="s3">False,</span>
    <span class="s1">uplims: bool | ArrayLike = </span><span class="s3">False,</span>
    <span class="s1">xlolims: bool | ArrayLike = </span><span class="s3">False,</span>
    <span class="s1">xuplims: bool | ArrayLike = </span><span class="s3">False,</span>
    <span class="s1">errorevery: int | tuple[int</span><span class="s3">, </span><span class="s1">int] = </span><span class="s5">1</span><span class="s3">,</span>
    <span class="s1">capthick: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">data=</span><span class="s3">None,</span>
    <span class="s1">**kwargs</span><span class="s3">,</span>
<span class="s1">) -&gt; ErrorbarContainer:</span>
    <span class="s3">return </span><span class="s1">gca().errorbar(</span>
        <span class="s1">x</span><span class="s3">,</span>
        <span class="s1">y</span><span class="s3">,</span>
        <span class="s1">yerr=yerr</span><span class="s3">,</span>
        <span class="s1">xerr=xerr</span><span class="s3">,</span>
        <span class="s1">fmt=fmt</span><span class="s3">,</span>
        <span class="s1">ecolor=ecolor</span><span class="s3">,</span>
        <span class="s1">elinewidth=elinewidth</span><span class="s3">,</span>
        <span class="s1">capsize=capsize</span><span class="s3">,</span>
        <span class="s1">barsabove=barsabove</span><span class="s3">,</span>
        <span class="s1">lolims=lolims</span><span class="s3">,</span>
        <span class="s1">uplims=uplims</span><span class="s3">,</span>
        <span class="s1">xlolims=xlolims</span><span class="s3">,</span>
        <span class="s1">xuplims=xuplims</span><span class="s3">,</span>
        <span class="s1">errorevery=errorevery</span><span class="s3">,</span>
        <span class="s1">capthick=capthick</span><span class="s3">,</span>
        <span class="s1">**({</span><span class="s4">&quot;data&quot;</span><span class="s1">: data} </span><span class="s3">if </span><span class="s1">data </span><span class="s3">is not None else </span><span class="s1">{})</span><span class="s3">,</span>
        <span class="s1">**kwargs</span><span class="s3">,</span>
    <span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.eventplot)</span>
<span class="s3">def </span><span class="s1">eventplot(</span>
    <span class="s1">positions: ArrayLike | Sequence[ArrayLike]</span><span class="s3">,</span>
    <span class="s1">orientation: Literal[</span><span class="s4">&quot;horizontal&quot;</span><span class="s3">, </span><span class="s4">&quot;vertical&quot;</span><span class="s1">] = </span><span class="s4">&quot;horizontal&quot;</span><span class="s3">,</span>
    <span class="s1">lineoffsets: float | Sequence[float] = </span><span class="s5">1</span><span class="s3">,</span>
    <span class="s1">linelengths: float | Sequence[float] = </span><span class="s5">1</span><span class="s3">,</span>
    <span class="s1">linewidths: float | Sequence[float] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">colors: ColorType | Sequence[ColorType] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">alpha: float | Sequence[float] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">linestyles: LineStyleType | Sequence[LineStyleType] = </span><span class="s4">&quot;solid&quot;</span><span class="s3">,</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">data=</span><span class="s3">None,</span>
    <span class="s1">**kwargs</span><span class="s3">,</span>
<span class="s1">) -&gt; EventCollection:</span>
    <span class="s3">return </span><span class="s1">gca().eventplot(</span>
        <span class="s1">positions</span><span class="s3">,</span>
        <span class="s1">orientation=orientation</span><span class="s3">,</span>
        <span class="s1">lineoffsets=lineoffsets</span><span class="s3">,</span>
        <span class="s1">linelengths=linelengths</span><span class="s3">,</span>
        <span class="s1">linewidths=linewidths</span><span class="s3">,</span>
        <span class="s1">colors=colors</span><span class="s3">,</span>
        <span class="s1">alpha=alpha</span><span class="s3">,</span>
        <span class="s1">linestyles=linestyles</span><span class="s3">,</span>
        <span class="s1">**({</span><span class="s4">&quot;data&quot;</span><span class="s1">: data} </span><span class="s3">if </span><span class="s1">data </span><span class="s3">is not None else </span><span class="s1">{})</span><span class="s3">,</span>
        <span class="s1">**kwargs</span><span class="s3">,</span>
    <span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.fill)</span>
<span class="s3">def </span><span class="s1">fill(*args</span><span class="s3">, </span><span class="s1">data=</span><span class="s3">None, </span><span class="s1">**kwargs) -&gt; list[Polygon]:</span>
    <span class="s3">return </span><span class="s1">gca().fill(*args</span><span class="s3">, </span><span class="s1">**({</span><span class="s4">&quot;data&quot;</span><span class="s1">: data} </span><span class="s3">if </span><span class="s1">data </span><span class="s3">is not None else </span><span class="s1">{})</span><span class="s3">, </span><span class="s1">**kwargs)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.fill_between)</span>
<span class="s3">def </span><span class="s1">fill_between(</span>
    <span class="s1">x: ArrayLike</span><span class="s3">,</span>
    <span class="s1">y1: ArrayLike | float</span><span class="s3">,</span>
    <span class="s1">y2: ArrayLike | float = </span><span class="s5">0</span><span class="s3">,</span>
    <span class="s1">where: Sequence[bool] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">interpolate: bool = </span><span class="s3">False,</span>
    <span class="s1">step: Literal[</span><span class="s4">&quot;pre&quot;</span><span class="s3">, </span><span class="s4">&quot;post&quot;</span><span class="s3">, </span><span class="s4">&quot;mid&quot;</span><span class="s1">] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">data=</span><span class="s3">None,</span>
    <span class="s1">**kwargs</span><span class="s3">,</span>
<span class="s1">) -&gt; PolyCollection:</span>
    <span class="s3">return </span><span class="s1">gca().fill_between(</span>
        <span class="s1">x</span><span class="s3">,</span>
        <span class="s1">y1</span><span class="s3">,</span>
        <span class="s1">y2=y2</span><span class="s3">,</span>
        <span class="s1">where=where</span><span class="s3">,</span>
        <span class="s1">interpolate=interpolate</span><span class="s3">,</span>
        <span class="s1">step=step</span><span class="s3">,</span>
        <span class="s1">**({</span><span class="s4">&quot;data&quot;</span><span class="s1">: data} </span><span class="s3">if </span><span class="s1">data </span><span class="s3">is not None else </span><span class="s1">{})</span><span class="s3">,</span>
        <span class="s1">**kwargs</span><span class="s3">,</span>
    <span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.fill_betweenx)</span>
<span class="s3">def </span><span class="s1">fill_betweenx(</span>
    <span class="s1">y: ArrayLike</span><span class="s3">,</span>
    <span class="s1">x1: ArrayLike | float</span><span class="s3">,</span>
    <span class="s1">x2: ArrayLike | float = </span><span class="s5">0</span><span class="s3">,</span>
    <span class="s1">where: Sequence[bool] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">step: Literal[</span><span class="s4">&quot;pre&quot;</span><span class="s3">, </span><span class="s4">&quot;post&quot;</span><span class="s3">, </span><span class="s4">&quot;mid&quot;</span><span class="s1">] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">interpolate: bool = </span><span class="s3">False,</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">data=</span><span class="s3">None,</span>
    <span class="s1">**kwargs</span><span class="s3">,</span>
<span class="s1">) -&gt; PolyCollection:</span>
    <span class="s3">return </span><span class="s1">gca().fill_betweenx(</span>
        <span class="s1">y</span><span class="s3">,</span>
        <span class="s1">x1</span><span class="s3">,</span>
        <span class="s1">x2=x2</span><span class="s3">,</span>
        <span class="s1">where=where</span><span class="s3">,</span>
        <span class="s1">step=step</span><span class="s3">,</span>
        <span class="s1">interpolate=interpolate</span><span class="s3">,</span>
        <span class="s1">**({</span><span class="s4">&quot;data&quot;</span><span class="s1">: data} </span><span class="s3">if </span><span class="s1">data </span><span class="s3">is not None else </span><span class="s1">{})</span><span class="s3">,</span>
        <span class="s1">**kwargs</span><span class="s3">,</span>
    <span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.grid)</span>
<span class="s3">def </span><span class="s1">grid(</span>
    <span class="s1">visible: bool | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">which: Literal[</span><span class="s4">&quot;major&quot;</span><span class="s3">, </span><span class="s4">&quot;minor&quot;</span><span class="s3">, </span><span class="s4">&quot;both&quot;</span><span class="s1">] = </span><span class="s4">&quot;major&quot;</span><span class="s3">,</span>
    <span class="s1">axis: Literal[</span><span class="s4">&quot;both&quot;</span><span class="s3">, </span><span class="s4">&quot;x&quot;</span><span class="s3">, </span><span class="s4">&quot;y&quot;</span><span class="s1">] = </span><span class="s4">&quot;both&quot;</span><span class="s3">,</span>
    <span class="s1">**kwargs</span><span class="s3">,</span>
<span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s1">gca().grid(visible=visible</span><span class="s3">, </span><span class="s1">which=which</span><span class="s3">, </span><span class="s1">axis=axis</span><span class="s3">, </span><span class="s1">**kwargs)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.hexbin)</span>
<span class="s3">def </span><span class="s1">hexbin(</span>
    <span class="s1">x: ArrayLike</span><span class="s3">,</span>
    <span class="s1">y: ArrayLike</span><span class="s3">,</span>
    <span class="s1">C: ArrayLike | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">gridsize: int | tuple[int</span><span class="s3">, </span><span class="s1">int] = </span><span class="s5">100</span><span class="s3">,</span>
    <span class="s1">bins: Literal[</span><span class="s4">&quot;log&quot;</span><span class="s1">] | int | Sequence[float] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">xscale: Literal[</span><span class="s4">&quot;linear&quot;</span><span class="s3">, </span><span class="s4">&quot;log&quot;</span><span class="s1">] = </span><span class="s4">&quot;linear&quot;</span><span class="s3">,</span>
    <span class="s1">yscale: Literal[</span><span class="s4">&quot;linear&quot;</span><span class="s3">, </span><span class="s4">&quot;log&quot;</span><span class="s1">] = </span><span class="s4">&quot;linear&quot;</span><span class="s3">,</span>
    <span class="s1">extent: tuple[float</span><span class="s3">, </span><span class="s1">float</span><span class="s3">, </span><span class="s1">float</span><span class="s3">, </span><span class="s1">float] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">cmap: str | Colormap | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">norm: str | Normalize | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">vmin: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">vmax: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">alpha: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">linewidths: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">edgecolors: Literal[</span><span class="s4">&quot;face&quot;</span><span class="s3">, </span><span class="s4">&quot;none&quot;</span><span class="s1">] | ColorType = </span><span class="s4">&quot;face&quot;</span><span class="s3">,</span>
    <span class="s1">reduce_C_function: Callable[[np.ndarray | list[float]]</span><span class="s3">, </span><span class="s1">float] = np.mean</span><span class="s3">,</span>
    <span class="s1">mincnt: int | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">marginals: bool = </span><span class="s3">False,</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">data=</span><span class="s3">None,</span>
    <span class="s1">**kwargs</span><span class="s3">,</span>
<span class="s1">) -&gt; PolyCollection:</span>
    <span class="s1">__ret = gca().hexbin(</span>
        <span class="s1">x</span><span class="s3">,</span>
        <span class="s1">y</span><span class="s3">,</span>
        <span class="s1">C=C</span><span class="s3">,</span>
        <span class="s1">gridsize=gridsize</span><span class="s3">,</span>
        <span class="s1">bins=bins</span><span class="s3">,</span>
        <span class="s1">xscale=xscale</span><span class="s3">,</span>
        <span class="s1">yscale=yscale</span><span class="s3">,</span>
        <span class="s1">extent=extent</span><span class="s3">,</span>
        <span class="s1">cmap=cmap</span><span class="s3">,</span>
        <span class="s1">norm=norm</span><span class="s3">,</span>
        <span class="s1">vmin=vmin</span><span class="s3">,</span>
        <span class="s1">vmax=vmax</span><span class="s3">,</span>
        <span class="s1">alpha=alpha</span><span class="s3">,</span>
        <span class="s1">linewidths=linewidths</span><span class="s3">,</span>
        <span class="s1">edgecolors=edgecolors</span><span class="s3">,</span>
        <span class="s1">reduce_C_function=reduce_C_function</span><span class="s3">,</span>
        <span class="s1">mincnt=mincnt</span><span class="s3">,</span>
        <span class="s1">marginals=marginals</span><span class="s3">,</span>
        <span class="s1">**({</span><span class="s4">&quot;data&quot;</span><span class="s1">: data} </span><span class="s3">if </span><span class="s1">data </span><span class="s3">is not None else </span><span class="s1">{})</span><span class="s3">,</span>
        <span class="s1">**kwargs</span><span class="s3">,</span>
    <span class="s1">)</span>
    <span class="s1">sci(__ret)</span>
    <span class="s3">return </span><span class="s1">__ret</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.hist)</span>
<span class="s3">def </span><span class="s1">hist(</span>
    <span class="s1">x: ArrayLike | Sequence[ArrayLike]</span><span class="s3">,</span>
    <span class="s1">bins: int | Sequence[float] | str | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">range: tuple[float</span><span class="s3">, </span><span class="s1">float] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">density: bool = </span><span class="s3">False,</span>
    <span class="s1">weights: ArrayLike | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">cumulative: bool | float = </span><span class="s3">False,</span>
    <span class="s1">bottom: ArrayLike | float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">histtype: Literal[</span><span class="s4">&quot;bar&quot;</span><span class="s3">, </span><span class="s4">&quot;barstacked&quot;</span><span class="s3">, </span><span class="s4">&quot;step&quot;</span><span class="s3">, </span><span class="s4">&quot;stepfilled&quot;</span><span class="s1">] = </span><span class="s4">&quot;bar&quot;</span><span class="s3">,</span>
    <span class="s1">align: Literal[</span><span class="s4">&quot;left&quot;</span><span class="s3">, </span><span class="s4">&quot;mid&quot;</span><span class="s3">, </span><span class="s4">&quot;right&quot;</span><span class="s1">] = </span><span class="s4">&quot;mid&quot;</span><span class="s3">,</span>
    <span class="s1">orientation: Literal[</span><span class="s4">&quot;vertical&quot;</span><span class="s3">, </span><span class="s4">&quot;horizontal&quot;</span><span class="s1">] = </span><span class="s4">&quot;vertical&quot;</span><span class="s3">,</span>
    <span class="s1">rwidth: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">log: bool = </span><span class="s3">False,</span>
    <span class="s1">color: ColorType | Sequence[ColorType] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">label: str | Sequence[str] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">stacked: bool = </span><span class="s3">False,</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">data=</span><span class="s3">None,</span>
    <span class="s1">**kwargs</span><span class="s3">,</span>
<span class="s1">) -&gt; tuple[</span>
    <span class="s1">np.ndarray | list[np.ndarray]</span><span class="s3">,</span>
    <span class="s1">np.ndarray</span><span class="s3">,</span>
    <span class="s1">BarContainer | Polygon | list[BarContainer | Polygon]</span><span class="s3">,</span>
<span class="s1">]:</span>
    <span class="s3">return </span><span class="s1">gca().hist(</span>
        <span class="s1">x</span><span class="s3">,</span>
        <span class="s1">bins=bins</span><span class="s3">,</span>
        <span class="s1">range=range</span><span class="s3">,</span>
        <span class="s1">density=density</span><span class="s3">,</span>
        <span class="s1">weights=weights</span><span class="s3">,</span>
        <span class="s1">cumulative=cumulative</span><span class="s3">,</span>
        <span class="s1">bottom=bottom</span><span class="s3">,</span>
        <span class="s1">histtype=histtype</span><span class="s3">,</span>
        <span class="s1">align=align</span><span class="s3">,</span>
        <span class="s1">orientation=orientation</span><span class="s3">,</span>
        <span class="s1">rwidth=rwidth</span><span class="s3">,</span>
        <span class="s1">log=log</span><span class="s3">,</span>
        <span class="s1">color=color</span><span class="s3">,</span>
        <span class="s1">label=label</span><span class="s3">,</span>
        <span class="s1">stacked=stacked</span><span class="s3">,</span>
        <span class="s1">**({</span><span class="s4">&quot;data&quot;</span><span class="s1">: data} </span><span class="s3">if </span><span class="s1">data </span><span class="s3">is not None else </span><span class="s1">{})</span><span class="s3">,</span>
        <span class="s1">**kwargs</span><span class="s3">,</span>
    <span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.stairs)</span>
<span class="s3">def </span><span class="s1">stairs(</span>
    <span class="s1">values: ArrayLike</span><span class="s3">,</span>
    <span class="s1">edges: ArrayLike | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">orientation: Literal[</span><span class="s4">&quot;vertical&quot;</span><span class="s3">, </span><span class="s4">&quot;horizontal&quot;</span><span class="s1">] = </span><span class="s4">&quot;vertical&quot;</span><span class="s3">,</span>
    <span class="s1">baseline: float | ArrayLike | </span><span class="s3">None </span><span class="s1">= </span><span class="s5">0</span><span class="s3">,</span>
    <span class="s1">fill: bool = </span><span class="s3">False,</span>
    <span class="s1">data=</span><span class="s3">None,</span>
    <span class="s1">**kwargs</span><span class="s3">,</span>
<span class="s1">) -&gt; StepPatch:</span>
    <span class="s3">return </span><span class="s1">gca().stairs(</span>
        <span class="s1">values</span><span class="s3">,</span>
        <span class="s1">edges=edges</span><span class="s3">,</span>
        <span class="s1">orientation=orientation</span><span class="s3">,</span>
        <span class="s1">baseline=baseline</span><span class="s3">,</span>
        <span class="s1">fill=fill</span><span class="s3">,</span>
        <span class="s1">**({</span><span class="s4">&quot;data&quot;</span><span class="s1">: data} </span><span class="s3">if </span><span class="s1">data </span><span class="s3">is not None else </span><span class="s1">{})</span><span class="s3">,</span>
        <span class="s1">**kwargs</span><span class="s3">,</span>
    <span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.hist2d)</span>
<span class="s3">def </span><span class="s1">hist2d(</span>
    <span class="s1">x: ArrayLike</span><span class="s3">,</span>
    <span class="s1">y: ArrayLike</span><span class="s3">,</span>
    <span class="s1">bins: </span><span class="s3">None </span><span class="s1">| int | tuple[int</span><span class="s3">, </span><span class="s1">int] | ArrayLike | tuple[ArrayLike</span><span class="s3">, </span><span class="s1">ArrayLike] = </span><span class="s5">10</span><span class="s3">,</span>
    <span class="s1">range: ArrayLike | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">density: bool = </span><span class="s3">False,</span>
    <span class="s1">weights: ArrayLike | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">cmin: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">cmax: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">data=</span><span class="s3">None,</span>
    <span class="s1">**kwargs</span><span class="s3">,</span>
<span class="s1">) -&gt; tuple[np.ndarray</span><span class="s3">, </span><span class="s1">np.ndarray</span><span class="s3">, </span><span class="s1">np.ndarray</span><span class="s3">, </span><span class="s1">QuadMesh]:</span>
    <span class="s1">__ret = gca().hist2d(</span>
        <span class="s1">x</span><span class="s3">,</span>
        <span class="s1">y</span><span class="s3">,</span>
        <span class="s1">bins=bins</span><span class="s3">,</span>
        <span class="s1">range=range</span><span class="s3">,</span>
        <span class="s1">density=density</span><span class="s3">,</span>
        <span class="s1">weights=weights</span><span class="s3">,</span>
        <span class="s1">cmin=cmin</span><span class="s3">,</span>
        <span class="s1">cmax=cmax</span><span class="s3">,</span>
        <span class="s1">**({</span><span class="s4">&quot;data&quot;</span><span class="s1">: data} </span><span class="s3">if </span><span class="s1">data </span><span class="s3">is not None else </span><span class="s1">{})</span><span class="s3">,</span>
        <span class="s1">**kwargs</span><span class="s3">,</span>
    <span class="s1">)</span>
    <span class="s1">sci(__ret[-</span><span class="s5">1</span><span class="s1">])</span>
    <span class="s3">return </span><span class="s1">__ret</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.hlines)</span>
<span class="s3">def </span><span class="s1">hlines(</span>
    <span class="s1">y: float | ArrayLike</span><span class="s3">,</span>
    <span class="s1">xmin: float | ArrayLike</span><span class="s3">,</span>
    <span class="s1">xmax: float | ArrayLike</span><span class="s3">,</span>
    <span class="s1">colors: ColorType | Sequence[ColorType] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">linestyles: LineStyleType = </span><span class="s4">&quot;solid&quot;</span><span class="s3">,</span>
    <span class="s1">label: str = </span><span class="s4">&quot;&quot;</span><span class="s3">,</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">data=</span><span class="s3">None,</span>
    <span class="s1">**kwargs</span><span class="s3">,</span>
<span class="s1">) -&gt; LineCollection:</span>
    <span class="s3">return </span><span class="s1">gca().hlines(</span>
        <span class="s1">y</span><span class="s3">,</span>
        <span class="s1">xmin</span><span class="s3">,</span>
        <span class="s1">xmax</span><span class="s3">,</span>
        <span class="s1">colors=colors</span><span class="s3">,</span>
        <span class="s1">linestyles=linestyles</span><span class="s3">,</span>
        <span class="s1">label=label</span><span class="s3">,</span>
        <span class="s1">**({</span><span class="s4">&quot;data&quot;</span><span class="s1">: data} </span><span class="s3">if </span><span class="s1">data </span><span class="s3">is not None else </span><span class="s1">{})</span><span class="s3">,</span>
        <span class="s1">**kwargs</span><span class="s3">,</span>
    <span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.imshow)</span>
<span class="s3">def </span><span class="s1">imshow(</span>
    <span class="s1">X: ArrayLike | PIL.Image.Image</span><span class="s3">,</span>
    <span class="s1">cmap: str | Colormap | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">norm: str | Normalize | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">aspect: Literal[</span><span class="s4">&quot;equal&quot;</span><span class="s3">, </span><span class="s4">&quot;auto&quot;</span><span class="s1">] | float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">interpolation: str | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">alpha: float | ArrayLike | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">vmin: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">vmax: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">origin: Literal[</span><span class="s4">&quot;upper&quot;</span><span class="s3">, </span><span class="s4">&quot;lower&quot;</span><span class="s1">] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">extent: tuple[float</span><span class="s3">, </span><span class="s1">float</span><span class="s3">, </span><span class="s1">float</span><span class="s3">, </span><span class="s1">float] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">interpolation_stage: Literal[</span><span class="s4">&quot;data&quot;</span><span class="s3">, </span><span class="s4">&quot;rgba&quot;</span><span class="s1">] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">filternorm: bool = </span><span class="s3">True,</span>
    <span class="s1">filterrad: float = </span><span class="s5">4.0</span><span class="s3">,</span>
    <span class="s1">resample: bool | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">url: str | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">data=</span><span class="s3">None,</span>
    <span class="s1">**kwargs</span><span class="s3">,</span>
<span class="s1">) -&gt; AxesImage:</span>
    <span class="s1">__ret = gca().imshow(</span>
        <span class="s1">X</span><span class="s3">,</span>
        <span class="s1">cmap=cmap</span><span class="s3">,</span>
        <span class="s1">norm=norm</span><span class="s3">,</span>
        <span class="s1">aspect=aspect</span><span class="s3">,</span>
        <span class="s1">interpolation=interpolation</span><span class="s3">,</span>
        <span class="s1">alpha=alpha</span><span class="s3">,</span>
        <span class="s1">vmin=vmin</span><span class="s3">,</span>
        <span class="s1">vmax=vmax</span><span class="s3">,</span>
        <span class="s1">origin=origin</span><span class="s3">,</span>
        <span class="s1">extent=extent</span><span class="s3">,</span>
        <span class="s1">interpolation_stage=interpolation_stage</span><span class="s3">,</span>
        <span class="s1">filternorm=filternorm</span><span class="s3">,</span>
        <span class="s1">filterrad=filterrad</span><span class="s3">,</span>
        <span class="s1">resample=resample</span><span class="s3">,</span>
        <span class="s1">url=url</span><span class="s3">,</span>
        <span class="s1">**({</span><span class="s4">&quot;data&quot;</span><span class="s1">: data} </span><span class="s3">if </span><span class="s1">data </span><span class="s3">is not None else </span><span class="s1">{})</span><span class="s3">,</span>
        <span class="s1">**kwargs</span><span class="s3">,</span>
    <span class="s1">)</span>
    <span class="s1">sci(__ret)</span>
    <span class="s3">return </span><span class="s1">__ret</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.legend)</span>
<span class="s3">def </span><span class="s1">legend(*args</span><span class="s3">, </span><span class="s1">**kwargs) -&gt; Legend:</span>
    <span class="s3">return </span><span class="s1">gca().legend(*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.locator_params)</span>
<span class="s3">def </span><span class="s1">locator_params(</span>
    <span class="s1">axis: Literal[</span><span class="s4">&quot;both&quot;</span><span class="s3">, </span><span class="s4">&quot;x&quot;</span><span class="s3">, </span><span class="s4">&quot;y&quot;</span><span class="s1">] = </span><span class="s4">&quot;both&quot;</span><span class="s3">, </span><span class="s1">tight: bool | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None, </span><span class="s1">**kwargs</span>
<span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s1">gca().locator_params(axis=axis</span><span class="s3">, </span><span class="s1">tight=tight</span><span class="s3">, </span><span class="s1">**kwargs)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.loglog)</span>
<span class="s3">def </span><span class="s1">loglog(*args</span><span class="s3">, </span><span class="s1">**kwargs) -&gt; list[Line2D]:</span>
    <span class="s3">return </span><span class="s1">gca().loglog(*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.magnitude_spectrum)</span>
<span class="s3">def </span><span class="s1">magnitude_spectrum(</span>
    <span class="s1">x: ArrayLike</span><span class="s3">,</span>
    <span class="s1">Fs: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">Fc: int | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">window: Callable[[ArrayLike]</span><span class="s3">, </span><span class="s1">ArrayLike] | ArrayLike | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">pad_to: int | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">sides: Literal[</span><span class="s4">&quot;default&quot;</span><span class="s3">, </span><span class="s4">&quot;onesided&quot;</span><span class="s3">, </span><span class="s4">&quot;twosided&quot;</span><span class="s1">] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">scale: Literal[</span><span class="s4">&quot;default&quot;</span><span class="s3">, </span><span class="s4">&quot;linear&quot;</span><span class="s3">, </span><span class="s4">&quot;dB&quot;</span><span class="s1">] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">data=</span><span class="s3">None,</span>
    <span class="s1">**kwargs</span><span class="s3">,</span>
<span class="s1">) -&gt; tuple[np.ndarray</span><span class="s3">, </span><span class="s1">np.ndarray</span><span class="s3">, </span><span class="s1">Line2D]:</span>
    <span class="s3">return </span><span class="s1">gca().magnitude_spectrum(</span>
        <span class="s1">x</span><span class="s3">,</span>
        <span class="s1">Fs=Fs</span><span class="s3">,</span>
        <span class="s1">Fc=Fc</span><span class="s3">,</span>
        <span class="s1">window=window</span><span class="s3">,</span>
        <span class="s1">pad_to=pad_to</span><span class="s3">,</span>
        <span class="s1">sides=sides</span><span class="s3">,</span>
        <span class="s1">scale=scale</span><span class="s3">,</span>
        <span class="s1">**({</span><span class="s4">&quot;data&quot;</span><span class="s1">: data} </span><span class="s3">if </span><span class="s1">data </span><span class="s3">is not None else </span><span class="s1">{})</span><span class="s3">,</span>
        <span class="s1">**kwargs</span><span class="s3">,</span>
    <span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.margins)</span>
<span class="s3">def </span><span class="s1">margins(</span>
    <span class="s1">*margins: float</span><span class="s3">,</span>
    <span class="s1">x: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">y: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">tight: bool | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">True,</span>
<span class="s1">) -&gt; tuple[float</span><span class="s3">, </span><span class="s1">float] | </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s3">return </span><span class="s1">gca().margins(*margins</span><span class="s3">, </span><span class="s1">x=x</span><span class="s3">, </span><span class="s1">y=y</span><span class="s3">, </span><span class="s1">tight=tight)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.minorticks_off)</span>
<span class="s3">def </span><span class="s1">minorticks_off() -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s1">gca().minorticks_off()</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.minorticks_on)</span>
<span class="s3">def </span><span class="s1">minorticks_on() -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s1">gca().minorticks_on()</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.pcolor)</span>
<span class="s3">def </span><span class="s1">pcolor(</span>
    <span class="s1">*args: ArrayLike</span><span class="s3">,</span>
    <span class="s1">shading: Literal[</span><span class="s4">&quot;flat&quot;</span><span class="s3">, </span><span class="s4">&quot;nearest&quot;</span><span class="s3">, </span><span class="s4">&quot;auto&quot;</span><span class="s1">] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">alpha: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">norm: str | Normalize | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">cmap: str | Colormap | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">vmin: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">vmax: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">data=</span><span class="s3">None,</span>
    <span class="s1">**kwargs</span><span class="s3">,</span>
<span class="s1">) -&gt; Collection:</span>
    <span class="s1">__ret = gca().pcolor(</span>
        <span class="s1">*args</span><span class="s3">,</span>
        <span class="s1">shading=shading</span><span class="s3">,</span>
        <span class="s1">alpha=alpha</span><span class="s3">,</span>
        <span class="s1">norm=norm</span><span class="s3">,</span>
        <span class="s1">cmap=cmap</span><span class="s3">,</span>
        <span class="s1">vmin=vmin</span><span class="s3">,</span>
        <span class="s1">vmax=vmax</span><span class="s3">,</span>
        <span class="s1">**({</span><span class="s4">&quot;data&quot;</span><span class="s1">: data} </span><span class="s3">if </span><span class="s1">data </span><span class="s3">is not None else </span><span class="s1">{})</span><span class="s3">,</span>
        <span class="s1">**kwargs</span><span class="s3">,</span>
    <span class="s1">)</span>
    <span class="s1">sci(__ret)</span>
    <span class="s3">return </span><span class="s1">__ret</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.pcolormesh)</span>
<span class="s3">def </span><span class="s1">pcolormesh(</span>
    <span class="s1">*args: ArrayLike</span><span class="s3">,</span>
    <span class="s1">alpha: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">norm: str | Normalize | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">cmap: str | Colormap | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">vmin: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">vmax: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">shading: Literal[</span><span class="s4">&quot;flat&quot;</span><span class="s3">, </span><span class="s4">&quot;nearest&quot;</span><span class="s3">, </span><span class="s4">&quot;gouraud&quot;</span><span class="s3">, </span><span class="s4">&quot;auto&quot;</span><span class="s1">] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">antialiased: bool = </span><span class="s3">False,</span>
    <span class="s1">data=</span><span class="s3">None,</span>
    <span class="s1">**kwargs</span><span class="s3">,</span>
<span class="s1">) -&gt; QuadMesh:</span>
    <span class="s1">__ret = gca().pcolormesh(</span>
        <span class="s1">*args</span><span class="s3">,</span>
        <span class="s1">alpha=alpha</span><span class="s3">,</span>
        <span class="s1">norm=norm</span><span class="s3">,</span>
        <span class="s1">cmap=cmap</span><span class="s3">,</span>
        <span class="s1">vmin=vmin</span><span class="s3">,</span>
        <span class="s1">vmax=vmax</span><span class="s3">,</span>
        <span class="s1">shading=shading</span><span class="s3">,</span>
        <span class="s1">antialiased=antialiased</span><span class="s3">,</span>
        <span class="s1">**({</span><span class="s4">&quot;data&quot;</span><span class="s1">: data} </span><span class="s3">if </span><span class="s1">data </span><span class="s3">is not None else </span><span class="s1">{})</span><span class="s3">,</span>
        <span class="s1">**kwargs</span><span class="s3">,</span>
    <span class="s1">)</span>
    <span class="s1">sci(__ret)</span>
    <span class="s3">return </span><span class="s1">__ret</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.phase_spectrum)</span>
<span class="s3">def </span><span class="s1">phase_spectrum(</span>
    <span class="s1">x: ArrayLike</span><span class="s3">,</span>
    <span class="s1">Fs: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">Fc: int | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">window: Callable[[ArrayLike]</span><span class="s3">, </span><span class="s1">ArrayLike] | ArrayLike | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">pad_to: int | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">sides: Literal[</span><span class="s4">&quot;default&quot;</span><span class="s3">, </span><span class="s4">&quot;onesided&quot;</span><span class="s3">, </span><span class="s4">&quot;twosided&quot;</span><span class="s1">] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">data=</span><span class="s3">None,</span>
    <span class="s1">**kwargs</span><span class="s3">,</span>
<span class="s1">) -&gt; tuple[np.ndarray</span><span class="s3">, </span><span class="s1">np.ndarray</span><span class="s3">, </span><span class="s1">Line2D]:</span>
    <span class="s3">return </span><span class="s1">gca().phase_spectrum(</span>
        <span class="s1">x</span><span class="s3">,</span>
        <span class="s1">Fs=Fs</span><span class="s3">,</span>
        <span class="s1">Fc=Fc</span><span class="s3">,</span>
        <span class="s1">window=window</span><span class="s3">,</span>
        <span class="s1">pad_to=pad_to</span><span class="s3">,</span>
        <span class="s1">sides=sides</span><span class="s3">,</span>
        <span class="s1">**({</span><span class="s4">&quot;data&quot;</span><span class="s1">: data} </span><span class="s3">if </span><span class="s1">data </span><span class="s3">is not None else </span><span class="s1">{})</span><span class="s3">,</span>
        <span class="s1">**kwargs</span><span class="s3">,</span>
    <span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.pie)</span>
<span class="s3">def </span><span class="s1">pie(</span>
    <span class="s1">x: ArrayLike</span><span class="s3">,</span>
    <span class="s1">explode: ArrayLike | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">labels: Sequence[str] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">colors: ColorType | Sequence[ColorType] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">autopct: str | Callable[[float]</span><span class="s3">, </span><span class="s1">str] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">pctdistance: float = </span><span class="s5">0.6</span><span class="s3">,</span>
    <span class="s1">shadow: bool = </span><span class="s3">False,</span>
    <span class="s1">labeldistance: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s5">1.1</span><span class="s3">,</span>
    <span class="s1">startangle: float = </span><span class="s5">0</span><span class="s3">,</span>
    <span class="s1">radius: float = </span><span class="s5">1</span><span class="s3">,</span>
    <span class="s1">counterclock: bool = </span><span class="s3">True,</span>
    <span class="s1">wedgeprops: dict[str</span><span class="s3">, </span><span class="s1">Any] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">textprops: dict[str</span><span class="s3">, </span><span class="s1">Any] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">center: tuple[float</span><span class="s3">, </span><span class="s1">float] = (</span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">frame: bool = </span><span class="s3">False,</span>
    <span class="s1">rotatelabels: bool = </span><span class="s3">False,</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">normalize: bool = </span><span class="s3">True,</span>
    <span class="s1">hatch: str | Sequence[str] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">data=</span><span class="s3">None,</span>
<span class="s1">) -&gt; tuple[list[Wedge]</span><span class="s3">, </span><span class="s1">list[Text]] | tuple[list[Wedge]</span><span class="s3">, </span><span class="s1">list[Text]</span><span class="s3">, </span><span class="s1">list[Text]]:</span>
    <span class="s3">return </span><span class="s1">gca().pie(</span>
        <span class="s1">x</span><span class="s3">,</span>
        <span class="s1">explode=explode</span><span class="s3">,</span>
        <span class="s1">labels=labels</span><span class="s3">,</span>
        <span class="s1">colors=colors</span><span class="s3">,</span>
        <span class="s1">autopct=autopct</span><span class="s3">,</span>
        <span class="s1">pctdistance=pctdistance</span><span class="s3">,</span>
        <span class="s1">shadow=shadow</span><span class="s3">,</span>
        <span class="s1">labeldistance=labeldistance</span><span class="s3">,</span>
        <span class="s1">startangle=startangle</span><span class="s3">,</span>
        <span class="s1">radius=radius</span><span class="s3">,</span>
        <span class="s1">counterclock=counterclock</span><span class="s3">,</span>
        <span class="s1">wedgeprops=wedgeprops</span><span class="s3">,</span>
        <span class="s1">textprops=textprops</span><span class="s3">,</span>
        <span class="s1">center=center</span><span class="s3">,</span>
        <span class="s1">frame=frame</span><span class="s3">,</span>
        <span class="s1">rotatelabels=rotatelabels</span><span class="s3">,</span>
        <span class="s1">normalize=normalize</span><span class="s3">,</span>
        <span class="s1">hatch=hatch</span><span class="s3">,</span>
        <span class="s1">**({</span><span class="s4">&quot;data&quot;</span><span class="s1">: data} </span><span class="s3">if </span><span class="s1">data </span><span class="s3">is not None else </span><span class="s1">{})</span><span class="s3">,</span>
    <span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.plot)</span>
<span class="s3">def </span><span class="s1">plot(</span>
    <span class="s1">*args: float | ArrayLike | str</span><span class="s3">,</span>
    <span class="s1">scalex: bool = </span><span class="s3">True,</span>
    <span class="s1">scaley: bool = </span><span class="s3">True,</span>
    <span class="s1">data=</span><span class="s3">None,</span>
    <span class="s1">**kwargs</span><span class="s3">,</span>
<span class="s1">) -&gt; list[Line2D]:</span>
    <span class="s3">return </span><span class="s1">gca().plot(</span>
        <span class="s1">*args</span><span class="s3">,</span>
        <span class="s1">scalex=scalex</span><span class="s3">,</span>
        <span class="s1">scaley=scaley</span><span class="s3">,</span>
        <span class="s1">**({</span><span class="s4">&quot;data&quot;</span><span class="s1">: data} </span><span class="s3">if </span><span class="s1">data </span><span class="s3">is not None else </span><span class="s1">{})</span><span class="s3">,</span>
        <span class="s1">**kwargs</span><span class="s3">,</span>
    <span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.plot_date)</span>
<span class="s3">def </span><span class="s1">plot_date(</span>
    <span class="s1">x: ArrayLike</span><span class="s3">,</span>
    <span class="s1">y: ArrayLike</span><span class="s3">,</span>
    <span class="s1">fmt: str = </span><span class="s4">&quot;o&quot;</span><span class="s3">,</span>
    <span class="s1">tz: str | datetime.tzinfo | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">xdate: bool = </span><span class="s3">True,</span>
    <span class="s1">ydate: bool = </span><span class="s3">False,</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">data=</span><span class="s3">None,</span>
    <span class="s1">**kwargs</span><span class="s3">,</span>
<span class="s1">) -&gt; list[Line2D]:</span>
    <span class="s3">return </span><span class="s1">gca().plot_date(</span>
        <span class="s1">x</span><span class="s3">,</span>
        <span class="s1">y</span><span class="s3">,</span>
        <span class="s1">fmt=fmt</span><span class="s3">,</span>
        <span class="s1">tz=tz</span><span class="s3">,</span>
        <span class="s1">xdate=xdate</span><span class="s3">,</span>
        <span class="s1">ydate=ydate</span><span class="s3">,</span>
        <span class="s1">**({</span><span class="s4">&quot;data&quot;</span><span class="s1">: data} </span><span class="s3">if </span><span class="s1">data </span><span class="s3">is not None else </span><span class="s1">{})</span><span class="s3">,</span>
        <span class="s1">**kwargs</span><span class="s3">,</span>
    <span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.psd)</span>
<span class="s3">def </span><span class="s1">psd(</span>
    <span class="s1">x: ArrayLike</span><span class="s3">,</span>
    <span class="s1">NFFT: int | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">Fs: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">Fc: int | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">detrend: Literal[</span><span class="s4">&quot;none&quot;</span><span class="s3">, </span><span class="s4">&quot;mean&quot;</span><span class="s3">, </span><span class="s4">&quot;linear&quot;</span><span class="s1">]</span>
    <span class="s1">| Callable[[ArrayLike]</span><span class="s3">, </span><span class="s1">ArrayLike]</span>
    <span class="s1">| </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">window: Callable[[ArrayLike]</span><span class="s3">, </span><span class="s1">ArrayLike] | ArrayLike | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">noverlap: int | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">pad_to: int | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">sides: Literal[</span><span class="s4">&quot;default&quot;</span><span class="s3">, </span><span class="s4">&quot;onesided&quot;</span><span class="s3">, </span><span class="s4">&quot;twosided&quot;</span><span class="s1">] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">scale_by_freq: bool | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">return_line: bool | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">data=</span><span class="s3">None,</span>
    <span class="s1">**kwargs</span><span class="s3">,</span>
<span class="s1">) -&gt; tuple[np.ndarray</span><span class="s3">, </span><span class="s1">np.ndarray] | tuple[np.ndarray</span><span class="s3">, </span><span class="s1">np.ndarray</span><span class="s3">, </span><span class="s1">Line2D]:</span>
    <span class="s3">return </span><span class="s1">gca().psd(</span>
        <span class="s1">x</span><span class="s3">,</span>
        <span class="s1">NFFT=NFFT</span><span class="s3">,</span>
        <span class="s1">Fs=Fs</span><span class="s3">,</span>
        <span class="s1">Fc=Fc</span><span class="s3">,</span>
        <span class="s1">detrend=detrend</span><span class="s3">,</span>
        <span class="s1">window=window</span><span class="s3">,</span>
        <span class="s1">noverlap=noverlap</span><span class="s3">,</span>
        <span class="s1">pad_to=pad_to</span><span class="s3">,</span>
        <span class="s1">sides=sides</span><span class="s3">,</span>
        <span class="s1">scale_by_freq=scale_by_freq</span><span class="s3">,</span>
        <span class="s1">return_line=return_line</span><span class="s3">,</span>
        <span class="s1">**({</span><span class="s4">&quot;data&quot;</span><span class="s1">: data} </span><span class="s3">if </span><span class="s1">data </span><span class="s3">is not None else </span><span class="s1">{})</span><span class="s3">,</span>
        <span class="s1">**kwargs</span><span class="s3">,</span>
    <span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.quiver)</span>
<span class="s3">def </span><span class="s1">quiver(*args</span><span class="s3">, </span><span class="s1">data=</span><span class="s3">None, </span><span class="s1">**kwargs) -&gt; Quiver:</span>
    <span class="s1">__ret = gca().quiver(</span>
        <span class="s1">*args</span><span class="s3">, </span><span class="s1">**({</span><span class="s4">&quot;data&quot;</span><span class="s1">: data} </span><span class="s3">if </span><span class="s1">data </span><span class="s3">is not None else </span><span class="s1">{})</span><span class="s3">, </span><span class="s1">**kwargs</span>
    <span class="s1">)</span>
    <span class="s1">sci(__ret)</span>
    <span class="s3">return </span><span class="s1">__ret</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.quiverkey)</span>
<span class="s3">def </span><span class="s1">quiverkey(</span>
    <span class="s1">Q: Quiver</span><span class="s3">, </span><span class="s1">X: float</span><span class="s3">, </span><span class="s1">Y: float</span><span class="s3">, </span><span class="s1">U: float</span><span class="s3">, </span><span class="s1">label: str</span><span class="s3">, </span><span class="s1">**kwargs</span>
<span class="s1">) -&gt; QuiverKey:</span>
    <span class="s3">return </span><span class="s1">gca().quiverkey(Q</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">Y</span><span class="s3">, </span><span class="s1">U</span><span class="s3">, </span><span class="s1">label</span><span class="s3">, </span><span class="s1">**kwargs)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.scatter)</span>
<span class="s3">def </span><span class="s1">scatter(</span>
    <span class="s1">x: float | ArrayLike</span><span class="s3">,</span>
    <span class="s1">y: float | ArrayLike</span><span class="s3">,</span>
    <span class="s1">s: float | ArrayLike | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">c: ArrayLike | Sequence[ColorType] | ColorType | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">marker: MarkerType | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">cmap: str | Colormap | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">norm: str | Normalize | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">vmin: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">vmax: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">alpha: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">linewidths: float | Sequence[float] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">edgecolors: Literal[</span><span class="s4">&quot;face&quot;</span><span class="s3">, </span><span class="s4">&quot;none&quot;</span><span class="s1">] | ColorType | Sequence[ColorType] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">plotnonfinite: bool = </span><span class="s3">False,</span>
    <span class="s1">data=</span><span class="s3">None,</span>
    <span class="s1">**kwargs</span><span class="s3">,</span>
<span class="s1">) -&gt; PathCollection:</span>
    <span class="s1">__ret = gca().scatter(</span>
        <span class="s1">x</span><span class="s3">,</span>
        <span class="s1">y</span><span class="s3">,</span>
        <span class="s1">s=s</span><span class="s3">,</span>
        <span class="s1">c=c</span><span class="s3">,</span>
        <span class="s1">marker=marker</span><span class="s3">,</span>
        <span class="s1">cmap=cmap</span><span class="s3">,</span>
        <span class="s1">norm=norm</span><span class="s3">,</span>
        <span class="s1">vmin=vmin</span><span class="s3">,</span>
        <span class="s1">vmax=vmax</span><span class="s3">,</span>
        <span class="s1">alpha=alpha</span><span class="s3">,</span>
        <span class="s1">linewidths=linewidths</span><span class="s3">,</span>
        <span class="s1">edgecolors=edgecolors</span><span class="s3">,</span>
        <span class="s1">plotnonfinite=plotnonfinite</span><span class="s3">,</span>
        <span class="s1">**({</span><span class="s4">&quot;data&quot;</span><span class="s1">: data} </span><span class="s3">if </span><span class="s1">data </span><span class="s3">is not None else </span><span class="s1">{})</span><span class="s3">,</span>
        <span class="s1">**kwargs</span><span class="s3">,</span>
    <span class="s1">)</span>
    <span class="s1">sci(__ret)</span>
    <span class="s3">return </span><span class="s1">__ret</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.semilogx)</span>
<span class="s3">def </span><span class="s1">semilogx(*args</span><span class="s3">, </span><span class="s1">**kwargs) -&gt; list[Line2D]:</span>
    <span class="s3">return </span><span class="s1">gca().semilogx(*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.semilogy)</span>
<span class="s3">def </span><span class="s1">semilogy(*args</span><span class="s3">, </span><span class="s1">**kwargs) -&gt; list[Line2D]:</span>
    <span class="s3">return </span><span class="s1">gca().semilogy(*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.specgram)</span>
<span class="s3">def </span><span class="s1">specgram(</span>
    <span class="s1">x: ArrayLike</span><span class="s3">,</span>
    <span class="s1">NFFT: int | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">Fs: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">Fc: int | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">detrend: Literal[</span><span class="s4">&quot;none&quot;</span><span class="s3">, </span><span class="s4">&quot;mean&quot;</span><span class="s3">, </span><span class="s4">&quot;linear&quot;</span><span class="s1">]</span>
    <span class="s1">| Callable[[ArrayLike]</span><span class="s3">, </span><span class="s1">ArrayLike]</span>
    <span class="s1">| </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">window: Callable[[ArrayLike]</span><span class="s3">, </span><span class="s1">ArrayLike] | ArrayLike | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">noverlap: int | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">cmap: str | Colormap | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">xextent: tuple[float</span><span class="s3">, </span><span class="s1">float] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">pad_to: int | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">sides: Literal[</span><span class="s4">&quot;default&quot;</span><span class="s3">, </span><span class="s4">&quot;onesided&quot;</span><span class="s3">, </span><span class="s4">&quot;twosided&quot;</span><span class="s1">] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">scale_by_freq: bool | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">mode: Literal[</span><span class="s4">&quot;default&quot;</span><span class="s3">, </span><span class="s4">&quot;psd&quot;</span><span class="s3">, </span><span class="s4">&quot;magnitude&quot;</span><span class="s3">, </span><span class="s4">&quot;angle&quot;</span><span class="s3">, </span><span class="s4">&quot;phase&quot;</span><span class="s1">] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">scale: Literal[</span><span class="s4">&quot;default&quot;</span><span class="s3">, </span><span class="s4">&quot;linear&quot;</span><span class="s3">, </span><span class="s4">&quot;dB&quot;</span><span class="s1">] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">vmin: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">vmax: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">data=</span><span class="s3">None,</span>
    <span class="s1">**kwargs</span><span class="s3">,</span>
<span class="s1">) -&gt; tuple[np.ndarray</span><span class="s3">, </span><span class="s1">np.ndarray</span><span class="s3">, </span><span class="s1">np.ndarray</span><span class="s3">, </span><span class="s1">AxesImage]:</span>
    <span class="s1">__ret = gca().specgram(</span>
        <span class="s1">x</span><span class="s3">,</span>
        <span class="s1">NFFT=NFFT</span><span class="s3">,</span>
        <span class="s1">Fs=Fs</span><span class="s3">,</span>
        <span class="s1">Fc=Fc</span><span class="s3">,</span>
        <span class="s1">detrend=detrend</span><span class="s3">,</span>
        <span class="s1">window=window</span><span class="s3">,</span>
        <span class="s1">noverlap=noverlap</span><span class="s3">,</span>
        <span class="s1">cmap=cmap</span><span class="s3">,</span>
        <span class="s1">xextent=xextent</span><span class="s3">,</span>
        <span class="s1">pad_to=pad_to</span><span class="s3">,</span>
        <span class="s1">sides=sides</span><span class="s3">,</span>
        <span class="s1">scale_by_freq=scale_by_freq</span><span class="s3">,</span>
        <span class="s1">mode=mode</span><span class="s3">,</span>
        <span class="s1">scale=scale</span><span class="s3">,</span>
        <span class="s1">vmin=vmin</span><span class="s3">,</span>
        <span class="s1">vmax=vmax</span><span class="s3">,</span>
        <span class="s1">**({</span><span class="s4">&quot;data&quot;</span><span class="s1">: data} </span><span class="s3">if </span><span class="s1">data </span><span class="s3">is not None else </span><span class="s1">{})</span><span class="s3">,</span>
        <span class="s1">**kwargs</span><span class="s3">,</span>
    <span class="s1">)</span>
    <span class="s1">sci(__ret[-</span><span class="s5">1</span><span class="s1">])</span>
    <span class="s3">return </span><span class="s1">__ret</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.spy)</span>
<span class="s3">def </span><span class="s1">spy(</span>
    <span class="s1">Z: ArrayLike</span><span class="s3">,</span>
    <span class="s1">precision: float | Literal[</span><span class="s4">&quot;present&quot;</span><span class="s1">] = </span><span class="s5">0</span><span class="s3">,</span>
    <span class="s1">marker: str | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">markersize: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">aspect: Literal[</span><span class="s4">&quot;equal&quot;</span><span class="s3">, </span><span class="s4">&quot;auto&quot;</span><span class="s1">] | float | </span><span class="s3">None </span><span class="s1">= </span><span class="s4">&quot;equal&quot;</span><span class="s3">,</span>
    <span class="s1">origin: Literal[</span><span class="s4">&quot;upper&quot;</span><span class="s3">, </span><span class="s4">&quot;lower&quot;</span><span class="s1">] = </span><span class="s4">&quot;upper&quot;</span><span class="s3">,</span>
    <span class="s1">**kwargs</span><span class="s3">,</span>
<span class="s1">) -&gt; AxesImage:</span>
    <span class="s1">__ret = gca().spy(</span>
        <span class="s1">Z</span><span class="s3">,</span>
        <span class="s1">precision=precision</span><span class="s3">,</span>
        <span class="s1">marker=marker</span><span class="s3">,</span>
        <span class="s1">markersize=markersize</span><span class="s3">,</span>
        <span class="s1">aspect=aspect</span><span class="s3">,</span>
        <span class="s1">origin=origin</span><span class="s3">,</span>
        <span class="s1">**kwargs</span><span class="s3">,</span>
    <span class="s1">)</span>
    <span class="s3">if </span><span class="s1">isinstance(__ret</span><span class="s3">, </span><span class="s1">cm.ScalarMappable):</span>
        <span class="s1">sci(__ret)  </span><span class="s0"># noqa</span>
    <span class="s3">return </span><span class="s1">__ret</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.stackplot)</span>
<span class="s3">def </span><span class="s1">stackplot(x</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">labels=()</span><span class="s3">, </span><span class="s1">colors=</span><span class="s3">None, </span><span class="s1">baseline=</span><span class="s4">&quot;zero&quot;</span><span class="s3">, </span><span class="s1">data=</span><span class="s3">None, </span><span class="s1">**kwargs):</span>
    <span class="s3">return </span><span class="s1">gca().stackplot(</span>
        <span class="s1">x</span><span class="s3">,</span>
        <span class="s1">*args</span><span class="s3">,</span>
        <span class="s1">labels=labels</span><span class="s3">,</span>
        <span class="s1">colors=colors</span><span class="s3">,</span>
        <span class="s1">baseline=baseline</span><span class="s3">,</span>
        <span class="s1">**({</span><span class="s4">&quot;data&quot;</span><span class="s1">: data} </span><span class="s3">if </span><span class="s1">data </span><span class="s3">is not None else </span><span class="s1">{})</span><span class="s3">,</span>
        <span class="s1">**kwargs</span><span class="s3">,</span>
    <span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.stem)</span>
<span class="s3">def </span><span class="s1">stem(</span>
    <span class="s1">*args: ArrayLike | str</span><span class="s3">,</span>
    <span class="s1">linefmt: str | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">markerfmt: str | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">basefmt: str | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">bottom: float = </span><span class="s5">0</span><span class="s3">,</span>
    <span class="s1">label: str | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">orientation: Literal[</span><span class="s4">&quot;vertical&quot;</span><span class="s3">, </span><span class="s4">&quot;horizontal&quot;</span><span class="s1">] = </span><span class="s4">&quot;vertical&quot;</span><span class="s3">,</span>
    <span class="s1">data=</span><span class="s3">None,</span>
<span class="s1">) -&gt; StemContainer:</span>
    <span class="s3">return </span><span class="s1">gca().stem(</span>
        <span class="s1">*args</span><span class="s3">,</span>
        <span class="s1">linefmt=linefmt</span><span class="s3">,</span>
        <span class="s1">markerfmt=markerfmt</span><span class="s3">,</span>
        <span class="s1">basefmt=basefmt</span><span class="s3">,</span>
        <span class="s1">bottom=bottom</span><span class="s3">,</span>
        <span class="s1">label=label</span><span class="s3">,</span>
        <span class="s1">orientation=orientation</span><span class="s3">,</span>
        <span class="s1">**({</span><span class="s4">&quot;data&quot;</span><span class="s1">: data} </span><span class="s3">if </span><span class="s1">data </span><span class="s3">is not None else </span><span class="s1">{})</span><span class="s3">,</span>
    <span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.step)</span>
<span class="s3">def </span><span class="s1">step(</span>
    <span class="s1">x: ArrayLike</span><span class="s3">,</span>
    <span class="s1">y: ArrayLike</span><span class="s3">,</span>
    <span class="s1">*args</span><span class="s3">,</span>
    <span class="s1">where: Literal[</span><span class="s4">&quot;pre&quot;</span><span class="s3">, </span><span class="s4">&quot;post&quot;</span><span class="s3">, </span><span class="s4">&quot;mid&quot;</span><span class="s1">] = </span><span class="s4">&quot;pre&quot;</span><span class="s3">,</span>
    <span class="s1">data=</span><span class="s3">None,</span>
    <span class="s1">**kwargs</span><span class="s3">,</span>
<span class="s1">) -&gt; list[Line2D]:</span>
    <span class="s3">return </span><span class="s1">gca().step(</span>
        <span class="s1">x</span><span class="s3">,</span>
        <span class="s1">y</span><span class="s3">,</span>
        <span class="s1">*args</span><span class="s3">,</span>
        <span class="s1">where=where</span><span class="s3">,</span>
        <span class="s1">**({</span><span class="s4">&quot;data&quot;</span><span class="s1">: data} </span><span class="s3">if </span><span class="s1">data </span><span class="s3">is not None else </span><span class="s1">{})</span><span class="s3">,</span>
        <span class="s1">**kwargs</span><span class="s3">,</span>
    <span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.streamplot)</span>
<span class="s3">def </span><span class="s1">streamplot(</span>
    <span class="s1">x</span><span class="s3">,</span>
    <span class="s1">y</span><span class="s3">,</span>
    <span class="s1">u</span><span class="s3">,</span>
    <span class="s1">v</span><span class="s3">,</span>
    <span class="s1">density=</span><span class="s5">1</span><span class="s3">,</span>
    <span class="s1">linewidth=</span><span class="s3">None,</span>
    <span class="s1">color=</span><span class="s3">None,</span>
    <span class="s1">cmap=</span><span class="s3">None,</span>
    <span class="s1">norm=</span><span class="s3">None,</span>
    <span class="s1">arrowsize=</span><span class="s5">1</span><span class="s3">,</span>
    <span class="s1">arrowstyle=</span><span class="s4">&quot;-|&gt;&quot;</span><span class="s3">,</span>
    <span class="s1">minlength=</span><span class="s5">0.1</span><span class="s3">,</span>
    <span class="s1">transform=</span><span class="s3">None,</span>
    <span class="s1">zorder=</span><span class="s3">None,</span>
    <span class="s1">start_points=</span><span class="s3">None,</span>
    <span class="s1">maxlength=</span><span class="s5">4.0</span><span class="s3">,</span>
    <span class="s1">integration_direction=</span><span class="s4">&quot;both&quot;</span><span class="s3">,</span>
    <span class="s1">broken_streamlines=</span><span class="s3">True,</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">data=</span><span class="s3">None,</span>
<span class="s1">):</span>
    <span class="s1">__ret = gca().streamplot(</span>
        <span class="s1">x</span><span class="s3">,</span>
        <span class="s1">y</span><span class="s3">,</span>
        <span class="s1">u</span><span class="s3">,</span>
        <span class="s1">v</span><span class="s3">,</span>
        <span class="s1">density=density</span><span class="s3">,</span>
        <span class="s1">linewidth=linewidth</span><span class="s3">,</span>
        <span class="s1">color=color</span><span class="s3">,</span>
        <span class="s1">cmap=cmap</span><span class="s3">,</span>
        <span class="s1">norm=norm</span><span class="s3">,</span>
        <span class="s1">arrowsize=arrowsize</span><span class="s3">,</span>
        <span class="s1">arrowstyle=arrowstyle</span><span class="s3">,</span>
        <span class="s1">minlength=minlength</span><span class="s3">,</span>
        <span class="s1">transform=transform</span><span class="s3">,</span>
        <span class="s1">zorder=zorder</span><span class="s3">,</span>
        <span class="s1">start_points=start_points</span><span class="s3">,</span>
        <span class="s1">maxlength=maxlength</span><span class="s3">,</span>
        <span class="s1">integration_direction=integration_direction</span><span class="s3">,</span>
        <span class="s1">broken_streamlines=broken_streamlines</span><span class="s3">,</span>
        <span class="s1">**({</span><span class="s4">&quot;data&quot;</span><span class="s1">: data} </span><span class="s3">if </span><span class="s1">data </span><span class="s3">is not None else </span><span class="s1">{})</span><span class="s3">,</span>
    <span class="s1">)</span>
    <span class="s1">sci(__ret.lines)</span>
    <span class="s3">return </span><span class="s1">__ret</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.table)</span>
<span class="s3">def </span><span class="s1">table(</span>
    <span class="s1">cellText=</span><span class="s3">None,</span>
    <span class="s1">cellColours=</span><span class="s3">None,</span>
    <span class="s1">cellLoc=</span><span class="s4">&quot;right&quot;</span><span class="s3">,</span>
    <span class="s1">colWidths=</span><span class="s3">None,</span>
    <span class="s1">rowLabels=</span><span class="s3">None,</span>
    <span class="s1">rowColours=</span><span class="s3">None,</span>
    <span class="s1">rowLoc=</span><span class="s4">&quot;left&quot;</span><span class="s3">,</span>
    <span class="s1">colLabels=</span><span class="s3">None,</span>
    <span class="s1">colColours=</span><span class="s3">None,</span>
    <span class="s1">colLoc=</span><span class="s4">&quot;center&quot;</span><span class="s3">,</span>
    <span class="s1">loc=</span><span class="s4">&quot;bottom&quot;</span><span class="s3">,</span>
    <span class="s1">bbox=</span><span class="s3">None,</span>
    <span class="s1">edges=</span><span class="s4">&quot;closed&quot;</span><span class="s3">,</span>
    <span class="s1">**kwargs</span><span class="s3">,</span>
<span class="s1">):</span>
    <span class="s3">return </span><span class="s1">gca().table(</span>
        <span class="s1">cellText=cellText</span><span class="s3">,</span>
        <span class="s1">cellColours=cellColours</span><span class="s3">,</span>
        <span class="s1">cellLoc=cellLoc</span><span class="s3">,</span>
        <span class="s1">colWidths=colWidths</span><span class="s3">,</span>
        <span class="s1">rowLabels=rowLabels</span><span class="s3">,</span>
        <span class="s1">rowColours=rowColours</span><span class="s3">,</span>
        <span class="s1">rowLoc=rowLoc</span><span class="s3">,</span>
        <span class="s1">colLabels=colLabels</span><span class="s3">,</span>
        <span class="s1">colColours=colColours</span><span class="s3">,</span>
        <span class="s1">colLoc=colLoc</span><span class="s3">,</span>
        <span class="s1">loc=loc</span><span class="s3">,</span>
        <span class="s1">bbox=bbox</span><span class="s3">,</span>
        <span class="s1">edges=edges</span><span class="s3">,</span>
        <span class="s1">**kwargs</span><span class="s3">,</span>
    <span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.text)</span>
<span class="s3">def </span><span class="s1">text(</span>
    <span class="s1">x: float</span><span class="s3">, </span><span class="s1">y: float</span><span class="s3">, </span><span class="s1">s: str</span><span class="s3">, </span><span class="s1">fontdict: dict[str</span><span class="s3">, </span><span class="s1">Any] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None, </span><span class="s1">**kwargs</span>
<span class="s1">) -&gt; Text:</span>
    <span class="s3">return </span><span class="s1">gca().text(x</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">s</span><span class="s3">, </span><span class="s1">fontdict=fontdict</span><span class="s3">, </span><span class="s1">**kwargs)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.tick_params)</span>
<span class="s3">def </span><span class="s1">tick_params(axis: Literal[</span><span class="s4">&quot;both&quot;</span><span class="s3">, </span><span class="s4">&quot;x&quot;</span><span class="s3">, </span><span class="s4">&quot;y&quot;</span><span class="s1">] = </span><span class="s4">&quot;both&quot;</span><span class="s3">, </span><span class="s1">**kwargs) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s1">gca().tick_params(axis=axis</span><span class="s3">, </span><span class="s1">**kwargs)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.ticklabel_format)</span>
<span class="s3">def </span><span class="s1">ticklabel_format(</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">axis: Literal[</span><span class="s4">&quot;both&quot;</span><span class="s3">, </span><span class="s4">&quot;x&quot;</span><span class="s3">, </span><span class="s4">&quot;y&quot;</span><span class="s1">] = </span><span class="s4">&quot;both&quot;</span><span class="s3">,</span>
    <span class="s1">style: Literal[</span><span class="s4">&quot;&quot;</span><span class="s3">, </span><span class="s4">&quot;sci&quot;</span><span class="s3">, </span><span class="s4">&quot;scientific&quot;</span><span class="s3">, </span><span class="s4">&quot;plain&quot;</span><span class="s1">] = </span><span class="s4">&quot;&quot;</span><span class="s3">,</span>
    <span class="s1">scilimits: tuple[int</span><span class="s3">, </span><span class="s1">int] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">useOffset: bool | float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">useLocale: bool | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">useMathText: bool | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
<span class="s1">) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s1">gca().ticklabel_format(</span>
        <span class="s1">axis=axis</span><span class="s3">,</span>
        <span class="s1">style=style</span><span class="s3">,</span>
        <span class="s1">scilimits=scilimits</span><span class="s3">,</span>
        <span class="s1">useOffset=useOffset</span><span class="s3">,</span>
        <span class="s1">useLocale=useLocale</span><span class="s3">,</span>
        <span class="s1">useMathText=useMathText</span><span class="s3">,</span>
    <span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.tricontour)</span>
<span class="s3">def </span><span class="s1">tricontour(*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
    <span class="s1">__ret = gca().tricontour(*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>
    <span class="s3">if </span><span class="s1">__ret._A </span><span class="s3">is not None</span><span class="s1">:  </span><span class="s0"># type: ignore[attr-defined]</span>
        <span class="s1">sci(__ret)</span>
    <span class="s3">return </span><span class="s1">__ret</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.tricontourf)</span>
<span class="s3">def </span><span class="s1">tricontourf(*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
    <span class="s1">__ret = gca().tricontourf(*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>
    <span class="s3">if </span><span class="s1">__ret._A </span><span class="s3">is not None</span><span class="s1">:  </span><span class="s0"># type: ignore[attr-defined]</span>
        <span class="s1">sci(__ret)</span>
    <span class="s3">return </span><span class="s1">__ret</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.tripcolor)</span>
<span class="s3">def </span><span class="s1">tripcolor(</span>
    <span class="s1">*args</span><span class="s3">,</span>
    <span class="s1">alpha=</span><span class="s5">1.0</span><span class="s3">,</span>
    <span class="s1">norm=</span><span class="s3">None,</span>
    <span class="s1">cmap=</span><span class="s3">None,</span>
    <span class="s1">vmin=</span><span class="s3">None,</span>
    <span class="s1">vmax=</span><span class="s3">None,</span>
    <span class="s1">shading=</span><span class="s4">&quot;flat&quot;</span><span class="s3">,</span>
    <span class="s1">facecolors=</span><span class="s3">None,</span>
    <span class="s1">**kwargs</span><span class="s3">,</span>
<span class="s1">):</span>
    <span class="s1">__ret = gca().tripcolor(</span>
        <span class="s1">*args</span><span class="s3">,</span>
        <span class="s1">alpha=alpha</span><span class="s3">,</span>
        <span class="s1">norm=norm</span><span class="s3">,</span>
        <span class="s1">cmap=cmap</span><span class="s3">,</span>
        <span class="s1">vmin=vmin</span><span class="s3">,</span>
        <span class="s1">vmax=vmax</span><span class="s3">,</span>
        <span class="s1">shading=shading</span><span class="s3">,</span>
        <span class="s1">facecolors=facecolors</span><span class="s3">,</span>
        <span class="s1">**kwargs</span><span class="s3">,</span>
    <span class="s1">)</span>
    <span class="s1">sci(__ret)</span>
    <span class="s3">return </span><span class="s1">__ret</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.triplot)</span>
<span class="s3">def </span><span class="s1">triplot(*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
    <span class="s3">return </span><span class="s1">gca().triplot(*args</span><span class="s3">, </span><span class="s1">**kwargs)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.violinplot)</span>
<span class="s3">def </span><span class="s1">violinplot(</span>
    <span class="s1">dataset: ArrayLike | Sequence[ArrayLike]</span><span class="s3">,</span>
    <span class="s1">positions: ArrayLike | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">vert: bool = </span><span class="s3">True,</span>
    <span class="s1">widths: float | ArrayLike = </span><span class="s5">0.5</span><span class="s3">,</span>
    <span class="s1">showmeans: bool = </span><span class="s3">False,</span>
    <span class="s1">showextrema: bool = </span><span class="s3">True,</span>
    <span class="s1">showmedians: bool = </span><span class="s3">False,</span>
    <span class="s1">quantiles: Sequence[float | Sequence[float]] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">points: int = </span><span class="s5">100</span><span class="s3">,</span>
    <span class="s1">bw_method: Literal[</span><span class="s4">&quot;scott&quot;</span><span class="s3">, </span><span class="s4">&quot;silverman&quot;</span><span class="s1">]</span>
    <span class="s1">| float</span>
    <span class="s1">| Callable[[GaussianKDE]</span><span class="s3">, </span><span class="s1">float]</span>
    <span class="s1">| </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">data=</span><span class="s3">None,</span>
<span class="s1">) -&gt; dict[str</span><span class="s3">, </span><span class="s1">Collection]:</span>
    <span class="s3">return </span><span class="s1">gca().violinplot(</span>
        <span class="s1">dataset</span><span class="s3">,</span>
        <span class="s1">positions=positions</span><span class="s3">,</span>
        <span class="s1">vert=vert</span><span class="s3">,</span>
        <span class="s1">widths=widths</span><span class="s3">,</span>
        <span class="s1">showmeans=showmeans</span><span class="s3">,</span>
        <span class="s1">showextrema=showextrema</span><span class="s3">,</span>
        <span class="s1">showmedians=showmedians</span><span class="s3">,</span>
        <span class="s1">quantiles=quantiles</span><span class="s3">,</span>
        <span class="s1">points=points</span><span class="s3">,</span>
        <span class="s1">bw_method=bw_method</span><span class="s3">,</span>
        <span class="s1">**({</span><span class="s4">&quot;data&quot;</span><span class="s1">: data} </span><span class="s3">if </span><span class="s1">data </span><span class="s3">is not None else </span><span class="s1">{})</span><span class="s3">,</span>
    <span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.vlines)</span>
<span class="s3">def </span><span class="s1">vlines(</span>
    <span class="s1">x: float | ArrayLike</span><span class="s3">,</span>
    <span class="s1">ymin: float | ArrayLike</span><span class="s3">,</span>
    <span class="s1">ymax: float | ArrayLike</span><span class="s3">,</span>
    <span class="s1">colors: ColorType | Sequence[ColorType] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">linestyles: LineStyleType = </span><span class="s4">&quot;solid&quot;</span><span class="s3">,</span>
    <span class="s1">label: str = </span><span class="s4">&quot;&quot;</span><span class="s3">,</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">data=</span><span class="s3">None,</span>
    <span class="s1">**kwargs</span><span class="s3">,</span>
<span class="s1">) -&gt; LineCollection:</span>
    <span class="s3">return </span><span class="s1">gca().vlines(</span>
        <span class="s1">x</span><span class="s3">,</span>
        <span class="s1">ymin</span><span class="s3">,</span>
        <span class="s1">ymax</span><span class="s3">,</span>
        <span class="s1">colors=colors</span><span class="s3">,</span>
        <span class="s1">linestyles=linestyles</span><span class="s3">,</span>
        <span class="s1">label=label</span><span class="s3">,</span>
        <span class="s1">**({</span><span class="s4">&quot;data&quot;</span><span class="s1">: data} </span><span class="s3">if </span><span class="s1">data </span><span class="s3">is not None else </span><span class="s1">{})</span><span class="s3">,</span>
        <span class="s1">**kwargs</span><span class="s3">,</span>
    <span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.xcorr)</span>
<span class="s3">def </span><span class="s1">xcorr(</span>
    <span class="s1">x: ArrayLike</span><span class="s3">,</span>
    <span class="s1">y: ArrayLike</span><span class="s3">,</span>
    <span class="s1">normed: bool = </span><span class="s3">True,</span>
    <span class="s1">detrend: Callable[[ArrayLike]</span><span class="s3">, </span><span class="s1">ArrayLike] = mlab.detrend_none</span><span class="s3">,</span>
    <span class="s1">usevlines: bool = </span><span class="s3">True,</span>
    <span class="s1">maxlags: int = </span><span class="s5">10</span><span class="s3">,</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">data=</span><span class="s3">None,</span>
    <span class="s1">**kwargs</span><span class="s3">,</span>
<span class="s1">) -&gt; tuple[np.ndarray</span><span class="s3">, </span><span class="s1">np.ndarray</span><span class="s3">, </span><span class="s1">LineCollection | Line2D</span><span class="s3">, </span><span class="s1">Line2D | </span><span class="s3">None</span><span class="s1">]:</span>
    <span class="s3">return </span><span class="s1">gca().xcorr(</span>
        <span class="s1">x</span><span class="s3">,</span>
        <span class="s1">y</span><span class="s3">,</span>
        <span class="s1">normed=normed</span><span class="s3">,</span>
        <span class="s1">detrend=detrend</span><span class="s3">,</span>
        <span class="s1">usevlines=usevlines</span><span class="s3">,</span>
        <span class="s1">maxlags=maxlags</span><span class="s3">,</span>
        <span class="s1">**({</span><span class="s4">&quot;data&quot;</span><span class="s1">: data} </span><span class="s3">if </span><span class="s1">data </span><span class="s3">is not None else </span><span class="s1">{})</span><span class="s3">,</span>
        <span class="s1">**kwargs</span><span class="s3">,</span>
    <span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes._sci)</span>
<span class="s3">def </span><span class="s1">sci(im: ScalarMappable) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s1">gca()._sci(im)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.set_title)</span>
<span class="s3">def </span><span class="s1">title(</span>
    <span class="s1">label: str</span><span class="s3">,</span>
    <span class="s1">fontdict: dict[str</span><span class="s3">, </span><span class="s1">Any] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">loc: Literal[</span><span class="s4">&quot;left&quot;</span><span class="s3">, </span><span class="s4">&quot;center&quot;</span><span class="s3">, </span><span class="s4">&quot;right&quot;</span><span class="s1">] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">pad: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">y: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">**kwargs</span><span class="s3">,</span>
<span class="s1">) -&gt; Text:</span>
    <span class="s3">return </span><span class="s1">gca().set_title(label</span><span class="s3">, </span><span class="s1">fontdict=fontdict</span><span class="s3">, </span><span class="s1">loc=loc</span><span class="s3">, </span><span class="s1">pad=pad</span><span class="s3">, </span><span class="s1">y=y</span><span class="s3">, </span><span class="s1">**kwargs)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.set_xlabel)</span>
<span class="s3">def </span><span class="s1">xlabel(</span>
    <span class="s1">xlabel: str</span><span class="s3">,</span>
    <span class="s1">fontdict: dict[str</span><span class="s3">, </span><span class="s1">Any] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">labelpad: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">loc: Literal[</span><span class="s4">&quot;left&quot;</span><span class="s3">, </span><span class="s4">&quot;center&quot;</span><span class="s3">, </span><span class="s4">&quot;right&quot;</span><span class="s1">] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">**kwargs</span><span class="s3">,</span>
<span class="s1">) -&gt; Text:</span>
    <span class="s3">return </span><span class="s1">gca().set_xlabel(</span>
        <span class="s1">xlabel</span><span class="s3">, </span><span class="s1">fontdict=fontdict</span><span class="s3">, </span><span class="s1">labelpad=labelpad</span><span class="s3">, </span><span class="s1">loc=loc</span><span class="s3">, </span><span class="s1">**kwargs</span>
    <span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.set_ylabel)</span>
<span class="s3">def </span><span class="s1">ylabel(</span>
    <span class="s1">ylabel: str</span><span class="s3">,</span>
    <span class="s1">fontdict: dict[str</span><span class="s3">, </span><span class="s1">Any] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">labelpad: float | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">loc: Literal[</span><span class="s4">&quot;bottom&quot;</span><span class="s3">, </span><span class="s4">&quot;center&quot;</span><span class="s3">, </span><span class="s4">&quot;top&quot;</span><span class="s1">] | </span><span class="s3">None </span><span class="s1">= </span><span class="s3">None,</span>
    <span class="s1">**kwargs</span><span class="s3">,</span>
<span class="s1">) -&gt; Text:</span>
    <span class="s3">return </span><span class="s1">gca().set_ylabel(</span>
        <span class="s1">ylabel</span><span class="s3">, </span><span class="s1">fontdict=fontdict</span><span class="s3">, </span><span class="s1">labelpad=labelpad</span><span class="s3">, </span><span class="s1">loc=loc</span><span class="s3">, </span><span class="s1">**kwargs</span>
    <span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.set_xscale)</span>
<span class="s3">def </span><span class="s1">xscale(value: str | ScaleBase</span><span class="s3">, </span><span class="s1">**kwargs) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s1">gca().set_xscale(value</span><span class="s3">, </span><span class="s1">**kwargs)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s1">@_copy_docstring_and_deprecators(Axes.set_yscale)</span>
<span class="s3">def </span><span class="s1">yscale(value: str | ScaleBase</span><span class="s3">, </span><span class="s1">**kwargs) -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s1">gca().set_yscale(value</span><span class="s3">, </span><span class="s1">**kwargs)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s3">def </span><span class="s1">autumn() -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot; 
    Set the colormap to 'autumn'. 
 
    This changes the default colormap as well as the colormap of the current 
    image if there is one. See ``help(colormaps)`` for more information. 
    &quot;&quot;&quot;</span>
    <span class="s1">set_cmap(</span><span class="s4">&quot;autumn&quot;</span><span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s3">def </span><span class="s1">bone() -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot; 
    Set the colormap to 'bone'. 
 
    This changes the default colormap as well as the colormap of the current 
    image if there is one. See ``help(colormaps)`` for more information. 
    &quot;&quot;&quot;</span>
    <span class="s1">set_cmap(</span><span class="s4">&quot;bone&quot;</span><span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s3">def </span><span class="s1">cool() -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot; 
    Set the colormap to 'cool'. 
 
    This changes the default colormap as well as the colormap of the current 
    image if there is one. See ``help(colormaps)`` for more information. 
    &quot;&quot;&quot;</span>
    <span class="s1">set_cmap(</span><span class="s4">&quot;cool&quot;</span><span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s3">def </span><span class="s1">copper() -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot; 
    Set the colormap to 'copper'. 
 
    This changes the default colormap as well as the colormap of the current 
    image if there is one. See ``help(colormaps)`` for more information. 
    &quot;&quot;&quot;</span>
    <span class="s1">set_cmap(</span><span class="s4">&quot;copper&quot;</span><span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s3">def </span><span class="s1">flag() -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot; 
    Set the colormap to 'flag'. 
 
    This changes the default colormap as well as the colormap of the current 
    image if there is one. See ``help(colormaps)`` for more information. 
    &quot;&quot;&quot;</span>
    <span class="s1">set_cmap(</span><span class="s4">&quot;flag&quot;</span><span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s3">def </span><span class="s1">gray() -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot; 
    Set the colormap to 'gray'. 
 
    This changes the default colormap as well as the colormap of the current 
    image if there is one. See ``help(colormaps)`` for more information. 
    &quot;&quot;&quot;</span>
    <span class="s1">set_cmap(</span><span class="s4">&quot;gray&quot;</span><span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s3">def </span><span class="s1">hot() -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot; 
    Set the colormap to 'hot'. 
 
    This changes the default colormap as well as the colormap of the current 
    image if there is one. See ``help(colormaps)`` for more information. 
    &quot;&quot;&quot;</span>
    <span class="s1">set_cmap(</span><span class="s4">&quot;hot&quot;</span><span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s3">def </span><span class="s1">hsv() -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot; 
    Set the colormap to 'hsv'. 
 
    This changes the default colormap as well as the colormap of the current 
    image if there is one. See ``help(colormaps)`` for more information. 
    &quot;&quot;&quot;</span>
    <span class="s1">set_cmap(</span><span class="s4">&quot;hsv&quot;</span><span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s3">def </span><span class="s1">jet() -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot; 
    Set the colormap to 'jet'. 
 
    This changes the default colormap as well as the colormap of the current 
    image if there is one. See ``help(colormaps)`` for more information. 
    &quot;&quot;&quot;</span>
    <span class="s1">set_cmap(</span><span class="s4">&quot;jet&quot;</span><span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s3">def </span><span class="s1">pink() -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot; 
    Set the colormap to 'pink'. 
 
    This changes the default colormap as well as the colormap of the current 
    image if there is one. See ``help(colormaps)`` for more information. 
    &quot;&quot;&quot;</span>
    <span class="s1">set_cmap(</span><span class="s4">&quot;pink&quot;</span><span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s3">def </span><span class="s1">prism() -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot; 
    Set the colormap to 'prism'. 
 
    This changes the default colormap as well as the colormap of the current 
    image if there is one. See ``help(colormaps)`` for more information. 
    &quot;&quot;&quot;</span>
    <span class="s1">set_cmap(</span><span class="s4">&quot;prism&quot;</span><span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s3">def </span><span class="s1">spring() -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot; 
    Set the colormap to 'spring'. 
 
    This changes the default colormap as well as the colormap of the current 
    image if there is one. See ``help(colormaps)`` for more information. 
    &quot;&quot;&quot;</span>
    <span class="s1">set_cmap(</span><span class="s4">&quot;spring&quot;</span><span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s3">def </span><span class="s1">summer() -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot; 
    Set the colormap to 'summer'. 
 
    This changes the default colormap as well as the colormap of the current 
    image if there is one. See ``help(colormaps)`` for more information. 
    &quot;&quot;&quot;</span>
    <span class="s1">set_cmap(</span><span class="s4">&quot;summer&quot;</span><span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s3">def </span><span class="s1">winter() -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot; 
    Set the colormap to 'winter'. 
 
    This changes the default colormap as well as the colormap of the current 
    image if there is one. See ``help(colormaps)`` for more information. 
    &quot;&quot;&quot;</span>
    <span class="s1">set_cmap(</span><span class="s4">&quot;winter&quot;</span><span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s3">def </span><span class="s1">magma() -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot; 
    Set the colormap to 'magma'. 
 
    This changes the default colormap as well as the colormap of the current 
    image if there is one. See ``help(colormaps)`` for more information. 
    &quot;&quot;&quot;</span>
    <span class="s1">set_cmap(</span><span class="s4">&quot;magma&quot;</span><span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s3">def </span><span class="s1">inferno() -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot; 
    Set the colormap to 'inferno'. 
 
    This changes the default colormap as well as the colormap of the current 
    image if there is one. See ``help(colormaps)`` for more information. 
    &quot;&quot;&quot;</span>
    <span class="s1">set_cmap(</span><span class="s4">&quot;inferno&quot;</span><span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s3">def </span><span class="s1">plasma() -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot; 
    Set the colormap to 'plasma'. 
 
    This changes the default colormap as well as the colormap of the current 
    image if there is one. See ``help(colormaps)`` for more information. 
    &quot;&quot;&quot;</span>
    <span class="s1">set_cmap(</span><span class="s4">&quot;plasma&quot;</span><span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s3">def </span><span class="s1">viridis() -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot; 
    Set the colormap to 'viridis'. 
 
    This changes the default colormap as well as the colormap of the current 
    image if there is one. See ``help(colormaps)`` for more information. 
    &quot;&quot;&quot;</span>
    <span class="s1">set_cmap(</span><span class="s4">&quot;viridis&quot;</span><span class="s1">)</span>


<span class="s0"># Autogenerated by boilerplate.py.  Do not edit as changes will be lost.</span>
<span class="s3">def </span><span class="s1">nipy_spectral() -&gt; </span><span class="s3">None</span><span class="s1">:</span>
    <span class="s2">&quot;&quot;&quot; 
    Set the colormap to 'nipy_spectral'. 
 
    This changes the default colormap as well as the colormap of the current 
    image if there is one. See ``help(colormaps)`` for more information. 
    &quot;&quot;&quot;</span>
    <span class="s1">set_cmap(</span><span class="s4">&quot;nipy_spectral&quot;</span><span class="s1">)</span>
</pre>
</body>
</html>