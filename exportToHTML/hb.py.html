<html>
<head>
<title>hb.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
hb.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Implementation of Harwell-Boeing read/write. 
 
At the moment not the full Harwell-Boeing format is supported. Supported 
features are: 
 
    - assembled, non-symmetric, real matrices 
    - integer for pointer/indices 
    - exponential format for float values, and int format 
 
&quot;&quot;&quot;</span>
<span class="s2"># TODO:</span>
<span class="s2">#   - Add more support (symmetric/complex matrices, non-assembled matrices ?)</span>

<span class="s2"># XXX: reading is reasonably efficient (&gt;= 85 % is in numpy.fromstring), but</span>
<span class="s2"># takes a lot of memory. Being faster would require compiled code.</span>
<span class="s2"># write is not efficient. Although not a terribly exciting task,</span>
<span class="s2"># having reusable facilities to efficiently read/write fortran-formatted files</span>
<span class="s2"># would be useful outside this module.</span>

<span class="s3">import </span><span class="s1">warnings</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">from </span><span class="s1">scipy.sparse </span><span class="s3">import </span><span class="s1">csc_matrix</span>
<span class="s3">from </span><span class="s1">._fortran_format_parser </span><span class="s3">import </span><span class="s1">FortranFormatParser</span><span class="s3">, </span><span class="s1">IntFormat</span><span class="s3">, </span><span class="s1">ExpFormat</span>

<span class="s1">__all__ = [</span><span class="s4">&quot;MalformedHeader&quot;</span><span class="s3">, </span><span class="s4">&quot;hb_read&quot;</span><span class="s3">, </span><span class="s4">&quot;hb_write&quot;</span><span class="s3">, </span><span class="s4">&quot;HBInfo&quot;</span><span class="s3">, </span><span class="s4">&quot;HBFile&quot;</span><span class="s3">,</span>
           <span class="s4">&quot;HBMatrixType&quot;</span><span class="s1">]</span>


<span class="s3">class </span><span class="s1">MalformedHeader(Exception):</span>
    <span class="s3">pass</span>


<span class="s3">class </span><span class="s1">LineOverflow(Warning):</span>
    <span class="s3">pass</span>


<span class="s3">def </span><span class="s1">_nbytes_full(fmt</span><span class="s3">, </span><span class="s1">nlines):</span>
    <span class="s0">&quot;&quot;&quot;Return the number of bytes to read to get every full lines for the 
    given parsed fortran format.&quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">(fmt.repeat * fmt.width + </span><span class="s5">1</span><span class="s1">) * (nlines - </span><span class="s5">1</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">HBInfo:</span>
    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">from_data(cls</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">title=</span><span class="s4">&quot;Default title&quot;</span><span class="s3">, </span><span class="s1">key=</span><span class="s4">&quot;0&quot;</span><span class="s3">, </span><span class="s1">mxtype=</span><span class="s3">None, </span><span class="s1">fmt=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Create a HBInfo instance from an existing sparse matrix. 
 
        Parameters 
        ---------- 
        m : sparse matrix 
            the HBInfo instance will derive its parameters from m 
        title : str 
            Title to put in the HB header 
        key : str 
            Key 
        mxtype : HBMatrixType 
            type of the input matrix 
        fmt : dict 
            not implemented 
 
        Returns 
        ------- 
        hb_info : HBInfo instance 
        &quot;&quot;&quot;</span>
        <span class="s1">m = m.tocsc(copy=</span><span class="s3">False</span><span class="s1">)</span>

        <span class="s1">pointer = m.indptr</span>
        <span class="s1">indices = m.indices</span>
        <span class="s1">values = m.data</span>

        <span class="s1">nrows</span><span class="s3">, </span><span class="s1">ncols = m.shape</span>
        <span class="s1">nnon_zeros = m.nnz</span>

        <span class="s3">if </span><span class="s1">fmt </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s2"># +1 because HB use one-based indexing (Fortran), and we will write</span>
            <span class="s2"># the indices /pointer as such</span>
            <span class="s1">pointer_fmt = IntFormat.from_number(np.max(pointer+</span><span class="s5">1</span><span class="s1">))</span>
            <span class="s1">indices_fmt = IntFormat.from_number(np.max(indices+</span><span class="s5">1</span><span class="s1">))</span>

            <span class="s3">if </span><span class="s1">values.dtype.kind </span><span class="s3">in </span><span class="s1">np.typecodes[</span><span class="s4">&quot;AllFloat&quot;</span><span class="s1">]:</span>
                <span class="s1">values_fmt = ExpFormat.from_number(-np.max(np.abs(values)))</span>
            <span class="s3">elif </span><span class="s1">values.dtype.kind </span><span class="s3">in </span><span class="s1">np.typecodes[</span><span class="s4">&quot;AllInteger&quot;</span><span class="s1">]:</span>
                <span class="s1">values_fmt = IntFormat.from_number(-np.max(np.abs(values)))</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;type %s not implemented yet&quot; </span><span class="s1">% values.dtype.kind)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;fmt argument not supported yet.&quot;</span><span class="s1">)</span>

        <span class="s3">if </span><span class="s1">mxtype </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">if not </span><span class="s1">np.isrealobj(values):</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Complex values not supported yet&quot;</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">values.dtype.kind </span><span class="s3">in </span><span class="s1">np.typecodes[</span><span class="s4">&quot;AllInteger&quot;</span><span class="s1">]:</span>
                <span class="s1">tp = </span><span class="s4">&quot;integer&quot;</span>
            <span class="s3">elif </span><span class="s1">values.dtype.kind </span><span class="s3">in </span><span class="s1">np.typecodes[</span><span class="s4">&quot;AllFloat&quot;</span><span class="s1">]:</span>
                <span class="s1">tp = </span><span class="s4">&quot;real&quot;</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;type %s for values not implemented&quot;</span>
                                          <span class="s1">% values.dtype)</span>
            <span class="s1">mxtype = HBMatrixType(tp</span><span class="s3">, </span><span class="s4">&quot;unsymmetric&quot;</span><span class="s3">, </span><span class="s4">&quot;assembled&quot;</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;mxtype argument not handled yet.&quot;</span><span class="s1">)</span>

        <span class="s3">def </span><span class="s1">_nlines(fmt</span><span class="s3">, </span><span class="s1">size):</span>
            <span class="s1">nlines = size // fmt.repeat</span>
            <span class="s3">if </span><span class="s1">nlines * fmt.repeat != size:</span>
                <span class="s1">nlines += </span><span class="s5">1</span>
            <span class="s3">return </span><span class="s1">nlines</span>

        <span class="s1">pointer_nlines = _nlines(pointer_fmt</span><span class="s3">, </span><span class="s1">pointer.size)</span>
        <span class="s1">indices_nlines = _nlines(indices_fmt</span><span class="s3">, </span><span class="s1">indices.size)</span>
        <span class="s1">values_nlines = _nlines(values_fmt</span><span class="s3">, </span><span class="s1">values.size)</span>

        <span class="s1">total_nlines = pointer_nlines + indices_nlines + values_nlines</span>

        <span class="s3">return </span><span class="s1">cls(title</span><span class="s3">, </span><span class="s1">key</span><span class="s3">,</span>
            <span class="s1">total_nlines</span><span class="s3">, </span><span class="s1">pointer_nlines</span><span class="s3">, </span><span class="s1">indices_nlines</span><span class="s3">, </span><span class="s1">values_nlines</span><span class="s3">,</span>
            <span class="s1">mxtype</span><span class="s3">, </span><span class="s1">nrows</span><span class="s3">, </span><span class="s1">ncols</span><span class="s3">, </span><span class="s1">nnon_zeros</span><span class="s3">,</span>
            <span class="s1">pointer_fmt.fortran_format</span><span class="s3">, </span><span class="s1">indices_fmt.fortran_format</span><span class="s3">,</span>
            <span class="s1">values_fmt.fortran_format)</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">from_file(cls</span><span class="s3">, </span><span class="s1">fid):</span>
        <span class="s0">&quot;&quot;&quot;Create a HBInfo instance from a file object containing a matrix in the 
        HB format. 
 
        Parameters 
        ---------- 
        fid : file-like matrix 
            File or file-like object containing a matrix in the HB format. 
 
        Returns 
        ------- 
        hb_info : HBInfo instance 
        &quot;&quot;&quot;</span>
        <span class="s2"># First line</span>
        <span class="s1">line = fid.readline().strip(</span><span class="s4">&quot;</span><span class="s3">\n</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s3">if not </span><span class="s1">len(line) &gt; </span><span class="s5">72</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Expected at least 72 characters for first line, &quot;</span>
                             <span class="s4">&quot;got: </span><span class="s3">\n</span><span class="s4">%s&quot; </span><span class="s1">% line)</span>
        <span class="s1">title = line[:</span><span class="s5">72</span><span class="s1">]</span>
        <span class="s1">key = line[</span><span class="s5">72</span><span class="s1">:]</span>

        <span class="s2"># Second line</span>
        <span class="s1">line = fid.readline().strip(</span><span class="s4">&quot;</span><span class="s3">\n</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s3">if not </span><span class="s1">len(line.rstrip()) &gt;= </span><span class="s5">56</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Expected at least 56 characters for second line, &quot;</span>
                             <span class="s4">&quot;got: </span><span class="s3">\n</span><span class="s4">%s&quot; </span><span class="s1">% line)</span>
        <span class="s1">total_nlines = _expect_int(line[:</span><span class="s5">14</span><span class="s1">])</span>
        <span class="s1">pointer_nlines = _expect_int(line[</span><span class="s5">14</span><span class="s1">:</span><span class="s5">28</span><span class="s1">])</span>
        <span class="s1">indices_nlines = _expect_int(line[</span><span class="s5">28</span><span class="s1">:</span><span class="s5">42</span><span class="s1">])</span>
        <span class="s1">values_nlines = _expect_int(line[</span><span class="s5">42</span><span class="s1">:</span><span class="s5">56</span><span class="s1">])</span>

        <span class="s1">rhs_nlines = line[</span><span class="s5">56</span><span class="s1">:</span><span class="s5">72</span><span class="s1">].strip()</span>
        <span class="s3">if </span><span class="s1">rhs_nlines == </span><span class="s4">''</span><span class="s1">:</span>
            <span class="s1">rhs_nlines = </span><span class="s5">0</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">rhs_nlines = _expect_int(rhs_nlines)</span>
        <span class="s3">if not </span><span class="s1">rhs_nlines == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Only files without right hand side supported for &quot;</span>
                             <span class="s4">&quot;now.&quot;</span><span class="s1">)</span>

        <span class="s2"># Third line</span>
        <span class="s1">line = fid.readline().strip(</span><span class="s4">&quot;</span><span class="s3">\n</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s3">if not </span><span class="s1">len(line) &gt;= </span><span class="s5">70</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Expected at least 72 character for third line, got:</span><span class="s3">\n</span><span class="s4">&quot;</span>
                             <span class="s4">&quot;%s&quot; </span><span class="s1">% line)</span>

        <span class="s1">mxtype_s = line[:</span><span class="s5">3</span><span class="s1">].upper()</span>
        <span class="s3">if not </span><span class="s1">len(mxtype_s) == </span><span class="s5">3</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;mxtype expected to be 3 characters long&quot;</span><span class="s1">)</span>

        <span class="s1">mxtype = HBMatrixType.from_fortran(mxtype_s)</span>
        <span class="s3">if </span><span class="s1">mxtype.value_type </span><span class="s3">not in </span><span class="s1">[</span><span class="s4">&quot;real&quot;</span><span class="s3">, </span><span class="s4">&quot;integer&quot;</span><span class="s1">]:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Only real or integer matrices supported for &quot;</span>
                             <span class="s4">&quot;now (detected %s)&quot; </span><span class="s1">% mxtype)</span>
        <span class="s3">if not </span><span class="s1">mxtype.structure == </span><span class="s4">&quot;unsymmetric&quot;</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Only unsymmetric matrices supported for &quot;</span>
                             <span class="s4">&quot;now (detected %s)&quot; </span><span class="s1">% mxtype)</span>
        <span class="s3">if not </span><span class="s1">mxtype.storage == </span><span class="s4">&quot;assembled&quot;</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Only assembled matrices supported for now&quot;</span><span class="s1">)</span>

        <span class="s3">if not </span><span class="s1">line[</span><span class="s5">3</span><span class="s1">:</span><span class="s5">14</span><span class="s1">] == </span><span class="s4">&quot; &quot; </span><span class="s1">* </span><span class="s5">11</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Malformed data for third line: %s&quot; </span><span class="s1">% line)</span>

        <span class="s1">nrows = _expect_int(line[</span><span class="s5">14</span><span class="s1">:</span><span class="s5">28</span><span class="s1">])</span>
        <span class="s1">ncols = _expect_int(line[</span><span class="s5">28</span><span class="s1">:</span><span class="s5">42</span><span class="s1">])</span>
        <span class="s1">nnon_zeros = _expect_int(line[</span><span class="s5">42</span><span class="s1">:</span><span class="s5">56</span><span class="s1">])</span>
        <span class="s1">nelementals = _expect_int(line[</span><span class="s5">56</span><span class="s1">:</span><span class="s5">70</span><span class="s1">])</span>
        <span class="s3">if not </span><span class="s1">nelementals == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Unexpected value %d for nltvl (last entry of line 3)&quot;</span>
                             <span class="s1">% nelementals)</span>

        <span class="s2"># Fourth line</span>
        <span class="s1">line = fid.readline().strip(</span><span class="s4">&quot;</span><span class="s3">\n</span><span class="s4">&quot;</span><span class="s1">)</span>

        <span class="s1">ct = line.split()</span>
        <span class="s3">if not </span><span class="s1">len(ct) == </span><span class="s5">3</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Expected 3 formats, got %s&quot; </span><span class="s1">% ct)</span>

        <span class="s3">return </span><span class="s1">cls(title</span><span class="s3">, </span><span class="s1">key</span><span class="s3">,</span>
                   <span class="s1">total_nlines</span><span class="s3">, </span><span class="s1">pointer_nlines</span><span class="s3">, </span><span class="s1">indices_nlines</span><span class="s3">, </span><span class="s1">values_nlines</span><span class="s3">,</span>
                   <span class="s1">mxtype</span><span class="s3">, </span><span class="s1">nrows</span><span class="s3">, </span><span class="s1">ncols</span><span class="s3">, </span><span class="s1">nnon_zeros</span><span class="s3">,</span>
                   <span class="s1">ct[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">ct[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">ct[</span><span class="s5">2</span><span class="s1">]</span><span class="s3">,</span>
                   <span class="s1">rhs_nlines</span><span class="s3">, </span><span class="s1">nelementals)</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">title</span><span class="s3">, </span><span class="s1">key</span><span class="s3">,</span>
            <span class="s1">total_nlines</span><span class="s3">, </span><span class="s1">pointer_nlines</span><span class="s3">, </span><span class="s1">indices_nlines</span><span class="s3">, </span><span class="s1">values_nlines</span><span class="s3">,</span>
            <span class="s1">mxtype</span><span class="s3">, </span><span class="s1">nrows</span><span class="s3">, </span><span class="s1">ncols</span><span class="s3">, </span><span class="s1">nnon_zeros</span><span class="s3">,</span>
            <span class="s1">pointer_format_str</span><span class="s3">, </span><span class="s1">indices_format_str</span><span class="s3">, </span><span class="s1">values_format_str</span><span class="s3">,</span>
            <span class="s1">right_hand_sides_nlines=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">nelementals=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Do not use this directly, but the class ctrs (from_* functions).&quot;&quot;&quot;</span>
        <span class="s1">self.title = title</span>
        <span class="s1">self.key = key</span>
        <span class="s3">if </span><span class="s1">title </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">title = </span><span class="s4">&quot;No Title&quot;</span>
        <span class="s3">if </span><span class="s1">len(title) &gt; </span><span class="s5">72</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;title cannot be &gt; 72 characters&quot;</span><span class="s1">)</span>

        <span class="s3">if </span><span class="s1">key </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">key = </span><span class="s4">&quot;|No Key&quot;</span>
        <span class="s3">if </span><span class="s1">len(key) &gt; </span><span class="s5">8</span><span class="s1">:</span>
            <span class="s1">warnings.warn(</span><span class="s4">&quot;key is &gt; 8 characters (key is %s)&quot; </span><span class="s1">% key</span><span class="s3">, </span><span class="s1">LineOverflow)</span>

        <span class="s1">self.total_nlines = total_nlines</span>
        <span class="s1">self.pointer_nlines = pointer_nlines</span>
        <span class="s1">self.indices_nlines = indices_nlines</span>
        <span class="s1">self.values_nlines = values_nlines</span>

        <span class="s1">parser = FortranFormatParser()</span>
        <span class="s1">pointer_format = parser.parse(pointer_format_str)</span>
        <span class="s3">if not </span><span class="s1">isinstance(pointer_format</span><span class="s3">, </span><span class="s1">IntFormat):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Expected int format for pointer format, got %s&quot;</span>
                             <span class="s1">% pointer_format)</span>

        <span class="s1">indices_format = parser.parse(indices_format_str)</span>
        <span class="s3">if not </span><span class="s1">isinstance(indices_format</span><span class="s3">, </span><span class="s1">IntFormat):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Expected int format for indices format, got %s&quot; </span><span class="s1">%</span>
                             <span class="s1">indices_format)</span>

        <span class="s1">values_format = parser.parse(values_format_str)</span>
        <span class="s3">if </span><span class="s1">isinstance(values_format</span><span class="s3">, </span><span class="s1">ExpFormat):</span>
            <span class="s3">if </span><span class="s1">mxtype.value_type </span><span class="s3">not in </span><span class="s1">[</span><span class="s4">&quot;real&quot;</span><span class="s3">, </span><span class="s4">&quot;complex&quot;</span><span class="s1">]:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Inconsistency between matrix type {} and &quot;</span>
                                 <span class="s4">&quot;value type {}&quot;</span><span class="s1">.format(mxtype</span><span class="s3">, </span><span class="s1">values_format))</span>
            <span class="s1">values_dtype = np.float64</span>
        <span class="s3">elif </span><span class="s1">isinstance(values_format</span><span class="s3">, </span><span class="s1">IntFormat):</span>
            <span class="s3">if </span><span class="s1">mxtype.value_type </span><span class="s3">not in </span><span class="s1">[</span><span class="s4">&quot;integer&quot;</span><span class="s1">]:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Inconsistency between matrix type {} and &quot;</span>
                                 <span class="s4">&quot;value type {}&quot;</span><span class="s1">.format(mxtype</span><span class="s3">, </span><span class="s1">values_format))</span>
            <span class="s2"># XXX: fortran int -&gt; dtype association ?</span>
            <span class="s1">values_dtype = int</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;Unsupported format for values </span><span class="s3">{</span><span class="s1">values_format</span><span class="s3">!r}</span><span class="s4">&quot;</span><span class="s1">)</span>

        <span class="s1">self.pointer_format = pointer_format</span>
        <span class="s1">self.indices_format = indices_format</span>
        <span class="s1">self.values_format = values_format</span>

        <span class="s1">self.pointer_dtype = np.int32</span>
        <span class="s1">self.indices_dtype = np.int32</span>
        <span class="s1">self.values_dtype = values_dtype</span>

        <span class="s1">self.pointer_nlines = pointer_nlines</span>
        <span class="s1">self.pointer_nbytes_full = _nbytes_full(pointer_format</span><span class="s3">, </span><span class="s1">pointer_nlines)</span>

        <span class="s1">self.indices_nlines = indices_nlines</span>
        <span class="s1">self.indices_nbytes_full = _nbytes_full(indices_format</span><span class="s3">, </span><span class="s1">indices_nlines)</span>

        <span class="s1">self.values_nlines = values_nlines</span>
        <span class="s1">self.values_nbytes_full = _nbytes_full(values_format</span><span class="s3">, </span><span class="s1">values_nlines)</span>

        <span class="s1">self.nrows = nrows</span>
        <span class="s1">self.ncols = ncols</span>
        <span class="s1">self.nnon_zeros = nnon_zeros</span>
        <span class="s1">self.nelementals = nelementals</span>
        <span class="s1">self.mxtype = mxtype</span>

    <span class="s3">def </span><span class="s1">dump(self):</span>
        <span class="s0">&quot;&quot;&quot;Gives the header corresponding to this instance as a string.&quot;&quot;&quot;</span>
        <span class="s1">header = [self.title.ljust(</span><span class="s5">72</span><span class="s1">) + self.key.ljust(</span><span class="s5">8</span><span class="s1">)]</span>

        <span class="s1">header.append(</span><span class="s4">&quot;%14d%14d%14d%14d&quot; </span><span class="s1">%</span>
                      <span class="s1">(self.total_nlines</span><span class="s3">, </span><span class="s1">self.pointer_nlines</span><span class="s3">,</span>
                       <span class="s1">self.indices_nlines</span><span class="s3">, </span><span class="s1">self.values_nlines))</span>
        <span class="s1">header.append(</span><span class="s4">&quot;%14s%14d%14d%14d%14d&quot; </span><span class="s1">%</span>
                      <span class="s1">(self.mxtype.fortran_format.ljust(</span><span class="s5">14</span><span class="s1">)</span><span class="s3">, </span><span class="s1">self.nrows</span><span class="s3">,</span>
                       <span class="s1">self.ncols</span><span class="s3">, </span><span class="s1">self.nnon_zeros</span><span class="s3">, </span><span class="s5">0</span><span class="s1">))</span>

        <span class="s1">pffmt = self.pointer_format.fortran_format</span>
        <span class="s1">iffmt = self.indices_format.fortran_format</span>
        <span class="s1">vffmt = self.values_format.fortran_format</span>
        <span class="s1">header.append(</span><span class="s4">&quot;%16s%16s%20s&quot; </span><span class="s1">%</span>
                      <span class="s1">(pffmt.ljust(</span><span class="s5">16</span><span class="s1">)</span><span class="s3">, </span><span class="s1">iffmt.ljust(</span><span class="s5">16</span><span class="s1">)</span><span class="s3">, </span><span class="s1">vffmt.ljust(</span><span class="s5">20</span><span class="s1">)))</span>
        <span class="s3">return </span><span class="s4">&quot;</span><span class="s3">\n</span><span class="s4">&quot;</span><span class="s1">.join(header)</span>


<span class="s3">def </span><span class="s1">_expect_int(value</span><span class="s3">, </span><span class="s1">msg=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">int(value)</span>
    <span class="s3">except </span><span class="s1">ValueError </span><span class="s3">as </span><span class="s1">e:</span>
        <span class="s3">if </span><span class="s1">msg </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s4">&quot;Expected an int, got %s&quot;</span>
        <span class="s3">raise </span><span class="s1">ValueError(msg % value) </span><span class="s3">from </span><span class="s1">e</span>


<span class="s3">def </span><span class="s1">_read_hb_data(content</span><span class="s3">, </span><span class="s1">header):</span>
    <span class="s2"># XXX: look at a way to reduce memory here (big string creation)</span>
    <span class="s1">ptr_string = </span><span class="s4">&quot;&quot;</span><span class="s1">.join([content.read(header.pointer_nbytes_full)</span><span class="s3">,</span>
                           <span class="s1">content.readline()])</span>
    <span class="s1">ptr = np.fromstring(ptr_string</span><span class="s3">,</span>
            <span class="s1">dtype=int</span><span class="s3">, </span><span class="s1">sep=</span><span class="s4">' '</span><span class="s1">)</span>

    <span class="s1">ind_string = </span><span class="s4">&quot;&quot;</span><span class="s1">.join([content.read(header.indices_nbytes_full)</span><span class="s3">,</span>
                       <span class="s1">content.readline()])</span>
    <span class="s1">ind = np.fromstring(ind_string</span><span class="s3">,</span>
            <span class="s1">dtype=int</span><span class="s3">, </span><span class="s1">sep=</span><span class="s4">' '</span><span class="s1">)</span>

    <span class="s1">val_string = </span><span class="s4">&quot;&quot;</span><span class="s1">.join([content.read(header.values_nbytes_full)</span><span class="s3">,</span>
                          <span class="s1">content.readline()])</span>
    <span class="s1">val = np.fromstring(val_string</span><span class="s3">,</span>
            <span class="s1">dtype=header.values_dtype</span><span class="s3">, </span><span class="s1">sep=</span><span class="s4">' '</span><span class="s1">)</span>

    <span class="s3">try</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">csc_matrix((val</span><span class="s3">, </span><span class="s1">ind-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">ptr-</span><span class="s5">1</span><span class="s1">)</span><span class="s3">,</span>
                          <span class="s1">shape=(header.nrows</span><span class="s3">, </span><span class="s1">header.ncols))</span>
    <span class="s3">except </span><span class="s1">ValueError </span><span class="s3">as </span><span class="s1">e:</span>
        <span class="s3">raise </span><span class="s1">e</span>


<span class="s3">def </span><span class="s1">_write_data(m</span><span class="s3">, </span><span class="s1">fid</span><span class="s3">, </span><span class="s1">header):</span>
    <span class="s1">m = m.tocsc(copy=</span><span class="s3">False</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">write_array(f</span><span class="s3">, </span><span class="s1">ar</span><span class="s3">, </span><span class="s1">nlines</span><span class="s3">, </span><span class="s1">fmt):</span>
        <span class="s2"># ar_nlines is the number of full lines, n is the number of items per</span>
        <span class="s2"># line, ffmt the fortran format</span>
        <span class="s1">pyfmt = fmt.python_format</span>
        <span class="s1">pyfmt_full = pyfmt * fmt.repeat</span>

        <span class="s2"># for each array to write, we first write the full lines, and special</span>
        <span class="s2"># case for partial line</span>
        <span class="s1">full = ar[:(nlines - </span><span class="s5">1</span><span class="s1">) * fmt.repeat]</span>
        <span class="s3">for </span><span class="s1">row </span><span class="s3">in </span><span class="s1">full.reshape((nlines-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">fmt.repeat)):</span>
            <span class="s1">f.write(pyfmt_full % tuple(row) + </span><span class="s4">&quot;</span><span class="s3">\n</span><span class="s4">&quot;</span><span class="s1">)</span>
        <span class="s1">nremain = ar.size - full.size</span>
        <span class="s3">if </span><span class="s1">nremain &gt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">f.write((pyfmt * nremain) % tuple(ar[ar.size - nremain:]) + </span><span class="s4">&quot;</span><span class="s3">\n</span><span class="s4">&quot;</span><span class="s1">)</span>

    <span class="s1">fid.write(header.dump())</span>
    <span class="s1">fid.write(</span><span class="s4">&quot;</span><span class="s3">\n</span><span class="s4">&quot;</span><span class="s1">)</span>
    <span class="s2"># +1 is for Fortran one-based indexing</span>
    <span class="s1">write_array(fid</span><span class="s3">, </span><span class="s1">m.indptr+</span><span class="s5">1</span><span class="s3">, </span><span class="s1">header.pointer_nlines</span><span class="s3">,</span>
                <span class="s1">header.pointer_format)</span>
    <span class="s1">write_array(fid</span><span class="s3">, </span><span class="s1">m.indices+</span><span class="s5">1</span><span class="s3">, </span><span class="s1">header.indices_nlines</span><span class="s3">,</span>
                <span class="s1">header.indices_format)</span>
    <span class="s1">write_array(fid</span><span class="s3">, </span><span class="s1">m.data</span><span class="s3">, </span><span class="s1">header.values_nlines</span><span class="s3">,</span>
                <span class="s1">header.values_format)</span>


<span class="s3">class </span><span class="s1">HBMatrixType:</span>
    <span class="s0">&quot;&quot;&quot;Class to hold the matrix type.&quot;&quot;&quot;</span>
    <span class="s2"># q2f* translates qualified names to Fortran character</span>
    <span class="s1">_q2f_type = {</span>
        <span class="s4">&quot;real&quot;</span><span class="s1">: </span><span class="s4">&quot;R&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;complex&quot;</span><span class="s1">: </span><span class="s4">&quot;C&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;pattern&quot;</span><span class="s1">: </span><span class="s4">&quot;P&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;integer&quot;</span><span class="s1">: </span><span class="s4">&quot;I&quot;</span><span class="s3">,</span>
    <span class="s1">}</span>
    <span class="s1">_q2f_structure = {</span>
            <span class="s4">&quot;symmetric&quot;</span><span class="s1">: </span><span class="s4">&quot;S&quot;</span><span class="s3">,</span>
            <span class="s4">&quot;unsymmetric&quot;</span><span class="s1">: </span><span class="s4">&quot;U&quot;</span><span class="s3">,</span>
            <span class="s4">&quot;hermitian&quot;</span><span class="s1">: </span><span class="s4">&quot;H&quot;</span><span class="s3">,</span>
            <span class="s4">&quot;skewsymmetric&quot;</span><span class="s1">: </span><span class="s4">&quot;Z&quot;</span><span class="s3">,</span>
            <span class="s4">&quot;rectangular&quot;</span><span class="s1">: </span><span class="s4">&quot;R&quot;</span>
    <span class="s1">}</span>
    <span class="s1">_q2f_storage = {</span>
        <span class="s4">&quot;assembled&quot;</span><span class="s1">: </span><span class="s4">&quot;A&quot;</span><span class="s3">,</span>
        <span class="s4">&quot;elemental&quot;</span><span class="s1">: </span><span class="s4">&quot;E&quot;</span><span class="s3">,</span>
    <span class="s1">}</span>

    <span class="s1">_f2q_type = {j: i </span><span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">j </span><span class="s3">in </span><span class="s1">_q2f_type.items()}</span>
    <span class="s1">_f2q_structure = {j: i </span><span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">j </span><span class="s3">in </span><span class="s1">_q2f_structure.items()}</span>
    <span class="s1">_f2q_storage = {j: i </span><span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">j </span><span class="s3">in </span><span class="s1">_q2f_storage.items()}</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">from_fortran(cls</span><span class="s3">, </span><span class="s1">fmt):</span>
        <span class="s3">if not </span><span class="s1">len(fmt) == </span><span class="s5">3</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Fortran format for matrix type should be 3 &quot;</span>
                             <span class="s4">&quot;characters long&quot;</span><span class="s1">)</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">value_type = cls._f2q_type[fmt[</span><span class="s5">0</span><span class="s1">]]</span>
            <span class="s1">structure = cls._f2q_structure[fmt[</span><span class="s5">1</span><span class="s1">]]</span>
            <span class="s1">storage = cls._f2q_storage[fmt[</span><span class="s5">2</span><span class="s1">]]</span>
            <span class="s3">return </span><span class="s1">cls(value_type</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">, </span><span class="s1">storage)</span>
        <span class="s3">except </span><span class="s1">KeyError </span><span class="s3">as </span><span class="s1">e:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Unrecognized format %s&quot; </span><span class="s1">% fmt) </span><span class="s3">from </span><span class="s1">e</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">value_type</span><span class="s3">, </span><span class="s1">structure</span><span class="s3">, </span><span class="s1">storage=</span><span class="s4">&quot;assembled&quot;</span><span class="s1">):</span>
        <span class="s1">self.value_type = value_type</span>
        <span class="s1">self.structure = structure</span>
        <span class="s1">self.storage = storage</span>

        <span class="s3">if </span><span class="s1">value_type </span><span class="s3">not in </span><span class="s1">self._q2f_type:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Unrecognized type %s&quot; </span><span class="s1">% value_type)</span>
        <span class="s3">if </span><span class="s1">structure </span><span class="s3">not in </span><span class="s1">self._q2f_structure:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Unrecognized structure %s&quot; </span><span class="s1">% structure)</span>
        <span class="s3">if </span><span class="s1">storage </span><span class="s3">not in </span><span class="s1">self._q2f_storage:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Unrecognized storage %s&quot; </span><span class="s1">% storage)</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">fortran_format(self):</span>
        <span class="s3">return </span><span class="s1">self._q2f_type[self.value_type] + \</span>
               <span class="s1">self._q2f_structure[self.structure] + \</span>
               <span class="s1">self._q2f_storage[self.storage]</span>

    <span class="s3">def </span><span class="s1">__repr__(self):</span>
        <span class="s3">return </span><span class="s4">&quot;HBMatrixType(%s, %s, %s)&quot; </span><span class="s1">% \</span>
               <span class="s1">(self.value_type</span><span class="s3">, </span><span class="s1">self.structure</span><span class="s3">, </span><span class="s1">self.storage)</span>


<span class="s3">class </span><span class="s1">HBFile:</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">file</span><span class="s3">, </span><span class="s1">hb_info=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Create a HBFile instance. 
 
        Parameters 
        ---------- 
        file : file-object 
            StringIO work as well 
        hb_info : HBInfo, optional 
            Should be given as an argument for writing, in which case the file 
            should be writable. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._fid = file</span>
        <span class="s3">if </span><span class="s1">hb_info </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">self._hb_info = HBInfo.from_file(file)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s2">#raise OSError(&quot;file %s is not writable, and hb_info &quot;</span>
            <span class="s2">#              &quot;was given.&quot; % file)</span>
            <span class="s1">self._hb_info = hb_info</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">title(self):</span>
        <span class="s3">return </span><span class="s1">self._hb_info.title</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">key(self):</span>
        <span class="s3">return </span><span class="s1">self._hb_info.key</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">type(self):</span>
        <span class="s3">return </span><span class="s1">self._hb_info.mxtype.value_type</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">structure(self):</span>
        <span class="s3">return </span><span class="s1">self._hb_info.mxtype.structure</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">storage(self):</span>
        <span class="s3">return </span><span class="s1">self._hb_info.mxtype.storage</span>

    <span class="s3">def </span><span class="s1">read_matrix(self):</span>
        <span class="s3">return </span><span class="s1">_read_hb_data(self._fid</span><span class="s3">, </span><span class="s1">self._hb_info)</span>

    <span class="s3">def </span><span class="s1">write_matrix(self</span><span class="s3">, </span><span class="s1">m):</span>
        <span class="s3">return </span><span class="s1">_write_data(m</span><span class="s3">, </span><span class="s1">self._fid</span><span class="s3">, </span><span class="s1">self._hb_info)</span>


<span class="s3">def </span><span class="s1">hb_read(path_or_open_file):</span>
    <span class="s0">&quot;&quot;&quot;Read HB-format file. 
 
    Parameters 
    ---------- 
    path_or_open_file : path-like or file-like 
        If a file-like object, it is used as-is. Otherwise, it is opened 
        before reading. 
 
    Returns 
    ------- 
    data : scipy.sparse.csc_matrix instance 
        The data read from the HB file as a sparse matrix. 
 
    Notes 
    ----- 
    At the moment not the full Harwell-Boeing format is supported. Supported 
    features are: 
 
        - assembled, non-symmetric, real matrices 
        - integer for pointer/indices 
        - exponential format for float values, and int format 
 
    Examples 
    -------- 
    We can read and write a harwell-boeing format file: 
 
    &gt;&gt;&gt; from scipy.io import hb_read, hb_write 
    &gt;&gt;&gt; from scipy.sparse import csr_matrix, eye 
    &gt;&gt;&gt; data = csr_matrix(eye(3))  # create a sparse matrix 
    &gt;&gt;&gt; hb_write(&quot;data.hb&quot;, data)  # write a hb file 
    &gt;&gt;&gt; print(hb_read(&quot;data.hb&quot;))  # read a hb file 
      (0, 0)    1.0 
      (1, 1)    1.0 
      (2, 2)    1.0 
 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">_get_matrix(fid):</span>
        <span class="s1">hb = HBFile(fid)</span>
        <span class="s3">return </span><span class="s1">hb.read_matrix()</span>

    <span class="s3">if </span><span class="s1">hasattr(path_or_open_file</span><span class="s3">, </span><span class="s4">'read'</span><span class="s1">):</span>
        <span class="s3">return </span><span class="s1">_get_matrix(path_or_open_file)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">with </span><span class="s1">open(path_or_open_file) </span><span class="s3">as </span><span class="s1">f:</span>
            <span class="s3">return </span><span class="s1">_get_matrix(f)</span>


<span class="s3">def </span><span class="s1">hb_write(path_or_open_file</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s1">hb_info=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Write HB-format file. 
 
    Parameters 
    ---------- 
    path_or_open_file : path-like or file-like 
        If a file-like object, it is used as-is. Otherwise, it is opened 
        before writing. 
    m : sparse-matrix 
        the sparse matrix to write 
    hb_info : HBInfo 
        contains the meta-data for write 
 
    Returns 
    ------- 
    None 
 
    Notes 
    ----- 
    At the moment not the full Harwell-Boeing format is supported. Supported 
    features are: 
 
        - assembled, non-symmetric, real matrices 
        - integer for pointer/indices 
        - exponential format for float values, and int format 
 
    Examples 
    -------- 
    We can read and write a harwell-boeing format file: 
 
    &gt;&gt;&gt; from scipy.io import hb_read, hb_write 
    &gt;&gt;&gt; from scipy.sparse import csr_matrix, eye 
    &gt;&gt;&gt; data = csr_matrix(eye(3))  # create a sparse matrix 
    &gt;&gt;&gt; hb_write(&quot;data.hb&quot;, data)  # write a hb file 
    &gt;&gt;&gt; print(hb_read(&quot;data.hb&quot;))  # read a hb file 
      (0, 0)    1.0 
      (1, 1)    1.0 
      (2, 2)    1.0 
 
    &quot;&quot;&quot;</span>
    <span class="s1">m = m.tocsc(copy=</span><span class="s3">False</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">hb_info </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">hb_info = HBInfo.from_data(m)</span>

    <span class="s3">def </span><span class="s1">_set_matrix(fid):</span>
        <span class="s1">hb = HBFile(fid</span><span class="s3">, </span><span class="s1">hb_info)</span>
        <span class="s3">return </span><span class="s1">hb.write_matrix(m)</span>

    <span class="s3">if </span><span class="s1">hasattr(path_or_open_file</span><span class="s3">, </span><span class="s4">'write'</span><span class="s1">):</span>
        <span class="s3">return </span><span class="s1">_set_matrix(path_or_open_file)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">with </span><span class="s1">open(path_or_open_file</span><span class="s3">, </span><span class="s4">'w'</span><span class="s1">) </span><span class="s3">as </span><span class="s1">f:</span>
            <span class="s3">return </span><span class="s1">_set_matrix(f)</span>
</pre>
</body>
</html>