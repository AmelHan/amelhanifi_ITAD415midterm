<html>
<head>
<title>_least_angle.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_least_angle.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Least Angle Regression algorithm. See the documentation on the 
Generalized Linear Model for a complete discussion. 
&quot;&quot;&quot;</span>
<span class="s2"># Author: Fabian Pedregosa &lt;fabian.pedregosa@inria.fr&gt;</span>
<span class="s2">#         Alexandre Gramfort &lt;alexandre.gramfort@inria.fr&gt;</span>
<span class="s2">#         Gael Varoquaux</span>
<span class="s2">#</span>
<span class="s2"># License: BSD 3 clause</span>

<span class="s3">import </span><span class="s1">sys</span>
<span class="s3">import </span><span class="s1">warnings</span>
<span class="s3">from </span><span class="s1">math </span><span class="s3">import </span><span class="s1">log</span>
<span class="s3">from </span><span class="s1">numbers </span><span class="s3">import </span><span class="s1">Integral</span><span class="s3">, </span><span class="s1">Real</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">from </span><span class="s1">scipy </span><span class="s3">import </span><span class="s1">interpolate</span><span class="s3">, </span><span class="s1">linalg</span>
<span class="s3">from </span><span class="s1">scipy.linalg.lapack </span><span class="s3">import </span><span class="s1">get_lapack_funcs</span>

<span class="s3">from </span><span class="s1">..base </span><span class="s3">import </span><span class="s1">MultiOutputMixin</span><span class="s3">, </span><span class="s1">RegressorMixin</span><span class="s3">, </span><span class="s1">_fit_context</span>
<span class="s3">from </span><span class="s1">..exceptions </span><span class="s3">import </span><span class="s1">ConvergenceWarning</span>
<span class="s3">from </span><span class="s1">..model_selection </span><span class="s3">import </span><span class="s1">check_cv</span>

<span class="s2"># mypy error: Module 'sklearn.utils' has no attribute 'arrayfuncs'</span>
<span class="s3">from </span><span class="s1">..utils </span><span class="s3">import </span><span class="s1">arrayfuncs</span><span class="s3">, </span><span class="s1">as_float_array</span><span class="s3">, </span><span class="s1">check_random_state  </span><span class="s2"># type: ignore</span>
<span class="s3">from </span><span class="s1">..utils._param_validation </span><span class="s3">import </span><span class="s1">Hidden</span><span class="s3">, </span><span class="s1">Interval</span><span class="s3">, </span><span class="s1">StrOptions</span>
<span class="s3">from </span><span class="s1">..utils.parallel </span><span class="s3">import </span><span class="s1">Parallel</span><span class="s3">, </span><span class="s1">delayed</span>
<span class="s3">from </span><span class="s1">._base </span><span class="s3">import </span><span class="s1">LinearModel</span><span class="s3">, </span><span class="s1">LinearRegression</span><span class="s3">, </span><span class="s1">_deprecate_normalize</span><span class="s3">, </span><span class="s1">_preprocess_data</span>

<span class="s1">SOLVE_TRIANGULAR_ARGS = {</span><span class="s4">&quot;check_finite&quot;</span><span class="s1">: </span><span class="s3">False</span><span class="s1">}</span>


<span class="s3">def </span><span class="s1">lars_path(</span>
    <span class="s1">X</span><span class="s3">,</span>
    <span class="s1">y</span><span class="s3">,</span>
    <span class="s1">Xy=</span><span class="s3">None,</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">Gram=</span><span class="s3">None,</span>
    <span class="s1">max_iter=</span><span class="s5">500</span><span class="s3">,</span>
    <span class="s1">alpha_min=</span><span class="s5">0</span><span class="s3">,</span>
    <span class="s1">method=</span><span class="s4">&quot;lar&quot;</span><span class="s3">,</span>
    <span class="s1">copy_X=</span><span class="s3">True,</span>
    <span class="s1">eps=np.finfo(float).eps</span><span class="s3">,</span>
    <span class="s1">copy_Gram=</span><span class="s3">True,</span>
    <span class="s1">verbose=</span><span class="s5">0</span><span class="s3">,</span>
    <span class="s1">return_path=</span><span class="s3">True,</span>
    <span class="s1">return_n_iter=</span><span class="s3">False,</span>
    <span class="s1">positive=</span><span class="s3">False,</span>
<span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Compute Least Angle Regression or Lasso path using the LARS algorithm [1]. 
 
    The optimization objective for the case method='lasso' is:: 
 
    (1 / (2 * n_samples)) * ||y - Xw||^2_2 + alpha * ||w||_1 
 
    in the case of method='lar', the objective function is only known in 
    the form of an implicit equation (see discussion in [1]). 
 
    Read more in the :ref:`User Guide &lt;least_angle_regression&gt;`. 
 
    Parameters 
    ---------- 
    X : None or array-like of shape (n_samples, n_features) 
        Input data. Note that if X is `None` then the Gram matrix must be 
        specified, i.e., cannot be `None` or `False`. 
 
    y : None or array-like of shape (n_samples,) 
        Input targets. 
 
    Xy : array-like of shape (n_features,) or (n_features, n_targets), \ 
            default=None 
        `Xy = np.dot(X.T, y)` that can be precomputed. It is useful 
        only when the Gram matrix is precomputed. 
 
    Gram : None, 'auto', array-like of shape (n_features, n_features), \ 
            default=None 
        Precomputed Gram matrix (X' * X), if `'auto'`, the Gram 
        matrix is precomputed from the given X, if there are more samples 
        than features. 
 
    max_iter : int, default=500 
        Maximum number of iterations to perform, set to infinity for no limit. 
 
    alpha_min : float, default=0 
        Minimum correlation along the path. It corresponds to the 
        regularization parameter `alpha` in the Lasso. 
 
    method : {'lar', 'lasso'}, default='lar' 
        Specifies the returned model. Select `'lar'` for Least Angle 
        Regression, `'lasso'` for the Lasso. 
 
    copy_X : bool, default=True 
        If `False`, `X` is overwritten. 
 
    eps : float, default=np.finfo(float).eps 
        The machine-precision regularization in the computation of the 
        Cholesky diagonal factors. Increase this for very ill-conditioned 
        systems. Unlike the `tol` parameter in some iterative 
        optimization-based algorithms, this parameter does not control 
        the tolerance of the optimization. 
 
    copy_Gram : bool, default=True 
        If `False`, `Gram` is overwritten. 
 
    verbose : int, default=0 
        Controls output verbosity. 
 
    return_path : bool, default=True 
        If `True`, returns the entire path, else returns only the 
        last point of the path. 
 
    return_n_iter : bool, default=False 
        Whether to return the number of iterations. 
 
    positive : bool, default=False 
        Restrict coefficients to be &gt;= 0. 
        This option is only allowed with method 'lasso'. Note that the model 
        coefficients will not converge to the ordinary-least-squares solution 
        for small values of alpha. Only coefficients up to the smallest alpha 
        value (`alphas_[alphas_ &gt; 0.].min()` when fit_path=True) reached by 
        the stepwise Lars-Lasso algorithm are typically in congruence with the 
        solution of the coordinate descent `lasso_path` function. 
 
    Returns 
    ------- 
    alphas : array-like of shape (n_alphas + 1,) 
        Maximum of covariances (in absolute value) at each iteration. 
        `n_alphas` is either `max_iter`, `n_features`, or the 
        number of nodes in the path with `alpha &gt;= alpha_min`, whichever 
        is smaller. 
 
    active : array-like of shape (n_alphas,) 
        Indices of active variables at the end of the path. 
 
    coefs : array-like of shape (n_features, n_alphas + 1) 
        Coefficients along the path. 
 
    n_iter : int 
        Number of iterations run. Returned only if return_n_iter is set 
        to True. 
 
    See Also 
    -------- 
    lars_path_gram : Compute LARS path in the sufficient stats mode. 
    lasso_path : Compute Lasso path with coordinate descent. 
    LassoLars : Lasso model fit with Least Angle Regression a.k.a. Lars. 
    Lars : Least Angle Regression model a.k.a. LAR. 
    LassoLarsCV : Cross-validated Lasso, using the LARS algorithm. 
    LarsCV : Cross-validated Least Angle Regression model. 
    sklearn.decomposition.sparse_encode : Sparse coding. 
 
    References 
    ---------- 
    .. [1] &quot;Least Angle Regression&quot;, Efron et al. 
           http://statweb.stanford.edu/~tibs/ftp/lars.pdf 
 
    .. [2] `Wikipedia entry on the Least-angle regression 
           &lt;https://en.wikipedia.org/wiki/Least-angle_regression&gt;`_ 
 
    .. [3] `Wikipedia entry on the Lasso 
           &lt;https://en.wikipedia.org/wiki/Lasso_(statistics)&gt;`_ 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">X </span><span class="s3">is None and </span><span class="s1">Gram </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span>
            <span class="s4">&quot;X cannot be None if Gram is not None&quot;</span>
            <span class="s4">&quot;Use lars_path_gram to avoid passing X and y.&quot;</span>
        <span class="s1">)</span>
    <span class="s3">return </span><span class="s1">_lars_path_solver(</span>
        <span class="s1">X=X</span><span class="s3">,</span>
        <span class="s1">y=y</span><span class="s3">,</span>
        <span class="s1">Xy=Xy</span><span class="s3">,</span>
        <span class="s1">Gram=Gram</span><span class="s3">,</span>
        <span class="s1">n_samples=</span><span class="s3">None,</span>
        <span class="s1">max_iter=max_iter</span><span class="s3">,</span>
        <span class="s1">alpha_min=alpha_min</span><span class="s3">,</span>
        <span class="s1">method=method</span><span class="s3">,</span>
        <span class="s1">copy_X=copy_X</span><span class="s3">,</span>
        <span class="s1">eps=eps</span><span class="s3">,</span>
        <span class="s1">copy_Gram=copy_Gram</span><span class="s3">,</span>
        <span class="s1">verbose=verbose</span><span class="s3">,</span>
        <span class="s1">return_path=return_path</span><span class="s3">,</span>
        <span class="s1">return_n_iter=return_n_iter</span><span class="s3">,</span>
        <span class="s1">positive=positive</span><span class="s3">,</span>
    <span class="s1">)</span>


<span class="s3">def </span><span class="s1">lars_path_gram(</span>
    <span class="s1">Xy</span><span class="s3">,</span>
    <span class="s1">Gram</span><span class="s3">,</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">n_samples</span><span class="s3">,</span>
    <span class="s1">max_iter=</span><span class="s5">500</span><span class="s3">,</span>
    <span class="s1">alpha_min=</span><span class="s5">0</span><span class="s3">,</span>
    <span class="s1">method=</span><span class="s4">&quot;lar&quot;</span><span class="s3">,</span>
    <span class="s1">copy_X=</span><span class="s3">True,</span>
    <span class="s1">eps=np.finfo(float).eps</span><span class="s3">,</span>
    <span class="s1">copy_Gram=</span><span class="s3">True,</span>
    <span class="s1">verbose=</span><span class="s5">0</span><span class="s3">,</span>
    <span class="s1">return_path=</span><span class="s3">True,</span>
    <span class="s1">return_n_iter=</span><span class="s3">False,</span>
    <span class="s1">positive=</span><span class="s3">False,</span>
<span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;The lars_path in the sufficient stats mode [1]. 
 
    The optimization objective for the case method='lasso' is:: 
 
    (1 / (2 * n_samples)) * ||y - Xw||^2_2 + alpha * ||w||_1 
 
    in the case of method='lars', the objective function is only known in 
    the form of an implicit equation (see discussion in [1]) 
 
    Read more in the :ref:`User Guide &lt;least_angle_regression&gt;`. 
 
    Parameters 
    ---------- 
    Xy : array-like of shape (n_features,) or (n_features, n_targets) 
        Xy = np.dot(X.T, y). 
 
    Gram : array-like of shape (n_features, n_features) 
        Gram = np.dot(X.T * X). 
 
    n_samples : int or float 
        Equivalent size of sample. 
 
    max_iter : int, default=500 
        Maximum number of iterations to perform, set to infinity for no limit. 
 
    alpha_min : float, default=0 
        Minimum correlation along the path. It corresponds to the 
        regularization parameter alpha parameter in the Lasso. 
 
    method : {'lar', 'lasso'}, default='lar' 
        Specifies the returned model. Select ``'lar'`` for Least Angle 
        Regression, ``'lasso'`` for the Lasso. 
 
    copy_X : bool, default=True 
        If ``False``, ``X`` is overwritten. 
 
    eps : float, default=np.finfo(float).eps 
        The machine-precision regularization in the computation of the 
        Cholesky diagonal factors. Increase this for very ill-conditioned 
        systems. Unlike the ``tol`` parameter in some iterative 
        optimization-based algorithms, this parameter does not control 
        the tolerance of the optimization. 
 
    copy_Gram : bool, default=True 
        If ``False``, ``Gram`` is overwritten. 
 
    verbose : int, default=0 
        Controls output verbosity. 
 
    return_path : bool, default=True 
        If ``return_path==True`` returns the entire path, else returns only the 
        last point of the path. 
 
    return_n_iter : bool, default=False 
        Whether to return the number of iterations. 
 
    positive : bool, default=False 
        Restrict coefficients to be &gt;= 0. 
        This option is only allowed with method 'lasso'. Note that the model 
        coefficients will not converge to the ordinary-least-squares solution 
        for small values of alpha. Only coefficients up to the smallest alpha 
        value (``alphas_[alphas_ &gt; 0.].min()`` when fit_path=True) reached by 
        the stepwise Lars-Lasso algorithm are typically in congruence with the 
        solution of the coordinate descent lasso_path function. 
 
    Returns 
    ------- 
    alphas : array-like of shape (n_alphas + 1,) 
        Maximum of covariances (in absolute value) at each iteration. 
        ``n_alphas`` is either ``max_iter``, ``n_features`` or the 
        number of nodes in the path with ``alpha &gt;= alpha_min``, whichever 
        is smaller. 
 
    active : array-like of shape (n_alphas,) 
        Indices of active variables at the end of the path. 
 
    coefs : array-like of shape (n_features, n_alphas + 1) 
        Coefficients along the path. 
 
    n_iter : int 
        Number of iterations run. Returned only if return_n_iter is set 
        to True. 
 
    See Also 
    -------- 
    lars_path_gram : Compute LARS path. 
    lasso_path : Compute Lasso path with coordinate descent. 
    LassoLars : Lasso model fit with Least Angle Regression a.k.a. Lars. 
    Lars : Least Angle Regression model a.k.a. LAR. 
    LassoLarsCV : Cross-validated Lasso, using the LARS algorithm. 
    LarsCV : Cross-validated Least Angle Regression model. 
    sklearn.decomposition.sparse_encode : Sparse coding. 
 
    References 
    ---------- 
    .. [1] &quot;Least Angle Regression&quot;, Efron et al. 
           http://statweb.stanford.edu/~tibs/ftp/lars.pdf 
 
    .. [2] `Wikipedia entry on the Least-angle regression 
           &lt;https://en.wikipedia.org/wiki/Least-angle_regression&gt;`_ 
 
    .. [3] `Wikipedia entry on the Lasso 
           &lt;https://en.wikipedia.org/wiki/Lasso_(statistics)&gt;`_ 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">_lars_path_solver(</span>
        <span class="s1">X=</span><span class="s3">None,</span>
        <span class="s1">y=</span><span class="s3">None,</span>
        <span class="s1">Xy=Xy</span><span class="s3">,</span>
        <span class="s1">Gram=Gram</span><span class="s3">,</span>
        <span class="s1">n_samples=n_samples</span><span class="s3">,</span>
        <span class="s1">max_iter=max_iter</span><span class="s3">,</span>
        <span class="s1">alpha_min=alpha_min</span><span class="s3">,</span>
        <span class="s1">method=method</span><span class="s3">,</span>
        <span class="s1">copy_X=copy_X</span><span class="s3">,</span>
        <span class="s1">eps=eps</span><span class="s3">,</span>
        <span class="s1">copy_Gram=copy_Gram</span><span class="s3">,</span>
        <span class="s1">verbose=verbose</span><span class="s3">,</span>
        <span class="s1">return_path=return_path</span><span class="s3">,</span>
        <span class="s1">return_n_iter=return_n_iter</span><span class="s3">,</span>
        <span class="s1">positive=positive</span><span class="s3">,</span>
    <span class="s1">)</span>


<span class="s3">def </span><span class="s1">_lars_path_solver(</span>
    <span class="s1">X</span><span class="s3">,</span>
    <span class="s1">y</span><span class="s3">,</span>
    <span class="s1">Xy=</span><span class="s3">None,</span>
    <span class="s1">Gram=</span><span class="s3">None,</span>
    <span class="s1">n_samples=</span><span class="s3">None,</span>
    <span class="s1">max_iter=</span><span class="s5">500</span><span class="s3">,</span>
    <span class="s1">alpha_min=</span><span class="s5">0</span><span class="s3">,</span>
    <span class="s1">method=</span><span class="s4">&quot;lar&quot;</span><span class="s3">,</span>
    <span class="s1">copy_X=</span><span class="s3">True,</span>
    <span class="s1">eps=np.finfo(float).eps</span><span class="s3">,</span>
    <span class="s1">copy_Gram=</span><span class="s3">True,</span>
    <span class="s1">verbose=</span><span class="s5">0</span><span class="s3">,</span>
    <span class="s1">return_path=</span><span class="s3">True,</span>
    <span class="s1">return_n_iter=</span><span class="s3">False,</span>
    <span class="s1">positive=</span><span class="s3">False,</span>
<span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Compute Least Angle Regression or Lasso path using LARS algorithm [1] 
 
    The optimization objective for the case method='lasso' is:: 
 
    (1 / (2 * n_samples)) * ||y - Xw||^2_2 + alpha * ||w||_1 
 
    in the case of method='lars', the objective function is only known in 
    the form of an implicit equation (see discussion in [1]) 
 
    Read more in the :ref:`User Guide &lt;least_angle_regression&gt;`. 
 
    Parameters 
    ---------- 
    X : None or ndarray of shape (n_samples, n_features) 
        Input data. Note that if X is None then Gram must be specified, 
        i.e., cannot be None or False. 
 
    y : None or ndarray of shape (n_samples,) 
        Input targets. 
 
    Xy : array-like of shape (n_features,) or (n_features, n_targets), \ 
            default=None 
        `Xy = np.dot(X.T, y)` that can be precomputed. It is useful 
        only when the Gram matrix is precomputed. 
 
    Gram : None, 'auto' or array-like of shape (n_features, n_features), \ 
            default=None 
        Precomputed Gram matrix `(X' * X)`, if ``'auto'``, the Gram 
        matrix is precomputed from the given X, if there are more samples 
        than features. 
 
    n_samples : int or float, default=None 
        Equivalent size of sample. If `None`, it will be `n_samples`. 
 
    max_iter : int, default=500 
        Maximum number of iterations to perform, set to infinity for no limit. 
 
    alpha_min : float, default=0 
        Minimum correlation along the path. It corresponds to the 
        regularization parameter alpha parameter in the Lasso. 
 
    method : {'lar', 'lasso'}, default='lar' 
        Specifies the returned model. Select ``'lar'`` for Least Angle 
        Regression, ``'lasso'`` for the Lasso. 
 
    copy_X : bool, default=True 
        If ``False``, ``X`` is overwritten. 
 
    eps : float, default=np.finfo(float).eps 
        The machine-precision regularization in the computation of the 
        Cholesky diagonal factors. Increase this for very ill-conditioned 
        systems. Unlike the ``tol`` parameter in some iterative 
        optimization-based algorithms, this parameter does not control 
        the tolerance of the optimization. 
 
    copy_Gram : bool, default=True 
        If ``False``, ``Gram`` is overwritten. 
 
    verbose : int, default=0 
        Controls output verbosity. 
 
    return_path : bool, default=True 
        If ``return_path==True`` returns the entire path, else returns only the 
        last point of the path. 
 
    return_n_iter : bool, default=False 
        Whether to return the number of iterations. 
 
    positive : bool, default=False 
        Restrict coefficients to be &gt;= 0. 
        This option is only allowed with method 'lasso'. Note that the model 
        coefficients will not converge to the ordinary-least-squares solution 
        for small values of alpha. Only coefficients up to the smallest alpha 
        value (``alphas_[alphas_ &gt; 0.].min()`` when fit_path=True) reached by 
        the stepwise Lars-Lasso algorithm are typically in congruence with the 
        solution of the coordinate descent lasso_path function. 
 
    Returns 
    ------- 
    alphas : array-like of shape (n_alphas + 1,) 
        Maximum of covariances (in absolute value) at each iteration. 
        ``n_alphas`` is either ``max_iter``, ``n_features`` or the 
        number of nodes in the path with ``alpha &gt;= alpha_min``, whichever 
        is smaller. 
 
    active : array-like of shape (n_alphas,) 
        Indices of active variables at the end of the path. 
 
    coefs : array-like of shape (n_features, n_alphas + 1) 
        Coefficients along the path 
 
    n_iter : int 
        Number of iterations run. Returned only if return_n_iter is set 
        to True. 
 
    See Also 
    -------- 
    lasso_path 
    LassoLars 
    Lars 
    LassoLarsCV 
    LarsCV 
    sklearn.decomposition.sparse_encode 
 
    References 
    ---------- 
    .. [1] &quot;Least Angle Regression&quot;, Efron et al. 
           http://statweb.stanford.edu/~tibs/ftp/lars.pdf 
 
    .. [2] `Wikipedia entry on the Least-angle regression 
           &lt;https://en.wikipedia.org/wiki/Least-angle_regression&gt;`_ 
 
    .. [3] `Wikipedia entry on the Lasso 
           &lt;https://en.wikipedia.org/wiki/Lasso_(statistics)&gt;`_ 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">method == </span><span class="s4">&quot;lar&quot; </span><span class="s3">and </span><span class="s1">positive:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Positive constraint not supported for 'lar' coding method.&quot;</span><span class="s1">)</span>

    <span class="s1">n_samples = n_samples </span><span class="s3">if </span><span class="s1">n_samples </span><span class="s3">is not None else </span><span class="s1">y.size</span>

    <span class="s3">if </span><span class="s1">Xy </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">Cov = np.dot(X.T</span><span class="s3">, </span><span class="s1">y)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">Cov = Xy.copy()</span>

    <span class="s3">if </span><span class="s1">Gram </span><span class="s3">is None or </span><span class="s1">Gram </span><span class="s3">is False</span><span class="s1">:</span>
        <span class="s1">Gram = </span><span class="s3">None</span>
        <span class="s3">if </span><span class="s1">X </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;X and Gram cannot both be unspecified.&quot;</span><span class="s1">)</span>
    <span class="s3">elif </span><span class="s1">isinstance(Gram</span><span class="s3">, </span><span class="s1">str) </span><span class="s3">and </span><span class="s1">Gram == </span><span class="s4">&quot;auto&quot; </span><span class="s3">or </span><span class="s1">Gram </span><span class="s3">is True</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">Gram </span><span class="s3">is True or </span><span class="s1">X.shape[</span><span class="s5">0</span><span class="s1">] &gt; X.shape[</span><span class="s5">1</span><span class="s1">]:</span>
            <span class="s1">Gram = np.dot(X.T</span><span class="s3">, </span><span class="s1">X)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">Gram = </span><span class="s3">None</span>
    <span class="s3">elif </span><span class="s1">copy_Gram:</span>
        <span class="s1">Gram = Gram.copy()</span>

    <span class="s3">if </span><span class="s1">Gram </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">n_features = X.shape[</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">n_features = Cov.shape[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s3">if </span><span class="s1">Gram.shape != (n_features</span><span class="s3">, </span><span class="s1">n_features):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;The shapes of the inputs Gram and Xy do not match.&quot;</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">copy_X </span><span class="s3">and </span><span class="s1">X </span><span class="s3">is not None and </span><span class="s1">Gram </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s2"># force copy. setting the array to be fortran-ordered</span>
        <span class="s2"># speeds up the calculation of the (partial) Gram matrix</span>
        <span class="s2"># and allows to easily swap columns</span>
        <span class="s1">X = X.copy(</span><span class="s4">&quot;F&quot;</span><span class="s1">)</span>

    <span class="s1">max_features = min(max_iter</span><span class="s3">, </span><span class="s1">n_features)</span>

    <span class="s1">dtypes = set(a.dtype </span><span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">Xy</span><span class="s3">, </span><span class="s1">Gram) </span><span class="s3">if </span><span class="s1">a </span><span class="s3">is not None</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">len(dtypes) == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s2"># use the precision level of input data if it is consistent</span>
        <span class="s1">return_dtype = next(iter(dtypes))</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s2"># fallback to double precision otherwise</span>
        <span class="s1">return_dtype = np.float64</span>

    <span class="s3">if </span><span class="s1">return_path:</span>
        <span class="s1">coefs = np.zeros((max_features + </span><span class="s5">1</span><span class="s3">, </span><span class="s1">n_features)</span><span class="s3">, </span><span class="s1">dtype=return_dtype)</span>
        <span class="s1">alphas = np.zeros(max_features + </span><span class="s5">1</span><span class="s3">, </span><span class="s1">dtype=return_dtype)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">coef</span><span class="s3">, </span><span class="s1">prev_coef = (</span>
            <span class="s1">np.zeros(n_features</span><span class="s3">, </span><span class="s1">dtype=return_dtype)</span><span class="s3">,</span>
            <span class="s1">np.zeros(n_features</span><span class="s3">, </span><span class="s1">dtype=return_dtype)</span><span class="s3">,</span>
        <span class="s1">)</span>
        <span class="s1">alpha</span><span class="s3">, </span><span class="s1">prev_alpha = (</span>
            <span class="s1">np.array([</span><span class="s5">0.0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dtype=return_dtype)</span><span class="s3">,</span>
            <span class="s1">np.array([</span><span class="s5">0.0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dtype=return_dtype)</span><span class="s3">,</span>
        <span class="s1">)</span>
        <span class="s2"># above better ideas?</span>

    <span class="s1">n_iter</span><span class="s3">, </span><span class="s1">n_active = </span><span class="s5">0</span><span class="s3">, </span><span class="s5">0</span>
    <span class="s1">active</span><span class="s3">, </span><span class="s1">indices = list()</span><span class="s3">, </span><span class="s1">np.arange(n_features)</span>
    <span class="s2"># holds the sign of covariance</span>
    <span class="s1">sign_active = np.empty(max_features</span><span class="s3">, </span><span class="s1">dtype=np.int8)</span>
    <span class="s1">drop = </span><span class="s3">False</span>

    <span class="s2"># will hold the cholesky factorization. Only lower part is</span>
    <span class="s2"># referenced.</span>
    <span class="s3">if </span><span class="s1">Gram </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">L = np.empty((max_features</span><span class="s3">, </span><span class="s1">max_features)</span><span class="s3">, </span><span class="s1">dtype=X.dtype)</span>
        <span class="s1">swap</span><span class="s3">, </span><span class="s1">nrm2 = linalg.get_blas_funcs((</span><span class="s4">&quot;swap&quot;</span><span class="s3">, </span><span class="s4">&quot;nrm2&quot;</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(X</span><span class="s3">,</span><span class="s1">))</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">L = np.empty((max_features</span><span class="s3">, </span><span class="s1">max_features)</span><span class="s3">, </span><span class="s1">dtype=Gram.dtype)</span>
        <span class="s1">swap</span><span class="s3">, </span><span class="s1">nrm2 = linalg.get_blas_funcs((</span><span class="s4">&quot;swap&quot;</span><span class="s3">, </span><span class="s4">&quot;nrm2&quot;</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(Cov</span><span class="s3">,</span><span class="s1">))</span>
    <span class="s1">(solve_cholesky</span><span class="s3">,</span><span class="s1">) = get_lapack_funcs((</span><span class="s4">&quot;potrs&quot;</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">(L</span><span class="s3">,</span><span class="s1">))</span>

    <span class="s3">if </span><span class="s1">verbose:</span>
        <span class="s3">if </span><span class="s1">verbose &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">print(</span><span class="s4">&quot;Step</span><span class="s3">\t\t</span><span class="s4">Added</span><span class="s3">\t\t</span><span class="s4">Dropped</span><span class="s3">\t\t</span><span class="s4">Active set size</span><span class="s3">\t\t</span><span class="s4">C&quot;</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">sys.stdout.write(</span><span class="s4">&quot;.&quot;</span><span class="s1">)</span>
            <span class="s1">sys.stdout.flush()</span>

    <span class="s1">tiny32 = np.finfo(np.float32).tiny  </span><span class="s2"># to avoid division by 0 warning</span>
    <span class="s1">cov_precision = np.finfo(Cov.dtype).precision</span>
    <span class="s1">equality_tolerance = np.finfo(np.float32).eps</span>

    <span class="s3">if </span><span class="s1">Gram </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s1">Gram_copy = Gram.copy()</span>
        <span class="s1">Cov_copy = Cov.copy()</span>

    <span class="s3">while True</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">Cov.size:</span>
            <span class="s3">if </span><span class="s1">positive:</span>
                <span class="s1">C_idx = np.argmax(Cov)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">C_idx = np.argmax(np.abs(Cov))</span>

            <span class="s1">C_ = Cov[C_idx]</span>

            <span class="s3">if </span><span class="s1">positive:</span>
                <span class="s1">C = C_</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">C = np.fabs(C_)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">C = </span><span class="s5">0.0</span>

        <span class="s3">if </span><span class="s1">return_path:</span>
            <span class="s1">alpha = alphas[n_iter</span><span class="s3">, </span><span class="s1">np.newaxis]</span>
            <span class="s1">coef = coefs[n_iter]</span>
            <span class="s1">prev_alpha = alphas[n_iter - </span><span class="s5">1</span><span class="s3">, </span><span class="s1">np.newaxis]</span>
            <span class="s1">prev_coef = coefs[n_iter - </span><span class="s5">1</span><span class="s1">]</span>

        <span class="s1">alpha[</span><span class="s5">0</span><span class="s1">] = C / n_samples</span>
        <span class="s3">if </span><span class="s1">alpha[</span><span class="s5">0</span><span class="s1">] &lt;= alpha_min + equality_tolerance:  </span><span class="s2"># early stopping</span>
            <span class="s3">if </span><span class="s1">abs(alpha[</span><span class="s5">0</span><span class="s1">] - alpha_min) &gt; equality_tolerance:</span>
                <span class="s2"># interpolation factor 0 &lt;= ss &lt; 1</span>
                <span class="s3">if </span><span class="s1">n_iter &gt; </span><span class="s5">0</span><span class="s1">:</span>
                    <span class="s2"># In the first iteration, all alphas are zero, the formula</span>
                    <span class="s2"># below would make ss a NaN</span>
                    <span class="s1">ss = (prev_alpha[</span><span class="s5">0</span><span class="s1">] - alpha_min) / (prev_alpha[</span><span class="s5">0</span><span class="s1">] - alpha[</span><span class="s5">0</span><span class="s1">])</span>
                    <span class="s1">coef[:] = prev_coef + ss * (coef - prev_coef)</span>
                <span class="s1">alpha[</span><span class="s5">0</span><span class="s1">] = alpha_min</span>
            <span class="s3">if </span><span class="s1">return_path:</span>
                <span class="s1">coefs[n_iter] = coef</span>
            <span class="s3">break</span>

        <span class="s3">if </span><span class="s1">n_iter &gt;= max_iter </span><span class="s3">or </span><span class="s1">n_active &gt;= n_features:</span>
            <span class="s3">break</span>
        <span class="s3">if not </span><span class="s1">drop:</span>
            <span class="s2">##########################################################</span>
            <span class="s2"># Append x_j to the Cholesky factorization of (Xa * Xa') #</span>
            <span class="s2">#                                                        #</span>
            <span class="s2">#            ( L   0 )                                   #</span>
            <span class="s2">#     L  -&gt;  (       )  , where L * w = Xa' x_j          #</span>
            <span class="s2">#            ( w   z )    and z = ||x_j||                #</span>
            <span class="s2">#                                                        #</span>
            <span class="s2">##########################################################</span>

            <span class="s3">if </span><span class="s1">positive:</span>
                <span class="s1">sign_active[n_active] = np.ones_like(C_)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">sign_active[n_active] = np.sign(C_)</span>
            <span class="s1">m</span><span class="s3">, </span><span class="s1">n = n_active</span><span class="s3">, </span><span class="s1">C_idx + n_active</span>

            <span class="s1">Cov[C_idx]</span><span class="s3">, </span><span class="s1">Cov[</span><span class="s5">0</span><span class="s1">] = swap(Cov[C_idx]</span><span class="s3">, </span><span class="s1">Cov[</span><span class="s5">0</span><span class="s1">])</span>
            <span class="s1">indices[n]</span><span class="s3">, </span><span class="s1">indices[m] = indices[m]</span><span class="s3">, </span><span class="s1">indices[n]</span>
            <span class="s1">Cov_not_shortened = Cov</span>
            <span class="s1">Cov = Cov[</span><span class="s5">1</span><span class="s1">:]  </span><span class="s2"># remove Cov[0]</span>

            <span class="s3">if </span><span class="s1">Gram </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s1">X.T[n]</span><span class="s3">, </span><span class="s1">X.T[m] = swap(X.T[n]</span><span class="s3">, </span><span class="s1">X.T[m])</span>
                <span class="s1">c = nrm2(X.T[n_active]) ** </span><span class="s5">2</span>
                <span class="s1">L[n_active</span><span class="s3">, </span><span class="s1">:n_active] = np.dot(X.T[n_active]</span><span class="s3">, </span><span class="s1">X.T[:n_active].T)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s2"># swap does only work inplace if matrix is fortran</span>
                <span class="s2"># contiguous ...</span>
                <span class="s1">Gram[m]</span><span class="s3">, </span><span class="s1">Gram[n] = swap(Gram[m]</span><span class="s3">, </span><span class="s1">Gram[n])</span>
                <span class="s1">Gram[:</span><span class="s3">, </span><span class="s1">m]</span><span class="s3">, </span><span class="s1">Gram[:</span><span class="s3">, </span><span class="s1">n] = swap(Gram[:</span><span class="s3">, </span><span class="s1">m]</span><span class="s3">, </span><span class="s1">Gram[:</span><span class="s3">, </span><span class="s1">n])</span>
                <span class="s1">c = Gram[n_active</span><span class="s3">, </span><span class="s1">n_active]</span>
                <span class="s1">L[n_active</span><span class="s3">, </span><span class="s1">:n_active] = Gram[n_active</span><span class="s3">, </span><span class="s1">:n_active]</span>

            <span class="s2"># Update the cholesky decomposition for the Gram matrix</span>
            <span class="s3">if </span><span class="s1">n_active:</span>
                <span class="s1">linalg.solve_triangular(</span>
                    <span class="s1">L[:n_active</span><span class="s3">, </span><span class="s1">:n_active]</span><span class="s3">,</span>
                    <span class="s1">L[n_active</span><span class="s3">, </span><span class="s1">:n_active]</span><span class="s3">,</span>
                    <span class="s1">trans=</span><span class="s5">0</span><span class="s3">,</span>
                    <span class="s1">lower=</span><span class="s5">1</span><span class="s3">,</span>
                    <span class="s1">overwrite_b=</span><span class="s3">True,</span>
                    <span class="s1">**SOLVE_TRIANGULAR_ARGS</span><span class="s3">,</span>
                <span class="s1">)</span>

            <span class="s1">v = np.dot(L[n_active</span><span class="s3">, </span><span class="s1">:n_active]</span><span class="s3">, </span><span class="s1">L[n_active</span><span class="s3">, </span><span class="s1">:n_active])</span>
            <span class="s1">diag = max(np.sqrt(np.abs(c - v))</span><span class="s3">, </span><span class="s1">eps)</span>
            <span class="s1">L[n_active</span><span class="s3">, </span><span class="s1">n_active] = diag</span>

            <span class="s3">if </span><span class="s1">diag &lt; </span><span class="s5">1e-7</span><span class="s1">:</span>
                <span class="s2"># The system is becoming too ill-conditioned.</span>
                <span class="s2"># We have degenerate vectors in our active set.</span>
                <span class="s2"># We'll 'drop for good' the last regressor added.</span>
                <span class="s1">warnings.warn(</span>
                    <span class="s4">&quot;Regressors in active set degenerate. &quot;</span>
                    <span class="s4">&quot;Dropping a regressor, after %i iterations, &quot;</span>
                    <span class="s4">&quot;i.e. alpha=%.3e, &quot;</span>
                    <span class="s4">&quot;with an active set of %i regressors, and &quot;</span>
                    <span class="s4">&quot;the smallest cholesky pivot element being %.3e.&quot;</span>
                    <span class="s4">&quot; Reduce max_iter or increase eps parameters.&quot;</span>
                    <span class="s1">% (n_iter</span><span class="s3">, </span><span class="s1">alpha.item()</span><span class="s3">, </span><span class="s1">n_active</span><span class="s3">, </span><span class="s1">diag)</span><span class="s3">,</span>
                    <span class="s1">ConvergenceWarning</span><span class="s3">,</span>
                <span class="s1">)</span>

                <span class="s2"># XXX: need to figure a 'drop for good' way</span>
                <span class="s1">Cov = Cov_not_shortened</span>
                <span class="s1">Cov[</span><span class="s5">0</span><span class="s1">] = </span><span class="s5">0</span>
                <span class="s1">Cov[C_idx]</span><span class="s3">, </span><span class="s1">Cov[</span><span class="s5">0</span><span class="s1">] = swap(Cov[C_idx]</span><span class="s3">, </span><span class="s1">Cov[</span><span class="s5">0</span><span class="s1">])</span>
                <span class="s3">continue</span>

            <span class="s1">active.append(indices[n_active])</span>
            <span class="s1">n_active += </span><span class="s5">1</span>

            <span class="s3">if </span><span class="s1">verbose &gt; </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">print(</span>
                    <span class="s4">&quot;%s</span><span class="s3">\t\t</span><span class="s4">%s</span><span class="s3">\t\t</span><span class="s4">%s</span><span class="s3">\t\t</span><span class="s4">%s</span><span class="s3">\t\t</span><span class="s4">%s&quot; </span><span class="s1">% (n_iter</span><span class="s3">, </span><span class="s1">active[-</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s4">&quot;&quot;</span><span class="s3">, </span><span class="s1">n_active</span><span class="s3">, </span><span class="s1">C)</span>
                <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">method == </span><span class="s4">&quot;lasso&quot; </span><span class="s3">and </span><span class="s1">n_iter &gt; </span><span class="s5">0 </span><span class="s3">and </span><span class="s1">prev_alpha[</span><span class="s5">0</span><span class="s1">] &lt; alpha[</span><span class="s5">0</span><span class="s1">]:</span>
            <span class="s2"># alpha is increasing. This is because the updates of Cov are</span>
            <span class="s2"># bringing in too much numerical error that is greater than</span>
            <span class="s2"># than the remaining correlation with the</span>
            <span class="s2"># regressors. Time to bail out</span>
            <span class="s1">warnings.warn(</span>
                <span class="s4">&quot;Early stopping the lars path, as the residues &quot;</span>
                <span class="s4">&quot;are small and the current value of alpha is no &quot;</span>
                <span class="s4">&quot;longer well controlled. %i iterations, alpha=%.3e, &quot;</span>
                <span class="s4">&quot;previous alpha=%.3e, with an active set of %i &quot;</span>
                <span class="s4">&quot;regressors.&quot; </span><span class="s1">% (n_iter</span><span class="s3">, </span><span class="s1">alpha.item()</span><span class="s3">, </span><span class="s1">prev_alpha.item()</span><span class="s3">, </span><span class="s1">n_active)</span><span class="s3">,</span>
                <span class="s1">ConvergenceWarning</span><span class="s3">,</span>
            <span class="s1">)</span>
            <span class="s3">break</span>

        <span class="s2"># least squares solution</span>
        <span class="s1">least_squares</span><span class="s3">, </span><span class="s1">_ = solve_cholesky(</span>
            <span class="s1">L[:n_active</span><span class="s3">, </span><span class="s1">:n_active]</span><span class="s3">, </span><span class="s1">sign_active[:n_active]</span><span class="s3">, </span><span class="s1">lower=</span><span class="s3">True</span>
        <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">least_squares.size == </span><span class="s5">1 </span><span class="s3">and </span><span class="s1">least_squares == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2"># This happens because sign_active[:n_active] = 0</span>
            <span class="s1">least_squares[...] = </span><span class="s5">1</span>
            <span class="s1">AA = </span><span class="s5">1.0</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s2"># is this really needed ?</span>
            <span class="s1">AA = </span><span class="s5">1.0 </span><span class="s1">/ np.sqrt(np.sum(least_squares * sign_active[:n_active]))</span>

            <span class="s3">if not </span><span class="s1">np.isfinite(AA):</span>
                <span class="s2"># L is too ill-conditioned</span>
                <span class="s1">i = </span><span class="s5">0</span>
                <span class="s1">L_ = L[:n_active</span><span class="s3">, </span><span class="s1">:n_active].copy()</span>
                <span class="s3">while not </span><span class="s1">np.isfinite(AA):</span>
                    <span class="s1">L_.flat[:: n_active + </span><span class="s5">1</span><span class="s1">] += (</span><span class="s5">2</span><span class="s1">**i) * eps</span>
                    <span class="s1">least_squares</span><span class="s3">, </span><span class="s1">_ = solve_cholesky(</span>
                        <span class="s1">L_</span><span class="s3">, </span><span class="s1">sign_active[:n_active]</span><span class="s3">, </span><span class="s1">lower=</span><span class="s3">True</span>
                    <span class="s1">)</span>
                    <span class="s1">tmp = max(np.sum(least_squares * sign_active[:n_active])</span><span class="s3">, </span><span class="s1">eps)</span>
                    <span class="s1">AA = </span><span class="s5">1.0 </span><span class="s1">/ np.sqrt(tmp)</span>
                    <span class="s1">i += </span><span class="s5">1</span>
            <span class="s1">least_squares *= AA</span>

        <span class="s3">if </span><span class="s1">Gram </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s2"># equiangular direction of variables in the active set</span>
            <span class="s1">eq_dir = np.dot(X.T[:n_active].T</span><span class="s3">, </span><span class="s1">least_squares)</span>
            <span class="s2"># correlation between each unactive variables and</span>
            <span class="s2"># eqiangular vector</span>
            <span class="s1">corr_eq_dir = np.dot(X.T[n_active:]</span><span class="s3">, </span><span class="s1">eq_dir)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s2"># if huge number of features, this takes 50% of time, I</span>
            <span class="s2"># think could be avoided if we just update it using an</span>
            <span class="s2"># orthogonal (QR) decomposition of X</span>
            <span class="s1">corr_eq_dir = np.dot(Gram[:n_active</span><span class="s3">, </span><span class="s1">n_active:].T</span><span class="s3">, </span><span class="s1">least_squares)</span>

        <span class="s2"># Explicit rounding can be necessary to avoid `np.argmax(Cov)` yielding</span>
        <span class="s2"># unstable results because of rounding errors.</span>
        <span class="s1">np.around(corr_eq_dir</span><span class="s3">, </span><span class="s1">decimals=cov_precision</span><span class="s3">, </span><span class="s1">out=corr_eq_dir)</span>

        <span class="s1">g1 = arrayfuncs.min_pos((C - Cov) / (AA - corr_eq_dir + tiny32))</span>
        <span class="s3">if </span><span class="s1">positive:</span>
            <span class="s1">gamma_ = min(g1</span><span class="s3">, </span><span class="s1">C / AA)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">g2 = arrayfuncs.min_pos((C + Cov) / (AA + corr_eq_dir + tiny32))</span>
            <span class="s1">gamma_ = min(g1</span><span class="s3">, </span><span class="s1">g2</span><span class="s3">, </span><span class="s1">C / AA)</span>

        <span class="s2"># TODO: better names for these variables: z</span>
        <span class="s1">drop = </span><span class="s3">False</span>
        <span class="s1">z = -coef[active] / (least_squares + tiny32)</span>
        <span class="s1">z_pos = arrayfuncs.min_pos(z)</span>
        <span class="s3">if </span><span class="s1">z_pos &lt; gamma_:</span>
            <span class="s2"># some coefficients have changed sign</span>
            <span class="s1">idx = np.where(z == z_pos)[</span><span class="s5">0</span><span class="s1">][::-</span><span class="s5">1</span><span class="s1">]</span>

            <span class="s2"># update the sign, important for LAR</span>
            <span class="s1">sign_active[idx] = -sign_active[idx]</span>

            <span class="s3">if </span><span class="s1">method == </span><span class="s4">&quot;lasso&quot;</span><span class="s1">:</span>
                <span class="s1">gamma_ = z_pos</span>
            <span class="s1">drop = </span><span class="s3">True</span>

        <span class="s1">n_iter += </span><span class="s5">1</span>

        <span class="s3">if </span><span class="s1">return_path:</span>
            <span class="s3">if </span><span class="s1">n_iter &gt;= coefs.shape[</span><span class="s5">0</span><span class="s1">]:</span>
                <span class="s3">del </span><span class="s1">coef</span><span class="s3">, </span><span class="s1">alpha</span><span class="s3">, </span><span class="s1">prev_alpha</span><span class="s3">, </span><span class="s1">prev_coef</span>
                <span class="s2"># resize the coefs and alphas array</span>
                <span class="s1">add_features = </span><span class="s5">2 </span><span class="s1">* max(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">(max_features - n_active))</span>
                <span class="s1">coefs = np.resize(coefs</span><span class="s3">, </span><span class="s1">(n_iter + add_features</span><span class="s3">, </span><span class="s1">n_features))</span>
                <span class="s1">coefs[-add_features:] = </span><span class="s5">0</span>
                <span class="s1">alphas = np.resize(alphas</span><span class="s3">, </span><span class="s1">n_iter + add_features)</span>
                <span class="s1">alphas[-add_features:] = </span><span class="s5">0</span>
            <span class="s1">coef = coefs[n_iter]</span>
            <span class="s1">prev_coef = coefs[n_iter - </span><span class="s5">1</span><span class="s1">]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s2"># mimic the effect of incrementing n_iter on the array references</span>
            <span class="s1">prev_coef = coef</span>
            <span class="s1">prev_alpha[</span><span class="s5">0</span><span class="s1">] = alpha[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">coef = np.zeros_like(coef)</span>

        <span class="s1">coef[active] = prev_coef[active] + gamma_ * least_squares</span>

        <span class="s2"># update correlations</span>
        <span class="s1">Cov -= gamma_ * corr_eq_dir</span>

        <span class="s2"># See if any coefficient has changed sign</span>
        <span class="s3">if </span><span class="s1">drop </span><span class="s3">and </span><span class="s1">method == </span><span class="s4">&quot;lasso&quot;</span><span class="s1">:</span>
            <span class="s2"># handle the case when idx is not length of 1</span>
            <span class="s3">for </span><span class="s1">ii </span><span class="s3">in </span><span class="s1">idx:</span>
                <span class="s1">arrayfuncs.cholesky_delete(L[:n_active</span><span class="s3">, </span><span class="s1">:n_active]</span><span class="s3">, </span><span class="s1">ii)</span>

            <span class="s1">n_active -= </span><span class="s5">1</span>
            <span class="s2"># handle the case when idx is not length of 1</span>
            <span class="s1">drop_idx = [active.pop(ii) </span><span class="s3">for </span><span class="s1">ii </span><span class="s3">in </span><span class="s1">idx]</span>

            <span class="s3">if </span><span class="s1">Gram </span><span class="s3">is None</span><span class="s1">:</span>
                <span class="s2"># propagate dropped variable</span>
                <span class="s3">for </span><span class="s1">ii </span><span class="s3">in </span><span class="s1">idx:</span>
                    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(ii</span><span class="s3">, </span><span class="s1">n_active):</span>
                        <span class="s1">X.T[i]</span><span class="s3">, </span><span class="s1">X.T[i + </span><span class="s5">1</span><span class="s1">] = swap(X.T[i]</span><span class="s3">, </span><span class="s1">X.T[i + </span><span class="s5">1</span><span class="s1">])</span>
                        <span class="s2"># yeah this is stupid</span>
                        <span class="s1">indices[i]</span><span class="s3">, </span><span class="s1">indices[i + </span><span class="s5">1</span><span class="s1">] = indices[i + </span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">indices[i]</span>

                <span class="s2"># TODO: this could be updated</span>
                <span class="s1">residual = y - np.dot(X[:</span><span class="s3">, </span><span class="s1">:n_active]</span><span class="s3">, </span><span class="s1">coef[active])</span>
                <span class="s1">temp = np.dot(X.T[n_active]</span><span class="s3">, </span><span class="s1">residual)</span>

                <span class="s1">Cov = np.r_[temp</span><span class="s3">, </span><span class="s1">Cov]</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">for </span><span class="s1">ii </span><span class="s3">in </span><span class="s1">idx:</span>
                    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(ii</span><span class="s3">, </span><span class="s1">n_active):</span>
                        <span class="s1">indices[i]</span><span class="s3">, </span><span class="s1">indices[i + </span><span class="s5">1</span><span class="s1">] = indices[i + </span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">indices[i]</span>
                        <span class="s1">Gram[i]</span><span class="s3">, </span><span class="s1">Gram[i + </span><span class="s5">1</span><span class="s1">] = swap(Gram[i]</span><span class="s3">, </span><span class="s1">Gram[i + </span><span class="s5">1</span><span class="s1">])</span>
                        <span class="s1">Gram[:</span><span class="s3">, </span><span class="s1">i]</span><span class="s3">, </span><span class="s1">Gram[:</span><span class="s3">, </span><span class="s1">i + </span><span class="s5">1</span><span class="s1">] = swap(Gram[:</span><span class="s3">, </span><span class="s1">i]</span><span class="s3">, </span><span class="s1">Gram[:</span><span class="s3">, </span><span class="s1">i + </span><span class="s5">1</span><span class="s1">])</span>

                <span class="s2"># Cov_n = Cov_j + x_j * X + increment(betas) TODO:</span>
                <span class="s2"># will this still work with multiple drops ?</span>

                <span class="s2"># recompute covariance. Probably could be done better</span>
                <span class="s2"># wrong as Xy is not swapped with the rest of variables</span>

                <span class="s2"># TODO: this could be updated</span>
                <span class="s1">temp = Cov_copy[drop_idx] - np.dot(Gram_copy[drop_idx]</span><span class="s3">, </span><span class="s1">coef)</span>
                <span class="s1">Cov = np.r_[temp</span><span class="s3">, </span><span class="s1">Cov]</span>

            <span class="s1">sign_active = np.delete(sign_active</span><span class="s3">, </span><span class="s1">idx)</span>
            <span class="s1">sign_active = np.append(sign_active</span><span class="s3">, </span><span class="s5">0.0</span><span class="s1">)  </span><span class="s2"># just to maintain size</span>
            <span class="s3">if </span><span class="s1">verbose &gt; </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">print(</span>
                    <span class="s4">&quot;%s</span><span class="s3">\t\t</span><span class="s4">%s</span><span class="s3">\t\t</span><span class="s4">%s</span><span class="s3">\t\t</span><span class="s4">%s</span><span class="s3">\t\t</span><span class="s4">%s&quot;</span>
                    <span class="s1">% (n_iter</span><span class="s3">, </span><span class="s4">&quot;&quot;</span><span class="s3">, </span><span class="s1">drop_idx</span><span class="s3">, </span><span class="s1">n_active</span><span class="s3">, </span><span class="s1">abs(temp))</span>
                <span class="s1">)</span>

    <span class="s3">if </span><span class="s1">return_path:</span>
        <span class="s2"># resize coefs in case of early stop</span>
        <span class="s1">alphas = alphas[: n_iter + </span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">coefs = coefs[: n_iter + </span><span class="s5">1</span><span class="s1">]</span>

        <span class="s3">if </span><span class="s1">return_n_iter:</span>
            <span class="s3">return </span><span class="s1">alphas</span><span class="s3">, </span><span class="s1">active</span><span class="s3">, </span><span class="s1">coefs.T</span><span class="s3">, </span><span class="s1">n_iter</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">alphas</span><span class="s3">, </span><span class="s1">active</span><span class="s3">, </span><span class="s1">coefs.T</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">return_n_iter:</span>
            <span class="s3">return </span><span class="s1">alpha</span><span class="s3">, </span><span class="s1">active</span><span class="s3">, </span><span class="s1">coef</span><span class="s3">, </span><span class="s1">n_iter</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">alpha</span><span class="s3">, </span><span class="s1">active</span><span class="s3">, </span><span class="s1">coef</span>


<span class="s2">###############################################################################</span>
<span class="s2"># Estimator classes</span>


<span class="s3">class </span><span class="s1">Lars(MultiOutputMixin</span><span class="s3">, </span><span class="s1">RegressorMixin</span><span class="s3">, </span><span class="s1">LinearModel):</span>
    <span class="s0">&quot;&quot;&quot;Least Angle Regression model a.k.a. LAR. 
 
    Read more in the :ref:`User Guide &lt;least_angle_regression&gt;`. 
 
    Parameters 
    ---------- 
    fit_intercept : bool, default=True 
        Whether to calculate the intercept for this model. If set 
        to false, no intercept will be used in calculations 
        (i.e. data is expected to be centered). 
 
    verbose : bool or int, default=False 
        Sets the verbosity amount. 
 
    normalize : bool, default=False 
        This parameter is ignored when ``fit_intercept`` is set to False. 
        If True, the regressors X will be normalized before regression by 
        subtracting the mean and dividing by the l2-norm. 
        If you wish to standardize, please use 
        :class:`~sklearn.preprocessing.StandardScaler` before calling ``fit`` 
        on an estimator with ``normalize=False``. 
 
        .. versionchanged:: 1.2 
           default changed from True to False in 1.2. 
 
        .. deprecated:: 1.2 
            ``normalize`` was deprecated in version 1.2 and will be removed in 1.4. 
 
    precompute : bool, 'auto' or array-like , default='auto' 
        Whether to use a precomputed Gram matrix to speed up 
        calculations. If set to ``'auto'`` let us decide. The Gram 
        matrix can also be passed as argument. 
 
    n_nonzero_coefs : int, default=500 
        Target number of non-zero coefficients. Use ``np.inf`` for no limit. 
 
    eps : float, default=np.finfo(float).eps 
        The machine-precision regularization in the computation of the 
        Cholesky diagonal factors. Increase this for very ill-conditioned 
        systems. Unlike the ``tol`` parameter in some iterative 
        optimization-based algorithms, this parameter does not control 
        the tolerance of the optimization. 
 
    copy_X : bool, default=True 
        If ``True``, X will be copied; else, it may be overwritten. 
 
    fit_path : bool, default=True 
        If True the full path is stored in the ``coef_path_`` attribute. 
        If you compute the solution for a large problem or many targets, 
        setting ``fit_path`` to ``False`` will lead to a speedup, especially 
        with a small alpha. 
 
    jitter : float, default=None 
        Upper bound on a uniform noise parameter to be added to the 
        `y` values, to satisfy the model's assumption of 
        one-at-a-time computations. Might help with stability. 
 
        .. versionadded:: 0.23 
 
    random_state : int, RandomState instance or None, default=None 
        Determines random number generation for jittering. Pass an int 
        for reproducible output across multiple function calls. 
        See :term:`Glossary &lt;random_state&gt;`. Ignored if `jitter` is None. 
 
        .. versionadded:: 0.23 
 
    Attributes 
    ---------- 
    alphas_ : array-like of shape (n_alphas + 1,) or list of such arrays 
        Maximum of covariances (in absolute value) at each iteration. 
        ``n_alphas`` is either ``max_iter``, ``n_features`` or the 
        number of nodes in the path with ``alpha &gt;= alpha_min``, whichever 
        is smaller. If this is a list of array-like, the length of the outer 
        list is `n_targets`. 
 
    active_ : list of shape (n_alphas,) or list of such lists 
        Indices of active variables at the end of the path. 
        If this is a list of list, the length of the outer list is `n_targets`. 
 
    coef_path_ : array-like of shape (n_features, n_alphas + 1) or list \ 
            of such arrays 
        The varying values of the coefficients along the path. It is not 
        present if the ``fit_path`` parameter is ``False``. If this is a list 
        of array-like, the length of the outer list is `n_targets`. 
 
    coef_ : array-like of shape (n_features,) or (n_targets, n_features) 
        Parameter vector (w in the formulation formula). 
 
    intercept_ : float or array-like of shape (n_targets,) 
        Independent term in decision function. 
 
    n_iter_ : array-like or int 
        The number of iterations taken by lars_path to find the 
        grid of alphas for each target. 
 
    n_features_in_ : int 
        Number of features seen during :term:`fit`. 
 
        .. versionadded:: 0.24 
 
    feature_names_in_ : ndarray of shape (`n_features_in_`,) 
        Names of features seen during :term:`fit`. Defined only when `X` 
        has feature names that are all strings. 
 
        .. versionadded:: 1.0 
 
    See Also 
    -------- 
    lars_path: Compute Least Angle Regression or Lasso 
        path using LARS algorithm. 
    LarsCV : Cross-validated Least Angle Regression model. 
    sklearn.decomposition.sparse_encode : Sparse coding. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn import linear_model 
    &gt;&gt;&gt; reg = linear_model.Lars(n_nonzero_coefs=1) 
    &gt;&gt;&gt; reg.fit([[-1, 1], [0, 0], [1, 1]], [-1.1111, 0, -1.1111]) 
    Lars(n_nonzero_coefs=1) 
    &gt;&gt;&gt; print(reg.coef_) 
    [ 0. -1.11...] 
    &quot;&quot;&quot;</span>

    <span class="s1">_parameter_constraints: dict = {</span>
        <span class="s4">&quot;fit_intercept&quot;</span><span class="s1">: [</span><span class="s4">&quot;boolean&quot;</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;verbose&quot;</span><span class="s1">: [</span><span class="s4">&quot;verbose&quot;</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;normalize&quot;</span><span class="s1">: [</span><span class="s4">&quot;boolean&quot;</span><span class="s3">, </span><span class="s1">Hidden(StrOptions({</span><span class="s4">&quot;deprecated&quot;</span><span class="s1">}))]</span><span class="s3">,</span>
        <span class="s4">&quot;precompute&quot;</span><span class="s1">: [</span><span class="s4">&quot;boolean&quot;</span><span class="s3">, </span><span class="s1">StrOptions({</span><span class="s4">&quot;auto&quot;</span><span class="s1">})</span><span class="s3">, </span><span class="s1">np.ndarray</span><span class="s3">, </span><span class="s1">Hidden(</span><span class="s3">None</span><span class="s1">)]</span><span class="s3">,</span>
        <span class="s4">&quot;n_nonzero_coefs&quot;</span><span class="s1">: [Interval(Integral</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, None, </span><span class="s1">closed=</span><span class="s4">&quot;left&quot;</span><span class="s1">)]</span><span class="s3">,</span>
        <span class="s4">&quot;eps&quot;</span><span class="s1">: [Interval(Real</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, None, </span><span class="s1">closed=</span><span class="s4">&quot;left&quot;</span><span class="s1">)]</span><span class="s3">,</span>
        <span class="s4">&quot;copy_X&quot;</span><span class="s1">: [</span><span class="s4">&quot;boolean&quot;</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;fit_path&quot;</span><span class="s1">: [</span><span class="s4">&quot;boolean&quot;</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;jitter&quot;</span><span class="s1">: [Interval(Real</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, None, </span><span class="s1">closed=</span><span class="s4">&quot;left&quot;</span><span class="s1">)</span><span class="s3">, None</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;random_state&quot;</span><span class="s1">: [</span><span class="s4">&quot;random_state&quot;</span><span class="s1">]</span><span class="s3">,</span>
    <span class="s1">}</span>

    <span class="s1">method = </span><span class="s4">&quot;lar&quot;</span>
    <span class="s1">positive = </span><span class="s3">False</span>

    <span class="s3">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">*</span><span class="s3">,</span>
        <span class="s1">fit_intercept=</span><span class="s3">True,</span>
        <span class="s1">verbose=</span><span class="s3">False,</span>
        <span class="s1">normalize=</span><span class="s4">&quot;deprecated&quot;</span><span class="s3">,</span>
        <span class="s1">precompute=</span><span class="s4">&quot;auto&quot;</span><span class="s3">,</span>
        <span class="s1">n_nonzero_coefs=</span><span class="s5">500</span><span class="s3">,</span>
        <span class="s1">eps=np.finfo(float).eps</span><span class="s3">,</span>
        <span class="s1">copy_X=</span><span class="s3">True,</span>
        <span class="s1">fit_path=</span><span class="s3">True,</span>
        <span class="s1">jitter=</span><span class="s3">None,</span>
        <span class="s1">random_state=</span><span class="s3">None,</span>
    <span class="s1">):</span>
        <span class="s1">self.fit_intercept = fit_intercept</span>
        <span class="s1">self.verbose = verbose</span>
        <span class="s1">self.normalize = normalize</span>
        <span class="s1">self.precompute = precompute</span>
        <span class="s1">self.n_nonzero_coefs = n_nonzero_coefs</span>
        <span class="s1">self.eps = eps</span>
        <span class="s1">self.copy_X = copy_X</span>
        <span class="s1">self.fit_path = fit_path</span>
        <span class="s1">self.jitter = jitter</span>
        <span class="s1">self.random_state = random_state</span>

    <span class="s1">@staticmethod</span>
    <span class="s3">def </span><span class="s1">_get_gram(precompute</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y):</span>
        <span class="s3">if </span><span class="s1">(</span><span class="s3">not </span><span class="s1">hasattr(precompute</span><span class="s3">, </span><span class="s4">&quot;__array__&quot;</span><span class="s1">)) </span><span class="s3">and </span><span class="s1">(</span>
            <span class="s1">(precompute </span><span class="s3">is True</span><span class="s1">)</span>
            <span class="s3">or </span><span class="s1">(precompute == </span><span class="s4">&quot;auto&quot; </span><span class="s3">and </span><span class="s1">X.shape[</span><span class="s5">0</span><span class="s1">] &gt; X.shape[</span><span class="s5">1</span><span class="s1">])</span>
            <span class="s3">or </span><span class="s1">(precompute == </span><span class="s4">&quot;auto&quot; </span><span class="s3">and </span><span class="s1">y.shape[</span><span class="s5">1</span><span class="s1">] &gt; </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">):</span>
            <span class="s1">precompute = np.dot(X.T</span><span class="s3">, </span><span class="s1">X)</span>

        <span class="s3">return </span><span class="s1">precompute</span>

    <span class="s3">def </span><span class="s1">_fit(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">max_iter</span><span class="s3">, </span><span class="s1">alpha</span><span class="s3">, </span><span class="s1">fit_path</span><span class="s3">, </span><span class="s1">normalize</span><span class="s3">, </span><span class="s1">Xy=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Auxiliary method to fit the model using X, y as training data&quot;&quot;&quot;</span>
        <span class="s1">n_features = X.shape[</span><span class="s5">1</span><span class="s1">]</span>

        <span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">X_offset</span><span class="s3">, </span><span class="s1">y_offset</span><span class="s3">, </span><span class="s1">X_scale = _preprocess_data(</span>
            <span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">self.fit_intercept</span><span class="s3">, </span><span class="s1">normalize</span><span class="s3">, </span><span class="s1">self.copy_X</span>
        <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">y.ndim == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">y = y[:</span><span class="s3">, </span><span class="s1">np.newaxis]</span>

        <span class="s1">n_targets = y.shape[</span><span class="s5">1</span><span class="s1">]</span>

        <span class="s1">Gram = self._get_gram(self.precompute</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y)</span>

        <span class="s1">self.alphas_ = []</span>
        <span class="s1">self.n_iter_ = []</span>
        <span class="s1">self.coef_ = np.empty((n_targets</span><span class="s3">, </span><span class="s1">n_features)</span><span class="s3">, </span><span class="s1">dtype=X.dtype)</span>

        <span class="s3">if </span><span class="s1">fit_path:</span>
            <span class="s1">self.active_ = []</span>
            <span class="s1">self.coef_path_ = []</span>
            <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">range(n_targets):</span>
                <span class="s1">this_Xy = </span><span class="s3">None if </span><span class="s1">Xy </span><span class="s3">is None else </span><span class="s1">Xy[:</span><span class="s3">, </span><span class="s1">k]</span>
                <span class="s1">alphas</span><span class="s3">, </span><span class="s1">active</span><span class="s3">, </span><span class="s1">coef_path</span><span class="s3">, </span><span class="s1">n_iter_ = lars_path(</span>
                    <span class="s1">X</span><span class="s3">,</span>
                    <span class="s1">y[:</span><span class="s3">, </span><span class="s1">k]</span><span class="s3">,</span>
                    <span class="s1">Gram=Gram</span><span class="s3">,</span>
                    <span class="s1">Xy=this_Xy</span><span class="s3">,</span>
                    <span class="s1">copy_X=self.copy_X</span><span class="s3">,</span>
                    <span class="s1">copy_Gram=</span><span class="s3">True,</span>
                    <span class="s1">alpha_min=alpha</span><span class="s3">,</span>
                    <span class="s1">method=self.method</span><span class="s3">,</span>
                    <span class="s1">verbose=max(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">self.verbose - </span><span class="s5">1</span><span class="s1">)</span><span class="s3">,</span>
                    <span class="s1">max_iter=max_iter</span><span class="s3">,</span>
                    <span class="s1">eps=self.eps</span><span class="s3">,</span>
                    <span class="s1">return_path=</span><span class="s3">True,</span>
                    <span class="s1">return_n_iter=</span><span class="s3">True,</span>
                    <span class="s1">positive=self.positive</span><span class="s3">,</span>
                <span class="s1">)</span>
                <span class="s1">self.alphas_.append(alphas)</span>
                <span class="s1">self.active_.append(active)</span>
                <span class="s1">self.n_iter_.append(n_iter_)</span>
                <span class="s1">self.coef_path_.append(coef_path)</span>
                <span class="s1">self.coef_[k] = coef_path[:</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">]</span>

            <span class="s3">if </span><span class="s1">n_targets == </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">self.alphas_</span><span class="s3">, </span><span class="s1">self.active_</span><span class="s3">, </span><span class="s1">self.coef_path_</span><span class="s3">, </span><span class="s1">self.coef_ = [</span>
                    <span class="s1">a[</span><span class="s5">0</span><span class="s1">]</span>
                    <span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">(self.alphas_</span><span class="s3">, </span><span class="s1">self.active_</span><span class="s3">, </span><span class="s1">self.coef_path_</span><span class="s3">, </span><span class="s1">self.coef_)</span>
                <span class="s1">]</span>
                <span class="s1">self.n_iter_ = self.n_iter_[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">range(n_targets):</span>
                <span class="s1">this_Xy = </span><span class="s3">None if </span><span class="s1">Xy </span><span class="s3">is None else </span><span class="s1">Xy[:</span><span class="s3">, </span><span class="s1">k]</span>
                <span class="s1">alphas</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">self.coef_[k]</span><span class="s3">, </span><span class="s1">n_iter_ = lars_path(</span>
                    <span class="s1">X</span><span class="s3">,</span>
                    <span class="s1">y[:</span><span class="s3">, </span><span class="s1">k]</span><span class="s3">,</span>
                    <span class="s1">Gram=Gram</span><span class="s3">,</span>
                    <span class="s1">Xy=this_Xy</span><span class="s3">,</span>
                    <span class="s1">copy_X=self.copy_X</span><span class="s3">,</span>
                    <span class="s1">copy_Gram=</span><span class="s3">True,</span>
                    <span class="s1">alpha_min=alpha</span><span class="s3">,</span>
                    <span class="s1">method=self.method</span><span class="s3">,</span>
                    <span class="s1">verbose=max(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">self.verbose - </span><span class="s5">1</span><span class="s1">)</span><span class="s3">,</span>
                    <span class="s1">max_iter=max_iter</span><span class="s3">,</span>
                    <span class="s1">eps=self.eps</span><span class="s3">,</span>
                    <span class="s1">return_path=</span><span class="s3">False,</span>
                    <span class="s1">return_n_iter=</span><span class="s3">True,</span>
                    <span class="s1">positive=self.positive</span><span class="s3">,</span>
                <span class="s1">)</span>
                <span class="s1">self.alphas_.append(alphas)</span>
                <span class="s1">self.n_iter_.append(n_iter_)</span>
            <span class="s3">if </span><span class="s1">n_targets == </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">self.alphas_ = self.alphas_[</span><span class="s5">0</span><span class="s1">]</span>
                <span class="s1">self.n_iter_ = self.n_iter_[</span><span class="s5">0</span><span class="s1">]</span>

        <span class="s1">self._set_intercept(X_offset</span><span class="s3">, </span><span class="s1">y_offset</span><span class="s3">, </span><span class="s1">X_scale)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s1">@_fit_context(prefer_skip_nested_validation=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s3">def </span><span class="s1">fit(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">Xy=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Fit the model using X, y as training data. 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) 
            Training data. 
 
        y : array-like of shape (n_samples,) or (n_samples, n_targets) 
            Target values. 
 
        Xy : array-like of shape (n_features,) or (n_features, n_targets), \ 
                default=None 
            Xy = np.dot(X.T, y) that can be precomputed. It is useful 
            only when the Gram matrix is precomputed. 
 
        Returns 
        ------- 
        self : object 
            Returns an instance of self. 
        &quot;&quot;&quot;</span>
        <span class="s1">X</span><span class="s3">, </span><span class="s1">y = self._validate_data(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">y_numeric=</span><span class="s3">True, </span><span class="s1">multi_output=</span><span class="s3">True</span><span class="s1">)</span>

        <span class="s1">_normalize = _deprecate_normalize(</span>
            <span class="s1">self.normalize</span><span class="s3">, </span><span class="s1">estimator_name=self.__class__.__name__</span>
        <span class="s1">)</span>

        <span class="s1">alpha = getattr(self</span><span class="s3">, </span><span class="s4">&quot;alpha&quot;</span><span class="s3">, </span><span class="s5">0.0</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">hasattr(self</span><span class="s3">, </span><span class="s4">&quot;n_nonzero_coefs&quot;</span><span class="s1">):</span>
            <span class="s1">alpha = </span><span class="s5">0.0  </span><span class="s2"># n_nonzero_coefs parametrization takes priority</span>
            <span class="s1">max_iter = self.n_nonzero_coefs</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">max_iter = self.max_iter</span>

        <span class="s3">if </span><span class="s1">self.jitter </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">rng = check_random_state(self.random_state)</span>

            <span class="s1">noise = rng.uniform(high=self.jitter</span><span class="s3">, </span><span class="s1">size=len(y))</span>
            <span class="s1">y = y + noise</span>

        <span class="s1">self._fit(</span>
            <span class="s1">X</span><span class="s3">,</span>
            <span class="s1">y</span><span class="s3">,</span>
            <span class="s1">max_iter=max_iter</span><span class="s3">,</span>
            <span class="s1">alpha=alpha</span><span class="s3">,</span>
            <span class="s1">fit_path=self.fit_path</span><span class="s3">,</span>
            <span class="s1">normalize=_normalize</span><span class="s3">,</span>
            <span class="s1">Xy=Xy</span><span class="s3">,</span>
        <span class="s1">)</span>

        <span class="s3">return </span><span class="s1">self</span>


<span class="s3">class </span><span class="s1">LassoLars(Lars):</span>
    <span class="s0">&quot;&quot;&quot;Lasso model fit with Least Angle Regression a.k.a. Lars. 
 
    It is a Linear Model trained with an L1 prior as regularizer. 
 
    The optimization objective for Lasso is:: 
 
    (1 / (2 * n_samples)) * ||y - Xw||^2_2 + alpha * ||w||_1 
 
    Read more in the :ref:`User Guide &lt;least_angle_regression&gt;`. 
 
    Parameters 
    ---------- 
    alpha : float, default=1.0 
        Constant that multiplies the penalty term. Defaults to 1.0. 
        ``alpha = 0`` is equivalent to an ordinary least square, solved 
        by :class:`LinearRegression`. For numerical reasons, using 
        ``alpha = 0`` with the LassoLars object is not advised and you 
        should prefer the LinearRegression object. 
 
    fit_intercept : bool, default=True 
        Whether to calculate the intercept for this model. If set 
        to false, no intercept will be used in calculations 
        (i.e. data is expected to be centered). 
 
    verbose : bool or int, default=False 
        Sets the verbosity amount. 
 
    normalize : bool, default=False 
        This parameter is ignored when ``fit_intercept`` is set to False. 
        If True, the regressors X will be normalized before regression by 
        subtracting the mean and dividing by the l2-norm. 
        If you wish to standardize, please use 
        :class:`~sklearn.preprocessing.StandardScaler` before calling ``fit`` 
        on an estimator with ``normalize=False``. 
 
        .. versionchanged:: 1.2 
           default changed from True to False in 1.2. 
 
        .. deprecated:: 1.2 
            ``normalize`` was deprecated in version 1.2 and will be removed in 1.4. 
 
    precompute : bool, 'auto' or array-like, default='auto' 
        Whether to use a precomputed Gram matrix to speed up 
        calculations. If set to ``'auto'`` let us decide. The Gram 
        matrix can also be passed as argument. 
 
    max_iter : int, default=500 
        Maximum number of iterations to perform. 
 
    eps : float, default=np.finfo(float).eps 
        The machine-precision regularization in the computation of the 
        Cholesky diagonal factors. Increase this for very ill-conditioned 
        systems. Unlike the ``tol`` parameter in some iterative 
        optimization-based algorithms, this parameter does not control 
        the tolerance of the optimization. 
 
    copy_X : bool, default=True 
        If True, X will be copied; else, it may be overwritten. 
 
    fit_path : bool, default=True 
        If ``True`` the full path is stored in the ``coef_path_`` attribute. 
        If you compute the solution for a large problem or many targets, 
        setting ``fit_path`` to ``False`` will lead to a speedup, especially 
        with a small alpha. 
 
    positive : bool, default=False 
        Restrict coefficients to be &gt;= 0. Be aware that you might want to 
        remove fit_intercept which is set True by default. 
        Under the positive restriction the model coefficients will not converge 
        to the ordinary-least-squares solution for small values of alpha. 
        Only coefficients up to the smallest alpha value (``alphas_[alphas_ &gt; 
        0.].min()`` when fit_path=True) reached by the stepwise Lars-Lasso 
        algorithm are typically in congruence with the solution of the 
        coordinate descent Lasso estimator. 
 
    jitter : float, default=None 
        Upper bound on a uniform noise parameter to be added to the 
        `y` values, to satisfy the model's assumption of 
        one-at-a-time computations. Might help with stability. 
 
        .. versionadded:: 0.23 
 
    random_state : int, RandomState instance or None, default=None 
        Determines random number generation for jittering. Pass an int 
        for reproducible output across multiple function calls. 
        See :term:`Glossary &lt;random_state&gt;`. Ignored if `jitter` is None. 
 
        .. versionadded:: 0.23 
 
    Attributes 
    ---------- 
    alphas_ : array-like of shape (n_alphas + 1,) or list of such arrays 
        Maximum of covariances (in absolute value) at each iteration. 
        ``n_alphas`` is either ``max_iter``, ``n_features`` or the 
        number of nodes in the path with ``alpha &gt;= alpha_min``, whichever 
        is smaller. If this is a list of array-like, the length of the outer 
        list is `n_targets`. 
 
    active_ : list of length n_alphas or list of such lists 
        Indices of active variables at the end of the path. 
        If this is a list of list, the length of the outer list is `n_targets`. 
 
    coef_path_ : array-like of shape (n_features, n_alphas + 1) or list \ 
            of such arrays 
        If a list is passed it's expected to be one of n_targets such arrays. 
        The varying values of the coefficients along the path. It is not 
        present if the ``fit_path`` parameter is ``False``. If this is a list 
        of array-like, the length of the outer list is `n_targets`. 
 
    coef_ : array-like of shape (n_features,) or (n_targets, n_features) 
        Parameter vector (w in the formulation formula). 
 
    intercept_ : float or array-like of shape (n_targets,) 
        Independent term in decision function. 
 
    n_iter_ : array-like or int 
        The number of iterations taken by lars_path to find the 
        grid of alphas for each target. 
 
    n_features_in_ : int 
        Number of features seen during :term:`fit`. 
 
        .. versionadded:: 0.24 
 
    feature_names_in_ : ndarray of shape (`n_features_in_`,) 
        Names of features seen during :term:`fit`. Defined only when `X` 
        has feature names that are all strings. 
 
        .. versionadded:: 1.0 
 
    See Also 
    -------- 
    lars_path : Compute Least Angle Regression or Lasso 
        path using LARS algorithm. 
    lasso_path : Compute Lasso path with coordinate descent. 
    Lasso : Linear Model trained with L1 prior as 
        regularizer (aka the Lasso). 
    LassoCV : Lasso linear model with iterative fitting 
        along a regularization path. 
    LassoLarsCV: Cross-validated Lasso, using the LARS algorithm. 
    LassoLarsIC : Lasso model fit with Lars using BIC 
        or AIC for model selection. 
    sklearn.decomposition.sparse_encode : Sparse coding. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn import linear_model 
    &gt;&gt;&gt; reg = linear_model.LassoLars(alpha=0.01) 
    &gt;&gt;&gt; reg.fit([[-1, 1], [0, 0], [1, 1]], [-1, 0, -1]) 
    LassoLars(alpha=0.01) 
    &gt;&gt;&gt; print(reg.coef_) 
    [ 0.         -0.955...] 
    &quot;&quot;&quot;</span>

    <span class="s1">_parameter_constraints: dict = {</span>
        <span class="s1">**Lars._parameter_constraints</span><span class="s3">,</span>
        <span class="s4">&quot;alpha&quot;</span><span class="s1">: [Interval(Real</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, None, </span><span class="s1">closed=</span><span class="s4">&quot;left&quot;</span><span class="s1">)]</span><span class="s3">,</span>
        <span class="s4">&quot;max_iter&quot;</span><span class="s1">: [Interval(Integral</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, None, </span><span class="s1">closed=</span><span class="s4">&quot;left&quot;</span><span class="s1">)]</span><span class="s3">,</span>
        <span class="s4">&quot;positive&quot;</span><span class="s1">: [</span><span class="s4">&quot;boolean&quot;</span><span class="s1">]</span><span class="s3">,</span>
    <span class="s1">}</span>
    <span class="s1">_parameter_constraints.pop(</span><span class="s4">&quot;n_nonzero_coefs&quot;</span><span class="s1">)</span>

    <span class="s1">method = </span><span class="s4">&quot;lasso&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">alpha=</span><span class="s5">1.0</span><span class="s3">,</span>
        <span class="s1">*</span><span class="s3">,</span>
        <span class="s1">fit_intercept=</span><span class="s3">True,</span>
        <span class="s1">verbose=</span><span class="s3">False,</span>
        <span class="s1">normalize=</span><span class="s4">&quot;deprecated&quot;</span><span class="s3">,</span>
        <span class="s1">precompute=</span><span class="s4">&quot;auto&quot;</span><span class="s3">,</span>
        <span class="s1">max_iter=</span><span class="s5">500</span><span class="s3">,</span>
        <span class="s1">eps=np.finfo(float).eps</span><span class="s3">,</span>
        <span class="s1">copy_X=</span><span class="s3">True,</span>
        <span class="s1">fit_path=</span><span class="s3">True,</span>
        <span class="s1">positive=</span><span class="s3">False,</span>
        <span class="s1">jitter=</span><span class="s3">None,</span>
        <span class="s1">random_state=</span><span class="s3">None,</span>
    <span class="s1">):</span>
        <span class="s1">self.alpha = alpha</span>
        <span class="s1">self.fit_intercept = fit_intercept</span>
        <span class="s1">self.max_iter = max_iter</span>
        <span class="s1">self.verbose = verbose</span>
        <span class="s1">self.normalize = normalize</span>
        <span class="s1">self.positive = positive</span>
        <span class="s1">self.precompute = precompute</span>
        <span class="s1">self.copy_X = copy_X</span>
        <span class="s1">self.eps = eps</span>
        <span class="s1">self.fit_path = fit_path</span>
        <span class="s1">self.jitter = jitter</span>
        <span class="s1">self.random_state = random_state</span>


<span class="s2">###############################################################################</span>
<span class="s2"># Cross-validated estimator classes</span>


<span class="s3">def </span><span class="s1">_check_copy_and_writeable(array</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s3">if </span><span class="s1">copy </span><span class="s3">or not </span><span class="s1">array.flags.writeable:</span>
        <span class="s3">return </span><span class="s1">array.copy()</span>
    <span class="s3">return </span><span class="s1">array</span>


<span class="s3">def </span><span class="s1">_lars_path_residues(</span>
    <span class="s1">X_train</span><span class="s3">,</span>
    <span class="s1">y_train</span><span class="s3">,</span>
    <span class="s1">X_test</span><span class="s3">,</span>
    <span class="s1">y_test</span><span class="s3">,</span>
    <span class="s1">Gram=</span><span class="s3">None,</span>
    <span class="s1">copy=</span><span class="s3">True,</span>
    <span class="s1">method=</span><span class="s4">&quot;lars&quot;</span><span class="s3">,</span>
    <span class="s1">verbose=</span><span class="s3">False,</span>
    <span class="s1">fit_intercept=</span><span class="s3">True,</span>
    <span class="s1">normalize=</span><span class="s3">False,</span>
    <span class="s1">max_iter=</span><span class="s5">500</span><span class="s3">,</span>
    <span class="s1">eps=np.finfo(float).eps</span><span class="s3">,</span>
    <span class="s1">positive=</span><span class="s3">False,</span>
<span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Compute the residues on left-out data for a full LARS path 
 
    Parameters 
    ----------- 
    X_train : array-like of shape (n_samples, n_features) 
        The data to fit the LARS on 
 
    y_train : array-like of shape (n_samples,) 
        The target variable to fit LARS on 
 
    X_test : array-like of shape (n_samples, n_features) 
        The data to compute the residues on 
 
    y_test : array-like of shape (n_samples,) 
        The target variable to compute the residues on 
 
    Gram : None, 'auto' or array-like of shape (n_features, n_features), \ 
            default=None 
        Precomputed Gram matrix (X' * X), if ``'auto'``, the Gram 
        matrix is precomputed from the given X, if there are more samples 
        than features 
 
    copy : bool, default=True 
        Whether X_train, X_test, y_train and y_test should be copied; 
        if False, they may be overwritten. 
 
    method : {'lar' , 'lasso'}, default='lar' 
        Specifies the returned model. Select ``'lar'`` for Least Angle 
        Regression, ``'lasso'`` for the Lasso. 
 
    verbose : bool or int, default=False 
        Sets the amount of verbosity 
 
    fit_intercept : bool, default=True 
        whether to calculate the intercept for this model. If set 
        to false, no intercept will be used in calculations 
        (i.e. data is expected to be centered). 
 
    positive : bool, default=False 
        Restrict coefficients to be &gt;= 0. Be aware that you might want to 
        remove fit_intercept which is set True by default. 
        See reservations for using this option in combination with method 
        'lasso' for expected small values of alpha in the doc of LassoLarsCV 
        and LassoLarsIC. 
 
    normalize : bool, default=False 
        This parameter is ignored when ``fit_intercept`` is set to False. 
        If True, the regressors X will be normalized before regression by 
        subtracting the mean and dividing by the l2-norm. 
        If you wish to standardize, please use 
        :class:`~sklearn.preprocessing.StandardScaler` before calling ``fit`` 
        on an estimator with ``normalize=False``. 
 
        .. versionchanged:: 1.2 
           default changed from True to False in 1.2. 
 
        .. deprecated:: 1.2 
            ``normalize`` was deprecated in version 1.2 and will be removed in 1.4. 
 
    max_iter : int, default=500 
        Maximum number of iterations to perform. 
 
    eps : float, default=np.finfo(float).eps 
        The machine-precision regularization in the computation of the 
        Cholesky diagonal factors. Increase this for very ill-conditioned 
        systems. Unlike the ``tol`` parameter in some iterative 
        optimization-based algorithms, this parameter does not control 
        the tolerance of the optimization. 
 
    Returns 
    -------- 
    alphas : array-like of shape (n_alphas,) 
        Maximum of covariances (in absolute value) at each iteration. 
        ``n_alphas`` is either ``max_iter`` or ``n_features``, whichever 
        is smaller. 
 
    active : list 
        Indices of active variables at the end of the path. 
 
    coefs : array-like of shape (n_features, n_alphas) 
        Coefficients along the path 
 
    residues : array-like of shape (n_alphas, n_samples) 
        Residues of the prediction on the test data 
    &quot;&quot;&quot;</span>
    <span class="s1">X_train = _check_copy_and_writeable(X_train</span><span class="s3">, </span><span class="s1">copy)</span>
    <span class="s1">y_train = _check_copy_and_writeable(y_train</span><span class="s3">, </span><span class="s1">copy)</span>
    <span class="s1">X_test = _check_copy_and_writeable(X_test</span><span class="s3">, </span><span class="s1">copy)</span>
    <span class="s1">y_test = _check_copy_and_writeable(y_test</span><span class="s3">, </span><span class="s1">copy)</span>

    <span class="s3">if </span><span class="s1">fit_intercept:</span>
        <span class="s1">X_mean = X_train.mean(axis=</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">X_train -= X_mean</span>
        <span class="s1">X_test -= X_mean</span>
        <span class="s1">y_mean = y_train.mean(axis=</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">y_train = as_float_array(y_train</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">)</span>
        <span class="s1">y_train -= y_mean</span>
        <span class="s1">y_test = as_float_array(y_test</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">)</span>
        <span class="s1">y_test -= y_mean</span>

    <span class="s3">if </span><span class="s1">normalize:</span>
        <span class="s1">norms = np.sqrt(np.sum(X_train**</span><span class="s5">2</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">))</span>
        <span class="s1">nonzeros = np.flatnonzero(norms)</span>
        <span class="s1">X_train[:</span><span class="s3">, </span><span class="s1">nonzeros] /= norms[nonzeros]</span>

    <span class="s1">alphas</span><span class="s3">, </span><span class="s1">active</span><span class="s3">, </span><span class="s1">coefs = lars_path(</span>
        <span class="s1">X_train</span><span class="s3">,</span>
        <span class="s1">y_train</span><span class="s3">,</span>
        <span class="s1">Gram=Gram</span><span class="s3">,</span>
        <span class="s1">copy_X=</span><span class="s3">False,</span>
        <span class="s1">copy_Gram=</span><span class="s3">False,</span>
        <span class="s1">method=method</span><span class="s3">,</span>
        <span class="s1">verbose=max(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">verbose - </span><span class="s5">1</span><span class="s1">)</span><span class="s3">,</span>
        <span class="s1">max_iter=max_iter</span><span class="s3">,</span>
        <span class="s1">eps=eps</span><span class="s3">,</span>
        <span class="s1">positive=positive</span><span class="s3">,</span>
    <span class="s1">)</span>
    <span class="s3">if </span><span class="s1">normalize:</span>
        <span class="s1">coefs[nonzeros] /= norms[nonzeros][:</span><span class="s3">, </span><span class="s1">np.newaxis]</span>
    <span class="s1">residues = np.dot(X_test</span><span class="s3">, </span><span class="s1">coefs) - y_test[:</span><span class="s3">, </span><span class="s1">np.newaxis]</span>
    <span class="s3">return </span><span class="s1">alphas</span><span class="s3">, </span><span class="s1">active</span><span class="s3">, </span><span class="s1">coefs</span><span class="s3">, </span><span class="s1">residues.T</span>


<span class="s3">class </span><span class="s1">LarsCV(Lars):</span>
    <span class="s0">&quot;&quot;&quot;Cross-validated Least Angle Regression model. 
 
    See glossary entry for :term:`cross-validation estimator`. 
 
    Read more in the :ref:`User Guide &lt;least_angle_regression&gt;`. 
 
    Parameters 
    ---------- 
    fit_intercept : bool, default=True 
        Whether to calculate the intercept for this model. If set 
        to false, no intercept will be used in calculations 
        (i.e. data is expected to be centered). 
 
    verbose : bool or int, default=False 
        Sets the verbosity amount. 
 
    max_iter : int, default=500 
        Maximum number of iterations to perform. 
 
    normalize : bool, default=False 
        This parameter is ignored when ``fit_intercept`` is set to False. 
        If True, the regressors X will be normalized before regression by 
        subtracting the mean and dividing by the l2-norm. 
        If you wish to standardize, please use 
        :class:`~sklearn.preprocessing.StandardScaler` before calling ``fit`` 
        on an estimator with ``normalize=False``. 
 
        .. versionchanged:: 1.2 
           default changed from True to False in 1.2. 
 
        .. deprecated:: 1.2 
            ``normalize`` was deprecated in version 1.2 and will be removed in 1.4. 
 
    precompute : bool, 'auto' or array-like , default='auto' 
        Whether to use a precomputed Gram matrix to speed up 
        calculations. If set to ``'auto'`` let us decide. The Gram matrix 
        cannot be passed as argument since we will use only subsets of X. 
 
    cv : int, cross-validation generator or an iterable, default=None 
        Determines the cross-validation splitting strategy. 
        Possible inputs for cv are: 
 
        - None, to use the default 5-fold cross-validation, 
        - integer, to specify the number of folds. 
        - :term:`CV splitter`, 
        - An iterable yielding (train, test) splits as arrays of indices. 
 
        For integer/None inputs, :class:`~sklearn.model_selection.KFold` is used. 
 
        Refer :ref:`User Guide &lt;cross_validation&gt;` for the various 
        cross-validation strategies that can be used here. 
 
        .. versionchanged:: 0.22 
            ``cv`` default value if None changed from 3-fold to 5-fold. 
 
    max_n_alphas : int, default=1000 
        The maximum number of points on the path used to compute the 
        residuals in the cross-validation. 
 
    n_jobs : int or None, default=None 
        Number of CPUs to use during the cross validation. 
        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context. 
        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;` 
        for more details. 
 
    eps : float, default=np.finfo(float).eps 
        The machine-precision regularization in the computation of the 
        Cholesky diagonal factors. Increase this for very ill-conditioned 
        systems. Unlike the ``tol`` parameter in some iterative 
        optimization-based algorithms, this parameter does not control 
        the tolerance of the optimization. 
 
    copy_X : bool, default=True 
        If ``True``, X will be copied; else, it may be overwritten. 
 
    Attributes 
    ---------- 
    active_ : list of length n_alphas or list of such lists 
        Indices of active variables at the end of the path. 
        If this is a list of lists, the outer list length is `n_targets`. 
 
    coef_ : array-like of shape (n_features,) 
        parameter vector (w in the formulation formula) 
 
    intercept_ : float 
        independent term in decision function 
 
    coef_path_ : array-like of shape (n_features, n_alphas) 
        the varying values of the coefficients along the path 
 
    alpha_ : float 
        the estimated regularization parameter alpha 
 
    alphas_ : array-like of shape (n_alphas,) 
        the different values of alpha along the path 
 
    cv_alphas_ : array-like of shape (n_cv_alphas,) 
        all the values of alpha along the path for the different folds 
 
    mse_path_ : array-like of shape (n_folds, n_cv_alphas) 
        the mean square error on left-out for each fold along the path 
        (alpha values given by ``cv_alphas``) 
 
    n_iter_ : array-like or int 
        the number of iterations run by Lars with the optimal alpha. 
 
    n_features_in_ : int 
        Number of features seen during :term:`fit`. 
 
        .. versionadded:: 0.24 
 
    feature_names_in_ : ndarray of shape (`n_features_in_`,) 
        Names of features seen during :term:`fit`. Defined only when `X` 
        has feature names that are all strings. 
 
        .. versionadded:: 1.0 
 
    See Also 
    -------- 
    lars_path : Compute Least Angle Regression or Lasso 
        path using LARS algorithm. 
    lasso_path : Compute Lasso path with coordinate descent. 
    Lasso : Linear Model trained with L1 prior as 
        regularizer (aka the Lasso). 
    LassoCV : Lasso linear model with iterative fitting 
        along a regularization path. 
    LassoLars : Lasso model fit with Least Angle Regression a.k.a. Lars. 
    LassoLarsIC : Lasso model fit with Lars using BIC 
        or AIC for model selection. 
    sklearn.decomposition.sparse_encode : Sparse coding. 
 
    Notes 
    ----- 
    In `fit`, once the best parameter `alpha` is found through 
    cross-validation, the model is fit again using the entire training set. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.linear_model import LarsCV 
    &gt;&gt;&gt; from sklearn.datasets import make_regression 
    &gt;&gt;&gt; X, y = make_regression(n_samples=200, noise=4.0, random_state=0) 
    &gt;&gt;&gt; reg = LarsCV(cv=5).fit(X, y) 
    &gt;&gt;&gt; reg.score(X, y) 
    0.9996... 
    &gt;&gt;&gt; reg.alpha_ 
    0.2961... 
    &gt;&gt;&gt; reg.predict(X[:1,]) 
    array([154.3996...]) 
    &quot;&quot;&quot;</span>

    <span class="s1">_parameter_constraints: dict = {</span>
        <span class="s1">**Lars._parameter_constraints</span><span class="s3">,</span>
        <span class="s4">&quot;max_iter&quot;</span><span class="s1">: [Interval(Integral</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, None, </span><span class="s1">closed=</span><span class="s4">&quot;left&quot;</span><span class="s1">)]</span><span class="s3">,</span>
        <span class="s4">&quot;cv&quot;</span><span class="s1">: [</span><span class="s4">&quot;cv_object&quot;</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;max_n_alphas&quot;</span><span class="s1">: [Interval(Integral</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, None, </span><span class="s1">closed=</span><span class="s4">&quot;left&quot;</span><span class="s1">)]</span><span class="s3">,</span>
        <span class="s4">&quot;n_jobs&quot;</span><span class="s1">: [Integral</span><span class="s3">, None</span><span class="s1">]</span><span class="s3">,</span>
    <span class="s1">}</span>

    <span class="s3">for </span><span class="s1">parameter </span><span class="s3">in </span><span class="s1">[</span><span class="s4">&quot;n_nonzero_coefs&quot;</span><span class="s3">, </span><span class="s4">&quot;jitter&quot;</span><span class="s3">, </span><span class="s4">&quot;fit_path&quot;</span><span class="s3">, </span><span class="s4">&quot;random_state&quot;</span><span class="s1">]:</span>
        <span class="s1">_parameter_constraints.pop(parameter)</span>

    <span class="s1">method = </span><span class="s4">&quot;lar&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">*</span><span class="s3">,</span>
        <span class="s1">fit_intercept=</span><span class="s3">True,</span>
        <span class="s1">verbose=</span><span class="s3">False,</span>
        <span class="s1">max_iter=</span><span class="s5">500</span><span class="s3">,</span>
        <span class="s1">normalize=</span><span class="s4">&quot;deprecated&quot;</span><span class="s3">,</span>
        <span class="s1">precompute=</span><span class="s4">&quot;auto&quot;</span><span class="s3">,</span>
        <span class="s1">cv=</span><span class="s3">None,</span>
        <span class="s1">max_n_alphas=</span><span class="s5">1000</span><span class="s3">,</span>
        <span class="s1">n_jobs=</span><span class="s3">None,</span>
        <span class="s1">eps=np.finfo(float).eps</span><span class="s3">,</span>
        <span class="s1">copy_X=</span><span class="s3">True,</span>
    <span class="s1">):</span>
        <span class="s1">self.max_iter = max_iter</span>
        <span class="s1">self.cv = cv</span>
        <span class="s1">self.max_n_alphas = max_n_alphas</span>
        <span class="s1">self.n_jobs = n_jobs</span>
        <span class="s1">super().__init__(</span>
            <span class="s1">fit_intercept=fit_intercept</span><span class="s3">,</span>
            <span class="s1">verbose=verbose</span><span class="s3">,</span>
            <span class="s1">normalize=normalize</span><span class="s3">,</span>
            <span class="s1">precompute=precompute</span><span class="s3">,</span>
            <span class="s1">n_nonzero_coefs=</span><span class="s5">500</span><span class="s3">,</span>
            <span class="s1">eps=eps</span><span class="s3">,</span>
            <span class="s1">copy_X=copy_X</span><span class="s3">,</span>
            <span class="s1">fit_path=</span><span class="s3">True,</span>
        <span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_more_tags(self):</span>
        <span class="s3">return </span><span class="s1">{</span><span class="s4">&quot;multioutput&quot;</span><span class="s1">: </span><span class="s3">False</span><span class="s1">}</span>

    <span class="s1">@_fit_context(prefer_skip_nested_validation=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s3">def </span><span class="s1">fit(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y):</span>
        <span class="s0">&quot;&quot;&quot;Fit the model using X, y as training data. 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) 
            Training data. 
 
        y : array-like of shape (n_samples,) 
            Target values. 
 
        Returns 
        ------- 
        self : object 
            Returns an instance of self. 
        &quot;&quot;&quot;</span>
        <span class="s1">_normalize = _deprecate_normalize(</span>
            <span class="s1">self.normalize</span><span class="s3">, </span><span class="s1">estimator_name=self.__class__.__name__</span>
        <span class="s1">)</span>

        <span class="s1">X</span><span class="s3">, </span><span class="s1">y = self._validate_data(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">y_numeric=</span><span class="s3">True</span><span class="s1">)</span>
        <span class="s1">X = as_float_array(X</span><span class="s3">, </span><span class="s1">copy=self.copy_X)</span>
        <span class="s1">y = as_float_array(y</span><span class="s3">, </span><span class="s1">copy=self.copy_X)</span>

        <span class="s2"># init cross-validation generator</span>
        <span class="s1">cv = check_cv(self.cv</span><span class="s3">, </span><span class="s1">classifier=</span><span class="s3">False</span><span class="s1">)</span>

        <span class="s2"># As we use cross-validation, the Gram matrix is not precomputed here</span>
        <span class="s1">Gram = self.precompute</span>
        <span class="s3">if </span><span class="s1">hasattr(Gram</span><span class="s3">, </span><span class="s4">&quot;__array__&quot;</span><span class="s1">):</span>
            <span class="s1">warnings.warn(</span>
                <span class="s4">'Parameter &quot;precompute&quot; cannot be an array in '</span>
                <span class="s4">'%s. Automatically switch to &quot;auto&quot; instead.'</span>
                <span class="s1">% self.__class__.__name__</span>
            <span class="s1">)</span>
            <span class="s1">Gram = </span><span class="s4">&quot;auto&quot;</span>

        <span class="s1">cv_paths = Parallel(n_jobs=self.n_jobs</span><span class="s3">, </span><span class="s1">verbose=self.verbose)(</span>
            <span class="s1">delayed(_lars_path_residues)(</span>
                <span class="s1">X[train]</span><span class="s3">,</span>
                <span class="s1">y[train]</span><span class="s3">,</span>
                <span class="s1">X[test]</span><span class="s3">,</span>
                <span class="s1">y[test]</span><span class="s3">,</span>
                <span class="s1">Gram=Gram</span><span class="s3">,</span>
                <span class="s1">copy=</span><span class="s3">False,</span>
                <span class="s1">method=self.method</span><span class="s3">,</span>
                <span class="s1">verbose=max(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">self.verbose - </span><span class="s5">1</span><span class="s1">)</span><span class="s3">,</span>
                <span class="s1">normalize=_normalize</span><span class="s3">,</span>
                <span class="s1">fit_intercept=self.fit_intercept</span><span class="s3">,</span>
                <span class="s1">max_iter=self.max_iter</span><span class="s3">,</span>
                <span class="s1">eps=self.eps</span><span class="s3">,</span>
                <span class="s1">positive=self.positive</span><span class="s3">,</span>
            <span class="s1">)</span>
            <span class="s3">for </span><span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">in </span><span class="s1">cv.split(X</span><span class="s3">, </span><span class="s1">y)</span>
        <span class="s1">)</span>
        <span class="s1">all_alphas = np.concatenate(list(zip(*cv_paths))[</span><span class="s5">0</span><span class="s1">])</span>
        <span class="s2"># Unique also sorts</span>
        <span class="s1">all_alphas = np.unique(all_alphas)</span>
        <span class="s2"># Take at most max_n_alphas values</span>
        <span class="s1">stride = int(max(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">int(len(all_alphas) / float(self.max_n_alphas))))</span>
        <span class="s1">all_alphas = all_alphas[::stride]</span>

        <span class="s1">mse_path = np.empty((len(all_alphas)</span><span class="s3">, </span><span class="s1">len(cv_paths)))</span>
        <span class="s3">for </span><span class="s1">index</span><span class="s3">, </span><span class="s1">(alphas</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">residues) </span><span class="s3">in </span><span class="s1">enumerate(cv_paths):</span>
            <span class="s1">alphas = alphas[::-</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s1">residues = residues[::-</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s3">if </span><span class="s1">alphas[</span><span class="s5">0</span><span class="s1">] != </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">alphas = np.r_[</span><span class="s5">0</span><span class="s3">, </span><span class="s1">alphas]</span>
                <span class="s1">residues = np.r_[residues[</span><span class="s5">0</span><span class="s3">, </span><span class="s1">np.newaxis]</span><span class="s3">, </span><span class="s1">residues]</span>
            <span class="s3">if </span><span class="s1">alphas[-</span><span class="s5">1</span><span class="s1">] != all_alphas[-</span><span class="s5">1</span><span class="s1">]:</span>
                <span class="s1">alphas = np.r_[alphas</span><span class="s3">, </span><span class="s1">all_alphas[-</span><span class="s5">1</span><span class="s1">]]</span>
                <span class="s1">residues = np.r_[residues</span><span class="s3">, </span><span class="s1">residues[-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">np.newaxis]]</span>
            <span class="s1">this_residues = interpolate.interp1d(alphas</span><span class="s3">, </span><span class="s1">residues</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">)(all_alphas)</span>
            <span class="s1">this_residues **= </span><span class="s5">2</span>
            <span class="s1">mse_path[:</span><span class="s3">, </span><span class="s1">index] = np.mean(this_residues</span><span class="s3">, </span><span class="s1">axis=-</span><span class="s5">1</span><span class="s1">)</span>

        <span class="s1">mask = np.all(np.isfinite(mse_path)</span><span class="s3">, </span><span class="s1">axis=-</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">all_alphas = all_alphas[mask]</span>
        <span class="s1">mse_path = mse_path[mask]</span>
        <span class="s2"># Select the alpha that minimizes left-out error</span>
        <span class="s1">i_best_alpha = np.argmin(mse_path.mean(axis=-</span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">best_alpha = all_alphas[i_best_alpha]</span>

        <span class="s2"># Store our parameters</span>
        <span class="s1">self.alpha_ = best_alpha</span>
        <span class="s1">self.cv_alphas_ = all_alphas</span>
        <span class="s1">self.mse_path_ = mse_path</span>

        <span class="s2"># Now compute the full model using best_alpha</span>
        <span class="s2"># it will call a lasso internally when self if LassoLarsCV</span>
        <span class="s2"># as self.method == 'lasso'</span>
        <span class="s1">self._fit(</span>
            <span class="s1">X</span><span class="s3">,</span>
            <span class="s1">y</span><span class="s3">,</span>
            <span class="s1">max_iter=self.max_iter</span><span class="s3">,</span>
            <span class="s1">alpha=best_alpha</span><span class="s3">,</span>
            <span class="s1">Xy=</span><span class="s3">None,</span>
            <span class="s1">fit_path=</span><span class="s3">True,</span>
            <span class="s1">normalize=_normalize</span><span class="s3">,</span>
        <span class="s1">)</span>
        <span class="s3">return </span><span class="s1">self</span>


<span class="s3">class </span><span class="s1">LassoLarsCV(LarsCV):</span>
    <span class="s0">&quot;&quot;&quot;Cross-validated Lasso, using the LARS algorithm. 
 
    See glossary entry for :term:`cross-validation estimator`. 
 
    The optimization objective for Lasso is:: 
 
    (1 / (2 * n_samples)) * ||y - Xw||^2_2 + alpha * ||w||_1 
 
    Read more in the :ref:`User Guide &lt;least_angle_regression&gt;`. 
 
    Parameters 
    ---------- 
    fit_intercept : bool, default=True 
        Whether to calculate the intercept for this model. If set 
        to false, no intercept will be used in calculations 
        (i.e. data is expected to be centered). 
 
    verbose : bool or int, default=False 
        Sets the verbosity amount. 
 
    max_iter : int, default=500 
        Maximum number of iterations to perform. 
 
    normalize : bool, default=False 
        This parameter is ignored when ``fit_intercept`` is set to False. 
        If True, the regressors X will be normalized before regression by 
        subtracting the mean and dividing by the l2-norm. 
        If you wish to standardize, please use 
        :class:`~sklearn.preprocessing.StandardScaler` before calling ``fit`` 
        on an estimator with ``normalize=False``. 
 
        .. versionchanged:: 1.2 
           default changed from True to False in 1.2. 
 
        .. deprecated:: 1.2 
            ``normalize`` was deprecated in version 1.2 and will be removed in 1.4. 
 
    precompute : bool or 'auto' , default='auto' 
        Whether to use a precomputed Gram matrix to speed up 
        calculations. If set to ``'auto'`` let us decide. The Gram matrix 
        cannot be passed as argument since we will use only subsets of X. 
 
    cv : int, cross-validation generator or an iterable, default=None 
        Determines the cross-validation splitting strategy. 
        Possible inputs for cv are: 
 
        - None, to use the default 5-fold cross-validation, 
        - integer, to specify the number of folds. 
        - :term:`CV splitter`, 
        - An iterable yielding (train, test) splits as arrays of indices. 
 
        For integer/None inputs, :class:`~sklearn.model_selection.KFold` is used. 
 
        Refer :ref:`User Guide &lt;cross_validation&gt;` for the various 
        cross-validation strategies that can be used here. 
 
        .. versionchanged:: 0.22 
            ``cv`` default value if None changed from 3-fold to 5-fold. 
 
    max_n_alphas : int, default=1000 
        The maximum number of points on the path used to compute the 
        residuals in the cross-validation. 
 
    n_jobs : int or None, default=None 
        Number of CPUs to use during the cross validation. 
        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context. 
        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;` 
        for more details. 
 
    eps : float, default=np.finfo(float).eps 
        The machine-precision regularization in the computation of the 
        Cholesky diagonal factors. Increase this for very ill-conditioned 
        systems. Unlike the ``tol`` parameter in some iterative 
        optimization-based algorithms, this parameter does not control 
        the tolerance of the optimization. 
 
    copy_X : bool, default=True 
        If True, X will be copied; else, it may be overwritten. 
 
    positive : bool, default=False 
        Restrict coefficients to be &gt;= 0. Be aware that you might want to 
        remove fit_intercept which is set True by default. 
        Under the positive restriction the model coefficients do not converge 
        to the ordinary-least-squares solution for small values of alpha. 
        Only coefficients up to the smallest alpha value (``alphas_[alphas_ &gt; 
        0.].min()`` when fit_path=True) reached by the stepwise Lars-Lasso 
        algorithm are typically in congruence with the solution of the 
        coordinate descent Lasso estimator. 
        As a consequence using LassoLarsCV only makes sense for problems where 
        a sparse solution is expected and/or reached. 
 
    Attributes 
    ---------- 
    coef_ : array-like of shape (n_features,) 
        parameter vector (w in the formulation formula) 
 
    intercept_ : float 
        independent term in decision function. 
 
    coef_path_ : array-like of shape (n_features, n_alphas) 
        the varying values of the coefficients along the path 
 
    alpha_ : float 
        the estimated regularization parameter alpha 
 
    alphas_ : array-like of shape (n_alphas,) 
        the different values of alpha along the path 
 
    cv_alphas_ : array-like of shape (n_cv_alphas,) 
        all the values of alpha along the path for the different folds 
 
    mse_path_ : array-like of shape (n_folds, n_cv_alphas) 
        the mean square error on left-out for each fold along the path 
        (alpha values given by ``cv_alphas``) 
 
    n_iter_ : array-like or int 
        the number of iterations run by Lars with the optimal alpha. 
 
    active_ : list of int 
        Indices of active variables at the end of the path. 
 
    n_features_in_ : int 
        Number of features seen during :term:`fit`. 
 
        .. versionadded:: 0.24 
 
    feature_names_in_ : ndarray of shape (`n_features_in_`,) 
        Names of features seen during :term:`fit`. Defined only when `X` 
        has feature names that are all strings. 
 
        .. versionadded:: 1.0 
 
    See Also 
    -------- 
    lars_path : Compute Least Angle Regression or Lasso 
        path using LARS algorithm. 
    lasso_path : Compute Lasso path with coordinate descent. 
    Lasso : Linear Model trained with L1 prior as 
        regularizer (aka the Lasso). 
    LassoCV : Lasso linear model with iterative fitting 
        along a regularization path. 
    LassoLars : Lasso model fit with Least Angle Regression a.k.a. Lars. 
    LassoLarsIC : Lasso model fit with Lars using BIC 
        or AIC for model selection. 
    sklearn.decomposition.sparse_encode : Sparse coding. 
 
    Notes 
    ----- 
    The object solves the same problem as the 
    :class:`~sklearn.linear_model.LassoCV` object. However, unlike the 
    :class:`~sklearn.linear_model.LassoCV`, it find the relevant alphas values 
    by itself. In general, because of this property, it will be more stable. 
    However, it is more fragile to heavily multicollinear datasets. 
 
    It is more efficient than the :class:`~sklearn.linear_model.LassoCV` if 
    only a small number of features are selected compared to the total number, 
    for instance if there are very few samples compared to the number of 
    features. 
 
    In `fit`, once the best parameter `alpha` is found through 
    cross-validation, the model is fit again using the entire training set. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.linear_model import LassoLarsCV 
    &gt;&gt;&gt; from sklearn.datasets import make_regression 
    &gt;&gt;&gt; X, y = make_regression(noise=4.0, random_state=0) 
    &gt;&gt;&gt; reg = LassoLarsCV(cv=5).fit(X, y) 
    &gt;&gt;&gt; reg.score(X, y) 
    0.9993... 
    &gt;&gt;&gt; reg.alpha_ 
    0.3972... 
    &gt;&gt;&gt; reg.predict(X[:1,]) 
    array([-78.4831...]) 
    &quot;&quot;&quot;</span>

    <span class="s1">_parameter_constraints = {</span>
        <span class="s1">**LarsCV._parameter_constraints</span><span class="s3">,</span>
        <span class="s4">&quot;positive&quot;</span><span class="s1">: [</span><span class="s4">&quot;boolean&quot;</span><span class="s1">]</span><span class="s3">,</span>
    <span class="s1">}</span>

    <span class="s1">method = </span><span class="s4">&quot;lasso&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">*</span><span class="s3">,</span>
        <span class="s1">fit_intercept=</span><span class="s3">True,</span>
        <span class="s1">verbose=</span><span class="s3">False,</span>
        <span class="s1">max_iter=</span><span class="s5">500</span><span class="s3">,</span>
        <span class="s1">normalize=</span><span class="s4">&quot;deprecated&quot;</span><span class="s3">,</span>
        <span class="s1">precompute=</span><span class="s4">&quot;auto&quot;</span><span class="s3">,</span>
        <span class="s1">cv=</span><span class="s3">None,</span>
        <span class="s1">max_n_alphas=</span><span class="s5">1000</span><span class="s3">,</span>
        <span class="s1">n_jobs=</span><span class="s3">None,</span>
        <span class="s1">eps=np.finfo(float).eps</span><span class="s3">,</span>
        <span class="s1">copy_X=</span><span class="s3">True,</span>
        <span class="s1">positive=</span><span class="s3">False,</span>
    <span class="s1">):</span>
        <span class="s1">self.fit_intercept = fit_intercept</span>
        <span class="s1">self.verbose = verbose</span>
        <span class="s1">self.max_iter = max_iter</span>
        <span class="s1">self.normalize = normalize</span>
        <span class="s1">self.precompute = precompute</span>
        <span class="s1">self.cv = cv</span>
        <span class="s1">self.max_n_alphas = max_n_alphas</span>
        <span class="s1">self.n_jobs = n_jobs</span>
        <span class="s1">self.eps = eps</span>
        <span class="s1">self.copy_X = copy_X</span>
        <span class="s1">self.positive = positive</span>
        <span class="s2"># XXX : we don't use super().__init__</span>
        <span class="s2"># to avoid setting n_nonzero_coefs</span>


<span class="s3">class </span><span class="s1">LassoLarsIC(LassoLars):</span>
    <span class="s0">&quot;&quot;&quot;Lasso model fit with Lars using BIC or AIC for model selection. 
 
    The optimization objective for Lasso is:: 
 
    (1 / (2 * n_samples)) * ||y - Xw||^2_2 + alpha * ||w||_1 
 
    AIC is the Akaike information criterion [2]_ and BIC is the Bayes 
    Information criterion [3]_. Such criteria are useful to select the value 
    of the regularization parameter by making a trade-off between the 
    goodness of fit and the complexity of the model. A good model should 
    explain well the data while being simple. 
 
    Read more in the :ref:`User Guide &lt;lasso_lars_ic&gt;`. 
 
    Parameters 
    ---------- 
    criterion : {'aic', 'bic'}, default='aic' 
        The type of criterion to use. 
 
    fit_intercept : bool, default=True 
        Whether to calculate the intercept for this model. If set 
        to false, no intercept will be used in calculations 
        (i.e. data is expected to be centered). 
 
    verbose : bool or int, default=False 
        Sets the verbosity amount. 
 
    normalize : bool, default=False 
        This parameter is ignored when ``fit_intercept`` is set to False. 
        If True, the regressors X will be normalized before regression by 
        subtracting the mean and dividing by the l2-norm. 
        If you wish to standardize, please use 
        :class:`~sklearn.preprocessing.StandardScaler` before calling ``fit`` 
        on an estimator with ``normalize=False``. 
 
        .. versionchanged:: 1.2 
           default changed from True to False in 1.2. 
 
        .. deprecated:: 1.2 
            ``normalize`` was deprecated in version 1.2 and will be removed in 1.4. 
 
    precompute : bool, 'auto' or array-like, default='auto' 
        Whether to use a precomputed Gram matrix to speed up 
        calculations. If set to ``'auto'`` let us decide. The Gram 
        matrix can also be passed as argument. 
 
    max_iter : int, default=500 
        Maximum number of iterations to perform. Can be used for 
        early stopping. 
 
    eps : float, default=np.finfo(float).eps 
        The machine-precision regularization in the computation of the 
        Cholesky diagonal factors. Increase this for very ill-conditioned 
        systems. Unlike the ``tol`` parameter in some iterative 
        optimization-based algorithms, this parameter does not control 
        the tolerance of the optimization. 
 
    copy_X : bool, default=True 
        If True, X will be copied; else, it may be overwritten. 
 
    positive : bool, default=False 
        Restrict coefficients to be &gt;= 0. Be aware that you might want to 
        remove fit_intercept which is set True by default. 
        Under the positive restriction the model coefficients do not converge 
        to the ordinary-least-squares solution for small values of alpha. 
        Only coefficients up to the smallest alpha value (``alphas_[alphas_ &gt; 
        0.].min()`` when fit_path=True) reached by the stepwise Lars-Lasso 
        algorithm are typically in congruence with the solution of the 
        coordinate descent Lasso estimator. 
        As a consequence using LassoLarsIC only makes sense for problems where 
        a sparse solution is expected and/or reached. 
 
    noise_variance : float, default=None 
        The estimated noise variance of the data. If `None`, an unbiased 
        estimate is computed by an OLS model. However, it is only possible 
        in the case where `n_samples &gt; n_features + fit_intercept`. 
 
        .. versionadded:: 1.1 
 
    Attributes 
    ---------- 
    coef_ : array-like of shape (n_features,) 
        parameter vector (w in the formulation formula) 
 
    intercept_ : float 
        independent term in decision function. 
 
    alpha_ : float 
        the alpha parameter chosen by the information criterion 
 
    alphas_ : array-like of shape (n_alphas + 1,) or list of such arrays 
        Maximum of covariances (in absolute value) at each iteration. 
        ``n_alphas`` is either ``max_iter``, ``n_features`` or the 
        number of nodes in the path with ``alpha &gt;= alpha_min``, whichever 
        is smaller. If a list, it will be of length `n_targets`. 
 
    n_iter_ : int 
        number of iterations run by lars_path to find the grid of 
        alphas. 
 
    criterion_ : array-like of shape (n_alphas,) 
        The value of the information criteria ('aic', 'bic') across all 
        alphas. The alpha which has the smallest information criterion is 
        chosen, as specified in [1]_. 
 
    noise_variance_ : float 
        The estimated noise variance from the data used to compute the 
        criterion. 
 
        .. versionadded:: 1.1 
 
    n_features_in_ : int 
        Number of features seen during :term:`fit`. 
 
        .. versionadded:: 0.24 
 
    feature_names_in_ : ndarray of shape (`n_features_in_`,) 
        Names of features seen during :term:`fit`. Defined only when `X` 
        has feature names that are all strings. 
 
        .. versionadded:: 1.0 
 
    See Also 
    -------- 
    lars_path : Compute Least Angle Regression or Lasso 
        path using LARS algorithm. 
    lasso_path : Compute Lasso path with coordinate descent. 
    Lasso : Linear Model trained with L1 prior as 
        regularizer (aka the Lasso). 
    LassoCV : Lasso linear model with iterative fitting 
        along a regularization path. 
    LassoLars : Lasso model fit with Least Angle Regression a.k.a. Lars. 
    LassoLarsCV: Cross-validated Lasso, using the LARS algorithm. 
    sklearn.decomposition.sparse_encode : Sparse coding. 
 
    Notes 
    ----- 
    The number of degrees of freedom is computed as in [1]_. 
 
    To have more details regarding the mathematical formulation of the 
    AIC and BIC criteria, please refer to :ref:`User Guide &lt;lasso_lars_ic&gt;`. 
 
    References 
    ---------- 
    .. [1] :arxiv:`Zou, Hui, Trevor Hastie, and Robert Tibshirani. 
            &quot;On the degrees of freedom of the lasso.&quot; 
            The Annals of Statistics 35.5 (2007): 2173-2192. 
            &lt;0712.0881&gt;` 
 
    .. [2] `Wikipedia entry on the Akaike information criterion 
            &lt;https://en.wikipedia.org/wiki/Akaike_information_criterion&gt;`_ 
 
    .. [3] `Wikipedia entry on the Bayesian information criterion 
            &lt;https://en.wikipedia.org/wiki/Bayesian_information_criterion&gt;`_ 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn import linear_model 
    &gt;&gt;&gt; reg = linear_model.LassoLarsIC(criterion='bic') 
    &gt;&gt;&gt; X = [[-2, 2], [-1, 1], [0, 0], [1, 1], [2, 2]] 
    &gt;&gt;&gt; y = [-2.2222, -1.1111, 0, -1.1111, -2.2222] 
    &gt;&gt;&gt; reg.fit(X, y) 
    LassoLarsIC(criterion='bic') 
    &gt;&gt;&gt; print(reg.coef_) 
    [ 0.  -1.11...] 
    &quot;&quot;&quot;</span>

    <span class="s1">_parameter_constraints: dict = {</span>
        <span class="s1">**LassoLars._parameter_constraints</span><span class="s3">,</span>
        <span class="s4">&quot;criterion&quot;</span><span class="s1">: [StrOptions({</span><span class="s4">&quot;aic&quot;</span><span class="s3">, </span><span class="s4">&quot;bic&quot;</span><span class="s1">})]</span><span class="s3">,</span>
        <span class="s4">&quot;noise_variance&quot;</span><span class="s1">: [Interval(Real</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, None, </span><span class="s1">closed=</span><span class="s4">&quot;left&quot;</span><span class="s1">)</span><span class="s3">, None</span><span class="s1">]</span><span class="s3">,</span>
    <span class="s1">}</span>

    <span class="s3">for </span><span class="s1">parameter </span><span class="s3">in </span><span class="s1">[</span><span class="s4">&quot;jitter&quot;</span><span class="s3">, </span><span class="s4">&quot;fit_path&quot;</span><span class="s3">, </span><span class="s4">&quot;alpha&quot;</span><span class="s3">, </span><span class="s4">&quot;random_state&quot;</span><span class="s1">]:</span>
        <span class="s1">_parameter_constraints.pop(parameter)</span>

    <span class="s3">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s3">,</span>
        <span class="s1">criterion=</span><span class="s4">&quot;aic&quot;</span><span class="s3">,</span>
        <span class="s1">*</span><span class="s3">,</span>
        <span class="s1">fit_intercept=</span><span class="s3">True,</span>
        <span class="s1">verbose=</span><span class="s3">False,</span>
        <span class="s1">normalize=</span><span class="s4">&quot;deprecated&quot;</span><span class="s3">,</span>
        <span class="s1">precompute=</span><span class="s4">&quot;auto&quot;</span><span class="s3">,</span>
        <span class="s1">max_iter=</span><span class="s5">500</span><span class="s3">,</span>
        <span class="s1">eps=np.finfo(float).eps</span><span class="s3">,</span>
        <span class="s1">copy_X=</span><span class="s3">True,</span>
        <span class="s1">positive=</span><span class="s3">False,</span>
        <span class="s1">noise_variance=</span><span class="s3">None,</span>
    <span class="s1">):</span>
        <span class="s1">self.criterion = criterion</span>
        <span class="s1">self.fit_intercept = fit_intercept</span>
        <span class="s1">self.positive = positive</span>
        <span class="s1">self.max_iter = max_iter</span>
        <span class="s1">self.verbose = verbose</span>
        <span class="s1">self.normalize = normalize</span>
        <span class="s1">self.copy_X = copy_X</span>
        <span class="s1">self.precompute = precompute</span>
        <span class="s1">self.eps = eps</span>
        <span class="s1">self.fit_path = </span><span class="s3">True</span>
        <span class="s1">self.noise_variance = noise_variance</span>

    <span class="s3">def </span><span class="s1">_more_tags(self):</span>
        <span class="s3">return </span><span class="s1">{</span><span class="s4">&quot;multioutput&quot;</span><span class="s1">: </span><span class="s3">False</span><span class="s1">}</span>

    <span class="s1">@_fit_context(prefer_skip_nested_validation=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s3">def </span><span class="s1">fit(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">copy_X=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Fit the model using X, y as training data. 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) 
            Training data. 
 
        y : array-like of shape (n_samples,) 
            Target values. Will be cast to X's dtype if necessary. 
 
        copy_X : bool, default=None 
            If provided, this parameter will override the choice 
            of copy_X made at instance creation. 
            If ``True``, X will be copied; else, it may be overwritten. 
 
        Returns 
        ------- 
        self : object 
            Returns an instance of self. 
        &quot;&quot;&quot;</span>
        <span class="s1">_normalize = _deprecate_normalize(</span>
            <span class="s1">self.normalize</span><span class="s3">, </span><span class="s1">estimator_name=self.__class__.__name__</span>
        <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">copy_X </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">copy_X = self.copy_X</span>
        <span class="s1">X</span><span class="s3">, </span><span class="s1">y = self._validate_data(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">y_numeric=</span><span class="s3">True</span><span class="s1">)</span>

        <span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">Xmean</span><span class="s3">, </span><span class="s1">ymean</span><span class="s3">, </span><span class="s1">Xstd = _preprocess_data(</span>
            <span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">self.fit_intercept</span><span class="s3">, </span><span class="s1">_normalize</span><span class="s3">, </span><span class="s1">copy_X</span>
        <span class="s1">)</span>

        <span class="s1">Gram = self.precompute</span>

        <span class="s1">alphas_</span><span class="s3">, </span><span class="s1">_</span><span class="s3">, </span><span class="s1">coef_path_</span><span class="s3">, </span><span class="s1">self.n_iter_ = lars_path(</span>
            <span class="s1">X</span><span class="s3">,</span>
            <span class="s1">y</span><span class="s3">,</span>
            <span class="s1">Gram=Gram</span><span class="s3">,</span>
            <span class="s1">copy_X=copy_X</span><span class="s3">,</span>
            <span class="s1">copy_Gram=</span><span class="s3">True,</span>
            <span class="s1">alpha_min=</span><span class="s5">0.0</span><span class="s3">,</span>
            <span class="s1">method=</span><span class="s4">&quot;lasso&quot;</span><span class="s3">,</span>
            <span class="s1">verbose=self.verbose</span><span class="s3">,</span>
            <span class="s1">max_iter=self.max_iter</span><span class="s3">,</span>
            <span class="s1">eps=self.eps</span><span class="s3">,</span>
            <span class="s1">return_n_iter=</span><span class="s3">True,</span>
            <span class="s1">positive=self.positive</span><span class="s3">,</span>
        <span class="s1">)</span>

        <span class="s1">n_samples = X.shape[</span><span class="s5">0</span><span class="s1">]</span>

        <span class="s3">if </span><span class="s1">self.criterion == </span><span class="s4">&quot;aic&quot;</span><span class="s1">:</span>
            <span class="s1">criterion_factor = </span><span class="s5">2</span>
        <span class="s3">elif </span><span class="s1">self.criterion == </span><span class="s4">&quot;bic&quot;</span><span class="s1">:</span>
            <span class="s1">criterion_factor = log(n_samples)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span>
                <span class="s4">f&quot;criterion should be either bic or aic, got </span><span class="s3">{</span><span class="s1">self.criterion</span><span class="s3">!r}</span><span class="s4">&quot;</span>
            <span class="s1">)</span>

        <span class="s1">residuals = y[:</span><span class="s3">, </span><span class="s1">np.newaxis] - np.dot(X</span><span class="s3">, </span><span class="s1">coef_path_)</span>
        <span class="s1">residuals_sum_squares = np.sum(residuals**</span><span class="s5">2</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">degrees_of_freedom = np.zeros(coef_path_.shape[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dtype=int)</span>
        <span class="s3">for </span><span class="s1">k</span><span class="s3">, </span><span class="s1">coef </span><span class="s3">in </span><span class="s1">enumerate(coef_path_.T):</span>
            <span class="s1">mask = np.abs(coef) &gt; np.finfo(coef.dtype).eps</span>
            <span class="s3">if not </span><span class="s1">np.any(mask):</span>
                <span class="s3">continue</span>
            <span class="s2"># get the number of degrees of freedom equal to:</span>
            <span class="s2"># Xc = X[:, mask]</span>
            <span class="s2"># Trace(Xc * inv(Xc.T, Xc) * Xc.T) ie the number of non-zero coefs</span>
            <span class="s1">degrees_of_freedom[k] = np.sum(mask)</span>

        <span class="s1">self.alphas_ = alphas_</span>

        <span class="s3">if </span><span class="s1">self.noise_variance </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">self.noise_variance_ = self._estimate_noise_variance(</span>
                <span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">positive=self.positive</span>
            <span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.noise_variance_ = self.noise_variance</span>

        <span class="s1">self.criterion_ = (</span>
            <span class="s1">n_samples * np.log(</span><span class="s5">2 </span><span class="s1">* np.pi * self.noise_variance_)</span>
            <span class="s1">+ residuals_sum_squares / self.noise_variance_</span>
            <span class="s1">+ criterion_factor * degrees_of_freedom</span>
        <span class="s1">)</span>
        <span class="s1">n_best = np.argmin(self.criterion_)</span>

        <span class="s1">self.alpha_ = alphas_[n_best]</span>
        <span class="s1">self.coef_ = coef_path_[:</span><span class="s3">, </span><span class="s1">n_best]</span>
        <span class="s1">self._set_intercept(Xmean</span><span class="s3">, </span><span class="s1">ymean</span><span class="s3">, </span><span class="s1">Xstd)</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">_estimate_noise_variance(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">positive):</span>
        <span class="s0">&quot;&quot;&quot;Compute an estimate of the variance with an OLS model. 
 
        Parameters 
        ---------- 
        X : ndarray of shape (n_samples, n_features) 
            Data to be fitted by the OLS model. We expect the data to be 
            centered. 
 
        y : ndarray of shape (n_samples,) 
            Associated target. 
 
        positive : bool, default=False 
            Restrict coefficients to be &gt;= 0. This should be inline with 
            the `positive` parameter from `LassoLarsIC`. 
 
        Returns 
        ------- 
        noise_variance : float 
            An estimator of the noise variance of an OLS model. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">X.shape[</span><span class="s5">0</span><span class="s1">] &lt;= X.shape[</span><span class="s5">1</span><span class="s1">] + self.fit_intercept:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span>
                <span class="s4">f&quot;You are using </span><span class="s3">{</span><span class="s1">self.__class__.__name__</span><span class="s3">} </span><span class="s4">in the case where the number &quot;</span>
                <span class="s4">&quot;of samples is smaller than the number of features. In this setting, &quot;</span>
                <span class="s4">&quot;getting a good estimate for the variance of the noise is not &quot;</span>
                <span class="s4">&quot;possible. Provide an estimate of the noise variance in the &quot;</span>
                <span class="s4">&quot;constructor.&quot;</span>
            <span class="s1">)</span>
        <span class="s2"># X and y are already centered and we don't need to fit with an intercept</span>
        <span class="s1">ols_model = LinearRegression(positive=positive</span><span class="s3">, </span><span class="s1">fit_intercept=</span><span class="s3">False</span><span class="s1">)</span>
        <span class="s1">y_pred = ols_model.fit(X</span><span class="s3">, </span><span class="s1">y).predict(X)</span>
        <span class="s3">return </span><span class="s1">np.sum((y - y_pred) ** </span><span class="s5">2</span><span class="s1">) / (</span>
            <span class="s1">X.shape[</span><span class="s5">0</span><span class="s1">] - X.shape[</span><span class="s5">1</span><span class="s1">] - self.fit_intercept</span>
        <span class="s1">)</span>
</pre>
</body>
</html>