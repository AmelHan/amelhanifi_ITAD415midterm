<html>
<head>
<title>results.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #6897bb;}
.s4 { color: #6a8759;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
results.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">pandas </span><span class="s0">as </span><span class="s1">pd</span>
<span class="s0">from </span><span class="s1">scipy.special </span><span class="s0">import </span><span class="s1">inv_boxcox</span>
<span class="s0">from </span><span class="s1">scipy.stats </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">boxcox</span><span class="s0">,</span>
    <span class="s1">rv_continuous</span><span class="s0">,</span>
    <span class="s1">rv_discrete</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">scipy.stats.distributions </span><span class="s0">import </span><span class="s1">rv_frozen</span>

<span class="s0">from </span><span class="s1">statsmodels.base.data </span><span class="s0">import </span><span class="s1">PandasData</span>
<span class="s0">from </span><span class="s1">statsmodels.base.model </span><span class="s0">import </span><span class="s1">Results</span>
<span class="s0">from </span><span class="s1">statsmodels.base.wrapper </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">ResultsWrapper</span><span class="s0">,</span>
    <span class="s1">populate_wrapper</span><span class="s0">,</span>
    <span class="s1">union_dicts</span><span class="s0">,</span>
<span class="s1">)</span>


<span class="s0">class </span><span class="s1">HoltWintersResults(Results):</span>
    <span class="s2">&quot;&quot;&quot; 
    Results from fitting Exponential Smoothing models. 
 
    Parameters 
    ---------- 
    model : ExponentialSmoothing instance 
        The fitted model instance. 
    params : dict 
        All the parameters for the Exponential Smoothing model. 
    sse : float 
        The sum of squared errors. 
    aic : float 
        The Akaike information criterion. 
    aicc : float 
        AIC with a correction for finite sample sizes. 
    bic : float 
        The Bayesian information criterion. 
    optimized : bool 
        Flag indicating whether the model parameters were optimized to fit 
        the data. 
    level : ndarray 
        An array of the levels values that make up the fitted values. 
    trend : ndarray 
        An array of the trend values that make up the fitted values. 
    season : ndarray 
        An array of the seasonal values that make up the fitted values. 
    params_formatted : pd.DataFrame 
        DataFrame containing all parameters, their short names and a flag 
        indicating whether the parameter's value was optimized to fit the data. 
    resid : ndarray 
        An array of the residuals of the fittedvalues and actual values. 
    k : int 
        The k parameter used to remove the bias in AIC, BIC etc. 
    fittedvalues : ndarray 
        An array of the fitted values. Fitted by the Exponential Smoothing 
        model. 
    fittedfcast : ndarray 
        An array of both the fitted values and forecast values. 
    fcastvalues : ndarray 
        An array of the forecast values forecast by the Exponential Smoothing 
        model. 
    mle_retvals : {None, scipy.optimize.optimize.OptimizeResult} 
        Optimization results if the parameters were optimized to fit the data. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">model</span><span class="s0">,</span>
        <span class="s1">params</span><span class="s0">,</span>
        <span class="s1">sse</span><span class="s0">,</span>
        <span class="s1">aic</span><span class="s0">,</span>
        <span class="s1">aicc</span><span class="s0">,</span>
        <span class="s1">bic</span><span class="s0">,</span>
        <span class="s1">optimized</span><span class="s0">,</span>
        <span class="s1">level</span><span class="s0">,</span>
        <span class="s1">trend</span><span class="s0">,</span>
        <span class="s1">season</span><span class="s0">,</span>
        <span class="s1">params_formatted</span><span class="s0">,</span>
        <span class="s1">resid</span><span class="s0">,</span>
        <span class="s1">k</span><span class="s0">,</span>
        <span class="s1">fittedvalues</span><span class="s0">,</span>
        <span class="s1">fittedfcast</span><span class="s0">,</span>
        <span class="s1">fcastvalues</span><span class="s0">,</span>
        <span class="s1">mle_retvals=</span><span class="s0">None,</span>
    <span class="s1">):</span>
        <span class="s1">self.data = model.data</span>
        <span class="s1">super().__init__(model</span><span class="s0">, </span><span class="s1">params)</span>
        <span class="s1">self._model = model</span>
        <span class="s1">self._sse = sse</span>
        <span class="s1">self._aic = aic</span>
        <span class="s1">self._aicc = aicc</span>
        <span class="s1">self._bic = bic</span>
        <span class="s1">self._optimized = optimized</span>
        <span class="s1">self._level = level</span>
        <span class="s1">self._trend = trend</span>
        <span class="s1">self._season = season</span>
        <span class="s1">self._params_formatted = params_formatted</span>
        <span class="s1">self._fittedvalues = fittedvalues</span>
        <span class="s1">self._fittedfcast = fittedfcast</span>
        <span class="s1">self._fcastvalues = fcastvalues</span>
        <span class="s1">self._resid = resid</span>
        <span class="s1">self._k = k</span>
        <span class="s1">self._mle_retvals = mle_retvals</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">aic(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        The Akaike information criterion. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._aic</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">aicc(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        AIC with a correction for finite sample sizes. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._aicc</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">bic(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        The Bayesian information criterion. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._bic</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">sse(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        The sum of squared errors between the data and the fittted value. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._sse</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">model(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        The model used to produce the results instance. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._model</span>

    <span class="s1">@model.setter</span>
    <span class="s0">def </span><span class="s1">model(self</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s1">self._model = value</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">level(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        An array of the levels values that make up the fitted values. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._level</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">optimized(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Flag indicating if model parameters were optimized to fit the data. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._optimized</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">trend(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        An array of the trend values that make up the fitted values. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._trend</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">season(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        An array of the seasonal values that make up the fitted values. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._season</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">params_formatted(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        DataFrame containing all parameters 
 
        Contains short names and a flag indicating whether the parameter's 
        value was optimized to fit the data. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._params_formatted</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">fittedvalues(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        An array of the fitted values 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._fittedvalues</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">fittedfcast(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        An array of both the fitted values and forecast values. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._fittedfcast</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">fcastvalues(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        An array of the forecast values 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._fcastvalues</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">resid(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        An array of the residuals of the fittedvalues and actual values. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._resid</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">k(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        The k parameter used to remove the bias in AIC, BIC etc. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._k</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">mle_retvals(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Optimization results if the parameters were optimized to fit the data. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._mle_retvals</span>

    <span class="s1">@mle_retvals.setter</span>
    <span class="s0">def </span><span class="s1">mle_retvals(self</span><span class="s0">, </span><span class="s1">value):</span>
        <span class="s1">self._mle_retvals = value</span>

    <span class="s0">def </span><span class="s1">predict(self</span><span class="s0">, </span><span class="s1">start=</span><span class="s0">None, </span><span class="s1">end=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        In-sample prediction and out-of-sample forecasting 
 
        Parameters 
        ---------- 
        start : int, str, or datetime, optional 
            Zero-indexed observation number at which to start forecasting, ie., 
            the first forecast is start. Can also be a date string to 
            parse or a datetime type. Default is the the zeroth observation. 
        end : int, str, or datetime, optional 
            Zero-indexed observation number at which to end forecasting, ie., 
            the first forecast is start. Can also be a date string to 
            parse or a datetime type. However, if the dates index does not 
            have a fixed frequency, end must be an integer index if you 
            want out of sample prediction. Default is the last observation in 
            the sample. 
 
        Returns 
        ------- 
        forecast : ndarray 
            Array of out of sample forecasts. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.model.predict(self.params</span><span class="s0">, </span><span class="s1">start</span><span class="s0">, </span><span class="s1">end)</span>

    <span class="s0">def </span><span class="s1">forecast(self</span><span class="s0">, </span><span class="s1">steps=</span><span class="s3">1</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Out-of-sample forecasts 
 
        Parameters 
        ---------- 
        steps : int 
            The number of out of sample forecasts from the end of the 
            sample. 
 
        Returns 
        ------- 
        forecast : ndarray 
            Array of out of sample forecasts 
        &quot;&quot;&quot;</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">freq = getattr(self.model._index</span><span class="s0">, </span><span class="s4">&quot;freq&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
            <span class="s0">if not </span><span class="s1">isinstance(freq</span><span class="s0">, </span><span class="s1">int) </span><span class="s0">and </span><span class="s1">isinstance(</span>
                <span class="s1">self.model._index</span><span class="s0">, </span><span class="s1">(pd.DatetimeIndex</span><span class="s0">, </span><span class="s1">pd.PeriodIndex)</span>
            <span class="s1">):</span>
                <span class="s1">start = self.model._index[-</span><span class="s3">1</span><span class="s1">] + freq</span>
                <span class="s1">end = self.model._index[-</span><span class="s3">1</span><span class="s1">] + steps * freq</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">start = self.model._index.shape[</span><span class="s3">0</span><span class="s1">]</span>
                <span class="s1">end = start + steps - </span><span class="s3">1</span>
            <span class="s0">return </span><span class="s1">self.model.predict(self.params</span><span class="s0">, </span><span class="s1">start=start</span><span class="s0">, </span><span class="s1">end=end)</span>
        <span class="s0">except </span><span class="s1">AttributeError:</span>
            <span class="s5"># May occur when the index does not have a freq</span>
            <span class="s0">return </span><span class="s1">self.model._predict(h=steps</span><span class="s0">, </span><span class="s1">**self.params).fcastvalues</span>

    <span class="s0">def </span><span class="s1">summary(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Summarize the fitted Model 
 
        Returns 
        ------- 
        smry : Summary instance 
            This holds the summary table and text, which can be printed or 
            converted to various output formats. 
 
        See Also 
        -------- 
        statsmodels.iolib.summary.Summary 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">statsmodels.iolib.summary </span><span class="s0">import </span><span class="s1">Summary</span>
        <span class="s0">from </span><span class="s1">statsmodels.iolib.table </span><span class="s0">import </span><span class="s1">SimpleTable</span>

        <span class="s1">model = self.model</span>
        <span class="s1">title = model.__class__.__name__ + </span><span class="s4">&quot; Model Results&quot;</span>

        <span class="s1">dep_variable = </span><span class="s4">&quot;endog&quot;</span>
        <span class="s1">orig_endog = self.model.data.orig_endog</span>
        <span class="s0">if </span><span class="s1">isinstance(orig_endog</span><span class="s0">, </span><span class="s1">pd.DataFrame):</span>
            <span class="s1">dep_variable = orig_endog.columns[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s0">elif </span><span class="s1">isinstance(orig_endog</span><span class="s0">, </span><span class="s1">pd.Series):</span>
            <span class="s1">dep_variable = orig_endog.name</span>
        <span class="s1">seasonal_periods = (</span>
            <span class="s0">None</span>
            <span class="s0">if </span><span class="s1">self.model.seasonal </span><span class="s0">is None</span>
            <span class="s0">else </span><span class="s1">self.model.seasonal_periods</span>
        <span class="s1">)</span>
        <span class="s1">lookup = {</span>
            <span class="s4">&quot;add&quot;</span><span class="s1">: </span><span class="s4">&quot;Additive&quot;</span><span class="s0">,</span>
            <span class="s4">&quot;additive&quot;</span><span class="s1">: </span><span class="s4">&quot;Additive&quot;</span><span class="s0">,</span>
            <span class="s4">&quot;mul&quot;</span><span class="s1">: </span><span class="s4">&quot;Multiplicative&quot;</span><span class="s0">,</span>
            <span class="s4">&quot;multiplicative&quot;</span><span class="s1">: </span><span class="s4">&quot;Multiplicative&quot;</span><span class="s0">,</span>
            <span class="s0">None</span><span class="s1">: </span><span class="s4">&quot;None&quot;</span><span class="s0">,</span>
        <span class="s1">}</span>
        <span class="s1">transform = self.params[</span><span class="s4">&quot;use_boxcox&quot;</span><span class="s1">]</span>
        <span class="s1">box_cox_transform = </span><span class="s0">True if </span><span class="s1">transform </span><span class="s0">else False</span>
        <span class="s1">box_cox_coeff = (</span>
            <span class="s1">transform </span><span class="s0">if </span><span class="s1">isinstance(transform</span><span class="s0">, </span><span class="s1">str) </span><span class="s0">else </span><span class="s1">self.params[</span><span class="s4">&quot;lamda&quot;</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">isinstance(box_cox_coeff</span><span class="s0">, </span><span class="s1">float):</span>
            <span class="s1">box_cox_coeff = </span><span class="s4">&quot;{:&gt;10.5f}&quot;</span><span class="s1">.format(box_cox_coeff)</span>
        <span class="s1">top_left = [</span>
            <span class="s1">(</span><span class="s4">&quot;Dep. Variable:&quot;</span><span class="s0">, </span><span class="s1">[dep_variable])</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s4">&quot;Model:&quot;</span><span class="s0">, </span><span class="s1">[model.__class__.__name__])</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s4">&quot;Optimized:&quot;</span><span class="s0">, </span><span class="s1">[str(np.any(self.optimized))])</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s4">&quot;Trend:&quot;</span><span class="s0">, </span><span class="s1">[lookup[self.model.trend]])</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s4">&quot;Seasonal:&quot;</span><span class="s0">, </span><span class="s1">[lookup[self.model.seasonal]])</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s4">&quot;Seasonal Periods:&quot;</span><span class="s0">, </span><span class="s1">[str(seasonal_periods)])</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s4">&quot;Box-Cox:&quot;</span><span class="s0">, </span><span class="s1">[str(box_cox_transform)])</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s4">&quot;Box-Cox Coeff.:&quot;</span><span class="s0">, </span><span class="s1">[str(box_cox_coeff)])</span><span class="s0">,</span>
        <span class="s1">]</span>

        <span class="s1">top_right = [</span>
            <span class="s1">(</span><span class="s4">&quot;No. Observations:&quot;</span><span class="s0">, </span><span class="s1">[str(len(self.model.endog))])</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s4">&quot;SSE&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;{:5.3f}&quot;</span><span class="s1">.format(self.sse)])</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s4">&quot;AIC&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;{:5.3f}&quot;</span><span class="s1">.format(self.aic)])</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s4">&quot;BIC&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;{:5.3f}&quot;</span><span class="s1">.format(self.bic)])</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s4">&quot;AICC&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s4">&quot;{:5.3f}&quot;</span><span class="s1">.format(self.aicc)])</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s4">&quot;Date:&quot;</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s4">&quot;Time:&quot;</span><span class="s0">, None</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span>

        <span class="s1">smry = Summary()</span>
        <span class="s1">smry.add_table_2cols(</span>
            <span class="s1">self</span><span class="s0">, </span><span class="s1">gleft=top_left</span><span class="s0">, </span><span class="s1">gright=top_right</span><span class="s0">, </span><span class="s1">title=title</span>
        <span class="s1">)</span>
        <span class="s1">formatted = self.params_formatted  </span><span class="s5"># type: pd.DataFrame</span>

        <span class="s0">def </span><span class="s1">_fmt(x):</span>
            <span class="s1">abs_x = np.abs(x)</span>
            <span class="s1">scale = </span><span class="s3">1</span>
            <span class="s0">if </span><span class="s1">np.isnan(x):</span>
                <span class="s0">return </span><span class="s4">f&quot;</span><span class="s0">{</span><span class="s1">str(x)</span><span class="s0">:</span><span class="s4">&gt;20</span><span class="s0">}</span><span class="s4">&quot;</span>
            <span class="s0">if </span><span class="s1">abs_x != </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s1">scale = int(np.log10(abs_x))</span>
            <span class="s0">if </span><span class="s1">scale &gt; </span><span class="s3">4 </span><span class="s0">or </span><span class="s1">scale &lt; -</span><span class="s3">3</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s4">&quot;{:&gt;20.5g}&quot;</span><span class="s1">.format(x)</span>
            <span class="s1">dec = min(</span><span class="s3">7 </span><span class="s1">- scale</span><span class="s0">, </span><span class="s3">7</span><span class="s1">)</span>
            <span class="s1">fmt = </span><span class="s4">&quot;{{:&gt;20.{0}f}}&quot;</span><span class="s1">.format(dec)</span>
            <span class="s0">return </span><span class="s1">fmt.format(x)</span>

        <span class="s1">tab = []</span>
        <span class="s0">for </span><span class="s1">_</span><span class="s0">, </span><span class="s1">vals </span><span class="s0">in </span><span class="s1">formatted.iterrows():</span>
            <span class="s1">tab.append(</span>
                <span class="s1">[</span>
                    <span class="s1">_fmt(vals.iloc[</span><span class="s3">1</span><span class="s1">])</span><span class="s0">,</span>
                    <span class="s4">&quot;{0:&gt;20}&quot;</span><span class="s1">.format(vals.iloc[</span><span class="s3">0</span><span class="s1">])</span><span class="s0">,</span>
                    <span class="s4">&quot;{0:&gt;20}&quot;</span><span class="s1">.format(str(bool(vals.iloc[</span><span class="s3">2</span><span class="s1">])))</span><span class="s0">,</span>
                <span class="s1">]</span>
            <span class="s1">)</span>
        <span class="s1">params_table = SimpleTable(</span>
            <span class="s1">tab</span><span class="s0">,</span>
            <span class="s1">headers=[</span><span class="s4">&quot;coeff&quot;</span><span class="s0">, </span><span class="s4">&quot;code&quot;</span><span class="s0">, </span><span class="s4">&quot;optimized&quot;</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">title=</span><span class="s4">&quot;&quot;</span><span class="s0">,</span>
            <span class="s1">stubs=list(formatted.index)</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s1">smry.tables.append(params_table)</span>

        <span class="s0">return </span><span class="s1">smry</span>

    <span class="s0">def </span><span class="s1">simulate(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">nsimulations</span><span class="s0">,</span>
        <span class="s1">anchor=</span><span class="s0">None,</span>
        <span class="s1">repetitions=</span><span class="s3">1</span><span class="s0">,</span>
        <span class="s1">error=</span><span class="s4">&quot;add&quot;</span><span class="s0">,</span>
        <span class="s1">random_errors=</span><span class="s0">None,</span>
        <span class="s1">random_state=</span><span class="s0">None,</span>
    <span class="s1">):</span>
        <span class="s2">r&quot;&quot;&quot; 
        Random simulations using the state space formulation. 
 
        Parameters 
        ---------- 
        nsimulations : int 
            The number of simulation steps. 
        anchor : int, str, or datetime, optional 
            First period for simulation. The simulation will be conditional on 
            all existing datapoints prior to the `anchor`.  Type depends on the 
            index of the given `endog` in the model. Two special cases are the 
            strings 'start' and 'end'. `start` refers to beginning the 
            simulation at the first period of the sample, and `end` refers to 
            beginning the simulation at the first period after the sample. 
            Integer values can run from 0 to `nobs`, or can be negative to 
            apply negative indexing. Finally, if a date/time index was provided 
            to the model, then this argument can be a date string to parse or a 
            datetime type. Default is 'end'. 
        repetitions : int, optional 
            Number of simulated paths to generate. Default is 1 simulated path. 
        error : {&quot;add&quot;, &quot;mul&quot;, &quot;additive&quot;, &quot;multiplicative&quot;}, optional 
            Error model for state space formulation. Default is ``&quot;add&quot;``. 
        random_errors : optional 
            Specifies how the random errors should be obtained. Can be one of 
            the following: 
 
            * ``None``: Random normally distributed values with variance 
              estimated from the fit errors drawn from numpy's standard 
              RNG (can be seeded with the `random_state` argument). This is the 
              default option. 
            * A distribution function from ``scipy.stats``, e.g. 
              ``scipy.stats.norm``: Fits the distribution function to the fit 
              errors and draws from the fitted distribution. 
              Note the difference between ``scipy.stats.norm`` and 
              ``scipy.stats.norm()``, the latter one is a frozen distribution 
              function. 
            * A frozen distribution function from ``scipy.stats``, e.g. 
              ``scipy.stats.norm(scale=2)``: Draws from the frozen distribution 
              function. 
            * A ``np.ndarray`` with shape (`nsimulations`, `repetitions`): Uses 
              the given values as random errors. 
            * ``&quot;bootstrap&quot;``: Samples the random errors from the fit errors. 
 
        random_state : int or np.random.RandomState, optional 
            A seed for the random number generator or a 
            ``np.random.RandomState`` object. Only used if `random_errors` is 
            ``None``. Default is ``None``. 
 
        Returns 
        ------- 
        sim : pd.Series, pd.DataFrame or np.ndarray 
            An ``np.ndarray``, ``pd.Series``, or ``pd.DataFrame`` of simulated 
            values. 
            If the original data was a ``pd.Series`` or ``pd.DataFrame``, `sim` 
            will be a ``pd.Series`` if `repetitions` is 1, and a 
            ``pd.DataFrame`` of shape (`nsimulations`, `repetitions`) else. 
            Otherwise, if `repetitions` is 1, a ``np.ndarray`` of shape 
            (`nsimulations`,) is returned, and if `repetitions` is not 1 a 
            ``np.ndarray`` of shape (`nsimulations`, `repetitions`) is 
            returned. 
 
        Notes 
        ----- 
        The simulation is based on the state space model of the Holt-Winter's 
        methods. The state space model assumes that the true value at time 
        :math:`t` is randomly distributed around the prediction value. 
        If using the additive error model, this means: 
 
        .. math:: 
 
            y_t &amp;= \hat{y}_{t|t-1} + e_t\\ 
            e_t &amp;\sim \mathcal{N}(0, \sigma^2) 
 
        Using the multiplicative error model: 
 
        .. math:: 
 
            y_t &amp;= \hat{y}_{t|t-1} \cdot (1 + e_t)\\ 
            e_t &amp;\sim \mathcal{N}(0, \sigma^2) 
 
        Inserting these equations into the smoothing equation formulation leads 
        to the state space equations. The notation used here follows 
        [1]_. 
 
        Additionally, 
 
        .. math:: 
 
           B_t &amp;= b_{t-1} \circ_d \phi\\ 
           L_t &amp;= l_{t-1} \circ_b B_t\\ 
           S_t &amp;= s_{t-m}\\ 
           Y_t &amp;= L_t \circ_s S_t, 
 
        where :math:`\circ_d` is the operation linking trend and damping 
        parameter (multiplication if the trend is additive, power if the trend 
        is multiplicative), :math:`\circ_b` is the operation linking level and 
        trend (addition if the trend is additive, multiplication if the trend 
        is multiplicative), and :math:`\circ_s` is the operation linking 
        seasonality to the rest. 
 
        The state space equations can then be formulated as 
 
        .. math:: 
 
           y_t &amp;= Y_t + \eta \cdot e_t\\ 
           l_t &amp;= L_t + \alpha \cdot (M_e \cdot L_t + \kappa_l) \cdot e_t\\ 
           b_t &amp;= B_t + \beta \cdot (M_e \cdot B_t + \kappa_b) \cdot e_t\\ 
           s_t &amp;= S_t + \gamma \cdot (M_e \cdot S_t + \kappa_s) \cdot e_t\\ 
 
        with 
 
        .. math:: 
 
           \eta &amp;= \begin{cases} 
                       Y_t\quad\text{if error is multiplicative}\\ 
                       1\quad\text{else} 
                   \end{cases}\\ 
           M_e &amp;= \begin{cases} 
                       1\quad\text{if error is multiplicative}\\ 
                       0\quad\text{else} 
                   \end{cases}\\ 
 
        and, when using the additive error model, 
 
        .. math:: 
 
           \kappa_l &amp;= \begin{cases} 
                       \frac{1}{S_t}\quad 
                       \text{if seasonality is multiplicative}\\ 
                       1\quad\text{else} 
                   \end{cases}\\ 
           \kappa_b &amp;= \begin{cases} 
                       \frac{\kappa_l}{l_{t-1}}\quad 
                       \text{if trend is multiplicative}\\ 
                       \kappa_l\quad\text{else} 
                   \end{cases}\\ 
           \kappa_s &amp;= \begin{cases} 
                       \frac{1}{L_t}\quad\text{if seasonality is 
                                               multiplicative}\\ 
                       1\quad\text{else} 
                   \end{cases} 
 
        When using the multiplicative error model 
 
        .. math:: 
 
           \kappa_l &amp;= \begin{cases} 
                       0\quad 
                       \text{if seasonality is multiplicative}\\ 
                       S_t\quad\text{else} 
                   \end{cases}\\ 
           \kappa_b &amp;= \begin{cases} 
                       \frac{\kappa_l}{l_{t-1}}\quad 
                       \text{if trend is multiplicative}\\ 
                       \kappa_l + l_{t-1}\quad\text{else} 
                   \end{cases}\\ 
           \kappa_s &amp;= \begin{cases} 
                       0\quad\text{if seasonality is multiplicative}\\ 
                       L_t\quad\text{else} 
                   \end{cases} 
 
        References 
        ---------- 
        .. [1] Hyndman, R.J., &amp; Athanasopoulos, G. (2018) *Forecasting: 
           principles and practice*, 2nd edition, OTexts: Melbourne, 
           Australia. OTexts.com/fpp2. Accessed on February 28th 2020. 
        &quot;&quot;&quot;</span>

        <span class="s5"># check inputs</span>
        <span class="s0">if </span><span class="s1">error </span><span class="s0">in </span><span class="s1">[</span><span class="s4">&quot;additive&quot;</span><span class="s0">, </span><span class="s4">&quot;multiplicative&quot;</span><span class="s1">]:</span>
            <span class="s1">error = {</span><span class="s4">&quot;additive&quot;</span><span class="s1">: </span><span class="s4">&quot;add&quot;</span><span class="s0">, </span><span class="s4">&quot;multiplicative&quot;</span><span class="s1">: </span><span class="s4">&quot;mul&quot;</span><span class="s1">}[error]</span>
        <span class="s0">if </span><span class="s1">error </span><span class="s0">not in </span><span class="s1">[</span><span class="s4">&quot;add&quot;</span><span class="s0">, </span><span class="s4">&quot;mul&quot;</span><span class="s1">]:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;error must be 'add' or 'mul'!&quot;</span><span class="s1">)</span>

        <span class="s5"># Get the starting location</span>
        <span class="s0">if </span><span class="s1">anchor </span><span class="s0">is None or </span><span class="s1">anchor == </span><span class="s4">&quot;end&quot;</span><span class="s1">:</span>
            <span class="s1">start_idx = self.model.nobs</span>
        <span class="s0">elif </span><span class="s1">anchor == </span><span class="s4">&quot;start&quot;</span><span class="s1">:</span>
            <span class="s1">start_idx = </span><span class="s3">0</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">start_idx</span><span class="s0">, </span><span class="s1">_</span><span class="s0">, </span><span class="s1">_ = self.model._get_index_loc(anchor)</span>
            <span class="s0">if </span><span class="s1">isinstance(start_idx</span><span class="s0">, </span><span class="s1">slice):</span>
                <span class="s1">start_idx = start_idx.start</span>
        <span class="s0">if </span><span class="s1">start_idx &lt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">start_idx += self.model.nobs</span>
        <span class="s0">if </span><span class="s1">start_idx &gt; self.model.nobs:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Cannot anchor simulation outside of the sample.&quot;</span><span class="s1">)</span>

        <span class="s5"># get Holt-Winters settings and parameters</span>
        <span class="s1">trend = self.model.trend</span>
        <span class="s1">damped = self.model.damped_trend</span>
        <span class="s1">seasonal = self.model.seasonal</span>
        <span class="s1">use_boxcox = self.params[</span><span class="s4">&quot;use_boxcox&quot;</span><span class="s1">]</span>
        <span class="s1">lamda = self.params[</span><span class="s4">&quot;lamda&quot;</span><span class="s1">]</span>
        <span class="s1">alpha = self.params[</span><span class="s4">&quot;smoothing_level&quot;</span><span class="s1">]</span>
        <span class="s1">beta = self.params[</span><span class="s4">&quot;smoothing_trend&quot;</span><span class="s1">]</span>
        <span class="s1">gamma = self.params[</span><span class="s4">&quot;smoothing_seasonal&quot;</span><span class="s1">]</span>
        <span class="s1">phi = self.params[</span><span class="s4">&quot;damping_trend&quot;</span><span class="s1">]</span>
        <span class="s5"># if model has no seasonal component, use 1 as period length</span>
        <span class="s1">m = max(self.model.seasonal_periods</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">n_params = (</span>
            <span class="s3">2</span>
            <span class="s1">+ </span><span class="s3">2 </span><span class="s1">* self.model.has_trend</span>
            <span class="s1">+ (m + </span><span class="s3">1</span><span class="s1">) * self.model.has_seasonal</span>
            <span class="s1">+ damped</span>
        <span class="s1">)</span>
        <span class="s1">mul_seasonal = seasonal == </span><span class="s4">&quot;mul&quot;</span>
        <span class="s1">mul_trend = trend == </span><span class="s4">&quot;mul&quot;</span>
        <span class="s1">mul_error = error == </span><span class="s4">&quot;mul&quot;</span>

        <span class="s5"># define trend, damping and seasonality operations</span>
        <span class="s0">if </span><span class="s1">mul_trend:</span>
            <span class="s1">op_b = np.multiply</span>
            <span class="s1">op_d = np.power</span>
            <span class="s1">neutral_b = </span><span class="s3">1</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">op_b = np.add</span>
            <span class="s1">op_d = np.multiply</span>
            <span class="s1">neutral_b = </span><span class="s3">0</span>
        <span class="s0">if </span><span class="s1">mul_seasonal:</span>
            <span class="s1">op_s = np.multiply</span>
            <span class="s1">neutral_s = </span><span class="s3">1</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">op_s = np.add</span>
            <span class="s1">neutral_s = </span><span class="s3">0</span>

        <span class="s5"># set initial values</span>
        <span class="s1">level = self.level</span>
        <span class="s1">_trend = self.trend</span>
        <span class="s1">season = self.season</span>
        <span class="s5"># (notation as in https://otexts.com/fpp2/ets.html)</span>
        <span class="s1">y = np.empty((nsimulations</span><span class="s0">, </span><span class="s1">repetitions))</span>
        <span class="s5"># lvl instead of l because of E741</span>
        <span class="s1">lvl = np.empty((nsimulations + </span><span class="s3">1</span><span class="s0">, </span><span class="s1">repetitions))</span>
        <span class="s1">b = np.empty((nsimulations + </span><span class="s3">1</span><span class="s0">, </span><span class="s1">repetitions))</span>
        <span class="s1">s = np.empty((nsimulations + m</span><span class="s0">, </span><span class="s1">repetitions))</span>
        <span class="s5"># the following uses python's index wrapping</span>
        <span class="s0">if </span><span class="s1">start_idx == </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">lvl[-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">:] = self.params[</span><span class="s4">&quot;initial_level&quot;</span><span class="s1">]</span>
            <span class="s1">b[-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">:] = self.params[</span><span class="s4">&quot;initial_trend&quot;</span><span class="s1">]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">lvl[-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">:] = level[start_idx - </span><span class="s3">1</span><span class="s1">]</span>
            <span class="s1">b[-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">:] = _trend[start_idx - </span><span class="s3">1</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s3">0 </span><span class="s1">&lt;= start_idx </span><span class="s0">and </span><span class="s1">start_idx &lt;= m:</span>
            <span class="s1">initial_seasons = self.params[</span><span class="s4">&quot;initial_seasons&quot;</span><span class="s1">]</span>
            <span class="s1">_s = np.concatenate(</span>
                <span class="s1">(initial_seasons[start_idx:]</span><span class="s0">, </span><span class="s1">season[:start_idx])</span>
            <span class="s1">)</span>
            <span class="s1">s[-m:</span><span class="s0">, </span><span class="s1">:] = np.tile(_s</span><span class="s0">, </span><span class="s1">(repetitions</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)).T</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">s[-m:</span><span class="s0">, </span><span class="s1">:] = np.tile(</span>
                <span class="s1">season[start_idx - m : start_idx]</span><span class="s0">, </span><span class="s1">(repetitions</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>
            <span class="s1">).T</span>

        <span class="s5"># set neutral values for unused features</span>
        <span class="s0">if </span><span class="s1">trend </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">b[:</span><span class="s0">, </span><span class="s1">:] = neutral_b</span>
            <span class="s1">phi = </span><span class="s3">1</span>
            <span class="s1">beta = </span><span class="s3">0</span>
        <span class="s0">if </span><span class="s1">seasonal </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">s[:</span><span class="s0">, </span><span class="s1">:] = neutral_s</span>
            <span class="s1">gamma = </span><span class="s3">0</span>
        <span class="s0">if not </span><span class="s1">damped:</span>
            <span class="s1">phi = </span><span class="s3">1</span>

        <span class="s5"># calculate residuals for error covariance estimation</span>
        <span class="s0">if </span><span class="s1">use_boxcox:</span>
            <span class="s1">fitted = boxcox(self.fittedvalues</span><span class="s0">, </span><span class="s1">lamda)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">fitted = self.fittedvalues</span>
        <span class="s0">if </span><span class="s1">error == </span><span class="s4">&quot;add&quot;</span><span class="s1">:</span>
            <span class="s1">resid = self.model._y - fitted</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">resid = (self.model._y - fitted) / fitted</span>
        <span class="s1">sigma = np.sqrt(np.sum(resid**</span><span class="s3">2</span><span class="s1">) / (len(resid) - n_params))</span>

        <span class="s5"># get random error eps</span>
        <span class="s0">if </span><span class="s1">isinstance(random_errors</span><span class="s0">, </span><span class="s1">np.ndarray):</span>
            <span class="s0">if </span><span class="s1">random_errors.shape != (nsimulations</span><span class="s0">, </span><span class="s1">repetitions):</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">&quot;If random_errors is an ndarray, it must have shape &quot;</span>
                    <span class="s4">&quot;(nsimulations, repetitions)&quot;</span>
                <span class="s1">)</span>
            <span class="s1">eps = random_errors</span>
        <span class="s0">elif </span><span class="s1">random_errors == </span><span class="s4">&quot;bootstrap&quot;</span><span class="s1">:</span>
            <span class="s1">eps = np.random.choice(</span>
                <span class="s1">resid</span><span class="s0">, </span><span class="s1">size=(nsimulations</span><span class="s0">, </span><span class="s1">repetitions)</span><span class="s0">, </span><span class="s1">replace=</span><span class="s0">True</span>
            <span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">random_errors </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">random_state </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s1">eps = np.random.randn(nsimulations</span><span class="s0">, </span><span class="s1">repetitions) * sigma</span>
            <span class="s0">elif </span><span class="s1">isinstance(random_state</span><span class="s0">, </span><span class="s1">int):</span>
                <span class="s1">rng = np.random.RandomState(random_state)</span>
                <span class="s1">eps = rng.randn(nsimulations</span><span class="s0">, </span><span class="s1">repetitions) * sigma</span>
            <span class="s0">elif </span><span class="s1">isinstance(random_state</span><span class="s0">, </span><span class="s1">np.random.RandomState):</span>
                <span class="s1">eps = random_state.randn(nsimulations</span><span class="s0">, </span><span class="s1">repetitions) * sigma</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">&quot;Argument random_state must be None, an integer, &quot;</span>
                    <span class="s4">&quot;or an instance of np.random.RandomState&quot;</span>
                <span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">isinstance(random_errors</span><span class="s0">, </span><span class="s1">(rv_continuous</span><span class="s0">, </span><span class="s1">rv_discrete)):</span>
            <span class="s1">params = random_errors.fit(resid)</span>
            <span class="s1">eps = random_errors.rvs(*params</span><span class="s0">, </span><span class="s1">size=(nsimulations</span><span class="s0">, </span><span class="s1">repetitions))</span>
        <span class="s0">elif </span><span class="s1">isinstance(random_errors</span><span class="s0">, </span><span class="s1">rv_frozen):</span>
            <span class="s1">eps = random_errors.rvs(size=(nsimulations</span><span class="s0">, </span><span class="s1">repetitions))</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Argument random_errors has unexpected value!&quot;</span><span class="s1">)</span>

        <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">range(nsimulations):</span>
            <span class="s1">b0 = op_d(b[t - </span><span class="s3">1</span><span class="s0">, </span><span class="s1">:]</span><span class="s0">, </span><span class="s1">phi)</span>
            <span class="s1">l0 = op_b(lvl[t - </span><span class="s3">1</span><span class="s0">, </span><span class="s1">:]</span><span class="s0">, </span><span class="s1">b0)</span>
            <span class="s1">s0 = s[t - m</span><span class="s0">, </span><span class="s1">:]</span>
            <span class="s1">y0 = op_s(l0</span><span class="s0">, </span><span class="s1">s0)</span>
            <span class="s0">if </span><span class="s1">error == </span><span class="s4">&quot;add&quot;</span><span class="s1">:</span>
                <span class="s1">eta = </span><span class="s3">1</span>
                <span class="s1">kappa_l = </span><span class="s3">1 </span><span class="s1">/ s0 </span><span class="s0">if </span><span class="s1">mul_seasonal </span><span class="s0">else </span><span class="s3">1</span>
                <span class="s1">kappa_b = kappa_l / lvl[t - </span><span class="s3">1</span><span class="s0">, </span><span class="s1">:] </span><span class="s0">if </span><span class="s1">mul_trend </span><span class="s0">else </span><span class="s1">kappa_l</span>
                <span class="s1">kappa_s = </span><span class="s3">1 </span><span class="s1">/ l0 </span><span class="s0">if </span><span class="s1">mul_seasonal </span><span class="s0">else </span><span class="s3">1</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">eta = y0</span>
                <span class="s1">kappa_l = </span><span class="s3">0 </span><span class="s0">if </span><span class="s1">mul_seasonal </span><span class="s0">else </span><span class="s1">s0</span>
                <span class="s1">kappa_b = (</span>
                    <span class="s1">kappa_l / lvl[t - </span><span class="s3">1</span><span class="s0">, </span><span class="s1">:]</span>
                    <span class="s0">if </span><span class="s1">mul_trend</span>
                    <span class="s0">else </span><span class="s1">kappa_l + lvl[t - </span><span class="s3">1</span><span class="s0">, </span><span class="s1">:]</span>
                <span class="s1">)</span>
                <span class="s1">kappa_s = </span><span class="s3">0 </span><span class="s0">if </span><span class="s1">mul_seasonal </span><span class="s0">else </span><span class="s1">l0</span>

            <span class="s1">y[t</span><span class="s0">, </span><span class="s1">:] = y0 + eta * eps[t</span><span class="s0">, </span><span class="s1">:]</span>
            <span class="s1">lvl[t</span><span class="s0">, </span><span class="s1">:] = l0 + alpha * (mul_error * l0 + kappa_l) * eps[t</span><span class="s0">, </span><span class="s1">:]</span>
            <span class="s1">b[t</span><span class="s0">, </span><span class="s1">:] = b0 + beta * (mul_error * b0 + kappa_b) * eps[t</span><span class="s0">, </span><span class="s1">:]</span>
            <span class="s1">s[t</span><span class="s0">, </span><span class="s1">:] = s0 + gamma * (mul_error * s0 + kappa_s) * eps[t</span><span class="s0">, </span><span class="s1">:]</span>

        <span class="s0">if </span><span class="s1">use_boxcox:</span>
            <span class="s1">y = inv_boxcox(y</span><span class="s0">, </span><span class="s1">lamda)</span>

        <span class="s1">sim = np.atleast_1d(np.squeeze(y))</span>
        <span class="s0">if </span><span class="s1">y.shape[</span><span class="s3">0</span><span class="s1">] == </span><span class="s3">1 </span><span class="s0">and </span><span class="s1">y.size &gt; </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s1">sim = sim[</span><span class="s0">None, </span><span class="s1">:]</span>
        <span class="s5"># Wrap data / squeeze where appropriate</span>
        <span class="s0">if not </span><span class="s1">isinstance(self.model.data</span><span class="s0">, </span><span class="s1">PandasData):</span>
            <span class="s0">return </span><span class="s1">sim</span>

        <span class="s1">_</span><span class="s0">, </span><span class="s1">_</span><span class="s0">, </span><span class="s1">_</span><span class="s0">, </span><span class="s1">index = self.model._get_prediction_index(</span>
            <span class="s1">start_idx</span><span class="s0">, </span><span class="s1">start_idx + nsimulations - </span><span class="s3">1</span>
        <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">repetitions == </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s1">sim = pd.Series(sim</span><span class="s0">, </span><span class="s1">index=index</span><span class="s0">, </span><span class="s1">name=self.model.endog_names)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">sim = pd.DataFrame(sim</span><span class="s0">, </span><span class="s1">index=index)</span>

        <span class="s0">return </span><span class="s1">sim</span>


<span class="s0">class </span><span class="s1">HoltWintersResultsWrapper(ResultsWrapper):</span>
    <span class="s1">_attrs = {</span>
        <span class="s4">&quot;fittedvalues&quot;</span><span class="s1">: </span><span class="s4">&quot;rows&quot;</span><span class="s0">,</span>
        <span class="s4">&quot;level&quot;</span><span class="s1">: </span><span class="s4">&quot;rows&quot;</span><span class="s0">,</span>
        <span class="s4">&quot;resid&quot;</span><span class="s1">: </span><span class="s4">&quot;rows&quot;</span><span class="s0">,</span>
        <span class="s4">&quot;season&quot;</span><span class="s1">: </span><span class="s4">&quot;rows&quot;</span><span class="s0">,</span>
        <span class="s4">&quot;trend&quot;</span><span class="s1">: </span><span class="s4">&quot;rows&quot;</span><span class="s0">,</span>
        <span class="s4">&quot;slope&quot;</span><span class="s1">: </span><span class="s4">&quot;rows&quot;</span><span class="s0">,</span>
    <span class="s1">}</span>
    <span class="s1">_wrap_attrs = union_dicts(ResultsWrapper._wrap_attrs</span><span class="s0">, </span><span class="s1">_attrs)</span>
    <span class="s1">_methods = {</span><span class="s4">&quot;predict&quot;</span><span class="s1">: </span><span class="s4">&quot;dates&quot;</span><span class="s0">, </span><span class="s4">&quot;forecast&quot;</span><span class="s1">: </span><span class="s4">&quot;dates&quot;</span><span class="s1">}</span>
    <span class="s1">_wrap_methods = union_dicts(ResultsWrapper._wrap_methods</span><span class="s0">, </span><span class="s1">_methods)</span>


<span class="s1">populate_wrapper(HoltWintersResultsWrapper</span><span class="s0">, </span><span class="s1">HoltWintersResults)</span>
</pre>
</body>
</html>