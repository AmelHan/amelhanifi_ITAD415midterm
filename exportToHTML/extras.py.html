<html>
<head>
<title>extras.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
extras.py</font>
</center></td></tr></table>
<pre><span class="s0">'''Various extensions to distributions 
 
* skew normal and skew t distribution by Azzalini, A. &amp; Capitanio, A. 
* Gram-Charlier expansion distribution (using 4 moments), 
* distributions based on non-linear transformation 
  - Transf_gen 
  - ExpTransf_gen, LogTransf_gen 
  - TransfTwo_gen 
    (defines as examples: square, negative square and abs transformations) 
  - this versions are without __new__ 
* mnvormcdf, mvstdnormcdf : cdf, rectangular integral for multivariate normal 
  distribution 
 
TODO: 
* Where is Transf_gen for general monotonic transformation ? found and added it 
* write some docstrings, some parts I do not remember 
* add Box-Cox transformation, parametrized ? 
 
 
this is only partially cleaned, still includes test examples as functions 
 
main changes 
* add transf_gen (2010-05-09) 
* added separate example and tests (2010-05-09) 
* collect transformation function into classes 
 
Example 
------- 
 
&gt;&gt;&gt; logtg = Transf_gen(stats.t, np.exp, np.log, 
                numargs = 1, a=0, name = 'lnnorm', 
                longname = 'Exp transformed normal', 
                extradoc = '\ndistribution of y = exp(x), with x standard normal' 
                'precision for moment andstats is not very high, 2-3 decimals') 
&gt;&gt;&gt; logtg.cdf(5, 6) 
0.92067704211191848 
&gt;&gt;&gt; stats.t.cdf(np.log(5), 6) 
0.92067704211191848 
 
&gt;&gt;&gt; logtg.pdf(5, 6) 
0.021798547904239293 
&gt;&gt;&gt; stats.t.pdf(np.log(5), 6) 
0.10899273954837908 
&gt;&gt;&gt; stats.t.pdf(np.log(5), 6)/5.  #derivative 
0.021798547909675815 
 
 
Author: josef-pktd 
License: BSD 
 
'''</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">numpy </span><span class="s2">import </span><span class="s1">poly1d</span><span class="s2">, </span><span class="s1">sqrt</span><span class="s2">, </span><span class="s1">exp</span>

<span class="s2">import </span><span class="s1">scipy</span>
<span class="s2">from </span><span class="s1">scipy </span><span class="s2">import </span><span class="s1">stats</span><span class="s2">, </span><span class="s1">special</span>
<span class="s2">from </span><span class="s1">scipy.stats </span><span class="s2">import </span><span class="s1">distributions</span>

<span class="s2">from </span><span class="s1">statsmodels.stats.moment_helpers </span><span class="s2">import </span><span class="s1">mvsk2mc</span><span class="s2">, </span><span class="s1">mc2mvsk</span>

<span class="s2">try</span><span class="s1">:</span>
    <span class="s2">from </span><span class="s1">scipy.stats._mvn </span><span class="s2">import </span><span class="s1">mvndst</span>
<span class="s2">except </span><span class="s1">ImportError:</span>
    <span class="s3"># Must be using SciPy &lt;1.8.0 where this function was moved (it's not a</span>
    <span class="s3"># public SciPy function, but we need it here)</span>
    <span class="s2">from </span><span class="s1">scipy.stats.mvn </span><span class="s2">import </span><span class="s1">mvndst</span>


<span class="s3"># note copied from distr_skewnorm_0.py</span>


<span class="s2">class </span><span class="s1">SkewNorm_gen(distributions.rv_continuous):</span>
    <span class="s0">'''univariate Skew-Normal distribution of Azzalini 
 
    class follows scipy.stats.distributions pattern 
    but with __init__ 
 
 
    '''</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s3"># super(SkewNorm_gen,self).__init__(</span>
        <span class="s1">distributions.rv_continuous.__init__(self</span><span class="s2">,</span>
                                             <span class="s1">name=</span><span class="s4">'Skew Normal distribution'</span><span class="s2">, </span><span class="s1">shapes=</span><span class="s4">'alpha'</span><span class="s2">,</span>
                                             <span class="s3"># extradoc = ''' '''</span>
                                             <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_argcheck(self</span><span class="s2">, </span><span class="s1">alpha):</span>
        <span class="s2">return </span><span class="s5">1  </span><span class="s3"># (alpha &gt;= 0)</span>

    <span class="s2">def </span><span class="s1">_rvs(self</span><span class="s2">, </span><span class="s1">alpha):</span>
        <span class="s3"># see http://azzalini.stat.unipd.it/SN/faq.html</span>
        <span class="s1">delta = alpha / np.sqrt(</span><span class="s5">1 </span><span class="s1">+ alpha ** </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">u0 = stats.norm.rvs(size=self._size)</span>
        <span class="s1">u1 = delta * u0 + np.sqrt(</span><span class="s5">1 </span><span class="s1">- delta ** </span><span class="s5">2</span><span class="s1">) * stats.norm.rvs(size=self._size)</span>
        <span class="s2">return </span><span class="s1">np.where(u0 &gt; </span><span class="s5">0</span><span class="s2">, </span><span class="s1">u1</span><span class="s2">, </span><span class="s1">-u1)</span>

    <span class="s2">def </span><span class="s1">_munp(self</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">alpha):</span>
        <span class="s3"># use pdf integration with _mom0_sc if only _pdf is defined.</span>
        <span class="s3"># default stats calculation uses ppf, which is much slower</span>
        <span class="s2">return </span><span class="s1">self._mom0_sc(n</span><span class="s2">, </span><span class="s1">alpha)</span>

    <span class="s2">def </span><span class="s1">_pdf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">alpha):</span>
        <span class="s3"># 2*normpdf(x)*normcdf(alpha*x)</span>
        <span class="s2">return </span><span class="s5">2.0 </span><span class="s1">/ np.sqrt(</span><span class="s5">2 </span><span class="s1">* np.pi) * np.exp(-x ** </span><span class="s5">2 </span><span class="s1">/ </span><span class="s5">2.0</span><span class="s1">) * special.ndtr(alpha * x)</span>

    <span class="s2">def </span><span class="s1">_stats_skip(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">alpha</span><span class="s2">, </span><span class="s1">moments=</span><span class="s4">'mvsk'</span><span class="s1">):</span>
        <span class="s3"># skip for now to force moment integration as check</span>
        <span class="s2">pass</span>


<span class="s1">skewnorm = SkewNorm_gen()</span>


<span class="s3"># generated the same way as distributions in stats.distributions</span>
<span class="s2">class </span><span class="s1">SkewNorm2_gen(distributions.rv_continuous):</span>
    <span class="s0">'''univariate Skew-Normal distribution of Azzalini 
 
    class follows scipy.stats.distributions pattern 
 
    '''</span>

    <span class="s2">def </span><span class="s1">_argcheck(self</span><span class="s2">, </span><span class="s1">alpha):</span>
        <span class="s2">return </span><span class="s5">1  </span><span class="s3"># where(alpha&gt;=0, 1, 0)</span>

    <span class="s2">def </span><span class="s1">_pdf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">alpha):</span>
        <span class="s3"># 2*normpdf(x)*normcdf(alpha*x</span>
        <span class="s2">return </span><span class="s5">2.0 </span><span class="s1">/ np.sqrt(</span><span class="s5">2 </span><span class="s1">* np.pi) * np.exp(-x ** </span><span class="s5">2 </span><span class="s1">/ </span><span class="s5">2.0</span><span class="s1">) * special.ndtr(alpha * x)</span>


<span class="s1">skewnorm2 = SkewNorm2_gen(name=</span><span class="s4">'Skew Normal distribution'</span><span class="s2">, </span><span class="s1">shapes=</span><span class="s4">'alpha'</span><span class="s2">,</span>
                          <span class="s3"># extradoc = '''  -inf &lt; alpha &lt; inf'''</span>
                          <span class="s1">)</span>


<span class="s2">class </span><span class="s1">ACSkewT_gen(distributions.rv_continuous):</span>
    <span class="s0">'''univariate Skew-T distribution of Azzalini 
 
    class follows scipy.stats.distributions pattern 
    but with __init__ 
    '''</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s3"># super(SkewT_gen,self).__init__(</span>
        <span class="s1">distributions.rv_continuous.__init__(self</span><span class="s2">,</span>
                                             <span class="s1">name=</span><span class="s4">'Skew T distribution'</span><span class="s2">, </span><span class="s1">shapes=</span><span class="s4">'df, alpha'</span><span class="s2">,</span>
                                             <span class="s1">)</span>

    <span class="s3">#             extradoc = '''</span>
    <span class="s3"># Skewed T distribution by Azzalini, A. &amp; Capitanio, A. (2003)_</span>
    <span class="s3">#</span>
    <span class="s3"># the pdf is given by:</span>
    <span class="s3">#  pdf(x) = 2.0 * t.pdf(x, df) * t.cdf(df+1, alpha*x*np.sqrt((1+df)/(x**2+df)))</span>
    <span class="s3">#</span>
    <span class="s3"># with alpha &gt;=0</span>
    <span class="s3">#</span>
    <span class="s3"># Note: different from skewed t distribution by Hansen 1999</span>
    <span class="s3"># .._</span>
    <span class="s3"># Azzalini, A. &amp; Capitanio, A. (2003), Distributions generated by perturbation of</span>
    <span class="s3"># symmetry with emphasis on a multivariate skew-t distribution,</span>
    <span class="s3"># appears in J.Roy.Statist.Soc, series B, vol.65, pp.367-389</span>
    <span class="s3">#</span>
    <span class="s3"># '''                               )</span>

    <span class="s2">def </span><span class="s1">_argcheck(self</span><span class="s2">, </span><span class="s1">df</span><span class="s2">, </span><span class="s1">alpha):</span>
        <span class="s2">return </span><span class="s1">(alpha == alpha) * (df &gt; </span><span class="s5">0</span><span class="s1">)</span>

    <span class="s3">##    def _arg_check(self, alpha):</span>
    <span class="s3">##        return np.where(alpha&gt;=0, 0, 1)</span>
    <span class="s3">##    def _argcheck(self, alpha):</span>
    <span class="s3">##        return np.where(alpha&gt;=0, 1, 0)</span>

    <span class="s2">def </span><span class="s1">_rvs(self</span><span class="s2">, </span><span class="s1">df</span><span class="s2">, </span><span class="s1">alpha):</span>
        <span class="s3"># see http://azzalini.stat.unipd.it/SN/faq.html</span>
        <span class="s3"># delta = alpha/np.sqrt(1+alpha**2)</span>
        <span class="s1">V = stats.chi2.rvs(df</span><span class="s2">, </span><span class="s1">size=self._size)</span>
        <span class="s1">z = skewnorm.rvs(alpha</span><span class="s2">, </span><span class="s1">size=self._size)</span>
        <span class="s2">return </span><span class="s1">z / np.sqrt(V / df)</span>

    <span class="s2">def </span><span class="s1">_munp(self</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">df</span><span class="s2">, </span><span class="s1">alpha):</span>
        <span class="s3"># use pdf integration with _mom0_sc if only _pdf is defined.</span>
        <span class="s3"># default stats calculation uses ppf</span>
        <span class="s2">return </span><span class="s1">self._mom0_sc(n</span><span class="s2">, </span><span class="s1">df</span><span class="s2">, </span><span class="s1">alpha)</span>

    <span class="s2">def </span><span class="s1">_pdf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">df</span><span class="s2">, </span><span class="s1">alpha):</span>
        <span class="s3"># 2*normpdf(x)*normcdf(alpha*x)</span>
        <span class="s2">return </span><span class="s5">2.0 </span><span class="s1">* distributions.t._pdf(x</span><span class="s2">, </span><span class="s1">df) * special.stdtr(df + </span><span class="s5">1</span><span class="s2">, </span><span class="s1">alpha * x * np.sqrt(</span>
            <span class="s1">(</span><span class="s5">1 </span><span class="s1">+ df) / (x ** </span><span class="s5">2 </span><span class="s1">+ df)))</span>


<span class="s3">##</span>
<span class="s3">##def mvsk2cm(*args):</span>
<span class="s3">##    mu,sig,sk,kur = args</span>
<span class="s3">##    # Get central moments</span>
<span class="s3">##    cnt = [None]*4</span>
<span class="s3">##    cnt[0] = mu</span>
<span class="s3">##    cnt[1] = sig #*sig</span>
<span class="s3">##    cnt[2] = sk * sig**1.5</span>
<span class="s3">##    cnt[3] = (kur+3.0) * sig**2.0</span>
<span class="s3">##    return cnt</span>
<span class="s3">##</span>
<span class="s3">##</span>
<span class="s3">##def mvsk2m(args):</span>
<span class="s3">##    mc, mc2, skew, kurt = args#= self._stats(*args,**mdict)</span>
<span class="s3">##    mnc = mc</span>
<span class="s3">##    mnc2 = mc2 + mc*mc</span>
<span class="s3">##    mc3  = skew*(mc2**1.5) # 3rd central moment</span>
<span class="s3">##    mnc3 = mc3+3*mc*mc2+mc**3 # 3rd non-central moment</span>
<span class="s3">##    mc4  = (kurt+3.0)*(mc2**2.0) # 4th central moment</span>
<span class="s3">##    mnc4 = mc4+4*mc*mc3+6*mc*mc*mc2+mc**4</span>
<span class="s3">##    return (mc, mc2, mc3, mc4), (mnc, mnc2, mnc3, mnc4)</span>
<span class="s3">##</span>
<span class="s3">##def mc2mvsk(args):</span>
<span class="s3">##    mc, mc2, mc3, mc4 = args</span>
<span class="s3">##    skew = mc3 / mc2**1.5</span>
<span class="s3">##    kurt = mc4 / mc2**2.0 - 3.0</span>
<span class="s3">##    return (mc, mc2, skew, kurt)</span>
<span class="s3">##</span>
<span class="s3">##def m2mc(args):</span>
<span class="s3">##    mnc, mnc2, mnc3, mnc4 = args</span>
<span class="s3">##    mc = mnc</span>
<span class="s3">##    mc2 = mnc2 - mnc*mnc</span>
<span class="s3">##    #mc3  = skew*(mc2**1.5) # 3rd central moment</span>
<span class="s3">##    mc3 = mnc3 - (3*mc*mc2+mc**3) # 3rd central moment</span>
<span class="s3">##    #mc4  = (kurt+3.0)*(mc2**2.0) # 4th central moment</span>
<span class="s3">##    mc4 = mnc4 - (4*mc*mc3+6*mc*mc*mc2+mc**4)</span>
<span class="s3">##    return (mc, mc2, mc3, mc4)</span>


<span class="s2">def </span><span class="s1">_hermnorm(N):</span>
    <span class="s3"># return the negatively normalized hermite polynomials up to order N-1</span>
    <span class="s3">#  (inclusive)</span>
    <span class="s3">#  using the recursive relationship</span>
    <span class="s3">#  p_n+1 = p_n(x)' - x*p_n(x)</span>
    <span class="s3">#   and p_0(x) = 1</span>
    <span class="s1">plist = [</span><span class="s2">None</span><span class="s1">] * N</span>
    <span class="s1">plist[</span><span class="s5">0</span><span class="s1">] = poly1d(</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">N):</span>
        <span class="s1">plist[n] = plist[n - </span><span class="s5">1</span><span class="s1">].deriv() - poly1d([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]) * plist[n - </span><span class="s5">1</span><span class="s1">]</span>
    <span class="s2">return </span><span class="s1">plist</span>


<span class="s2">def </span><span class="s1">pdf_moments_st(cnt):</span>
    <span class="s0">&quot;&quot;&quot;Return the Gaussian expanded pdf function given the list of central 
    moments (first one is mean). 
 
    version of scipy.stats, any changes ? 
    the scipy.stats version has a bug and returns normal distribution 
    &quot;&quot;&quot;</span>

    <span class="s1">N = len(cnt)</span>
    <span class="s2">if </span><span class="s1">N &lt; </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;At least two moments must be given to &quot;</span>
                         <span class="s4">&quot;approximate the pdf.&quot;</span><span class="s1">)</span>

    <span class="s1">totp = poly1d(</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">sig = sqrt(cnt[</span><span class="s5">1</span><span class="s1">])</span>
    <span class="s1">mu = cnt[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s2">if </span><span class="s1">N &gt; </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s1">Dvals = _hermnorm(N + </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">3</span><span class="s2">, </span><span class="s1">N + </span><span class="s5">1</span><span class="s1">):</span>
        <span class="s3"># Find Ck</span>
        <span class="s1">Ck = </span><span class="s5">0.0</span>
        <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">range((k - </span><span class="s5">3</span><span class="s1">) / </span><span class="s5">2</span><span class="s1">):</span>
            <span class="s1">m = k - </span><span class="s5">2 </span><span class="s1">* n</span>
            <span class="s2">if </span><span class="s1">m % </span><span class="s5">2</span><span class="s1">:  </span><span class="s3"># m is odd</span>
                <span class="s1">momdiff = cnt[m - </span><span class="s5">1</span><span class="s1">]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">momdiff = cnt[m - </span><span class="s5">1</span><span class="s1">] - sig * sig * scipy.factorial2(m - </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">Ck += Dvals[k][m] / sig ** m * momdiff</span>
        <span class="s3"># Add to totp</span>
        <span class="s2">raise </span><span class="s1">SystemError</span>
        <span class="s1">print(Dvals)</span>
        <span class="s1">print(Ck)</span>
        <span class="s1">totp = totp + Ck * Dvals[k]</span>

    <span class="s2">def </span><span class="s1">thisfunc(x):</span>
        <span class="s1">xn = (x - mu) / sig</span>
        <span class="s2">return </span><span class="s1">totp(xn) * exp(-xn * xn / </span><span class="s5">2.0</span><span class="s1">) / sqrt(</span><span class="s5">2 </span><span class="s1">* np.pi) / sig</span>

    <span class="s2">return </span><span class="s1">thisfunc</span><span class="s2">, </span><span class="s1">totp</span>


<span class="s2">def </span><span class="s1">pdf_mvsk(mvsk):</span>
    <span class="s0">&quot;&quot;&quot;Return the Gaussian expanded pdf function given the list of 1st, 2nd 
    moment and skew and Fisher (excess) kurtosis. 
 
 
 
    Parameters 
    ---------- 
    mvsk : list of mu, mc2, skew, kurt 
        distribution is matched to these four moments 
 
    Returns 
    ------- 
    pdffunc : function 
        function that evaluates the pdf(x), where x is the non-standardized 
        random variable. 
 
 
    Notes 
    ----- 
 
    Changed so it works only if four arguments are given. Uses explicit 
    formula, not loop. 
 
    This implements a Gram-Charlier expansion of the normal distribution 
    where the first 2 moments coincide with those of the normal distribution 
    but skew and kurtosis can deviate from it. 
 
    In the Gram-Charlier distribution it is possible that the density 
    becomes negative. This is the case when the deviation from the 
    normal distribution is too large. 
 
 
 
    References 
    ---------- 
    https://en.wikipedia.org/wiki/Edgeworth_series 
    Johnson N.L., S. Kotz, N. Balakrishnan: Continuous Univariate 
    Distributions, Volume 1, 2nd ed., p.30 
    &quot;&quot;&quot;</span>
    <span class="s1">N = len(mvsk)</span>
    <span class="s2">if </span><span class="s1">N &lt; </span><span class="s5">4</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Four moments must be given to &quot;</span>
                         <span class="s4">&quot;approximate the pdf.&quot;</span><span class="s1">)</span>

    <span class="s1">mu</span><span class="s2">, </span><span class="s1">mc2</span><span class="s2">, </span><span class="s1">skew</span><span class="s2">, </span><span class="s1">kurt = mvsk</span>

    <span class="s1">totp = poly1d(</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">sig = sqrt(mc2)</span>
    <span class="s2">if </span><span class="s1">N &gt; </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s1">Dvals = _hermnorm(N + </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">C3 = skew / </span><span class="s5">6.0</span>
        <span class="s1">C4 = kurt / </span><span class="s5">24.0</span>
        <span class="s3"># Note: Hermite polynomial for order 3 in _hermnorm is negative</span>
        <span class="s3"># instead of positive</span>
        <span class="s1">totp = totp - C3 * Dvals[</span><span class="s5">3</span><span class="s1">] + C4 * Dvals[</span><span class="s5">4</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">pdffunc(x):</span>
        <span class="s1">xn = (x - mu) / sig</span>
        <span class="s2">return </span><span class="s1">totp(xn) * np.exp(-xn * xn / </span><span class="s5">2.0</span><span class="s1">) / np.sqrt(</span><span class="s5">2 </span><span class="s1">* np.pi) / sig</span>

    <span class="s2">return </span><span class="s1">pdffunc</span>


<span class="s2">def </span><span class="s1">pdf_moments(cnt):</span>
    <span class="s0">&quot;&quot;&quot;Return the Gaussian expanded pdf function given the list of central 
    moments (first one is mean). 
 
    Changed so it works only if four arguments are given. Uses explicit 
    formula, not loop. 
 
    Notes 
    ----- 
 
    This implements a Gram-Charlier expansion of the normal distribution 
    where the first 2 moments coincide with those of the normal distribution 
    but skew and kurtosis can deviate from it. 
 
    In the Gram-Charlier distribution it is possible that the density 
    becomes negative. This is the case when the deviation from the 
    normal distribution is too large. 
 
 
 
    References 
    ---------- 
    https://en.wikipedia.org/wiki/Edgeworth_series 
    Johnson N.L., S. Kotz, N. Balakrishnan: Continuous Univariate 
    Distributions, Volume 1, 2nd ed., p.30 
    &quot;&quot;&quot;</span>
    <span class="s1">N = len(cnt)</span>
    <span class="s2">if </span><span class="s1">N &lt; </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;At least two moments must be given to &quot;</span>
                         <span class="s4">&quot;approximate the pdf.&quot;</span><span class="s1">)</span>

    <span class="s1">mc</span><span class="s2">, </span><span class="s1">mc2</span><span class="s2">, </span><span class="s1">mc3</span><span class="s2">, </span><span class="s1">mc4 = cnt</span>
    <span class="s1">skew = mc3 / mc2 ** </span><span class="s5">1.5</span>
    <span class="s1">kurt = mc4 / mc2 ** </span><span class="s5">2.0 </span><span class="s1">- </span><span class="s5">3.0  </span><span class="s3"># Fisher kurtosis, excess kurtosis</span>

    <span class="s1">totp = poly1d(</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">sig = sqrt(cnt[</span><span class="s5">1</span><span class="s1">])</span>
    <span class="s1">mu = cnt[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s2">if </span><span class="s1">N &gt; </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s1">Dvals = _hermnorm(N + </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s3">##    for k in range(3,N+1):</span>
        <span class="s3">##        # Find Ck</span>
        <span class="s3">##        Ck = 0.0</span>
        <span class="s3">##        for n in range((k-3)/2):</span>
        <span class="s3">##            m = k-2*n</span>
        <span class="s3">##            if m % 2: # m is odd</span>
        <span class="s3">##                momdiff = cnt[m-1]</span>
        <span class="s3">##            else:</span>
        <span class="s3">##                momdiff = cnt[m-1] - sig*sig*scipy.factorial2(m-1)</span>
        <span class="s3">##            Ck += Dvals[k][m] / sig**m * momdiff</span>
        <span class="s3">##        # Add to totp</span>
        <span class="s3">##        raise</span>
        <span class="s3">##        print Dvals</span>
        <span class="s3">##        print Ck</span>
        <span class="s3">##        totp = totp +  Ck*Dvals[k]</span>
        <span class="s1">C3 = skew / </span><span class="s5">6.0</span>
        <span class="s1">C4 = kurt / </span><span class="s5">24.0</span>
        <span class="s1">totp = totp - C3 * Dvals[</span><span class="s5">3</span><span class="s1">] + C4 * Dvals[</span><span class="s5">4</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">thisfunc(x):</span>
        <span class="s1">xn = (x - mu) / sig</span>
        <span class="s2">return </span><span class="s1">totp(xn) * np.exp(-xn * xn / </span><span class="s5">2.0</span><span class="s1">) / np.sqrt(</span><span class="s5">2 </span><span class="s1">* np.pi) / sig</span>

    <span class="s2">return </span><span class="s1">thisfunc</span>


<span class="s2">class </span><span class="s1">NormExpan_gen(distributions.rv_continuous):</span>
    <span class="s0">'''Gram-Charlier Expansion of Normal distribution 
 
    class follows scipy.stats.distributions pattern 
    but with __init__ 
 
    '''</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">**kwds):</span>
        <span class="s3"># todo: replace with super call</span>
        <span class="s1">distributions.rv_continuous.__init__(self</span><span class="s2">,</span>
                                             <span class="s1">name=</span><span class="s4">'Normal Expansion distribution'</span><span class="s2">, </span><span class="s1">shapes=</span><span class="s4">' '</span><span class="s2">,</span>
                                             <span class="s1">)</span>
        <span class="s3">#     extradoc = '''</span>
        <span class="s3"># The distribution is defined as the Gram-Charlier expansion of</span>
        <span class="s3"># the normal distribution using the first four moments. The pdf</span>
        <span class="s3"># is given by</span>
        <span class="s3">#</span>
        <span class="s3"># pdf(x) = (1+ skew/6.0 * H(xc,3) + kurt/24.0 * H(xc,4))*normpdf(xc)</span>
        <span class="s3">#</span>
        <span class="s3"># where xc = (x-mu)/sig is the standardized value of the random variable</span>
        <span class="s3"># and H(xc,3) and H(xc,4) are Hermite polynomials</span>
        <span class="s3">#</span>
        <span class="s3"># Note: This distribution has to be parametrized during</span>
        <span class="s3"># initialization and instantiation, and does not have a shape</span>
        <span class="s3"># parameter after instantiation (similar to frozen distribution</span>
        <span class="s3"># except for location and scale.) Location and scale can be used</span>
        <span class="s3"># as with other distributions, however note, that they are relative</span>
        <span class="s3"># to the initialized distribution.</span>
        <span class="s3"># '''  )</span>
        <span class="s3"># print args, kwds</span>
        <span class="s1">mode = kwds.get(</span><span class="s4">'mode'</span><span class="s2">, </span><span class="s4">'sample'</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">mode == </span><span class="s4">'sample'</span><span class="s1">:</span>
            <span class="s1">mu</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">sk</span><span class="s2">, </span><span class="s1">kur = stats.describe(args)[</span><span class="s5">2</span><span class="s1">:]</span>
            <span class="s1">self.mvsk = (mu</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">sk</span><span class="s2">, </span><span class="s1">kur)</span>
            <span class="s1">cnt = mvsk2mc((mu</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">sk</span><span class="s2">, </span><span class="s1">kur))</span>
        <span class="s2">elif </span><span class="s1">mode == </span><span class="s4">'mvsk'</span><span class="s1">:</span>
            <span class="s1">cnt = mvsk2mc(args)</span>
            <span class="s1">self.mvsk = args</span>
        <span class="s2">elif </span><span class="s1">mode == </span><span class="s4">'centmom'</span><span class="s1">:</span>
            <span class="s1">cnt = args</span>
            <span class="s1">self.mvsk = mc2mvsk(cnt)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;mode must be 'mvsk' or centmom&quot;</span><span class="s1">)</span>

        <span class="s1">self.cnt = cnt</span>
        <span class="s3"># self.mvsk = (mu,sig,sk,kur)</span>
        <span class="s3"># self._pdf = pdf_moments(cnt)</span>
        <span class="s1">self._pdf = pdf_mvsk(self.mvsk)</span>

    <span class="s2">def </span><span class="s1">_munp(self</span><span class="s2">, </span><span class="s1">n):</span>
        <span class="s3"># use pdf integration with _mom0_sc if only _pdf is defined.</span>
        <span class="s3"># default stats calculation uses ppf</span>
        <span class="s2">return </span><span class="s1">self._mom0_sc(n)</span>

    <span class="s2">def </span><span class="s1">_stats_skip(self):</span>
        <span class="s3"># skip for now to force numerical integration of pdf for testing</span>
        <span class="s2">return </span><span class="s1">self.mvsk</span>


<span class="s3">## copied from nonlinear_transform_gen.py</span>

<span class="s4">''' A class for the distribution of a non-linear monotonic transformation of a continuous random variable 
 
simplest usage: 
example: create log-gamma distribution, i.e. y = log(x), 
            where x is gamma distributed (also available in scipy.stats) 
    loggammaexpg = Transf_gen(stats.gamma, np.log, np.exp) 
 
example: what is the distribution of the discount factor y=1/(1+x) 
            where interest rate x is normally distributed with N(mux,stdx**2)')? 
            (just to come up with a story that implies a nice transformation) 
    invnormalg = Transf_gen(stats.norm, inversew, inversew_inv, decr=True, a=-np.inf) 
 
This class does not work well for distributions with difficult shapes, 
    e.g. 1/x where x is standard normal, because of the singularity and jump at zero. 
 
Note: I'm working from my version of scipy.stats.distribution. 
      But this script runs under scipy 0.6.0 (checked with numpy: 1.2.0rc2 and python 2.4) 
 
This is not yet thoroughly tested, polished or optimized 
 
TODO: 
  * numargs handling is not yet working properly, numargs needs to be specified (default = 0 or 1) 
  * feeding args and kwargs to underlying distribution is untested and incomplete 
  * distinguish args and kwargs for the transformed and the underlying distribution 
    - currently all args and no kwargs are transmitted to underlying distribution 
    - loc and scale only work for transformed, but not for underlying distribution 
    - possible to separate args for transformation and underlying distribution parameters 
 
  * add _rvs as method, will be faster in many cases 
 
 
Created on Tuesday, October 28, 2008, 12:40:37 PM 
Author: josef-pktd 
License: BSD 
 
'''</span>


<span class="s2">def </span><span class="s1">get_u_argskwargs(**kwargs):</span>
    <span class="s3"># Todo: What's this? wrong spacing, used in Transf_gen TransfTwo_gen</span>
    <span class="s1">u_kwargs = dict((k.replace(</span><span class="s4">'u_'</span><span class="s2">, </span><span class="s4">''</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">v) </span><span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">kwargs.items()</span>
                    <span class="s2">if </span><span class="s1">k.startswith(</span><span class="s4">'u_'</span><span class="s1">))</span>
    <span class="s1">u_args = u_kwargs.pop(</span><span class="s4">'u_args'</span><span class="s2">, None</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">u_args</span><span class="s2">, </span><span class="s1">u_kwargs</span>


<span class="s2">class </span><span class="s1">Transf_gen(distributions.rv_continuous):</span>
    <span class="s0">'''a class for non-linear monotonic transformation of a continuous random variable 
 
    '''</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">kls</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">funcinv</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s3"># print args</span>
        <span class="s3"># print kwargs</span>

        <span class="s1">self.func = func</span>
        <span class="s1">self.funcinv = funcinv</span>
        <span class="s3"># explicit for self.__dict__.update(kwargs)</span>
        <span class="s3"># need to set numargs because inspection does not work</span>
        <span class="s1">self.numargs = kwargs.pop(</span><span class="s4">'numargs'</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s3"># print self.numargs</span>
        <span class="s1">name = kwargs.pop(</span><span class="s4">'name'</span><span class="s2">, </span><span class="s4">'transfdist'</span><span class="s1">)</span>
        <span class="s1">longname = kwargs.pop(</span><span class="s4">'longname'</span><span class="s2">, </span><span class="s4">'Non-linear transformed distribution'</span><span class="s1">)</span>
        <span class="s1">extradoc = kwargs.pop(</span><span class="s4">'extradoc'</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s1">a = kwargs.pop(</span><span class="s4">'a'</span><span class="s2">, </span><span class="s1">-np.inf)</span>
        <span class="s1">b = kwargs.pop(</span><span class="s4">'b'</span><span class="s2">, </span><span class="s1">np.inf)</span>
        <span class="s1">self.decr = kwargs.pop(</span><span class="s4">'decr'</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s3"># defines whether it is a decreasing (True)</span>
        <span class="s3">#       or increasing (False) monotonic transformation</span>

        <span class="s1">self.u_args</span><span class="s2">, </span><span class="s1">self.u_kwargs = get_u_argskwargs(**kwargs)</span>
        <span class="s1">self.kls = kls  </span><span class="s3"># (self.u_args, self.u_kwargs)</span>
        <span class="s3"># possible to freeze the underlying distribution</span>

        <span class="s1">super(Transf_gen</span><span class="s2">, </span><span class="s1">self).__init__(a=a</span><span class="s2">, </span><span class="s1">b=b</span><span class="s2">, </span><span class="s1">name=name</span><span class="s2">,</span>
                                         <span class="s1">longname=longname</span><span class="s2">,</span>
                                         <span class="s1">)</span>
        <span class="s3"># extradoc = extradoc)</span>

    <span class="s2">def </span><span class="s1">_rvs(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">self.kls._size = self._size</span>
        <span class="s2">return </span><span class="s1">self.funcinv(self.kls._rvs(*args))</span>

    <span class="s2">def </span><span class="s1">_cdf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s3"># print args</span>
        <span class="s2">if not </span><span class="s1">self.decr:</span>
            <span class="s2">return </span><span class="s1">self.kls._cdf(self.funcinv(x)</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
            <span class="s3"># note scipy _cdf only take *args not *kwargs</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s5">1.0 </span><span class="s1">- self.kls._cdf(self.funcinv(x)</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">_ppf(self</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s2">if not </span><span class="s1">self.decr:</span>
            <span class="s2">return </span><span class="s1">self.func(self.kls._ppf(q</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.func(self.kls._ppf(</span><span class="s5">1 </span><span class="s1">- q</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs))</span>


<span class="s2">def </span><span class="s1">inverse(x):</span>
    <span class="s2">return </span><span class="s1">np.divide(</span><span class="s5">1.0</span><span class="s2">, </span><span class="s1">x)</span>


<span class="s1">mux</span><span class="s2">, </span><span class="s1">stdx = </span><span class="s5">0.05</span><span class="s2">, </span><span class="s5">0.1</span>
<span class="s1">mux</span><span class="s2">, </span><span class="s1">stdx = </span><span class="s5">9.0</span><span class="s2">, </span><span class="s5">1.0</span>


<span class="s2">def </span><span class="s1">inversew(x):</span>
    <span class="s2">return </span><span class="s5">1.0 </span><span class="s1">/ (</span><span class="s5">1 </span><span class="s1">+ mux + x * stdx)</span>


<span class="s2">def </span><span class="s1">inversew_inv(x):</span>
    <span class="s2">return </span><span class="s1">(</span><span class="s5">1.0 </span><span class="s1">/ x - </span><span class="s5">1.0 </span><span class="s1">- mux) / stdx  </span><span class="s3"># .np.divide(1.0,x)-10</span>


<span class="s2">def </span><span class="s1">identit(x):</span>
    <span class="s2">return </span><span class="s1">x</span>


<span class="s1">invdnormalg = Transf_gen(stats.norm</span><span class="s2">, </span><span class="s1">inversew</span><span class="s2">, </span><span class="s1">inversew_inv</span><span class="s2">, </span><span class="s1">decr=</span><span class="s2">True,  </span><span class="s3"># a=-np.inf,</span>
                         <span class="s1">numargs=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">name=</span><span class="s4">'discf'</span><span class="s2">, </span><span class="s1">longname=</span><span class="s4">'normal-based discount factor'</span><span class="s2">,</span>
                         <span class="s1">extradoc=</span><span class="s4">'</span><span class="s2">\n</span><span class="s4">distribution of discount factor y=1/(1+x)) with x N(0.05,0.1**2)'</span><span class="s1">)</span>

<span class="s1">lognormalg = Transf_gen(stats.norm</span><span class="s2">, </span><span class="s1">np.exp</span><span class="s2">, </span><span class="s1">np.log</span><span class="s2">,</span>
                        <span class="s1">numargs=</span><span class="s5">2</span><span class="s2">, </span><span class="s1">a=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">name=</span><span class="s4">'lnnorm'</span><span class="s2">,</span>
                        <span class="s1">longname=</span><span class="s4">'Exp transformed normal'</span><span class="s2">,</span>
                        <span class="s3"># extradoc = '\ndistribution of y = exp(x), with x standard normal'</span>
                        <span class="s3"># 'precision for moment andstats is not very high, 2-3 decimals'</span>
                        <span class="s1">)</span>

<span class="s1">loggammaexpg = Transf_gen(stats.gamma</span><span class="s2">, </span><span class="s1">np.log</span><span class="s2">, </span><span class="s1">np.exp</span><span class="s2">, </span><span class="s1">numargs=</span><span class="s5">1</span><span class="s1">)</span>

<span class="s3">## copied form nonlinear_transform_short.py</span>

<span class="s4">'''univariate distribution of a non-linear monotonic transformation of a 
random variable 
 
'''</span>


<span class="s2">class </span><span class="s1">ExpTransf_gen(distributions.rv_continuous):</span>
    <span class="s0">'''Distribution based on log/exp transformation 
 
    the constructor can be called with a distribution class 
    and generates the distribution of the transformed random variable 
 
    '''</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">kls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s3"># print args</span>
        <span class="s3"># print kwargs</span>
        <span class="s3"># explicit for self.__dict__.update(kwargs)</span>
        <span class="s2">if </span><span class="s4">'numargs' </span><span class="s2">in </span><span class="s1">kwargs:</span>
            <span class="s1">self.numargs = kwargs[</span><span class="s4">'numargs'</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.numargs = </span><span class="s5">1</span>
        <span class="s2">if </span><span class="s4">'name' </span><span class="s2">in </span><span class="s1">kwargs:</span>
            <span class="s1">name = kwargs[</span><span class="s4">'name'</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">name = </span><span class="s4">'Log transformed distribution'</span>
        <span class="s2">if </span><span class="s4">'a' </span><span class="s2">in </span><span class="s1">kwargs:</span>
            <span class="s1">a = kwargs[</span><span class="s4">'a'</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">a = </span><span class="s5">0</span>
        <span class="s1">super(ExpTransf_gen</span><span class="s2">, </span><span class="s1">self).__init__(a=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">name=name)</span>
        <span class="s1">self.kls = kls</span>

    <span class="s2">def </span><span class="s1">_cdf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s2">pass</span>
        <span class="s3"># print args</span>
        <span class="s2">return </span><span class="s1">self.kls.cdf(np.log(x)</span><span class="s2">, </span><span class="s1">*args)</span>

    <span class="s2">def </span><span class="s1">_ppf(self</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s2">return </span><span class="s1">np.exp(self.kls.ppf(q</span><span class="s2">, </span><span class="s1">*args))</span>


<span class="s2">class </span><span class="s1">LogTransf_gen(distributions.rv_continuous):</span>
    <span class="s0">'''Distribution based on log/exp transformation 
 
    the constructor can be called with a distribution class 
    and generates the distribution of the transformed random variable 
 
    '''</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">kls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s3"># explicit for self.__dict__.update(kwargs)</span>
        <span class="s2">if </span><span class="s4">'numargs' </span><span class="s2">in </span><span class="s1">kwargs:</span>
            <span class="s1">self.numargs = kwargs[</span><span class="s4">'numargs'</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.numargs = </span><span class="s5">1</span>
        <span class="s2">if </span><span class="s4">'name' </span><span class="s2">in </span><span class="s1">kwargs:</span>
            <span class="s1">name = kwargs[</span><span class="s4">'name'</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">name = </span><span class="s4">'Log transformed distribution'</span>
        <span class="s2">if </span><span class="s4">'a' </span><span class="s2">in </span><span class="s1">kwargs:</span>
            <span class="s1">a = kwargs[</span><span class="s4">'a'</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">a = </span><span class="s5">0</span>

        <span class="s1">super(LogTransf_gen</span><span class="s2">, </span><span class="s1">self).__init__(a=a</span><span class="s2">, </span><span class="s1">name=name)</span>
        <span class="s1">self.kls = kls</span>

    <span class="s2">def </span><span class="s1">_cdf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s3"># print args</span>
        <span class="s2">return </span><span class="s1">self.kls._cdf(np.exp(x)</span><span class="s2">, </span><span class="s1">*args)</span>

    <span class="s2">def </span><span class="s1">_ppf(self</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s2">return </span><span class="s1">np.log(self.kls._ppf(q</span><span class="s2">, </span><span class="s1">*args))</span>


<span class="s3">## copied from transformtwo.py</span>

<span class="s4">''' 
Created on Apr 28, 2009 
 
@author: Josef Perktold 
'''</span>

<span class="s4">''' A class for the distribution of a non-linear u-shaped or hump shaped transformation of a 
continuous random variable 
 
This is a companion to the distributions of non-linear monotonic transformation to the case 
when the inverse mapping is a 2-valued correspondence, for example for absolute value or square 
 
simplest usage: 
example: create squared distribution, i.e. y = x**2, 
            where x is normal or t distributed 
 
 
This class does not work well for distributions with difficult shapes, 
    e.g. 1/x where x is standard normal, because of the singularity and jump at zero. 
 
 
This verifies for normal - chi2, normal - halfnorm, foldnorm, and t - F 
 
TODO: 
  * numargs handling is not yet working properly, 
    numargs needs to be specified (default = 0 or 1) 
  * feeding args and kwargs to underlying distribution works in t distribution example 
  * distinguish args and kwargs for the transformed and the underlying distribution 
    - currently all args and no kwargs are transmitted to underlying distribution 
    - loc and scale only work for transformed, but not for underlying distribution 
    - possible to separate args for transformation and underlying distribution parameters 
 
  * add _rvs as method, will be faster in many cases 
 
'''</span>


<span class="s2">class </span><span class="s1">TransfTwo_gen(distributions.rv_continuous):</span>
    <span class="s0">'''Distribution based on a non-monotonic (u- or hump-shaped transformation) 
 
    the constructor can be called with a distribution class, and functions 
    that define the non-linear transformation. 
    and generates the distribution of the transformed random variable 
 
    Note: the transformation, it's inverse and derivatives need to be fully 
    specified: func, funcinvplus, funcinvminus, derivplus,  derivminus. 
    Currently no numerical derivatives or inverse are calculated 
 
    This can be used to generate distribution instances similar to the 
    distributions in scipy.stats. 
 
    '''</span>

    <span class="s3"># a class for non-linear non-monotonic transformation of a continuous random variable</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">kls</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">funcinvplus</span><span class="s2">, </span><span class="s1">funcinvminus</span><span class="s2">, </span><span class="s1">derivplus</span><span class="s2">,</span>
                 <span class="s1">derivminus</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s3"># print args</span>
        <span class="s3"># print kwargs</span>

        <span class="s1">self.func = func</span>
        <span class="s1">self.funcinvplus = funcinvplus</span>
        <span class="s1">self.funcinvminus = funcinvminus</span>
        <span class="s1">self.derivplus = derivplus</span>
        <span class="s1">self.derivminus = derivminus</span>
        <span class="s3"># explicit for self.__dict__.update(kwargs)</span>
        <span class="s3"># need to set numargs because inspection does not work</span>
        <span class="s1">self.numargs = kwargs.pop(</span><span class="s4">'numargs'</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s3"># print self.numargs</span>
        <span class="s1">name = kwargs.pop(</span><span class="s4">'name'</span><span class="s2">, </span><span class="s4">'transfdist'</span><span class="s1">)</span>
        <span class="s1">longname = kwargs.pop(</span><span class="s4">'longname'</span><span class="s2">, </span><span class="s4">'Non-linear transformed distribution'</span><span class="s1">)</span>
        <span class="s1">extradoc = kwargs.pop(</span><span class="s4">'extradoc'</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s1">a = kwargs.pop(</span><span class="s4">'a'</span><span class="s2">, </span><span class="s1">-np.inf)  </span><span class="s3"># attached to self in super</span>
        <span class="s1">b = kwargs.pop(</span><span class="s4">'b'</span><span class="s2">, </span><span class="s1">np.inf)  </span><span class="s3"># self.a, self.b would be overwritten</span>
        <span class="s1">self.shape = kwargs.pop(</span><span class="s4">'shape'</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s3"># defines whether it is a `u` shaped or `hump' shaped</span>
        <span class="s3">#       transformation</span>

        <span class="s1">self.u_args</span><span class="s2">, </span><span class="s1">self.u_kwargs = get_u_argskwargs(**kwargs)</span>
        <span class="s1">self.kls = kls  </span><span class="s3"># (self.u_args, self.u_kwargs)</span>
        <span class="s3"># possible to freeze the underlying distribution</span>

        <span class="s1">super(TransfTwo_gen</span><span class="s2">, </span><span class="s1">self).__init__(a=a</span><span class="s2">, </span><span class="s1">b=b</span><span class="s2">, </span><span class="s1">name=name</span><span class="s2">,</span>
                                            <span class="s1">shapes=kls.shapes</span><span class="s2">,</span>
                                            <span class="s1">longname=longname</span><span class="s2">,</span>
                                            <span class="s3"># extradoc = extradoc</span>
                                            <span class="s1">)</span>

        <span class="s3"># add enough info for self.freeze() to be able to reconstruct the instance</span>
        <span class="s1">self._ctor_param.update(</span>
            <span class="s1">dict(kls=kls</span><span class="s2">, </span><span class="s1">func=func</span><span class="s2">, </span><span class="s1">funcinvplus=funcinvplus</span><span class="s2">,</span>
                 <span class="s1">funcinvminus=funcinvminus</span><span class="s2">, </span><span class="s1">derivplus=derivplus</span><span class="s2">,</span>
                 <span class="s1">derivminus=derivminus</span><span class="s2">, </span><span class="s1">shape=self.shape)</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_rvs(self</span><span class="s2">, </span><span class="s1">*args):</span>
        <span class="s1">self.kls._size = self._size  </span><span class="s3"># size attached to self, not function argument</span>
        <span class="s2">return </span><span class="s1">self.func(self.kls._rvs(*args))</span>

    <span class="s2">def </span><span class="s1">_pdf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s3"># print args</span>
        <span class="s2">if </span><span class="s1">self.shape == </span><span class="s4">'u'</span><span class="s1">:</span>
            <span class="s1">signpdf = </span><span class="s5">1</span>
        <span class="s2">elif </span><span class="s1">self.shape == </span><span class="s4">'hump'</span><span class="s1">:</span>
            <span class="s1">signpdf = -</span><span class="s5">1</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'shape can only be `u` or `hump`'</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">signpdf * (self.derivplus(x) * self.kls._pdf(self.funcinvplus(x)</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs) -</span>
                          <span class="s1">self.derivminus(x) * self.kls._pdf(self.funcinvminus(x)</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">,</span>
                                                             <span class="s1">**kwargs))</span>
        <span class="s3"># note scipy _cdf only take *args not *kwargs</span>

    <span class="s2">def </span><span class="s1">_cdf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s3"># print args</span>
        <span class="s2">if </span><span class="s1">self.shape == </span><span class="s4">'u'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.kls._cdf(self.funcinvplus(x)</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs) - \</span>
                <span class="s1">self.kls._cdf(self.funcinvminus(x)</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
            <span class="s3"># note scipy _cdf only take *args not *kwargs</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s5">1.0 </span><span class="s1">- self._sf(x</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">_sf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s3"># print args</span>
        <span class="s2">if </span><span class="s1">self.shape == </span><span class="s4">'hump'</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.kls._cdf(self.funcinvplus(x)</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs) - \</span>
                <span class="s1">self.kls._cdf(self.funcinvminus(x)</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>
            <span class="s3"># note scipy _cdf only take *args not *kwargs</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s5">1.0 </span><span class="s1">- self._cdf(x</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">_munp(self</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">args = [np.squeeze(arg) </span><span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">args]</span>
        <span class="s1">out = np.squeeze(self._mom0_sc(n</span><span class="s2">, </span><span class="s1">*args))</span>
        <span class="s2">if </span><span class="s1">np.isscalar(out):</span>
            <span class="s2">return </span><span class="s1">float(out)</span>
        <span class="s2">return </span><span class="s1">out</span>


<span class="s3"># ppf might not be possible in general case?</span>
<span class="s3"># should be possible in symmetric case</span>
<span class="s3">#    def _ppf(self, q, *args, **kwargs):</span>
<span class="s3">#        if self.shape == 'u':</span>
<span class="s3">#            return self.func(self.kls._ppf(q,*args, **kwargs))</span>
<span class="s3">#        elif self.shape == 'hump':</span>
<span class="s3">#            return self.func(self.kls._ppf(1-q,*args, **kwargs))</span>

<span class="s3"># TODO: rename these functions to have unique names</span>

<span class="s2">class </span><span class="s1">SquareFunc:</span>
    <span class="s0">'''class to hold quadratic function with inverse function and derivative 
 
    using instance methods instead of class methods, if we want extension 
    to parametrized function 
    '''</span>

    <span class="s2">def </span><span class="s1">inverseplus(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s1">np.sqrt(x)</span>

    <span class="s2">def </span><span class="s1">inverseminus(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s5">0.0 </span><span class="s1">- np.sqrt(x)</span>

    <span class="s2">def </span><span class="s1">derivplus(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s5">0.5 </span><span class="s1">/ np.sqrt(x)</span>

    <span class="s2">def </span><span class="s1">derivminus(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s5">0.0 </span><span class="s1">- </span><span class="s5">0.5 </span><span class="s1">/ np.sqrt(x)</span>

    <span class="s2">def </span><span class="s1">squarefunc(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s1">np.power(x</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>


<span class="s1">sqfunc = SquareFunc()</span>

<span class="s1">squarenormalg = TransfTwo_gen(stats.norm</span><span class="s2">, </span><span class="s1">sqfunc.squarefunc</span><span class="s2">, </span><span class="s1">sqfunc.inverseplus</span><span class="s2">,</span>
                              <span class="s1">sqfunc.inverseminus</span><span class="s2">, </span><span class="s1">sqfunc.derivplus</span><span class="s2">, </span><span class="s1">sqfunc.derivminus</span><span class="s2">,</span>
                              <span class="s1">shape=</span><span class="s4">'u'</span><span class="s2">, </span><span class="s1">a=</span><span class="s5">0.0</span><span class="s2">, </span><span class="s1">b=np.inf</span><span class="s2">,</span>
                              <span class="s1">numargs=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">name=</span><span class="s4">'squarenorm'</span><span class="s2">, </span><span class="s1">longname=</span><span class="s4">'squared normal distribution'</span><span class="s2">,</span>
                              <span class="s3"># extradoc = '\ndistribution of the square of a normal random variable' +\</span>
                              <span class="s3">#           ' y=x**2 with x N(0.0,1)'</span>
                              <span class="s1">)</span>
<span class="s3"># u_loc=l, u_scale=s)</span>
<span class="s1">squaretg = TransfTwo_gen(stats.t</span><span class="s2">, </span><span class="s1">sqfunc.squarefunc</span><span class="s2">, </span><span class="s1">sqfunc.inverseplus</span><span class="s2">,</span>
                         <span class="s1">sqfunc.inverseminus</span><span class="s2">, </span><span class="s1">sqfunc.derivplus</span><span class="s2">, </span><span class="s1">sqfunc.derivminus</span><span class="s2">,</span>
                         <span class="s1">shape=</span><span class="s4">'u'</span><span class="s2">, </span><span class="s1">a=</span><span class="s5">0.0</span><span class="s2">, </span><span class="s1">b=np.inf</span><span class="s2">,</span>
                         <span class="s1">numargs=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">name=</span><span class="s4">'squarenorm'</span><span class="s2">, </span><span class="s1">longname=</span><span class="s4">'squared t distribution'</span><span class="s2">,</span>
                         <span class="s3"># extradoc = '\ndistribution of the square of a t random variable' +\</span>
                         <span class="s3">#            ' y=x**2 with x t(dof,0.0,1)'</span>
                         <span class="s1">)</span>


<span class="s2">def </span><span class="s1">inverseplus(x):</span>
    <span class="s2">return </span><span class="s1">np.sqrt(-x)</span>


<span class="s2">def </span><span class="s1">inverseminus(x):</span>
    <span class="s2">return </span><span class="s5">0.0 </span><span class="s1">- np.sqrt(-x)</span>


<span class="s2">def </span><span class="s1">derivplus(x):</span>
    <span class="s2">return </span><span class="s5">0.0 </span><span class="s1">- </span><span class="s5">0.5 </span><span class="s1">/ np.sqrt(-x)</span>


<span class="s2">def </span><span class="s1">derivminus(x):</span>
    <span class="s2">return </span><span class="s5">0.5 </span><span class="s1">/ np.sqrt(-x)</span>


<span class="s2">def </span><span class="s1">negsquarefunc(x):</span>
    <span class="s2">return </span><span class="s1">-np.power(x</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>


<span class="s1">negsquarenormalg = TransfTwo_gen(stats.norm</span><span class="s2">, </span><span class="s1">negsquarefunc</span><span class="s2">, </span><span class="s1">inverseplus</span><span class="s2">, </span><span class="s1">inverseminus</span><span class="s2">,</span>
                                 <span class="s1">derivplus</span><span class="s2">, </span><span class="s1">derivminus</span><span class="s2">, </span><span class="s1">shape=</span><span class="s4">'hump'</span><span class="s2">, </span><span class="s1">a=-np.inf</span><span class="s2">, </span><span class="s1">b=</span><span class="s5">0.0</span><span class="s2">,</span>
                                 <span class="s1">numargs=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">name=</span><span class="s4">'negsquarenorm'</span><span class="s2">,</span>
                                 <span class="s1">longname=</span><span class="s4">'negative squared normal distribution'</span><span class="s2">,</span>
                                 <span class="s3"># extradoc = '\ndistribution of the negative square of a normal random variable' +\</span>
                                 <span class="s3">#            ' y=-x**2 with x N(0.0,1)'</span>
                                 <span class="s1">)</span>


<span class="s3"># u_loc=l, u_scale=s)</span>

<span class="s2">def </span><span class="s1">inverseplus(x):</span>
    <span class="s2">return </span><span class="s1">x</span>


<span class="s2">def </span><span class="s1">inverseminus(x):</span>
    <span class="s2">return </span><span class="s5">0.0 </span><span class="s1">- x</span>


<span class="s2">def </span><span class="s1">derivplus(x):</span>
    <span class="s2">return </span><span class="s5">1.0</span>


<span class="s2">def </span><span class="s1">derivminus(x):</span>
    <span class="s2">return </span><span class="s5">0.0 </span><span class="s1">- </span><span class="s5">1.0</span>


<span class="s2">def </span><span class="s1">absfunc(x):</span>
    <span class="s2">return </span><span class="s1">np.abs(x)</span>


<span class="s1">absnormalg = TransfTwo_gen(stats.norm</span><span class="s2">, </span><span class="s1">np.abs</span><span class="s2">, </span><span class="s1">inverseplus</span><span class="s2">, </span><span class="s1">inverseminus</span><span class="s2">,</span>
                           <span class="s1">derivplus</span><span class="s2">, </span><span class="s1">derivminus</span><span class="s2">, </span><span class="s1">shape=</span><span class="s4">'u'</span><span class="s2">, </span><span class="s1">a=</span><span class="s5">0.0</span><span class="s2">, </span><span class="s1">b=np.inf</span><span class="s2">,</span>
                           <span class="s1">numargs=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">name=</span><span class="s4">'absnorm'</span><span class="s2">, </span><span class="s1">longname=</span><span class="s4">'absolute of normal distribution'</span><span class="s2">,</span>
                           <span class="s3"># extradoc = '\ndistribution of the absolute value of a normal random variable' +\</span>
                           <span class="s3">#            ' y=abs(x) with x N(0,1)'</span>
                           <span class="s1">)</span>

<span class="s3"># copied from mvncdf.py</span>
<span class="s4">'''multivariate normal probabilities and cumulative distribution function 
a wrapper for scipy.stats._mvn.mvndst 
 
 
      SUBROUTINE MVNDST( N, LOWER, UPPER, INFIN, CORREL, MAXPTS, 
     &amp;                   ABSEPS, RELEPS, ERROR, VALUE, INFORM ) 
* 
*     A subroutine for computing multivariate normal probabilities. 
*     This subroutine uses an algorithm given in the paper 
*     &quot;Numerical Computation of Multivariate Normal Probabilities&quot;, in 
*     J. of Computational and Graphical Stat., 1(1992), pp. 141-149, by 
*          Alan Genz 
*          Department of Mathematics 
*          Washington State University 
*          Pullman, WA 99164-3113 
*          Email : AlanGenz@wsu.edu 
* 
*  Parameters 
* 
*     N      INTEGER, the number of variables. 
*     LOWER  REAL, array of lower integration limits. 
*     UPPER  REAL, array of upper integration limits. 
*     INFIN  INTEGER, array of integration limits flags: 
*            if INFIN(I) &lt; 0, Ith limits are (-infinity, infinity); 
*            if INFIN(I) = 0, Ith limits are (-infinity, UPPER(I)]; 
*            if INFIN(I) = 1, Ith limits are [LOWER(I), infinity); 
*            if INFIN(I) = 2, Ith limits are [LOWER(I), UPPER(I)]. 
*     CORREL REAL, array of correlation coefficients; the correlation 
*            coefficient in row I column J of the correlation matrix 
*            should be stored in CORREL( J + ((I-2)*(I-1))/2 ), for J &lt; I. 
*            The correlation matrix must be positive semidefinite. 
*     MAXPTS INTEGER, maximum number of function values allowed. This 
*            parameter can be used to limit the time. A sensible 
*            strategy is to start with MAXPTS = 1000*N, and then 
*            increase MAXPTS if ERROR is too large. 
*     ABSEPS REAL absolute error tolerance. 
*     RELEPS REAL relative error tolerance. 
*     ERROR  REAL estimated absolute error, with 99% confidence level. 
*     VALUE  REAL estimated value for the integral 
*     INFORM INTEGER, termination status parameter: 
*            if INFORM = 0, normal completion with ERROR &lt; EPS; 
*            if INFORM = 1, completion with ERROR &gt; EPS and MAXPTS 
*                           function vaules used; increase MAXPTS to 
*                           decrease ERROR; 
*            if INFORM = 2, N &gt; 500 or N &lt; 1. 
* 
 
 
 
&gt;&gt;&gt; mvndst([0.0,0.0],[10.0,10.0],[0,0],[0.5]) 
(2e-016, 1.0, 0) 
&gt;&gt;&gt; mvndst([0.0,0.0],[100.0,100.0],[0,0],[0.0]) 
(2e-016, 1.0, 0) 
&gt;&gt;&gt; mvndst([0.0,0.0],[1.0,1.0],[0,0],[0.0]) 
(2e-016, 0.70786098173714096, 0) 
&gt;&gt;&gt; mvndst([0.0,0.0],[0.001,1.0],[0,0],[0.0]) 
(2e-016, 0.42100802096993045, 0) 
&gt;&gt;&gt; mvndst([0.0,0.0],[0.001,10.0],[0,0],[0.0]) 
(2e-016, 0.50039894221391101, 0) 
&gt;&gt;&gt; mvndst([0.0,0.0],[0.001,100.0],[0,0],[0.0]) 
(2e-016, 0.50039894221391101, 0) 
&gt;&gt;&gt; mvndst([0.0,0.0],[0.01,100.0],[0,0],[0.0]) 
(2e-016, 0.5039893563146316, 0) 
&gt;&gt;&gt; mvndst([0.0,0.0],[0.1,100.0],[0,0],[0.0]) 
(2e-016, 0.53982783727702899, 0) 
&gt;&gt;&gt; mvndst([0.0,0.0],[0.1,100.0],[2,2],[0.0]) 
(2e-016, 0.019913918638514494, 0) 
&gt;&gt;&gt; mvndst([0.0,0.0],[0.0,0.0],[0,0],[0.0]) 
(2e-016, 0.25, 0) 
&gt;&gt;&gt; mvndst([0.0,0.0],[0.0,0.0],[-1,0],[0.0]) 
(2e-016, 0.5, 0) 
&gt;&gt;&gt; mvndst([0.0,0.0],[0.0,0.0],[-1,0],[0.5]) 
(2e-016, 0.5, 0) 
&gt;&gt;&gt; mvndst([0.0,0.0],[0.0,0.0],[0,0],[0.5]) 
(2e-016, 0.33333333333333337, 0) 
&gt;&gt;&gt; mvndst([0.0,0.0],[0.0,0.0],[0,0],[0.99]) 
(2e-016, 0.47747329317779391, 0) 
'''</span>

<span class="s1">informcode = {</span><span class="s5">0</span><span class="s1">: </span><span class="s4">'normal completion with ERROR &lt; EPS'</span><span class="s2">,</span>
              <span class="s5">1</span><span class="s1">: </span><span class="s4">'''completion with ERROR &gt; EPS and MAXPTS function values used; 
                    increase MAXPTS to decrease ERROR;'''</span><span class="s2">,</span>
              <span class="s5">2</span><span class="s1">: </span><span class="s4">'N &gt; 500 or N &lt; 1'</span><span class="s1">}</span>


<span class="s2">def </span><span class="s1">mvstdnormcdf(lower</span><span class="s2">, </span><span class="s1">upper</span><span class="s2">, </span><span class="s1">corrcoef</span><span class="s2">, </span><span class="s1">**kwds):</span>
    <span class="s0">'''standardized multivariate normal cumulative distribution function 
 
    This is a wrapper for scipy.stats._mvn.mvndst which calculates 
    a rectangular integral over a standardized multivariate normal 
    distribution. 
 
    This function assumes standardized scale, that is the variance in each dimension 
    is one, but correlation can be arbitrary, covariance = correlation matrix 
 
    Parameters 
    ---------- 
    lower, upper : array_like, 1d 
       lower and upper integration limits with length equal to the number 
       of dimensions of the multivariate normal distribution. It can contain 
       -np.inf or np.inf for open integration intervals 
    corrcoef : float or array_like 
       specifies correlation matrix in one of three ways, see notes 
    optional keyword parameters to influence integration 
        * maxpts : int, maximum number of function values allowed. This 
             parameter can be used to limit the time. A sensible 
             strategy is to start with `maxpts` = 1000*N, and then 
             increase `maxpts` if ERROR is too large. 
        * abseps : float absolute error tolerance. 
        * releps : float relative error tolerance. 
 
    Returns 
    ------- 
    cdfvalue : float 
        value of the integral 
 
 
    Notes 
    ----- 
    The correlation matrix corrcoef can be given in 3 different ways 
    If the multivariate normal is two-dimensional than only the 
    correlation coefficient needs to be provided. 
    For general dimension the correlation matrix can be provided either 
    as a one-dimensional array of the upper triangular correlation 
    coefficients stacked by rows, or as full square correlation matrix 
 
    See Also 
    -------- 
    mvnormcdf : cdf of multivariate normal distribution without 
        standardization 
 
    Examples 
    -------- 
 
    &gt;&gt;&gt; print(mvstdnormcdf([-np.inf,-np.inf], [0.0,np.inf], 0.5)) 
    0.5 
    &gt;&gt;&gt; corr = [[1.0, 0, 0.5],[0,1,0],[0.5,0,1]] 
    &gt;&gt;&gt; print(mvstdnormcdf([-np.inf,-np.inf,-100.0], [0.0,0.0,0.0], corr, abseps=1e-6)) 
    0.166666399198 
    &gt;&gt;&gt; print(mvstdnormcdf([-np.inf,-np.inf,-100.0],[0.0,0.0,0.0],corr, abseps=1e-8)) 
    something wrong completion with ERROR &gt; EPS and MAXPTS function values used; 
                        increase MAXPTS to decrease ERROR; 1.048330348e-006 
    0.166666546218 
    &gt;&gt;&gt; print(mvstdnormcdf([-np.inf,-np.inf,-100.0],[0.0,0.0,0.0], corr, \ 
                            maxpts=100000, abseps=1e-8)) 
    0.166666588293 
 
    '''</span>
    <span class="s1">n = len(lower)</span>
    <span class="s3"># do not know if converting to array is necessary,</span>
    <span class="s3"># but it makes ndim check possible</span>
    <span class="s1">lower = np.array(lower)</span>
    <span class="s1">upper = np.array(upper)</span>
    <span class="s1">corrcoef = np.array(corrcoef)</span>

    <span class="s1">correl = np.zeros(int(n * (n - </span><span class="s5">1</span><span class="s1">) / </span><span class="s5">2.0</span><span class="s1">))  </span><span class="s3"># dtype necessary?</span>

    <span class="s2">if </span><span class="s1">(lower.ndim != </span><span class="s5">1</span><span class="s1">) </span><span class="s2">or </span><span class="s1">(upper.ndim != </span><span class="s5">1</span><span class="s1">):</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'can handle only 1D bounds'</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">len(upper) != n:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'bounds have different lengths'</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">n == </span><span class="s5">2 </span><span class="s2">and </span><span class="s1">corrcoef.size == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">correl = corrcoef</span>
        <span class="s3"># print 'case scalar rho', n</span>
    <span class="s2">elif </span><span class="s1">corrcoef.ndim == </span><span class="s5">1 </span><span class="s2">and </span><span class="s1">len(corrcoef) == n * (n - </span><span class="s5">1</span><span class="s1">) / </span><span class="s5">2.0</span><span class="s1">:</span>
        <span class="s3"># print 'case flat corr', corrcoeff.shape</span>
        <span class="s1">correl = corrcoef</span>
    <span class="s2">elif </span><span class="s1">corrcoef.shape == (n</span><span class="s2">, </span><span class="s1">n):</span>
        <span class="s3"># print 'case square corr',  correl.shape</span>
        <span class="s1">correl = corrcoef[np.tril_indices(n</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)]</span>
    <span class="s3">#        for ii in range(n):</span>
    <span class="s3">#            for jj in range(ii):</span>
    <span class="s3">#                correl[ jj + ((ii-2)*(ii-1))/2] = corrcoef[ii,jj]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'corrcoef has incorrect dimension'</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s4">'maxpts' </span><span class="s2">not in </span><span class="s1">kwds:</span>
        <span class="s2">if </span><span class="s1">n &gt; </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">kwds[</span><span class="s4">'maxpts'</span><span class="s1">] = </span><span class="s5">10000 </span><span class="s1">* n</span>

    <span class="s1">lowinf = np.isneginf(lower)</span>
    <span class="s1">uppinf = np.isposinf(upper)</span>
    <span class="s1">infin = </span><span class="s5">2.0 </span><span class="s1">* np.ones(n)</span>

    <span class="s1">np.putmask(infin</span><span class="s2">, </span><span class="s1">lowinf</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)  </span><span class="s3"># infin.putmask(0,lowinf)</span>
    <span class="s1">np.putmask(infin</span><span class="s2">, </span><span class="s1">uppinf</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)  </span><span class="s3"># infin.putmask(1,uppinf)</span>
    <span class="s3"># this has to be last</span>
    <span class="s1">np.putmask(infin</span><span class="s2">, </span><span class="s1">lowinf * uppinf</span><span class="s2">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span>

    <span class="s3">##    #remove infs</span>
    <span class="s3">##    np.putmask(lower,lowinf,-100)# infin.putmask(0,lowinf)</span>
    <span class="s3">##    np.putmask(upper,uppinf,100) #infin.putmask(1,uppinf)</span>

    <span class="s3"># print lower,',',upper,',',infin,',',correl</span>
    <span class="s3"># print correl.shape</span>
    <span class="s3"># print kwds.items()</span>
    <span class="s1">error</span><span class="s2">, </span><span class="s1">cdfvalue</span><span class="s2">, </span><span class="s1">inform = mvndst(lower</span><span class="s2">, </span><span class="s1">upper</span><span class="s2">, </span><span class="s1">infin</span><span class="s2">, </span><span class="s1">correl</span><span class="s2">, </span><span class="s1">**kwds)</span>
    <span class="s2">if </span><span class="s1">inform:</span>
        <span class="s1">print(</span><span class="s4">'something wrong'</span><span class="s2">, </span><span class="s1">informcode[inform]</span><span class="s2">, </span><span class="s1">error)</span>
    <span class="s2">return </span><span class="s1">cdfvalue</span>


<span class="s2">def </span><span class="s1">mvnormcdf(upper</span><span class="s2">, </span><span class="s1">mu</span><span class="s2">, </span><span class="s1">cov</span><span class="s2">, </span><span class="s1">lower=</span><span class="s2">None, </span><span class="s1">**kwds):</span>
    <span class="s0">'''multivariate normal cumulative distribution function 
 
    This is a wrapper for scipy.stats._mvn.mvndst which calculates 
    a rectangular integral over a multivariate normal distribution. 
 
    Parameters 
    ---------- 
    lower, upper : array_like, 1d 
       lower and upper integration limits with length equal to the number 
       of dimensions of the multivariate normal distribution. It can contain 
       -np.inf or np.inf for open integration intervals 
    mu : array_lik, 1d 
       list or array of means 
    cov : array_like, 2d 
       specifies covariance matrix 
    optional keyword parameters to influence integration 
        * maxpts : int, maximum number of function values allowed. This 
             parameter can be used to limit the time. A sensible 
             strategy is to start with `maxpts` = 1000*N, and then 
             increase `maxpts` if ERROR is too large. 
        * abseps : float absolute error tolerance. 
        * releps : float relative error tolerance. 
 
    Returns 
    ------- 
    cdfvalue : float 
        value of the integral 
 
 
    Notes 
    ----- 
    This function normalizes the location and scale of the multivariate 
    normal distribution and then uses `mvstdnormcdf` to call the integration. 
 
    See Also 
    -------- 
    mvstdnormcdf : location and scale standardized multivariate normal cdf 
    '''</span>

    <span class="s1">upper = np.array(upper)</span>
    <span class="s2">if </span><span class="s1">lower </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">lower = -np.ones(upper.shape) * np.inf</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">lower = np.array(lower)</span>
    <span class="s1">cov = np.array(cov)</span>
    <span class="s1">stdev = np.sqrt(np.diag(cov))  </span><span class="s3"># standard deviation vector</span>
    <span class="s3"># do I need to make sure stdev is float and not int?</span>
    <span class="s3"># is this correct to normalize to corr?</span>
    <span class="s1">lower = (lower - mu) / stdev</span>
    <span class="s1">upper = (upper - mu) / stdev</span>
    <span class="s1">divrow = np.atleast_2d(stdev)</span>
    <span class="s1">corr = cov / divrow / divrow.T</span>
    <span class="s3"># v/np.sqrt(np.atleast_2d(np.diag(covv)))/np.sqrt(np.atleast_2d(np.diag(covv))).T</span>

    <span class="s2">return </span><span class="s1">mvstdnormcdf(lower</span><span class="s2">, </span><span class="s1">upper</span><span class="s2">, </span><span class="s1">corr</span><span class="s2">, </span><span class="s1">**kwds)</span>
</pre>
</body>
</html>