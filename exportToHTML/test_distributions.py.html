<html>
<head>
<title>test_distributions.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_distributions.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Test functions for stats module 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">import </span><span class="s1">re</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">pickle</span>
<span class="s2">from </span><span class="s1">pathlib </span><span class="s2">import </span><span class="s1">Path</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">json</span>
<span class="s2">import </span><span class="s1">platform</span>

<span class="s2">from </span><span class="s1">numpy.testing </span><span class="s2">import </span><span class="s1">(assert_equal</span><span class="s2">, </span><span class="s1">assert_array_equal</span><span class="s2">,</span>
                           <span class="s1">assert_almost_equal</span><span class="s2">, </span><span class="s1">assert_array_almost_equal</span><span class="s2">,</span>
                           <span class="s1">assert_allclose</span><span class="s2">, </span><span class="s1">assert_</span><span class="s2">, </span><span class="s1">assert_warns</span><span class="s2">,</span>
                           <span class="s1">assert_array_less</span><span class="s2">, </span><span class="s1">suppress_warnings</span><span class="s2">, </span><span class="s1">IS_PYPY)</span>
<span class="s2">import </span><span class="s1">pytest</span>
<span class="s2">from </span><span class="s1">pytest </span><span class="s2">import </span><span class="s1">raises </span><span class="s2">as </span><span class="s1">assert_raises</span>

<span class="s2">import </span><span class="s1">numpy</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">numpy </span><span class="s2">import </span><span class="s1">typecodes</span><span class="s2">, </span><span class="s1">array</span>
<span class="s2">from </span><span class="s1">numpy.lib.recfunctions </span><span class="s2">import </span><span class="s1">rec_append_fields</span>
<span class="s2">from </span><span class="s1">scipy </span><span class="s2">import </span><span class="s1">special</span>
<span class="s2">from </span><span class="s1">scipy._lib._util </span><span class="s2">import </span><span class="s1">check_random_state</span>
<span class="s2">from </span><span class="s1">scipy.integrate </span><span class="s2">import </span><span class="s1">(IntegrationWarning</span><span class="s2">, </span><span class="s1">quad</span><span class="s2">, </span><span class="s1">trapezoid</span><span class="s2">,</span>
                             <span class="s1">cumulative_trapezoid)</span>
<span class="s2">import </span><span class="s1">scipy.stats </span><span class="s2">as </span><span class="s1">stats</span>
<span class="s2">from </span><span class="s1">scipy.stats._distn_infrastructure </span><span class="s2">import </span><span class="s1">argsreduce</span>
<span class="s2">import </span><span class="s1">scipy.stats.distributions</span>

<span class="s2">from </span><span class="s1">scipy.special </span><span class="s2">import </span><span class="s1">xlogy</span><span class="s2">, </span><span class="s1">polygamma</span><span class="s2">, </span><span class="s1">entr</span>
<span class="s2">from </span><span class="s1">scipy.stats._distr_params </span><span class="s2">import </span><span class="s1">distcont</span><span class="s2">, </span><span class="s1">invdistcont</span>
<span class="s2">from </span><span class="s1">.test_discrete_basic </span><span class="s2">import </span><span class="s1">distdiscrete</span><span class="s2">, </span><span class="s1">invdistdiscrete</span>
<span class="s2">from </span><span class="s1">scipy.stats._continuous_distns </span><span class="s2">import </span><span class="s1">FitDataError</span><span class="s2">, </span><span class="s1">_argus_phi</span>
<span class="s2">from </span><span class="s1">scipy.optimize </span><span class="s2">import </span><span class="s1">root</span><span class="s2">, </span><span class="s1">fmin</span>
<span class="s2">from </span><span class="s1">itertools </span><span class="s2">import </span><span class="s1">product</span>

<span class="s3"># python -OO strips docstrings</span>
<span class="s1">DOCSTRINGS_STRIPPED = sys.flags.optimize &gt; </span><span class="s4">1</span>

<span class="s3"># Failing on macOS 11, Intel CPUs. See gh-14901</span>
<span class="s1">MACOS_INTEL = (sys.platform == </span><span class="s5">'darwin'</span><span class="s1">) </span><span class="s2">and </span><span class="s1">(platform.machine() == </span><span class="s5">'x86_64'</span><span class="s1">)</span>


<span class="s3"># distributions to skip while testing the fix for the support method</span>
<span class="s3"># introduced in gh-13294. These distributions are skipped as they</span>
<span class="s3"># always return a non-nan support for every parametrization.</span>
<span class="s1">skip_test_support_gh13294_regression = [</span><span class="s5">'tukeylambda'</span><span class="s2">, </span><span class="s5">'pearson3'</span><span class="s1">]</span>


<span class="s2">def </span><span class="s1">_assert_hasattr(a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">msg=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s2">if </span><span class="s1">msg </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">msg = </span><span class="s5">f'</span><span class="s2">{</span><span class="s1">a</span><span class="s2">} </span><span class="s5">does not have attribute </span><span class="s2">{</span><span class="s1">b</span><span class="s2">}</span><span class="s5">'</span>
    <span class="s1">assert_(hasattr(a</span><span class="s2">, </span><span class="s1">b)</span><span class="s2">, </span><span class="s1">msg=msg)</span>


<span class="s2">def </span><span class="s1">test_api_regression():</span>
    <span class="s3"># https://github.com/scipy/scipy/issues/3802</span>
    <span class="s1">_assert_hasattr(scipy.stats.distributions</span><span class="s2">, </span><span class="s5">'f_gen'</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_distributions_submodule():</span>
    <span class="s1">actual = set(scipy.stats.distributions.__all__)</span>
    <span class="s1">continuous = [dist[</span><span class="s4">0</span><span class="s1">] </span><span class="s2">for </span><span class="s1">dist </span><span class="s2">in </span><span class="s1">distcont]    </span><span class="s3"># continuous dist names</span>
    <span class="s1">discrete = [dist[</span><span class="s4">0</span><span class="s1">] </span><span class="s2">for </span><span class="s1">dist </span><span class="s2">in </span><span class="s1">distdiscrete]  </span><span class="s3"># discrete dist names</span>
    <span class="s1">other = [</span><span class="s5">'rv_discrete'</span><span class="s2">, </span><span class="s5">'rv_continuous'</span><span class="s2">, </span><span class="s5">'rv_histogram'</span><span class="s2">,</span>
             <span class="s5">'entropy'</span><span class="s2">, </span><span class="s5">'trapz'</span><span class="s1">]</span>
    <span class="s1">expected = continuous + discrete + other</span>

    <span class="s3"># need to remove, e.g.,</span>
    <span class="s3"># &lt;scipy.stats._continuous_distns.trapezoid_gen at 0x1df83bbc688&gt;</span>
    <span class="s1">expected = set(filter(</span><span class="s2">lambda </span><span class="s1">s: </span><span class="s2">not </span><span class="s1">str(s).startswith(</span><span class="s5">'&lt;'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">expected))</span>

    <span class="s2">assert </span><span class="s1">actual == expected</span>


<span class="s2">class </span><span class="s1">TestVonMises:</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'k'</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">101</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'x'</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">np.pi</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">100</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_vonmises_periodic(self</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">def </span><span class="s1">check_vonmises_pdf_periodic(k</span><span class="s2">, </span><span class="s1">L</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">x):</span>
            <span class="s1">vm = stats.vonmises(k</span><span class="s2">, </span><span class="s1">loc=L</span><span class="s2">, </span><span class="s1">scale=s)</span>
            <span class="s1">assert_almost_equal(vm.pdf(x)</span><span class="s2">, </span><span class="s1">vm.pdf(x % (</span><span class="s4">2 </span><span class="s1">* np.pi * s)))</span>

        <span class="s2">def </span><span class="s1">check_vonmises_cdf_periodic(k</span><span class="s2">, </span><span class="s1">L</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">x):</span>
            <span class="s1">vm = stats.vonmises(k</span><span class="s2">, </span><span class="s1">loc=L</span><span class="s2">, </span><span class="s1">scale=s)</span>
            <span class="s1">assert_almost_equal(vm.cdf(x) % </span><span class="s4">1</span><span class="s2">,</span>
                                <span class="s1">vm.cdf(x % (</span><span class="s4">2 </span><span class="s1">* np.pi * s)) % </span><span class="s4">1</span><span class="s1">)</span>

        <span class="s1">check_vonmises_pdf_periodic(k</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">x)</span>
        <span class="s1">check_vonmises_pdf_periodic(k</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">x)</span>
        <span class="s1">check_vonmises_pdf_periodic(k</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s1">x)</span>

        <span class="s1">check_vonmises_cdf_periodic(k</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">x)</span>
        <span class="s1">check_vonmises_cdf_periodic(k</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">x)</span>
        <span class="s1">check_vonmises_cdf_periodic(k</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s1">x)</span>

    <span class="s2">def </span><span class="s1">test_vonmises_line_support(self):</span>
        <span class="s1">assert_equal(stats.vonmises_line.a</span><span class="s2">, </span><span class="s1">-np.pi)</span>
        <span class="s1">assert_equal(stats.vonmises_line.b</span><span class="s2">, </span><span class="s1">np.pi)</span>

    <span class="s2">def </span><span class="s1">test_vonmises_numerical(self):</span>
        <span class="s1">vm = stats.vonmises(</span><span class="s4">800</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(vm.cdf(</span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)</span>

    <span class="s3"># Expected values of the vonmises PDF were computed using</span>
    <span class="s3"># mpmath with 50 digits of precision:</span>
    <span class="s3">#</span>
    <span class="s3"># def vmpdf_mp(x, kappa):</span>
    <span class="s3">#     x = mpmath.mpf(x)</span>
    <span class="s3">#     kappa = mpmath.mpf(kappa)</span>
    <span class="s3">#     num = mpmath.exp(kappa*mpmath.cos(x))</span>
    <span class="s3">#     den = 2 * mpmath.pi * mpmath.besseli(0, kappa)</span>
    <span class="s3">#     return num/den</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'x, kappa, expected_pdf'</span><span class="s2">,</span>
                             <span class="s1">[(</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.01</span><span class="s2">, </span><span class="s4">0.16074242744907072</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">25.0</span><span class="s2">, </span><span class="s4">1.7515464099118245</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">800</span><span class="s2">, </span><span class="s4">0.2073272544458798</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">0.01</span><span class="s2">, </span><span class="s4">0.15849003875385817</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">25.0</span><span class="s2">, </span><span class="s4">8.356882934278192e-16</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">800</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_vonmises_pdf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">kappa</span><span class="s2">, </span><span class="s1">expected_pdf):</span>
        <span class="s1">pdf = stats.vonmises.pdf(x</span><span class="s2">, </span><span class="s1">kappa)</span>
        <span class="s1">assert_allclose(pdf</span><span class="s2">, </span><span class="s1">expected_pdf</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-15</span><span class="s1">)</span>

    <span class="s3"># Expected values of the vonmises entropy were computed using</span>
    <span class="s3"># mpmath with 50 digits of precision:</span>
    <span class="s3">#</span>
    <span class="s3"># def vonmises_entropy(kappa):</span>
    <span class="s3">#     kappa = mpmath.mpf(kappa)</span>
    <span class="s3">#     return (-kappa * mpmath.besseli(1, kappa) /</span>
    <span class="s3">#             mpmath.besseli(0, kappa) + mpmath.log(2 * mpmath.pi *</span>
    <span class="s3">#             mpmath.besseli(0, kappa)))</span>
    <span class="s3"># &gt;&gt;&gt; float(vonmises_entropy(kappa))</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'kappa, expected_entropy'</span><span class="s2">,</span>
                             <span class="s1">[(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1.6274014590199897</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">5</span><span class="s2">, </span><span class="s4">0.6756431570114528</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">100</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.8811275441649473</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">1000</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2.03468891852547</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">2000</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2.3813876496587847</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_vonmises_entropy(self</span><span class="s2">, </span><span class="s1">kappa</span><span class="s2">, </span><span class="s1">expected_entropy):</span>
        <span class="s1">entropy = stats.vonmises.entropy(kappa)</span>
        <span class="s1">assert_allclose(entropy</span><span class="s2">, </span><span class="s1">expected_entropy</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-13</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_vonmises_rvs_gh4598(self):</span>
        <span class="s3"># check that random variates wrap around as discussed in gh-4598</span>
        <span class="s1">seed = abs(hash(</span><span class="s5">'von_mises_rvs'</span><span class="s1">))</span>
        <span class="s1">rng1 = np.random.default_rng(seed)</span>
        <span class="s1">rng2 = np.random.default_rng(seed)</span>
        <span class="s1">rng3 = np.random.default_rng(seed)</span>
        <span class="s1">rvs1 = stats.vonmises(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">1</span><span class="s1">).rvs(random_state=rng1)</span>
        <span class="s1">rvs2 = stats.vonmises(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">2</span><span class="s1">*np.pi</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">1</span><span class="s1">).rvs(random_state=rng2)</span>
        <span class="s1">rvs3 = stats.vonmises(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">0</span><span class="s2">,</span>
                              <span class="s1">scale=(</span><span class="s4">2</span><span class="s1">*np.pi/abs(rvs1)+</span><span class="s4">1</span><span class="s1">)).rvs(random_state=rng3)</span>
        <span class="s1">assert_allclose(rvs1</span><span class="s2">, </span><span class="s1">rvs2</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-15</span><span class="s1">)</span>
        <span class="s1">assert_allclose(rvs1</span><span class="s2">, </span><span class="s1">rvs3</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-15</span><span class="s1">)</span>

    <span class="s3"># Expected values of the vonmises LOGPDF were computed</span>
    <span class="s3"># using wolfram alpha:</span>
    <span class="s3"># kappa * cos(x) - log(2*pi*I0(kappa))</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'x, kappa, expected_logpdf'</span><span class="s2">,</span>
                             <span class="s1">[(</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.01</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.8279520246003170</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">25.0</span><span class="s2">, </span><span class="s4">0.5604990605420549</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">800</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.5734567947337514</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">0.01</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.8420635346185686</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">25.0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">34.7182759850871489</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">800</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1130.4942582548682739</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_vonmises_logpdf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">kappa</span><span class="s2">, </span><span class="s1">expected_logpdf):</span>
        <span class="s1">logpdf = stats.vonmises.logpdf(x</span><span class="s2">, </span><span class="s1">kappa)</span>
        <span class="s1">assert_allclose(logpdf</span><span class="s2">, </span><span class="s1">expected_logpdf</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-15</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_vonmises_expect(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Test that the vonmises expectation values are 
        computed correctly.  This test checks that the 
        numeric integration estimates the correct normalization 
        (1) and mean angle (loc).  These expectations are 
        independent of the chosen 2pi interval. 
        &quot;&quot;&quot;</span>
        <span class="s1">rng = np.random.default_rng(</span><span class="s4">6762668991392531563</span><span class="s1">)</span>

        <span class="s1">loc</span><span class="s2">, </span><span class="s1">kappa</span><span class="s2">, </span><span class="s1">lb = rng.random(</span><span class="s4">3</span><span class="s1">) * </span><span class="s4">10</span>
        <span class="s1">res = stats.vonmises(loc=loc</span><span class="s2">, </span><span class="s1">kappa=kappa).expect(</span><span class="s2">lambda </span><span class="s1">x: </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">np.issubdtype(res.dtype</span><span class="s2">, </span><span class="s1">np.floating)</span>

        <span class="s1">bounds = lb</span><span class="s2">, </span><span class="s1">lb + </span><span class="s4">2 </span><span class="s1">* np.pi</span>
        <span class="s1">res = stats.vonmises(loc=loc</span><span class="s2">, </span><span class="s1">kappa=kappa).expect(</span><span class="s2">lambda </span><span class="s1">x: </span><span class="s4">1</span><span class="s2">, </span><span class="s1">*bounds)</span>
        <span class="s1">assert_allclose(res</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">np.issubdtype(res.dtype</span><span class="s2">, </span><span class="s1">np.floating)</span>

        <span class="s1">bounds = lb</span><span class="s2">, </span><span class="s1">lb + </span><span class="s4">2 </span><span class="s1">* np.pi</span>
        <span class="s1">res = stats.vonmises(loc=loc</span><span class="s2">, </span><span class="s1">kappa=kappa).expect(</span><span class="s2">lambda </span><span class="s1">x: np.exp(</span><span class="s4">1j</span><span class="s1">*x)</span><span class="s2">,</span>
                                                          <span class="s1">*bounds</span><span class="s2">, </span><span class="s1">complex_func=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(np.angle(res)</span><span class="s2">, </span><span class="s1">loc % (</span><span class="s4">2</span><span class="s1">*np.pi))</span>
        <span class="s2">assert </span><span class="s1">np.issubdtype(res.dtype</span><span class="s2">, </span><span class="s1">np.complexfloating)</span>

    <span class="s1">@pytest.mark.xslow</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;rvs_loc&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;rvs_shape&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">100</span><span class="s2">, </span><span class="s4">1e8</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'fix_loc'</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'fix_shape'</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_fit_MLE_comp_optimizer(self</span><span class="s2">, </span><span class="s1">rvs_loc</span><span class="s2">, </span><span class="s1">rvs_shape</span><span class="s2">,</span>
                                    <span class="s1">fix_loc</span><span class="s2">, </span><span class="s1">fix_shape):</span>
        <span class="s2">if </span><span class="s1">fix_shape </span><span class="s2">and </span><span class="s1">fix_loc:</span>
            <span class="s1">pytest.skip(</span><span class="s5">&quot;Nothing to fit.&quot;</span><span class="s1">)</span>

        <span class="s1">rng = np.random.default_rng(</span><span class="s4">6762668991392531563</span><span class="s1">)</span>
        <span class="s1">data = stats.vonmises.rvs(rvs_shape</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">1000</span><span class="s2">, </span><span class="s1">loc=rvs_loc</span><span class="s2">,</span>
                                  <span class="s1">random_state=rng)</span>

        <span class="s1">kwds = {</span><span class="s5">'fscale'</span><span class="s1">: </span><span class="s4">1</span><span class="s1">}</span>
        <span class="s2">if </span><span class="s1">fix_loc:</span>
            <span class="s1">kwds[</span><span class="s5">'floc'</span><span class="s1">] = rvs_loc</span>
        <span class="s2">if </span><span class="s1">fix_shape:</span>
            <span class="s1">kwds[</span><span class="s5">'f0'</span><span class="s1">] = rvs_shape</span>

        <span class="s1">_assert_less_or_close_loglike(stats.vonmises</span><span class="s2">, </span><span class="s1">data</span><span class="s2">,</span>
                                      <span class="s1">stats.vonmises.nnlf</span><span class="s2">, </span><span class="s1">**kwds)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'loc'</span><span class="s2">, </span><span class="s1">[-</span><span class="s4">0.5 </span><span class="s1">* np.pi</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">np.pi])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'kappa_tol'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">1e-1</span><span class="s2">, </span><span class="s4">5e-2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1e2</span><span class="s2">, </span><span class="s4">1e-2</span><span class="s1">)</span><span class="s2">,</span>
                                           <span class="s1">(</span><span class="s4">1e5</span><span class="s2">, </span><span class="s4">1e-2</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_vonmises_fit_all(self</span><span class="s2">, </span><span class="s1">kappa_tol</span><span class="s2">, </span><span class="s1">loc):</span>
        <span class="s1">rng = np.random.default_rng(</span><span class="s4">6762668991392531563</span><span class="s1">)</span>
        <span class="s1">kappa</span><span class="s2">, </span><span class="s1">tol = kappa_tol</span>
        <span class="s1">data = stats.vonmises(loc=loc</span><span class="s2">, </span><span class="s1">kappa=kappa).rvs(</span><span class="s4">100000</span><span class="s2">,</span>
                                                        <span class="s1">random_state=rng)</span>
        <span class="s1">kappa_fit</span><span class="s2">, </span><span class="s1">loc_fit</span><span class="s2">, </span><span class="s1">scale_fit = stats.vonmises.fit(data)</span>
        <span class="s2">assert </span><span class="s1">scale_fit == </span><span class="s4">1</span>
        <span class="s1">loc_vec = np.array([np.cos(loc)</span><span class="s2">, </span><span class="s1">np.sin(loc)])</span>
        <span class="s1">loc_fit_vec = np.array([np.cos(loc_fit)</span><span class="s2">, </span><span class="s1">np.sin(loc_fit)])</span>
        <span class="s1">angle = np.arccos(loc_vec.dot(loc_fit_vec))</span>
        <span class="s1">assert_allclose(angle</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol=tol</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(kappa</span><span class="s2">, </span><span class="s1">kappa_fit</span><span class="s2">, </span><span class="s1">rtol=tol)</span>

    <span class="s2">def </span><span class="s1">test_vonmises_fit_shape(self):</span>
        <span class="s1">rng = np.random.default_rng(</span><span class="s4">6762668991392531563</span><span class="s1">)</span>
        <span class="s1">loc = </span><span class="s4">0.25</span><span class="s1">*np.pi</span>
        <span class="s1">kappa = </span><span class="s4">10</span>
        <span class="s1">data = stats.vonmises(loc=loc</span><span class="s2">, </span><span class="s1">kappa=kappa).rvs(</span><span class="s4">100000</span><span class="s2">, </span><span class="s1">random_state=rng)</span>
        <span class="s1">kappa_fit</span><span class="s2">, </span><span class="s1">loc_fit</span><span class="s2">, </span><span class="s1">scale_fit = stats.vonmises.fit(data</span><span class="s2">, </span><span class="s1">floc=loc)</span>
        <span class="s2">assert </span><span class="s1">loc_fit == loc</span>
        <span class="s2">assert </span><span class="s1">scale_fit == </span><span class="s4">1</span>
        <span class="s1">assert_allclose(kappa</span><span class="s2">, </span><span class="s1">kappa_fit</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-2</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.xslow</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'loc'</span><span class="s2">, </span><span class="s1">[-</span><span class="s4">0.5 </span><span class="s1">* np.pi</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.9 </span><span class="s1">* np.pi])</span>
    <span class="s2">def </span><span class="s1">test_vonmises_fit_bad_floc(self</span><span class="s2">, </span><span class="s1">loc):</span>
        <span class="s1">data = [-</span><span class="s4">0.92923506</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.32498224</span><span class="s2">, </span><span class="s4">0.13054989</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.97252014</span><span class="s2">, </span><span class="s4">2.79658071</span><span class="s2">,</span>
                <span class="s1">-</span><span class="s4">0.89110948</span><span class="s2">, </span><span class="s4">1.22520295</span><span class="s2">, </span><span class="s4">1.44398065</span><span class="s2">, </span><span class="s4">2.49163859</span><span class="s2">, </span><span class="s4">1.50315096</span><span class="s2">,</span>
                <span class="s4">3.05437696</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2.73126329</span><span class="s2">, </span><span class="s1">-</span><span class="s4">3.06272048</span><span class="s2">, </span><span class="s4">1.64647173</span><span class="s2">, </span><span class="s4">1.94509247</span><span class="s2">,</span>
                <span class="s1">-</span><span class="s4">1.14328023</span><span class="s2">, </span><span class="s4">0.8499056</span><span class="s2">, </span><span class="s4">2.36714682</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.6823179</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.88359996</span><span class="s1">]</span>
        <span class="s1">data = np.asarray(data)</span>
        <span class="s1">kappa_fit</span><span class="s2">, </span><span class="s1">loc_fit</span><span class="s2">, </span><span class="s1">scale_fit = stats.vonmises.fit(data</span><span class="s2">, </span><span class="s1">floc=loc)</span>
        <span class="s2">assert </span><span class="s1">kappa_fit == np.finfo(float).tiny</span>
        <span class="s1">_assert_less_or_close_loglike(stats.vonmises</span><span class="s2">, </span><span class="s1">data</span><span class="s2">,</span>
                                      <span class="s1">stats.vonmises.nnlf</span><span class="s2">, </span><span class="s1">fscale=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">floc=loc)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'sign'</span><span class="s2">, </span><span class="s1">[-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_vonmises_fit_unwrapped_data(self</span><span class="s2">, </span><span class="s1">sign):</span>
        <span class="s1">rng = np.random.default_rng(</span><span class="s4">6762668991392531563</span><span class="s1">)</span>
        <span class="s1">data = stats.vonmises(loc=sign*</span><span class="s4">0.5</span><span class="s1">*np.pi</span><span class="s2">, </span><span class="s1">kappa=</span><span class="s4">10</span><span class="s1">).rvs(</span><span class="s4">100000</span><span class="s2">,</span>
                                                                <span class="s1">random_state=rng)</span>
        <span class="s1">shifted_data = data + </span><span class="s4">4</span><span class="s1">*np.pi</span>
        <span class="s1">kappa_fit</span><span class="s2">, </span><span class="s1">loc_fit</span><span class="s2">, </span><span class="s1">scale_fit = stats.vonmises.fit(data)</span>
        <span class="s1">kappa_fit_shifted</span><span class="s2">, </span><span class="s1">loc_fit_shifted</span><span class="s2">, </span><span class="s1">_ = stats.vonmises.fit(shifted_data)</span>
        <span class="s1">assert_allclose(loc_fit</span><span class="s2">, </span><span class="s1">loc_fit_shifted)</span>
        <span class="s1">assert_allclose(kappa_fit</span><span class="s2">, </span><span class="s1">kappa_fit_shifted)</span>
        <span class="s2">assert </span><span class="s1">scale_fit == </span><span class="s4">1</span>
        <span class="s2">assert </span><span class="s1">-np.pi &lt; loc_fit &lt; np.pi</span>


<span class="s2">def </span><span class="s1">_assert_less_or_close_loglike(dist</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">func=</span><span class="s2">None, </span><span class="s1">**kwds):</span>
    <span class="s0">&quot;&quot;&quot; 
    This utility function checks that the negative log-likelihood function 
    (or `func`) of the result computed using dist.fit() is less than or equal 
    to the result computed using the generic fit method.  Because of 
    normal numerical imprecision, the &quot;equality&quot; check is made using 
    `np.allclose` with a relative tolerance of 1e-15. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">func </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">func = dist.nnlf</span>

    <span class="s1">mle_analytical = dist.fit(data</span><span class="s2">, </span><span class="s1">**kwds)</span>
    <span class="s1">numerical_opt = super(type(dist)</span><span class="s2">, </span><span class="s1">dist).fit(data</span><span class="s2">, </span><span class="s1">**kwds)</span>
    <span class="s1">ll_mle_analytical = func(mle_analytical</span><span class="s2">, </span><span class="s1">data)</span>
    <span class="s1">ll_numerical_opt = func(numerical_opt</span><span class="s2">, </span><span class="s1">data)</span>
    <span class="s2">assert </span><span class="s1">(ll_mle_analytical &lt;= ll_numerical_opt </span><span class="s2">or</span>
            <span class="s1">np.allclose(ll_mle_analytical</span><span class="s2">, </span><span class="s1">ll_numerical_opt</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-15</span><span class="s1">))</span>

    <span class="s3"># Ideally we'd check that shapes are correctly fixed, too, but that is</span>
    <span class="s3"># complicated by the many ways of fixing them (e.g. f0, fix_a, fa).</span>
    <span class="s2">if </span><span class="s5">'floc' </span><span class="s2">in </span><span class="s1">kwds:</span>
        <span class="s2">assert </span><span class="s1">mle_analytical[-</span><span class="s4">2</span><span class="s1">] == kwds[</span><span class="s5">'floc'</span><span class="s1">]</span>
    <span class="s2">if </span><span class="s5">'fscale' </span><span class="s2">in </span><span class="s1">kwds:</span>
        <span class="s2">assert </span><span class="s1">mle_analytical[-</span><span class="s4">1</span><span class="s1">] == kwds[</span><span class="s5">'fscale'</span><span class="s1">]</span>


<span class="s2">def </span><span class="s1">assert_fit_warnings(dist):</span>
    <span class="s1">param = [</span><span class="s5">'floc'</span><span class="s2">, </span><span class="s5">'fscale'</span><span class="s1">]</span>
    <span class="s2">if </span><span class="s1">dist.shapes:</span>
        <span class="s1">nshapes = len(dist.shapes.split(</span><span class="s5">&quot;,&quot;</span><span class="s1">))</span>
        <span class="s1">param += [</span><span class="s5">'f0'</span><span class="s2">, </span><span class="s5">'f1'</span><span class="s2">, </span><span class="s5">'f2'</span><span class="s1">][:nshapes]</span>
    <span class="s1">all_fixed = dict(zip(param</span><span class="s2">, </span><span class="s1">np.arange(len(param))))</span>
    <span class="s1">data = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span>
    <span class="s2">with </span><span class="s1">pytest.raises(RuntimeError</span><span class="s2">,</span>
                       <span class="s1">match=</span><span class="s5">&quot;All parameters fixed. There is nothing &quot;</span>
                       <span class="s5">&quot;to optimize.&quot;</span><span class="s1">):</span>
        <span class="s1">dist.fit(data</span><span class="s2">, </span><span class="s1">**all_fixed)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">,</span>
                       <span class="s1">match=</span><span class="s5">&quot;The data contains non-finite values&quot;</span><span class="s1">):</span>
        <span class="s1">dist.fit([np.nan])</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">,</span>
                       <span class="s1">match=</span><span class="s5">&quot;The data contains non-finite values&quot;</span><span class="s1">):</span>
        <span class="s1">dist.fit([np.inf])</span>
    <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=</span><span class="s5">&quot;Unknown keyword arguments:&quot;</span><span class="s1">):</span>
        <span class="s1">dist.fit(data</span><span class="s2">, </span><span class="s1">extra_keyword=</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=</span><span class="s5">&quot;Too many positional arguments.&quot;</span><span class="s1">):</span>
        <span class="s1">dist.fit(data</span><span class="s2">, </span><span class="s1">*[</span><span class="s4">1</span><span class="s1">]*(len(param) - </span><span class="s4">1</span><span class="s1">))</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s5">'dist'</span><span class="s2">,</span>
                         <span class="s1">[</span><span class="s5">'alpha'</span><span class="s2">, </span><span class="s5">'betaprime'</span><span class="s2">,</span>
                          <span class="s5">'fatiguelife'</span><span class="s2">, </span><span class="s5">'invgamma'</span><span class="s2">, </span><span class="s5">'invgauss'</span><span class="s2">, </span><span class="s5">'invweibull'</span><span class="s2">,</span>
                          <span class="s5">'johnsonsb'</span><span class="s2">, </span><span class="s5">'levy'</span><span class="s2">, </span><span class="s5">'levy_l'</span><span class="s2">, </span><span class="s5">'lognorm'</span><span class="s2">, </span><span class="s5">'gibrat'</span><span class="s2">,</span>
                          <span class="s5">'powerlognorm'</span><span class="s2">, </span><span class="s5">'rayleigh'</span><span class="s2">, </span><span class="s5">'wald'</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_support(dist):</span>
    <span class="s0">&quot;&quot;&quot;gh-6235&quot;&quot;&quot;</span>
    <span class="s1">dct = dict(distcont)</span>
    <span class="s1">args = dct[dist]</span>

    <span class="s1">dist = getattr(stats</span><span class="s2">, </span><span class="s1">dist)</span>

    <span class="s1">assert_almost_equal(dist.pdf(dist.a</span><span class="s2">, </span><span class="s1">*args)</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">assert_equal(dist.logpdf(dist.a</span><span class="s2">, </span><span class="s1">*args)</span><span class="s2">, </span><span class="s1">-np.inf)</span>
    <span class="s1">assert_almost_equal(dist.pdf(dist.b</span><span class="s2">, </span><span class="s1">*args)</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">assert_equal(dist.logpdf(dist.b</span><span class="s2">, </span><span class="s1">*args)</span><span class="s2">, </span><span class="s1">-np.inf)</span>


<span class="s2">class </span><span class="s1">TestRandInt:</span>
    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">np.random.seed(</span><span class="s4">1234</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_rvs(self):</span>
        <span class="s1">vals = stats.randint.rvs(</span><span class="s4">5</span><span class="s2">, </span><span class="s4">30</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">100</span><span class="s1">)</span>
        <span class="s1">assert_(numpy.all(vals &lt; </span><span class="s4">30</span><span class="s1">) &amp; numpy.all(vals &gt;= </span><span class="s4">5</span><span class="s1">))</span>
        <span class="s1">assert_(len(vals) == </span><span class="s4">100</span><span class="s1">)</span>
        <span class="s1">vals = stats.randint.rvs(</span><span class="s4">5</span><span class="s2">, </span><span class="s4">30</span><span class="s2">, </span><span class="s1">size=(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">50</span><span class="s1">))</span>
        <span class="s1">assert_(numpy.shape(vals) == (</span><span class="s4">2</span><span class="s2">, </span><span class="s4">50</span><span class="s1">))</span>
        <span class="s1">assert_(vals.dtype.char </span><span class="s2">in </span><span class="s1">typecodes[</span><span class="s5">'AllInteger'</span><span class="s1">])</span>
        <span class="s1">val = stats.randint.rvs(</span><span class="s4">15</span><span class="s2">, </span><span class="s4">46</span><span class="s1">)</span>
        <span class="s1">assert_((val &gt;= </span><span class="s4">15</span><span class="s1">) &amp; (val &lt; </span><span class="s4">46</span><span class="s1">))</span>
        <span class="s1">assert_(isinstance(val</span><span class="s2">, </span><span class="s1">numpy.ScalarType)</span><span class="s2">, </span><span class="s1">msg=repr(type(val)))</span>
        <span class="s1">val = stats.randint(</span><span class="s4">15</span><span class="s2">, </span><span class="s4">46</span><span class="s1">).rvs(</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">assert_(val.dtype.char </span><span class="s2">in </span><span class="s1">typecodes[</span><span class="s5">'AllInteger'</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_pdf(self):</span>
        <span class="s1">k = numpy.r_[</span><span class="s4">0</span><span class="s1">:</span><span class="s4">36</span><span class="s1">]</span>
        <span class="s1">out = numpy.where((k &gt;= </span><span class="s4">5</span><span class="s1">) &amp; (k &lt; </span><span class="s4">30</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">/(</span><span class="s4">30</span><span class="s1">-</span><span class="s4">5</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">vals = stats.randint.pmf(k</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">30</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(vals</span><span class="s2">, </span><span class="s1">out)</span>

    <span class="s2">def </span><span class="s1">test_cdf(self):</span>
        <span class="s1">x = np.linspace(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">36</span><span class="s2">, </span><span class="s4">100</span><span class="s1">)</span>
        <span class="s1">k = numpy.floor(x)</span>
        <span class="s1">out = numpy.select([k &gt;= </span><span class="s4">30</span><span class="s2">, </span><span class="s1">k &gt;= </span><span class="s4">5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">(k-</span><span class="s4">5.0</span><span class="s1">+</span><span class="s4">1</span><span class="s1">)/(</span><span class="s4">30</span><span class="s1">-</span><span class="s4">5.0</span><span class="s1">)]</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">vals = stats.randint.cdf(x</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">30</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(vals</span><span class="s2">, </span><span class="s1">out</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">12</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestBinom:</span>
    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">np.random.seed(</span><span class="s4">1234</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_rvs(self):</span>
        <span class="s1">vals = stats.binom.rvs(</span><span class="s4">10</span><span class="s2">, </span><span class="s4">0.75</span><span class="s2">, </span><span class="s1">size=(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">50</span><span class="s1">))</span>
        <span class="s1">assert_(numpy.all(vals &gt;= </span><span class="s4">0</span><span class="s1">) &amp; numpy.all(vals &lt;= </span><span class="s4">10</span><span class="s1">))</span>
        <span class="s1">assert_(numpy.shape(vals) == (</span><span class="s4">2</span><span class="s2">, </span><span class="s4">50</span><span class="s1">))</span>
        <span class="s1">assert_(vals.dtype.char </span><span class="s2">in </span><span class="s1">typecodes[</span><span class="s5">'AllInteger'</span><span class="s1">])</span>
        <span class="s1">val = stats.binom.rvs(</span><span class="s4">10</span><span class="s2">, </span><span class="s4">0.75</span><span class="s1">)</span>
        <span class="s1">assert_(isinstance(val</span><span class="s2">, </span><span class="s1">int))</span>
        <span class="s1">val = stats.binom(</span><span class="s4">10</span><span class="s2">, </span><span class="s4">0.75</span><span class="s1">).rvs(</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">assert_(isinstance(val</span><span class="s2">, </span><span class="s1">numpy.ndarray))</span>
        <span class="s1">assert_(val.dtype.char </span><span class="s2">in </span><span class="s1">typecodes[</span><span class="s5">'AllInteger'</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_pmf(self):</span>
        <span class="s3"># regression test for Ticket #1842</span>
        <span class="s1">vals1 = stats.binom.pmf(</span><span class="s4">100</span><span class="s2">, </span><span class="s4">100</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">vals2 = stats.binom.pmf(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">100</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(vals1</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-15</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(vals2</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-15</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_entropy(self):</span>
        <span class="s3"># Basic entropy tests.</span>
        <span class="s1">b = stats.binom(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)</span>
        <span class="s1">expected_p = np.array([</span><span class="s4">0.25</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.25</span><span class="s1">])</span>
        <span class="s1">expected_h = -sum(xlogy(expected_p</span><span class="s2">, </span><span class="s1">expected_p))</span>
        <span class="s1">h = b.entropy()</span>
        <span class="s1">assert_allclose(h</span><span class="s2">, </span><span class="s1">expected_h)</span>

        <span class="s1">b = stats.binom(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">)</span>
        <span class="s1">h = b.entropy()</span>
        <span class="s1">assert_equal(h</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">)</span>

        <span class="s1">b = stats.binom(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">)</span>
        <span class="s1">h = b.entropy()</span>
        <span class="s1">assert_equal(h</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_warns_p0(self):</span>
        <span class="s3"># no spurious warnigns are generated for p=0; gh-3817</span>
        <span class="s2">with </span><span class="s1">warnings.catch_warnings():</span>
            <span class="s1">warnings.simplefilter(</span><span class="s5">&quot;error&quot;</span><span class="s2">, </span><span class="s1">RuntimeWarning)</span>
            <span class="s1">assert_equal(stats.binom(n=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">p=</span><span class="s4">0</span><span class="s1">).mean()</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
            <span class="s1">assert_equal(stats.binom(n=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">p=</span><span class="s4">0</span><span class="s1">).std()</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_ppf_p1(self):</span>
        <span class="s3"># Check that gh-17388 is resolved: PPF == n when p = 1</span>
        <span class="s1">n = </span><span class="s4">4</span>
        <span class="s2">assert </span><span class="s1">stats.binom.ppf(q=</span><span class="s4">0.3</span><span class="s2">, </span><span class="s1">n=n</span><span class="s2">, </span><span class="s1">p=</span><span class="s4">1.0</span><span class="s1">) == n</span>

    <span class="s2">def </span><span class="s1">test_pmf_poisson(self):</span>
        <span class="s3"># Check that gh-17146 is resolved: binom -&gt; poisson</span>
        <span class="s1">n = </span><span class="s4">1541096362225563.0</span>
        <span class="s1">p = </span><span class="s4">1.0477878413173978e-18</span>
        <span class="s1">x = np.arange(</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">res = stats.binom.pmf(x</span><span class="s2">, </span><span class="s1">n=n</span><span class="s2">, </span><span class="s1">p=p)</span>
        <span class="s1">ref = stats.poisson.pmf(x</span><span class="s2">, </span><span class="s1">n * p)</span>
        <span class="s1">assert_allclose(res</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-16</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_pmf_cdf(self):</span>
        <span class="s3"># Check that gh-17809 is resolved: binom.pmf(0) ~ binom.cdf(0)</span>
        <span class="s1">n = </span><span class="s4">25.0 </span><span class="s1">* </span><span class="s4">10 </span><span class="s1">** </span><span class="s4">21</span>
        <span class="s1">p = </span><span class="s4">1.0 </span><span class="s1">* </span><span class="s4">10 </span><span class="s1">** -</span><span class="s4">21</span>
        <span class="s1">r = </span><span class="s4">0</span>
        <span class="s1">res = stats.binom.pmf(r</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">p)</span>
        <span class="s1">ref = stats.binom.cdf(r</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">p)</span>
        <span class="s1">assert_allclose(res</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-16</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_pmf_gh15101(self):</span>
        <span class="s3"># Check that gh-15101 is resolved (no divide warnings when p~1, n~oo)</span>
        <span class="s1">res = stats.binom.pmf(</span><span class="s4">3</span><span class="s2">, </span><span class="s4">2000</span><span class="s2">, </span><span class="s4">0.999</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-16</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestArcsine:</span>

    <span class="s2">def </span><span class="s1">test_endpoints(self):</span>
        <span class="s3"># Regression test for gh-13697.  The following calculation</span>
        <span class="s3"># should not generate a warning.</span>
        <span class="s1">p = stats.arcsine.pdf([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>
        <span class="s1">assert_equal(p</span><span class="s2">, </span><span class="s1">[np.inf</span><span class="s2">, </span><span class="s1">np.inf])</span>


<span class="s2">class </span><span class="s1">TestBernoulli:</span>
    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">np.random.seed(</span><span class="s4">1234</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_rvs(self):</span>
        <span class="s1">vals = stats.bernoulli.rvs(</span><span class="s4">0.75</span><span class="s2">, </span><span class="s1">size=(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">50</span><span class="s1">))</span>
        <span class="s1">assert_(numpy.all(vals &gt;= </span><span class="s4">0</span><span class="s1">) &amp; numpy.all(vals &lt;= </span><span class="s4">1</span><span class="s1">))</span>
        <span class="s1">assert_(numpy.shape(vals) == (</span><span class="s4">2</span><span class="s2">, </span><span class="s4">50</span><span class="s1">))</span>
        <span class="s1">assert_(vals.dtype.char </span><span class="s2">in </span><span class="s1">typecodes[</span><span class="s5">'AllInteger'</span><span class="s1">])</span>
        <span class="s1">val = stats.bernoulli.rvs(</span><span class="s4">0.75</span><span class="s1">)</span>
        <span class="s1">assert_(isinstance(val</span><span class="s2">, </span><span class="s1">int))</span>
        <span class="s1">val = stats.bernoulli(</span><span class="s4">0.75</span><span class="s1">).rvs(</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">assert_(isinstance(val</span><span class="s2">, </span><span class="s1">numpy.ndarray))</span>
        <span class="s1">assert_(val.dtype.char </span><span class="s2">in </span><span class="s1">typecodes[</span><span class="s5">'AllInteger'</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_entropy(self):</span>
        <span class="s3"># Simple tests of entropy.</span>
        <span class="s1">b = stats.bernoulli(</span><span class="s4">0.25</span><span class="s1">)</span>
        <span class="s1">expected_h = -</span><span class="s4">0.25</span><span class="s1">*np.log(</span><span class="s4">0.25</span><span class="s1">) - </span><span class="s4">0.75</span><span class="s1">*np.log(</span><span class="s4">0.75</span><span class="s1">)</span>
        <span class="s1">h = b.entropy()</span>
        <span class="s1">assert_allclose(h</span><span class="s2">, </span><span class="s1">expected_h)</span>

        <span class="s1">b = stats.bernoulli(</span><span class="s4">0.0</span><span class="s1">)</span>
        <span class="s1">h = b.entropy()</span>
        <span class="s1">assert_equal(h</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">)</span>

        <span class="s1">b = stats.bernoulli(</span><span class="s4">1.0</span><span class="s1">)</span>
        <span class="s1">h = b.entropy()</span>
        <span class="s1">assert_equal(h</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestBradford:</span>
    <span class="s3"># gh-6216</span>
    <span class="s2">def </span><span class="s1">test_cdf_ppf(self):</span>
        <span class="s1">c = </span><span class="s4">0.1</span>
        <span class="s1">x = np.logspace(-</span><span class="s4">20</span><span class="s2">, </span><span class="s1">-</span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">q = stats.bradford.cdf(x</span><span class="s2">, </span><span class="s1">c)</span>
        <span class="s1">xx = stats.bradford.ppf(q</span><span class="s2">, </span><span class="s1">c)</span>
        <span class="s1">assert_allclose(x</span><span class="s2">, </span><span class="s1">xx)</span>


<span class="s2">class </span><span class="s1">TestChi:</span>

    <span class="s3"># &quot;Exact&quot; value of chi.sf(10, 4), as computed by Wolfram Alpha with</span>
    <span class="s3">#     1 - CDF[ChiDistribution[4], 10]</span>
    <span class="s1">CHI_SF_10_4 = </span><span class="s4">9.83662422461598e-21</span>
    <span class="s3"># &quot;Exact&quot; value of chi.mean(df=1000) as computed by Wolfram Alpha with</span>
    <span class="s3">#       Mean[ChiDistribution[1000]]</span>
    <span class="s1">CHI_MEAN_1000 = </span><span class="s4">31.614871896980</span>

    <span class="s2">def </span><span class="s1">test_sf(self):</span>
        <span class="s1">s = stats.chi.sf(</span><span class="s4">10</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">assert_allclose(s</span><span class="s2">, </span><span class="s1">self.CHI_SF_10_4</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-15</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_isf(self):</span>
        <span class="s1">x = stats.chi.isf(self.CHI_SF_10_4</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">assert_allclose(x</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-15</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_mean(self):</span>
        <span class="s1">x = stats.chi.mean(df=</span><span class="s4">1000</span><span class="s1">)</span>
        <span class="s1">assert_allclose(x</span><span class="s2">, </span><span class="s1">self.CHI_MEAN_1000</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-12</span><span class="s1">)</span>

    <span class="s3"># Entropy references values were computed with the following mpmath code</span>
    <span class="s3"># from mpmath import mp</span>
    <span class="s3"># mp.dps = 50</span>
    <span class="s3"># def chi_entropy_mpmath(df):</span>
    <span class="s3">#     df = mp.mpf(df)</span>
    <span class="s3">#     half_df = 0.5 * df</span>
    <span class="s3">#     entropy = mp.log(mp.gamma(half_df)) + 0.5 * \</span>
    <span class="s3">#               (df - mp.log(2) - (df - mp.one) * mp.digamma(half_df))</span>
    <span class="s3">#     return float(entropy)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'df, ref'</span><span class="s2">,</span>
                             <span class="s1">[(</span><span class="s4">1e-4</span><span class="s2">, </span><span class="s1">-</span><span class="s4">9989.7316027504</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.7257913526447274</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">1e3</span><span class="s2">, </span><span class="s4">1.0721981095025448</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">1e10</span><span class="s2">, </span><span class="s4">1.0723649429080335</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">1e100</span><span class="s2">, </span><span class="s4">1.0723649429247002</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_entropy(self</span><span class="s2">, </span><span class="s1">df</span><span class="s2">, </span><span class="s1">ref):</span>
        <span class="s1">assert_allclose(stats.chi(df).entropy()</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-15</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestNBinom:</span>
    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">np.random.seed(</span><span class="s4">1234</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_rvs(self):</span>
        <span class="s1">vals = stats.nbinom.rvs(</span><span class="s4">10</span><span class="s2">, </span><span class="s4">0.75</span><span class="s2">, </span><span class="s1">size=(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">50</span><span class="s1">))</span>
        <span class="s1">assert_(numpy.all(vals &gt;= </span><span class="s4">0</span><span class="s1">))</span>
        <span class="s1">assert_(numpy.shape(vals) == (</span><span class="s4">2</span><span class="s2">, </span><span class="s4">50</span><span class="s1">))</span>
        <span class="s1">assert_(vals.dtype.char </span><span class="s2">in </span><span class="s1">typecodes[</span><span class="s5">'AllInteger'</span><span class="s1">])</span>
        <span class="s1">val = stats.nbinom.rvs(</span><span class="s4">10</span><span class="s2">, </span><span class="s4">0.75</span><span class="s1">)</span>
        <span class="s1">assert_(isinstance(val</span><span class="s2">, </span><span class="s1">int))</span>
        <span class="s1">val = stats.nbinom(</span><span class="s4">10</span><span class="s2">, </span><span class="s4">0.75</span><span class="s1">).rvs(</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">assert_(isinstance(val</span><span class="s2">, </span><span class="s1">numpy.ndarray))</span>
        <span class="s1">assert_(val.dtype.char </span><span class="s2">in </span><span class="s1">typecodes[</span><span class="s5">'AllInteger'</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_pmf(self):</span>
        <span class="s3"># regression test for ticket 1779</span>
        <span class="s1">assert_allclose(np.exp(stats.nbinom.logpmf(</span><span class="s4">700</span><span class="s2">, </span><span class="s4">721</span><span class="s2">, </span><span class="s4">0.52</span><span class="s1">))</span><span class="s2">,</span>
                        <span class="s1">stats.nbinom.pmf(</span><span class="s4">700</span><span class="s2">, </span><span class="s4">721</span><span class="s2">, </span><span class="s4">0.52</span><span class="s1">))</span>
        <span class="s3"># logpmf(0,1,1) shouldn't return nan (regression test for gh-4029)</span>
        <span class="s1">val = scipy.stats.nbinom.logpmf(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(val</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_logcdf_gh16159(self):</span>
        <span class="s3"># check that gh16159 is resolved.</span>
        <span class="s1">vals = stats.nbinom.logcdf([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">n=</span><span class="s4">4.8</span><span class="s2">, </span><span class="s1">p=</span><span class="s4">0.45</span><span class="s1">)</span>
        <span class="s1">ref = np.log(stats.nbinom.cdf([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">n=</span><span class="s4">4.8</span><span class="s2">, </span><span class="s1">p=</span><span class="s4">0.45</span><span class="s1">))</span>
        <span class="s1">assert_allclose(vals</span><span class="s2">, </span><span class="s1">ref)</span>


<span class="s2">class </span><span class="s1">TestGenInvGauss:</span>
    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">np.random.seed(</span><span class="s4">1234</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s2">def </span><span class="s1">test_rvs_with_mode_shift(self):</span>
        <span class="s3"># ratio_unif w/ mode shift</span>
        <span class="s1">gig = stats.geninvgauss(</span><span class="s4">2.3</span><span class="s2">, </span><span class="s4">1.5</span><span class="s1">)</span>
        <span class="s1">_</span><span class="s2">, </span><span class="s1">p = stats.kstest(gig.rvs(size=</span><span class="s4">1500</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s4">1234</span><span class="s1">)</span><span class="s2">, </span><span class="s1">gig.cdf)</span>
        <span class="s1">assert_equal(p &gt; </span><span class="s4">0.05</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s2">def </span><span class="s1">test_rvs_without_mode_shift(self):</span>
        <span class="s3"># ratio_unif w/o mode shift</span>
        <span class="s1">gig = stats.geninvgauss(</span><span class="s4">0.9</span><span class="s2">, </span><span class="s4">0.75</span><span class="s1">)</span>
        <span class="s1">_</span><span class="s2">, </span><span class="s1">p = stats.kstest(gig.rvs(size=</span><span class="s4">1500</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s4">1234</span><span class="s1">)</span><span class="s2">, </span><span class="s1">gig.cdf)</span>
        <span class="s1">assert_equal(p &gt; </span><span class="s4">0.05</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s2">def </span><span class="s1">test_rvs_new_method(self):</span>
        <span class="s3"># new algorithm of Hoermann / Leydold</span>
        <span class="s1">gig = stats.geninvgauss(</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.2</span><span class="s1">)</span>
        <span class="s1">_</span><span class="s2">, </span><span class="s1">p = stats.kstest(gig.rvs(size=</span><span class="s4">1500</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s4">1234</span><span class="s1">)</span><span class="s2">, </span><span class="s1">gig.cdf)</span>
        <span class="s1">assert_equal(p &gt; </span><span class="s4">0.05</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s2">def </span><span class="s1">test_rvs_p_zero(self):</span>
        <span class="s2">def </span><span class="s1">my_ks_check(p</span><span class="s2">, </span><span class="s1">b):</span>
            <span class="s1">gig = stats.geninvgauss(p</span><span class="s2">, </span><span class="s1">b)</span>
            <span class="s1">rvs = gig.rvs(size=</span><span class="s4">1500</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s4">1234</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">stats.kstest(rvs</span><span class="s2">, </span><span class="s1">gig.cdf)[</span><span class="s4">1</span><span class="s1">] &gt; </span><span class="s4">0.05</span>
        <span class="s3"># boundary cases when p = 0</span>
        <span class="s1">assert_equal(my_ks_check(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0.2</span><span class="s1">)</span><span class="s2">, True</span><span class="s1">)  </span><span class="s3"># new algo</span>
        <span class="s1">assert_equal(my_ks_check(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0.9</span><span class="s1">)</span><span class="s2">, True</span><span class="s1">)  </span><span class="s3"># ratio_unif w/o shift</span>
        <span class="s1">assert_equal(my_ks_check(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1.5</span><span class="s1">)</span><span class="s2">, True</span><span class="s1">)  </span><span class="s3"># ratio_unif with shift</span>

    <span class="s2">def </span><span class="s1">test_rvs_negative_p(self):</span>
        <span class="s3"># if p negative, return inverse</span>
        <span class="s1">assert_equal(</span>
                <span class="s1">stats.geninvgauss(-</span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">2</span><span class="s1">).rvs(size=</span><span class="s4">10</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s4">1234</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s4">1 </span><span class="s1">/ stats.geninvgauss(</span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">2</span><span class="s1">).rvs(size=</span><span class="s4">10</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s4">1234</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_invgauss(self):</span>
        <span class="s3"># test that invgauss is special case</span>
        <span class="s1">ig = stats.geninvgauss.rvs(size=</span><span class="s4">1500</span><span class="s2">, </span><span class="s1">p=-</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">b=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s4">1234</span><span class="s1">)</span>
        <span class="s1">assert_equal(stats.kstest(ig</span><span class="s2">, </span><span class="s5">'invgauss'</span><span class="s2">, </span><span class="s1">args=[</span><span class="s4">1</span><span class="s1">])[</span><span class="s4">1</span><span class="s1">] &gt; </span><span class="s4">0.15</span><span class="s2">, True</span><span class="s1">)</span>
        <span class="s3"># test pdf and cdf</span>
        <span class="s1">mu</span><span class="s2">, </span><span class="s1">x = </span><span class="s4">100</span><span class="s2">, </span><span class="s1">np.linspace(</span><span class="s4">0.01</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">pdf_ig = stats.geninvgauss.pdf(x</span><span class="s2">, </span><span class="s1">p=-</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">b=</span><span class="s4">1 </span><span class="s1">/ mu</span><span class="s2">, </span><span class="s1">scale=mu)</span>
        <span class="s1">assert_allclose(pdf_ig</span><span class="s2">, </span><span class="s1">stats.invgauss(mu).pdf(x))</span>
        <span class="s1">cdf_ig = stats.geninvgauss.cdf(x</span><span class="s2">, </span><span class="s1">p=-</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">b=</span><span class="s4">1 </span><span class="s1">/ mu</span><span class="s2">, </span><span class="s1">scale=mu)</span>
        <span class="s1">assert_allclose(cdf_ig</span><span class="s2">, </span><span class="s1">stats.invgauss(mu).cdf(x))</span>

    <span class="s2">def </span><span class="s1">test_pdf_R(self):</span>
        <span class="s3"># test against R package GIGrvg</span>
        <span class="s3"># x &lt;- seq(0.01, 5, length.out = 10)</span>
        <span class="s3"># GIGrvg::dgig(x, 0.5, 1, 1)</span>
        <span class="s1">vals_R = np.array([</span><span class="s4">2.081176820e-21</span><span class="s2">, </span><span class="s4">4.488660034e-01</span><span class="s2">, </span><span class="s4">3.747774338e-01</span><span class="s2">,</span>
                           <span class="s4">2.693297528e-01</span><span class="s2">, </span><span class="s4">1.905637275e-01</span><span class="s2">, </span><span class="s4">1.351476913e-01</span><span class="s2">,</span>
                           <span class="s4">9.636538981e-02</span><span class="s2">, </span><span class="s4">6.909040154e-02</span><span class="s2">, </span><span class="s4">4.978006801e-02</span><span class="s2">,</span>
                           <span class="s4">3.602084467e-02</span><span class="s1">])</span>
        <span class="s1">x = np.linspace(</span><span class="s4">0.01</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">assert_allclose(vals_R</span><span class="s2">, </span><span class="s1">stats.geninvgauss.pdf(x</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_pdf_zero(self):</span>
        <span class="s3"># pdf at 0 is 0, needs special treatment to avoid 1/x in pdf</span>
        <span class="s1">assert_equal(stats.geninvgauss.pdf(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s3"># if x is large and p is moderate, make sure that pdf does not</span>
        <span class="s3"># overflow because of x**(p-1); exp(-b*x) forces pdf to zero</span>
        <span class="s1">assert_equal(stats.geninvgauss.pdf(</span><span class="s4">2e6</span><span class="s2">, </span><span class="s4">50</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestGenHyperbolic:</span>
    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">np.random.seed(</span><span class="s4">1234</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_pdf_r(self):</span>
        <span class="s3"># test against R package GeneralizedHyperbolic</span>
        <span class="s3"># x &lt;- seq(-10, 10, length.out = 10)</span>
        <span class="s3"># GeneralizedHyperbolic::dghyp(</span>
        <span class="s3">#    x = x, lambda = 2, alpha = 2, beta = 1, delta = 1.5, mu = 0.5</span>
        <span class="s3"># )</span>
        <span class="s1">vals_R = np.array([</span>
            <span class="s4">2.94895678275316e-13</span><span class="s2">, </span><span class="s4">1.75746848647696e-10</span><span class="s2">, </span><span class="s4">9.48149804073045e-08</span><span class="s2">,</span>
            <span class="s4">4.17862521692026e-05</span><span class="s2">, </span><span class="s4">0.0103947630463822</span><span class="s2">, </span><span class="s4">0.240864958986839</span><span class="s2">,</span>
            <span class="s4">0.162833527161649</span><span class="s2">, </span><span class="s4">0.0374609592899472</span><span class="s2">, </span><span class="s4">0.00634894847327781</span><span class="s2">,</span>
            <span class="s4">0.000941920705790324</span>
            <span class="s1">])</span>

        <span class="s1">lmbda</span><span class="s2">, </span><span class="s1">alpha</span><span class="s2">, </span><span class="s1">beta = </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span>
        <span class="s1">mu</span><span class="s2">, </span><span class="s1">delta = </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1.5</span>
        <span class="s1">args = (lmbda</span><span class="s2">, </span><span class="s1">alpha*delta</span><span class="s2">, </span><span class="s1">beta*delta)</span>

        <span class="s1">gh = stats.genhyperbolic(*args</span><span class="s2">, </span><span class="s1">loc=mu</span><span class="s2">, </span><span class="s1">scale=delta)</span>
        <span class="s1">x = np.linspace(-</span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span>

        <span class="s1">assert_allclose(gh.pdf(x)</span><span class="s2">, </span><span class="s1">vals_R</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-13</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_cdf_r(self):</span>
        <span class="s3"># test against R package GeneralizedHyperbolic</span>
        <span class="s3"># q &lt;- seq(-10, 10, length.out = 10)</span>
        <span class="s3"># GeneralizedHyperbolic::pghyp(</span>
        <span class="s3">#   q = q, lambda = 2, alpha = 2, beta = 1, delta = 1.5, mu = 0.5</span>
        <span class="s3"># )</span>
        <span class="s1">vals_R = np.array([</span>
            <span class="s4">1.01881590921421e-13</span><span class="s2">, </span><span class="s4">6.13697274983578e-11</span><span class="s2">, </span><span class="s4">3.37504977637992e-08</span><span class="s2">,</span>
            <span class="s4">1.55258698166181e-05</span><span class="s2">, </span><span class="s4">0.00447005453832497</span><span class="s2">, </span><span class="s4">0.228935323956347</span><span class="s2">,</span>
            <span class="s4">0.755759458895243</span><span class="s2">, </span><span class="s4">0.953061062884484</span><span class="s2">, </span><span class="s4">0.992598013917513</span><span class="s2">,</span>
            <span class="s4">0.998942646586662</span>
            <span class="s1">])</span>

        <span class="s1">lmbda</span><span class="s2">, </span><span class="s1">alpha</span><span class="s2">, </span><span class="s1">beta = </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span>
        <span class="s1">mu</span><span class="s2">, </span><span class="s1">delta = </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1.5</span>
        <span class="s1">args = (lmbda</span><span class="s2">, </span><span class="s1">alpha*delta</span><span class="s2">, </span><span class="s1">beta*delta)</span>

        <span class="s1">gh = stats.genhyperbolic(*args</span><span class="s2">, </span><span class="s1">loc=mu</span><span class="s2">, </span><span class="s1">scale=delta)</span>
        <span class="s1">x = np.linspace(-</span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span>

        <span class="s1">assert_allclose(gh.cdf(x)</span><span class="s2">, </span><span class="s1">vals_R</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-6</span><span class="s1">)</span>

    <span class="s3"># The reference values were computed by implementing the PDF with mpmath</span>
    <span class="s3"># and integrating it with mp.quad.  The values were computed with</span>
    <span class="s3"># mp.dps=250, and then again with mp.dps=400 to ensure the full 64 bit</span>
    <span class="s3"># precision was computed.</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s5">'x, p, a, b, loc, scale, ref'</span><span class="s2">,</span>
        <span class="s1">[(-</span><span class="s4">15</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">4.770036428808252e-20</span><span class="s1">)</span><span class="s2">,</span>
         <span class="s1">(-</span><span class="s4">15</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">0.25</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">0.03282964575089294</span><span class="s1">)</span><span class="s2">,</span>
         <span class="s1">(-</span><span class="s4">15</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">1.375</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">3.3711159600215594e-23</span><span class="s1">)</span><span class="s2">,</span>
         <span class="s1">(-</span><span class="s4">15</span><span class="s2">, </span><span class="s4">0.125</span><span class="s2">, </span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">1.49995</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">4.729401428898605e-23</span><span class="s1">)</span><span class="s2">,</span>
         <span class="s1">(-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.125</span><span class="s2">, </span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">1.49995</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.0003565725914786859</span><span class="s1">)</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">5</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.125</span><span class="s2">, </span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">1.49995</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.2600651974023352</span><span class="s1">)</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">5</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.125</span><span class="s2">, </span><span class="s4">1000</span><span class="s2">, </span><span class="s4">999</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">5.923270556517253e-28</span><span class="s1">)</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">20</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.125</span><span class="s2">, </span><span class="s4">1000</span><span class="s2">, </span><span class="s4">999</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.23452293711665634</span><span class="s1">)</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">40</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.125</span><span class="s2">, </span><span class="s4">1000</span><span class="s2">, </span><span class="s4">999</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.9999648749561968</span><span class="s1">)</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">60</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.125</span><span class="s2">, </span><span class="s4">1000</span><span class="s2">, </span><span class="s4">999</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.9999999999975475</span><span class="s1">)]</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_cdf_mpmath(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale</span><span class="s2">, </span><span class="s1">ref):</span>
        <span class="s1">cdf = stats.genhyperbolic.cdf(x</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">loc=loc</span><span class="s2">, </span><span class="s1">scale=scale)</span>
        <span class="s1">assert_allclose(cdf</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">5e-12</span><span class="s1">)</span>

    <span class="s3"># The reference values were computed by implementing the PDF with mpmath</span>
    <span class="s3"># and integrating it with mp.quad.  The values were computed with</span>
    <span class="s3"># mp.dps=250, and then again with mp.dps=400 to ensure the full 64 bit</span>
    <span class="s3"># precision was computed.</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s5">'x, p, a, b, loc, scale, ref'</span><span class="s2">,</span>
        <span class="s1">[(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1e-6</span><span class="s2">, </span><span class="s4">12</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.38520358671350524</span><span class="s1">)</span><span class="s2">,</span>
         <span class="s1">(-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">2.5</span><span class="s2">, </span><span class="s4">2.375</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">0.9999901774267577</span><span class="s1">)</span><span class="s2">,</span>
         <span class="s1">(-</span><span class="s4">20</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">2.5</span><span class="s2">, </span><span class="s4">2.375</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">)</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">25</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">8.593419916523976e-10</span><span class="s1">)</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">300</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">0.25</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">6.137415609872158e-24</span><span class="s1">)</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">60</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.125</span><span class="s2">, </span><span class="s4">1000</span><span class="s2">, </span><span class="s4">999</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2.4524915075944173e-12</span><span class="s1">)</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">75</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.125</span><span class="s2">, </span><span class="s4">1000</span><span class="s2">, </span><span class="s4">999</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2.9435194886214633e-18</span><span class="s1">)]</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_sf_mpmath(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale</span><span class="s2">, </span><span class="s1">ref):</span>
        <span class="s1">sf = stats.genhyperbolic.sf(x</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">loc=loc</span><span class="s2">, </span><span class="s1">scale=scale)</span>
        <span class="s1">assert_allclose(sf</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">5e-12</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_moments_r(self):</span>
        <span class="s3"># test against R package GeneralizedHyperbolic</span>
        <span class="s3"># sapply(1:4,</span>
        <span class="s3">#    function(x) GeneralizedHyperbolic::ghypMom(</span>
        <span class="s3">#        order = x, lambda = 2, alpha = 2,</span>
        <span class="s3">#        beta = 1, delta = 1.5, mu = 0.5,</span>
        <span class="s3">#        momType = 'raw')</span>
        <span class="s3"># )</span>

        <span class="s1">vals_R = [</span><span class="s4">2.36848366948115</span><span class="s2">, </span><span class="s4">8.4739346779246</span><span class="s2">,</span>
                  <span class="s4">37.8870502710066</span><span class="s2">, </span><span class="s4">205.76608511485</span><span class="s1">]</span>

        <span class="s1">lmbda</span><span class="s2">, </span><span class="s1">alpha</span><span class="s2">, </span><span class="s1">beta = </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span>
        <span class="s1">mu</span><span class="s2">, </span><span class="s1">delta = </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1.5</span>
        <span class="s1">args = (lmbda</span><span class="s2">, </span><span class="s1">alpha*delta</span><span class="s2">, </span><span class="s1">beta*delta)</span>

        <span class="s1">vals_us = [</span>
            <span class="s1">stats.genhyperbolic(*args</span><span class="s2">, </span><span class="s1">loc=mu</span><span class="s2">, </span><span class="s1">scale=delta).moment(i)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">5</span><span class="s1">)</span>
            <span class="s1">]</span>

        <span class="s1">assert_allclose(vals_us</span><span class="s2">, </span><span class="s1">vals_R</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-13</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_rvs(self):</span>
        <span class="s3"># Kolmogorov-Smirnov test to ensure alignment</span>
        <span class="s3"># of analytical and empirical cdfs</span>

        <span class="s1">lmbda</span><span class="s2">, </span><span class="s1">alpha</span><span class="s2">, </span><span class="s1">beta = </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span>
        <span class="s1">mu</span><span class="s2">, </span><span class="s1">delta = </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1.5</span>
        <span class="s1">args = (lmbda</span><span class="s2">, </span><span class="s1">alpha*delta</span><span class="s2">, </span><span class="s1">beta*delta)</span>

        <span class="s1">gh = stats.genhyperbolic(*args</span><span class="s2">, </span><span class="s1">loc=mu</span><span class="s2">, </span><span class="s1">scale=delta)</span>
        <span class="s1">_</span><span class="s2">, </span><span class="s1">p = stats.kstest(gh.rvs(size=</span><span class="s4">1500</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s4">1234</span><span class="s1">)</span><span class="s2">, </span><span class="s1">gh.cdf)</span>

        <span class="s1">assert_equal(p &gt; </span><span class="s4">0.05</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_pdf_t(self):</span>
        <span class="s3"># Test Against T-Student with 1 - 30 df</span>
        <span class="s1">df = np.linspace(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">30</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span>

        <span class="s3"># in principle alpha should be zero in practice for big lmbdas</span>
        <span class="s3"># alpha cannot be too small else pdf does not integrate</span>
        <span class="s1">alpha</span><span class="s2">, </span><span class="s1">beta = np.float_power(df</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)*np.finfo(np.float32).eps</span><span class="s2">, </span><span class="s4">0</span>
        <span class="s1">mu</span><span class="s2">, </span><span class="s1">delta = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">np.sqrt(df)</span>
        <span class="s1">args = (-df/</span><span class="s4">2</span><span class="s2">, </span><span class="s1">alpha</span><span class="s2">, </span><span class="s1">beta)</span>

        <span class="s1">gh = stats.genhyperbolic(*args</span><span class="s2">, </span><span class="s1">loc=mu</span><span class="s2">, </span><span class="s1">scale=delta)</span>
        <span class="s1">x = np.linspace(gh.ppf(</span><span class="s4">0.01</span><span class="s1">)</span><span class="s2">, </span><span class="s1">gh.ppf(</span><span class="s4">0.99</span><span class="s1">)</span><span class="s2">, </span><span class="s4">50</span><span class="s1">)[:</span><span class="s2">, </span><span class="s1">np.newaxis]</span>

        <span class="s1">assert_allclose(</span>
            <span class="s1">gh.pdf(x)</span><span class="s2">, </span><span class="s1">stats.t.pdf(x</span><span class="s2">, </span><span class="s1">df)</span><span class="s2">,</span>
            <span class="s1">atol=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-6</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_pdf_cauchy(self):</span>
        <span class="s3"># Test Against Cauchy distribution</span>

        <span class="s3"># in principle alpha should be zero in practice for big lmbdas</span>
        <span class="s3"># alpha cannot be too small else pdf does not integrate</span>
        <span class="s1">lmbda</span><span class="s2">, </span><span class="s1">alpha</span><span class="s2">, </span><span class="s1">beta = -</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">np.finfo(np.float32).eps</span><span class="s2">, </span><span class="s4">0</span>
        <span class="s1">mu</span><span class="s2">, </span><span class="s1">delta = </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span>
        <span class="s1">args = (lmbda</span><span class="s2">, </span><span class="s1">alpha</span><span class="s2">, </span><span class="s1">beta)</span>

        <span class="s1">gh = stats.genhyperbolic(*args</span><span class="s2">, </span><span class="s1">loc=mu</span><span class="s2">, </span><span class="s1">scale=delta)</span>
        <span class="s1">x = np.linspace(gh.ppf(</span><span class="s4">0.01</span><span class="s1">)</span><span class="s2">, </span><span class="s1">gh.ppf(</span><span class="s4">0.99</span><span class="s1">)</span><span class="s2">, </span><span class="s4">50</span><span class="s1">)[:</span><span class="s2">, </span><span class="s1">np.newaxis]</span>

        <span class="s1">assert_allclose(</span>
            <span class="s1">gh.pdf(x)</span><span class="s2">, </span><span class="s1">stats.cauchy.pdf(x)</span><span class="s2">,</span>
            <span class="s1">atol=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-6</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_pdf_laplace(self):</span>
        <span class="s3"># Test Against Laplace with location param [-10, 10]</span>
        <span class="s1">loc = np.linspace(-</span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span>

        <span class="s3"># in principle delta should be zero in practice for big loc delta</span>
        <span class="s3"># cannot be too small else pdf does not integrate</span>
        <span class="s1">delta = np.finfo(np.float32).eps</span>

        <span class="s1">lmbda</span><span class="s2">, </span><span class="s1">alpha</span><span class="s2">, </span><span class="s1">beta = </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span>
        <span class="s1">args = (lmbda</span><span class="s2">, </span><span class="s1">alpha*delta</span><span class="s2">, </span><span class="s1">beta*delta)</span>

        <span class="s3"># ppf does not integrate for scale &lt; 5e-4</span>
        <span class="s3"># therefore using simple linspace to define the support</span>
        <span class="s1">gh = stats.genhyperbolic(*args</span><span class="s2">, </span><span class="s1">loc=loc</span><span class="s2">, </span><span class="s1">scale=delta)</span>
        <span class="s1">x = np.linspace(-</span><span class="s4">20</span><span class="s2">, </span><span class="s4">20</span><span class="s2">, </span><span class="s4">50</span><span class="s1">)[:</span><span class="s2">, </span><span class="s1">np.newaxis]</span>

        <span class="s1">assert_allclose(</span>
            <span class="s1">gh.pdf(x)</span><span class="s2">, </span><span class="s1">stats.laplace.pdf(x</span><span class="s2">, </span><span class="s1">loc=loc</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">atol=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-11</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_pdf_norminvgauss(self):</span>
        <span class="s3"># Test Against NIG with varying alpha/beta/delta/mu</span>

        <span class="s1">alpha</span><span class="s2">, </span><span class="s1">beta</span><span class="s2">, </span><span class="s1">delta</span><span class="s2">, </span><span class="s1">mu = (</span>
                <span class="s1">np.linspace(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">20</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">np.linspace(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">19</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)*np.float_power(-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">range(</span><span class="s4">10</span><span class="s1">))</span><span class="s2">,</span>
                <span class="s1">np.linspace(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">np.linspace(-</span><span class="s4">100</span><span class="s2">, </span><span class="s4">100</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span>
                <span class="s1">)</span>

        <span class="s1">lmbda = - </span><span class="s4">0.5</span>
        <span class="s1">args = (lmbda</span><span class="s2">, </span><span class="s1">alpha * delta</span><span class="s2">, </span><span class="s1">beta * delta)</span>

        <span class="s1">gh = stats.genhyperbolic(*args</span><span class="s2">, </span><span class="s1">loc=mu</span><span class="s2">, </span><span class="s1">scale=delta)</span>
        <span class="s1">x = np.linspace(gh.ppf(</span><span class="s4">0.01</span><span class="s1">)</span><span class="s2">, </span><span class="s1">gh.ppf(</span><span class="s4">0.99</span><span class="s1">)</span><span class="s2">, </span><span class="s4">50</span><span class="s1">)[:</span><span class="s2">, </span><span class="s1">np.newaxis]</span>

        <span class="s1">assert_allclose(</span>
            <span class="s1">gh.pdf(x)</span><span class="s2">, </span><span class="s1">stats.norminvgauss.pdf(</span>
                <span class="s1">x</span><span class="s2">, </span><span class="s1">a=alpha</span><span class="s2">, </span><span class="s1">b=beta</span><span class="s2">, </span><span class="s1">loc=mu</span><span class="s2">, </span><span class="s1">scale=delta)</span><span class="s2">,</span>
            <span class="s1">atol=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-13</span>
            <span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestNormInvGauss:</span>
    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">np.random.seed(</span><span class="s4">1234</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_cdf_R(self):</span>
        <span class="s3"># test pdf and cdf vals against R</span>
        <span class="s3"># require(&quot;GeneralizedHyperbolic&quot;)</span>
        <span class="s3"># x_test &lt;- c(-7, -5, 0, 8, 15)</span>
        <span class="s3"># r_cdf &lt;- GeneralizedHyperbolic::pnig(x_test, mu = 0, a = 1, b = 0.5)</span>
        <span class="s3"># r_pdf &lt;- GeneralizedHyperbolic::dnig(x_test, mu = 0, a = 1, b = 0.5)</span>
        <span class="s1">r_cdf = np.array([</span><span class="s4">8.034920282e-07</span><span class="s2">, </span><span class="s4">2.512671945e-05</span><span class="s2">, </span><span class="s4">3.186661051e-01</span><span class="s2">,</span>
                          <span class="s4">9.988650664e-01</span><span class="s2">, </span><span class="s4">9.999848769e-01</span><span class="s1">])</span>
        <span class="s1">x_test = np.array([-</span><span class="s4">7</span><span class="s2">, </span><span class="s1">-</span><span class="s4">5</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">15</span><span class="s1">])</span>
        <span class="s1">vals_cdf = stats.norminvgauss.cdf(x_test</span><span class="s2">, </span><span class="s1">a=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">b=</span><span class="s4">0.5</span><span class="s1">)</span>
        <span class="s1">assert_allclose(vals_cdf</span><span class="s2">, </span><span class="s1">r_cdf</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-9</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_pdf_R(self):</span>
        <span class="s3"># values from R as defined in test_cdf_R</span>
        <span class="s1">r_pdf = np.array([</span><span class="s4">1.359600783e-06</span><span class="s2">, </span><span class="s4">4.413878805e-05</span><span class="s2">, </span><span class="s4">4.555014266e-01</span><span class="s2">,</span>
                          <span class="s4">7.450485342e-04</span><span class="s2">, </span><span class="s4">8.917889931e-06</span><span class="s1">])</span>
        <span class="s1">x_test = np.array([-</span><span class="s4">7</span><span class="s2">, </span><span class="s1">-</span><span class="s4">5</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">15</span><span class="s1">])</span>
        <span class="s1">vals_pdf = stats.norminvgauss.pdf(x_test</span><span class="s2">, </span><span class="s1">a=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">b=</span><span class="s4">0.5</span><span class="s1">)</span>
        <span class="s1">assert_allclose(vals_pdf</span><span class="s2">, </span><span class="s1">r_pdf</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-9</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'x, a, b, sf, rtol'</span><span class="s2">,</span>
                             <span class="s1">[(-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0.8759652211005315</span><span class="s2">, </span><span class="s4">1e-13</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">25</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1.1318690184042579e-13</span><span class="s2">, </span><span class="s4">1e-4</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">0.002066711134653577</span><span class="s2">, </span><span class="s4">1e-12</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">10</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">2.308435233930669e-29</span><span class="s2">, </span><span class="s4">1e-9</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_sf_isf_mpmath(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">sf</span><span class="s2">, </span><span class="s1">rtol):</span>
        <span class="s3"># Reference data generated with `reference_distributions.NormInvGauss`,</span>
        <span class="s3"># e.g. `NormInvGauss(alpha=1, beta=0).sf(-1)` with mp.dps = 50</span>
        <span class="s1">s = stats.norminvgauss.sf(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b)</span>
        <span class="s1">assert_allclose(s</span><span class="s2">, </span><span class="s1">sf</span><span class="s2">, </span><span class="s1">rtol=rtol)</span>
        <span class="s1">i = stats.norminvgauss.isf(sf</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b)</span>
        <span class="s1">assert_allclose(i</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">rtol=rtol)</span>

    <span class="s2">def </span><span class="s1">test_sf_isf_mpmath_vectorized(self):</span>
        <span class="s1">x = [-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">25</span><span class="s1">]</span>
        <span class="s1">a = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">b = </span><span class="s4">0</span>
        <span class="s1">sf = [</span><span class="s4">0.8759652211005315</span><span class="s2">, </span><span class="s4">1.1318690184042579e-13</span><span class="s1">]  </span><span class="s3"># see previous test</span>
        <span class="s1">s = stats.norminvgauss.sf(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b)</span>
        <span class="s1">assert_allclose(s</span><span class="s2">, </span><span class="s1">sf</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-13</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-16</span><span class="s1">)</span>
        <span class="s1">i = stats.norminvgauss.isf(sf</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b)</span>
        <span class="s3"># Not perfect, but better than it was. See gh-13338.</span>
        <span class="s1">assert_allclose(i</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-6</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_gh8718(self):</span>
        <span class="s3"># Add test that gh-13338 resolved gh-8718</span>
        <span class="s1">dst = stats.norminvgauss(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">x = np.arange(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">20</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">sf = dst.sf(x)</span>
        <span class="s1">isf = dst.isf(sf)</span>
        <span class="s1">assert_allclose(isf</span><span class="s2">, </span><span class="s1">x)</span>

    <span class="s2">def </span><span class="s1">test_stats(self):</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">b = </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.5</span>
        <span class="s1">gamma = np.sqrt(a**</span><span class="s4">2 </span><span class="s1">- b**</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">v_stats = (b / gamma</span><span class="s2">, </span><span class="s1">a**</span><span class="s4">2 </span><span class="s1">/ gamma**</span><span class="s4">3</span><span class="s2">, </span><span class="s4">3.0 </span><span class="s1">* b / (a * np.sqrt(gamma))</span><span class="s2">,</span>
                   <span class="s4">3.0 </span><span class="s1">* (</span><span class="s4">1 </span><span class="s1">+ </span><span class="s4">4 </span><span class="s1">* b**</span><span class="s4">2 </span><span class="s1">/ a**</span><span class="s4">2</span><span class="s1">) / gamma)</span>
        <span class="s1">assert_equal(v_stats</span><span class="s2">, </span><span class="s1">stats.norminvgauss.stats(a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">moments=</span><span class="s5">'mvsk'</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_ppf(self):</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">b = </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.5</span>
        <span class="s1">x_test = np.array([</span><span class="s4">0.001</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.999</span><span class="s1">])</span>
        <span class="s1">vals = stats.norminvgauss.ppf(x_test</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b)</span>
        <span class="s1">assert_allclose(x_test</span><span class="s2">, </span><span class="s1">stats.norminvgauss.cdf(vals</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b))</span>


<span class="s2">class </span><span class="s1">TestGeom:</span>
    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">np.random.seed(</span><span class="s4">1234</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_rvs(self):</span>
        <span class="s1">vals = stats.geom.rvs(</span><span class="s4">0.75</span><span class="s2">, </span><span class="s1">size=(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">50</span><span class="s1">))</span>
        <span class="s1">assert_(numpy.all(vals &gt;= </span><span class="s4">0</span><span class="s1">))</span>
        <span class="s1">assert_(numpy.shape(vals) == (</span><span class="s4">2</span><span class="s2">, </span><span class="s4">50</span><span class="s1">))</span>
        <span class="s1">assert_(vals.dtype.char </span><span class="s2">in </span><span class="s1">typecodes[</span><span class="s5">'AllInteger'</span><span class="s1">])</span>
        <span class="s1">val = stats.geom.rvs(</span><span class="s4">0.75</span><span class="s1">)</span>
        <span class="s1">assert_(isinstance(val</span><span class="s2">, </span><span class="s1">int))</span>
        <span class="s1">val = stats.geom(</span><span class="s4">0.75</span><span class="s1">).rvs(</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">assert_(isinstance(val</span><span class="s2">, </span><span class="s1">numpy.ndarray))</span>
        <span class="s1">assert_(val.dtype.char </span><span class="s2">in </span><span class="s1">typecodes[</span><span class="s5">'AllInteger'</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_rvs_9313(self):</span>
        <span class="s3"># previously, RVS were converted to `np.int32` on some platforms,</span>
        <span class="s3"># causing overflow for moderately large integer output (gh-9313).</span>
        <span class="s3"># Check that this is resolved to the extent possible w/ `np.int64`.</span>
        <span class="s1">rng = np.random.default_rng(</span><span class="s4">649496242618848</span><span class="s1">)</span>
        <span class="s1">rvs = stats.geom.rvs(np.exp(-</span><span class="s4">35</span><span class="s1">)</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">random_state=rng)</span>
        <span class="s2">assert </span><span class="s1">rvs.dtype == np.int64</span>
        <span class="s2">assert </span><span class="s1">np.all(rvs &gt; np.iinfo(np.int32).max)</span>

    <span class="s2">def </span><span class="s1">test_pmf(self):</span>
        <span class="s1">vals = stats.geom.pmf([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(vals</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.25</span><span class="s2">, </span><span class="s4">0.125</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_logpmf(self):</span>
        <span class="s3"># regression test for ticket 1793</span>
        <span class="s1">vals1 = np.log(stats.geom.pmf([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">))</span>
        <span class="s1">vals2 = stats.geom.logpmf([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)</span>
        <span class="s1">assert_allclose(vals1</span><span class="s2">, </span><span class="s1">vals2</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-15</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s3"># regression test for gh-4028</span>
        <span class="s1">val = stats.geom.logpmf(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(val</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_cdf_sf(self):</span>
        <span class="s1">vals = stats.geom.cdf([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)</span>
        <span class="s1">vals_sf = stats.geom.sf([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)</span>
        <span class="s1">expected = array([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.75</span><span class="s2">, </span><span class="s4">0.875</span><span class="s1">])</span>
        <span class="s1">assert_array_almost_equal(vals</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">assert_array_almost_equal(vals_sf</span><span class="s2">, </span><span class="s4">1</span><span class="s1">-expected)</span>

    <span class="s2">def </span><span class="s1">test_logcdf_logsf(self):</span>
        <span class="s1">vals = stats.geom.logcdf([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)</span>
        <span class="s1">vals_sf = stats.geom.logsf([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)</span>
        <span class="s1">expected = array([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.75</span><span class="s2">, </span><span class="s4">0.875</span><span class="s1">])</span>
        <span class="s1">assert_array_almost_equal(vals</span><span class="s2">, </span><span class="s1">np.log(expected))</span>
        <span class="s1">assert_array_almost_equal(vals_sf</span><span class="s2">, </span><span class="s1">np.log1p(-expected))</span>

    <span class="s2">def </span><span class="s1">test_ppf(self):</span>
        <span class="s1">vals = stats.geom.ppf([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.75</span><span class="s2">, </span><span class="s4">0.875</span><span class="s1">]</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)</span>
        <span class="s1">expected = array([</span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">3.0</span><span class="s1">])</span>
        <span class="s1">assert_array_almost_equal(vals</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_ppf_underflow(self):</span>
        <span class="s3"># this should not underflow</span>
        <span class="s1">assert_allclose(stats.geom.ppf(</span><span class="s4">1e-20</span><span class="s2">, </span><span class="s4">1e-20</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-14</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_entropy_gh18226(self):</span>
        <span class="s3"># gh-18226 reported that `geom.entropy` produced a warning and</span>
        <span class="s3"># inaccurate output for small p. Check that this is resolved.</span>
        <span class="s1">h = stats.geom(</span><span class="s4">0.0146</span><span class="s1">).entropy()</span>
        <span class="s1">assert_allclose(h</span><span class="s2">, </span><span class="s4">5.219397961962308</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-15</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestPlanck:</span>
    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">np.random.seed(</span><span class="s4">1234</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_sf(self):</span>
        <span class="s1">vals = stats.planck.sf([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s4">5.</span><span class="s1">)</span>
        <span class="s1">expected = array([</span><span class="s4">4.5399929762484854e-05</span><span class="s2">,</span>
                          <span class="s4">3.0590232050182579e-07</span><span class="s2">,</span>
                          <span class="s4">2.0611536224385579e-09</span><span class="s1">])</span>
        <span class="s1">assert_array_almost_equal(vals</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_logsf(self):</span>
        <span class="s1">vals = stats.planck.logsf([</span><span class="s4">1000.</span><span class="s2">, </span><span class="s4">2000.</span><span class="s2">, </span><span class="s4">3000.</span><span class="s1">]</span><span class="s2">, </span><span class="s4">1000.</span><span class="s1">)</span>
        <span class="s1">expected = array([-</span><span class="s4">1001000.</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2001000.</span><span class="s2">, </span><span class="s1">-</span><span class="s4">3001000.</span><span class="s1">])</span>
        <span class="s1">assert_array_almost_equal(vals</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">class </span><span class="s1">TestGennorm:</span>
    <span class="s2">def </span><span class="s1">test_laplace(self):</span>
        <span class="s3"># test against Laplace (special case for beta=1)</span>
        <span class="s1">points = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span>
        <span class="s1">pdf1 = stats.gennorm.pdf(points</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">pdf2 = stats.laplace.pdf(points)</span>
        <span class="s1">assert_almost_equal(pdf1</span><span class="s2">, </span><span class="s1">pdf2)</span>

    <span class="s2">def </span><span class="s1">test_norm(self):</span>
        <span class="s3"># test against normal (special case for beta=2)</span>
        <span class="s1">points = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span>
        <span class="s1">pdf1 = stats.gennorm.pdf(points</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">pdf2 = stats.norm.pdf(points</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">2</span><span class="s1">**-</span><span class="s4">.5</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(pdf1</span><span class="s2">, </span><span class="s1">pdf2)</span>

    <span class="s2">def </span><span class="s1">test_rvs(self):</span>
        <span class="s1">np.random.seed(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s3"># 0 &lt; beta &lt; 1</span>
        <span class="s1">dist = stats.gennorm(</span><span class="s4">0.5</span><span class="s1">)</span>
        <span class="s1">rvs = dist.rvs(size=</span><span class="s4">1000</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">stats.kstest(rvs</span><span class="s2">, </span><span class="s1">dist.cdf).pvalue &gt; </span><span class="s4">0.1</span>
        <span class="s3"># beta = 1</span>
        <span class="s1">dist = stats.gennorm(</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">rvs = dist.rvs(size=</span><span class="s4">1000</span><span class="s1">)</span>
        <span class="s1">rvs_laplace = stats.laplace.rvs(size=</span><span class="s4">1000</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">stats.ks_2samp(rvs</span><span class="s2">, </span><span class="s1">rvs_laplace).pvalue &gt; </span><span class="s4">0.1</span>
        <span class="s3"># beta = 2</span>
        <span class="s1">dist = stats.gennorm(</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">rvs = dist.rvs(size=</span><span class="s4">1000</span><span class="s1">)</span>
        <span class="s1">rvs_norm = stats.norm.rvs(scale=</span><span class="s4">1</span><span class="s1">/</span><span class="s4">2</span><span class="s1">**</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">1000</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">stats.ks_2samp(rvs</span><span class="s2">, </span><span class="s1">rvs_norm).pvalue &gt; </span><span class="s4">0.1</span>

    <span class="s2">def </span><span class="s1">test_rvs_broadcasting(self):</span>
        <span class="s1">np.random.seed(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">dist = stats.gennorm([[</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2.</span><span class="s2">, </span><span class="s4">5.</span><span class="s1">]])</span>
        <span class="s1">rvs = dist.rvs(size=[</span><span class="s4">1000</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">])</span>
        <span class="s2">assert </span><span class="s1">stats.kstest(rvs[:</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">stats.gennorm(</span><span class="s4">0.5</span><span class="s1">).cdf)[</span><span class="s4">1</span><span class="s1">] &gt; </span><span class="s4">0.1</span>
        <span class="s2">assert </span><span class="s1">stats.kstest(rvs[:</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">stats.gennorm(</span><span class="s4">1.0</span><span class="s1">).cdf)[</span><span class="s4">1</span><span class="s1">] &gt; </span><span class="s4">0.1</span>
        <span class="s2">assert </span><span class="s1">stats.kstest(rvs[:</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">stats.gennorm(</span><span class="s4">2.0</span><span class="s1">).cdf)[</span><span class="s4">1</span><span class="s1">] &gt; </span><span class="s4">0.1</span>
        <span class="s2">assert </span><span class="s1">stats.kstest(rvs[:</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">stats.gennorm(</span><span class="s4">5.0</span><span class="s1">).cdf)[</span><span class="s4">1</span><span class="s1">] &gt; </span><span class="s4">0.1</span>


<span class="s2">class </span><span class="s1">TestGibrat:</span>

    <span class="s3"># sfx is sf(x).  The values were computed with mpmath:</span>
    <span class="s3">#</span>
    <span class="s3">#   from mpmath import mp</span>
    <span class="s3">#   mp.dps = 100</span>
    <span class="s3">#   def gibrat_sf(x):</span>
    <span class="s3">#       return 1 - mp.ncdf(mp.log(x))</span>
    <span class="s3">#</span>
    <span class="s3"># E.g.</span>
    <span class="s3">#</span>
    <span class="s3">#   &gt;&gt;&gt; float(gibrat_sf(1.5))</span>
    <span class="s3">#   0.3425678305148459</span>
    <span class="s3">#</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'x, sfx'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">0.3425678305148459</span><span class="s1">)</span><span class="s2">,</span>
                                        <span class="s1">(</span><span class="s4">5000</span><span class="s2">, </span><span class="s4">8.173334352522493e-18</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_sf_isf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">sfx):</span>
        <span class="s1">assert_allclose(stats.gibrat.sf(x)</span><span class="s2">, </span><span class="s1">sfx</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">2e-14</span><span class="s1">)</span>
        <span class="s1">assert_allclose(stats.gibrat.isf(sfx)</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">2e-14</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestGompertz:</span>

    <span class="s2">def </span><span class="s1">test_gompertz_accuracy(self):</span>
        <span class="s3"># Regression test for gh-4031</span>
        <span class="s1">p = stats.gompertz.ppf(stats.gompertz.cdf(</span><span class="s4">1e-100</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(p</span><span class="s2">, </span><span class="s4">1e-100</span><span class="s1">)</span>

    <span class="s3"># sfx is sf(x).  The values were computed with mpmath:</span>
    <span class="s3">#</span>
    <span class="s3">#   from mpmath import mp</span>
    <span class="s3">#   mp.dps = 100</span>
    <span class="s3">#   def gompertz_sf(x, c):</span>
    <span class="s3">#       reurn mp.exp(-c*mp.expm1(x))</span>
    <span class="s3">#</span>
    <span class="s3"># E.g.</span>
    <span class="s3">#</span>
    <span class="s3">#   &gt;&gt;&gt; float(gompertz_sf(1, 2.5))</span>
    <span class="s3">#   0.013626967146253437</span>
    <span class="s3">#</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'x, c, sfx'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2.5</span><span class="s2">, </span><span class="s4">0.013626967146253437</span><span class="s1">)</span><span class="s2">,</span>
                                           <span class="s1">(</span><span class="s4">3</span><span class="s2">, </span><span class="s4">2.5</span><span class="s2">, </span><span class="s4">1.8973243273704087e-21</span><span class="s1">)</span><span class="s2">,</span>
                                           <span class="s1">(</span><span class="s4">0.05</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">0.7738668242570479</span><span class="s1">)</span><span class="s2">,</span>
                                           <span class="s1">(</span><span class="s4">2.25</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">3.707795833465481e-19</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_sf_isf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">sfx):</span>
        <span class="s1">assert_allclose(stats.gompertz.sf(x</span><span class="s2">, </span><span class="s1">c)</span><span class="s2">, </span><span class="s1">sfx</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-14</span><span class="s1">)</span>
        <span class="s1">assert_allclose(stats.gompertz.isf(sfx</span><span class="s2">, </span><span class="s1">c)</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-14</span><span class="s1">)</span>

    <span class="s3"># reference values were computed with mpmath</span>
    <span class="s3"># from mpmath import mp</span>
    <span class="s3"># mp.dps = 100</span>
    <span class="s3"># def gompertz_entropy(c):</span>
    <span class="s3">#     c = mp.mpf(c)</span>
    <span class="s3">#     return float(mp.one - mp.log(c) - mp.exp(c)*mp.e1(c))</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'c, ref'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">1e-4</span><span class="s2">, </span><span class="s4">1.5762523017634573</span><span class="s1">)</span><span class="s2">,</span>
                                        <span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.4036526376768059</span><span class="s1">)</span><span class="s2">,</span>
                                        <span class="s1">(</span><span class="s4">1000</span><span class="s2">, </span><span class="s1">-</span><span class="s4">5.908754280976161</span><span class="s1">)</span><span class="s2">,</span>
                                        <span class="s1">(</span><span class="s4">1e10</span><span class="s2">, </span><span class="s1">-</span><span class="s4">22.025850930040455</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_entropy(self</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">ref):</span>
        <span class="s1">assert_allclose(stats.gompertz.entropy(c)</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-14</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestFoldNorm:</span>

    <span class="s3"># reference values were computed with mpmath with 50 digits of precision</span>
    <span class="s3"># from mpmath import mp</span>
    <span class="s3"># mp.dps = 50</span>
    <span class="s3"># mp.mpf(0.5) * (mp.erf((x - c)/mp.sqrt(2)) + mp.erf((x + c)/mp.sqrt(2)))</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'x, c, ref'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">1e-4</span><span class="s2">, </span><span class="s4">1e-8</span><span class="s2">, </span><span class="s4">7.978845594730578e-05</span><span class="s1">)</span><span class="s2">,</span>
                                           <span class="s1">(</span><span class="s4">1e-4</span><span class="s2">, </span><span class="s4">1e-4</span><span class="s2">, </span><span class="s4">7.97884555483635e-05</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_cdf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">ref):</span>
        <span class="s1">assert_allclose(stats.foldnorm.cdf(x</span><span class="s2">, </span><span class="s1">c)</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-15</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestHalfNorm:</span>

    <span class="s3"># sfx is sf(x).  The values were computed with mpmath:</span>
    <span class="s3">#</span>
    <span class="s3">#   from mpmath import mp</span>
    <span class="s3">#   mp.dps = 100</span>
    <span class="s3">#   def halfnorm_sf(x):</span>
    <span class="s3">#       reurn 2*(1 - mp.ncdf(x))</span>
    <span class="s3">#</span>
    <span class="s3"># E.g.</span>
    <span class="s3">#</span>
    <span class="s3">#   &gt;&gt;&gt; float(halfnorm_sf(1))</span>
    <span class="s3">#   0.3173105078629141</span>
    <span class="s3">#</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'x, sfx'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.3173105078629141</span><span class="s1">)</span><span class="s2">,</span>
                                        <span class="s1">(</span><span class="s4">10</span><span class="s2">, </span><span class="s4">1.523970604832105e-23</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_sf_isf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">sfx):</span>
        <span class="s1">assert_allclose(stats.halfnorm.sf(x)</span><span class="s2">, </span><span class="s1">sfx</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-14</span><span class="s1">)</span>
        <span class="s1">assert_allclose(stats.halfnorm.isf(sfx)</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-14</span><span class="s1">)</span>

    <span class="s3">#   reference values were computed via mpmath</span>
    <span class="s3">#   from mpmath import mp</span>
    <span class="s3">#   mp.dps = 100</span>
    <span class="s3">#   def halfnorm_cdf_mpmath(x):</span>
    <span class="s3">#       x = mp.mpf(x)</span>
    <span class="s3">#       return float(mp.erf(x/mp.sqrt(2.)))</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'x, ref'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">1e-40</span><span class="s2">, </span><span class="s4">7.978845608028653e-41</span><span class="s1">)</span><span class="s2">,</span>
                                        <span class="s1">(</span><span class="s4">1e-18</span><span class="s2">, </span><span class="s4">7.978845608028654e-19</span><span class="s1">)</span><span class="s2">,</span>
                                        <span class="s1">(</span><span class="s4">8</span><span class="s2">, </span><span class="s4">0.9999999999999988</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_cdf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">ref):</span>
        <span class="s1">assert_allclose(stats.halfnorm.cdf(x)</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-15</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestHalfLogistic:</span>
    <span class="s3"># survival function reference values were computed with mpmath</span>
    <span class="s3"># from mpmath import mp</span>
    <span class="s3"># mp.dps = 50</span>
    <span class="s3"># def sf_mpmath(x):</span>
    <span class="s3">#     x = mp.mpf(x)</span>
    <span class="s3">#     return float(mp.mpf(2.)/(mp.exp(x) + mp.one))</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'x, ref'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">100</span><span class="s2">, </span><span class="s4">7.440151952041672e-44</span><span class="s1">)</span><span class="s2">,</span>
                                        <span class="s1">(</span><span class="s4">200</span><span class="s2">, </span><span class="s4">2.767793053473475e-87</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_sf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">ref):</span>
        <span class="s1">assert_allclose(stats.halflogistic.sf(x)</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-15</span><span class="s1">)</span>

    <span class="s3"># inverse survival function reference values were computed with mpmath</span>
    <span class="s3"># from mpmath import mp</span>
    <span class="s3"># mp.dps = 200</span>
    <span class="s3"># def isf_mpmath(x):</span>
    <span class="s3">#     halfx = mp.mpf(x)/2</span>
    <span class="s3">#     return float(-mp.log(halfx/(mp.one - halfx)))</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'q, ref'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">7.440151952041672e-44</span><span class="s2">, </span><span class="s4">100</span><span class="s1">)</span><span class="s2">,</span>
                                        <span class="s1">(</span><span class="s4">2.767793053473475e-87</span><span class="s2">, </span><span class="s4">200</span><span class="s1">)</span><span class="s2">,</span>
                                        <span class="s1">(</span><span class="s4">1</span><span class="s1">-</span><span class="s4">1e-9</span><span class="s2">, </span><span class="s4">1.999999943436137e-09</span><span class="s1">)</span><span class="s2">,</span>
                                        <span class="s1">(</span><span class="s4">1</span><span class="s1">-</span><span class="s4">1e-15</span><span class="s2">, </span><span class="s4">1.9984014443252818e-15</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_isf(self</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">ref):</span>
        <span class="s1">assert_allclose(stats.halflogistic.isf(q)</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-15</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestHalfgennorm:</span>
    <span class="s2">def </span><span class="s1">test_expon(self):</span>
        <span class="s3"># test against exponential (special case for beta=1)</span>
        <span class="s1">points = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span>
        <span class="s1">pdf1 = stats.halfgennorm.pdf(points</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">pdf2 = stats.expon.pdf(points)</span>
        <span class="s1">assert_almost_equal(pdf1</span><span class="s2">, </span><span class="s1">pdf2)</span>

    <span class="s2">def </span><span class="s1">test_halfnorm(self):</span>
        <span class="s3"># test against half normal (special case for beta=2)</span>
        <span class="s1">points = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span>
        <span class="s1">pdf1 = stats.halfgennorm.pdf(points</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">pdf2 = stats.halfnorm.pdf(points</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">2</span><span class="s1">**-</span><span class="s4">.5</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(pdf1</span><span class="s2">, </span><span class="s1">pdf2)</span>

    <span class="s2">def </span><span class="s1">test_gennorm(self):</span>
        <span class="s3"># test against generalized normal</span>
        <span class="s1">points = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span>
        <span class="s1">pdf1 = stats.halfgennorm.pdf(points</span><span class="s2">, </span><span class="s4">.497324</span><span class="s1">)</span>
        <span class="s1">pdf2 = stats.gennorm.pdf(points</span><span class="s2">, </span><span class="s4">.497324</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(pdf1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">*pdf2)</span>


<span class="s2">class </span><span class="s1">TestLaplaceasymmetric:</span>
    <span class="s2">def </span><span class="s1">test_laplace(self):</span>
        <span class="s3"># test against Laplace (special case for kappa=1)</span>
        <span class="s1">points = np.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">])</span>
        <span class="s1">pdf1 = stats.laplace_asymmetric.pdf(points</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">pdf2 = stats.laplace.pdf(points)</span>
        <span class="s1">assert_allclose(pdf1</span><span class="s2">, </span><span class="s1">pdf2)</span>

    <span class="s2">def </span><span class="s1">test_asymmetric_laplace_pdf(self):</span>
        <span class="s3"># test assymetric Laplace</span>
        <span class="s1">points = np.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">])</span>
        <span class="s1">kappa = </span><span class="s4">2</span>
        <span class="s1">kapinv = </span><span class="s4">1</span><span class="s1">/kappa</span>
        <span class="s1">pdf1 = stats.laplace_asymmetric.pdf(points</span><span class="s2">, </span><span class="s1">kappa)</span>
        <span class="s1">pdf2 = stats.laplace_asymmetric.pdf(points*(kappa**</span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">kapinv)</span>
        <span class="s1">assert_allclose(pdf1</span><span class="s2">, </span><span class="s1">pdf2)</span>

    <span class="s2">def </span><span class="s1">test_asymmetric_laplace_log_10_16(self):</span>
        <span class="s3"># test assymetric Laplace</span>
        <span class="s1">points = np.array([-np.log(</span><span class="s4">16</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.log(</span><span class="s4">10</span><span class="s1">)])</span>
        <span class="s1">kappa = </span><span class="s4">2</span>
        <span class="s1">pdf1 = stats.laplace_asymmetric.pdf(points</span><span class="s2">, </span><span class="s1">kappa)</span>
        <span class="s1">cdf1 = stats.laplace_asymmetric.cdf(points</span><span class="s2">, </span><span class="s1">kappa)</span>
        <span class="s1">sf1 = stats.laplace_asymmetric.sf(points</span><span class="s2">, </span><span class="s1">kappa)</span>
        <span class="s1">pdf2 = np.array([</span><span class="s4">1</span><span class="s1">/</span><span class="s4">10</span><span class="s2">, </span><span class="s4">1</span><span class="s1">/</span><span class="s4">250</span><span class="s1">])</span>
        <span class="s1">cdf2 = np.array([</span><span class="s4">1</span><span class="s1">/</span><span class="s4">5</span><span class="s2">, </span><span class="s4">1 </span><span class="s1">- </span><span class="s4">1</span><span class="s1">/</span><span class="s4">500</span><span class="s1">])</span>
        <span class="s1">sf2 = np.array([</span><span class="s4">4</span><span class="s1">/</span><span class="s4">5</span><span class="s2">, </span><span class="s4">1</span><span class="s1">/</span><span class="s4">500</span><span class="s1">])</span>
        <span class="s1">ppf1 = stats.laplace_asymmetric.ppf(cdf2</span><span class="s2">, </span><span class="s1">kappa)</span>
        <span class="s1">ppf2 = points</span>
        <span class="s1">isf1 = stats.laplace_asymmetric.isf(sf2</span><span class="s2">, </span><span class="s1">kappa)</span>
        <span class="s1">isf2 = points</span>
        <span class="s1">assert_allclose(np.concatenate((pdf1</span><span class="s2">, </span><span class="s1">cdf1</span><span class="s2">, </span><span class="s1">sf1</span><span class="s2">, </span><span class="s1">ppf1</span><span class="s2">, </span><span class="s1">isf1))</span><span class="s2">,</span>
                        <span class="s1">np.concatenate((pdf2</span><span class="s2">, </span><span class="s1">cdf2</span><span class="s2">, </span><span class="s1">sf2</span><span class="s2">, </span><span class="s1">ppf2</span><span class="s2">, </span><span class="s1">isf2)))</span>


<span class="s2">class </span><span class="s1">TestTruncnorm:</span>
    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">np.random.seed(</span><span class="s4">1234</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;a, b, ref&quot;</span><span class="s2">,</span>
                             <span class="s1">[(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">100</span><span class="s2">, </span><span class="s4">0.7257913526447274</span><span class="s1">)</span><span class="s2">,</span>
                             <span class="s1">(</span><span class="s4">0.6</span><span class="s2">, </span><span class="s4">0.7</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2.3027610681852573</span><span class="s1">)</span><span class="s2">,</span>
                             <span class="s1">(</span><span class="s4">1e-06</span><span class="s2">, </span><span class="s4">2e-06</span><span class="s2">, </span><span class="s1">-</span><span class="s4">13.815510557964274</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_entropy(self</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">ref):</span>
        <span class="s3"># All reference values were calculated with mpmath:</span>
        <span class="s3"># import numpy as np</span>
        <span class="s3"># from mpmath import mp</span>
        <span class="s3"># mp.dps = 50</span>
        <span class="s3"># def entropy_trun(a, b):</span>
        <span class="s3">#     a, b = mp.mpf(a), mp.mpf(b)</span>
        <span class="s3">#     Z = mp.ncdf(b) - mp.ncdf(a)</span>
        <span class="s3">#</span>
        <span class="s3">#     def pdf(x):</span>
        <span class="s3">#         return mp.npdf(x) / Z</span>
        <span class="s3">#</span>
        <span class="s3">#     res = -mp.quad(lambda t: pdf(t) * mp.log(pdf(t)), [a, b])</span>
        <span class="s3">#     return np.float64(res)</span>
        <span class="s1">assert_allclose(stats.truncnorm.entropy(a</span><span class="s2">, </span><span class="s1">b)</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-10</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;a, b, ref&quot;</span><span class="s2">,</span>
                             <span class="s1">[(</span><span class="s4">1e-11</span><span class="s2">, </span><span class="s4">10000000000.0</span><span class="s2">, </span><span class="s4">0.725791352640738</span><span class="s1">)</span><span class="s2">,</span>
                             <span class="s1">(</span><span class="s4">1e-100</span><span class="s2">, </span><span class="s4">1e+100</span><span class="s2">, </span><span class="s4">0.7257913526447274</span><span class="s1">)</span><span class="s2">,</span>
                             <span class="s1">(-</span><span class="s4">1e-100</span><span class="s2">, </span><span class="s4">1e+100</span><span class="s2">, </span><span class="s4">0.7257913526447274</span><span class="s1">)</span><span class="s2">,</span>
                             <span class="s1">(-</span><span class="s4">1e+100</span><span class="s2">, </span><span class="s4">1e+100</span><span class="s2">, </span><span class="s4">1.4189385332046727</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_extreme_entropy(self</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">ref):</span>
        <span class="s3"># The reference values were calculated with mpmath</span>
        <span class="s3"># import numpy as np</span>
        <span class="s3"># from mpmath import mp</span>
        <span class="s3"># mp.dps = 50</span>
        <span class="s3"># def trunc_norm_entropy(a, b):</span>
        <span class="s3">#     a, b = mp.mpf(a), mp.mpf(b)</span>
        <span class="s3">#     Z = mp.ncdf(b) - mp.ncdf(a)</span>
        <span class="s3">#     A = mp.log(mp.sqrt(2 * mp.pi * mp.e) * Z)</span>
        <span class="s3">#     B = (a * mp.npdf(a) - b * mp.npdf(b)) / (2 * Z)</span>
        <span class="s3">#     return np.float64(A + B)</span>
        <span class="s1">assert_allclose(stats.truncnorm.entropy(a</span><span class="s2">, </span><span class="s1">b)</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-14</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_ppf_ticket1131(self):</span>
        <span class="s1">vals = stats.truncnorm.ppf([-</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1e-4</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1</span><span class="s1">-</span><span class="s4">1e-4</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">,</span>
                                   <span class="s1">loc=[</span><span class="s4">3</span><span class="s1">]*</span><span class="s4">7</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">expected = np.array([np.nan</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1.00056419</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4.99943581</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s1">np.nan])</span>
        <span class="s1">assert_array_almost_equal(vals</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_isf_ticket1131(self):</span>
        <span class="s1">vals = stats.truncnorm.isf([-</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1e-4</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1</span><span class="s1">-</span><span class="s4">1e-4</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">,</span>
                                   <span class="s1">loc=[</span><span class="s4">3</span><span class="s1">]*</span><span class="s4">7</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">expected = np.array([np.nan</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">4.99943581</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">1.00056419</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">np.nan])</span>
        <span class="s1">assert_array_almost_equal(vals</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_gh_2477_small_values(self):</span>
        <span class="s3"># Check a case that worked in the original issue.</span>
        <span class="s1">low</span><span class="s2">, </span><span class="s1">high = -</span><span class="s4">11</span><span class="s2">, </span><span class="s1">-</span><span class="s4">10</span>
        <span class="s1">x = stats.truncnorm.rvs(low</span><span class="s2">, </span><span class="s1">high</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">assert_(low &lt; x.min() &lt; x.max() &lt; high)</span>
        <span class="s3"># Check a case that failed in the original issue.</span>
        <span class="s1">low</span><span class="s2">, </span><span class="s1">high = </span><span class="s4">10</span><span class="s2">, </span><span class="s4">11</span>
        <span class="s1">x = stats.truncnorm.rvs(low</span><span class="s2">, </span><span class="s1">high</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">assert_(low &lt; x.min() &lt; x.max() &lt; high)</span>

    <span class="s2">def </span><span class="s1">test_gh_2477_large_values(self):</span>
        <span class="s3"># Check a case that used to fail because of extreme tailness.</span>
        <span class="s1">low</span><span class="s2">, </span><span class="s1">high = </span><span class="s4">100</span><span class="s2">, </span><span class="s4">101</span>
        <span class="s1">x = stats.truncnorm.rvs(low</span><span class="s2">, </span><span class="s1">high</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">assert_(low &lt;= x.min() &lt;= x.max() &lt;= high)</span><span class="s2">, </span><span class="s1">str([low</span><span class="s2">, </span><span class="s1">high</span><span class="s2">, </span><span class="s1">x])</span>

        <span class="s3"># Check some additional extreme tails</span>
        <span class="s1">low</span><span class="s2">, </span><span class="s1">high = </span><span class="s4">1000</span><span class="s2">, </span><span class="s4">1001</span>
        <span class="s1">x = stats.truncnorm.rvs(low</span><span class="s2">, </span><span class="s1">high</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">assert_(low &lt; x.min() &lt; x.max() &lt; high)</span>

        <span class="s1">low</span><span class="s2">, </span><span class="s1">high = </span><span class="s4">10000</span><span class="s2">, </span><span class="s4">10001</span>
        <span class="s1">x = stats.truncnorm.rvs(low</span><span class="s2">, </span><span class="s1">high</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">assert_(low &lt; x.min() &lt; x.max() &lt; high)</span>

        <span class="s1">low</span><span class="s2">, </span><span class="s1">high = -</span><span class="s4">10001</span><span class="s2">, </span><span class="s1">-</span><span class="s4">10000</span>
        <span class="s1">x = stats.truncnorm.rvs(low</span><span class="s2">, </span><span class="s1">high</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">assert_(low &lt; x.min() &lt; x.max() &lt; high)</span>

    <span class="s2">def </span><span class="s1">test_gh_9403_nontail_values(self):</span>
        <span class="s2">for </span><span class="s1">low</span><span class="s2">, </span><span class="s1">high </span><span class="s2">in </span><span class="s1">[[</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[-</span><span class="s4">4</span><span class="s2">, </span><span class="s1">-</span><span class="s4">3</span><span class="s1">]]:</span>
            <span class="s1">xvals = np.array([-np.inf</span><span class="s2">, </span><span class="s1">low</span><span class="s2">, </span><span class="s1">high</span><span class="s2">, </span><span class="s1">np.inf])</span>
            <span class="s1">xmid = (high+low)/</span><span class="s4">2.0</span>
            <span class="s1">cdfs = stats.truncnorm.cdf(xvals</span><span class="s2">, </span><span class="s1">low</span><span class="s2">, </span><span class="s1">high)</span>
            <span class="s1">sfs = stats.truncnorm.sf(xvals</span><span class="s2">, </span><span class="s1">low</span><span class="s2">, </span><span class="s1">high)</span>
            <span class="s1">pdfs = stats.truncnorm.pdf(xvals</span><span class="s2">, </span><span class="s1">low</span><span class="s2">, </span><span class="s1">high)</span>
            <span class="s1">expected_cdfs = np.array([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>
            <span class="s1">expected_sfs = np.array([</span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">])</span>
            <span class="s1">expected_pdfs = np.array([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">3.3619772</span><span class="s2">, </span><span class="s4">0.1015229</span><span class="s2">, </span><span class="s4">0</span><span class="s1">])</span>
            <span class="s2">if </span><span class="s1">low &lt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">expected_pdfs = np.array([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0.1015229</span><span class="s2">, </span><span class="s4">3.3619772</span><span class="s2">, </span><span class="s4">0</span><span class="s1">])</span>
            <span class="s1">assert_almost_equal(cdfs</span><span class="s2">, </span><span class="s1">expected_cdfs)</span>
            <span class="s1">assert_almost_equal(sfs</span><span class="s2">, </span><span class="s1">expected_sfs)</span>
            <span class="s1">assert_almost_equal(pdfs</span><span class="s2">, </span><span class="s1">expected_pdfs)</span>
            <span class="s1">assert_almost_equal(np.log(expected_pdfs[</span><span class="s4">1</span><span class="s1">]/expected_pdfs[</span><span class="s4">2</span><span class="s1">])</span><span class="s2">,</span>
                                <span class="s1">low + </span><span class="s4">0.5</span><span class="s1">)</span>
            <span class="s1">pvals = np.array([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">])</span>
            <span class="s1">ppfs = stats.truncnorm.ppf(pvals</span><span class="s2">, </span><span class="s1">low</span><span class="s2">, </span><span class="s1">high)</span>
            <span class="s1">expected_ppfs = np.array([low</span><span class="s2">, </span><span class="s1">np.sign(low)*</span><span class="s4">3.1984741</span><span class="s2">, </span><span class="s1">high])</span>
            <span class="s1">assert_almost_equal(ppfs</span><span class="s2">, </span><span class="s1">expected_ppfs)</span>

            <span class="s2">if </span><span class="s1">low &lt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">assert_almost_equal(stats.truncnorm.sf(xmid</span><span class="s2">, </span><span class="s1">low</span><span class="s2">, </span><span class="s1">high)</span><span class="s2">,</span>
                                    <span class="s4">0.8475544278436675</span><span class="s1">)</span>
                <span class="s1">assert_almost_equal(stats.truncnorm.cdf(xmid</span><span class="s2">, </span><span class="s1">low</span><span class="s2">, </span><span class="s1">high)</span><span class="s2">,</span>
                                    <span class="s4">0.1524455721563326</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">assert_almost_equal(stats.truncnorm.cdf(xmid</span><span class="s2">, </span><span class="s1">low</span><span class="s2">, </span><span class="s1">high)</span><span class="s2">,</span>
                                    <span class="s4">0.8475544278436675</span><span class="s1">)</span>
                <span class="s1">assert_almost_equal(stats.truncnorm.sf(xmid</span><span class="s2">, </span><span class="s1">low</span><span class="s2">, </span><span class="s1">high)</span><span class="s2">,</span>
                                    <span class="s4">0.1524455721563326</span><span class="s1">)</span>
            <span class="s1">pdf = stats.truncnorm.pdf(xmid</span><span class="s2">, </span><span class="s1">low</span><span class="s2">, </span><span class="s1">high)</span>
            <span class="s1">assert_almost_equal(np.log(pdf/expected_pdfs[</span><span class="s4">2</span><span class="s1">])</span><span class="s2">, </span><span class="s1">(xmid+</span><span class="s4">0.25</span><span class="s1">)/</span><span class="s4">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_gh_9403_medium_tail_values(self):</span>
        <span class="s2">for </span><span class="s1">low</span><span class="s2">, </span><span class="s1">high </span><span class="s2">in </span><span class="s1">[[</span><span class="s4">39</span><span class="s2">, </span><span class="s4">40</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[-</span><span class="s4">40</span><span class="s2">, </span><span class="s1">-</span><span class="s4">39</span><span class="s1">]]:</span>
            <span class="s1">xvals = np.array([-np.inf</span><span class="s2">, </span><span class="s1">low</span><span class="s2">, </span><span class="s1">high</span><span class="s2">, </span><span class="s1">np.inf])</span>
            <span class="s1">xmid = (high+low)/</span><span class="s4">2.0</span>
            <span class="s1">cdfs = stats.truncnorm.cdf(xvals</span><span class="s2">, </span><span class="s1">low</span><span class="s2">, </span><span class="s1">high)</span>
            <span class="s1">sfs = stats.truncnorm.sf(xvals</span><span class="s2">, </span><span class="s1">low</span><span class="s2">, </span><span class="s1">high)</span>
            <span class="s1">pdfs = stats.truncnorm.pdf(xvals</span><span class="s2">, </span><span class="s1">low</span><span class="s2">, </span><span class="s1">high)</span>
            <span class="s1">expected_cdfs = np.array([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>
            <span class="s1">expected_sfs = np.array([</span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">])</span>
            <span class="s1">expected_pdfs = np.array([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">3.90256074e+01</span><span class="s2">, </span><span class="s4">2.73349092e-16</span><span class="s2">, </span><span class="s4">0</span><span class="s1">])</span>
            <span class="s2">if </span><span class="s1">low &lt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">expected_pdfs = np.array([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2.73349092e-16</span><span class="s2">,</span>
                                          <span class="s4">3.90256074e+01</span><span class="s2">, </span><span class="s4">0</span><span class="s1">])</span>
            <span class="s1">assert_almost_equal(cdfs</span><span class="s2">, </span><span class="s1">expected_cdfs)</span>
            <span class="s1">assert_almost_equal(sfs</span><span class="s2">, </span><span class="s1">expected_sfs)</span>
            <span class="s1">assert_almost_equal(pdfs</span><span class="s2">, </span><span class="s1">expected_pdfs)</span>
            <span class="s1">assert_almost_equal(np.log(expected_pdfs[</span><span class="s4">1</span><span class="s1">]/expected_pdfs[</span><span class="s4">2</span><span class="s1">])</span><span class="s2">,</span>
                                <span class="s1">low + </span><span class="s4">0.5</span><span class="s1">)</span>
            <span class="s1">pvals = np.array([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">])</span>
            <span class="s1">ppfs = stats.truncnorm.ppf(pvals</span><span class="s2">, </span><span class="s1">low</span><span class="s2">, </span><span class="s1">high)</span>
            <span class="s1">expected_ppfs = np.array([low</span><span class="s2">, </span><span class="s1">np.sign(low)*</span><span class="s4">39.01775731</span><span class="s2">, </span><span class="s1">high])</span>
            <span class="s1">assert_almost_equal(ppfs</span><span class="s2">, </span><span class="s1">expected_ppfs)</span>
            <span class="s1">cdfs = stats.truncnorm.cdf(ppfs</span><span class="s2">, </span><span class="s1">low</span><span class="s2">, </span><span class="s1">high)</span>
            <span class="s1">assert_almost_equal(cdfs</span><span class="s2">, </span><span class="s1">pvals)</span>

            <span class="s2">if </span><span class="s1">low &lt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s1">assert_almost_equal(stats.truncnorm.sf(xmid</span><span class="s2">, </span><span class="s1">low</span><span class="s2">, </span><span class="s1">high)</span><span class="s2">,</span>
                                    <span class="s4">0.9999999970389126</span><span class="s1">)</span>
                <span class="s1">assert_almost_equal(stats.truncnorm.cdf(xmid</span><span class="s2">, </span><span class="s1">low</span><span class="s2">, </span><span class="s1">high)</span><span class="s2">,</span>
                                    <span class="s4">2.961048103554866e-09</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">assert_almost_equal(stats.truncnorm.cdf(xmid</span><span class="s2">, </span><span class="s1">low</span><span class="s2">, </span><span class="s1">high)</span><span class="s2">,</span>
                                    <span class="s4">0.9999999970389126</span><span class="s1">)</span>
                <span class="s1">assert_almost_equal(stats.truncnorm.sf(xmid</span><span class="s2">, </span><span class="s1">low</span><span class="s2">, </span><span class="s1">high)</span><span class="s2">,</span>
                                    <span class="s4">2.961048103554866e-09</span><span class="s1">)</span>
            <span class="s1">pdf = stats.truncnorm.pdf(xmid</span><span class="s2">, </span><span class="s1">low</span><span class="s2">, </span><span class="s1">high)</span>
            <span class="s1">assert_almost_equal(np.log(pdf/expected_pdfs[</span><span class="s4">2</span><span class="s1">])</span><span class="s2">, </span><span class="s1">(xmid+</span><span class="s4">0.25</span><span class="s1">)/</span><span class="s4">2</span><span class="s1">)</span>

            <span class="s1">xvals = np.linspace(low</span><span class="s2">, </span><span class="s1">high</span><span class="s2">, </span><span class="s4">11</span><span class="s1">)</span>
            <span class="s1">xvals2 = -xvals[::-</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s1">assert_almost_equal(stats.truncnorm.cdf(xvals</span><span class="s2">, </span><span class="s1">low</span><span class="s2">, </span><span class="s1">high)</span><span class="s2">,</span>
                                <span class="s1">stats.truncnorm.sf(xvals2</span><span class="s2">, </span><span class="s1">-high</span><span class="s2">, </span><span class="s1">-low)[::-</span><span class="s4">1</span><span class="s1">])</span>
            <span class="s1">assert_almost_equal(stats.truncnorm.sf(xvals</span><span class="s2">, </span><span class="s1">low</span><span class="s2">, </span><span class="s1">high)</span><span class="s2">,</span>
                                <span class="s1">stats.truncnorm.cdf(xvals2</span><span class="s2">, </span><span class="s1">-high</span><span class="s2">, </span><span class="s1">-low)[::-</span><span class="s4">1</span><span class="s1">])</span>
            <span class="s1">assert_almost_equal(stats.truncnorm.pdf(xvals</span><span class="s2">, </span><span class="s1">low</span><span class="s2">, </span><span class="s1">high)</span><span class="s2">,</span>
                                <span class="s1">stats.truncnorm.pdf(xvals2</span><span class="s2">, </span><span class="s1">-high</span><span class="s2">, </span><span class="s1">-low)[::-</span><span class="s4">1</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_cdf_tail_15110_14753(self):</span>
        <span class="s3"># Check accuracy issues reported in gh-14753 and gh-155110</span>
        <span class="s3"># Ground truth values calculated using Wolfram Alpha, e.g.</span>
        <span class="s3"># (CDF[NormalDistribution[0,1],83/10]-CDF[NormalDistribution[0,1],8])/</span>
        <span class="s3">#     (1 - CDF[NormalDistribution[0,1],8])</span>
        <span class="s1">assert_allclose(stats.truncnorm(</span><span class="s4">13.</span><span class="s2">, </span><span class="s4">15.</span><span class="s1">).cdf(</span><span class="s4">14.</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s4">0.9999987259565643</span><span class="s1">)</span>
        <span class="s1">assert_allclose(stats.truncnorm(</span><span class="s4">8</span><span class="s2">, </span><span class="s1">np.inf).cdf(</span><span class="s4">8.3</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s4">0.9163220907327540</span><span class="s1">)</span>

    <span class="s3"># Test data for the truncnorm stats() method.</span>
    <span class="s3"># The data in each row is:</span>
    <span class="s3">#   a, b, mean, variance, skewness, excess kurtosis. Generated using</span>
    <span class="s3"># https://gist.github.com/WarrenWeckesser/636b537ee889679227d53543d333a720</span>
    <span class="s1">_truncnorm_stats_data = [</span>
        <span class="s1">[-</span><span class="s4">30</span><span class="s2">, </span><span class="s4">30</span><span class="s2">,</span>
         <span class="s4">0.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[-</span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s2">,</span>
         <span class="s4">0.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.4927521335810455e-19</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[-</span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s2">,</span>
         <span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.9733369246625415</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.17111443639774404</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[-</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">,</span>
         <span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.7737413035499232</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.6344632828703505</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s1">np.inf</span><span class="s2">,</span>
         <span class="s4">0.7978845608028654</span><span class="s2">,</span>
         <span class="s4">0.3633802276324187</span><span class="s2">,</span>
         <span class="s4">0.995271746431156</span><span class="s2">,</span>
         <span class="s4">0.8691773036059741</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[-np.inf</span><span class="s2">, </span><span class="s4">0</span><span class="s2">,</span>
         <span class="s1">-</span><span class="s4">0.7978845608028654</span><span class="s2">,</span>
         <span class="s4">0.3633802276324187</span><span class="s2">,</span>
         <span class="s1">-</span><span class="s4">0.995271746431156</span><span class="s2">,</span>
         <span class="s4">0.8691773036059741</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s2">,</span>
         <span class="s4">0.282786110727154</span><span class="s2">,</span>
         <span class="s4">0.6161417353578293</span><span class="s2">,</span>
         <span class="s4">0.5393018494027877</span><span class="s2">,</span>
         <span class="s1">-</span><span class="s4">0.20582065135274694</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[-</span><span class="s4">3</span><span class="s2">, </span><span class="s4">1</span><span class="s2">,</span>
         <span class="s1">-</span><span class="s4">0.282786110727154</span><span class="s2">,</span>
         <span class="s4">0.6161417353578293</span><span class="s2">,</span>
         <span class="s1">-</span><span class="s4">0.5393018494027877</span><span class="s2">,</span>
         <span class="s1">-</span><span class="s4">0.20582065135274694</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[-</span><span class="s4">10</span><span class="s2">, </span><span class="s1">-</span><span class="s4">9</span><span class="s2">,</span>
         <span class="s1">-</span><span class="s4">9.108456288012409</span><span class="s2">,</span>
         <span class="s4">0.011448805821636248</span><span class="s2">,</span>
         <span class="s1">-</span><span class="s4">1.8985607290949496</span><span class="s2">,</span>
         <span class="s4">5.0733461105025075</span><span class="s1">]</span><span class="s2">,</span>
    <span class="s1">]</span>
    <span class="s1">_truncnorm_stats_data = np.array(_truncnorm_stats_data)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;case&quot;</span><span class="s2">, </span><span class="s1">_truncnorm_stats_data)</span>
    <span class="s2">def </span><span class="s1">test_moments(self</span><span class="s2">, </span><span class="s1">case):</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">m0</span><span class="s2">, </span><span class="s1">v0</span><span class="s2">, </span><span class="s1">s0</span><span class="s2">, </span><span class="s1">k0 = case</span>
        <span class="s1">m</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">k = stats.truncnorm.stats(a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">moments=</span><span class="s5">'mvsk'</span><span class="s1">)</span>
        <span class="s1">assert_allclose([m</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">k]</span><span class="s2">, </span><span class="s1">[m0</span><span class="s2">, </span><span class="s1">v0</span><span class="s2">, </span><span class="s1">s0</span><span class="s2">, </span><span class="s1">k0]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-17</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_9902_moments(self):</span>
        <span class="s1">m</span><span class="s2">, </span><span class="s1">v = stats.truncnorm.stats(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">np.inf</span><span class="s2">, </span><span class="s1">moments=</span><span class="s5">'mv'</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(m</span><span class="s2">, </span><span class="s4">0.79788456</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(v</span><span class="s2">, </span><span class="s4">0.36338023</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_gh_1489_trac_962_rvs(self):</span>
        <span class="s3"># Check the original example.</span>
        <span class="s1">low</span><span class="s2">, </span><span class="s1">high = </span><span class="s4">10</span><span class="s2">, </span><span class="s4">15</span>
        <span class="s1">x = stats.truncnorm.rvs(low</span><span class="s2">, </span><span class="s1">high</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">assert_(low &lt; x.min() &lt; x.max() &lt; high)</span>

    <span class="s2">def </span><span class="s1">test_gh_11299_rvs(self):</span>
        <span class="s3"># Arose from investigating gh-11299</span>
        <span class="s3"># Test multiple shape parameters simultaneously.</span>
        <span class="s1">low = [-</span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s1">-np.inf</span><span class="s2">, </span><span class="s1">-</span><span class="s4">5</span><span class="s2">, </span><span class="s1">-np.inf</span><span class="s2">, </span><span class="s1">-np.inf</span><span class="s2">, </span><span class="s1">-</span><span class="s4">45</span><span class="s2">, </span><span class="s1">-</span><span class="s4">45</span><span class="s2">, </span><span class="s4">40</span><span class="s2">, </span><span class="s1">-</span><span class="s4">10</span><span class="s2">, </span><span class="s4">40</span><span class="s1">]</span>
        <span class="s1">high = [-</span><span class="s4">5</span><span class="s2">, </span><span class="s4">11</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s1">np.inf</span><span class="s2">, </span><span class="s4">40</span><span class="s2">, </span><span class="s1">-</span><span class="s4">40</span><span class="s2">, </span><span class="s4">40</span><span class="s2">, </span><span class="s1">-</span><span class="s4">40</span><span class="s2">, </span><span class="s4">45</span><span class="s2">, </span><span class="s1">np.inf</span><span class="s2">, </span><span class="s1">np.inf]</span>
        <span class="s1">x = stats.truncnorm.rvs(low</span><span class="s2">, </span><span class="s1">high</span><span class="s2">, </span><span class="s1">size=(</span><span class="s4">5</span><span class="s2">, </span><span class="s1">len(low)))</span>
        <span class="s2">assert </span><span class="s1">np.shape(x) == (</span><span class="s4">5</span><span class="s2">, </span><span class="s1">len(low))</span>
        <span class="s1">assert_(np.all(low &lt;= x.min(axis=</span><span class="s4">0</span><span class="s1">)))</span>
        <span class="s1">assert_(np.all(x.max(axis=</span><span class="s4">0</span><span class="s1">) &lt;= high))</span>

    <span class="s2">def </span><span class="s1">test_rvs_Generator(self):</span>
        <span class="s3"># check that rvs can use a Generator</span>
        <span class="s2">if </span><span class="s1">hasattr(np.random</span><span class="s2">, </span><span class="s5">&quot;default_rng&quot;</span><span class="s1">):</span>
            <span class="s1">stats.truncnorm.rvs(-</span><span class="s4">10</span><span class="s2">, </span><span class="s1">-</span><span class="s4">5</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">5</span><span class="s2">,</span>
                                <span class="s1">random_state=np.random.default_rng())</span>

    <span class="s2">def </span><span class="s1">test_logcdf_gh17064(self):</span>
        <span class="s3"># regression test for gh-17064 - avoid roundoff error for logcdfs ~0</span>
        <span class="s1">a = np.array([-np.inf</span><span class="s2">, </span><span class="s1">-np.inf</span><span class="s2">, </span><span class="s1">-</span><span class="s4">8</span><span class="s2">, </span><span class="s1">-np.inf</span><span class="s2">, </span><span class="s4">10</span><span class="s1">])</span>
        <span class="s1">b = np.array([np.inf</span><span class="s2">, </span><span class="s1">np.inf</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s1">np.inf])</span>
        <span class="s1">x = np.array([</span><span class="s4">10</span><span class="s2">, </span><span class="s4">7.5</span><span class="s2">, </span><span class="s4">7.5</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">20</span><span class="s1">])</span>
        <span class="s1">expected = [-</span><span class="s4">7.619853024160525e-24</span><span class="s2">, </span><span class="s1">-</span><span class="s4">3.190891672910947e-14</span><span class="s2">,</span>
                    <span class="s1">-</span><span class="s4">3.128682067168231e-14</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.1285122074235991e-19</span><span class="s2">,</span>
                    <span class="s1">-</span><span class="s4">3.61374964828753e-66</span><span class="s1">]</span>
        <span class="s1">assert_allclose(stats.truncnorm(a</span><span class="s2">, </span><span class="s1">b).logcdf(x)</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">assert_allclose(stats.truncnorm(-b</span><span class="s2">, </span><span class="s1">-a).logsf(-x)</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_moments_gh18634(self):</span>
        <span class="s3"># gh-18634 reported that moments 5 and higher didn't work; check that</span>
        <span class="s3"># this is resolved</span>
        <span class="s1">res = stats.truncnorm(-</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">).moment(</span><span class="s4">5</span><span class="s1">)</span>
        <span class="s3"># From Mathematica:</span>
        <span class="s3"># Moment[TruncatedDistribution[{-2, 3}, NormalDistribution[]], 5]</span>
        <span class="s1">ref = </span><span class="s4">1.645309620208361</span>
        <span class="s1">assert_allclose(res</span><span class="s2">, </span><span class="s1">ref)</span>


<span class="s2">class </span><span class="s1">TestGenLogistic:</span>

    <span class="s3"># Expected values computed with mpmath with 50 digits of precision.</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'x, expected'</span><span class="s2">, </span><span class="s1">[(-</span><span class="s4">1000</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1499.5945348918917</span><span class="s1">)</span><span class="s2">,</span>
                                             <span class="s1">(-</span><span class="s4">125</span><span class="s2">, </span><span class="s1">-</span><span class="s4">187.09453489189184</span><span class="s1">)</span><span class="s2">,</span>
                                             <span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.3274028432916989</span><span class="s1">)</span><span class="s2">,</span>
                                             <span class="s1">(</span><span class="s4">100</span><span class="s2">, </span><span class="s1">-</span><span class="s4">99.59453489189184</span><span class="s1">)</span><span class="s2">,</span>
                                             <span class="s1">(</span><span class="s4">1000</span><span class="s2">, </span><span class="s1">-</span><span class="s4">999.5945348918918</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_logpdf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">expected):</span>
        <span class="s1">c = </span><span class="s4">1.5</span>
        <span class="s1">logp = stats.genlogistic.logpdf(x</span><span class="s2">, </span><span class="s1">c)</span>
        <span class="s1">assert_allclose(logp</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-13</span><span class="s1">)</span>

    <span class="s3"># Expected values computed with mpmath with 50 digits of precision</span>
    <span class="s3"># from mpmath import mp</span>
    <span class="s3"># mp.dps = 50</span>
    <span class="s3"># def entropy_mp(c):</span>
    <span class="s3">#     c = mp.mpf(c)</span>
    <span class="s3">#     return float(-mp.log(c)+mp.one+mp.digamma(c + mp.one) + mp.euler)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'c, ref'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">1e-100</span><span class="s2">, </span><span class="s4">231.25850929940458</span><span class="s1">)</span><span class="s2">,</span>
                                        <span class="s1">(</span><span class="s4">1e-4</span><span class="s2">, </span><span class="s4">10.21050485336338</span><span class="s1">)</span><span class="s2">,</span>
                                        <span class="s1">(</span><span class="s4">1e8</span><span class="s2">, </span><span class="s4">1.577215669901533</span><span class="s1">)</span><span class="s2">,</span>
                                        <span class="s1">(</span><span class="s4">1e100</span><span class="s2">, </span><span class="s4">1.5772156649015328</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_entropy(self</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">ref):</span>
        <span class="s1">assert_allclose(stats.genlogistic.entropy(c)</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">5e-15</span><span class="s1">)</span>

    <span class="s3"># Expected values computed with mpmath with 50 digits of precision</span>
    <span class="s3"># from mpmath import mp</span>
    <span class="s3"># mp.dps = 1000</span>
    <span class="s3">#</span>
    <span class="s3"># def genlogistic_cdf_mp(x, c):</span>
    <span class="s3">#     x = mp.mpf(x)</span>
    <span class="s3">#     c = mp.mpf(c)</span>
    <span class="s3">#     return (mp.one + mp.exp(-x)) ** (-c)</span>
    <span class="s3">#</span>
    <span class="s3"># def genlogistic_sf_mp(x, c):</span>
    <span class="s3">#     return mp.one - genlogistic_cdf_mp(x, c)</span>
    <span class="s3">#</span>
    <span class="s3"># x, c, ref = 100, 0.02, -7.440151952041672e-466</span>
    <span class="s3"># print(float(mp.log(genlogistic_cdf_mp(x, c))))</span>
    <span class="s3"># ppf/isf reference values generated by passing in `ref` (`q` is produced)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'x, c, ref'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">200</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">1.3838965267367375e-86</span><span class="s1">)</span><span class="s2">,</span>
                                           <span class="s1">(</span><span class="s4">500</span><span class="s2">, </span><span class="s4">20</span><span class="s2">, </span><span class="s4">1.424915281348257e-216</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_sf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">ref):</span>
        <span class="s1">assert_allclose(stats.genlogistic.sf(x</span><span class="s2">, </span><span class="s1">c)</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-14</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'q, c, ref'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">0.01</span><span class="s2">, </span><span class="s4">200</span><span class="s2">, </span><span class="s4">9.898441467379765</span><span class="s1">)</span><span class="s2">,</span>
                                           <span class="s1">(</span><span class="s4">0.001</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">7.600152115573173</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_isf(self</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">ref):</span>
        <span class="s1">assert_allclose(stats.genlogistic.isf(q</span><span class="s2">, </span><span class="s1">c)</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">5e-16</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'q, c, ref'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">200</span><span class="s2">, </span><span class="s4">5.6630969187064615</span><span class="s1">)</span><span class="s2">,</span>
                                           <span class="s1">(</span><span class="s4">0.99</span><span class="s2">, </span><span class="s4">20</span><span class="s2">, </span><span class="s4">7.595630231412436</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_ppf(self</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">ref):</span>
        <span class="s1">assert_allclose(stats.genlogistic.ppf(q</span><span class="s2">, </span><span class="s1">c)</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">5e-16</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'x, c, ref'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">100</span><span class="s2">, </span><span class="s4">0.02</span><span class="s2">, </span><span class="s1">-</span><span class="s4">7.440151952041672e-46</span><span class="s1">)</span><span class="s2">,</span>
                                           <span class="s1">(</span><span class="s4">50</span><span class="s2">, </span><span class="s4">20</span><span class="s2">, </span><span class="s1">-</span><span class="s4">3.857499695927835e-21</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_logcdf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">ref):</span>
        <span class="s1">assert_allclose(stats.genlogistic.logcdf(x</span><span class="s2">, </span><span class="s1">c)</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-15</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestHypergeom:</span>
    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">np.random.seed(</span><span class="s4">1234</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_rvs(self):</span>
        <span class="s1">vals = stats.hypergeom.rvs(</span><span class="s4">20</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s1">size=(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">50</span><span class="s1">))</span>
        <span class="s1">assert_(numpy.all(vals &gt;= </span><span class="s4">0</span><span class="s1">) &amp;</span>
                <span class="s1">numpy.all(vals &lt;= </span><span class="s4">3</span><span class="s1">))</span>
        <span class="s1">assert_(numpy.shape(vals) == (</span><span class="s4">2</span><span class="s2">, </span><span class="s4">50</span><span class="s1">))</span>
        <span class="s1">assert_(vals.dtype.char </span><span class="s2">in </span><span class="s1">typecodes[</span><span class="s5">'AllInteger'</span><span class="s1">])</span>
        <span class="s1">val = stats.hypergeom.rvs(</span><span class="s4">20</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">assert_(isinstance(val</span><span class="s2">, </span><span class="s1">int))</span>
        <span class="s1">val = stats.hypergeom(</span><span class="s4">20</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">10</span><span class="s1">).rvs(</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">assert_(isinstance(val</span><span class="s2">, </span><span class="s1">numpy.ndarray))</span>
        <span class="s1">assert_(val.dtype.char </span><span class="s2">in </span><span class="s1">typecodes[</span><span class="s5">'AllInteger'</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_precision(self):</span>
        <span class="s3"># comparison number from mpmath</span>
        <span class="s1">M = </span><span class="s4">2500</span>
        <span class="s1">n = </span><span class="s4">50</span>
        <span class="s1">N = </span><span class="s4">500</span>
        <span class="s1">tot = M</span>
        <span class="s1">good = n</span>
        <span class="s1">hgpmf = stats.hypergeom.pmf(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">tot</span><span class="s2">, </span><span class="s1">good</span><span class="s2">, </span><span class="s1">N)</span>
        <span class="s1">assert_almost_equal(hgpmf</span><span class="s2">, </span><span class="s4">0.0010114963068932233</span><span class="s2">, </span><span class="s4">11</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_args(self):</span>
        <span class="s3"># test correct output for corner cases of arguments</span>
        <span class="s3"># see gh-2325</span>
        <span class="s1">assert_almost_equal(stats.hypergeom.pmf(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">11</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(stats.hypergeom.pmf(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">11</span><span class="s1">)</span>

        <span class="s1">assert_almost_equal(stats.hypergeom.pmf(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">11</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(stats.hypergeom.pmf(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">11</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_cdf_above_one(self):</span>
        <span class="s3"># for some values of parameters, hypergeom cdf was &gt;1, see gh-2238</span>
        <span class="s1">assert_(</span><span class="s4">0 </span><span class="s1">&lt;= stats.hypergeom.cdf(</span><span class="s4">30</span><span class="s2">, </span><span class="s4">13397950</span><span class="s2">, </span><span class="s4">4363</span><span class="s2">, </span><span class="s4">12390</span><span class="s1">) &lt;= </span><span class="s4">1.0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_precision2(self):</span>
        <span class="s3"># Test hypergeom precision for large numbers.  See #1218.</span>
        <span class="s3"># Results compared with those from R.</span>
        <span class="s1">oranges = </span><span class="s4">9.9e4</span>
        <span class="s1">pears = </span><span class="s4">1.1e5</span>
        <span class="s1">fruits_eaten = np.array([</span><span class="s4">3</span><span class="s2">, </span><span class="s4">3.8</span><span class="s2">, </span><span class="s4">3.9</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">4.1</span><span class="s2">, </span><span class="s4">4.2</span><span class="s2">, </span><span class="s4">5</span><span class="s1">]) * </span><span class="s4">1e4</span>
        <span class="s1">quantile = </span><span class="s4">2e4</span>
        <span class="s1">res = [stats.hypergeom.sf(quantile</span><span class="s2">, </span><span class="s1">oranges + pears</span><span class="s2">, </span><span class="s1">oranges</span><span class="s2">, </span><span class="s1">eaten)</span>
               <span class="s2">for </span><span class="s1">eaten </span><span class="s2">in </span><span class="s1">fruits_eaten]</span>
        <span class="s1">expected = np.array([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1.904153e-114</span><span class="s2">, </span><span class="s4">2.752693e-66</span><span class="s2">, </span><span class="s4">4.931217e-32</span><span class="s2">,</span>
                             <span class="s4">8.265601e-11</span><span class="s2">, </span><span class="s4">0.1237904</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>
        <span class="s1">assert_allclose(res</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">5e-7</span><span class="s1">)</span>

        <span class="s3"># Test with array_like first argument</span>
        <span class="s1">quantiles = [</span><span class="s4">1.9e4</span><span class="s2">, </span><span class="s4">2e4</span><span class="s2">, </span><span class="s4">2.1e4</span><span class="s2">, </span><span class="s4">2.15e4</span><span class="s1">]</span>
        <span class="s1">res2 = stats.hypergeom.sf(quantiles</span><span class="s2">, </span><span class="s1">oranges + pears</span><span class="s2">, </span><span class="s1">oranges</span><span class="s2">, </span><span class="s4">4.2e4</span><span class="s1">)</span>
        <span class="s1">expected2 = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.1237904</span><span class="s2">, </span><span class="s4">6.511452e-34</span><span class="s2">, </span><span class="s4">3.277667e-69</span><span class="s1">]</span>
        <span class="s1">assert_allclose(res2</span><span class="s2">, </span><span class="s1">expected2</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">5e-7</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_entropy(self):</span>
        <span class="s3"># Simple tests of entropy.</span>
        <span class="s1">hg = stats.hypergeom(</span><span class="s4">4</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">h = hg.entropy()</span>
        <span class="s1">expected_p = np.array([</span><span class="s4">0.75</span><span class="s2">, </span><span class="s4">0.25</span><span class="s1">])</span>
        <span class="s1">expected_h = -np.sum(xlogy(expected_p</span><span class="s2">, </span><span class="s1">expected_p))</span>
        <span class="s1">assert_allclose(h</span><span class="s2">, </span><span class="s1">expected_h)</span>

        <span class="s1">hg = stats.hypergeom(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">h = hg.entropy()</span>
        <span class="s1">assert_equal(h</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_logsf(self):</span>
        <span class="s3"># Test logsf for very large numbers. See issue #4982</span>
        <span class="s3"># Results compare with those from R (v3.2.0):</span>
        <span class="s3"># phyper(k, n, M-n, N, lower.tail=FALSE, log.p=TRUE)</span>
        <span class="s3"># -2239.771</span>

        <span class="s1">k = </span><span class="s4">1e4</span>
        <span class="s1">M = </span><span class="s4">1e7</span>
        <span class="s1">n = </span><span class="s4">1e6</span>
        <span class="s1">N = </span><span class="s4">5e4</span>

        <span class="s1">result = stats.hypergeom.logsf(k</span><span class="s2">, </span><span class="s1">M</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">N)</span>
        <span class="s1">expected = -</span><span class="s4">2239.771   </span><span class="s3"># From R</span>
        <span class="s1">assert_almost_equal(result</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">3</span><span class="s1">)</span>

        <span class="s1">k = </span><span class="s4">1</span>
        <span class="s1">M = </span><span class="s4">1600</span>
        <span class="s1">n = </span><span class="s4">600</span>
        <span class="s1">N = </span><span class="s4">300</span>

        <span class="s1">result = stats.hypergeom.logsf(k</span><span class="s2">, </span><span class="s1">M</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">N)</span>
        <span class="s1">expected = -</span><span class="s4">2.566567e-68   </span><span class="s3"># From R</span>
        <span class="s1">assert_almost_equal(result</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">15</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_logcdf(self):</span>
        <span class="s3"># Test logcdf for very large numbers. See issue #8692</span>
        <span class="s3"># Results compare with those from R (v3.3.2):</span>
        <span class="s3"># phyper(k, n, M-n, N, lower.tail=TRUE, log.p=TRUE)</span>
        <span class="s3"># -5273.335</span>

        <span class="s1">k = </span><span class="s4">1</span>
        <span class="s1">M = </span><span class="s4">1e7</span>
        <span class="s1">n = </span><span class="s4">1e6</span>
        <span class="s1">N = </span><span class="s4">5e4</span>

        <span class="s1">result = stats.hypergeom.logcdf(k</span><span class="s2">, </span><span class="s1">M</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">N)</span>
        <span class="s1">expected = -</span><span class="s4">5273.335   </span><span class="s3"># From R</span>
        <span class="s1">assert_almost_equal(result</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">3</span><span class="s1">)</span>

        <span class="s3"># Same example as in issue #8692</span>
        <span class="s1">k = </span><span class="s4">40</span>
        <span class="s1">M = </span><span class="s4">1600</span>
        <span class="s1">n = </span><span class="s4">50</span>
        <span class="s1">N = </span><span class="s4">300</span>

        <span class="s1">result = stats.hypergeom.logcdf(k</span><span class="s2">, </span><span class="s1">M</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">N)</span>
        <span class="s1">expected = -</span><span class="s4">7.565148879229e-23    </span><span class="s3"># From R</span>
        <span class="s1">assert_almost_equal(result</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">15</span><span class="s1">)</span>

        <span class="s1">k = </span><span class="s4">125</span>
        <span class="s1">M = </span><span class="s4">1600</span>
        <span class="s1">n = </span><span class="s4">250</span>
        <span class="s1">N = </span><span class="s4">500</span>

        <span class="s1">result = stats.hypergeom.logcdf(k</span><span class="s2">, </span><span class="s1">M</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">N)</span>
        <span class="s1">expected = -</span><span class="s4">4.242688e-12    </span><span class="s3"># From R</span>
        <span class="s1">assert_almost_equal(result</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">15</span><span class="s1">)</span>

        <span class="s3"># test broadcasting robustness based on reviewer</span>
        <span class="s3"># concerns in PR 9603; using an array version of</span>
        <span class="s3"># the example from issue #8692</span>
        <span class="s1">k = np.array([</span><span class="s4">40</span><span class="s2">, </span><span class="s4">40</span><span class="s2">, </span><span class="s4">40</span><span class="s1">])</span>
        <span class="s1">M = </span><span class="s4">1600</span>
        <span class="s1">n = </span><span class="s4">50</span>
        <span class="s1">N = </span><span class="s4">300</span>

        <span class="s1">result = stats.hypergeom.logcdf(k</span><span class="s2">, </span><span class="s1">M</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">N)</span>
        <span class="s1">expected = np.full(</span><span class="s4">3</span><span class="s2">, </span><span class="s1">-</span><span class="s4">7.565148879229e-23</span><span class="s1">)  </span><span class="s3"># filled from R result</span>
        <span class="s1">assert_almost_equal(result</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">15</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestLoggamma:</span>

    <span class="s3"># Expected cdf values were computed with mpmath. For given x and c,</span>
    <span class="s3">#     x = mpmath.mpf(x)</span>
    <span class="s3">#     c = mpmath.mpf(c)</span>
    <span class="s3">#     cdf = mpmath.gammainc(c, 0, mpmath.exp(x),</span>
    <span class="s3">#                           regularized=True)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'x, c, cdf'</span><span class="s2">,</span>
                             <span class="s1">[(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">0.7546378854206702</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">14</span><span class="s2">, </span><span class="s4">6.768116452566383e-18</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(-</span><span class="s4">745.1</span><span class="s2">, </span><span class="s4">0.001</span><span class="s2">, </span><span class="s4">0.4749605142005238</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(-</span><span class="s4">800</span><span class="s2">, </span><span class="s4">0.001</span><span class="s2">, </span><span class="s4">0.44958802911019136</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(-</span><span class="s4">725</span><span class="s2">, </span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">3.4301205868273265e-32</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(-</span><span class="s4">740</span><span class="s2">, </span><span class="s4">0.75</span><span class="s2">, </span><span class="s4">1.0074360436599631e-241</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_cdf_ppf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">cdf):</span>
        <span class="s1">p = stats.loggamma.cdf(x</span><span class="s2">, </span><span class="s1">c)</span>
        <span class="s1">assert_allclose(p</span><span class="s2">, </span><span class="s1">cdf</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-13</span><span class="s1">)</span>
        <span class="s1">y = stats.loggamma.ppf(cdf</span><span class="s2">, </span><span class="s1">c)</span>
        <span class="s1">assert_allclose(y</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-13</span><span class="s1">)</span>

    <span class="s3"># Expected sf values were computed with mpmath. For given x and c,</span>
    <span class="s3">#     x = mpmath.mpf(x)</span>
    <span class="s3">#     c = mpmath.mpf(c)</span>
    <span class="s3">#     sf = mpmath.gammainc(c, mpmath.exp(x), mpmath.inf,</span>
    <span class="s3">#                          regularized=True)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'x, c, sf'</span><span class="s2">,</span>
                             <span class="s1">[(</span><span class="s4">4</span><span class="s2">, </span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">1.6341528919488565e-23</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">6</span><span class="s2">, </span><span class="s4">100</span><span class="s2">, </span><span class="s4">8.23836829202024e-74</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(-</span><span class="s4">800</span><span class="s2">, </span><span class="s4">0.001</span><span class="s2">, </span><span class="s4">0.5504119708898086</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(-</span><span class="s4">743</span><span class="s2">, </span><span class="s4">0.0025</span><span class="s2">, </span><span class="s4">0.8437131370024089</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_sf_isf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">sf):</span>
        <span class="s1">s = stats.loggamma.sf(x</span><span class="s2">, </span><span class="s1">c)</span>
        <span class="s1">assert_allclose(s</span><span class="s2">, </span><span class="s1">sf</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-13</span><span class="s1">)</span>
        <span class="s1">y = stats.loggamma.isf(sf</span><span class="s2">, </span><span class="s1">c)</span>
        <span class="s1">assert_allclose(y</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-13</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_logpdf(self):</span>
        <span class="s3"># Test logpdf with x=-500, c=2.  ln(gamma(2)) = 0, and</span>
        <span class="s3"># exp(-500) ~= 7e-218, which is far smaller than the ULP</span>
        <span class="s3"># of c*x=-1000, so logpdf(-500, 2) = c*x - exp(x) - ln(gamma(2))</span>
        <span class="s3"># should give -1000.0.</span>
        <span class="s1">lp = stats.loggamma.logpdf(-</span><span class="s4">500</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">assert_allclose(lp</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1000.0</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-14</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_stats(self):</span>
        <span class="s3"># The following precomputed values are from the table in section 2.2</span>
        <span class="s3"># of &quot;A Statistical Study of Log-Gamma Distribution&quot;, by Ping Shing</span>
        <span class="s3"># Chan (thesis, McMaster University, 1993).</span>
        <span class="s1">table = np.array([</span>
                <span class="s3"># c,    mean,   var,    skew,    exc. kurt.</span>
                <span class="s4">0.5</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.9635</span><span class="s2">, </span><span class="s4">4.9348</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.5351</span><span class="s2">, </span><span class="s4">4.0000</span><span class="s2">,</span>
                <span class="s4">1.0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.5772</span><span class="s2">, </span><span class="s4">1.6449</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.1395</span><span class="s2">, </span><span class="s4">2.4000</span><span class="s2">,</span>
                <span class="s4">12.0</span><span class="s2">, </span><span class="s4">2.4427</span><span class="s2">, </span><span class="s4">0.0869</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.2946</span><span class="s2">, </span><span class="s4">0.1735</span><span class="s2">,</span>
            <span class="s1">]).reshape(-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">5</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">c</span><span class="s2">, </span><span class="s1">mean</span><span class="s2">, </span><span class="s1">var</span><span class="s2">, </span><span class="s1">skew</span><span class="s2">, </span><span class="s1">kurt </span><span class="s2">in </span><span class="s1">table:</span>
            <span class="s1">computed = stats.loggamma.stats(c</span><span class="s2">, </span><span class="s1">moments=</span><span class="s5">'msvk'</span><span class="s1">)</span>
            <span class="s1">assert_array_almost_equal(computed</span><span class="s2">, </span><span class="s1">[mean</span><span class="s2">, </span><span class="s1">var</span><span class="s2">, </span><span class="s1">skew</span><span class="s2">, </span><span class="s1">kurt]</span><span class="s2">,</span>
                                      <span class="s1">decimal=</span><span class="s4">4</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'c'</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.001</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_rvs(self</span><span class="s2">, </span><span class="s1">c):</span>
        <span class="s3"># Regression test for gh-11094.</span>
        <span class="s1">x = stats.loggamma.rvs(c</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">100000</span><span class="s1">)</span>
        <span class="s3"># Before gh-11094 was fixed, the case with c=0.001 would</span>
        <span class="s3"># generate many -inf values.</span>
        <span class="s2">assert </span><span class="s1">np.isfinite(x).all()</span>
        <span class="s3"># Crude statistical test.  About half the values should be</span>
        <span class="s3"># less than the median and half greater than the median.</span>
        <span class="s1">med = stats.loggamma.median(c)</span>
        <span class="s1">btest = stats.binomtest(np.count_nonzero(x &lt; med)</span><span class="s2">, </span><span class="s1">len(x))</span>
        <span class="s1">ci = btest.proportion_ci(confidence_level=</span><span class="s4">0.999</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">ci.low &lt; </span><span class="s4">0.5 </span><span class="s1">&lt; ci.high</span>


<span class="s2">class </span><span class="s1">TestJohnsonsu:</span>
    <span class="s3"># reference values were computed via mpmath</span>
    <span class="s3"># from mpmath import mp</span>
    <span class="s3"># mp.dps = 50</span>
    <span class="s3"># def johnsonsu_sf(x, a, b):</span>
    <span class="s3">#     x = mp.mpf(x)</span>
    <span class="s3">#     a = mp.mpf(a)</span>
    <span class="s3">#     b = mp.mpf(b)</span>
    <span class="s3">#     return float(mp.ncdf(-(a + b * mp.log(x + mp.sqrt(x*x + 1)))))</span>
    <span class="s3"># Order is x, a, b, sf, isf tol</span>
    <span class="s3"># (Can't expect full precision when the ISF input is very nearly 1)</span>
    <span class="s1">cases = [(-</span><span class="s4">500</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.9999999982660072</span><span class="s2">, </span><span class="s4">1e-8</span><span class="s1">)</span><span class="s2">,</span>
             <span class="s1">(</span><span class="s4">2000</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">7.426351000595343e-21</span><span class="s2">, </span><span class="s4">5e-14</span><span class="s1">)</span><span class="s2">,</span>
             <span class="s1">(</span><span class="s4">100000</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">4.046923979269977e-40</span><span class="s2">, </span><span class="s4">5e-14</span><span class="s1">)]</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;case&quot;</span><span class="s2">, </span><span class="s1">cases)</span>
    <span class="s2">def </span><span class="s1">test_sf_isf(self</span><span class="s2">, </span><span class="s1">case):</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">sf</span><span class="s2">, </span><span class="s1">tol = case</span>
        <span class="s1">assert_allclose(stats.johnsonsu.sf(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b)</span><span class="s2">, </span><span class="s1">sf</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">5e-14</span><span class="s1">)</span>
        <span class="s1">assert_allclose(stats.johnsonsu.isf(sf</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b)</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">rtol=tol)</span>


<span class="s2">class </span><span class="s1">TestJohnsonb:</span>
    <span class="s3"># reference values were computed via mpmath</span>
    <span class="s3"># from mpmath import mp</span>
    <span class="s3"># mp.dps = 50</span>
    <span class="s3"># def johnsonb_sf(x, a, b):</span>
    <span class="s3">#     x = mp.mpf(x)</span>
    <span class="s3">#     a = mp.mpf(a)</span>
    <span class="s3">#     b = mp.mpf(b)</span>
    <span class="s3">#     return float(mp.ncdf(-(a + b * mp.log(x/(mp.one - x)))))</span>
    <span class="s3"># Order is x, a, b, sf, isf atol</span>
    <span class="s3"># (Can't expect full precision when the ISF input is very nearly 1)</span>
    <span class="s1">cases = [(</span><span class="s4">1e-4</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.9999999999999999</span><span class="s2">, </span><span class="s4">1e-7</span><span class="s1">)</span><span class="s2">,</span>
             <span class="s1">(</span><span class="s4">0.9999</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">8.921114313932308e-25</span><span class="s2">, </span><span class="s4">5e-14</span><span class="s1">)</span><span class="s2">,</span>
             <span class="s1">(</span><span class="s4">0.999999</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">5.815197487181902e-50</span><span class="s2">, </span><span class="s4">5e-14</span><span class="s1">)]</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;case&quot;</span><span class="s2">, </span><span class="s1">cases)</span>
    <span class="s2">def </span><span class="s1">test_sf_isf(self</span><span class="s2">, </span><span class="s1">case):</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">sf</span><span class="s2">, </span><span class="s1">tol = case</span>
        <span class="s1">assert_allclose(stats.johnsonsb.sf(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b)</span><span class="s2">, </span><span class="s1">sf</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">5e-14</span><span class="s1">)</span>
        <span class="s1">assert_allclose(stats.johnsonsb.isf(sf</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b)</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">atol=tol)</span>


<span class="s2">class </span><span class="s1">TestLogistic:</span>
    <span class="s3"># gh-6226</span>
    <span class="s2">def </span><span class="s1">test_cdf_ppf(self):</span>
        <span class="s1">x = np.linspace(-</span><span class="s4">20</span><span class="s2">, </span><span class="s4">20</span><span class="s1">)</span>
        <span class="s1">y = stats.logistic.cdf(x)</span>
        <span class="s1">xx = stats.logistic.ppf(y)</span>
        <span class="s1">assert_allclose(x</span><span class="s2">, </span><span class="s1">xx)</span>

    <span class="s2">def </span><span class="s1">test_sf_isf(self):</span>
        <span class="s1">x = np.linspace(-</span><span class="s4">20</span><span class="s2">, </span><span class="s4">20</span><span class="s1">)</span>
        <span class="s1">y = stats.logistic.sf(x)</span>
        <span class="s1">xx = stats.logistic.isf(y)</span>
        <span class="s1">assert_allclose(x</span><span class="s2">, </span><span class="s1">xx)</span>

    <span class="s2">def </span><span class="s1">test_extreme_values(self):</span>
        <span class="s3"># p is chosen so that 1 - (1 - p) == p in double precision</span>
        <span class="s1">p = </span><span class="s4">9.992007221626409e-16</span>
        <span class="s1">desired = </span><span class="s4">34.53957599234088</span>
        <span class="s1">assert_allclose(stats.logistic.ppf(</span><span class="s4">1 </span><span class="s1">- p)</span><span class="s2">, </span><span class="s1">desired)</span>
        <span class="s1">assert_allclose(stats.logistic.isf(p)</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s2">def </span><span class="s1">test_logpdf_basic(self):</span>
        <span class="s1">logp = stats.logistic.logpdf([-</span><span class="s4">15</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">10</span><span class="s1">])</span>
        <span class="s3"># Expected values computed with mpmath with 50 digits of precision.</span>
        <span class="s1">expected = [-</span><span class="s4">15.000000611804547</span><span class="s2">,</span>
                    <span class="s1">-</span><span class="s4">1.3862943611198906</span><span class="s2">,</span>
                    <span class="s1">-</span><span class="s4">10.000090797798434</span><span class="s1">]</span>
        <span class="s1">assert_allclose(logp</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-13</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_logpdf_extreme_values(self):</span>
        <span class="s1">logp = stats.logistic.logpdf([</span><span class="s4">800</span><span class="s2">, </span><span class="s1">-</span><span class="s4">800</span><span class="s1">])</span>
        <span class="s3"># For such large arguments, logpdf(x) = -abs(x) when computed</span>
        <span class="s3"># with 64 bit floating point.</span>
        <span class="s1">assert_equal(logp</span><span class="s2">, </span><span class="s1">[-</span><span class="s4">800</span><span class="s2">, </span><span class="s1">-</span><span class="s4">800</span><span class="s1">])</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;loc_rvs,scale_rvs&quot;</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">0.4484955</span><span class="s2">, </span><span class="s4">0.10216821</span><span class="s1">)</span><span class="s2">,</span>
                                                   <span class="s1">(</span><span class="s4">0.62918191</span><span class="s2">, </span><span class="s4">0.74367064</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_fit(self</span><span class="s2">, </span><span class="s1">loc_rvs</span><span class="s2">, </span><span class="s1">scale_rvs):</span>
        <span class="s1">data = stats.logistic.rvs(size=</span><span class="s4">100</span><span class="s2">, </span><span class="s1">loc=loc_rvs</span><span class="s2">, </span><span class="s1">scale=scale_rvs)</span>

        <span class="s3"># test that result of fit method is the same as optimization</span>
        <span class="s2">def </span><span class="s1">func(input</span><span class="s2">, </span><span class="s1">data):</span>
            <span class="s1">a</span><span class="s2">, </span><span class="s1">b = input</span>
            <span class="s1">n = len(data)</span>
            <span class="s1">x1 = np.sum(np.exp((data - a) / b) /</span>
                        <span class="s1">(</span><span class="s4">1 </span><span class="s1">+ np.exp((data - a) / b))) - n / </span><span class="s4">2</span>
            <span class="s1">x2 = np.sum(((data - a) / b) *</span>
                        <span class="s1">((np.exp((data - a) / b) - </span><span class="s4">1</span><span class="s1">) /</span>
                         <span class="s1">(np.exp((data - a) / b) + </span><span class="s4">1</span><span class="s1">))) - n</span>
            <span class="s2">return </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">x2</span>

        <span class="s1">expected_solution = root(func</span><span class="s2">, </span><span class="s1">stats.logistic._fitstart(data)</span><span class="s2">, </span><span class="s1">args=(</span>
            <span class="s1">data</span><span class="s2">,</span><span class="s1">)).x</span>
        <span class="s1">fit_method = stats.logistic.fit(data)</span>

        <span class="s3"># other than computational variances, the fit method and the solution</span>
        <span class="s3"># to this system of equations are equal</span>
        <span class="s1">assert_allclose(fit_method</span><span class="s2">, </span><span class="s1">expected_solution</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-30</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_fit_comp_optimizer(self):</span>
        <span class="s1">data = stats.logistic.rvs(size=</span><span class="s4">100</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">_assert_less_or_close_loglike(stats.logistic</span><span class="s2">, </span><span class="s1">data)</span>
        <span class="s1">_assert_less_or_close_loglike(stats.logistic</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">floc=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">_assert_less_or_close_loglike(stats.logistic</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">fscale=</span><span class="s4">1</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'testlogcdf'</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_logcdfsf_tails(self</span><span class="s2">, </span><span class="s1">testlogcdf):</span>
        <span class="s3"># Test either logcdf or logsf.  By symmetry, we can use the same</span>
        <span class="s3"># expected values for both by switching the sign of x for logsf.</span>
        <span class="s1">x = np.array([-</span><span class="s4">10000</span><span class="s2">, </span><span class="s1">-</span><span class="s4">800</span><span class="s2">, </span><span class="s4">17</span><span class="s2">, </span><span class="s4">50</span><span class="s2">, </span><span class="s4">500</span><span class="s1">])</span>
        <span class="s2">if </span><span class="s1">testlogcdf:</span>
            <span class="s1">y = stats.logistic.logcdf(x)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">y = stats.logistic.logsf(-x)</span>
        <span class="s3"># The expected values were computed with mpmath.</span>
        <span class="s1">expected = [-</span><span class="s4">10000.0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">800.0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">4.139937633089748e-08</span><span class="s2">,</span>
                    <span class="s1">-</span><span class="s4">1.9287498479639178e-22</span><span class="s2">, </span><span class="s1">-</span><span class="s4">7.124576406741286e-218</span><span class="s1">]</span>
        <span class="s1">assert_allclose(y</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">2e-15</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_fit_gh_18176(self):</span>
        <span class="s3"># logistic.fit returned `scale &lt; 0` for this data. Check that this has</span>
        <span class="s3"># been fixed.</span>
        <span class="s1">data = np.array([-</span><span class="s4">459</span><span class="s2">, </span><span class="s4">37</span><span class="s2">, </span><span class="s4">43</span><span class="s2">, </span><span class="s4">45</span><span class="s2">, </span><span class="s4">45</span><span class="s2">, </span><span class="s4">48</span><span class="s2">, </span><span class="s4">54</span><span class="s2">, </span><span class="s4">55</span><span class="s2">, </span><span class="s4">58</span><span class="s1">]</span>
                        <span class="s1">+ [</span><span class="s4">59</span><span class="s1">] * </span><span class="s4">3 </span><span class="s1">+ [</span><span class="s4">61</span><span class="s1">] * </span><span class="s4">9</span><span class="s1">)</span>
        <span class="s3"># If scale were negative, NLLF would be infinite, so this would fail</span>
        <span class="s1">_assert_less_or_close_loglike(stats.logistic</span><span class="s2">, </span><span class="s1">data)</span>


<span class="s2">class </span><span class="s1">TestLogser:</span>
    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">np.random.seed(</span><span class="s4">1234</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_rvs(self):</span>
        <span class="s1">vals = stats.logser.rvs(</span><span class="s4">0.75</span><span class="s2">, </span><span class="s1">size=(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">50</span><span class="s1">))</span>
        <span class="s1">assert_(numpy.all(vals &gt;= </span><span class="s4">1</span><span class="s1">))</span>
        <span class="s1">assert_(numpy.shape(vals) == (</span><span class="s4">2</span><span class="s2">, </span><span class="s4">50</span><span class="s1">))</span>
        <span class="s1">assert_(vals.dtype.char </span><span class="s2">in </span><span class="s1">typecodes[</span><span class="s5">'AllInteger'</span><span class="s1">])</span>
        <span class="s1">val = stats.logser.rvs(</span><span class="s4">0.75</span><span class="s1">)</span>
        <span class="s1">assert_(isinstance(val</span><span class="s2">, </span><span class="s1">int))</span>
        <span class="s1">val = stats.logser(</span><span class="s4">0.75</span><span class="s1">).rvs(</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">assert_(isinstance(val</span><span class="s2">, </span><span class="s1">numpy.ndarray))</span>
        <span class="s1">assert_(val.dtype.char </span><span class="s2">in </span><span class="s1">typecodes[</span><span class="s5">'AllInteger'</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_pmf_small_p(self):</span>
        <span class="s1">m = stats.logser.pmf(</span><span class="s4">4</span><span class="s2">, </span><span class="s4">1e-20</span><span class="s1">)</span>
        <span class="s3"># The expected value was computed using mpmath:</span>
        <span class="s3">#   &gt;&gt;&gt; import mpmath</span>
        <span class="s3">#   &gt;&gt;&gt; mpmath.mp.dps = 64</span>
        <span class="s3">#   &gt;&gt;&gt; k = 4</span>
        <span class="s3">#   &gt;&gt;&gt; p = mpmath.mpf('1e-20')</span>
        <span class="s3">#   &gt;&gt;&gt; float(-(p**k)/k/mpmath.log(1-p))</span>
        <span class="s3">#   2.5e-61</span>
        <span class="s3"># It is also clear from noticing that for very small p,</span>
        <span class="s3"># log(1-p) is approximately -p, and the formula becomes</span>
        <span class="s3">#    p**(k-1) / k</span>
        <span class="s1">assert_allclose(m</span><span class="s2">, </span><span class="s4">2.5e-61</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_mean_small_p(self):</span>
        <span class="s1">m = stats.logser.mean(</span><span class="s4">1e-8</span><span class="s1">)</span>
        <span class="s3"># The expected mean was computed using mpmath:</span>
        <span class="s3">#   &gt;&gt;&gt; import mpmath</span>
        <span class="s3">#   &gt;&gt;&gt; mpmath.dps = 60</span>
        <span class="s3">#   &gt;&gt;&gt; p = mpmath.mpf('1e-8')</span>
        <span class="s3">#   &gt;&gt;&gt; float(-p / ((1 - p)*mpmath.log(1 - p)))</span>
        <span class="s3">#   1.000000005</span>
        <span class="s1">assert_allclose(m</span><span class="s2">, </span><span class="s4">1.000000005</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestGumbel_r_l:</span>
    <span class="s1">@pytest.fixture(scope=</span><span class="s5">'function'</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">rng(self):</span>
        <span class="s2">return </span><span class="s1">np.random.default_rng(</span><span class="s4">1234</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;dist&quot;</span><span class="s2">, </span><span class="s1">[stats.gumbel_r</span><span class="s2">, </span><span class="s1">stats.gumbel_l])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;loc_rvs&quot;</span><span class="s2">, </span><span class="s1">[-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;scale_rvs&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s4">.1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">5</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'fix_loc, fix_scale'</span><span class="s2">,</span>
                             <span class="s1">([</span><span class="s2">True, False</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s2">False, True</span><span class="s1">]))</span>
    <span class="s2">def </span><span class="s1">test_fit_comp_optimizer(self</span><span class="s2">, </span><span class="s1">dist</span><span class="s2">, </span><span class="s1">loc_rvs</span><span class="s2">, </span><span class="s1">scale_rvs</span><span class="s2">,</span>
                                <span class="s1">fix_loc</span><span class="s2">, </span><span class="s1">fix_scale</span><span class="s2">, </span><span class="s1">rng):</span>
        <span class="s1">data = dist.rvs(size=</span><span class="s4">100</span><span class="s2">, </span><span class="s1">loc=loc_rvs</span><span class="s2">, </span><span class="s1">scale=scale_rvs</span><span class="s2">,</span>
                        <span class="s1">random_state=rng)</span>

        <span class="s1">kwds = dict()</span>
        <span class="s3"># the fixed location and scales are arbitrarily modified to not be</span>
        <span class="s3"># close to the true value.</span>
        <span class="s2">if </span><span class="s1">fix_loc:</span>
            <span class="s1">kwds[</span><span class="s5">'floc'</span><span class="s1">] = loc_rvs * </span><span class="s4">2</span>
        <span class="s2">if </span><span class="s1">fix_scale:</span>
            <span class="s1">kwds[</span><span class="s5">'fscale'</span><span class="s1">] = scale_rvs * </span><span class="s4">2</span>

        <span class="s3"># test that the gumbel_* fit method is better than super method</span>
        <span class="s1">_assert_less_or_close_loglike(dist</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">**kwds)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;dist, sgn&quot;</span><span class="s2">, </span><span class="s1">[(stats.gumbel_r</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
                                           <span class="s1">(stats.gumbel_l</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_fit(self</span><span class="s2">, </span><span class="s1">dist</span><span class="s2">, </span><span class="s1">sgn):</span>
        <span class="s1">z = sgn*np.array([</span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">3.00000001</span><span class="s1">])</span>
        <span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = dist.fit(z)</span>
        <span class="s3"># The expected values were computed with mpmath with 60 digits</span>
        <span class="s3"># of precision.</span>
        <span class="s1">assert_allclose(loc</span><span class="s2">, </span><span class="s1">sgn*</span><span class="s4">3.0000000001667906</span><span class="s1">)</span>
        <span class="s1">assert_allclose(scale</span><span class="s2">, </span><span class="s4">1.2495222465145514e-09</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-6</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestPareto:</span>
    <span class="s2">def </span><span class="s1">test_stats(self):</span>
        <span class="s3"># Check the stats() method with some simple values. Also check</span>
        <span class="s3"># that the calculations do not trigger RuntimeWarnings.</span>
        <span class="s2">with </span><span class="s1">warnings.catch_warnings():</span>
            <span class="s1">warnings.simplefilter(</span><span class="s5">&quot;error&quot;</span><span class="s2">, </span><span class="s1">RuntimeWarning)</span>

            <span class="s1">m</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">k = stats.pareto.stats(</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">moments=</span><span class="s5">'mvsk'</span><span class="s1">)</span>
            <span class="s1">assert_equal(m</span><span class="s2">, </span><span class="s1">np.inf)</span>
            <span class="s1">assert_equal(v</span><span class="s2">, </span><span class="s1">np.inf)</span>
            <span class="s1">assert_equal(s</span><span class="s2">, </span><span class="s1">np.nan)</span>
            <span class="s1">assert_equal(k</span><span class="s2">, </span><span class="s1">np.nan)</span>

            <span class="s1">m</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">k = stats.pareto.stats(</span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">moments=</span><span class="s5">'mvsk'</span><span class="s1">)</span>
            <span class="s1">assert_equal(m</span><span class="s2">, </span><span class="s1">np.inf)</span>
            <span class="s1">assert_equal(v</span><span class="s2">, </span><span class="s1">np.inf)</span>
            <span class="s1">assert_equal(s</span><span class="s2">, </span><span class="s1">np.nan)</span>
            <span class="s1">assert_equal(k</span><span class="s2">, </span><span class="s1">np.nan)</span>

            <span class="s1">m</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">k = stats.pareto.stats(</span><span class="s4">1.5</span><span class="s2">, </span><span class="s1">moments=</span><span class="s5">'mvsk'</span><span class="s1">)</span>
            <span class="s1">assert_equal(m</span><span class="s2">, </span><span class="s4">3.0</span><span class="s1">)</span>
            <span class="s1">assert_equal(v</span><span class="s2">, </span><span class="s1">np.inf)</span>
            <span class="s1">assert_equal(s</span><span class="s2">, </span><span class="s1">np.nan)</span>
            <span class="s1">assert_equal(k</span><span class="s2">, </span><span class="s1">np.nan)</span>

            <span class="s1">m</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">k = stats.pareto.stats(</span><span class="s4">2.0</span><span class="s2">, </span><span class="s1">moments=</span><span class="s5">'mvsk'</span><span class="s1">)</span>
            <span class="s1">assert_equal(m</span><span class="s2">, </span><span class="s4">2.0</span><span class="s1">)</span>
            <span class="s1">assert_equal(v</span><span class="s2">, </span><span class="s1">np.inf)</span>
            <span class="s1">assert_equal(s</span><span class="s2">, </span><span class="s1">np.nan)</span>
            <span class="s1">assert_equal(k</span><span class="s2">, </span><span class="s1">np.nan)</span>

            <span class="s1">m</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">k = stats.pareto.stats(</span><span class="s4">2.5</span><span class="s2">, </span><span class="s1">moments=</span><span class="s5">'mvsk'</span><span class="s1">)</span>
            <span class="s1">assert_allclose(m</span><span class="s2">, </span><span class="s4">2.5 </span><span class="s1">/ </span><span class="s4">1.5</span><span class="s1">)</span>
            <span class="s1">assert_allclose(v</span><span class="s2">, </span><span class="s4">2.5 </span><span class="s1">/ (</span><span class="s4">1.5</span><span class="s1">*</span><span class="s4">1.5</span><span class="s1">*</span><span class="s4">0.5</span><span class="s1">))</span>
            <span class="s1">assert_equal(s</span><span class="s2">, </span><span class="s1">np.nan)</span>
            <span class="s1">assert_equal(k</span><span class="s2">, </span><span class="s1">np.nan)</span>

            <span class="s1">m</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">k = stats.pareto.stats(</span><span class="s4">3.0</span><span class="s2">, </span><span class="s1">moments=</span><span class="s5">'mvsk'</span><span class="s1">)</span>
            <span class="s1">assert_allclose(m</span><span class="s2">, </span><span class="s4">1.5</span><span class="s1">)</span>
            <span class="s1">assert_allclose(v</span><span class="s2">, </span><span class="s4">0.75</span><span class="s1">)</span>
            <span class="s1">assert_equal(s</span><span class="s2">, </span><span class="s1">np.nan)</span>
            <span class="s1">assert_equal(k</span><span class="s2">, </span><span class="s1">np.nan)</span>

            <span class="s1">m</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">k = stats.pareto.stats(</span><span class="s4">3.5</span><span class="s2">, </span><span class="s1">moments=</span><span class="s5">'mvsk'</span><span class="s1">)</span>
            <span class="s1">assert_allclose(m</span><span class="s2">, </span><span class="s4">3.5 </span><span class="s1">/ </span><span class="s4">2.5</span><span class="s1">)</span>
            <span class="s1">assert_allclose(v</span><span class="s2">, </span><span class="s4">3.5 </span><span class="s1">/ (</span><span class="s4">2.5</span><span class="s1">*</span><span class="s4">2.5</span><span class="s1">*</span><span class="s4">1.5</span><span class="s1">))</span>
            <span class="s1">assert_allclose(s</span><span class="s2">, </span><span class="s1">(</span><span class="s4">2</span><span class="s1">*</span><span class="s4">4.5</span><span class="s1">/</span><span class="s4">0.5</span><span class="s1">)*np.sqrt(</span><span class="s4">1.5</span><span class="s1">/</span><span class="s4">3.5</span><span class="s1">))</span>
            <span class="s1">assert_equal(k</span><span class="s2">, </span><span class="s1">np.nan)</span>

            <span class="s1">m</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">k = stats.pareto.stats(</span><span class="s4">4.0</span><span class="s2">, </span><span class="s1">moments=</span><span class="s5">'mvsk'</span><span class="s1">)</span>
            <span class="s1">assert_allclose(m</span><span class="s2">, </span><span class="s4">4.0 </span><span class="s1">/ </span><span class="s4">3.0</span><span class="s1">)</span>
            <span class="s1">assert_allclose(v</span><span class="s2">, </span><span class="s4">4.0 </span><span class="s1">/ </span><span class="s4">18.0</span><span class="s1">)</span>
            <span class="s1">assert_allclose(s</span><span class="s2">, </span><span class="s4">2</span><span class="s1">*(</span><span class="s4">1</span><span class="s1">+</span><span class="s4">4.0</span><span class="s1">)/(</span><span class="s4">4.0</span><span class="s1">-</span><span class="s4">3</span><span class="s1">) * np.sqrt((</span><span class="s4">4.0</span><span class="s1">-</span><span class="s4">2</span><span class="s1">)/</span><span class="s4">4.0</span><span class="s1">))</span>
            <span class="s1">assert_equal(k</span><span class="s2">, </span><span class="s1">np.nan)</span>

            <span class="s1">m</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">k = stats.pareto.stats(</span><span class="s4">4.5</span><span class="s2">, </span><span class="s1">moments=</span><span class="s5">'mvsk'</span><span class="s1">)</span>
            <span class="s1">assert_allclose(m</span><span class="s2">, </span><span class="s4">4.5 </span><span class="s1">/ </span><span class="s4">3.5</span><span class="s1">)</span>
            <span class="s1">assert_allclose(v</span><span class="s2">, </span><span class="s4">4.5 </span><span class="s1">/ (</span><span class="s4">3.5</span><span class="s1">*</span><span class="s4">3.5</span><span class="s1">*</span><span class="s4">2.5</span><span class="s1">))</span>
            <span class="s1">assert_allclose(s</span><span class="s2">, </span><span class="s1">(</span><span class="s4">2</span><span class="s1">*</span><span class="s4">5.5</span><span class="s1">/</span><span class="s4">1.5</span><span class="s1">) * np.sqrt(</span><span class="s4">2.5</span><span class="s1">/</span><span class="s4">4.5</span><span class="s1">))</span>
            <span class="s1">assert_allclose(k</span><span class="s2">, </span><span class="s4">6</span><span class="s1">*(</span><span class="s4">4.5</span><span class="s1">**</span><span class="s4">3 </span><span class="s1">+ </span><span class="s4">4.5</span><span class="s1">**</span><span class="s4">2 </span><span class="s1">- </span><span class="s4">6</span><span class="s1">*</span><span class="s4">4.5 </span><span class="s1">- </span><span class="s4">2</span><span class="s1">)/(</span><span class="s4">4.5</span><span class="s1">*</span><span class="s4">1.5</span><span class="s1">*</span><span class="s4">0.5</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_sf(self):</span>
        <span class="s1">x = </span><span class="s4">1e9</span>
        <span class="s1">b = </span><span class="s4">2</span>
        <span class="s1">scale = </span><span class="s4">1.5</span>
        <span class="s1">p = stats.pareto.sf(x</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">scale=scale)</span>
        <span class="s1">expected = (scale/x)**b   </span><span class="s3"># 2.25e-18</span>
        <span class="s1">assert_allclose(p</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.fixture(scope=</span><span class="s5">'function'</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">rng(self):</span>
        <span class="s2">return </span><span class="s1">np.random.default_rng(</span><span class="s4">1234</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.filterwarnings(</span><span class="s5">&quot;ignore:invalid value encountered in &quot;</span>
                                <span class="s5">&quot;double_scalars&quot;</span><span class="s1">)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;rvs_shape&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;rvs_loc&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;rvs_scale&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">5</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_fit(self</span><span class="s2">, </span><span class="s1">rvs_shape</span><span class="s2">, </span><span class="s1">rvs_loc</span><span class="s2">, </span><span class="s1">rvs_scale</span><span class="s2">, </span><span class="s1">rng):</span>
        <span class="s1">data = stats.pareto.rvs(size=</span><span class="s4">100</span><span class="s2">, </span><span class="s1">b=rvs_shape</span><span class="s2">, </span><span class="s1">scale=rvs_scale</span><span class="s2">,</span>
                                <span class="s1">loc=rvs_loc</span><span class="s2">, </span><span class="s1">random_state=rng)</span>

        <span class="s3"># shape can still be fixed with multiple names</span>
        <span class="s1">shape_mle_analytical1 = stats.pareto.fit(data</span><span class="s2">, </span><span class="s1">floc=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">f0=</span><span class="s4">1.04</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">shape_mle_analytical2 = stats.pareto.fit(data</span><span class="s2">, </span><span class="s1">floc=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">fix_b=</span><span class="s4">1.04</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">shape_mle_analytical3 = stats.pareto.fit(data</span><span class="s2">, </span><span class="s1">floc=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">fb=</span><span class="s4">1.04</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s2">assert </span><span class="s1">(shape_mle_analytical1 == shape_mle_analytical2 ==</span>
                <span class="s1">shape_mle_analytical3 == </span><span class="s4">1.04</span><span class="s1">)</span>

        <span class="s3"># data can be shifted with changes to `loc`</span>
        <span class="s1">data = stats.pareto.rvs(size=</span><span class="s4">100</span><span class="s2">, </span><span class="s1">b=rvs_shape</span><span class="s2">, </span><span class="s1">scale=rvs_scale</span><span class="s2">,</span>
                                <span class="s1">loc=(rvs_loc + </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">random_state=rng)</span>
        <span class="s1">shape_mle_a</span><span class="s2">, </span><span class="s1">loc_mle_a</span><span class="s2">, </span><span class="s1">scale_mle_a = stats.pareto.fit(data</span><span class="s2">, </span><span class="s1">floc=</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">assert_equal(scale_mle_a + </span><span class="s4">2</span><span class="s2">, </span><span class="s1">data.min())</span>

        <span class="s1">data_shift = data - </span><span class="s4">2</span>
        <span class="s1">ndata = data_shift.shape[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">assert_equal(shape_mle_a</span><span class="s2">,</span>
                     <span class="s1">ndata / np.sum(np.log(data_shift/data_shift.min())))</span>
        <span class="s1">assert_equal(loc_mle_a</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;rvs_shape&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s4">.1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;rvs_loc&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;rvs_scale&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">5</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'fix_shape, fix_loc, fix_scale'</span><span class="s2">,</span>
                             <span class="s1">[p </span><span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">product([</span><span class="s2">True, False</span><span class="s1">]</span><span class="s2">, </span><span class="s1">repeat=</span><span class="s4">3</span><span class="s1">)</span>
                              <span class="s2">if False in </span><span class="s1">p])</span>
    <span class="s1">@np.errstate(invalid=</span><span class="s5">&quot;ignore&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_fit_MLE_comp_optimizer(self</span><span class="s2">, </span><span class="s1">rvs_shape</span><span class="s2">, </span><span class="s1">rvs_loc</span><span class="s2">, </span><span class="s1">rvs_scale</span><span class="s2">,</span>
                                    <span class="s1">fix_shape</span><span class="s2">, </span><span class="s1">fix_loc</span><span class="s2">, </span><span class="s1">fix_scale</span><span class="s2">, </span><span class="s1">rng):</span>
        <span class="s1">data = stats.pareto.rvs(size=</span><span class="s4">100</span><span class="s2">, </span><span class="s1">b=rvs_shape</span><span class="s2">, </span><span class="s1">scale=rvs_scale</span><span class="s2">,</span>
                                <span class="s1">loc=rvs_loc</span><span class="s2">, </span><span class="s1">random_state=rng)</span>

        <span class="s1">kwds = {}</span>
        <span class="s2">if </span><span class="s1">fix_shape:</span>
            <span class="s1">kwds[</span><span class="s5">'f0'</span><span class="s1">] = rvs_shape</span>
        <span class="s2">if </span><span class="s1">fix_loc:</span>
            <span class="s1">kwds[</span><span class="s5">'floc'</span><span class="s1">] = rvs_loc</span>
        <span class="s2">if </span><span class="s1">fix_scale:</span>
            <span class="s1">kwds[</span><span class="s5">'fscale'</span><span class="s1">] = rvs_scale</span>

        <span class="s1">_assert_less_or_close_loglike(stats.pareto</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">**kwds)</span>

    <span class="s1">@np.errstate(invalid=</span><span class="s5">&quot;ignore&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_fit_known_bad_seed(self):</span>
        <span class="s3"># Tests a known seed and set of parameters that would produce a result</span>
        <span class="s3"># would violate the support of Pareto if the fit method did not check</span>
        <span class="s3"># the constraint `fscale + floc &lt; min(data)`.</span>
        <span class="s1">shape</span><span class="s2">, </span><span class="s1">location</span><span class="s2">, </span><span class="s1">scale = </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span>
        <span class="s1">data = stats.pareto.rvs(shape</span><span class="s2">, </span><span class="s1">location</span><span class="s2">, </span><span class="s1">scale</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">100</span><span class="s2">,</span>
                                <span class="s1">random_state=np.random.default_rng(</span><span class="s4">2535619</span><span class="s1">))</span>
        <span class="s1">_assert_less_or_close_loglike(stats.pareto</span><span class="s2">, </span><span class="s1">data)</span>

    <span class="s2">def </span><span class="s1">test_fit_warnings(self):</span>
        <span class="s1">assert_fit_warnings(stats.pareto)</span>
        <span class="s3"># `floc` that causes invalid negative data</span>
        <span class="s1">assert_raises(FitDataError</span><span class="s2">, </span><span class="s1">stats.pareto.fit</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">floc=</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s3"># `floc` and `fscale` combination causes invalid data</span>
        <span class="s1">assert_raises(FitDataError</span><span class="s2">, </span><span class="s1">stats.pareto.fit</span><span class="s2">, </span><span class="s1">[</span><span class="s4">5</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">floc=</span><span class="s4">1</span><span class="s2">,</span>
                      <span class="s1">fscale=</span><span class="s4">3</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_negative_data(self</span><span class="s2">, </span><span class="s1">rng):</span>
        <span class="s1">data = stats.pareto.rvs(loc=-</span><span class="s4">130</span><span class="s2">, </span><span class="s1">b=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">100</span><span class="s2">, </span><span class="s1">random_state=rng)</span>
        <span class="s1">assert_array_less(data</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s3"># The purpose of this test is to make sure that no runtime warnings are</span>
        <span class="s3"># raised for all negative data, not the output of the fit method. Other</span>
        <span class="s3"># methods test the output but have to silence warnings from the super</span>
        <span class="s3"># method.</span>
        <span class="s1">_ = stats.pareto.fit(data)</span>


<span class="s2">class </span><span class="s1">TestGenpareto:</span>
    <span class="s2">def </span><span class="s1">test_ab(self):</span>
        <span class="s3"># c &gt;= 0: a, b = [0, inf]</span>
        <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">[</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0.</span><span class="s1">]:</span>
            <span class="s1">c = np.asarray(c)</span>
            <span class="s1">a</span><span class="s2">, </span><span class="s1">b = stats.genpareto._get_support(c)</span>
            <span class="s1">assert_equal(a</span><span class="s2">, </span><span class="s4">0.</span><span class="s1">)</span>
            <span class="s1">assert_(np.isposinf(b))</span>

        <span class="s3"># c &lt; 0: a=0, b=1/|c|</span>
        <span class="s1">c = np.asarray(-</span><span class="s4">2.</span><span class="s1">)</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">b = stats.genpareto._get_support(c)</span>
        <span class="s1">assert_allclose([a</span><span class="s2">, </span><span class="s1">b]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_c0(self):</span>
        <span class="s3"># with c=0, genpareto reduces to the exponential distribution</span>
        <span class="s3"># rv = stats.genpareto(c=0.)</span>
        <span class="s1">rv = stats.genpareto(c=</span><span class="s4">0.</span><span class="s1">)</span>
        <span class="s1">x = np.linspace(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">10.</span><span class="s2">, </span><span class="s4">30</span><span class="s1">)</span>
        <span class="s1">assert_allclose(rv.pdf(x)</span><span class="s2">, </span><span class="s1">stats.expon.pdf(x))</span>
        <span class="s1">assert_allclose(rv.cdf(x)</span><span class="s2">, </span><span class="s1">stats.expon.cdf(x))</span>
        <span class="s1">assert_allclose(rv.sf(x)</span><span class="s2">, </span><span class="s1">stats.expon.sf(x))</span>

        <span class="s1">q = np.linspace(</span><span class="s4">0.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">assert_allclose(rv.ppf(q)</span><span class="s2">, </span><span class="s1">stats.expon.ppf(q))</span>

    <span class="s2">def </span><span class="s1">test_cm1(self):</span>
        <span class="s3"># with c=-1, genpareto reduces to the uniform distr on [0, 1]</span>
        <span class="s1">rv = stats.genpareto(c=-</span><span class="s4">1.</span><span class="s1">)</span>
        <span class="s1">x = np.linspace(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">10.</span><span class="s2">, </span><span class="s4">30</span><span class="s1">)</span>
        <span class="s1">assert_allclose(rv.pdf(x)</span><span class="s2">, </span><span class="s1">stats.uniform.pdf(x))</span>
        <span class="s1">assert_allclose(rv.cdf(x)</span><span class="s2">, </span><span class="s1">stats.uniform.cdf(x))</span>
        <span class="s1">assert_allclose(rv.sf(x)</span><span class="s2">, </span><span class="s1">stats.uniform.sf(x))</span>

        <span class="s1">q = np.linspace(</span><span class="s4">0.</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">assert_allclose(rv.ppf(q)</span><span class="s2">, </span><span class="s1">stats.uniform.ppf(q))</span>

        <span class="s3"># logpdf(1., c=-1) should be zero</span>
        <span class="s1">assert_allclose(rv.logpdf(</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_x_inf(self):</span>
        <span class="s3"># make sure x=inf is handled gracefully</span>
        <span class="s1">rv = stats.genpareto(c=</span><span class="s4">0.1</span><span class="s1">)</span>
        <span class="s1">assert_allclose([rv.pdf(np.inf)</span><span class="s2">, </span><span class="s1">rv.cdf(np.inf)]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">])</span>
        <span class="s1">assert_(np.isneginf(rv.logpdf(np.inf)))</span>

        <span class="s1">rv = stats.genpareto(c=</span><span class="s4">0.</span><span class="s1">)</span>
        <span class="s1">assert_allclose([rv.pdf(np.inf)</span><span class="s2">, </span><span class="s1">rv.cdf(np.inf)]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">])</span>
        <span class="s1">assert_(np.isneginf(rv.logpdf(np.inf)))</span>

        <span class="s1">rv = stats.genpareto(c=-</span><span class="s4">1.</span><span class="s1">)</span>
        <span class="s1">assert_allclose([rv.pdf(np.inf)</span><span class="s2">, </span><span class="s1">rv.cdf(np.inf)]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">])</span>
        <span class="s1">assert_(np.isneginf(rv.logpdf(np.inf)))</span>

    <span class="s2">def </span><span class="s1">test_c_continuity(self):</span>
        <span class="s3"># pdf is continuous at c=0, -1</span>
        <span class="s1">x = np.linspace(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">30</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]:</span>
            <span class="s1">pdf0 = stats.genpareto.pdf(x</span><span class="s2">, </span><span class="s1">c)</span>
            <span class="s2">for </span><span class="s1">dc </span><span class="s2">in </span><span class="s1">[</span><span class="s4">1e-14</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1e-14</span><span class="s1">]:</span>
                <span class="s1">pdfc = stats.genpareto.pdf(x</span><span class="s2">, </span><span class="s1">c + dc)</span>
                <span class="s1">assert_allclose(pdf0</span><span class="s2">, </span><span class="s1">pdfc</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-12</span><span class="s1">)</span>

            <span class="s1">cdf0 = stats.genpareto.cdf(x</span><span class="s2">, </span><span class="s1">c)</span>
            <span class="s2">for </span><span class="s1">dc </span><span class="s2">in </span><span class="s1">[</span><span class="s4">1e-14</span><span class="s2">, </span><span class="s4">1e-14</span><span class="s1">]:</span>
                <span class="s1">cdfc = stats.genpareto.cdf(x</span><span class="s2">, </span><span class="s1">c + dc)</span>
                <span class="s1">assert_allclose(cdf0</span><span class="s2">, </span><span class="s1">cdfc</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-12</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_c_continuity_ppf(self):</span>
        <span class="s1">q = np.r_[np.logspace(</span><span class="s4">1e-12</span><span class="s2">, </span><span class="s4">0.01</span><span class="s2">, </span><span class="s1">base=</span><span class="s4">0.1</span><span class="s1">)</span><span class="s2">,</span>
                  <span class="s1">np.linspace(</span><span class="s4">0.01</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">30</span><span class="s2">, </span><span class="s1">endpoint=</span><span class="s2">False</span><span class="s1">)</span><span class="s2">,</span>
                  <span class="s4">1. </span><span class="s1">- np.logspace(</span><span class="s4">1e-12</span><span class="s2">, </span><span class="s4">0.01</span><span class="s2">, </span><span class="s1">base=</span><span class="s4">0.1</span><span class="s1">)]</span>
        <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">[</span><span class="s4">0.</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.</span><span class="s1">]:</span>
            <span class="s1">ppf0 = stats.genpareto.ppf(q</span><span class="s2">, </span><span class="s1">c)</span>
            <span class="s2">for </span><span class="s1">dc </span><span class="s2">in </span><span class="s1">[</span><span class="s4">1e-14</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1e-14</span><span class="s1">]:</span>
                <span class="s1">ppfc = stats.genpareto.ppf(q</span><span class="s2">, </span><span class="s1">c + dc)</span>
                <span class="s1">assert_allclose(ppf0</span><span class="s2">, </span><span class="s1">ppfc</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-12</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_c_continuity_isf(self):</span>
        <span class="s1">q = np.r_[np.logspace(</span><span class="s4">1e-12</span><span class="s2">, </span><span class="s4">0.01</span><span class="s2">, </span><span class="s1">base=</span><span class="s4">0.1</span><span class="s1">)</span><span class="s2">,</span>
                  <span class="s1">np.linspace(</span><span class="s4">0.01</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">30</span><span class="s2">, </span><span class="s1">endpoint=</span><span class="s2">False</span><span class="s1">)</span><span class="s2">,</span>
                  <span class="s4">1. </span><span class="s1">- np.logspace(</span><span class="s4">1e-12</span><span class="s2">, </span><span class="s4">0.01</span><span class="s2">, </span><span class="s1">base=</span><span class="s4">0.1</span><span class="s1">)]</span>
        <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">[</span><span class="s4">0.</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.</span><span class="s1">]:</span>
            <span class="s1">isf0 = stats.genpareto.isf(q</span><span class="s2">, </span><span class="s1">c)</span>
            <span class="s2">for </span><span class="s1">dc </span><span class="s2">in </span><span class="s1">[</span><span class="s4">1e-14</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1e-14</span><span class="s1">]:</span>
                <span class="s1">isfc = stats.genpareto.isf(q</span><span class="s2">, </span><span class="s1">c + dc)</span>
                <span class="s1">assert_allclose(isf0</span><span class="s2">, </span><span class="s1">isfc</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-12</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_cdf_ppf_roundtrip(self):</span>
        <span class="s3"># this should pass with machine precision. hat tip @pbrod</span>
        <span class="s1">q = np.r_[np.logspace(</span><span class="s4">1e-12</span><span class="s2">, </span><span class="s4">0.01</span><span class="s2">, </span><span class="s1">base=</span><span class="s4">0.1</span><span class="s1">)</span><span class="s2">,</span>
                  <span class="s1">np.linspace(</span><span class="s4">0.01</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">30</span><span class="s2">, </span><span class="s1">endpoint=</span><span class="s2">False</span><span class="s1">)</span><span class="s2">,</span>
                  <span class="s4">1. </span><span class="s1">- np.logspace(</span><span class="s4">1e-12</span><span class="s2">, </span><span class="s4">0.01</span><span class="s2">, </span><span class="s1">base=</span><span class="s4">0.1</span><span class="s1">)]</span>
        <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">[</span><span class="s4">1e-8</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1e-18</span><span class="s2">, </span><span class="s4">1e-15</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1e-15</span><span class="s1">]:</span>
            <span class="s1">assert_allclose(stats.genpareto.cdf(stats.genpareto.ppf(q</span><span class="s2">, </span><span class="s1">c)</span><span class="s2">, </span><span class="s1">c)</span><span class="s2">,</span>
                            <span class="s1">q</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-15</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_logsf(self):</span>
        <span class="s1">logp = stats.genpareto.logsf(</span><span class="s4">1e10</span><span class="s2">, </span><span class="s4">.01</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(logp</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1842.0680753952365</span><span class="s1">)</span>

    <span class="s3"># Values in 'expected_stats' are</span>
    <span class="s3"># [mean, variance, skewness, excess kurtosis].</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s5">'c, expected_stats'</span><span class="s2">,</span>
        <span class="s1">[(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">6</span><span class="s1">])</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">1</span><span class="s1">/</span><span class="s4">4</span><span class="s2">, </span><span class="s1">[</span><span class="s4">4</span><span class="s1">/</span><span class="s4">3</span><span class="s2">, </span><span class="s4">32</span><span class="s1">/</span><span class="s4">9</span><span class="s2">, </span><span class="s4">10</span><span class="s1">/np.sqrt(</span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.nan])</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">1</span><span class="s1">/</span><span class="s4">9</span><span class="s2">, </span><span class="s1">[</span><span class="s4">9</span><span class="s1">/</span><span class="s4">8</span><span class="s2">, </span><span class="s1">(</span><span class="s4">81</span><span class="s1">/</span><span class="s4">64</span><span class="s1">)*(</span><span class="s4">9</span><span class="s1">/</span><span class="s4">7</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">10</span><span class="s1">/</span><span class="s4">9</span><span class="s1">)*np.sqrt(</span><span class="s4">7</span><span class="s1">)</span><span class="s2">, </span><span class="s4">754</span><span class="s1">/</span><span class="s4">45</span><span class="s1">])</span><span class="s2">,</span>
         <span class="s1">(-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s1">/</span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s1">/</span><span class="s4">12</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">6</span><span class="s1">/</span><span class="s4">5</span><span class="s1">])])</span>
    <span class="s2">def </span><span class="s1">test_stats(self</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">expected_stats):</span>
        <span class="s1">result = stats.genpareto.stats(c</span><span class="s2">, </span><span class="s1">moments=</span><span class="s5">'mvsk'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(result</span><span class="s2">, </span><span class="s1">expected_stats</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-13</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-15</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_var(self):</span>
        <span class="s3"># Regression test for gh-11168.</span>
        <span class="s1">v = stats.genpareto.var(</span><span class="s4">1e-8</span><span class="s1">)</span>
        <span class="s1">assert_allclose(v</span><span class="s2">, </span><span class="s4">1.000000040000001</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-13</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestPearson3:</span>
    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">np.random.seed(</span><span class="s4">1234</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_rvs(self):</span>
        <span class="s1">vals = stats.pearson3.rvs(</span><span class="s4">0.1</span><span class="s2">, </span><span class="s1">size=(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">50</span><span class="s1">))</span>
        <span class="s1">assert_(numpy.shape(vals) == (</span><span class="s4">2</span><span class="s2">, </span><span class="s4">50</span><span class="s1">))</span>
        <span class="s1">assert_(vals.dtype.char </span><span class="s2">in </span><span class="s1">typecodes[</span><span class="s5">'AllFloat'</span><span class="s1">])</span>
        <span class="s1">val = stats.pearson3.rvs(</span><span class="s4">0.5</span><span class="s1">)</span>
        <span class="s1">assert_(isinstance(val</span><span class="s2">, </span><span class="s1">float))</span>
        <span class="s1">val = stats.pearson3(</span><span class="s4">0.5</span><span class="s1">).rvs(</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">assert_(isinstance(val</span><span class="s2">, </span><span class="s1">numpy.ndarray))</span>
        <span class="s1">assert_(val.dtype.char </span><span class="s2">in </span><span class="s1">typecodes[</span><span class="s5">'AllFloat'</span><span class="s1">])</span>
        <span class="s1">assert_(len(val) == </span><span class="s4">3</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_pdf(self):</span>
        <span class="s1">vals = stats.pearson3.pdf(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.2</span><span class="s1">])</span>
        <span class="s1">assert_allclose(vals</span><span class="s2">, </span><span class="s1">np.array([</span><span class="s4">0.05399097</span><span class="s2">, </span><span class="s4">0.05555481</span><span class="s2">, </span><span class="s4">0.05670246</span><span class="s1">])</span><span class="s2">,</span>
                        <span class="s1">atol=</span><span class="s4">1e-6</span><span class="s1">)</span>
        <span class="s1">vals = stats.pearson3.pdf(-</span><span class="s4">3</span><span class="s2">, </span><span class="s4">0.1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(vals</span><span class="s2">, </span><span class="s1">np.array([</span><span class="s4">0.00313791</span><span class="s1">])</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-6</span><span class="s1">)</span>
        <span class="s1">vals = stats.pearson3.pdf([-</span><span class="s4">3</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s4">0.1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(vals</span><span class="s2">, </span><span class="s1">np.array([</span><span class="s4">0.00313791</span><span class="s2">, </span><span class="s4">0.05192304</span><span class="s2">, </span><span class="s4">0.25028092</span><span class="s2">,</span>
                                        <span class="s4">0.39885918</span><span class="s2">, </span><span class="s4">0.23413173</span><span class="s1">])</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-6</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_cdf(self):</span>
        <span class="s1">vals = stats.pearson3.cdf(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.2</span><span class="s1">])</span>
        <span class="s1">assert_allclose(vals</span><span class="s2">, </span><span class="s1">np.array([</span><span class="s4">0.97724987</span><span class="s2">, </span><span class="s4">0.97462004</span><span class="s2">, </span><span class="s4">0.97213626</span><span class="s1">])</span><span class="s2">,</span>
                        <span class="s1">atol=</span><span class="s4">1e-6</span><span class="s1">)</span>
        <span class="s1">vals = stats.pearson3.cdf(-</span><span class="s4">3</span><span class="s2">, </span><span class="s4">0.1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(vals</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.00082256</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-6</span><span class="s1">)</span>
        <span class="s1">vals = stats.pearson3.cdf([-</span><span class="s4">3</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s4">0.1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(vals</span><span class="s2">, </span><span class="s1">[</span><span class="s4">8.22563821e-04</span><span class="s2">, </span><span class="s4">1.99860448e-02</span><span class="s2">, </span><span class="s4">1.58550710e-01</span><span class="s2">,</span>
                               <span class="s4">5.06649130e-01</span><span class="s2">, </span><span class="s4">8.41442111e-01</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-6</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_negative_cdf_bug_11186(self):</span>
        <span class="s3"># incorrect CDFs for negative skews in gh-11186; fixed in gh-12640</span>
        <span class="s3"># Also check vectorization w/ negative, zero, and positive skews</span>
        <span class="s1">skews = [-</span><span class="s4">3</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">]</span>
        <span class="s1">x_eval = </span><span class="s4">0.5</span>
        <span class="s1">neg_inf = -</span><span class="s4">30  </span><span class="s3"># avoid RuntimeWarning caused by np.log(0)</span>
        <span class="s1">cdfs = stats.pearson3.cdf(x_eval</span><span class="s2">, </span><span class="s1">skews)</span>
        <span class="s1">int_pdfs = [quad(stats.pearson3(skew).pdf</span><span class="s2">, </span><span class="s1">neg_inf</span><span class="s2">, </span><span class="s1">x_eval)[</span><span class="s4">0</span><span class="s1">]</span>
                    <span class="s2">for </span><span class="s1">skew </span><span class="s2">in </span><span class="s1">skews]</span>
        <span class="s1">assert_allclose(cdfs</span><span class="s2">, </span><span class="s1">int_pdfs)</span>

    <span class="s2">def </span><span class="s1">test_return_array_bug_11746(self):</span>
        <span class="s3"># pearson3.moment was returning size 0 or 1 array instead of float</span>
        <span class="s3"># The first moment is equal to the loc, which defaults to zero</span>
        <span class="s1">moment = stats.pearson3.moment(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">assert_equal(moment</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">isinstance(moment</span><span class="s2">, </span><span class="s1">np.number)</span>

        <span class="s1">moment = stats.pearson3.moment(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.000001</span><span class="s1">)</span>
        <span class="s1">assert_equal(moment</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">isinstance(moment</span><span class="s2">, </span><span class="s1">np.number)</span>

    <span class="s2">def </span><span class="s1">test_ppf_bug_17050(self):</span>
        <span class="s3"># incorrect PPF for negative skews were reported in gh-17050</span>
        <span class="s3"># Check that this is fixed (even in the array case)</span>
        <span class="s1">skews = [-</span><span class="s4">3</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">]</span>
        <span class="s1">x_eval = </span><span class="s4">0.5</span>
        <span class="s1">res = stats.pearson3.ppf(stats.pearson3.cdf(x_eval</span><span class="s2">, </span><span class="s1">skews)</span><span class="s2">, </span><span class="s1">skews)</span>
        <span class="s1">assert_allclose(res</span><span class="s2">, </span><span class="s1">x_eval)</span>

        <span class="s3"># Negation of the skew flips the distribution about the origin, so</span>
        <span class="s3"># the following should hold</span>
        <span class="s1">skew = np.array([[-</span><span class="s4">0.5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1.5</span><span class="s1">]])</span>
        <span class="s1">x = np.linspace(-</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">assert_allclose(stats.pearson3.pdf(x</span><span class="s2">, </span><span class="s1">skew)</span><span class="s2">,</span>
                        <span class="s1">stats.pearson3.pdf(-x</span><span class="s2">, </span><span class="s1">-skew))</span>
        <span class="s1">assert_allclose(stats.pearson3.cdf(x</span><span class="s2">, </span><span class="s1">skew)</span><span class="s2">,</span>
                        <span class="s1">stats.pearson3.sf(-x</span><span class="s2">, </span><span class="s1">-skew))</span>
        <span class="s1">assert_allclose(stats.pearson3.ppf(x</span><span class="s2">, </span><span class="s1">skew)</span><span class="s2">,</span>
                        <span class="s1">-stats.pearson3.isf(x</span><span class="s2">, </span><span class="s1">-skew))</span>


<span class="s2">class </span><span class="s1">TestKappa4:</span>
    <span class="s2">def </span><span class="s1">test_cdf_genpareto(self):</span>
        <span class="s3"># h = 1 and k != 0 is generalized Pareto</span>
        <span class="s1">x = [</span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">]</span>
        <span class="s1">h = </span><span class="s4">1.0</span>
        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">[-</span><span class="s4">1.9</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.2</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">,</span>
                  <span class="s4">1.9</span><span class="s1">]:</span>
            <span class="s1">vals = stats.kappa4.cdf(x</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">k)</span>
            <span class="s3"># shape parameter is opposite what is expected</span>
            <span class="s1">vals_comp = stats.genpareto.cdf(x</span><span class="s2">, </span><span class="s1">-k)</span>
            <span class="s1">assert_allclose(vals</span><span class="s2">, </span><span class="s1">vals_comp)</span>

    <span class="s2">def </span><span class="s1">test_cdf_genextreme(self):</span>
        <span class="s3"># h = 0 and k != 0 is generalized extreme value</span>
        <span class="s1">x = np.linspace(-</span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">h = </span><span class="s4">0.0</span>
        <span class="s1">k = np.linspace(-</span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">vals = stats.kappa4.cdf(x</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">k)</span>
        <span class="s1">vals_comp = stats.genextreme.cdf(x</span><span class="s2">, </span><span class="s1">k)</span>
        <span class="s1">assert_allclose(vals</span><span class="s2">, </span><span class="s1">vals_comp)</span>

    <span class="s2">def </span><span class="s1">test_cdf_expon(self):</span>
        <span class="s3"># h = 1 and k = 0 is exponential</span>
        <span class="s1">x = np.linspace(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">h = </span><span class="s4">1.0</span>
        <span class="s1">k = </span><span class="s4">0.0</span>
        <span class="s1">vals = stats.kappa4.cdf(x</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">k)</span>
        <span class="s1">vals_comp = stats.expon.cdf(x)</span>
        <span class="s1">assert_allclose(vals</span><span class="s2">, </span><span class="s1">vals_comp)</span>

    <span class="s2">def </span><span class="s1">test_cdf_gumbel_r(self):</span>
        <span class="s3"># h = 0 and k = 0 is gumbel_r</span>
        <span class="s1">x = np.linspace(-</span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">h = </span><span class="s4">0.0</span>
        <span class="s1">k = </span><span class="s4">0.0</span>
        <span class="s1">vals = stats.kappa4.cdf(x</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">k)</span>
        <span class="s1">vals_comp = stats.gumbel_r.cdf(x)</span>
        <span class="s1">assert_allclose(vals</span><span class="s2">, </span><span class="s1">vals_comp)</span>

    <span class="s2">def </span><span class="s1">test_cdf_logistic(self):</span>
        <span class="s3"># h = -1 and k = 0 is logistic</span>
        <span class="s1">x = np.linspace(-</span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">h = -</span><span class="s4">1.0</span>
        <span class="s1">k = </span><span class="s4">0.0</span>
        <span class="s1">vals = stats.kappa4.cdf(x</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">k)</span>
        <span class="s1">vals_comp = stats.logistic.cdf(x)</span>
        <span class="s1">assert_allclose(vals</span><span class="s2">, </span><span class="s1">vals_comp)</span>

    <span class="s2">def </span><span class="s1">test_cdf_uniform(self):</span>
        <span class="s3"># h = 1 and k = 1 is uniform</span>
        <span class="s1">x = np.linspace(-</span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">h = </span><span class="s4">1.0</span>
        <span class="s1">k = </span><span class="s4">1.0</span>
        <span class="s1">vals = stats.kappa4.cdf(x</span><span class="s2">, </span><span class="s1">h</span><span class="s2">, </span><span class="s1">k)</span>
        <span class="s1">vals_comp = stats.uniform.cdf(x)</span>
        <span class="s1">assert_allclose(vals</span><span class="s2">, </span><span class="s1">vals_comp)</span>

    <span class="s2">def </span><span class="s1">test_integers_ctor(self):</span>
        <span class="s3"># regression test for gh-7416: _argcheck fails for integer h and k</span>
        <span class="s3"># in numpy 1.12</span>
        <span class="s1">stats.kappa4(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestPoisson:</span>
    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">np.random.seed(</span><span class="s4">1234</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_pmf_basic(self):</span>
        <span class="s3"># Basic case</span>
        <span class="s1">ln2 = np.log(</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">vals = stats.poisson.pmf([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">ln2)</span>
        <span class="s1">expected = [</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">ln2/</span><span class="s4">2</span><span class="s2">, </span><span class="s1">ln2**</span><span class="s4">2</span><span class="s1">/</span><span class="s4">4</span><span class="s1">]</span>
        <span class="s1">assert_allclose(vals</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_mu0(self):</span>
        <span class="s3"># Edge case: mu=0</span>
        <span class="s1">vals = stats.poisson.pmf([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">expected = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">assert_array_equal(vals</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">interval = stats.poisson.interval(</span><span class="s4">0.95</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_equal(interval</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_rvs(self):</span>
        <span class="s1">vals = stats.poisson.rvs(</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">size=(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">50</span><span class="s1">))</span>
        <span class="s1">assert_(numpy.all(vals &gt;= </span><span class="s4">0</span><span class="s1">))</span>
        <span class="s1">assert_(numpy.shape(vals) == (</span><span class="s4">2</span><span class="s2">, </span><span class="s4">50</span><span class="s1">))</span>
        <span class="s1">assert_(vals.dtype.char </span><span class="s2">in </span><span class="s1">typecodes[</span><span class="s5">'AllInteger'</span><span class="s1">])</span>
        <span class="s1">val = stats.poisson.rvs(</span><span class="s4">0.5</span><span class="s1">)</span>
        <span class="s1">assert_(isinstance(val</span><span class="s2">, </span><span class="s1">int))</span>
        <span class="s1">val = stats.poisson(</span><span class="s4">0.5</span><span class="s1">).rvs(</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">assert_(isinstance(val</span><span class="s2">, </span><span class="s1">numpy.ndarray))</span>
        <span class="s1">assert_(val.dtype.char </span><span class="s2">in </span><span class="s1">typecodes[</span><span class="s5">'AllInteger'</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_stats(self):</span>
        <span class="s1">mu = </span><span class="s4">16.0</span>
        <span class="s1">result = stats.poisson.stats(mu</span><span class="s2">, </span><span class="s1">moments=</span><span class="s5">'mvsk'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(result</span><span class="s2">, </span><span class="s1">[mu</span><span class="s2">, </span><span class="s1">mu</span><span class="s2">, </span><span class="s1">np.sqrt(</span><span class="s4">1.0</span><span class="s1">/mu)</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">/mu])</span>

        <span class="s1">mu = np.array([</span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">2.0</span><span class="s1">])</span>
        <span class="s1">result = stats.poisson.stats(mu</span><span class="s2">, </span><span class="s1">moments=</span><span class="s5">'mvsk'</span><span class="s1">)</span>
        <span class="s1">expected = (mu</span><span class="s2">, </span><span class="s1">mu</span><span class="s2">, </span><span class="s1">[np.inf</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">/np.sqrt(</span><span class="s4">2</span><span class="s1">)]</span><span class="s2">, </span><span class="s1">[np.inf</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">])</span>
        <span class="s1">assert_allclose(result</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">class </span><span class="s1">TestKSTwo:</span>
    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">np.random.seed(</span><span class="s4">1234</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_cdf(self):</span>
        <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">100</span><span class="s2">, </span><span class="s4">1000</span><span class="s1">]:</span>
            <span class="s3"># Test x-values:</span>
            <span class="s3">#  0, 1/2n, where the cdf should be 0</span>
            <span class="s3">#  1/n, where the cdf should be n!/n^n</span>
            <span class="s3">#  0.5, where the cdf should match ksone.cdf</span>
            <span class="s3"># 1-1/n, where cdf = 1-2/n^n</span>
            <span class="s3"># 1, where cdf == 1</span>
            <span class="s3"># (E.g. Exact values given by Eqn 1 in Simard / L'Ecuyer)</span>
            <span class="s1">x = np.array([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">/n</span><span class="s2">, </span><span class="s4">1</span><span class="s1">/n</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1</span><span class="s1">-</span><span class="s4">1.0</span><span class="s1">/n</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>
            <span class="s1">v1 = (</span><span class="s4">1.0</span><span class="s1">/n)**n</span>
            <span class="s1">lg = scipy.special.gammaln(n+</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">elg = (np.exp(lg) </span><span class="s2">if </span><span class="s1">v1 != </span><span class="s4">0 </span><span class="s2">else </span><span class="s4">0</span><span class="s1">)</span>
            <span class="s1">expected = np.array([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">v1 * elg</span><span class="s2">,</span>
                                 <span class="s4">1 </span><span class="s1">- </span><span class="s4">2</span><span class="s1">*stats.ksone.sf(</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">n)</span><span class="s2">,</span>
                                 <span class="s1">max(</span><span class="s4">1 </span><span class="s1">- </span><span class="s4">2</span><span class="s1">*v1</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">)</span><span class="s2">,</span>
                                 <span class="s4">1.0</span><span class="s1">])</span>
            <span class="s1">vals_cdf = stats.kstwo.cdf(x</span><span class="s2">, </span><span class="s1">n)</span>
            <span class="s1">assert_allclose(vals_cdf</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_sf(self):</span>
        <span class="s1">x = np.linspace(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">11</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">100</span><span class="s2">, </span><span class="s4">1000</span><span class="s1">]:</span>
            <span class="s3"># Same x values as in test_cdf, and use sf = 1 - cdf</span>
            <span class="s1">x = np.array([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">/n</span><span class="s2">, </span><span class="s4">1</span><span class="s1">/n</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1</span><span class="s1">-</span><span class="s4">1.0</span><span class="s1">/n</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>
            <span class="s1">v1 = (</span><span class="s4">1.0</span><span class="s1">/n)**n</span>
            <span class="s1">lg = scipy.special.gammaln(n+</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">elg = (np.exp(lg) </span><span class="s2">if </span><span class="s1">v1 != </span><span class="s4">0 </span><span class="s2">else </span><span class="s4">0</span><span class="s1">)</span>
            <span class="s1">expected = np.array([</span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">,</span>
                                 <span class="s4">1 </span><span class="s1">- v1 * elg</span><span class="s2">,</span>
                                 <span class="s4">2</span><span class="s1">*stats.ksone.sf(</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">n)</span><span class="s2">,</span>
                                 <span class="s1">min(</span><span class="s4">2</span><span class="s1">*v1</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0</span><span class="s1">])</span>
            <span class="s1">vals_sf = stats.kstwo.sf(x</span><span class="s2">, </span><span class="s1">n)</span>
            <span class="s1">assert_allclose(vals_sf</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_cdf_sqrtn(self):</span>
        <span class="s3"># For fixed a, cdf(a/sqrt(n), n) -&gt; kstwobign(a) as n-&gt;infinity</span>
        <span class="s3"># cdf(a/sqrt(n), n) is an increasing function of n (and a)</span>
        <span class="s3"># Check that the function is indeed increasing (allowing for some</span>
        <span class="s3"># small floating point and algorithm differences.)</span>
        <span class="s1">x = np.linspace(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">11</span><span class="s1">)[</span><span class="s4">1</span><span class="s1">:]</span>
        <span class="s1">ns = [</span><span class="s4">50</span><span class="s2">, </span><span class="s4">100</span><span class="s2">, </span><span class="s4">200</span><span class="s2">, </span><span class="s4">400</span><span class="s2">, </span><span class="s4">1000</span><span class="s2">, </span><span class="s4">2000</span><span class="s1">]</span>
        <span class="s2">for </span><span class="s1">_x </span><span class="s2">in </span><span class="s1">x:</span>
            <span class="s1">xn = _x / np.sqrt(ns)</span>
            <span class="s1">probs = stats.kstwo.cdf(xn</span><span class="s2">, </span><span class="s1">ns)</span>
            <span class="s1">diffs = np.diff(probs)</span>
            <span class="s1">assert_array_less(diffs</span><span class="s2">, </span><span class="s4">1e-8</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_cdf_sf(self):</span>
        <span class="s1">x = np.linspace(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">11</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">100</span><span class="s2">, </span><span class="s4">1000</span><span class="s1">]:</span>
            <span class="s1">vals_cdf = stats.kstwo.cdf(x</span><span class="s2">, </span><span class="s1">n)</span>
            <span class="s1">vals_sf = stats.kstwo.sf(x</span><span class="s2">, </span><span class="s1">n)</span>
            <span class="s1">assert_array_almost_equal(vals_cdf</span><span class="s2">, </span><span class="s4">1 </span><span class="s1">- vals_sf)</span>

    <span class="s2">def </span><span class="s1">test_cdf_sf_sqrtn(self):</span>
        <span class="s1">x = np.linspace(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">11</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">100</span><span class="s2">, </span><span class="s4">1000</span><span class="s1">]:</span>
            <span class="s1">xn = x / np.sqrt(n)</span>
            <span class="s1">vals_cdf = stats.kstwo.cdf(xn</span><span class="s2">, </span><span class="s1">n)</span>
            <span class="s1">vals_sf = stats.kstwo.sf(xn</span><span class="s2">, </span><span class="s1">n)</span>
            <span class="s1">assert_array_almost_equal(vals_cdf</span><span class="s2">, </span><span class="s4">1 </span><span class="s1">- vals_sf)</span>

    <span class="s2">def </span><span class="s1">test_ppf_of_cdf(self):</span>
        <span class="s1">x = np.linspace(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">11</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">100</span><span class="s2">, </span><span class="s4">1000</span><span class="s1">]:</span>
            <span class="s1">xn = x[x &gt; </span><span class="s4">0.5</span><span class="s1">/n]</span>
            <span class="s1">vals_cdf = stats.kstwo.cdf(xn</span><span class="s2">, </span><span class="s1">n)</span>
            <span class="s3"># CDFs close to 1 are better dealt with using the SF</span>
            <span class="s1">cond = (</span><span class="s4">0 </span><span class="s1">&lt; vals_cdf) &amp; (vals_cdf &lt; </span><span class="s4">0.99</span><span class="s1">)</span>
            <span class="s1">vals = stats.kstwo.ppf(vals_cdf</span><span class="s2">, </span><span class="s1">n)</span>
            <span class="s1">assert_allclose(vals[cond]</span><span class="s2">, </span><span class="s1">xn[cond]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-4</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_isf_of_sf(self):</span>
        <span class="s1">x = np.linspace(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">11</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">100</span><span class="s2">, </span><span class="s4">1000</span><span class="s1">]:</span>
            <span class="s1">xn = x[x &gt; </span><span class="s4">0.5</span><span class="s1">/n]</span>
            <span class="s1">vals_isf = stats.kstwo.isf(xn</span><span class="s2">, </span><span class="s1">n)</span>
            <span class="s1">cond = (</span><span class="s4">0 </span><span class="s1">&lt; vals_isf) &amp; (vals_isf &lt; </span><span class="s4">1.0</span><span class="s1">)</span>
            <span class="s1">vals = stats.kstwo.sf(vals_isf</span><span class="s2">, </span><span class="s1">n)</span>
            <span class="s1">assert_allclose(vals[cond]</span><span class="s2">, </span><span class="s1">xn[cond]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-4</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_ppf_of_cdf_sqrtn(self):</span>
        <span class="s1">x = np.linspace(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">11</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">100</span><span class="s2">, </span><span class="s4">1000</span><span class="s1">]:</span>
            <span class="s1">xn = (x / np.sqrt(n))[x &gt; </span><span class="s4">0.5</span><span class="s1">/n]</span>
            <span class="s1">vals_cdf = stats.kstwo.cdf(xn</span><span class="s2">, </span><span class="s1">n)</span>
            <span class="s1">cond = (</span><span class="s4">0 </span><span class="s1">&lt; vals_cdf) &amp; (vals_cdf &lt; </span><span class="s4">1.0</span><span class="s1">)</span>
            <span class="s1">vals = stats.kstwo.ppf(vals_cdf</span><span class="s2">, </span><span class="s1">n)</span>
            <span class="s1">assert_allclose(vals[cond]</span><span class="s2">, </span><span class="s1">xn[cond])</span>

    <span class="s2">def </span><span class="s1">test_isf_of_sf_sqrtn(self):</span>
        <span class="s1">x = np.linspace(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">11</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">100</span><span class="s2">, </span><span class="s4">1000</span><span class="s1">]:</span>
            <span class="s1">xn = (x / np.sqrt(n))[x &gt; </span><span class="s4">0.5</span><span class="s1">/n]</span>
            <span class="s1">vals_sf = stats.kstwo.sf(xn</span><span class="s2">, </span><span class="s1">n)</span>
            <span class="s3"># SFs close to 1 are better dealt with using the CDF</span>
            <span class="s1">cond = (</span><span class="s4">0 </span><span class="s1">&lt; vals_sf) &amp; (vals_sf &lt; </span><span class="s4">0.95</span><span class="s1">)</span>
            <span class="s1">vals = stats.kstwo.isf(vals_sf</span><span class="s2">, </span><span class="s1">n)</span>
            <span class="s1">assert_allclose(vals[cond]</span><span class="s2">, </span><span class="s1">xn[cond])</span>

    <span class="s2">def </span><span class="s1">test_ppf(self):</span>
        <span class="s1">probs = np.linspace(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">11</span><span class="s1">)[</span><span class="s4">1</span><span class="s1">:]</span>
        <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">100</span><span class="s2">, </span><span class="s4">1000</span><span class="s1">]:</span>
            <span class="s1">xn = stats.kstwo.ppf(probs</span><span class="s2">, </span><span class="s1">n)</span>
            <span class="s1">vals_cdf = stats.kstwo.cdf(xn</span><span class="s2">, </span><span class="s1">n)</span>
            <span class="s1">assert_allclose(vals_cdf</span><span class="s2">, </span><span class="s1">probs)</span>

    <span class="s2">def </span><span class="s1">test_simard_lecuyer_table1(self):</span>
        <span class="s3"># Compute the cdf for values near the mean of the distribution.</span>
        <span class="s3"># The mean u ~ log(2)*sqrt(pi/(2n))</span>
        <span class="s3"># Compute for x in [u/4, u/3, u/2, u, 2u, 3u]</span>
        <span class="s3"># This is the computation of Table 1 of Simard, R., L'Ecuyer, P. (2011)</span>
        <span class="s3">#  &quot;Computing the Two-Sided Kolmogorov-Smirnov Distribution&quot;.</span>
        <span class="s3"># Except that the values below are not from the published table, but</span>
        <span class="s3"># were generated using an independent SageMath implementation of</span>
        <span class="s3"># Durbin's algorithm (with the exponentiation and scaling of</span>
        <span class="s3"># Marsaglia/Tsang/Wang's version) using 500 bit arithmetic.</span>
        <span class="s3"># Some of the values in the published table have relative</span>
        <span class="s3"># errors greater than 1e-4.</span>
        <span class="s1">ns = [</span><span class="s4">10</span><span class="s2">, </span><span class="s4">50</span><span class="s2">, </span><span class="s4">100</span><span class="s2">, </span><span class="s4">200</span><span class="s2">, </span><span class="s4">500</span><span class="s2">, </span><span class="s4">1000</span><span class="s1">]</span>
        <span class="s1">ratios = np.array([</span><span class="s4">1.0</span><span class="s1">/</span><span class="s4">4</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">/</span><span class="s4">3</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">/</span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">])</span>
        <span class="s1">expected = np.array([</span>
            <span class="s1">[</span><span class="s4">1.92155292e-08</span><span class="s2">, </span><span class="s4">5.72933228e-05</span><span class="s2">, </span><span class="s4">2.15233226e-02</span><span class="s2">, </span><span class="s4">6.31566589e-01</span><span class="s2">,</span>
             <span class="s4">9.97685592e-01</span><span class="s2">, </span><span class="s4">9.99999942e-01</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s4">2.28096224e-09</span><span class="s2">, </span><span class="s4">1.99142563e-05</span><span class="s2">, </span><span class="s4">1.42617934e-02</span><span class="s2">, </span><span class="s4">5.95345542e-01</span><span class="s2">,</span>
             <span class="s4">9.96177701e-01</span><span class="s2">, </span><span class="s4">9.99998662e-01</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s4">1.00201886e-09</span><span class="s2">, </span><span class="s4">1.32673079e-05</span><span class="s2">, </span><span class="s4">1.24608594e-02</span><span class="s2">, </span><span class="s4">5.86163220e-01</span><span class="s2">,</span>
             <span class="s4">9.95866877e-01</span><span class="s2">, </span><span class="s4">9.99998240e-01</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s4">4.93313022e-10</span><span class="s2">, </span><span class="s4">9.52658029e-06</span><span class="s2">, </span><span class="s4">1.12123138e-02</span><span class="s2">, </span><span class="s4">5.79486872e-01</span><span class="s2">,</span>
             <span class="s4">9.95661824e-01</span><span class="s2">, </span><span class="s4">9.99997964e-01</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s4">2.37049293e-10</span><span class="s2">, </span><span class="s4">6.85002458e-06</span><span class="s2">, </span><span class="s4">1.01309221e-02</span><span class="s2">, </span><span class="s4">5.73427224e-01</span><span class="s2">,</span>
             <span class="s4">9.95491207e-01</span><span class="s2">, </span><span class="s4">9.99997750e-01</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s4">1.56990874e-10</span><span class="s2">, </span><span class="s4">5.71738276e-06</span><span class="s2">, </span><span class="s4">9.59725430e-03</span><span class="s2">, </span><span class="s4">5.70322692e-01</span><span class="s2">,</span>
             <span class="s4">9.95409545e-01</span><span class="s2">, </span><span class="s4">9.99997657e-01</span><span class="s1">]</span>
        <span class="s1">])</span>
        <span class="s2">for </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">n </span><span class="s2">in </span><span class="s1">enumerate(ns):</span>
            <span class="s1">x = ratios * np.log(</span><span class="s4">2</span><span class="s1">) * np.sqrt(np.pi/</span><span class="s4">2</span><span class="s1">/n)</span>
            <span class="s1">vals_cdf = stats.kstwo.cdf(x</span><span class="s2">, </span><span class="s1">n)</span>
            <span class="s1">assert_allclose(vals_cdf</span><span class="s2">, </span><span class="s1">expected[idx]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-5</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestZipf:</span>
    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">np.random.seed(</span><span class="s4">1234</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_rvs(self):</span>
        <span class="s1">vals = stats.zipf.rvs(</span><span class="s4">1.5</span><span class="s2">, </span><span class="s1">size=(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">50</span><span class="s1">))</span>
        <span class="s1">assert_(numpy.all(vals &gt;= </span><span class="s4">1</span><span class="s1">))</span>
        <span class="s1">assert_(numpy.shape(vals) == (</span><span class="s4">2</span><span class="s2">, </span><span class="s4">50</span><span class="s1">))</span>
        <span class="s1">assert_(vals.dtype.char </span><span class="s2">in </span><span class="s1">typecodes[</span><span class="s5">'AllInteger'</span><span class="s1">])</span>
        <span class="s1">val = stats.zipf.rvs(</span><span class="s4">1.5</span><span class="s1">)</span>
        <span class="s1">assert_(isinstance(val</span><span class="s2">, </span><span class="s1">int))</span>
        <span class="s1">val = stats.zipf(</span><span class="s4">1.5</span><span class="s1">).rvs(</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">assert_(isinstance(val</span><span class="s2">, </span><span class="s1">numpy.ndarray))</span>
        <span class="s1">assert_(val.dtype.char </span><span class="s2">in </span><span class="s1">typecodes[</span><span class="s5">'AllInteger'</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_moments(self):</span>
        <span class="s3"># n-th moment is finite iff a &gt; n + 1</span>
        <span class="s1">m</span><span class="s2">, </span><span class="s1">v = stats.zipf.stats(a=</span><span class="s4">2.8</span><span class="s1">)</span>
        <span class="s1">assert_(np.isfinite(m))</span>
        <span class="s1">assert_equal(v</span><span class="s2">, </span><span class="s1">np.inf)</span>

        <span class="s1">s</span><span class="s2">, </span><span class="s1">k = stats.zipf.stats(a=</span><span class="s4">4.8</span><span class="s2">, </span><span class="s1">moments=</span><span class="s5">'sk'</span><span class="s1">)</span>
        <span class="s1">assert_(</span><span class="s2">not </span><span class="s1">np.isfinite([s</span><span class="s2">, </span><span class="s1">k]).all())</span>


<span class="s2">class </span><span class="s1">TestDLaplace:</span>
    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">np.random.seed(</span><span class="s4">1234</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_rvs(self):</span>
        <span class="s1">vals = stats.dlaplace.rvs(</span><span class="s4">1.5</span><span class="s2">, </span><span class="s1">size=(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">50</span><span class="s1">))</span>
        <span class="s1">assert_(numpy.shape(vals) == (</span><span class="s4">2</span><span class="s2">, </span><span class="s4">50</span><span class="s1">))</span>
        <span class="s1">assert_(vals.dtype.char </span><span class="s2">in </span><span class="s1">typecodes[</span><span class="s5">'AllInteger'</span><span class="s1">])</span>
        <span class="s1">val = stats.dlaplace.rvs(</span><span class="s4">1.5</span><span class="s1">)</span>
        <span class="s1">assert_(isinstance(val</span><span class="s2">, </span><span class="s1">int))</span>
        <span class="s1">val = stats.dlaplace(</span><span class="s4">1.5</span><span class="s1">).rvs(</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">assert_(isinstance(val</span><span class="s2">, </span><span class="s1">numpy.ndarray))</span>
        <span class="s1">assert_(val.dtype.char </span><span class="s2">in </span><span class="s1">typecodes[</span><span class="s5">'AllInteger'</span><span class="s1">])</span>
        <span class="s1">assert_(stats.dlaplace.rvs(</span><span class="s4">0.8</span><span class="s1">) </span><span class="s2">is not None</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_stats(self):</span>
        <span class="s3"># compare the explicit formulas w/ direct summation using pmf</span>
        <span class="s1">a = </span><span class="s4">1.</span>
        <span class="s1">dl = stats.dlaplace(a)</span>
        <span class="s1">m</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">k = dl.stats(</span><span class="s5">'mvsk'</span><span class="s1">)</span>

        <span class="s1">N = </span><span class="s4">37</span>
        <span class="s1">xx = np.arange(-N</span><span class="s2">, </span><span class="s1">N+</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">pp = dl.pmf(xx)</span>
        <span class="s1">m2</span><span class="s2">, </span><span class="s1">m4 = np.sum(pp*xx**</span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.sum(pp*xx**</span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">assert_equal((m</span><span class="s2">, </span><span class="s1">s)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">))</span>
        <span class="s1">assert_allclose((v</span><span class="s2">, </span><span class="s1">k)</span><span class="s2">, </span><span class="s1">(m2</span><span class="s2">, </span><span class="s1">m4/m2**</span><span class="s4">2 </span><span class="s1">- </span><span class="s4">3.</span><span class="s1">)</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-14</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-8</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_stats2(self):</span>
        <span class="s1">a = np.log(</span><span class="s4">2.</span><span class="s1">)</span>
        <span class="s1">dl = stats.dlaplace(a)</span>
        <span class="s1">m</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">k = dl.stats(</span><span class="s5">'mvsk'</span><span class="s1">)</span>
        <span class="s1">assert_equal((m</span><span class="s2">, </span><span class="s1">s)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.</span><span class="s2">, </span><span class="s4">0.</span><span class="s1">))</span>
        <span class="s1">assert_allclose((v</span><span class="s2">, </span><span class="s1">k)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">4.</span><span class="s2">, </span><span class="s4">3.25</span><span class="s1">))</span>


<span class="s2">class </span><span class="s1">TestInvgauss:</span>
    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">np.random.seed(</span><span class="s4">1234</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;rvs_mu,rvs_loc,rvs_scale&quot;</span><span class="s2">,</span>
                             <span class="s1">[(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">4.635</span><span class="s2">, </span><span class="s4">4.362</span><span class="s2">, </span><span class="s4">6.303</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_fit(self</span><span class="s2">, </span><span class="s1">rvs_mu</span><span class="s2">, </span><span class="s1">rvs_loc</span><span class="s2">, </span><span class="s1">rvs_scale):</span>
        <span class="s1">data = stats.invgauss.rvs(size=</span><span class="s4">100</span><span class="s2">, </span><span class="s1">mu=rvs_mu</span><span class="s2">,</span>
                                  <span class="s1">loc=rvs_loc</span><span class="s2">, </span><span class="s1">scale=rvs_scale)</span>
        <span class="s3"># Analytical MLEs are calculated with formula when `floc` is fixed</span>
        <span class="s1">mu</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = stats.invgauss.fit(data</span><span class="s2">, </span><span class="s1">floc=rvs_loc)</span>

        <span class="s1">data = data - rvs_loc</span>
        <span class="s1">mu_temp = np.mean(data)</span>
        <span class="s1">scale_mle = len(data) / (np.sum(data**(-</span><span class="s4">1</span><span class="s1">) - mu_temp**(-</span><span class="s4">1</span><span class="s1">)))</span>
        <span class="s1">mu_mle = mu_temp/scale_mle</span>

        <span class="s3"># `mu` and `scale` match analytical formula</span>
        <span class="s1">assert_allclose(mu_mle</span><span class="s2">, </span><span class="s1">mu</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-15</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-15</span><span class="s1">)</span>
        <span class="s1">assert_allclose(scale_mle</span><span class="s2">, </span><span class="s1">scale</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-15</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-15</span><span class="s1">)</span>
        <span class="s1">assert_equal(loc</span><span class="s2">, </span><span class="s1">rvs_loc)</span>
        <span class="s1">data = stats.invgauss.rvs(size=</span><span class="s4">100</span><span class="s2">, </span><span class="s1">mu=rvs_mu</span><span class="s2">,</span>
                                  <span class="s1">loc=rvs_loc</span><span class="s2">, </span><span class="s1">scale=rvs_scale)</span>
        <span class="s3"># fixed parameters are returned</span>
        <span class="s1">mu</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = stats.invgauss.fit(data</span><span class="s2">, </span><span class="s1">floc=rvs_loc - </span><span class="s4">1</span><span class="s2">,</span>
                                            <span class="s1">fscale=rvs_scale + </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(rvs_scale + </span><span class="s4">1</span><span class="s2">, </span><span class="s1">scale)</span>
        <span class="s1">assert_equal(rvs_loc - </span><span class="s4">1</span><span class="s2">, </span><span class="s1">loc)</span>

        <span class="s3"># shape can still be fixed with multiple names</span>
        <span class="s1">shape_mle1 = stats.invgauss.fit(data</span><span class="s2">, </span><span class="s1">fmu=</span><span class="s4">1.04</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">shape_mle2 = stats.invgauss.fit(data</span><span class="s2">, </span><span class="s1">fix_mu=</span><span class="s4">1.04</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">shape_mle3 = stats.invgauss.fit(data</span><span class="s2">, </span><span class="s1">f0=</span><span class="s4">1.04</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s2">assert </span><span class="s1">shape_mle1 == shape_mle2 == shape_mle3 == </span><span class="s4">1.04</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;rvs_mu,rvs_loc,rvs_scale&quot;</span><span class="s2">,</span>
                             <span class="s1">[(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">6.311</span><span class="s2">, </span><span class="s4">3.225</span><span class="s2">, </span><span class="s4">4.520</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_fit_MLE_comp_optimizer(self</span><span class="s2">, </span><span class="s1">rvs_mu</span><span class="s2">, </span><span class="s1">rvs_loc</span><span class="s2">, </span><span class="s1">rvs_scale):</span>
        <span class="s1">data = stats.invgauss.rvs(size=</span><span class="s4">100</span><span class="s2">, </span><span class="s1">mu=rvs_mu</span><span class="s2">,</span>
                                  <span class="s1">loc=rvs_loc</span><span class="s2">, </span><span class="s1">scale=rvs_scale)</span>

        <span class="s1">super_fit = super(type(stats.invgauss)</span><span class="s2">, </span><span class="s1">stats.invgauss).fit</span>
        <span class="s3"># fitting without `floc` uses superclass fit method</span>
        <span class="s1">super_fitted = super_fit(data)</span>
        <span class="s1">invgauss_fit = stats.invgauss.fit(data)</span>
        <span class="s1">assert_equal(super_fitted</span><span class="s2">, </span><span class="s1">invgauss_fit)</span>

        <span class="s3"># fitting with `fmu` is uses superclass fit method</span>
        <span class="s1">super_fitted = super_fit(data</span><span class="s2">, </span><span class="s1">floc=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">fmu=</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">invgauss_fit = stats.invgauss.fit(data</span><span class="s2">, </span><span class="s1">floc=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">fmu=</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">assert_equal(super_fitted</span><span class="s2">, </span><span class="s1">invgauss_fit)</span>

        <span class="s3"># fixed `floc` uses analytical formula and provides better fit than</span>
        <span class="s3"># super method</span>
        <span class="s1">_assert_less_or_close_loglike(stats.invgauss</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">floc=rvs_loc)</span>

        <span class="s3"># fixed `floc` not resulting in invalid data &lt; 0 uses analytical</span>
        <span class="s3"># formulas and provides a better fit than the super method</span>
        <span class="s2">assert </span><span class="s1">np.all((data - (rvs_loc - </span><span class="s4">1</span><span class="s1">)) &gt; </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">_assert_less_or_close_loglike(stats.invgauss</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">floc=rvs_loc - </span><span class="s4">1</span><span class="s1">)</span>

        <span class="s3"># fixed `floc` to an arbitrary number, 0, still provides a better fit</span>
        <span class="s3"># than the super method</span>
        <span class="s1">_assert_less_or_close_loglike(stats.invgauss</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">floc=</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s3"># fixed `fscale` to an arbitrary number still provides a better fit</span>
        <span class="s3"># than the super method</span>
        <span class="s1">_assert_less_or_close_loglike(stats.invgauss</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">floc=rvs_loc</span><span class="s2">,</span>
                                      <span class="s1">fscale=np.random.rand(</span><span class="s4">1</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_fit_raise_errors(self):</span>
        <span class="s1">assert_fit_warnings(stats.invgauss)</span>
        <span class="s3"># FitDataError is raised when negative invalid data</span>
        <span class="s2">with </span><span class="s1">pytest.raises(FitDataError):</span>
            <span class="s1">stats.invgauss.fit([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">floc=</span><span class="s4">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_cdf_sf(self):</span>
        <span class="s3"># Regression tests for gh-13614.</span>
        <span class="s3"># Ground truth from R's statmod library (pinvgauss), e.g.</span>
        <span class="s3"># library(statmod)</span>
        <span class="s3"># options(digits=15)</span>
        <span class="s3"># mu = c(4.17022005e-04, 7.20324493e-03, 1.14374817e-06,</span>
        <span class="s3">#        3.02332573e-03, 1.46755891e-03)</span>
        <span class="s3"># print(pinvgauss(5, mu, 1))</span>

        <span class="s3"># make sure a finite value is returned when mu is very small. see</span>
        <span class="s3"># GH-13614</span>
        <span class="s1">mu = [</span><span class="s4">4.17022005e-04</span><span class="s2">, </span><span class="s4">7.20324493e-03</span><span class="s2">, </span><span class="s4">1.14374817e-06</span><span class="s2">,</span>
              <span class="s4">3.02332573e-03</span><span class="s2">, </span><span class="s4">1.46755891e-03</span><span class="s1">]</span>
        <span class="s1">expected = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">actual = stats.invgauss.cdf(</span><span class="s4">0.4</span><span class="s2">, </span><span class="s1">mu=mu)</span>
        <span class="s1">assert_equal(expected</span><span class="s2">, </span><span class="s1">actual)</span>

        <span class="s3"># test if the function can distinguish small left/right tail</span>
        <span class="s3"># probabilities from zero.</span>
        <span class="s1">cdf_actual = stats.invgauss.cdf(</span><span class="s4">0.001</span><span class="s2">, </span><span class="s1">mu=</span><span class="s4">1.05</span><span class="s1">)</span>
        <span class="s1">assert_allclose(cdf_actual</span><span class="s2">, </span><span class="s4">4.65246506892667e-219</span><span class="s1">)</span>
        <span class="s1">sf_actual = stats.invgauss.sf(</span><span class="s4">110</span><span class="s2">, </span><span class="s1">mu=</span><span class="s4">1.05</span><span class="s1">)</span>
        <span class="s1">assert_allclose(sf_actual</span><span class="s2">, </span><span class="s4">4.12851625944048e-25</span><span class="s1">)</span>

        <span class="s3"># test if x does not cause numerical issues when mu is very small</span>
        <span class="s3"># and x is close to mu in value.</span>

        <span class="s3"># slightly smaller than mu</span>
        <span class="s1">actual = stats.invgauss.cdf(</span><span class="s4">0.00009</span><span class="s2">, </span><span class="s4">0.0001</span><span class="s1">)</span>
        <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s4">2.9458022894924e-26</span><span class="s1">)</span>

        <span class="s3"># slightly bigger than mu</span>
        <span class="s1">actual = stats.invgauss.cdf(</span><span class="s4">0.000102</span><span class="s2">, </span><span class="s4">0.0001</span><span class="s1">)</span>
        <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s4">0.976445540507925</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_logcdf_logsf(self):</span>
        <span class="s3"># Regression tests for improvements made in gh-13616.</span>
        <span class="s3"># Ground truth from R's statmod library (pinvgauss), e.g.</span>
        <span class="s3"># library(statmod)</span>
        <span class="s3"># options(digits=15)</span>
        <span class="s3"># print(pinvgauss(0.001, 1.05, 1, log.p=TRUE, lower.tail=FALSE))</span>

        <span class="s3"># test if logcdf and logsf can compute values too small to</span>
        <span class="s3"># be represented on the unlogged scale. See: gh-13616</span>
        <span class="s1">logcdf = stats.invgauss.logcdf(</span><span class="s4">0.0001</span><span class="s2">, </span><span class="s1">mu=</span><span class="s4">1.05</span><span class="s1">)</span>
        <span class="s1">assert_allclose(logcdf</span><span class="s2">, </span><span class="s1">-</span><span class="s4">5003.87872590367</span><span class="s1">)</span>
        <span class="s1">logcdf = stats.invgauss.logcdf(</span><span class="s4">110</span><span class="s2">, </span><span class="s4">1.05</span><span class="s1">)</span>
        <span class="s1">assert_allclose(logcdf</span><span class="s2">, </span><span class="s1">-</span><span class="s4">4.12851625944087e-25</span><span class="s1">)</span>
        <span class="s1">logsf = stats.invgauss.logsf(</span><span class="s4">0.001</span><span class="s2">, </span><span class="s1">mu=</span><span class="s4">1.05</span><span class="s1">)</span>
        <span class="s1">assert_allclose(logsf</span><span class="s2">, </span><span class="s1">-</span><span class="s4">4.65246506892676e-219</span><span class="s1">)</span>
        <span class="s1">logsf = stats.invgauss.logsf(</span><span class="s4">110</span><span class="s2">, </span><span class="s4">1.05</span><span class="s1">)</span>
        <span class="s1">assert_allclose(logsf</span><span class="s2">, </span><span class="s1">-</span><span class="s4">56.1467092416426</span><span class="s1">)</span>

    <span class="s3"># from mpmath import mp</span>
    <span class="s3"># mp.dps = 100</span>
    <span class="s3"># mu = mp.mpf(1e-2)</span>
    <span class="s3"># ref = (1/2 * mp.log(2 * mp.pi * mp.e * mu**3)</span>
    <span class="s3">#        - 3/2* mp.exp(2/mu) * mp.e1(2/mu))</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;mu, ref&quot;</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">2e-8</span><span class="s2">, </span><span class="s1">-</span><span class="s4">25.172361826883957</span><span class="s1">)</span><span class="s2">,</span>
                                         <span class="s1">(</span><span class="s4">1e-3</span><span class="s2">, </span><span class="s1">-</span><span class="s4">8.943444010642972</span><span class="s1">)</span><span class="s2">,</span>
                                         <span class="s1">(</span><span class="s4">1e-2</span><span class="s2">, </span><span class="s1">-</span><span class="s4">5.4962796152622335</span><span class="s1">)</span><span class="s2">,</span>
                                         <span class="s1">(</span><span class="s4">1e8</span><span class="s2">, </span><span class="s4">3.3244822568873476</span><span class="s1">)</span><span class="s2">,</span>
                                         <span class="s1">(</span><span class="s4">1e100</span><span class="s2">, </span><span class="s4">3.32448280139689</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_entropy(self</span><span class="s2">, </span><span class="s1">mu</span><span class="s2">, </span><span class="s1">ref):</span>
        <span class="s1">assert_allclose(stats.invgauss.entropy(mu)</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">5e-14</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestLaplace:</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;rvs_loc&quot;</span><span class="s2">, </span><span class="s1">[-</span><span class="s4">5</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;rvs_scale&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">10</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_fit(self</span><span class="s2">, </span><span class="s1">rvs_loc</span><span class="s2">, </span><span class="s1">rvs_scale):</span>
        <span class="s3"># tests that various inputs follow expected behavior</span>
        <span class="s3"># for a variety of `loc` and `scale`.</span>
        <span class="s1">data = stats.laplace.rvs(size=</span><span class="s4">100</span><span class="s2">, </span><span class="s1">loc=rvs_loc</span><span class="s2">, </span><span class="s1">scale=rvs_scale)</span>

        <span class="s3"># MLE estimates are given by</span>
        <span class="s1">loc_mle = np.median(data)</span>
        <span class="s1">scale_mle = np.sum(np.abs(data - loc_mle)) / len(data)</span>

        <span class="s3"># standard outputs should match analytical MLE formulas</span>
        <span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = stats.laplace.fit(data)</span>
        <span class="s1">assert_allclose(loc</span><span class="s2">, </span><span class="s1">loc_mle</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-15</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-15</span><span class="s1">)</span>
        <span class="s1">assert_allclose(scale</span><span class="s2">, </span><span class="s1">scale_mle</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-15</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-15</span><span class="s1">)</span>

        <span class="s3"># fixed parameter should use analytical formula for other</span>
        <span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = stats.laplace.fit(data</span><span class="s2">, </span><span class="s1">floc=loc_mle)</span>
        <span class="s1">assert_allclose(scale</span><span class="s2">, </span><span class="s1">scale_mle</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-15</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-15</span><span class="s1">)</span>
        <span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = stats.laplace.fit(data</span><span class="s2">, </span><span class="s1">fscale=scale_mle)</span>
        <span class="s1">assert_allclose(loc</span><span class="s2">, </span><span class="s1">loc_mle)</span>

        <span class="s3"># test with non-mle fixed parameter</span>
        <span class="s3"># create scale with non-median loc</span>
        <span class="s1">loc = rvs_loc * </span><span class="s4">2</span>
        <span class="s1">scale_mle = np.sum(np.abs(data - loc)) / len(data)</span>

        <span class="s3"># fixed loc to non median, scale should match</span>
        <span class="s3"># scale calculation with modified loc</span>
        <span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = stats.laplace.fit(data</span><span class="s2">, </span><span class="s1">floc=loc)</span>
        <span class="s1">assert_equal(scale_mle</span><span class="s2">, </span><span class="s1">scale)</span>

        <span class="s3"># fixed scale created with non median loc,</span>
        <span class="s3"># loc output should still be the data median.</span>
        <span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = stats.laplace.fit(data</span><span class="s2">, </span><span class="s1">fscale=scale_mle)</span>
        <span class="s1">assert_equal(loc_mle</span><span class="s2">, </span><span class="s1">loc)</span>

        <span class="s3"># error raised when both `floc` and `fscale` are fixed</span>
        <span class="s1">assert_raises(RuntimeError</span><span class="s2">, </span><span class="s1">stats.laplace.fit</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">floc=loc_mle</span><span class="s2">,</span>
                      <span class="s1">fscale=scale_mle)</span>

        <span class="s3"># error is raised with non-finite values</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.laplace.fit</span><span class="s2">, </span><span class="s1">[np.nan])</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.laplace.fit</span><span class="s2">, </span><span class="s1">[np.inf])</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;rvs_loc,rvs_scale&quot;</span><span class="s2">, </span><span class="s1">[(-</span><span class="s4">5</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span><span class="s2">,</span>
                                                   <span class="s1">(</span><span class="s4">10</span><span class="s2">, </span><span class="s4">5</span><span class="s1">)</span><span class="s2">,</span>
                                                   <span class="s1">(</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.2</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_fit_MLE_comp_optimizer(self</span><span class="s2">, </span><span class="s1">rvs_loc</span><span class="s2">, </span><span class="s1">rvs_scale):</span>
        <span class="s1">data = stats.laplace.rvs(size=</span><span class="s4">1000</span><span class="s2">, </span><span class="s1">loc=rvs_loc</span><span class="s2">, </span><span class="s1">scale=rvs_scale)</span>

        <span class="s3"># the log-likelihood function for laplace is given by</span>
        <span class="s2">def </span><span class="s1">ll(loc</span><span class="s2">, </span><span class="s1">scale</span><span class="s2">, </span><span class="s1">data):</span>
            <span class="s2">return </span><span class="s1">-</span><span class="s4">1 </span><span class="s1">* (- (len(data)) * np.log(</span><span class="s4">2</span><span class="s1">*scale) -</span>
                         <span class="s1">(</span><span class="s4">1</span><span class="s1">/scale)*np.sum(np.abs(data - loc)))</span>

        <span class="s3"># test that the objective function result of the analytical MLEs is</span>
        <span class="s3"># less than or equal to that of the numerically optimized estimate</span>
        <span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = stats.laplace.fit(data)</span>
        <span class="s1">loc_opt</span><span class="s2">, </span><span class="s1">scale_opt = super(type(stats.laplace)</span><span class="s2">,</span>
                                   <span class="s1">stats.laplace).fit(data)</span>
        <span class="s1">ll_mle = ll(loc</span><span class="s2">, </span><span class="s1">scale</span><span class="s2">, </span><span class="s1">data)</span>
        <span class="s1">ll_opt = ll(loc_opt</span><span class="s2">, </span><span class="s1">scale_opt</span><span class="s2">, </span><span class="s1">data)</span>
        <span class="s2">assert </span><span class="s1">ll_mle &lt; ll_opt </span><span class="s2">or </span><span class="s1">np.allclose(ll_mle</span><span class="s2">, </span><span class="s1">ll_opt</span><span class="s2">,</span>
                                              <span class="s1">atol=</span><span class="s4">1e-15</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-15</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_fit_simple_non_random_data(self):</span>
        <span class="s1">data = np.array([</span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">3.0</span><span class="s2">, </span><span class="s4">5.0</span><span class="s2">, </span><span class="s4">8.0</span><span class="s2">, </span><span class="s4">14.0</span><span class="s1">])</span>
        <span class="s3"># with `floc` fixed to 6, scale should be 4.</span>
        <span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = stats.laplace.fit(data</span><span class="s2">, </span><span class="s1">floc=</span><span class="s4">6</span><span class="s1">)</span>
        <span class="s1">assert_allclose(scale</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-15</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-15</span><span class="s1">)</span>
        <span class="s3"># with `fscale` fixed to 6, loc should be 4.</span>
        <span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = stats.laplace.fit(data</span><span class="s2">, </span><span class="s1">fscale=</span><span class="s4">6</span><span class="s1">)</span>
        <span class="s1">assert_allclose(loc</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-15</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-15</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_sf_cdf_extremes(self):</span>
        <span class="s3"># These calculations should not generate warnings.</span>
        <span class="s1">x = </span><span class="s4">1000</span>
        <span class="s1">p0 = stats.laplace.cdf(-x)</span>
        <span class="s3"># The exact value is smaller than can be represented with</span>
        <span class="s3"># 64 bit floating point, so the exected result is 0.</span>
        <span class="s2">assert </span><span class="s1">p0 == </span><span class="s4">0.0</span>
        <span class="s3"># The closest 64 bit floating point representation of the</span>
        <span class="s3"># exact value is 1.0.</span>
        <span class="s1">p1 = stats.laplace.cdf(x)</span>
        <span class="s2">assert </span><span class="s1">p1 == </span><span class="s4">1.0</span>

        <span class="s1">p0 = stats.laplace.sf(x)</span>
        <span class="s3"># The exact value is smaller than can be represented with</span>
        <span class="s3"># 64 bit floating point, so the exected result is 0.</span>
        <span class="s2">assert </span><span class="s1">p0 == </span><span class="s4">0.0</span>
        <span class="s3"># The closest 64 bit floating point representation of the</span>
        <span class="s3"># exact value is 1.0.</span>
        <span class="s1">p1 = stats.laplace.sf(-x)</span>
        <span class="s2">assert </span><span class="s1">p1 == </span><span class="s4">1.0</span>

    <span class="s2">def </span><span class="s1">test_sf(self):</span>
        <span class="s1">x = </span><span class="s4">200</span>
        <span class="s1">p = stats.laplace.sf(x)</span>
        <span class="s1">assert_allclose(p</span><span class="s2">, </span><span class="s1">np.exp(-x)/</span><span class="s4">2</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-13</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_isf(self):</span>
        <span class="s1">p = </span><span class="s4">1e-25</span>
        <span class="s1">x = stats.laplace.isf(p)</span>
        <span class="s1">assert_allclose(x</span><span class="s2">, </span><span class="s1">-np.log(</span><span class="s4">2</span><span class="s1">*p)</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-13</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestPowerlaw:</span>

    <span class="s3"># In the following data, `sf` was computed with mpmath.</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'x, a, sf'</span><span class="s2">,</span>
                             <span class="s1">[(</span><span class="s4">0.25</span><span class="s2">, </span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">0.9375</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">0.99609375</span><span class="s2">, </span><span class="s4">1</span><span class="s1">/</span><span class="s4">256</span><span class="s2">, </span><span class="s4">1.528855235208108e-05</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_sf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">sf):</span>
        <span class="s1">assert_allclose(stats.powerlaw.sf(x</span><span class="s2">, </span><span class="s1">a)</span><span class="s2">, </span><span class="s1">sf</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-15</span><span class="s1">)</span>

    <span class="s1">@pytest.fixture(scope=</span><span class="s5">'function'</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">rng(self):</span>
        <span class="s2">return </span><span class="s1">np.random.default_rng(</span><span class="s4">1234</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;rvs_shape&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s4">.1</span><span class="s2">, </span><span class="s4">.5</span><span class="s2">, </span><span class="s4">.75</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;rvs_loc&quot;</span><span class="s2">, </span><span class="s1">[-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;rvs_scale&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s4">.1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">5</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'fix_shape, fix_loc, fix_scale'</span><span class="s2">,</span>
                             <span class="s1">[p </span><span class="s2">for </span><span class="s1">p </span><span class="s2">in </span><span class="s1">product([</span><span class="s2">True, False</span><span class="s1">]</span><span class="s2">, </span><span class="s1">repeat=</span><span class="s4">3</span><span class="s1">)</span>
                              <span class="s2">if False in </span><span class="s1">p])</span>
    <span class="s2">def </span><span class="s1">test_fit_MLE_comp_optimizer(self</span><span class="s2">, </span><span class="s1">rvs_shape</span><span class="s2">, </span><span class="s1">rvs_loc</span><span class="s2">, </span><span class="s1">rvs_scale</span><span class="s2">,</span>
                                    <span class="s1">fix_shape</span><span class="s2">, </span><span class="s1">fix_loc</span><span class="s2">, </span><span class="s1">fix_scale</span><span class="s2">, </span><span class="s1">rng):</span>
        <span class="s1">data = stats.powerlaw.rvs(size=</span><span class="s4">250</span><span class="s2">, </span><span class="s1">a=rvs_shape</span><span class="s2">, </span><span class="s1">loc=rvs_loc</span><span class="s2">,</span>
                                  <span class="s1">scale=rvs_scale</span><span class="s2">, </span><span class="s1">random_state=rng)</span>

        <span class="s1">kwds = dict()</span>
        <span class="s2">if </span><span class="s1">fix_shape:</span>
            <span class="s1">kwds[</span><span class="s5">'f0'</span><span class="s1">] = rvs_shape</span>
        <span class="s2">if </span><span class="s1">fix_loc:</span>
            <span class="s1">kwds[</span><span class="s5">'floc'</span><span class="s1">] = np.nextafter(data.min()</span><span class="s2">, </span><span class="s1">-np.inf)</span>
        <span class="s2">if </span><span class="s1">fix_scale:</span>
            <span class="s1">kwds[</span><span class="s5">'fscale'</span><span class="s1">] = rvs_scale</span>
        <span class="s1">_assert_less_or_close_loglike(stats.powerlaw</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">**kwds)</span>

    <span class="s2">def </span><span class="s1">test_problem_case(self):</span>
        <span class="s3"># An observed problem with the test method indicated that some fixed</span>
        <span class="s3"># scale values could cause bad results, this is now corrected.</span>
        <span class="s1">a = </span><span class="s4">2.50002862645130604506</span>
        <span class="s1">location = </span><span class="s4">0.0</span>
        <span class="s1">scale = </span><span class="s4">35.249023299873095</span>

        <span class="s1">data = stats.powerlaw.rvs(a=a</span><span class="s2">, </span><span class="s1">loc=location</span><span class="s2">, </span><span class="s1">scale=scale</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">100</span><span class="s2">,</span>
                                  <span class="s1">random_state=np.random.default_rng(</span><span class="s4">5</span><span class="s1">))</span>

        <span class="s1">kwds = {</span><span class="s5">'fscale'</span><span class="s1">: data.ptp() * </span><span class="s4">2</span><span class="s1">}</span>

        <span class="s1">_assert_less_or_close_loglike(stats.powerlaw</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">**kwds)</span>

    <span class="s2">def </span><span class="s1">test_fit_warnings(self):</span>
        <span class="s1">assert_fit_warnings(stats.powerlaw)</span>
        <span class="s3"># test for error when `fscale + floc &lt;= np.max(data)` is not satisfied</span>
        <span class="s1">msg = </span><span class="s5">r&quot; Maximum likelihood estimation with 'powerlaw' requires&quot;</span>
        <span class="s2">with </span><span class="s1">assert_raises(FitDataError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">stats.powerlaw.fit([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">floc=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">fscale=</span><span class="s4">3</span><span class="s1">)</span>

        <span class="s3"># test for error when `data - floc &gt;= 0`  is not satisfied</span>
        <span class="s1">msg = </span><span class="s5">r&quot; Maximum likelihood estimation with 'powerlaw' requires&quot;</span>
        <span class="s2">with </span><span class="s1">assert_raises(FitDataError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">stats.powerlaw.fit([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">floc=</span><span class="s4">2</span><span class="s1">)</span>

        <span class="s3"># test for fixed location not less than `min(data)`.</span>
        <span class="s1">msg = </span><span class="s5">r&quot; Maximum likelihood estimation with 'powerlaw' requires&quot;</span>
        <span class="s2">with </span><span class="s1">assert_raises(FitDataError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">stats.powerlaw.fit([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">floc=</span><span class="s4">1</span><span class="s1">)</span>

        <span class="s3"># test for when fixed scale is less than or equal to range of data</span>
        <span class="s1">msg = </span><span class="s5">r&quot;Negative or zero `fscale` is outside&quot;</span>
        <span class="s2">with </span><span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">stats.powerlaw.fit([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">fscale=-</span><span class="s4">3</span><span class="s1">)</span>

        <span class="s3"># test for when fixed scale is less than or equal to range of data</span>
        <span class="s1">msg = </span><span class="s5">r&quot;`fscale` must be greater than the range of data.&quot;</span>
        <span class="s2">with </span><span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">stats.powerlaw.fit([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">fscale=</span><span class="s4">3</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_minimum_data_zero_gh17801(self):</span>
        <span class="s3"># gh-17801 reported an overflow error when the minimum value of the</span>
        <span class="s3"># data is zero. Check that this problem is resolved.</span>
        <span class="s1">data = [</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s1">]</span>
        <span class="s1">dist = stats.powerlaw</span>
        <span class="s2">with </span><span class="s1">np.errstate(over=</span><span class="s5">'ignore'</span><span class="s1">):</span>
            <span class="s1">_assert_less_or_close_loglike(dist</span><span class="s2">, </span><span class="s1">data)</span>


<span class="s2">class </span><span class="s1">TestPowerLogNorm:</span>

    <span class="s3"># reference values were computed via mpmath</span>
    <span class="s3"># from mpmath import mp</span>
    <span class="s3"># mp.dps = 80</span>
    <span class="s3"># def powerlognorm_sf_mp(x, c, s):</span>
    <span class="s3">#     x = mp.mpf(x)</span>
    <span class="s3">#     c = mp.mpf(c)</span>
    <span class="s3">#     s = mp.mpf(s)</span>
    <span class="s3">#     return mp.ncdf(-mp.log(x) / s)**c</span>
    <span class="s3">#</span>
    <span class="s3"># def powerlognormal_cdf_mp(x, c, s):</span>
    <span class="s3">#     return mp.one - powerlognorm_sf_mp(x, c, s)</span>
    <span class="s3">#</span>
    <span class="s3"># x, c, s = 100, 20, 1</span>
    <span class="s3"># print(float(powerlognorm_sf_mp(x, c, s)))</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;x, c, s, ref&quot;</span><span class="s2">,</span>
                             <span class="s1">[(</span><span class="s4">100</span><span class="s2">, </span><span class="s4">20</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1.9057100820561928e-114</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">1e-3</span><span class="s2">, </span><span class="s4">20</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.9999999999507617</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">1e-3</span><span class="s2">, </span><span class="s4">0.02</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.9999999999999508</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">1e22</span><span class="s2">, </span><span class="s4">0.02</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">6.50744044621611e-12</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_sf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">ref):</span>
        <span class="s1">assert_allclose(stats.powerlognorm.sf(x</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">s)</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-13</span><span class="s1">)</span>

    <span class="s3"># reference values were computed via mpmath using the survival</span>
    <span class="s3"># function above (passing in `ref` and getting `q`).</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;q, c, s, ref&quot;</span><span class="s2">,</span>
                             <span class="s1">[(</span><span class="s4">0.9999999587870905</span><span class="s2">, </span><span class="s4">0.02</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.01</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">6.690376686108851e-233</span><span class="s2">, </span><span class="s4">20</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1000</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_isf(self</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">ref):</span>
        <span class="s1">assert_allclose(stats.powerlognorm.isf(q</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">s)</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">5e-11</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;x, c, s, ref&quot;</span><span class="s2">,</span>
                             <span class="s1">[(</span><span class="s4">1e25</span><span class="s2">, </span><span class="s4">0.02</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.9999999999999963</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">1e-6</span><span class="s2">, </span><span class="s4">0.02</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2.054921078040843e-45</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">1e-6</span><span class="s2">, </span><span class="s4">200</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2.0549210780408428e-41</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">0.3</span><span class="s2">, </span><span class="s4">200</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.9999999999713368</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_cdf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">ref):</span>
        <span class="s1">assert_allclose(stats.powerlognorm.cdf(x</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">s)</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">3e-14</span><span class="s1">)</span>

    <span class="s3"># reference values were computed via mpmath</span>
    <span class="s3"># from mpmath import mp</span>
    <span class="s3"># mp.dps = 50</span>
    <span class="s3"># def powerlognorm_pdf_mpmath(x, c, s):</span>
    <span class="s3">#     x = mp.mpf(x)</span>
    <span class="s3">#     c = mp.mpf(c)</span>
    <span class="s3">#     s = mp.mpf(s)</span>
    <span class="s3">#     res = (c/(x * s) * mp.npdf(mp.log(x)/s) *</span>
    <span class="s3">#            mp.ncdf(-mp.log(x)/s)**(c - mp.one))</span>
    <span class="s3">#     return float(res)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;x, c, s, ref&quot;</span><span class="s2">,</span>
                             <span class="s1">[(</span><span class="s4">1e22</span><span class="s2">, </span><span class="s4">0.02</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">6.5954987852335016e-34</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">1e20</span><span class="s2">, </span><span class="s4">1e-3</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1.588073750563988e-22</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">1e40</span><span class="s2">, </span><span class="s4">1e-3</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1.3179391812506349e-43</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_pdf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">ref):</span>
        <span class="s1">assert_allclose(stats.powerlognorm.pdf(x</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">s)</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">3e-12</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestPowerNorm:</span>

    <span class="s3"># survival function references were computed with mpmath via</span>
    <span class="s3"># from mpmath import mp</span>
    <span class="s3"># x = mp.mpf(x)</span>
    <span class="s3"># c = mp.mpf(x)</span>
    <span class="s3"># float(mp.ncdf(-x)**c)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;x, c, ref&quot;</span><span class="s2">,</span>
                             <span class="s1">[(</span><span class="s4">9</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1.1285884059538405e-19</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">20</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">7.582445786569958e-178</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">100</span><span class="s2">, </span><span class="s4">0.02</span><span class="s2">, </span><span class="s4">3.330957891903866e-44</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">200</span><span class="s2">, </span><span class="s4">0.01</span><span class="s2">, </span><span class="s4">1.3004759092324774e-87</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_sf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">ref):</span>
        <span class="s1">assert_allclose(stats.powernorm.sf(x</span><span class="s2">, </span><span class="s1">c)</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-13</span><span class="s1">)</span>

    <span class="s3"># inverse survival function references were computed with mpmath via</span>
    <span class="s3"># from mpmath import mp</span>
    <span class="s3"># def isf_mp(q, c):</span>
    <span class="s3">#     q = mp.mpf(q)</span>
    <span class="s3">#     c = mp.mpf(c)</span>
    <span class="s3">#     arg = q**(mp.one / c)</span>
    <span class="s3">#     return float(-mp.sqrt(2) * mp.erfinv(mp.mpf(2.) * arg - mp.one))</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;q, c, ref&quot;</span><span class="s2">,</span>
                             <span class="s1">[(</span><span class="s4">1e-5</span><span class="s2">, </span><span class="s4">20</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.15690800666514138</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">0.99999</span><span class="s2">, </span><span class="s4">100</span><span class="s2">, </span><span class="s1">-</span><span class="s4">5.19933666203545</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">0.9999</span><span class="s2">, </span><span class="s4">0.02</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2.576676052143387</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">5e-2</span><span class="s2">, </span><span class="s4">0.02</span><span class="s2">, </span><span class="s4">17.089518110222244</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">1e-18</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">5.9978070150076865</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">1e-50</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">6.361340902404057</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_isf(self</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">ref):</span>
        <span class="s1">assert_allclose(stats.powernorm.isf(q</span><span class="s2">, </span><span class="s1">c)</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">5e-12</span><span class="s1">)</span>

    <span class="s3"># CDF reference values were computed with mpmath via</span>
    <span class="s3"># from mpmath import mp</span>
    <span class="s3"># def cdf_mp(x, c):</span>
    <span class="s3">#     x = mp.mpf(x)</span>
    <span class="s3">#     c = mp.mpf(c)</span>
    <span class="s3">#     return float(mp.one - mp.ncdf(-x)**c)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;x, c, ref&quot;</span><span class="s2">,</span>
                             <span class="s1">[(-</span><span class="s4">12</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">1.598833900869911e-32</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">0.9999999999999983</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(-</span><span class="s4">20</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">2.4782617067456103e-88</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(-</span><span class="s4">5</span><span class="s2">, </span><span class="s4">0.02</span><span class="s2">, </span><span class="s4">5.733032242841443e-09</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(-</span><span class="s4">20</span><span class="s2">, </span><span class="s4">0.02</span><span class="s2">, </span><span class="s4">5.507248237212467e-91</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_cdf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">ref):</span>
        <span class="s1">assert_allclose(stats.powernorm.cdf(x</span><span class="s2">, </span><span class="s1">c)</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">5e-14</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestInvGamma:</span>
    <span class="s2">def </span><span class="s1">test_invgamma_inf_gh_1866(self):</span>
        <span class="s3"># invgamma's moments are only finite for a&gt;n</span>
        <span class="s3"># specific numbers checked w/ boost 1.54</span>
        <span class="s2">with </span><span class="s1">warnings.catch_warnings():</span>
            <span class="s1">warnings.simplefilter(</span><span class="s5">'error'</span><span class="s2">, </span><span class="s1">RuntimeWarning)</span>
            <span class="s1">mvsk = stats.invgamma.stats(a=</span><span class="s4">19.31</span><span class="s2">, </span><span class="s1">moments=</span><span class="s5">'mvsk'</span><span class="s1">)</span>
            <span class="s1">expected = [</span><span class="s4">0.05461496450</span><span class="s2">, </span><span class="s4">0.0001723162534</span><span class="s2">, </span><span class="s4">1.020362676</span><span class="s2">,</span>
                        <span class="s4">2.055616582</span><span class="s1">]</span>
            <span class="s1">assert_allclose(mvsk</span><span class="s2">, </span><span class="s1">expected)</span>

            <span class="s1">a = [</span><span class="s4">1.1</span><span class="s2">, </span><span class="s4">3.1</span><span class="s2">, </span><span class="s4">5.6</span><span class="s1">]</span>
            <span class="s1">mvsk = stats.invgamma.stats(a=a</span><span class="s2">, </span><span class="s1">moments=</span><span class="s5">'mvsk'</span><span class="s1">)</span>
            <span class="s1">expected = ([</span><span class="s4">10.</span><span class="s2">, </span><span class="s4">0.476190476</span><span class="s2">, </span><span class="s4">0.2173913043</span><span class="s1">]</span><span class="s2">,       </span><span class="s3"># mmm</span>
                        <span class="s1">[np.inf</span><span class="s2">, </span><span class="s4">0.2061430632</span><span class="s2">, </span><span class="s4">0.01312749422</span><span class="s1">]</span><span class="s2">,  </span><span class="s3"># vvv</span>
                        <span class="s1">[np.nan</span><span class="s2">, </span><span class="s4">41.95235392</span><span class="s2">, </span><span class="s4">2.919025532</span><span class="s1">]</span><span class="s2">,     </span><span class="s3"># sss</span>
                        <span class="s1">[np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s4">24.51923076</span><span class="s1">])          </span><span class="s3"># kkk</span>
            <span class="s2">for </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y </span><span class="s2">in </span><span class="s1">zip(mvsk</span><span class="s2">, </span><span class="s1">expected):</span>
                <span class="s1">assert_almost_equal(x</span><span class="s2">, </span><span class="s1">y)</span>

    <span class="s2">def </span><span class="s1">test_cdf_ppf(self):</span>
        <span class="s3"># gh-6245</span>
        <span class="s1">x = np.logspace(-</span><span class="s4">2.6</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">y = stats.invgamma.cdf(x</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">xx = stats.invgamma.ppf(y</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(x</span><span class="s2">, </span><span class="s1">xx)</span>

    <span class="s2">def </span><span class="s1">test_sf_isf(self):</span>
        <span class="s3"># gh-6245</span>
        <span class="s2">if </span><span class="s1">sys.maxsize &gt; </span><span class="s4">2</span><span class="s1">**</span><span class="s4">32</span><span class="s1">:</span>
            <span class="s1">x = np.logspace(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">100</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s3"># Invgamme roundtrip on 32-bit systems has relative accuracy</span>
            <span class="s3"># ~1e-15 until x=1e+15, and becomes inf above x=1e+18</span>
            <span class="s1">x = np.logspace(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">18</span><span class="s1">)</span>

        <span class="s1">y = stats.invgamma.sf(x</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">xx = stats.invgamma.isf(y</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(x</span><span class="s2">, </span><span class="s1">xx</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1.0</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;a, ref&quot;</span><span class="s2">,</span>
                             <span class="s1">[(</span><span class="s4">100000000.0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">26.21208257605721</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">1e+100</span><span class="s2">, </span><span class="s1">-</span><span class="s4">343.9688254159022</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_large_entropy(self</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">ref):</span>
        <span class="s3"># The reference values were calculated with mpmath:</span>
        <span class="s3"># from mpmath import mp</span>
        <span class="s3"># mp.dps = 500</span>

        <span class="s3"># def invgamma_entropy(a):</span>
        <span class="s3">#     a = mp.mpf(a)</span>
        <span class="s3">#     h = a + mp.loggamma(a) - (mp.one + a) * mp.digamma(a)</span>
        <span class="s3">#     return float(h)</span>
        <span class="s1">assert_allclose(stats.invgamma.entropy(a)</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-15</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestF:</span>
    <span class="s2">def </span><span class="s1">test_endpoints(self):</span>
        <span class="s3"># Compute the pdf at the left endpoint dst.a.</span>
        <span class="s1">data = [[stats.f</span><span class="s2">, </span><span class="s1">(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">]]</span>
        <span class="s2">for </span><span class="s1">_f</span><span class="s2">, </span><span class="s1">_args</span><span class="s2">, </span><span class="s1">_correct </span><span class="s2">in </span><span class="s1">data:</span>
            <span class="s1">ans = _f.pdf(_f.a</span><span class="s2">, </span><span class="s1">*_args)</span>

        <span class="s1">ans = [_f.pdf(_f.a</span><span class="s2">, </span><span class="s1">*_args) </span><span class="s2">for </span><span class="s1">_f</span><span class="s2">, </span><span class="s1">_args</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">data]</span>
        <span class="s1">correct = [_correct_ </span><span class="s2">for </span><span class="s1">_f</span><span class="s2">, </span><span class="s1">_args</span><span class="s2">, </span><span class="s1">_correct_ </span><span class="s2">in </span><span class="s1">data]</span>
        <span class="s1">assert_array_almost_equal(ans</span><span class="s2">, </span><span class="s1">correct)</span>

    <span class="s2">def </span><span class="s1">test_f_moments(self):</span>
        <span class="s3"># n-th moment of F distributions is only finite for n &lt; dfd / 2</span>
        <span class="s1">m</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">k = stats.f.stats(</span><span class="s4">11</span><span class="s2">, </span><span class="s4">6.5</span><span class="s2">, </span><span class="s1">moments=</span><span class="s5">'mvsk'</span><span class="s1">)</span>
        <span class="s1">assert_(np.isfinite(m))</span>
        <span class="s1">assert_(np.isfinite(v))</span>
        <span class="s1">assert_(np.isfinite(s))</span>
        <span class="s1">assert_(</span><span class="s2">not </span><span class="s1">np.isfinite(k))</span>

    <span class="s2">def </span><span class="s1">test_moments_warnings(self):</span>
        <span class="s3"># no warnings should be generated for dfd = 2, 4, 6, 8 (div by zero)</span>
        <span class="s2">with </span><span class="s1">warnings.catch_warnings():</span>
            <span class="s1">warnings.simplefilter(</span><span class="s5">'error'</span><span class="s2">, </span><span class="s1">RuntimeWarning)</span>
            <span class="s1">stats.f.stats(dfn=[</span><span class="s4">11</span><span class="s1">]*</span><span class="s4">4</span><span class="s2">, </span><span class="s1">dfd=[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">8</span><span class="s1">]</span><span class="s2">, </span><span class="s1">moments=</span><span class="s5">'mvsk'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_stats_broadcast(self):</span>
        <span class="s1">dfn = np.array([[</span><span class="s4">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">11</span><span class="s1">]])</span>
        <span class="s1">dfd = np.array([</span><span class="s4">11</span><span class="s2">, </span><span class="s4">12</span><span class="s1">])</span>
        <span class="s1">m</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">k = stats.f.stats(dfn=dfn</span><span class="s2">, </span><span class="s1">dfd=dfd</span><span class="s2">, </span><span class="s1">moments=</span><span class="s5">'mvsk'</span><span class="s1">)</span>
        <span class="s1">m2 = [dfd / (dfd - </span><span class="s4">2</span><span class="s1">)]*</span><span class="s4">2</span>
        <span class="s1">assert_allclose(m</span><span class="s2">, </span><span class="s1">m2)</span>
        <span class="s1">v2 = </span><span class="s4">2 </span><span class="s1">* dfd**</span><span class="s4">2 </span><span class="s1">* (dfn + dfd - </span><span class="s4">2</span><span class="s1">) / dfn / (dfd - </span><span class="s4">2</span><span class="s1">)**</span><span class="s4">2 </span><span class="s1">/ (dfd - </span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">assert_allclose(v</span><span class="s2">, </span><span class="s1">v2)</span>
        <span class="s1">s2 = ((</span><span class="s4">2</span><span class="s1">*dfn + dfd - </span><span class="s4">2</span><span class="s1">) * np.sqrt(</span><span class="s4">8</span><span class="s1">*(dfd - </span><span class="s4">4</span><span class="s1">)) /</span>
              <span class="s1">((dfd - </span><span class="s4">6</span><span class="s1">) * np.sqrt(dfn*(dfn + dfd - </span><span class="s4">2</span><span class="s1">))))</span>
        <span class="s1">assert_allclose(s</span><span class="s2">, </span><span class="s1">s2)</span>
        <span class="s1">k2num = </span><span class="s4">12 </span><span class="s1">* (dfn * (</span><span class="s4">5</span><span class="s1">*dfd - </span><span class="s4">22</span><span class="s1">) * (dfn + dfd - </span><span class="s4">2</span><span class="s1">) +</span>
                      <span class="s1">(dfd - </span><span class="s4">4</span><span class="s1">) * (dfd - </span><span class="s4">2</span><span class="s1">)**</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">k2den = dfn * (dfd - </span><span class="s4">6</span><span class="s1">) * (dfd - </span><span class="s4">8</span><span class="s1">) * (dfn + dfd - </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">k2 = k2num / k2den</span>
        <span class="s1">assert_allclose(k</span><span class="s2">, </span><span class="s1">k2)</span>


<span class="s2">class </span><span class="s1">TestStudentT:</span>
    <span class="s2">def </span><span class="s1">test_rvgeneric_std(self):</span>
        <span class="s3"># Regression test for #1191</span>
        <span class="s1">assert_array_almost_equal(stats.t.std([</span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s1">])</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1.29099445</span><span class="s2">, </span><span class="s4">1.22474487</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_moments_t(self):</span>
        <span class="s3"># regression test for #8786</span>
        <span class="s1">assert_equal(stats.t.stats(df=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">moments=</span><span class="s5">'mvsk'</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">(np.inf</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan))</span>
        <span class="s1">assert_equal(stats.t.stats(df=</span><span class="s4">1.01</span><span class="s2">, </span><span class="s1">moments=</span><span class="s5">'mvsk'</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">(</span><span class="s4">0.0</span><span class="s2">, </span><span class="s1">np.inf</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan))</span>
        <span class="s1">assert_equal(stats.t.stats(df=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">moments=</span><span class="s5">'mvsk'</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">(</span><span class="s4">0.0</span><span class="s2">, </span><span class="s1">np.inf</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan))</span>
        <span class="s1">assert_equal(stats.t.stats(df=</span><span class="s4">2.01</span><span class="s2">, </span><span class="s1">moments=</span><span class="s5">'mvsk'</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">(</span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">2.01</span><span class="s1">/(</span><span class="s4">2.01</span><span class="s1">-</span><span class="s4">2.0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.inf))</span>
        <span class="s1">assert_equal(stats.t.stats(df=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">moments=</span><span class="s5">'sk'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(np.nan</span><span class="s2">, </span><span class="s1">np.inf))</span>
        <span class="s1">assert_equal(stats.t.stats(df=</span><span class="s4">3.01</span><span class="s2">, </span><span class="s1">moments=</span><span class="s5">'sk'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.0</span><span class="s2">, </span><span class="s1">np.inf))</span>
        <span class="s1">assert_equal(stats.t.stats(df=</span><span class="s4">4</span><span class="s2">, </span><span class="s1">moments=</span><span class="s5">'sk'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.0</span><span class="s2">, </span><span class="s1">np.inf))</span>
        <span class="s1">assert_equal(stats.t.stats(df=</span><span class="s4">4.01</span><span class="s2">, </span><span class="s1">moments=</span><span class="s5">'sk'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">6.0</span><span class="s1">/(</span><span class="s4">4.01 </span><span class="s1">- </span><span class="s4">4.0</span><span class="s1">)))</span>

    <span class="s2">def </span><span class="s1">test_t_entropy(self):</span>
        <span class="s1">df = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">25</span><span class="s2">, </span><span class="s4">100</span><span class="s1">]</span>
        <span class="s3"># Expected values were computed with mpmath.</span>
        <span class="s1">expected = [</span><span class="s4">2.5310242469692907</span><span class="s2">, </span><span class="s4">1.9602792291600821</span><span class="s2">,</span>
                    <span class="s4">1.459327578078393</span><span class="s2">, </span><span class="s4">1.4289633653182439</span><span class="s1">]</span>
        <span class="s1">assert_allclose(stats.t.entropy(df)</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-13</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;v, ref&quot;</span><span class="s2">,</span>
                            <span class="s1">[(</span><span class="s4">100</span><span class="s2">, </span><span class="s4">1.4289633653182439</span><span class="s1">)</span><span class="s2">,</span>
                            <span class="s1">(</span><span class="s4">1e+100</span><span class="s2">, </span><span class="s4">1.4189385332046727</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_t_extreme_entropy(self</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">ref):</span>
        <span class="s3"># Reference values were calculated with mpmath:</span>
        <span class="s3"># from mpmath import mp</span>
        <span class="s3"># mp.dps = 500</span>
        <span class="s3">#</span>
        <span class="s3"># def t_entropy(v):</span>
        <span class="s3">#   v = mp.mpf(v)</span>
        <span class="s3">#   C = (v + mp.one) / 2</span>
        <span class="s3">#   A = C * (mp.digamma(C) - mp.digamma(v / 2))</span>
        <span class="s3">#   B = 0.5 * mp.log(v) + mp.log(mp.beta(v / 2, mp.one / 2))</span>
        <span class="s3">#   h = A + B</span>
        <span class="s3">#   return float(h)</span>
        <span class="s1">assert_allclose(stats.t.entropy(v)</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-14</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;methname&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s5">&quot;pdf&quot;</span><span class="s2">, </span><span class="s5">&quot;logpdf&quot;</span><span class="s2">, </span><span class="s5">&quot;cdf&quot;</span><span class="s2">,</span>
                                        <span class="s5">&quot;ppf&quot;</span><span class="s2">, </span><span class="s5">&quot;sf&quot;</span><span class="s2">, </span><span class="s5">&quot;isf&quot;</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;df_infmask&quot;</span><span class="s2">, </span><span class="s1">[[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
                                            <span class="s1">[[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]]</span><span class="s2">,</span>
                                            <span class="s1">[[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]]</span><span class="s2">,</span>
                                            <span class="s1">[[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s1">]]])</span>
    <span class="s2">def </span><span class="s1">test_t_inf_df(self</span><span class="s2">, </span><span class="s1">methname</span><span class="s2">, </span><span class="s1">df_infmask):</span>
        <span class="s1">np.random.seed(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">df_infmask = np.asarray(df_infmask</span><span class="s2">, </span><span class="s1">dtype=bool)</span>
        <span class="s1">df = np.random.uniform(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s1">size=df_infmask.shape)</span>
        <span class="s1">x = np.random.randn(*df_infmask.shape)</span>
        <span class="s1">df[df_infmask] = np.inf</span>
        <span class="s1">t_dist = stats.t(df=df</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">t_dist_ref = stats.t(df=df[~df_infmask]</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">norm_dist = stats.norm(loc=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">t_meth = getattr(t_dist</span><span class="s2">, </span><span class="s1">methname)</span>
        <span class="s1">t_meth_ref = getattr(t_dist_ref</span><span class="s2">, </span><span class="s1">methname)</span>
        <span class="s1">norm_meth = getattr(norm_dist</span><span class="s2">, </span><span class="s1">methname)</span>
        <span class="s1">res = t_meth(x)</span>
        <span class="s1">assert_equal(res[df_infmask]</span><span class="s2">, </span><span class="s1">norm_meth(x[df_infmask]))</span>
        <span class="s1">assert_equal(res[~df_infmask]</span><span class="s2">, </span><span class="s1">t_meth_ref(x[~df_infmask]))</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;df_infmask&quot;</span><span class="s2">, </span><span class="s1">[[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
                                            <span class="s1">[[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]]</span><span class="s2">,</span>
                                            <span class="s1">[[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]]</span><span class="s2">,</span>
                                            <span class="s1">[[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s1">]]])</span>
    <span class="s2">def </span><span class="s1">test_t_inf_df_stats_entropy(self</span><span class="s2">, </span><span class="s1">df_infmask):</span>
        <span class="s1">np.random.seed(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">df_infmask = np.asarray(df_infmask</span><span class="s2">, </span><span class="s1">dtype=bool)</span>
        <span class="s1">df = np.random.uniform(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s1">size=df_infmask.shape)</span>
        <span class="s1">df[df_infmask] = np.inf</span>
        <span class="s1">res = stats.t.stats(df=df</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">moments=</span><span class="s5">'mvsk'</span><span class="s1">)</span>
        <span class="s1">res_ex_inf = stats.norm.stats(loc=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">moments=</span><span class="s5">'mvsk'</span><span class="s1">)</span>
        <span class="s1">res_ex_noinf = stats.t.stats(df=df[~df_infmask]</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">1</span><span class="s2">,</span>
                                    <span class="s1">moments=</span><span class="s5">'mvsk'</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">4</span><span class="s1">):</span>
            <span class="s1">assert_equal(res[i][df_infmask]</span><span class="s2">, </span><span class="s1">res_ex_inf[i])</span>
            <span class="s1">assert_equal(res[i][~df_infmask]</span><span class="s2">, </span><span class="s1">res_ex_noinf[i])</span>

        <span class="s1">res = stats.t.entropy(df=df</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">res_ex_inf = stats.norm.entropy(loc=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">res_ex_noinf = stats.t.entropy(df=df[~df_infmask]</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(res[df_infmask]</span><span class="s2">, </span><span class="s1">res_ex_inf)</span>
        <span class="s1">assert_equal(res[~df_infmask]</span><span class="s2">, </span><span class="s1">res_ex_noinf)</span>


    <span class="s2">def </span><span class="s1">test_logpdf_pdf(self):</span>
        <span class="s3"># reference values were computed via the reference distribution, e.g.</span>
        <span class="s3"># mp.dps = 500; StudentT(df=df).logpdf(x), StudentT(df=df).pdf(x)</span>
        <span class="s1">x = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1e3</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">df = [</span><span class="s4">1e100</span><span class="s2">, </span><span class="s4">1e50</span><span class="s2">, </span><span class="s4">1e20</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">logpdf_ref = [-</span><span class="s4">1.4189385332046727</span><span class="s2">, </span><span class="s1">-</span><span class="s4">500000.9189385332</span><span class="s2">,</span>
                      <span class="s1">-</span><span class="s4">50.918938533204674</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.8378770664093456</span><span class="s1">]</span>
        <span class="s1">pdf_ref = [</span><span class="s4">0.24197072451914334</span><span class="s2">, </span><span class="s4">0</span><span class="s2">,</span>
                   <span class="s4">7.69459862670642e-23</span><span class="s2">, </span><span class="s4">0.15915494309189535</span><span class="s1">]</span>
        <span class="s1">assert_allclose(stats.t.logpdf(x</span><span class="s2">, </span><span class="s1">df)</span><span class="s2">, </span><span class="s1">logpdf_ref</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-15</span><span class="s1">)</span>
        <span class="s1">assert_allclose(stats.t.pdf(x</span><span class="s2">, </span><span class="s1">df)</span><span class="s2">, </span><span class="s1">pdf_ref</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-14</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestRvDiscrete:</span>
    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">np.random.seed(</span><span class="s4">1234</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_rvs(self):</span>
        <span class="s1">states = [-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span>
        <span class="s1">probability = [</span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.3</span><span class="s2">, </span><span class="s4">0.4</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.3</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">]</span>
        <span class="s1">samples = </span><span class="s4">1000</span>
        <span class="s1">r = stats.rv_discrete(name=</span><span class="s5">'sample'</span><span class="s2">, </span><span class="s1">values=(states</span><span class="s2">, </span><span class="s1">probability))</span>
        <span class="s1">x = r.rvs(size=samples)</span>
        <span class="s1">assert_(isinstance(x</span><span class="s2">, </span><span class="s1">numpy.ndarray))</span>

        <span class="s2">for </span><span class="s1">s</span><span class="s2">, </span><span class="s1">p </span><span class="s2">in </span><span class="s1">zip(states</span><span class="s2">, </span><span class="s1">probability):</span>
            <span class="s1">assert_(abs(sum(x == s)/float(samples) - p) &lt; </span><span class="s4">0.05</span><span class="s1">)</span>

        <span class="s1">x = r.rvs()</span>
        <span class="s2">assert </span><span class="s1">np.issubdtype(type(x)</span><span class="s2">, </span><span class="s1">np.integer)</span>

    <span class="s2">def </span><span class="s1">test_entropy(self):</span>
        <span class="s3"># Basic tests of entropy.</span>
        <span class="s1">pvals = np.array([</span><span class="s4">0.25</span><span class="s2">, </span><span class="s4">0.45</span><span class="s2">, </span><span class="s4">0.3</span><span class="s1">])</span>
        <span class="s1">p = stats.rv_discrete(values=([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">pvals))</span>
        <span class="s1">expected_h = -sum(xlogy(pvals</span><span class="s2">, </span><span class="s1">pvals))</span>
        <span class="s1">h = p.entropy()</span>
        <span class="s1">assert_allclose(h</span><span class="s2">, </span><span class="s1">expected_h)</span>

        <span class="s1">p = stats.rv_discrete(values=([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]))</span>
        <span class="s1">h = p.entropy()</span>
        <span class="s1">assert_equal(h</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_pmf(self):</span>
        <span class="s1">xk = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span>
        <span class="s1">pk = [</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.3</span><span class="s2">, </span><span class="s4">0.2</span><span class="s1">]</span>
        <span class="s1">rv = stats.rv_discrete(values=(xk</span><span class="s2">, </span><span class="s1">pk))</span>

        <span class="s1">x = [[</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">4.</span><span class="s1">]</span><span class="s2">,</span>
             <span class="s1">[</span><span class="s4">3.</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]]</span>
        <span class="s1">assert_allclose(rv.pmf(x)</span><span class="s2">,</span>
                        <span class="s1">[[</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.2</span><span class="s1">]</span><span class="s2">,</span>
                         <span class="s1">[</span><span class="s4">0.</span><span class="s2">, </span><span class="s4">0.3</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-14</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_cdf(self):</span>
        <span class="s1">xk = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span>
        <span class="s1">pk = [</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.3</span><span class="s2">, </span><span class="s4">0.2</span><span class="s1">]</span>
        <span class="s1">rv = stats.rv_discrete(values=(xk</span><span class="s2">, </span><span class="s1">pk))</span>

        <span class="s1">x_values = [-</span><span class="s4">2</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.1</span><span class="s2">, </span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">3.0</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s1">]</span>
        <span class="s1">expected = [</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.8</span><span class="s2">, </span><span class="s4">0.8</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">assert_allclose(rv.cdf(x_values)</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-14</span><span class="s1">)</span>

        <span class="s3"># also check scalar arguments</span>
        <span class="s1">assert_allclose([rv.cdf(xx) </span><span class="s2">for </span><span class="s1">xx </span><span class="s2">in </span><span class="s1">x_values]</span><span class="s2">,</span>
                        <span class="s1">expected</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-14</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_ppf(self):</span>
        <span class="s1">xk = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span>
        <span class="s1">pk = [</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.3</span><span class="s2">, </span><span class="s4">0.2</span><span class="s1">]</span>
        <span class="s1">rv = stats.rv_discrete(values=(xk</span><span class="s2">, </span><span class="s1">pk))</span>

        <span class="s1">q_values = [</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.6</span><span class="s2">, </span><span class="s4">0.8</span><span class="s2">, </span><span class="s4">0.9</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]</span>
        <span class="s1">expected = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span>
        <span class="s1">assert_allclose(rv.ppf(q_values)</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-14</span><span class="s1">)</span>

        <span class="s3"># also check scalar arguments</span>
        <span class="s1">assert_allclose([rv.ppf(q) </span><span class="s2">for </span><span class="s1">q </span><span class="s2">in </span><span class="s1">q_values]</span><span class="s2">,</span>
                        <span class="s1">expected</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-14</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_cdf_ppf_next(self):</span>
        <span class="s3"># copied and special cased from test_discrete_basic</span>
        <span class="s1">vals = ([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">8</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">0.3</span><span class="s2">, </span><span class="s4">0.3</span><span class="s2">, </span><span class="s4">0.1</span><span class="s1">])</span>
        <span class="s1">rv = stats.rv_discrete(values=vals)</span>

        <span class="s1">assert_array_equal(rv.ppf(rv.cdf(rv.xk[:-</span><span class="s4">1</span><span class="s1">]) + </span><span class="s4">1e-8</span><span class="s1">)</span><span class="s2">,</span>
                           <span class="s1">rv.xk[</span><span class="s4">1</span><span class="s1">:])</span>

    <span class="s2">def </span><span class="s1">test_multidimension(self):</span>
        <span class="s1">xk = np.arange(</span><span class="s4">12</span><span class="s1">).reshape((</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">))</span>
        <span class="s1">pk = np.array([[</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.15</span><span class="s2">, </span><span class="s4">0.05</span><span class="s1">]</span><span class="s2">,</span>
                       <span class="s1">[</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.05</span><span class="s2">, </span><span class="s4">0.05</span><span class="s1">]</span><span class="s2">,</span>
                       <span class="s1">[</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.05</span><span class="s2">, </span><span class="s4">0.05</span><span class="s1">]])</span>
        <span class="s1">rv = stats.rv_discrete(values=(xk</span><span class="s2">, </span><span class="s1">pk))</span>

        <span class="s1">assert_allclose(rv.expect()</span><span class="s2">, </span><span class="s1">np.sum(rv.xk * rv.pk)</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-14</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_bad_input(self):</span>
        <span class="s1">xk = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span>
        <span class="s1">pk = [</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">]</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.rv_discrete</span><span class="s2">, </span><span class="s1">**dict(values=(xk</span><span class="s2">, </span><span class="s1">pk)))</span>

        <span class="s1">pk = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.rv_discrete</span><span class="s2">, </span><span class="s1">**dict(values=(xk</span><span class="s2">, </span><span class="s1">pk)))</span>

        <span class="s1">xk = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span>
        <span class="s1">pk = [</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1.2</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.7</span><span class="s1">]</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.rv_discrete</span><span class="s2">, </span><span class="s1">**dict(values=(xk</span><span class="s2">, </span><span class="s1">pk)))</span>

        <span class="s1">xk = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s1">]</span>
        <span class="s1">pk = [</span><span class="s4">0.3</span><span class="s2">, </span><span class="s4">0.3</span><span class="s2">, </span><span class="s4">0.3</span><span class="s2">, </span><span class="s4">0.3</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.2</span><span class="s1">]</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.rv_discrete</span><span class="s2">, </span><span class="s1">**dict(values=(xk</span><span class="s2">, </span><span class="s1">pk)))</span>

    <span class="s2">def </span><span class="s1">test_shape_rv_sample(self):</span>
        <span class="s3"># tests added for gh-9565</span>

        <span class="s3"># mismatch of 2d inputs</span>
        <span class="s1">xk</span><span class="s2">, </span><span class="s1">pk = np.arange(</span><span class="s4">4</span><span class="s1">).reshape((</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span><span class="s2">, </span><span class="s1">np.full((</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1</span><span class="s1">/</span><span class="s4">6</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.rv_discrete</span><span class="s2">, </span><span class="s1">**dict(values=(xk</span><span class="s2">, </span><span class="s1">pk)))</span>

        <span class="s3"># same number of elements, but shapes not compatible</span>
        <span class="s1">xk</span><span class="s2">, </span><span class="s1">pk = np.arange(</span><span class="s4">6</span><span class="s1">).reshape((</span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span><span class="s2">, </span><span class="s1">np.full((</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1</span><span class="s1">/</span><span class="s4">6</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.rv_discrete</span><span class="s2">, </span><span class="s1">**dict(values=(xk</span><span class="s2">, </span><span class="s1">pk)))</span>

        <span class="s3"># same shapes =&gt; no error</span>
        <span class="s1">xk</span><span class="s2">, </span><span class="s1">pk = np.arange(</span><span class="s4">6</span><span class="s1">).reshape((</span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span><span class="s2">, </span><span class="s1">np.full((</span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1</span><span class="s1">/</span><span class="s4">6</span><span class="s1">)</span>
        <span class="s1">assert_equal(stats.rv_discrete(values=(xk</span><span class="s2">, </span><span class="s1">pk)).pmf(</span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1</span><span class="s1">/</span><span class="s4">6</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_expect1(self):</span>
        <span class="s1">xk = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">11</span><span class="s1">]</span>
        <span class="s1">pk = [</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">0.1</span><span class="s1">]</span>
        <span class="s1">rv = stats.rv_discrete(values=(xk</span><span class="s2">, </span><span class="s1">pk))</span>

        <span class="s1">assert_allclose(rv.expect()</span><span class="s2">, </span><span class="s1">np.sum(rv.xk * rv.pk)</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-14</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_expect2(self):</span>
        <span class="s3"># rv_sample should override _expect. Bug report from</span>
        <span class="s3"># https://stackoverflow.com/questions/63199792</span>
        <span class="s1">y = [</span><span class="s4">200.0</span><span class="s2">, </span><span class="s4">300.0</span><span class="s2">, </span><span class="s4">400.0</span><span class="s2">, </span><span class="s4">500.0</span><span class="s2">, </span><span class="s4">600.0</span><span class="s2">, </span><span class="s4">700.0</span><span class="s2">, </span><span class="s4">800.0</span><span class="s2">, </span><span class="s4">900.0</span><span class="s2">, </span><span class="s4">1000.0</span><span class="s2">,</span>
             <span class="s4">1100.0</span><span class="s2">, </span><span class="s4">1200.0</span><span class="s2">, </span><span class="s4">1300.0</span><span class="s2">, </span><span class="s4">1400.0</span><span class="s2">, </span><span class="s4">1500.0</span><span class="s2">, </span><span class="s4">1600.0</span><span class="s2">, </span><span class="s4">1700.0</span><span class="s2">, </span><span class="s4">1800.0</span><span class="s2">,</span>
             <span class="s4">1900.0</span><span class="s2">, </span><span class="s4">2000.0</span><span class="s2">, </span><span class="s4">2100.0</span><span class="s2">, </span><span class="s4">2200.0</span><span class="s2">, </span><span class="s4">2300.0</span><span class="s2">, </span><span class="s4">2400.0</span><span class="s2">, </span><span class="s4">2500.0</span><span class="s2">, </span><span class="s4">2600.0</span><span class="s2">,</span>
             <span class="s4">2700.0</span><span class="s2">, </span><span class="s4">2800.0</span><span class="s2">, </span><span class="s4">2900.0</span><span class="s2">, </span><span class="s4">3000.0</span><span class="s2">, </span><span class="s4">3100.0</span><span class="s2">, </span><span class="s4">3200.0</span><span class="s2">, </span><span class="s4">3300.0</span><span class="s2">, </span><span class="s4">3400.0</span><span class="s2">,</span>
             <span class="s4">3500.0</span><span class="s2">, </span><span class="s4">3600.0</span><span class="s2">, </span><span class="s4">3700.0</span><span class="s2">, </span><span class="s4">3800.0</span><span class="s2">, </span><span class="s4">3900.0</span><span class="s2">, </span><span class="s4">4000.0</span><span class="s2">, </span><span class="s4">4100.0</span><span class="s2">, </span><span class="s4">4200.0</span><span class="s2">,</span>
             <span class="s4">4300.0</span><span class="s2">, </span><span class="s4">4400.0</span><span class="s2">, </span><span class="s4">4500.0</span><span class="s2">, </span><span class="s4">4600.0</span><span class="s2">, </span><span class="s4">4700.0</span><span class="s2">, </span><span class="s4">4800.0</span><span class="s1">]</span>

        <span class="s1">py = [</span><span class="s4">0.0004</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.0033</span><span class="s2">, </span><span class="s4">0.006500000000000001</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">,</span>
              <span class="s4">0.004399999999999999</span><span class="s2">, </span><span class="s4">0.6862</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">,</span>
              <span class="s4">0.00019999999999997797</span><span class="s2">, </span><span class="s4">0.0006000000000000449</span><span class="s2">,</span>
              <span class="s4">0.024499999999999966</span><span class="s2">, </span><span class="s4">0.006400000000000072</span><span class="s2">,</span>
              <span class="s4">0.0043999999999999595</span><span class="s2">, </span><span class="s4">0.019499999999999962</span><span class="s2">,</span>
              <span class="s4">0.03770000000000007</span><span class="s2">, </span><span class="s4">0.01759999999999995</span><span class="s2">, </span><span class="s4">0.015199999999999991</span><span class="s2">,</span>
              <span class="s4">0.018100000000000005</span><span class="s2">, </span><span class="s4">0.04500000000000004</span><span class="s2">, </span><span class="s4">0.0025999999999999357</span><span class="s2">,</span>
              <span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.0041000000000001036</span><span class="s2">, </span><span class="s4">0.005999999999999894</span><span class="s2">,</span>
              <span class="s4">0.0042000000000000925</span><span class="s2">, </span><span class="s4">0.0050000000000000044</span><span class="s2">,</span>
              <span class="s4">0.0041999999999999815</span><span class="s2">, </span><span class="s4">0.0004999999999999449</span><span class="s2">,</span>
              <span class="s4">0.009199999999999986</span><span class="s2">, </span><span class="s4">0.008200000000000096</span><span class="s2">,</span>
              <span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.0046999999999999265</span><span class="s2">, </span><span class="s4">0.0019000000000000128</span><span class="s2">,</span>
              <span class="s4">0.0006000000000000449</span><span class="s2">, </span><span class="s4">0.02510000000000001</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">,</span>
              <span class="s4">0.007199999999999984</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.012699999999999934</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">,</span>
              <span class="s4">0.008199999999999985</span><span class="s2">, </span><span class="s4">0.005600000000000049</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">]</span>

        <span class="s1">rv = stats.rv_discrete(values=(y</span><span class="s2">, </span><span class="s1">py))</span>

        <span class="s3"># check the mean</span>
        <span class="s1">assert_allclose(rv.expect()</span><span class="s2">, </span><span class="s1">rv.mean()</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-14</span><span class="s1">)</span>
        <span class="s1">assert_allclose(rv.expect()</span><span class="s2">,</span>
                        <span class="s1">sum(v * w </span><span class="s2">for </span><span class="s1">v</span><span class="s2">, </span><span class="s1">w </span><span class="s2">in </span><span class="s1">zip(y</span><span class="s2">, </span><span class="s1">py))</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-14</span><span class="s1">)</span>

        <span class="s3"># also check the second moment</span>
        <span class="s1">assert_allclose(rv.expect(</span><span class="s2">lambda </span><span class="s1">x: x**</span><span class="s4">2</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">sum(v**</span><span class="s4">2 </span><span class="s1">* w </span><span class="s2">for </span><span class="s1">v</span><span class="s2">, </span><span class="s1">w </span><span class="s2">in </span><span class="s1">zip(y</span><span class="s2">, </span><span class="s1">py))</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-14</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestSkewCauchy:</span>
    <span class="s2">def </span><span class="s1">test_cauchy(self):</span>
        <span class="s1">x = np.linspace(-</span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">100</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(stats.skewcauchy.pdf(x</span><span class="s2">, </span><span class="s1">a=</span><span class="s4">0</span><span class="s1">)</span><span class="s2">,</span>
                                  <span class="s1">stats.cauchy.pdf(x))</span>
        <span class="s1">assert_array_almost_equal(stats.skewcauchy.cdf(x</span><span class="s2">, </span><span class="s1">a=</span><span class="s4">0</span><span class="s1">)</span><span class="s2">,</span>
                                  <span class="s1">stats.cauchy.cdf(x))</span>
        <span class="s1">assert_array_almost_equal(stats.skewcauchy.ppf(x</span><span class="s2">, </span><span class="s1">a=</span><span class="s4">0</span><span class="s1">)</span><span class="s2">,</span>
                                  <span class="s1">stats.cauchy.ppf(x))</span>

    <span class="s2">def </span><span class="s1">test_skewcauchy_R(self):</span>
        <span class="s3"># options(digits=16)</span>
        <span class="s3"># library(sgt)</span>
        <span class="s3"># # lmbda, x contain the values generated for a, x below</span>
        <span class="s3"># lmbda &lt;- c(0.0976270078546495, 0.430378732744839, 0.2055267521432877,</span>
        <span class="s3">#            0.0897663659937937, -0.15269040132219, 0.2917882261333122,</span>
        <span class="s3">#            -0.12482557747462, 0.7835460015641595, 0.9273255210020589,</span>
        <span class="s3">#            -0.2331169623484446)</span>
        <span class="s3"># x &lt;- c(2.917250380826646, 0.2889491975290444, 0.6804456109393229,</span>
        <span class="s3">#        4.25596638292661, -4.289639418021131, -4.1287070029845925,</span>
        <span class="s3">#        -4.797816025596743, 3.32619845547938, 2.7815675094985046,</span>
        <span class="s3">#        3.700121482468191)</span>
        <span class="s3"># pdf = dsgt(x, mu=0, lambda=lambda, sigma=1, q=1/2, mean.cent=FALSE,</span>
        <span class="s3">#            var.adj = sqrt(2))</span>
        <span class="s3"># cdf = psgt(x, mu=0, lambda=lambda, sigma=1, q=1/2, mean.cent=FALSE,</span>
        <span class="s3">#            var.adj = sqrt(2))</span>
        <span class="s3"># qsgt(cdf, mu=0, lambda=lambda, sigma=1, q=1/2, mean.cent=FALSE,</span>
        <span class="s3">#      var.adj = sqrt(2))</span>

        <span class="s1">np.random.seed(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">a = np.random.rand(</span><span class="s4">10</span><span class="s1">) * </span><span class="s4">2 </span><span class="s1">- </span><span class="s4">1</span>
        <span class="s1">x = np.random.rand(</span><span class="s4">10</span><span class="s1">) * </span><span class="s4">10 </span><span class="s1">- </span><span class="s4">5</span>
        <span class="s1">pdf = [</span><span class="s4">0.039473975217333909</span><span class="s2">, </span><span class="s4">0.305829714049903223</span><span class="s2">, </span><span class="s4">0.24140158118994162</span><span class="s2">,</span>
               <span class="s4">0.019585772402693054</span><span class="s2">, </span><span class="s4">0.021436553695989482</span><span class="s2">, </span><span class="s4">0.00909817103867518</span><span class="s2">,</span>
               <span class="s4">0.01658423410016873</span><span class="s2">, </span><span class="s4">0.071083288030394126</span><span class="s2">, </span><span class="s4">0.103250045941454524</span><span class="s2">,</span>
               <span class="s4">0.013110230778426242</span><span class="s1">]</span>
        <span class="s1">cdf = [</span><span class="s4">0.87426677718213752</span><span class="s2">, </span><span class="s4">0.37556468910780882</span><span class="s2">, </span><span class="s4">0.59442096496538066</span><span class="s2">,</span>
               <span class="s4">0.91304659850890202</span><span class="s2">, </span><span class="s4">0.09631964100300605</span><span class="s2">, </span><span class="s4">0.03829624330921733</span><span class="s2">,</span>
               <span class="s4">0.08245240578402535</span><span class="s2">, </span><span class="s4">0.72057062945510386</span><span class="s2">, </span><span class="s4">0.62826415852515449</span><span class="s2">,</span>
               <span class="s4">0.95011308463898292</span><span class="s1">]</span>
        <span class="s1">assert_allclose(stats.skewcauchy.pdf(x</span><span class="s2">, </span><span class="s1">a)</span><span class="s2">, </span><span class="s1">pdf)</span>
        <span class="s1">assert_allclose(stats.skewcauchy.cdf(x</span><span class="s2">, </span><span class="s1">a)</span><span class="s2">, </span><span class="s1">cdf)</span>
        <span class="s1">assert_allclose(stats.skewcauchy.ppf(cdf</span><span class="s2">, </span><span class="s1">a)</span><span class="s2">, </span><span class="s1">x)</span>


<span class="s3"># Test data for TestSkewNorm.test_noncentral_moments()</span>
<span class="s3"># The expected noncentral moments were computed by Wolfram Alpha.</span>
<span class="s3"># In Wolfram Alpha, enter</span>
<span class="s3">#    SkewNormalDistribution[0, 1, a] moment</span>
<span class="s3"># with `a` replaced by the desired shape parameter.  In the results, there</span>
<span class="s3"># should be a table of the first four moments. Click on &quot;More&quot; to get more</span>
<span class="s3"># moments.  The expected moments start with the first moment (order = 1).</span>
<span class="s1">_skewnorm_noncentral_moments = [</span>
    <span class="s1">(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2</span><span class="s1">*np.sqrt(</span><span class="s4">2</span><span class="s1">/(</span><span class="s4">5</span><span class="s1">*np.pi))</span><span class="s2">,</span>
         <span class="s4">1</span><span class="s2">,</span>
         <span class="s4">22</span><span class="s1">/</span><span class="s4">5</span><span class="s1">*np.sqrt(</span><span class="s4">2</span><span class="s1">/(</span><span class="s4">5</span><span class="s1">*np.pi))</span><span class="s2">,</span>
         <span class="s4">3</span><span class="s2">,</span>
         <span class="s4">446</span><span class="s1">/</span><span class="s4">25</span><span class="s1">*np.sqrt(</span><span class="s4">2</span><span class="s1">/(</span><span class="s4">5</span><span class="s1">*np.pi))</span><span class="s2">,</span>
         <span class="s4">15</span><span class="s2">,</span>
         <span class="s4">2682</span><span class="s1">/</span><span class="s4">25</span><span class="s1">*np.sqrt(</span><span class="s4">2</span><span class="s1">/(</span><span class="s4">5</span><span class="s1">*np.pi))</span><span class="s2">,</span>
         <span class="s4">105</span><span class="s2">,</span>
         <span class="s4">107322</span><span class="s1">/</span><span class="s4">125</span><span class="s1">*np.sqrt(</span><span class="s4">2</span><span class="s1">/(</span><span class="s4">5</span><span class="s1">*np.pi))])</span><span class="s2">,</span>
    <span class="s1">(</span><span class="s4">0.1</span><span class="s2">, </span><span class="s1">[np.sqrt(</span><span class="s4">2</span><span class="s1">/(</span><span class="s4">101</span><span class="s1">*np.pi))</span><span class="s2">,</span>
           <span class="s4">1</span><span class="s2">,</span>
           <span class="s4">302</span><span class="s1">/</span><span class="s4">101</span><span class="s1">*np.sqrt(</span><span class="s4">2</span><span class="s1">/(</span><span class="s4">101</span><span class="s1">*np.pi))</span><span class="s2">,</span>
           <span class="s4">3</span><span class="s2">,</span>
           <span class="s1">(</span><span class="s4">152008</span><span class="s1">*np.sqrt(</span><span class="s4">2</span><span class="s1">/(</span><span class="s4">101</span><span class="s1">*np.pi)))/</span><span class="s4">10201</span><span class="s2">,</span>
           <span class="s4">15</span><span class="s2">,</span>
           <span class="s1">(</span><span class="s4">107116848</span><span class="s1">*np.sqrt(</span><span class="s4">2</span><span class="s1">/(</span><span class="s4">101</span><span class="s1">*np.pi)))/</span><span class="s4">1030301</span><span class="s2">,</span>
           <span class="s4">105</span><span class="s2">,</span>
           <span class="s1">(</span><span class="s4">97050413184</span><span class="s1">*np.sqrt(</span><span class="s4">2</span><span class="s1">/(</span><span class="s4">101</span><span class="s1">*np.pi)))/</span><span class="s4">104060401</span><span class="s1">])</span><span class="s2">,</span>
    <span class="s1">(-</span><span class="s4">3</span><span class="s2">, </span><span class="s1">[-</span><span class="s4">3</span><span class="s1">/np.sqrt(</span><span class="s4">5</span><span class="s1">*np.pi)</span><span class="s2">,</span>
          <span class="s4">1</span><span class="s2">,</span>
          <span class="s1">-</span><span class="s4">63</span><span class="s1">/(</span><span class="s4">10</span><span class="s1">*np.sqrt(</span><span class="s4">5</span><span class="s1">*np.pi))</span><span class="s2">,</span>
          <span class="s4">3</span><span class="s2">,</span>
          <span class="s1">-</span><span class="s4">2529</span><span class="s1">/(</span><span class="s4">100</span><span class="s1">*np.sqrt(</span><span class="s4">5</span><span class="s1">*np.pi))</span><span class="s2">,</span>
          <span class="s4">15</span><span class="s2">,</span>
          <span class="s1">-</span><span class="s4">30357</span><span class="s1">/(</span><span class="s4">200</span><span class="s1">*np.sqrt(</span><span class="s4">5</span><span class="s1">*np.pi))</span><span class="s2">,</span>
          <span class="s4">105</span><span class="s2">,</span>
          <span class="s1">-</span><span class="s4">2428623</span><span class="s1">/(</span><span class="s4">2000</span><span class="s1">*np.sqrt(</span><span class="s4">5</span><span class="s1">*np.pi))</span><span class="s2">,</span>
          <span class="s4">945</span><span class="s2">,</span>
          <span class="s1">-</span><span class="s4">242862867</span><span class="s1">/(</span><span class="s4">20000</span><span class="s1">*np.sqrt(</span><span class="s4">5</span><span class="s1">*np.pi))</span><span class="s2">,</span>
          <span class="s4">10395</span><span class="s2">,</span>
          <span class="s1">-</span><span class="s4">29143550277</span><span class="s1">/(</span><span class="s4">200000</span><span class="s1">*np.sqrt(</span><span class="s4">5</span><span class="s1">*np.pi))</span><span class="s2">,</span>
          <span class="s4">135135</span><span class="s1">])</span><span class="s2">,</span>
<span class="s1">]</span>


<span class="s2">class </span><span class="s1">TestSkewNorm:</span>
    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">self.rng = check_random_state(</span><span class="s4">1234</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_normal(self):</span>
        <span class="s3"># When the skewness is 0 the distribution is normal</span>
        <span class="s1">x = np.linspace(-</span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">100</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(stats.skewnorm.pdf(x</span><span class="s2">, </span><span class="s1">a=</span><span class="s4">0</span><span class="s1">)</span><span class="s2">,</span>
                                  <span class="s1">stats.norm.pdf(x))</span>

    <span class="s2">def </span><span class="s1">test_rvs(self):</span>
        <span class="s1">shape = (</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s1">)</span>
        <span class="s1">x = stats.skewnorm.rvs(a=</span><span class="s4">0.75</span><span class="s2">, </span><span class="s1">size=shape</span><span class="s2">, </span><span class="s1">random_state=self.rng)</span>
        <span class="s1">assert_equal(shape</span><span class="s2">, </span><span class="s1">x.shape)</span>

        <span class="s1">x = stats.skewnorm.rvs(a=-</span><span class="s4">3</span><span class="s2">, </span><span class="s1">size=shape</span><span class="s2">, </span><span class="s1">random_state=self.rng)</span>
        <span class="s1">assert_equal(shape</span><span class="s2">, </span><span class="s1">x.shape)</span>

    <span class="s2">def </span><span class="s1">test_moments(self):</span>
        <span class="s1">X = stats.skewnorm.rvs(a=</span><span class="s4">4</span><span class="s2">, </span><span class="s1">size=int(</span><span class="s4">1e6</span><span class="s1">)</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">2</span><span class="s2">,</span>
                               <span class="s1">random_state=self.rng)</span>
        <span class="s1">expected = [np.mean(X)</span><span class="s2">, </span><span class="s1">np.var(X)</span><span class="s2">, </span><span class="s1">stats.skew(X)</span><span class="s2">, </span><span class="s1">stats.kurtosis(X)]</span>
        <span class="s1">computed = stats.skewnorm.stats(a=</span><span class="s4">4</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">moments=</span><span class="s5">'mvsk'</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(computed</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">2</span><span class="s1">)</span>

        <span class="s1">X = stats.skewnorm.rvs(a=-</span><span class="s4">4</span><span class="s2">, </span><span class="s1">size=int(</span><span class="s4">1e6</span><span class="s1">)</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">2</span><span class="s2">,</span>
                               <span class="s1">random_state=self.rng)</span>
        <span class="s1">expected = [np.mean(X)</span><span class="s2">, </span><span class="s1">np.var(X)</span><span class="s2">, </span><span class="s1">stats.skew(X)</span><span class="s2">, </span><span class="s1">stats.kurtosis(X)]</span>
        <span class="s1">computed = stats.skewnorm.stats(a=-</span><span class="s4">4</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">moments=</span><span class="s5">'mvsk'</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(computed</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_cdf_large_x(self):</span>
        <span class="s3"># Regression test for gh-7746.</span>
        <span class="s3"># The x values are large enough that the closest 64 bit floating</span>
        <span class="s3"># point representation of the exact CDF is 1.0.</span>
        <span class="s1">p = stats.skewnorm.cdf([</span><span class="s4">10</span><span class="s2">, </span><span class="s4">20</span><span class="s2">, </span><span class="s4">30</span><span class="s1">]</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(p</span><span class="s2">, </span><span class="s1">np.ones(</span><span class="s4">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-14</span><span class="s1">)</span>
        <span class="s1">p = stats.skewnorm.cdf(</span><span class="s4">25</span><span class="s2">, </span><span class="s4">2.5</span><span class="s1">)</span>
        <span class="s1">assert_allclose(p</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-14</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_cdf_sf_small_values(self):</span>
        <span class="s3"># Triples are [x, a, cdf(x, a)].  These values were computed</span>
        <span class="s3"># using CDF[SkewNormDistribution[0, 1, a], x] in Wolfram Alpha.</span>
        <span class="s1">cdfvals = [</span>
            <span class="s1">[-</span><span class="s4">8</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">3.870035046664392611e-31</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[-</span><span class="s4">4</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">8.1298399188811398e-21</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[-</span><span class="s4">2</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">1.55326826787106273e-26</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[-</span><span class="s4">9</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2.257176811907681295e-19</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[-</span><span class="s4">10</span><span class="s2">, </span><span class="s1">-</span><span class="s4">4</span><span class="s2">, </span><span class="s4">1.523970604832105213e-23</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">]</span>
        <span class="s2">for </span><span class="s1">x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">cdfval </span><span class="s2">in </span><span class="s1">cdfvals:</span>
            <span class="s1">p = stats.skewnorm.cdf(x</span><span class="s2">, </span><span class="s1">a)</span>
            <span class="s1">assert_allclose(p</span><span class="s2">, </span><span class="s1">cdfval</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-8</span><span class="s1">)</span>
            <span class="s3"># For the skew normal distribution, sf(-x, -a) = cdf(x, a).</span>
            <span class="s1">p = stats.skewnorm.sf(-x</span><span class="s2">, </span><span class="s1">-a)</span>
            <span class="s1">assert_allclose(p</span><span class="s2">, </span><span class="s1">cdfval</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-8</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'a, moments'</span><span class="s2">, </span><span class="s1">_skewnorm_noncentral_moments)</span>
    <span class="s2">def </span><span class="s1">test_noncentral_moments(self</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">moments):</span>
        <span class="s2">for </span><span class="s1">order</span><span class="s2">, </span><span class="s1">expected </span><span class="s2">in </span><span class="s1">enumerate(moments</span><span class="s2">, </span><span class="s1">start=</span><span class="s4">1</span><span class="s1">):</span>
            <span class="s1">mom = stats.skewnorm.moment(order</span><span class="s2">, </span><span class="s1">a)</span>
            <span class="s1">assert_allclose(mom</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-14</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_fit(self):</span>
        <span class="s1">rng = np.random.default_rng(</span><span class="s4">4609813989115202851</span><span class="s1">)</span>

        <span class="s1">a</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = -</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3.5</span><span class="s2">, </span><span class="s4">0.5  </span><span class="s3"># arbitrary, valid parameters</span>
        <span class="s1">dist = stats.skewnorm(a</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale)</span>
        <span class="s1">rvs = dist.rvs(size=</span><span class="s4">100</span><span class="s2">, </span><span class="s1">random_state=rng)</span>

        <span class="s3"># test that MLE still honors guesses and fixed parameters</span>
        <span class="s1">a2</span><span class="s2">, </span><span class="s1">loc2</span><span class="s2">, </span><span class="s1">scale2 = stats.skewnorm.fit(rvs</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.5</span><span class="s2">, </span><span class="s1">floc=</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">a3</span><span class="s2">, </span><span class="s1">loc3</span><span class="s2">, </span><span class="s1">scale3 = stats.skewnorm.fit(rvs</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.6</span><span class="s2">, </span><span class="s1">floc=</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">loc2 == loc3 == </span><span class="s4">3  </span><span class="s3"># fixed parameter is respected</span>
        <span class="s2">assert </span><span class="s1">a2 != a3  </span><span class="s3"># different guess -&gt; (slightly) different outcome</span>
        <span class="s3"># quality of fit is tested elsewhere</span>

        <span class="s3"># test that MoM honors fixed parameters, accepts (but ignores) guesses</span>
        <span class="s1">a4</span><span class="s2">, </span><span class="s1">loc4</span><span class="s2">, </span><span class="s1">scale4 = stats.skewnorm.fit(rvs</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s1">fscale=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">method=</span><span class="s5">'mm'</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">scale4 == </span><span class="s4">3</span>
        <span class="s3"># because scale was fixed, only the mean and skewness will be matched</span>
        <span class="s1">dist4 = stats.skewnorm(a4</span><span class="s2">, </span><span class="s1">loc4</span><span class="s2">, </span><span class="s1">scale4)</span>
        <span class="s1">res = dist4.stats(moments=</span><span class="s5">'ms'</span><span class="s1">)</span>
        <span class="s1">ref = np.mean(rvs)</span><span class="s2">, </span><span class="s1">stats.skew(rvs)</span>
        <span class="s1">assert_allclose(res</span><span class="s2">, </span><span class="s1">ref)</span>

        <span class="s3"># Test behavior when skew of data is beyond maximum of skewnorm</span>
        <span class="s1">rvs = stats.pareto.rvs(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">100</span><span class="s2">, </span><span class="s1">random_state=rng)</span>

        <span class="s3"># MLE still works</span>
        <span class="s1">res = stats.skewnorm.fit(rvs)</span>
        <span class="s2">assert </span><span class="s1">np.all(np.isfinite(res))</span>

        <span class="s3"># MoM fits variance and skewness</span>
        <span class="s1">a5</span><span class="s2">, </span><span class="s1">loc5</span><span class="s2">, </span><span class="s1">scale5 = stats.skewnorm.fit(rvs</span><span class="s2">, </span><span class="s1">method=</span><span class="s5">'mm'</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">np.isinf(a5)</span>
        <span class="s3"># distribution infrastruction doesn't allow infinite shape parameters</span>
        <span class="s3"># into _stats; it just bypasses it and produces NaNs. Calculate</span>
        <span class="s3"># moments manually.</span>
        <span class="s1">m</span><span class="s2">, </span><span class="s1">v = np.mean(rvs)</span><span class="s2">, </span><span class="s1">np.var(rvs)</span>
        <span class="s1">assert_allclose(m</span><span class="s2">, </span><span class="s1">loc5 + scale5 * np.sqrt(</span><span class="s4">2</span><span class="s1">/np.pi))</span>
        <span class="s1">assert_allclose(v</span><span class="s2">, </span><span class="s1">scale5**</span><span class="s4">2 </span><span class="s1">* (</span><span class="s4">1 </span><span class="s1">- </span><span class="s4">2 </span><span class="s1">/ np.pi))</span>


<span class="s2">class </span><span class="s1">TestExpon:</span>
    <span class="s2">def </span><span class="s1">test_zero(self):</span>
        <span class="s1">assert_equal(stats.expon.pdf(</span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_tail(self):  </span><span class="s3"># Regression test for ticket 807</span>
        <span class="s1">assert_equal(stats.expon.cdf(</span><span class="s4">1e-18</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1e-18</span><span class="s1">)</span>
        <span class="s1">assert_equal(stats.expon.isf(stats.expon.sf(</span><span class="s4">40</span><span class="s1">))</span><span class="s2">, </span><span class="s4">40</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_nan_raises_error(self):</span>
        <span class="s3"># see gh-issue 10300</span>
        <span class="s1">x = np.array([</span><span class="s4">1.6483</span><span class="s2">, </span><span class="s4">2.7169</span><span class="s2">, </span><span class="s4">2.4667</span><span class="s2">, </span><span class="s4">1.1791</span><span class="s2">, </span><span class="s4">3.5433</span><span class="s2">, </span><span class="s1">np.nan])</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.expon.fit</span><span class="s2">, </span><span class="s1">x)</span>

    <span class="s2">def </span><span class="s1">test_inf_raises_error(self):</span>
        <span class="s3"># see gh-issue 10300</span>
        <span class="s1">x = np.array([</span><span class="s4">1.6483</span><span class="s2">, </span><span class="s4">2.7169</span><span class="s2">, </span><span class="s4">2.4667</span><span class="s2">, </span><span class="s4">1.1791</span><span class="s2">, </span><span class="s4">3.5433</span><span class="s2">, </span><span class="s1">np.inf])</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.expon.fit</span><span class="s2">, </span><span class="s1">x)</span>


<span class="s2">class </span><span class="s1">TestNorm:</span>
    <span class="s2">def </span><span class="s1">test_nan_raises_error(self):</span>
        <span class="s3"># see gh-issue 10300</span>
        <span class="s1">x = np.array([</span><span class="s4">1.6483</span><span class="s2">, </span><span class="s4">2.7169</span><span class="s2">, </span><span class="s4">2.4667</span><span class="s2">, </span><span class="s4">1.1791</span><span class="s2">, </span><span class="s4">3.5433</span><span class="s2">, </span><span class="s1">np.nan])</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.norm.fit</span><span class="s2">, </span><span class="s1">x)</span>

    <span class="s2">def </span><span class="s1">test_inf_raises_error(self):</span>
        <span class="s3"># see gh-issue 10300</span>
        <span class="s1">x = np.array([</span><span class="s4">1.6483</span><span class="s2">, </span><span class="s4">2.7169</span><span class="s2">, </span><span class="s4">2.4667</span><span class="s2">, </span><span class="s4">1.1791</span><span class="s2">, </span><span class="s4">3.5433</span><span class="s2">, </span><span class="s1">np.inf])</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.norm.fit</span><span class="s2">, </span><span class="s1">x)</span>

    <span class="s2">def </span><span class="s1">test_bad_keyword_arg(self):</span>
        <span class="s1">x = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span>
        <span class="s1">assert_raises(TypeError</span><span class="s2">, </span><span class="s1">stats.norm.fit</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">plate=</span><span class="s5">&quot;shrimp&quot;</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'loc'</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_delta_cdf(self</span><span class="s2">, </span><span class="s1">loc):</span>
        <span class="s3"># The expected value is computed with mpmath:</span>
        <span class="s3"># &gt;&gt;&gt; import mpmath</span>
        <span class="s3"># &gt;&gt;&gt; mpmath.mp.dps = 60</span>
        <span class="s3"># &gt;&gt;&gt; float(mpmath.ncdf(12) - mpmath.ncdf(11))</span>
        <span class="s3"># 1.910641809677555e-28</span>
        <span class="s1">expected = </span><span class="s4">1.910641809677555e-28</span>
        <span class="s1">delta = stats.norm._delta_cdf(</span><span class="s4">11</span><span class="s1">+loc</span><span class="s2">, </span><span class="s4">12</span><span class="s1">+loc</span><span class="s2">, </span><span class="s1">loc=loc)</span>
        <span class="s1">assert_allclose(delta</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-13</span><span class="s1">)</span>
        <span class="s1">delta = stats.norm._delta_cdf(-(</span><span class="s4">12</span><span class="s1">+loc)</span><span class="s2">, </span><span class="s1">-(</span><span class="s4">11</span><span class="s1">+loc)</span><span class="s2">, </span><span class="s1">loc=-loc)</span>
        <span class="s1">assert_allclose(delta</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-13</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestUniform:</span>
    <span class="s0">&quot;&quot;&quot;gh-10300&quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">test_nan_raises_error(self):</span>
        <span class="s3"># see gh-issue 10300</span>
        <span class="s1">x = np.array([</span><span class="s4">1.6483</span><span class="s2">, </span><span class="s4">2.7169</span><span class="s2">, </span><span class="s4">2.4667</span><span class="s2">, </span><span class="s4">1.1791</span><span class="s2">, </span><span class="s4">3.5433</span><span class="s2">, </span><span class="s1">np.nan])</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.uniform.fit</span><span class="s2">, </span><span class="s1">x)</span>

    <span class="s2">def </span><span class="s1">test_inf_raises_error(self):</span>
        <span class="s3"># see gh-issue 10300</span>
        <span class="s1">x = np.array([</span><span class="s4">1.6483</span><span class="s2">, </span><span class="s4">2.7169</span><span class="s2">, </span><span class="s4">2.4667</span><span class="s2">, </span><span class="s4">1.1791</span><span class="s2">, </span><span class="s4">3.5433</span><span class="s2">, </span><span class="s1">np.inf])</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.uniform.fit</span><span class="s2">, </span><span class="s1">x)</span>


<span class="s2">class </span><span class="s1">TestExponNorm:</span>
    <span class="s2">def </span><span class="s1">test_moments(self):</span>
        <span class="s3"># Some moment test cases based on non-loc/scaled formula</span>
        <span class="s2">def </span><span class="s1">get_moms(lam</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">mu):</span>
            <span class="s3"># See wikipedia for these formulae</span>
            <span class="s3">#  where it is listed as an exponentially modified gaussian</span>
            <span class="s1">opK2 = </span><span class="s4">1.0 </span><span class="s1">+ </span><span class="s4">1 </span><span class="s1">/ (lam*sig)**</span><span class="s4">2</span>
            <span class="s1">exp_skew = </span><span class="s4">2 </span><span class="s1">/ (lam * sig)**</span><span class="s4">3 </span><span class="s1">* opK2**(-</span><span class="s4">1.5</span><span class="s1">)</span>
            <span class="s1">exp_kurt = </span><span class="s4">6.0 </span><span class="s1">* (</span><span class="s4">1 </span><span class="s1">+ (lam * sig)**</span><span class="s4">2</span><span class="s1">)**(-</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">[mu + </span><span class="s4">1</span><span class="s1">/lam</span><span class="s2">, </span><span class="s1">sig*sig + </span><span class="s4">1.0</span><span class="s1">/(lam*lam)</span><span class="s2">, </span><span class="s1">exp_skew</span><span class="s2">, </span><span class="s1">exp_kurt]</span>

        <span class="s1">mu</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">lam = </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span>
        <span class="s1">K = </span><span class="s4">1.0 </span><span class="s1">/ (lam * sig)</span>
        <span class="s1">sts = stats.exponnorm.stats(K</span><span class="s2">, </span><span class="s1">loc=mu</span><span class="s2">, </span><span class="s1">scale=sig</span><span class="s2">, </span><span class="s1">moments=</span><span class="s5">'mvsk'</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(sts</span><span class="s2">, </span><span class="s1">get_moms(lam</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">mu))</span>
        <span class="s1">mu</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">lam = -</span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">0.1</span>
        <span class="s1">K = </span><span class="s4">1.0 </span><span class="s1">/ (lam * sig)</span>
        <span class="s1">sts = stats.exponnorm.stats(K</span><span class="s2">, </span><span class="s1">loc=mu</span><span class="s2">, </span><span class="s1">scale=sig</span><span class="s2">, </span><span class="s1">moments=</span><span class="s5">'mvsk'</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(sts</span><span class="s2">, </span><span class="s1">get_moms(lam</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">mu))</span>
        <span class="s1">mu</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">lam = </span><span class="s4">0</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">1</span>
        <span class="s1">K = </span><span class="s4">1.0 </span><span class="s1">/ (lam * sig)</span>
        <span class="s1">sts = stats.exponnorm.stats(K</span><span class="s2">, </span><span class="s1">loc=mu</span><span class="s2">, </span><span class="s1">scale=sig</span><span class="s2">, </span><span class="s1">moments=</span><span class="s5">'mvsk'</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(sts</span><span class="s2">, </span><span class="s1">get_moms(lam</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">mu))</span>
        <span class="s1">mu</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">lam = -</span><span class="s4">5</span><span class="s2">, </span><span class="s4">11</span><span class="s2">, </span><span class="s4">3.5</span>
        <span class="s1">K = </span><span class="s4">1.0 </span><span class="s1">/ (lam * sig)</span>
        <span class="s1">sts = stats.exponnorm.stats(K</span><span class="s2">, </span><span class="s1">loc=mu</span><span class="s2">, </span><span class="s1">scale=sig</span><span class="s2">, </span><span class="s1">moments=</span><span class="s5">'mvsk'</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(sts</span><span class="s2">, </span><span class="s1">get_moms(lam</span><span class="s2">, </span><span class="s1">sig</span><span class="s2">, </span><span class="s1">mu))</span>

    <span class="s2">def </span><span class="s1">test_nan_raises_error(self):</span>
        <span class="s3"># see gh-issue 10300</span>
        <span class="s1">x = np.array([</span><span class="s4">1.6483</span><span class="s2">, </span><span class="s4">2.7169</span><span class="s2">, </span><span class="s4">2.4667</span><span class="s2">, </span><span class="s4">1.1791</span><span class="s2">, </span><span class="s4">3.5433</span><span class="s2">, </span><span class="s1">np.nan])</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.exponnorm.fit</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">floc=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">fscale=</span><span class="s4">1</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_inf_raises_error(self):</span>
        <span class="s3"># see gh-issue 10300</span>
        <span class="s1">x = np.array([</span><span class="s4">1.6483</span><span class="s2">, </span><span class="s4">2.7169</span><span class="s2">, </span><span class="s4">2.4667</span><span class="s2">, </span><span class="s4">1.1791</span><span class="s2">, </span><span class="s4">3.5433</span><span class="s2">, </span><span class="s1">np.inf])</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.exponnorm.fit</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">floc=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">fscale=</span><span class="s4">1</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_extremes_x(self):</span>
        <span class="s3"># Test for extreme values against overflows</span>
        <span class="s1">assert_almost_equal(stats.exponnorm.pdf(-</span><span class="s4">900</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(stats.exponnorm.pdf(+</span><span class="s4">900</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(stats.exponnorm.pdf(-</span><span class="s4">900</span><span class="s2">, </span><span class="s4">0.01</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(stats.exponnorm.pdf(+</span><span class="s4">900</span><span class="s2">, </span><span class="s4">0.01</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">)</span>

    <span class="s3"># Expected values for the PDF were computed with mpmath, with</span>
    <span class="s3"># the following function, and with mpmath.mp.dps = 50.</span>
    <span class="s3">#</span>
    <span class="s3">#   def exponnorm_stdpdf(x, K):</span>
    <span class="s3">#       x = mpmath.mpf(x)</span>
    <span class="s3">#       K = mpmath.mpf(K)</span>
    <span class="s3">#       t1 = mpmath.exp(1/(2*K**2) - x/K)</span>
    <span class="s3">#       erfcarg = -(x - 1/K)/mpmath.sqrt(2)</span>
    <span class="s3">#       t2 = mpmath.erfc(erfcarg)</span>
    <span class="s3">#       return t1 * t2 / (2*K)</span>
    <span class="s3">#</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'x, K, expected'</span><span class="s2">,</span>
                             <span class="s1">[(</span><span class="s4">20</span><span class="s2">, </span><span class="s4">0.01</span><span class="s2">, </span><span class="s4">6.90010764753618e-88</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.01</span><span class="s2">, </span><span class="s4">0.24438994313247364</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.01</span><span class="s2">, </span><span class="s4">0.23955149623472075</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(-</span><span class="s4">20</span><span class="s2">, </span><span class="s4">0.01</span><span class="s2">, </span><span class="s4">4.6004708690125477e-88</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">10</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">7.48518298877006e-05</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">10</span><span class="s2">, </span><span class="s4">10000</span><span class="s2">, </span><span class="s4">9.990005048283775e-05</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_std_pdf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">K</span><span class="s2">, </span><span class="s1">expected):</span>
        <span class="s1">assert_allclose(stats.exponnorm.pdf(x</span><span class="s2">, </span><span class="s1">K)</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">5e-12</span><span class="s1">)</span>

    <span class="s3"># Expected values for the CDF were computed with mpmath using</span>
    <span class="s3"># the following function and with mpmath.mp.dps = 60:</span>
    <span class="s3">#</span>
    <span class="s3">#   def mp_exponnorm_cdf(x, K, loc=0, scale=1):</span>
    <span class="s3">#       x = mpmath.mpf(x)</span>
    <span class="s3">#       K = mpmath.mpf(K)</span>
    <span class="s3">#       loc = mpmath.mpf(loc)</span>
    <span class="s3">#       scale = mpmath.mpf(scale)</span>
    <span class="s3">#       z = (x - loc)/scale</span>
    <span class="s3">#       return (mpmath.ncdf(z)</span>
    <span class="s3">#               - mpmath.exp((1/(2*K) - z)/K)*mpmath.ncdf(z - 1/K))</span>
    <span class="s3">#</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'x, K, scale, expected'</span><span class="s2">,</span>
                             <span class="s1">[[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0.01</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.4960109760186432</span><span class="s1">]</span><span class="s2">,</span>
                              <span class="s1">[-</span><span class="s4">5</span><span class="s2">, </span><span class="s4">0.005</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2.7939945412195734e-07</span><span class="s1">]</span><span class="s2">,</span>
                              <span class="s1">[-</span><span class="s4">1e4</span><span class="s2">, </span><span class="s4">0.01</span><span class="s2">, </span><span class="s4">100</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">]</span><span class="s2">,</span>
                              <span class="s1">[-</span><span class="s4">1e4</span><span class="s2">, </span><span class="s4">0.01</span><span class="s2">, </span><span class="s4">1000</span><span class="s2">, </span><span class="s4">6.920401854427357e-24</span><span class="s1">]</span><span class="s2">,</span>
                              <span class="s1">[</span><span class="s4">5</span><span class="s2">, </span><span class="s4">0.001</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.9999997118542392</span><span class="s1">]])</span>
    <span class="s2">def </span><span class="s1">test_cdf_small_K(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">K</span><span class="s2">, </span><span class="s1">scale</span><span class="s2">, </span><span class="s1">expected):</span>
        <span class="s1">p = stats.exponnorm.cdf(x</span><span class="s2">, </span><span class="s1">K</span><span class="s2">, </span><span class="s1">scale=scale)</span>
        <span class="s2">if </span><span class="s1">expected == </span><span class="s4">0.0</span><span class="s1">:</span>
            <span class="s2">assert </span><span class="s1">p == </span><span class="s4">0.0</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">assert_allclose(p</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-13</span><span class="s1">)</span>

    <span class="s3"># Expected values for the SF were computed with mpmath using</span>
    <span class="s3"># the following function and with mpmath.mp.dps = 60:</span>
    <span class="s3">#</span>
    <span class="s3">#   def mp_exponnorm_sf(x, K, loc=0, scale=1):</span>
    <span class="s3">#       x = mpmath.mpf(x)</span>
    <span class="s3">#       K = mpmath.mpf(K)</span>
    <span class="s3">#       loc = mpmath.mpf(loc)</span>
    <span class="s3">#       scale = mpmath.mpf(scale)</span>
    <span class="s3">#       z = (x - loc)/scale</span>
    <span class="s3">#       return (mpmath.ncdf(-z)</span>
    <span class="s3">#               + mpmath.exp((1/(2*K) - z)/K)*mpmath.ncdf(z - 1/K))</span>
    <span class="s3">#</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'x, K, scale, expected'</span><span class="s2">,</span>
                             <span class="s1">[[</span><span class="s4">10</span><span class="s2">, </span><span class="s4">0.01</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">8.474702916146657e-24</span><span class="s1">]</span><span class="s2">,</span>
                              <span class="s1">[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">0.005</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.02302280664231312</span><span class="s1">]</span><span class="s2">,</span>
                              <span class="s1">[</span><span class="s4">5</span><span class="s2">, </span><span class="s4">0.005</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">8.024820681931086e-24</span><span class="s1">]</span><span class="s2">,</span>
                              <span class="s1">[</span><span class="s4">10</span><span class="s2">, </span><span class="s4">0.005</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">3.0603340062892486e-89</span><span class="s1">]</span><span class="s2">,</span>
                              <span class="s1">[</span><span class="s4">20</span><span class="s2">, </span><span class="s4">0.005</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">]</span><span class="s2">,</span>
                              <span class="s1">[-</span><span class="s4">3</span><span class="s2">, </span><span class="s4">0.001</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.9986545205566117</span><span class="s1">]])</span>
    <span class="s2">def </span><span class="s1">test_sf_small_K(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">K</span><span class="s2">, </span><span class="s1">scale</span><span class="s2">, </span><span class="s1">expected):</span>
        <span class="s1">p = stats.exponnorm.sf(x</span><span class="s2">, </span><span class="s1">K</span><span class="s2">, </span><span class="s1">scale=scale)</span>
        <span class="s2">if </span><span class="s1">expected == </span><span class="s4">0.0</span><span class="s1">:</span>
            <span class="s2">assert </span><span class="s1">p == </span><span class="s4">0.0</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">assert_allclose(p</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">5e-13</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestGenExpon:</span>
    <span class="s2">def </span><span class="s1">test_pdf_unity_area(self):</span>
        <span class="s2">from </span><span class="s1">scipy.integrate </span><span class="s2">import </span><span class="s1">simps</span>
        <span class="s3"># PDF should integrate to one</span>
        <span class="s1">p = stats.genexpon.pdf(numpy.arange(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">0.01</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">2.0</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(simps(p</span><span class="s2">, </span><span class="s1">dx=</span><span class="s4">0.01</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_cdf_bounds(self):</span>
        <span class="s3"># CDF should always be positive</span>
        <span class="s1">cdf = stats.genexpon.cdf(numpy.arange(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">0.01</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">2.0</span><span class="s1">)</span>
        <span class="s1">assert_(numpy.all((</span><span class="s4">0 </span><span class="s1">&lt;= cdf) &amp; (cdf &lt;= </span><span class="s4">1</span><span class="s1">)))</span>

    <span class="s3"># The values of p in the following data were computed with mpmath.</span>
    <span class="s3"># E.g. the script</span>
    <span class="s3">#     from mpmath import mp</span>
    <span class="s3">#     mp.dps = 80</span>
    <span class="s3">#     x = mp.mpf('15.0')</span>
    <span class="s3">#     a = mp.mpf('1.0')</span>
    <span class="s3">#     b = mp.mpf('2.0')</span>
    <span class="s3">#     c = mp.mpf('1.5')</span>
    <span class="s3">#     print(float(mp.exp((-a-b)*x + (b/c)*-mp.expm1(-c*x))))</span>
    <span class="s3"># prints</span>
    <span class="s3">#     1.0859444834514553e-19</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'x, p, a, b, c'</span><span class="s2">,</span>
                             <span class="s1">[(</span><span class="s4">15</span><span class="s2">, </span><span class="s4">1.0859444834514553e-19</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1.5</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">0.25</span><span class="s2">, </span><span class="s4">0.7609068232534623</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">0.25</span><span class="s2">, </span><span class="s4">0.09026661397565876</span><span class="s2">, </span><span class="s4">9.5</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">0.01</span><span class="s2">, </span><span class="s4">0.9753038265071597</span><span class="s2">, </span><span class="s4">2.5</span><span class="s2">, </span><span class="s4">0.25</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">3.25</span><span class="s2">, </span><span class="s4">0.0001962824553094492</span><span class="s2">, </span><span class="s4">2.5</span><span class="s2">, </span><span class="s4">0.25</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">0.125</span><span class="s2">, </span><span class="s4">0.9508674287164001</span><span class="s2">, </span><span class="s4">0.25</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_sf_isf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">c):</span>
        <span class="s1">sf = stats.genexpon.sf(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">c)</span>
        <span class="s1">assert_allclose(sf</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-14</span><span class="s1">)</span>
        <span class="s1">isf = stats.genexpon.isf(p</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">c)</span>
        <span class="s1">assert_allclose(isf</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-14</span><span class="s1">)</span>

    <span class="s3"># The values of p in the following data were computed with mpmath.</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'x, p, a, b, c'</span><span class="s2">,</span>
                             <span class="s1">[(</span><span class="s4">0.25</span><span class="s2">, </span><span class="s4">0.2390931767465377</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">0.25</span><span class="s2">, </span><span class="s4">0.9097333860243412</span><span class="s2">, </span><span class="s4">9.5</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">0.01</span><span class="s2">, </span><span class="s4">0.0246961734928403</span><span class="s2">, </span><span class="s4">2.5</span><span class="s2">, </span><span class="s4">0.25</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">3.25</span><span class="s2">, </span><span class="s4">0.9998037175446906</span><span class="s2">, </span><span class="s4">2.5</span><span class="s2">, </span><span class="s4">0.25</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">0.125</span><span class="s2">, </span><span class="s4">0.04913257128359998</span><span class="s2">, </span><span class="s4">0.25</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_cdf_ppf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">c):</span>
        <span class="s1">cdf = stats.genexpon.cdf(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">c)</span>
        <span class="s1">assert_allclose(cdf</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-14</span><span class="s1">)</span>
        <span class="s1">ppf = stats.genexpon.ppf(p</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">c)</span>
        <span class="s1">assert_allclose(ppf</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-14</span><span class="s1">)</span>

<span class="s2">class </span><span class="s1">TestTruncexpon:</span>

    <span class="s2">def </span><span class="s1">test_sf_isf(self):</span>
        <span class="s3"># reference values were computed via the reference distribution, e.g.</span>
        <span class="s3"># mp.dps = 50; TruncExpon(b=b).sf(x)</span>
        <span class="s1">b = [</span><span class="s4">20</span><span class="s2">, </span><span class="s4">100</span><span class="s1">]</span>
        <span class="s1">x = [</span><span class="s4">19.999999</span><span class="s2">, </span><span class="s4">99.999999</span><span class="s1">]</span>
        <span class="s1">ref = [</span><span class="s4">2.0611546593828472e-15</span><span class="s2">, </span><span class="s4">3.7200778266671455e-50</span><span class="s1">]</span>
        <span class="s1">assert_allclose(stats.truncexpon.sf(x</span><span class="s2">, </span><span class="s1">b)</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-10</span><span class="s1">)</span>
        <span class="s1">assert_allclose(stats.truncexpon.isf(ref</span><span class="s2">, </span><span class="s1">b)</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-12</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestExponpow:</span>
    <span class="s2">def </span><span class="s1">test_tail(self):</span>
        <span class="s1">assert_almost_equal(stats.exponpow.cdf(</span><span class="s4">1e-10</span><span class="s2">, </span><span class="s4">2.</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1e-20</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(stats.exponpow.isf(stats.exponpow.sf(</span><span class="s4">5</span><span class="s2">, </span><span class="s4">.8</span><span class="s1">)</span><span class="s2">, </span><span class="s4">.8</span><span class="s1">)</span><span class="s2">,</span>
                            <span class="s4">5</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestSkellam:</span>
    <span class="s2">def </span><span class="s1">test_pmf(self):</span>
        <span class="s3"># comparison to R</span>
        <span class="s1">k = numpy.arange(-</span><span class="s4">10</span><span class="s2">, </span><span class="s4">15</span><span class="s1">)</span>
        <span class="s1">mu1</span><span class="s2">, </span><span class="s1">mu2 = </span><span class="s4">10</span><span class="s2">, </span><span class="s4">5</span>
        <span class="s1">skpmfR = numpy.array(</span>
                   <span class="s1">[</span><span class="s4">4.2254582961926893e-005</span><span class="s2">, </span><span class="s4">1.1404838449648488e-004</span><span class="s2">,</span>
                    <span class="s4">2.8979625801752660e-004</span><span class="s2">, </span><span class="s4">6.9177078182101231e-004</span><span class="s2">,</span>
                    <span class="s4">1.5480716105844708e-003</span><span class="s2">, </span><span class="s4">3.2412274963433889e-003</span><span class="s2">,</span>
                    <span class="s4">6.3373707175123292e-003</span><span class="s2">, </span><span class="s4">1.1552351566696643e-002</span><span class="s2">,</span>
                    <span class="s4">1.9606152375042644e-002</span><span class="s2">, </span><span class="s4">3.0947164083410337e-002</span><span class="s2">,</span>
                    <span class="s4">4.5401737566767360e-002</span><span class="s2">, </span><span class="s4">6.1894328166820688e-002</span><span class="s2">,</span>
                    <span class="s4">7.8424609500170578e-002</span><span class="s2">, </span><span class="s4">9.2418812533573133e-002</span><span class="s2">,</span>
                    <span class="s4">1.0139793148019728e-001</span><span class="s2">, </span><span class="s4">1.0371927988298846e-001</span><span class="s2">,</span>
                    <span class="s4">9.9076583077406091e-002</span><span class="s2">, </span><span class="s4">8.8546660073089561e-002</span><span class="s2">,</span>
                    <span class="s4">7.4187842052486810e-002</span><span class="s2">, </span><span class="s4">5.8392772862200251e-002</span><span class="s2">,</span>
                    <span class="s4">4.3268692953013159e-002</span><span class="s2">, </span><span class="s4">3.0248159818374226e-002</span><span class="s2">,</span>
                    <span class="s4">1.9991434305603021e-002</span><span class="s2">, </span><span class="s4">1.2516877303301180e-002</span><span class="s2">,</span>
                    <span class="s4">7.4389876226229707e-003</span><span class="s1">])</span>

        <span class="s1">assert_almost_equal(stats.skellam.pmf(k</span><span class="s2">, </span><span class="s1">mu1</span><span class="s2">, </span><span class="s1">mu2)</span><span class="s2">, </span><span class="s1">skpmfR</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">15</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_cdf(self):</span>
        <span class="s3"># comparison to R, only 5 decimals</span>
        <span class="s1">k = numpy.arange(-</span><span class="s4">10</span><span class="s2">, </span><span class="s4">15</span><span class="s1">)</span>
        <span class="s1">mu1</span><span class="s2">, </span><span class="s1">mu2 = </span><span class="s4">10</span><span class="s2">, </span><span class="s4">5</span>
        <span class="s1">skcdfR = numpy.array(</span>
                   <span class="s1">[</span><span class="s4">6.4061475386192104e-005</span><span class="s2">, </span><span class="s4">1.7810985988267694e-004</span><span class="s2">,</span>
                    <span class="s4">4.6790611790020336e-004</span><span class="s2">, </span><span class="s4">1.1596768997212152e-003</span><span class="s2">,</span>
                    <span class="s4">2.7077485103056847e-003</span><span class="s2">, </span><span class="s4">5.9489760066490718e-003</span><span class="s2">,</span>
                    <span class="s4">1.2286346724161398e-002</span><span class="s2">, </span><span class="s4">2.3838698290858034e-002</span><span class="s2">,</span>
                    <span class="s4">4.3444850665900668e-002</span><span class="s2">, </span><span class="s4">7.4392014749310995e-002</span><span class="s2">,</span>
                    <span class="s4">1.1979375231607835e-001</span><span class="s2">, </span><span class="s4">1.8168808048289900e-001</span><span class="s2">,</span>
                    <span class="s4">2.6011268998306952e-001</span><span class="s2">, </span><span class="s4">3.5253150251664261e-001</span><span class="s2">,</span>
                    <span class="s4">4.5392943399683988e-001</span><span class="s2">, </span><span class="s4">5.5764871387982828e-001</span><span class="s2">,</span>
                    <span class="s4">6.5672529695723436e-001</span><span class="s2">, </span><span class="s4">7.4527195703032389e-001</span><span class="s2">,</span>
                    <span class="s4">8.1945979908281064e-001</span><span class="s2">, </span><span class="s4">8.7785257194501087e-001</span><span class="s2">,</span>
                    <span class="s4">9.2112126489802404e-001</span><span class="s2">, </span><span class="s4">9.5136942471639818e-001</span><span class="s2">,</span>
                    <span class="s4">9.7136085902200120e-001</span><span class="s2">, </span><span class="s4">9.8387773632530240e-001</span><span class="s2">,</span>
                    <span class="s4">9.9131672394792536e-001</span><span class="s1">])</span>

        <span class="s1">assert_almost_equal(stats.skellam.cdf(k</span><span class="s2">, </span><span class="s1">mu1</span><span class="s2">, </span><span class="s1">mu2)</span><span class="s2">, </span><span class="s1">skcdfR</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">5</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_extreme_mu2(self):</span>
        <span class="s3"># check that crash reported by gh-17916 large mu2 is resolved</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">mu1</span><span class="s2">, </span><span class="s1">mu2 = </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">4820232647677555.0</span>
        <span class="s1">assert_allclose(stats.skellam.pmf(x</span><span class="s2">, </span><span class="s1">mu1</span><span class="s2">, </span><span class="s1">mu2)</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-16</span><span class="s1">)</span>
        <span class="s1">assert_allclose(stats.skellam.cdf(x</span><span class="s2">, </span><span class="s1">mu1</span><span class="s2">, </span><span class="s1">mu2)</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-16</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestLognorm:</span>
    <span class="s2">def </span><span class="s1">test_pdf(self):</span>
        <span class="s3"># Regression test for Ticket #1471: avoid nan with 0/0 situation</span>
        <span class="s3"># Also make sure there are no warnings at x=0, cf gh-5202</span>
        <span class="s2">with </span><span class="s1">warnings.catch_warnings():</span>
            <span class="s1">warnings.simplefilter(</span><span class="s5">'error'</span><span class="s2">, </span><span class="s1">RuntimeWarning)</span>
            <span class="s1">pdf = stats.lognorm.pdf([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">assert_array_almost_equal(pdf</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.62749608</span><span class="s2">, </span><span class="s4">0.39894228</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_logcdf(self):</span>
        <span class="s3"># Regression test for gh-5940: sf et al would underflow too early</span>
        <span class="s1">x2</span><span class="s2">, </span><span class="s1">mu</span><span class="s2">, </span><span class="s1">sigma = </span><span class="s4">201.68</span><span class="s2">, </span><span class="s4">195</span><span class="s2">, </span><span class="s4">0.149</span>
        <span class="s1">assert_allclose(stats.lognorm.sf(x2-mu</span><span class="s2">, </span><span class="s1">s=sigma)</span><span class="s2">,</span>
                        <span class="s1">stats.norm.sf(np.log(x2-mu)/sigma))</span>
        <span class="s1">assert_allclose(stats.lognorm.logsf(x2-mu</span><span class="s2">, </span><span class="s1">s=sigma)</span><span class="s2">,</span>
                        <span class="s1">stats.norm.logsf(np.log(x2-mu)/sigma))</span>

    <span class="s1">@pytest.fixture(scope=</span><span class="s5">'function'</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">rng(self):</span>
        <span class="s2">return </span><span class="s1">np.random.default_rng(</span><span class="s4">1234</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;rvs_shape&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s4">.1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;rvs_loc&quot;</span><span class="s2">, </span><span class="s1">[-</span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;rvs_scale&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s4">.2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">5</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'fix_shape, fix_loc, fix_scale'</span><span class="s2">,</span>
                             <span class="s1">[e </span><span class="s2">for </span><span class="s1">e </span><span class="s2">in </span><span class="s1">product((</span><span class="s2">False, True</span><span class="s1">)</span><span class="s2">, </span><span class="s1">repeat=</span><span class="s4">3</span><span class="s1">)</span>
                              <span class="s2">if False in </span><span class="s1">e])</span>
    <span class="s1">@np.errstate(invalid=</span><span class="s5">&quot;ignore&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_fit_MLE_comp_optimizer(self</span><span class="s2">, </span><span class="s1">rvs_shape</span><span class="s2">, </span><span class="s1">rvs_loc</span><span class="s2">, </span><span class="s1">rvs_scale</span><span class="s2">,</span>
                                    <span class="s1">fix_shape</span><span class="s2">, </span><span class="s1">fix_loc</span><span class="s2">, </span><span class="s1">fix_scale</span><span class="s2">, </span><span class="s1">rng):</span>
        <span class="s1">data = stats.lognorm.rvs(size=</span><span class="s4">100</span><span class="s2">, </span><span class="s1">s=rvs_shape</span><span class="s2">, </span><span class="s1">scale=rvs_scale</span><span class="s2">,</span>
                                 <span class="s1">loc=rvs_loc</span><span class="s2">, </span><span class="s1">random_state=rng)</span>

        <span class="s1">kwds = {}</span>
        <span class="s2">if </span><span class="s1">fix_shape:</span>
            <span class="s1">kwds[</span><span class="s5">'f0'</span><span class="s1">] = rvs_shape</span>
        <span class="s2">if </span><span class="s1">fix_loc:</span>
            <span class="s1">kwds[</span><span class="s5">'floc'</span><span class="s1">] = rvs_loc</span>
        <span class="s2">if </span><span class="s1">fix_scale:</span>
            <span class="s1">kwds[</span><span class="s5">'fscale'</span><span class="s1">] = rvs_scale</span>

        <span class="s1">_assert_less_or_close_loglike(stats.lognorm</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">**kwds)</span>


<span class="s2">class </span><span class="s1">TestBeta:</span>
    <span class="s2">def </span><span class="s1">test_logpdf(self):</span>
        <span class="s3"># Regression test for Ticket #1326: avoid nan with 0*log(0) situation</span>
        <span class="s1">logpdf = stats.beta.logpdf(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(logpdf</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.69314718056</span><span class="s1">)</span>
        <span class="s1">logpdf = stats.beta.logpdf(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(logpdf</span><span class="s2">, </span><span class="s1">np.inf)</span>

    <span class="s2">def </span><span class="s1">test_logpdf_ticket_1866(self):</span>
        <span class="s1">alpha</span><span class="s2">, </span><span class="s1">beta = </span><span class="s4">267</span><span class="s2">, </span><span class="s4">1472</span>
        <span class="s1">x = np.array([</span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.6</span><span class="s1">])</span>
        <span class="s1">b = stats.beta(alpha</span><span class="s2">, </span><span class="s1">beta)</span>
        <span class="s1">assert_allclose(b.logpdf(x).sum()</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1201.699061824062</span><span class="s1">)</span>
        <span class="s1">assert_allclose(b.pdf(x)</span><span class="s2">, </span><span class="s1">np.exp(b.logpdf(x)))</span>

    <span class="s2">def </span><span class="s1">test_fit_bad_keyword_args(self):</span>
        <span class="s1">x = [</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.6</span><span class="s1">]</span>
        <span class="s1">assert_raises(TypeError</span><span class="s2">, </span><span class="s1">stats.beta.fit</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">floc=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">fscale=</span><span class="s4">1</span><span class="s2">,</span>
                      <span class="s1">plate=</span><span class="s5">&quot;shrimp&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_fit_duplicated_fixed_parameter(self):</span>
        <span class="s3"># At most one of 'f0', 'fa' or 'fix_a' can be given to the fit method.</span>
        <span class="s3"># More than one raises a ValueError.</span>
        <span class="s1">x = [</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.6</span><span class="s1">]</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.beta.fit</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">fa=</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">fix_a=</span><span class="s4">0.5</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.skipif(MACOS_INTEL</span><span class="s2">, </span><span class="s1">reason=</span><span class="s5">&quot;Overflow, see gh-14901&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_issue_12635(self):</span>
        <span class="s3"># Confirm that Boost's beta distribution resolves gh-12635.</span>
        <span class="s3"># Check against R:</span>
        <span class="s3"># options(digits=16)</span>
        <span class="s3"># p = 0.9999999999997369</span>
        <span class="s3"># a = 75.0</span>
        <span class="s3"># b = 66334470.0</span>
        <span class="s3"># print(qbeta(p, a, b))</span>
        <span class="s1">p</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b = </span><span class="s4">0.9999999999997369</span><span class="s2">, </span><span class="s4">75.0</span><span class="s2">, </span><span class="s4">66334470.0</span>
        <span class="s1">assert_allclose(stats.beta.ppf(p</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b)</span><span class="s2">, </span><span class="s4">2.343620802982393e-06</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.skipif(MACOS_INTEL</span><span class="s2">, </span><span class="s1">reason=</span><span class="s5">&quot;Overflow, see gh-14901&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_issue_12794(self):</span>
        <span class="s3"># Confirm that Boost's beta distribution resolves gh-12794.</span>
        <span class="s3"># Check against R.</span>
        <span class="s3"># options(digits=16)</span>
        <span class="s3"># p = 1e-11</span>
        <span class="s3"># count_list = c(10,100,1000)</span>
        <span class="s3"># print(qbeta(1-p, count_list + 1, 100000 - count_list))</span>
        <span class="s1">inv_R = np.array([</span><span class="s4">0.0004944464889611935</span><span class="s2">,</span>
                          <span class="s4">0.0018360586912635726</span><span class="s2">,</span>
                          <span class="s4">0.0122663919942518351</span><span class="s1">])</span>
        <span class="s1">count_list = np.array([</span><span class="s4">10</span><span class="s2">, </span><span class="s4">100</span><span class="s2">, </span><span class="s4">1000</span><span class="s1">])</span>
        <span class="s1">p = </span><span class="s4">1e-11</span>
        <span class="s1">inv = stats.beta.isf(p</span><span class="s2">, </span><span class="s1">count_list + </span><span class="s4">1</span><span class="s2">, </span><span class="s4">100000 </span><span class="s1">- count_list)</span>
        <span class="s1">assert_allclose(inv</span><span class="s2">, </span><span class="s1">inv_R)</span>
        <span class="s1">res = stats.beta.sf(inv</span><span class="s2">, </span><span class="s1">count_list + </span><span class="s4">1</span><span class="s2">, </span><span class="s4">100000 </span><span class="s1">- count_list)</span>
        <span class="s1">assert_allclose(res</span><span class="s2">, </span><span class="s1">p)</span>

    <span class="s1">@pytest.mark.skipif(MACOS_INTEL</span><span class="s2">, </span><span class="s1">reason=</span><span class="s5">&quot;Overflow, see gh-14901&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_issue_12796(self):</span>
        <span class="s3"># Confirm that Boost's beta distribution succeeds in the case</span>
        <span class="s3"># of gh-12796</span>
        <span class="s1">alpha_2 = </span><span class="s4">5e-6</span>
        <span class="s1">count_ = np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">20</span><span class="s1">)</span>
        <span class="s1">nobs = </span><span class="s4">100000</span>
        <span class="s1">q</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b = </span><span class="s4">1 </span><span class="s1">- alpha_2</span><span class="s2">, </span><span class="s1">count_ + </span><span class="s4">1</span><span class="s2">, </span><span class="s1">nobs - count_</span>
        <span class="s1">inv = stats.beta.ppf(q</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b)</span>
        <span class="s1">res = stats.beta.cdf(inv</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b)</span>
        <span class="s1">assert_allclose(res</span><span class="s2">, </span><span class="s4">1 </span><span class="s1">- alpha_2)</span>

    <span class="s2">def </span><span class="s1">test_endpoints(self):</span>
        <span class="s3"># Confirm that boost's beta distribution returns inf at x=1</span>
        <span class="s3"># when b&lt;1</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">b = </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.5</span>
        <span class="s1">assert_equal(stats.beta.pdf(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b)</span><span class="s2">, </span><span class="s1">np.inf)</span>

        <span class="s3"># Confirm that boost's beta distribution returns inf at x=0</span>
        <span class="s3"># when a&lt;1</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">b = </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">3</span>
        <span class="s1">assert_equal(stats.beta.pdf(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b)</span><span class="s2">, </span><span class="s1">np.inf)</span>

        <span class="s3"># Confirm that boost's beta distribution returns 5 at x=0</span>
        <span class="s3"># when a=1, b=5</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">b = </span><span class="s4">1</span><span class="s2">, </span><span class="s4">5</span>
        <span class="s1">assert_equal(stats.beta.pdf(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b)</span><span class="s2">, </span><span class="s4">5</span><span class="s1">)</span>
        <span class="s1">assert_equal(stats.beta.pdf(</span><span class="s4">1e-310</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b)</span><span class="s2">, </span><span class="s4">5</span><span class="s1">)</span>

        <span class="s3"># Confirm that boost's beta distribution returns 5 at x=1</span>
        <span class="s3"># when a=5, b=1</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">b = </span><span class="s4">5</span><span class="s2">, </span><span class="s4">1</span>
        <span class="s1">assert_equal(stats.beta.pdf(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b)</span><span class="s2">, </span><span class="s4">5</span><span class="s1">)</span>
        <span class="s1">assert_equal(stats.beta.pdf(</span><span class="s4">1</span><span class="s1">-</span><span class="s4">1e-310</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b)</span><span class="s2">, </span><span class="s4">5</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.xfail(IS_PYPY</span><span class="s2">, </span><span class="s1">reason=</span><span class="s5">&quot;Does not convert boost warning&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_boost_eval_issue_14606(self):</span>
        <span class="s1">q</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b = </span><span class="s4">0.995</span><span class="s2">, </span><span class="s4">1.0e11</span><span class="s2">, </span><span class="s4">1.0e13</span>
        <span class="s2">with </span><span class="s1">pytest.warns(RuntimeWarning):</span>
            <span class="s1">stats.beta.ppf(q</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'method'</span><span class="s2">, </span><span class="s1">[stats.beta.ppf</span><span class="s2">, </span><span class="s1">stats.beta.isf])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'a, b'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">1e-310</span><span class="s2">, </span><span class="s4">12.5</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">12.5</span><span class="s2">, </span><span class="s4">1e-310</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_beta_ppf_with_subnormal_a_b(self</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b):</span>
        <span class="s3"># Regression test for gh-17444: beta.ppf(p, a, b) and beta.isf(p, a, b)</span>
        <span class="s3"># would result in a segmentation fault if either a or b was subnormal.</span>
        <span class="s1">p = </span><span class="s4">0.9</span>
        <span class="s3"># Depending on the version of Boost that we have vendored and</span>
        <span class="s3"># our setting of the Boost double promotion policy, the call</span>
        <span class="s3"># `stats.beta.ppf(p, a, b)` might raise an OverflowError or</span>
        <span class="s3"># return a value.  We'll accept either behavior (and not care about</span>
        <span class="s3"># the value), because our goal here is to verify that the call does</span>
        <span class="s3"># not trigger a segmentation fault.</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">method(p</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b)</span>
        <span class="s2">except </span><span class="s1">OverflowError:</span>
            <span class="s3"># The OverflowError exception occurs with Boost 1.80 or earlier</span>
            <span class="s3"># when Boost's double promotion policy is false; see</span>
            <span class="s3">#   https://github.com/boostorg/math/issues/882</span>
            <span class="s3"># and</span>
            <span class="s3">#   https://github.com/boostorg/math/pull/883</span>
            <span class="s3"># Once we have vendored the fixed version of Boost, we can drop</span>
            <span class="s3"># this try-except wrapper and just call the function.</span>
            <span class="s2">pass</span>

    <span class="s3"># entropy accuracy was confirmed using the following mpmath function</span>
    <span class="s3"># from mpmath import mp</span>
    <span class="s3"># mp.dps = 50</span>
    <span class="s3"># def beta_entropy_mpmath(a, b):</span>
    <span class="s3">#     a = mp.mpf(a)</span>
    <span class="s3">#     b = mp.mpf(b)</span>
    <span class="s3">#     entropy = mp.log(mp.beta(a, b)) - (a - 1) * mp.digamma(a) -\</span>
    <span class="s3">#              (b - 1) * mp.digamma(b) + (a + b -2) * mp.digamma(a + b)</span>
    <span class="s3">#     return float(entropy)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'a, b, ref'</span><span class="s2">,</span>
                             <span class="s1">[(</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.24156447527049044</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">0.001</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">992.0922447210179</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">10000</span><span class="s2">, </span><span class="s1">-</span><span class="s4">8.210440371976183</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">100000</span><span class="s2">, </span><span class="s4">100000</span><span class="s2">, </span><span class="s1">-</span><span class="s4">5.377247470132859</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_entropy(self</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">ref):</span>
        <span class="s1">assert_allclose(stats.beta(a</span><span class="s2">, </span><span class="s1">b).entropy()</span><span class="s2">, </span><span class="s1">ref)</span>


<span class="s2">class </span><span class="s1">TestBetaPrime:</span>
    <span class="s3"># the test values are used in test_cdf_gh_17631 / test_ppf_gh_17631</span>
    <span class="s3"># They are computed with mpmath. Example:</span>
    <span class="s3"># from mpmath import mp</span>
    <span class="s3"># mp.dps = 50</span>
    <span class="s3"># a, b = mp.mpf(0.05), mp.mpf(0.1)</span>
    <span class="s3"># x = mp.mpf(1e22)</span>
    <span class="s3"># float(mp.betainc(a, b, 0.0, x/(1+x), regularized=True))</span>
    <span class="s3"># note: we use the values computed by the cdf to test whether</span>
    <span class="s3"># ppf(cdf(x)) == x (up to a small tolerance)</span>
    <span class="s3"># since the ppf can be very sensitive to small variations of the input,</span>
    <span class="s3"># it can be required to generate the test case for the ppf separately,</span>
    <span class="s3"># see self.test_ppf</span>
    <span class="s1">cdf_vals = [</span>
        <span class="s1">(</span><span class="s4">1e22</span><span class="s2">, </span><span class="s4">100.0</span><span class="s2">, </span><span class="s4">0.05</span><span class="s2">, </span><span class="s4">0.8973027435427167</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">1e10</span><span class="s2">, </span><span class="s4">100.0</span><span class="s2">, </span><span class="s4">0.05</span><span class="s2">, </span><span class="s4">0.5911548582766262</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">1e8</span><span class="s2">, </span><span class="s4">0.05</span><span class="s2">, </span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.9467768090820048</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">1e8</span><span class="s2">, </span><span class="s4">100.0</span><span class="s2">, </span><span class="s4">0.05</span><span class="s2">, </span><span class="s4">0.4852944858726726</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">1e-10</span><span class="s2">, </span><span class="s4">0.05</span><span class="s2">, </span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.21238845427095</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">1e-10</span><span class="s2">, </span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">1.697652726007973e-15</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">1e-10</span><span class="s2">, </span><span class="s4">0.05</span><span class="s2">, </span><span class="s4">100.0</span><span class="s2">, </span><span class="s4">0.40884514172337383</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">1e-22</span><span class="s2">, </span><span class="s4">0.05</span><span class="s2">, </span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.053349567649287326</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">1e-22</span><span class="s2">, </span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">1.6976527263135503e-33</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">1e-22</span><span class="s2">, </span><span class="s4">0.05</span><span class="s2">, </span><span class="s4">100.0</span><span class="s2">, </span><span class="s4">0.10269725645728331</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">1e-100</span><span class="s2">, </span><span class="s4">0.05</span><span class="s2">, </span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">6.7163126421919795e-06</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">1e-100</span><span class="s2">, </span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">1.6976527263135503e-150</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">1e-100</span><span class="s2">, </span><span class="s4">0.05</span><span class="s2">, </span><span class="s4">100.0</span><span class="s2">, </span><span class="s4">1.2928818587561651e-05</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">]</span>

    <span class="s2">def </span><span class="s1">test_logpdf(self):</span>
        <span class="s1">alpha</span><span class="s2">, </span><span class="s1">beta = </span><span class="s4">267</span><span class="s2">, </span><span class="s4">1472</span>
        <span class="s1">x = np.array([</span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.6</span><span class="s1">])</span>
        <span class="s1">b = stats.betaprime(alpha</span><span class="s2">, </span><span class="s1">beta)</span>
        <span class="s1">assert_(np.isfinite(b.logpdf(x)).all())</span>
        <span class="s1">assert_allclose(b.pdf(x)</span><span class="s2">, </span><span class="s1">np.exp(b.logpdf(x)))</span>

    <span class="s2">def </span><span class="s1">test_cdf(self):</span>
        <span class="s3"># regression test for gh-4030: Implementation of</span>
        <span class="s3"># scipy.stats.betaprime.cdf()</span>
        <span class="s1">x = stats.betaprime.cdf(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">0.3</span><span class="s1">)</span>
        <span class="s1">assert_equal(x</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">)</span>

        <span class="s1">alpha</span><span class="s2">, </span><span class="s1">beta = </span><span class="s4">267</span><span class="s2">, </span><span class="s4">1472</span>
        <span class="s1">x = np.array([</span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.6</span><span class="s1">])</span>
        <span class="s1">cdfs = stats.betaprime.cdf(x</span><span class="s2">, </span><span class="s1">alpha</span><span class="s2">, </span><span class="s1">beta)</span>
        <span class="s1">assert_(np.isfinite(cdfs).all())</span>

        <span class="s3"># check the new cdf implementation vs generic one:</span>
        <span class="s1">gen_cdf = stats.rv_continuous._cdf_single</span>
        <span class="s1">cdfs_g = [gen_cdf(stats.betaprime</span><span class="s2">, </span><span class="s1">val</span><span class="s2">, </span><span class="s1">alpha</span><span class="s2">, </span><span class="s1">beta) </span><span class="s2">for </span><span class="s1">val </span><span class="s2">in </span><span class="s1">x]</span>
        <span class="s1">assert_allclose(cdfs</span><span class="s2">, </span><span class="s1">cdfs_g</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">2e-12</span><span class="s1">)</span>

    <span class="s3"># The expected values for test_ppf() were computed with mpmath, e.g.</span>
    <span class="s3">#</span>
    <span class="s3">#   from mpmath import mp</span>
    <span class="s3">#   mp.dps = 125</span>
    <span class="s3">#   p = 0.01</span>
    <span class="s3">#   a, b = 1.25, 2.5</span>
    <span class="s3">#   x = mp.findroot(lambda t: mp.betainc(a, b, x1=0, x2=t/(1+t),</span>
    <span class="s3">#                                        regularized=True) - p,</span>
    <span class="s3">#                   x0=(0.01, 0.011), method='secant')</span>
    <span class="s3">#   print(float(x))</span>
    <span class="s3">#</span>
    <span class="s3"># prints</span>
    <span class="s3">#</span>
    <span class="s3">#   0.01080162700956614</span>
    <span class="s3">#</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s5">'p, a, b, expected'</span><span class="s2">,</span>
        <span class="s1">[(</span><span class="s4">0.010</span><span class="s2">, </span><span class="s4">1.25</span><span class="s2">, </span><span class="s4">2.5</span><span class="s2">, </span><span class="s4">0.01080162700956614</span><span class="s1">)</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">1e-12</span><span class="s2">, </span><span class="s4">1.25</span><span class="s2">, </span><span class="s4">2.5</span><span class="s2">, </span><span class="s4">1.0610141996279122e-10</span><span class="s1">)</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">1e-18</span><span class="s2">, </span><span class="s4">1.25</span><span class="s2">, </span><span class="s4">2.5</span><span class="s2">, </span><span class="s4">1.6815941817974941e-15</span><span class="s1">)</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">1e-17</span><span class="s2">, </span><span class="s4">0.25</span><span class="s2">, </span><span class="s4">7.0</span><span class="s2">, </span><span class="s4">1.0179194531881782e-69</span><span class="s1">)</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">0.375</span><span class="s2">, </span><span class="s4">0.25</span><span class="s2">, </span><span class="s4">7.0</span><span class="s2">, </span><span class="s4">0.002036820346115211</span><span class="s1">)</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">0.9978811466052919</span><span class="s2">, </span><span class="s4">0.05</span><span class="s2">, </span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">1.0000000000001218e22</span><span class="s1">)</span><span class="s2">,</span><span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_ppf(self</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">expected):</span>
        <span class="s1">x = stats.betaprime.ppf(p</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b)</span>
        <span class="s1">assert_allclose(x</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-14</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'x, a, b, p'</span><span class="s2">, </span><span class="s1">cdf_vals)</span>
    <span class="s2">def </span><span class="s1">test_ppf_gh_17631(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">p):</span>
        <span class="s1">assert_allclose(stats.betaprime.ppf(p</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b)</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-14</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s5">'x, a, b, expected'</span><span class="s2">,</span>
        <span class="s1">cdf_vals + [</span>
            <span class="s1">(</span><span class="s4">1e10</span><span class="s2">, </span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">0.9999999999999983</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s4">1e10</span><span class="s2">, </span><span class="s4">0.05</span><span class="s2">, </span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.9664184367890859</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s4">1e22</span><span class="s2">, </span><span class="s4">0.05</span><span class="s2">, </span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.9978811466052919</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_cdf_gh_17631(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">expected):</span>
        <span class="s1">assert_allclose(stats.betaprime.cdf(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b)</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-14</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s5">'x, a, b, expected'</span><span class="s2">,</span>
        <span class="s1">[(</span><span class="s4">1e50</span><span class="s2">, </span><span class="s4">0.05</span><span class="s2">, </span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.9999966641709545</span><span class="s1">)</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">1e50</span><span class="s2">, </span><span class="s4">100.0</span><span class="s2">, </span><span class="s4">0.05</span><span class="s2">, </span><span class="s4">0.995925162631006</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_cdf_extreme_tails(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">expected):</span>
        <span class="s3"># for even more extreme values, we only get a few correct digits</span>
        <span class="s3"># results are still &lt; 1</span>
        <span class="s1">y = stats.betaprime.cdf(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b)</span>
        <span class="s2">assert </span><span class="s1">y &lt; </span><span class="s4">1.0</span>
        <span class="s1">assert_allclose(y</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">2e-5</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_sf(self):</span>
        <span class="s3"># reference values were computed via the reference distribution,</span>
        <span class="s3"># e.g.</span>
        <span class="s3"># mp.dps = 50</span>
        <span class="s3"># a, b = 5, 3</span>
        <span class="s3"># x = 1e10</span>
        <span class="s3"># BetaPrime(a=a, b=b).sf(x); returns 3.4999999979e-29</span>
        <span class="s1">a = [</span><span class="s4">5</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">0.05</span><span class="s2">, </span><span class="s4">0.05</span><span class="s2">, </span><span class="s4">0.05</span><span class="s2">, </span><span class="s4">0.05</span><span class="s2">, </span><span class="s4">100.0</span><span class="s2">, </span><span class="s4">100.0</span><span class="s2">, </span><span class="s4">0.05</span><span class="s2">, </span><span class="s4">0.05</span><span class="s2">,</span>
             <span class="s4">0.05</span><span class="s2">, </span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">1.5</span><span class="s1">]</span>
        <span class="s1">b = [</span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.05</span><span class="s2">, </span><span class="s4">0.05</span><span class="s2">, </span><span class="s4">100.0</span><span class="s2">, </span><span class="s4">100.0</span><span class="s2">,</span>
             <span class="s4">100.0</span><span class="s2">, </span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">1.5</span><span class="s1">]</span>
        <span class="s1">x = [</span><span class="s4">1e10</span><span class="s2">, </span><span class="s4">1e20</span><span class="s2">, </span><span class="s4">1e30</span><span class="s2">, </span><span class="s4">1e22</span><span class="s2">, </span><span class="s4">1e-10</span><span class="s2">, </span><span class="s4">1e-22</span><span class="s2">, </span><span class="s4">1e-100</span><span class="s2">, </span><span class="s4">1e22</span><span class="s2">, </span><span class="s4">1e10</span><span class="s2">,</span>
             <span class="s4">1e-10</span><span class="s2">, </span><span class="s4">1e-22</span><span class="s2">, </span><span class="s4">1e-100</span><span class="s2">, </span><span class="s4">1e10</span><span class="s2">, </span><span class="s4">1e-10</span><span class="s1">]</span>
        <span class="s1">ref = [</span><span class="s4">3.4999999979e-29</span><span class="s2">, </span><span class="s4">9.999999999994357e-40</span><span class="s2">, </span><span class="s4">1.9999999999999998e-30</span><span class="s2">,</span>
               <span class="s4">0.0021188533947081017</span><span class="s2">, </span><span class="s4">0.78761154572905</span><span class="s2">, </span><span class="s4">0.9466504323507127</span><span class="s2">,</span>
               <span class="s4">0.9999932836873578</span><span class="s2">, </span><span class="s4">0.10269725645728331</span><span class="s2">, </span><span class="s4">0.40884514172337383</span><span class="s2">,</span>
               <span class="s4">0.5911548582766262</span><span class="s2">, </span><span class="s4">0.8973027435427167</span><span class="s2">, </span><span class="s4">0.9999870711814124</span><span class="s2">,</span>
               <span class="s4">1.6976527260079727e-15</span><span class="s2">, </span><span class="s4">0.9999999999999983</span><span class="s1">]</span>
        <span class="s1">sf_values = stats.betaprime.sf(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b)</span>
        <span class="s1">assert_allclose(sf_values</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-12</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_fit_stats_gh18274(self):</span>
        <span class="s3"># gh-18274 reported spurious warning emitted when fitting `betaprime`</span>
        <span class="s3"># to data. Some of these were emitted by stats, too. Check that the</span>
        <span class="s3"># warnings are no longer emitted.</span>
        <span class="s1">stats.betaprime.fit([</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.25</span><span class="s2">, </span><span class="s4">0.3</span><span class="s2">, </span><span class="s4">1.2</span><span class="s2">, </span><span class="s4">1.6</span><span class="s1">]</span><span class="s2">, </span><span class="s1">floc=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">fscale=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">stats.betaprime(a=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">b=</span><span class="s4">1</span><span class="s1">).stats(</span><span class="s5">'mvsk'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_moment_gh18634(self):</span>
        <span class="s3"># Testing for gh-18634 revealed that `betaprime` raised a</span>
        <span class="s3"># NotImplementedError for higher moments. Check that this is</span>
        <span class="s3"># resolved. Parameters are arbitrary but lie on either side of the</span>
        <span class="s3"># moment order (5) to test both branches of `_lazywhere`. Reference</span>
        <span class="s3"># values produced with Mathematica, e.g.</span>
        <span class="s3"># `Moment[BetaPrimeDistribution[2,7],5]`</span>
        <span class="s1">ref = [np.inf</span><span class="s2">, </span><span class="s4">0.867096912929055</span><span class="s1">]</span>
        <span class="s1">res = stats.betaprime(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">[</span><span class="s4">4.2</span><span class="s2">, </span><span class="s4">7.1</span><span class="s1">]).moment(</span><span class="s4">5</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res</span><span class="s2">, </span><span class="s1">ref)</span>


<span class="s2">class </span><span class="s1">TestGamma:</span>
    <span class="s2">def </span><span class="s1">test_pdf(self):</span>
        <span class="s3"># a few test cases to compare with R</span>
        <span class="s1">pdf = stats.gamma.pdf(</span><span class="s4">90</span><span class="s2">, </span><span class="s4">394</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">1.</span><span class="s1">/</span><span class="s4">5</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(pdf</span><span class="s2">, </span><span class="s4">0.002312341</span><span class="s1">)</span>

        <span class="s1">pdf = stats.gamma.pdf(</span><span class="s4">3</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">1.</span><span class="s1">/</span><span class="s4">5</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(pdf</span><span class="s2">, </span><span class="s4">0.1620358</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_logpdf(self):</span>
        <span class="s3"># Regression test for Ticket #1326: cornercase avoid nan with 0*log(0)</span>
        <span class="s3"># situation</span>
        <span class="s1">logpdf = stats.gamma.logpdf(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(logpdf</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_fit_bad_keyword_args(self):</span>
        <span class="s1">x = [</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.6</span><span class="s1">]</span>
        <span class="s1">assert_raises(TypeError</span><span class="s2">, </span><span class="s1">stats.gamma.fit</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">floc=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">plate=</span><span class="s5">&quot;shrimp&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_isf(self):</span>
        <span class="s3"># Test cases for when the probability is very small. See gh-13664.</span>
        <span class="s3"># The expected values can be checked with mpmath.  With mpmath,</span>
        <span class="s3"># the survival function sf(x, k) can be computed as</span>
        <span class="s3">#</span>
        <span class="s3">#     mpmath.gammainc(k, x, mpmath.inf, regularized=True)</span>
        <span class="s3">#</span>
        <span class="s3"># Here we have:</span>
        <span class="s3">#</span>
        <span class="s3"># &gt;&gt;&gt; mpmath.mp.dps = 60</span>
        <span class="s3"># &gt;&gt;&gt; float(mpmath.gammainc(1, 39.14394658089878, mpmath.inf,</span>
        <span class="s3"># ...                       regularized=True))</span>
        <span class="s3"># 9.99999999999999e-18</span>
        <span class="s3"># &gt;&gt;&gt; float(mpmath.gammainc(100, 330.6557590436547, mpmath.inf,</span>
        <span class="s3">#                           regularized=True))</span>
        <span class="s3"># 1.000000000000028e-50</span>
        <span class="s3">#</span>
        <span class="s2">assert </span><span class="s1">np.isclose(stats.gamma.isf(</span><span class="s4">1e-17</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s4">39.14394658089878</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-14</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">np.isclose(stats.gamma.isf(</span><span class="s4">1e-50</span><span class="s2">, </span><span class="s4">100</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s4">330.6557590436547</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-13</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'scale'</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">5.0</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_delta_cdf(self</span><span class="s2">, </span><span class="s1">scale):</span>
        <span class="s3"># Expected value computed with mpmath:</span>
        <span class="s3">#</span>
        <span class="s3"># &gt;&gt;&gt; import mpmath</span>
        <span class="s3"># &gt;&gt;&gt; mpmath.mp.dps = 150</span>
        <span class="s3"># &gt;&gt;&gt; cdf1 = mpmath.gammainc(3, 0, 245, regularized=True)</span>
        <span class="s3"># &gt;&gt;&gt; cdf2 = mpmath.gammainc(3, 0, 250, regularized=True)</span>
        <span class="s3"># &gt;&gt;&gt; float(cdf2 - cdf1)</span>
        <span class="s3"># 1.1902609356171962e-102</span>
        <span class="s3">#</span>
        <span class="s1">delta = stats.gamma._delta_cdf(scale*</span><span class="s4">245</span><span class="s2">, </span><span class="s1">scale*</span><span class="s4">250</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s1">scale=scale)</span>
        <span class="s1">assert_allclose(delta</span><span class="s2">, </span><span class="s4">1.1902609356171962e-102</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-13</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'a, ref, rtol'</span><span class="s2">,</span>
                             <span class="s1">[(</span><span class="s4">1e-4</span><span class="s2">, </span><span class="s1">-</span><span class="s4">9990.366610819761</span><span class="s2">, </span><span class="s4">1e-15</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">1.5772156649015328</span><span class="s2">, </span><span class="s4">1e-15</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">100</span><span class="s2">, </span><span class="s4">3.7181819485047463</span><span class="s2">, </span><span class="s4">1e-13</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">1e4</span><span class="s2">, </span><span class="s4">6.024075385026086</span><span class="s2">, </span><span class="s4">1e-15</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">1e18</span><span class="s2">, </span><span class="s4">22.142204370151084</span><span class="s2">, </span><span class="s4">1e-15</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">1e100</span><span class="s2">, </span><span class="s4">116.54819318290696</span><span class="s2">, </span><span class="s4">1e-15</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_entropy(self</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">rtol):</span>
        <span class="s3"># expected value computed with mpmath:</span>
        <span class="s3"># from mpmath import mp</span>
        <span class="s3"># mp.dps = 500</span>
        <span class="s3"># def gamma_entropy_reference(x):</span>
        <span class="s3">#     x = mp.mpf(x)</span>
        <span class="s3">#     return float(mp.digamma(x) * (mp.one - x) + x + mp.loggamma(x))</span>

        <span class="s1">assert_allclose(stats.gamma.entropy(a)</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">rtol=rtol)</span>


<span class="s2">class </span><span class="s1">TestDgamma:</span>
    <span class="s2">def </span><span class="s1">test_pdf(self):</span>
        <span class="s1">rng = np.random.default_rng(</span><span class="s4">3791303244302340058</span><span class="s1">)</span>
        <span class="s1">size = </span><span class="s4">10  </span><span class="s3"># number of points to check</span>
        <span class="s1">x = rng.normal(scale=</span><span class="s4">10</span><span class="s2">, </span><span class="s1">size=size)</span>
        <span class="s1">a = rng.uniform(high=</span><span class="s4">10</span><span class="s2">, </span><span class="s1">size=size)</span>
        <span class="s1">res = stats.dgamma.pdf(x</span><span class="s2">, </span><span class="s1">a)</span>
        <span class="s1">ref = stats.gamma.pdf(np.abs(x)</span><span class="s2">, </span><span class="s1">a) / </span><span class="s4">2</span>
        <span class="s1">assert_allclose(res</span><span class="s2">, </span><span class="s1">ref)</span>

        <span class="s1">dist = stats.dgamma(a)</span>
        <span class="s1">assert_equal(dist.pdf(x)</span><span class="s2">, </span><span class="s1">res)</span>

    <span class="s3"># mpmath was used to compute the expected values.</span>
    <span class="s3"># For x &lt; 0, cdf(x, a) is mp.gammainc(a, -x, mp.inf, regularized=True)/2</span>
    <span class="s3"># For x &gt; 0, cdf(x, a) is (1 + mp.gammainc(a, 0, x, regularized=True))/2</span>
    <span class="s3"># E.g.</span>
    <span class="s3">#    from mpmath import mp</span>
    <span class="s3">#    mp.dps = 50</span>
    <span class="s3">#    print(float(mp.gammainc(1, 20, mp.inf, regularized=True)/2))</span>
    <span class="s3"># prints</span>
    <span class="s3">#    1.030576811219279e-09</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'x, a, expected'</span><span class="s2">,</span>
                             <span class="s1">[(-</span><span class="s4">20</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1.030576811219279e-09</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(-</span><span class="s4">40</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2.1241771276457944e-18</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(-</span><span class="s4">50</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">2.7248509914602648e-17</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(-</span><span class="s4">25</span><span class="s2">, </span><span class="s4">0.125</span><span class="s2">, </span><span class="s4">5.333071920958156e-14</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">5</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.9966310265004573</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_cdf_ppf_sf_isf_tail(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">expected):</span>
        <span class="s1">cdf = stats.dgamma.cdf(x</span><span class="s2">, </span><span class="s1">a)</span>
        <span class="s1">assert_allclose(cdf</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">5e-15</span><span class="s1">)</span>
        <span class="s1">ppf = stats.dgamma.ppf(expected</span><span class="s2">, </span><span class="s1">a)</span>
        <span class="s1">assert_allclose(ppf</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">5e-15</span><span class="s1">)</span>
        <span class="s1">sf = stats.dgamma.sf(-x</span><span class="s2">, </span><span class="s1">a)</span>
        <span class="s1">assert_allclose(sf</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">5e-15</span><span class="s1">)</span>
        <span class="s1">isf = stats.dgamma.isf(expected</span><span class="s2">, </span><span class="s1">a)</span>
        <span class="s1">assert_allclose(isf</span><span class="s2">, </span><span class="s1">-x</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">5e-15</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;a, ref&quot;</span><span class="s2">,</span>
                             <span class="s1">[(</span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">2.0541199559354117</span><span class="s1">)</span><span class="s2">,</span>
                             <span class="s1">(</span><span class="s4">1.3</span><span class="s2">, </span><span class="s4">1.9357296377121247</span><span class="s1">)</span><span class="s2">,</span>
                             <span class="s1">(</span><span class="s4">1.1</span><span class="s2">, </span><span class="s4">1.7856502333412134</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_entropy(self</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">ref):</span>
        <span class="s3"># The reference values were calculated with mpmath:</span>
        <span class="s3"># def entropy_dgamma(a):</span>
        <span class="s3">#    def pdf(x):</span>
        <span class="s3">#        A = mp.one / (mp.mpf(2.) * mp.gamma(a))</span>
        <span class="s3">#        B = mp.fabs(x) ** (a - mp.one)</span>
        <span class="s3">#        C = mp.exp(-mp.fabs(x))</span>
        <span class="s3">#        h = A * B * C</span>
        <span class="s3">#        return h</span>
        <span class="s3">#</span>
        <span class="s3">#    return -mp.quad(lambda t: pdf(t) * mp.log(pdf(t)),</span>
        <span class="s3">#                    [-mp.inf, mp.inf])</span>
        <span class="s1">assert_allclose(stats.dgamma.entropy(a)</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-14</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;a, ref&quot;</span><span class="s2">,</span>
                             <span class="s1">[(</span><span class="s4">1e-100</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1e+100</span><span class="s1">)</span><span class="s2">,</span>
                             <span class="s1">(</span><span class="s4">1e-10</span><span class="s2">, </span><span class="s1">-</span><span class="s4">9999999975.858217</span><span class="s1">)</span><span class="s2">,</span>
                             <span class="s1">(</span><span class="s4">1e-5</span><span class="s2">, </span><span class="s1">-</span><span class="s4">99987.37111657023</span><span class="s1">)</span><span class="s2">,</span>
                             <span class="s1">(</span><span class="s4">1e4</span><span class="s2">, </span><span class="s4">6.717222565586032</span><span class="s1">)</span><span class="s2">,</span>
                             <span class="s1">(</span><span class="s4">1000000000000000.0</span><span class="s2">, </span><span class="s4">19.38147391121996</span><span class="s1">)</span><span class="s2">,</span>
                             <span class="s1">(</span><span class="s4">1e+100</span><span class="s2">, </span><span class="s4">117.2413403634669</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_entropy_entreme_values(self</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">ref):</span>
        <span class="s3"># The reference values were calculated with mpmath:</span>
        <span class="s3"># from mpmath import mp</span>
        <span class="s3"># mp.dps = 500</span>
        <span class="s3"># def second_dgamma(a):</span>
        <span class="s3">#     a = mp.mpf(a)</span>
        <span class="s3">#     x_1 = a + mp.log(2) + mp.loggamma(a)</span>
        <span class="s3">#     x_2 = (mp.one - a) * mp.digamma(a)</span>
        <span class="s3">#     h = x_1 + x_2</span>
        <span class="s3">#     return h</span>
        <span class="s1">assert_allclose(stats.dgamma.entropy(a)</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-10</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_entropy_array_input(self):</span>
        <span class="s1">x = np.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">1e20</span><span class="s2">, </span><span class="s4">1e-5</span><span class="s1">])</span>
        <span class="s1">y = stats.dgamma.entropy(x)</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(y)):</span>
            <span class="s2">assert </span><span class="s1">y[i] == stats.dgamma.entropy(x[i])</span>


<span class="s2">class </span><span class="s1">TestChi2:</span>
    <span class="s3"># regression tests after precision improvements, ticket:1041, not verified</span>
    <span class="s2">def </span><span class="s1">test_precision(self):</span>
        <span class="s1">assert_almost_equal(stats.chi2.pdf(</span><span class="s4">1000</span><span class="s2">, </span><span class="s4">1000</span><span class="s1">)</span><span class="s2">, </span><span class="s4">8.919133934753128e-003</span><span class="s2">,</span>
                            <span class="s1">decimal=</span><span class="s4">14</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(stats.chi2.pdf(</span><span class="s4">100</span><span class="s2">, </span><span class="s4">100</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0.028162503162596778</span><span class="s2">,</span>
                            <span class="s1">decimal=</span><span class="s4">14</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_ppf(self):</span>
        <span class="s3"># Expected values computed with mpmath.</span>
        <span class="s1">df = </span><span class="s4">4.8</span>
        <span class="s1">x = stats.chi2.ppf(</span><span class="s4">2e-47</span><span class="s2">, </span><span class="s1">df)</span>
        <span class="s1">assert_allclose(x</span><span class="s2">, </span><span class="s4">1.098472479575179840604902808e-19</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-10</span><span class="s1">)</span>
        <span class="s1">x = stats.chi2.ppf(</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">df)</span>
        <span class="s1">assert_allclose(x</span><span class="s2">, </span><span class="s4">4.15231407598589358660093156</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-10</span><span class="s1">)</span>

        <span class="s1">df = </span><span class="s4">13</span>
        <span class="s1">x = stats.chi2.ppf(</span><span class="s4">2e-77</span><span class="s2">, </span><span class="s1">df)</span>
        <span class="s1">assert_allclose(x</span><span class="s2">, </span><span class="s4">1.0106330688195199050507943e-11</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-10</span><span class="s1">)</span>
        <span class="s1">x = stats.chi2.ppf(</span><span class="s4">0.1</span><span class="s2">, </span><span class="s1">df)</span>
        <span class="s1">assert_allclose(x</span><span class="s2">, </span><span class="s4">7.041504580095461859307179763</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-10</span><span class="s1">)</span>

    <span class="s3"># Entropy references values were computed with the following mpmath code</span>
    <span class="s3"># from mpmath import mp</span>
    <span class="s3"># mp.dps = 50</span>
    <span class="s3"># def chisq_entropy_mpmath(df):</span>
    <span class="s3">#     df = mp.mpf(df)</span>
    <span class="s3">#     half_df = 0.5 * df</span>
    <span class="s3">#     entropy = (half_df + mp.log(2) + mp.log(mp.gamma(half_df)) +</span>
    <span class="s3">#                (mp.one - half_df) * mp.digamma(half_df))</span>
    <span class="s3">#     return float(entropy)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'df, ref'</span><span class="s2">,</span>
                             <span class="s1">[(</span><span class="s4">1e-4</span><span class="s2">, </span><span class="s1">-</span><span class="s4">19988.980448690163</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.7837571104739337</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">100</span><span class="s2">, </span><span class="s4">4.061397128938114</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">251</span><span class="s2">, </span><span class="s4">4.525577254045129</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">1e15</span><span class="s2">, </span><span class="s4">19.034900320939986</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_entropy(self</span><span class="s2">, </span><span class="s1">df</span><span class="s2">, </span><span class="s1">ref):</span>
        <span class="s1">assert_allclose(stats.chi2(df).entropy()</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-13</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestGumbelL:</span>
    <span class="s3"># gh-6228</span>
    <span class="s2">def </span><span class="s1">test_cdf_ppf(self):</span>
        <span class="s1">x = np.linspace(-</span><span class="s4">100</span><span class="s2">, </span><span class="s1">-</span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">y = stats.gumbel_l.cdf(x)</span>
        <span class="s1">xx = stats.gumbel_l.ppf(y)</span>
        <span class="s1">assert_allclose(x</span><span class="s2">, </span><span class="s1">xx)</span>

    <span class="s2">def </span><span class="s1">test_logcdf_logsf(self):</span>
        <span class="s1">x = np.linspace(-</span><span class="s4">100</span><span class="s2">, </span><span class="s1">-</span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">y = stats.gumbel_l.logcdf(x)</span>
        <span class="s1">z = stats.gumbel_l.logsf(x)</span>
        <span class="s1">u = np.exp(y)</span>
        <span class="s1">v = -special.expm1(z)</span>
        <span class="s1">assert_allclose(u</span><span class="s2">, </span><span class="s1">v)</span>

    <span class="s2">def </span><span class="s1">test_sf_isf(self):</span>
        <span class="s1">x = np.linspace(-</span><span class="s4">20</span><span class="s2">, </span><span class="s4">5</span><span class="s1">)</span>
        <span class="s1">y = stats.gumbel_l.sf(x)</span>
        <span class="s1">xx = stats.gumbel_l.isf(y)</span>
        <span class="s1">assert_allclose(x</span><span class="s2">, </span><span class="s1">xx)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'loc'</span><span class="s2">, </span><span class="s1">[-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_fit_fixed_param(self</span><span class="s2">, </span><span class="s1">loc):</span>
        <span class="s3"># ensure fixed location is correctly reflected from `gumbel_r.fit`</span>
        <span class="s3"># See comments at end of gh-12737.</span>
        <span class="s1">data = stats.gumbel_l.rvs(size=</span><span class="s4">100</span><span class="s2">, </span><span class="s1">loc=loc)</span>
        <span class="s1">fitted_loc</span><span class="s2">, </span><span class="s1">_ = stats.gumbel_l.fit(data</span><span class="s2">, </span><span class="s1">floc=loc)</span>
        <span class="s1">assert_equal(fitted_loc</span><span class="s2">, </span><span class="s1">loc)</span>


<span class="s2">class </span><span class="s1">TestGumbelR:</span>

    <span class="s2">def </span><span class="s1">test_sf(self):</span>
        <span class="s3"># Expected value computed with mpmath:</span>
        <span class="s3">#   &gt;&gt;&gt; import mpmath</span>
        <span class="s3">#   &gt;&gt;&gt; mpmath.mp.dps = 40</span>
        <span class="s3">#   &gt;&gt;&gt; float(mpmath.mp.one - mpmath.exp(-mpmath.exp(-50)))</span>
        <span class="s3">#   1.9287498479639178e-22</span>
        <span class="s1">assert_allclose(stats.gumbel_r.sf(</span><span class="s4">50</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1.9287498479639178e-22</span><span class="s2">,</span>
                        <span class="s1">rtol=</span><span class="s4">1e-14</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_isf(self):</span>
        <span class="s3"># Expected value computed with mpmath:</span>
        <span class="s3">#   &gt;&gt;&gt; import mpmath</span>
        <span class="s3">#   &gt;&gt;&gt; mpmath.mp.dps = 40</span>
        <span class="s3">#   &gt;&gt;&gt; float(-mpmath.log(-mpmath.log(mpmath.mp.one - 1e-17)))</span>
        <span class="s3">#   39.14394658089878</span>
        <span class="s1">assert_allclose(stats.gumbel_r.isf(</span><span class="s4">1e-17</span><span class="s1">)</span><span class="s2">, </span><span class="s4">39.14394658089878</span><span class="s2">,</span>
                        <span class="s1">rtol=</span><span class="s4">1e-14</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestLevyStable:</span>
    <span class="s1">@pytest.fixture</span>
    <span class="s2">def </span><span class="s1">nolan_pdf_sample_data(self):</span>
        <span class="s0">&quot;&quot;&quot;Sample data points for pdf computed with Nolan's stablec 
 
        See - http://fs2.american.edu/jpnolan/www/stable/stable.html 
 
        There's a known limitation of Nolan's executable for alpha &lt; 0.2. 
 
        The data table loaded below is generated from Nolan's stablec 
        with the following parameter space: 
 
            alpha = 0.1, 0.2, ..., 2.0 
            beta = -1.0, -0.9, ..., 1.0 
            p = 0.01, 0.05, 0.1, 0.25, 0.35, 0.5, 
        and the equivalent for the right tail 
 
        Typically inputs for stablec: 
 
            stablec.exe &lt;&lt; 
            1 # pdf 
            1 # Nolan S equivalent to S0 in scipy 
            .25,2,.25 # alpha 
            -1,-1,0 # beta 
            -10,10,1 # x 
            1,0 # gamma, delta 
            2 # output file 
        &quot;&quot;&quot;</span>
        <span class="s1">data = np.load(</span>
            <span class="s1">Path(__file__).parent /</span>
            <span class="s5">'data/levy_stable/stable-Z1-pdf-sample-data.npy'</span>
        <span class="s1">)</span>
        <span class="s1">data = np.core.records.fromarrays(data.T</span><span class="s2">, </span><span class="s1">names=</span><span class="s5">'x,p,alpha,beta,pct'</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">data</span>

    <span class="s1">@pytest.fixture</span>
    <span class="s2">def </span><span class="s1">nolan_cdf_sample_data(self):</span>
        <span class="s0">&quot;&quot;&quot;Sample data points for cdf computed with Nolan's stablec 
 
        See - http://fs2.american.edu/jpnolan/www/stable/stable.html 
 
        There's a known limitation of Nolan's executable for alpha &lt; 0.2. 
 
        The data table loaded below is generated from Nolan's stablec 
        with the following parameter space: 
 
            alpha = 0.1, 0.2, ..., 2.0 
            beta = -1.0, -0.9, ..., 1.0 
            p = 0.01, 0.05, 0.1, 0.25, 0.35, 0.5, 
 
        and the equivalent for the right tail 
 
        Ideally, Nolan's output for CDF values should match the percentile 
        from where they have been sampled from. Even more so as we extract 
        percentile x positions from stablec too. However, we note at places 
        Nolan's stablec will produce absolute errors in order of 1e-5. We 
        compare against his calculations here. In future, once we less 
        reliant on Nolan's paper we might switch to comparing directly at 
        percentiles (those x values being produced from some alternative 
        means). 
 
        Typically inputs for stablec: 
 
            stablec.exe &lt;&lt; 
            2 # cdf 
            1 # Nolan S equivalent to S0 in scipy 
            .25,2,.25 # alpha 
            -1,-1,0 # beta 
            -10,10,1 # x 
            1,0 # gamma, delta 
            2 # output file 
        &quot;&quot;&quot;</span>
        <span class="s1">data = np.load(</span>
            <span class="s1">Path(__file__).parent /</span>
            <span class="s5">'data/levy_stable/stable-Z1-cdf-sample-data.npy'</span>
        <span class="s1">)</span>
        <span class="s1">data = np.core.records.fromarrays(data.T</span><span class="s2">, </span><span class="s1">names=</span><span class="s5">'x,p,alpha,beta,pct'</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">data</span>

    <span class="s1">@pytest.fixture</span>
    <span class="s2">def </span><span class="s1">nolan_loc_scale_sample_data(self):</span>
        <span class="s0">&quot;&quot;&quot;Sample data where loc, scale are different from 0, 1 
 
        Data extracted in similar way to pdf/cdf above using 
        Nolan's stablec but set to an arbitrary location scale of 
        (2, 3) for various important parameters alpha, beta and for 
        parameterisations S0 and S1. 
        &quot;&quot;&quot;</span>
        <span class="s1">data = np.load(</span>
            <span class="s1">Path(__file__).parent /</span>
            <span class="s5">'data/levy_stable/stable-loc-scale-sample-data.npy'</span>
        <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">data</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s5">&quot;sample_size&quot;</span><span class="s2">, </span><span class="s1">[</span>
            <span class="s1">pytest.param(</span><span class="s4">50</span><span class="s1">)</span><span class="s2">, </span><span class="s1">pytest.param(</span><span class="s4">1500</span><span class="s2">, </span><span class="s1">marks=pytest.mark.slow)</span>
        <span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;parameterization&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s5">&quot;S0&quot;</span><span class="s2">, </span><span class="s5">&quot;S1&quot;</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s5">&quot;alpha,beta&quot;</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.5</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1.9</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)]</span>
    <span class="s1">)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;gamma,delta&quot;</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_rvs(</span>
            <span class="s1">self</span><span class="s2">,</span>
            <span class="s1">parameterization</span><span class="s2">,</span>
            <span class="s1">alpha</span><span class="s2">,</span>
            <span class="s1">beta</span><span class="s2">,</span>
            <span class="s1">gamma</span><span class="s2">,</span>
            <span class="s1">delta</span><span class="s2">,</span>
            <span class="s1">sample_size</span><span class="s2">,</span>
    <span class="s1">):</span>
        <span class="s1">stats.levy_stable.parameterization = parameterization</span>
        <span class="s1">ls = stats.levy_stable(</span>
            <span class="s1">alpha=alpha</span><span class="s2">, </span><span class="s1">beta=beta</span><span class="s2">, </span><span class="s1">scale=gamma</span><span class="s2">, </span><span class="s1">loc=delta</span>
        <span class="s1">)</span>
        <span class="s1">_</span><span class="s2">, </span><span class="s1">p = stats.kstest(</span>
            <span class="s1">ls.rvs(size=sample_size</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s4">1234</span><span class="s1">)</span><span class="s2">, </span><span class="s1">ls.cdf</span>
        <span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">p &gt; </span><span class="s4">0.05</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'beta'</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_rvs_alpha1(self</span><span class="s2">, </span><span class="s1">beta):</span>
        <span class="s0">&quot;&quot;&quot;Additional test cases for rvs for alpha equal to 1.&quot;&quot;&quot;</span>
        <span class="s1">np.random.seed(</span><span class="s4">987654321</span><span class="s1">)</span>
        <span class="s1">alpha = </span><span class="s4">1.0</span>
        <span class="s1">loc = </span><span class="s4">0.5</span>
        <span class="s1">scale = </span><span class="s4">1.5</span>
        <span class="s1">x = stats.levy_stable.rvs(alpha</span><span class="s2">, </span><span class="s1">beta</span><span class="s2">, </span><span class="s1">loc=loc</span><span class="s2">, </span><span class="s1">scale=scale</span><span class="s2">,</span>
                                  <span class="s1">size=</span><span class="s4">5000</span><span class="s1">)</span>
        <span class="s1">stat</span><span class="s2">, </span><span class="s1">p = stats.kstest(x</span><span class="s2">, </span><span class="s5">'levy_stable'</span><span class="s2">,</span>
                               <span class="s1">args=(alpha</span><span class="s2">, </span><span class="s1">beta</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale))</span>
        <span class="s2">assert </span><span class="s1">p &gt; </span><span class="s4">0.01</span>

    <span class="s2">def </span><span class="s1">test_fit(self):</span>
        <span class="s3"># construct data to have percentiles that match</span>
        <span class="s3"># example in McCulloch 1986.</span>
        <span class="s1">x = [</span>
            <span class="s1">-</span><span class="s4">.05413</span><span class="s2">, </span><span class="s1">-</span><span class="s4">.05413</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">.00533</span><span class="s2">, </span><span class="s4">.00533</span><span class="s2">, </span><span class="s4">.00533</span><span class="s2">, </span><span class="s4">.00533</span><span class="s2">,</span>
            <span class="s4">.00533</span><span class="s2">, </span><span class="s4">.03354</span><span class="s2">, </span><span class="s4">.03354</span><span class="s2">, </span><span class="s4">.03354</span><span class="s2">, </span><span class="s4">.03354</span><span class="s2">, </span><span class="s4">.03354</span><span class="s2">, </span><span class="s4">.05309</span><span class="s2">, </span><span class="s4">.05309</span><span class="s2">,</span>
            <span class="s4">.05309</span><span class="s2">, </span><span class="s4">.05309</span><span class="s2">, </span><span class="s4">.05309</span>
        <span class="s1">]</span>
        <span class="s1">alpha1</span><span class="s2">, </span><span class="s1">beta1</span><span class="s2">, </span><span class="s1">loc1</span><span class="s2">, </span><span class="s1">scale1 = stats.levy_stable._fitstart(x)</span>
        <span class="s1">assert_allclose(alpha1</span><span class="s2">, </span><span class="s4">1.48</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">0.01</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(beta1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">.22</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(scale1</span><span class="s2">, </span><span class="s4">0.01717</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">loc1</span><span class="s2">, </span><span class="s4">0.00233</span><span class="s2">, </span><span class="s4">2</span>
        <span class="s1">)  </span><span class="s3"># to 2 dps due to rounding error in McCulloch86</span>

        <span class="s3"># cover alpha=2 scenario</span>
        <span class="s1">x2 = x + [</span><span class="s4">.05309</span><span class="s2">, </span><span class="s4">.05309</span><span class="s2">, </span><span class="s4">.05309</span><span class="s2">, </span><span class="s4">.05309</span><span class="s2">, </span><span class="s4">.05309</span><span class="s1">]</span>
        <span class="s1">alpha2</span><span class="s2">, </span><span class="s1">beta2</span><span class="s2">, </span><span class="s1">loc2</span><span class="s2">, </span><span class="s1">scale2 = stats.levy_stable._fitstart(x2)</span>
        <span class="s1">assert_equal(alpha2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">assert_equal(beta2</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(scale2</span><span class="s2">, </span><span class="s4">.02503</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(loc2</span><span class="s2">, </span><span class="s4">.03354</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.xfail(reason=</span><span class="s5">&quot;Unknown problem with fitstart.&quot;</span><span class="s1">)</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s5">&quot;alpha,beta,delta,gamma&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">0.4</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">0.4</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s5">&quot;parametrization&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s5">&quot;S0&quot;</span><span class="s2">, </span><span class="s5">&quot;S1&quot;</span><span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_fit_rvs(self</span><span class="s2">, </span><span class="s1">alpha</span><span class="s2">, </span><span class="s1">beta</span><span class="s2">, </span><span class="s1">delta</span><span class="s2">, </span><span class="s1">gamma</span><span class="s2">, </span><span class="s1">parametrization):</span>
        <span class="s0">&quot;&quot;&quot;Test that fit agrees with rvs for each parametrization.&quot;&quot;&quot;</span>
        <span class="s1">stats.levy_stable.parametrization = parametrization</span>
        <span class="s1">data = stats.levy_stable.rvs(</span>
            <span class="s1">alpha</span><span class="s2">, </span><span class="s1">beta</span><span class="s2">, </span><span class="s1">loc=delta</span><span class="s2">, </span><span class="s1">scale=gamma</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">10000</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s4">1234</span>
        <span class="s1">)</span>
        <span class="s1">fit = stats.levy_stable._fitstart(data)</span>
        <span class="s1">alpha_obs</span><span class="s2">, </span><span class="s1">beta_obs</span><span class="s2">, </span><span class="s1">delta_obs</span><span class="s2">, </span><span class="s1">gamma_obs = fit</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">[alpha</span><span class="s2">, </span><span class="s1">beta</span><span class="s2">, </span><span class="s1">delta</span><span class="s2">, </span><span class="s1">gamma]</span><span class="s2">,</span>
            <span class="s1">[alpha_obs</span><span class="s2">, </span><span class="s1">beta_obs</span><span class="s2">, </span><span class="s1">delta_obs</span><span class="s2">, </span><span class="s1">gamma_obs]</span><span class="s2">,</span>
            <span class="s1">rtol=</span><span class="s4">0.01</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_fit_beta_flip(self):</span>
        <span class="s3"># Confirm that sign of beta affects loc, not alpha or scale.</span>
        <span class="s1">x = np.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">30</span><span class="s2">, </span><span class="s4">30</span><span class="s2">, </span><span class="s4">100</span><span class="s2">, </span><span class="s4">100</span><span class="s1">])</span>
        <span class="s1">alpha1</span><span class="s2">, </span><span class="s1">beta1</span><span class="s2">, </span><span class="s1">loc1</span><span class="s2">, </span><span class="s1">scale1 = stats.levy_stable._fitstart(x)</span>
        <span class="s1">alpha2</span><span class="s2">, </span><span class="s1">beta2</span><span class="s2">, </span><span class="s1">loc2</span><span class="s2">, </span><span class="s1">scale2 = stats.levy_stable._fitstart(-x)</span>
        <span class="s1">assert_equal(beta1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">loc1 != </span><span class="s4">0</span>
        <span class="s1">assert_almost_equal(alpha2</span><span class="s2">, </span><span class="s1">alpha1)</span>
        <span class="s1">assert_almost_equal(beta2</span><span class="s2">, </span><span class="s1">-beta1)</span>
        <span class="s1">assert_almost_equal(loc2</span><span class="s2">, </span><span class="s1">-loc1)</span>
        <span class="s1">assert_almost_equal(scale2</span><span class="s2">, </span><span class="s1">scale1)</span>

    <span class="s2">def </span><span class="s1">test_fit_delta_shift(self):</span>
        <span class="s3"># Confirm that loc slides up and down if data shifts.</span>
        <span class="s1">SHIFT = </span><span class="s4">1</span>
        <span class="s1">x = np.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">30</span><span class="s2">, </span><span class="s4">30</span><span class="s2">, </span><span class="s4">100</span><span class="s2">, </span><span class="s4">100</span><span class="s1">])</span>
        <span class="s1">alpha1</span><span class="s2">, </span><span class="s1">beta1</span><span class="s2">, </span><span class="s1">loc1</span><span class="s2">, </span><span class="s1">scale1 = stats.levy_stable._fitstart(-x)</span>
        <span class="s1">alpha2</span><span class="s2">, </span><span class="s1">beta2</span><span class="s2">, </span><span class="s1">loc2</span><span class="s2">, </span><span class="s1">scale2 = stats.levy_stable._fitstart(-x + SHIFT)</span>
        <span class="s1">assert_almost_equal(alpha2</span><span class="s2">, </span><span class="s1">alpha1)</span>
        <span class="s1">assert_almost_equal(beta2</span><span class="s2">, </span><span class="s1">beta1)</span>
        <span class="s1">assert_almost_equal(loc2</span><span class="s2">, </span><span class="s1">loc1 + SHIFT)</span>
        <span class="s1">assert_almost_equal(scale2</span><span class="s2">, </span><span class="s1">scale1)</span>

    <span class="s2">def </span><span class="s1">test_fit_loc_extrap(self):</span>
        <span class="s3"># Confirm that loc goes out of sample for alpha close to 1.</span>
        <span class="s1">x = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">30</span><span class="s2">, </span><span class="s4">30</span><span class="s2">, </span><span class="s4">140</span><span class="s2">, </span><span class="s4">140</span><span class="s1">]</span>
        <span class="s1">alpha1</span><span class="s2">, </span><span class="s1">beta1</span><span class="s2">, </span><span class="s1">loc1</span><span class="s2">, </span><span class="s1">scale1 = stats.levy_stable._fitstart(x)</span>
        <span class="s2">assert </span><span class="s1">alpha1 &lt; </span><span class="s4">1</span><span class="s2">, </span><span class="s5">f&quot;Expected alpha &lt; 1, got </span><span class="s2">{</span><span class="s1">alpha1</span><span class="s2">}</span><span class="s5">&quot;</span>
        <span class="s2">assert </span><span class="s1">loc1 &lt; min(x)</span><span class="s2">, </span><span class="s5">f&quot;Expected loc &lt; </span><span class="s2">{</span><span class="s1">min(x)</span><span class="s2">}</span><span class="s5">, got </span><span class="s2">{</span><span class="s1">loc1</span><span class="s2">}</span><span class="s5">&quot;</span>

        <span class="s1">x2 = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">30</span><span class="s2">, </span><span class="s4">30</span><span class="s2">, </span><span class="s4">130</span><span class="s2">, </span><span class="s4">130</span><span class="s1">]</span>
        <span class="s1">alpha2</span><span class="s2">, </span><span class="s1">beta2</span><span class="s2">, </span><span class="s1">loc2</span><span class="s2">, </span><span class="s1">scale2 = stats.levy_stable._fitstart(x2)</span>
        <span class="s2">assert </span><span class="s1">alpha2 &gt; </span><span class="s4">1</span><span class="s2">, </span><span class="s5">f&quot;Expected alpha &gt; 1, got </span><span class="s2">{</span><span class="s1">alpha2</span><span class="s2">}</span><span class="s5">&quot;</span>
        <span class="s2">assert </span><span class="s1">loc2 &gt; max(x2)</span><span class="s2">, </span><span class="s5">f&quot;Expected loc &gt; </span><span class="s2">{</span><span class="s1">max(x2)</span><span class="s2">}</span><span class="s5">, got </span><span class="s2">{</span><span class="s1">loc2</span><span class="s2">}</span><span class="s5">&quot;</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s5">&quot;pct_range,alpha_range,beta_range&quot;</span><span class="s2">, </span><span class="s1">[</span>
            <span class="s1">pytest.param(</span>
                <span class="s1">[</span><span class="s4">.01</span><span class="s2">, </span><span class="s4">.5</span><span class="s2">, </span><span class="s4">.99</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s4">.1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">.8</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">pytest.param(</span>
                <span class="s1">[</span><span class="s4">.01</span><span class="s2">, </span><span class="s4">.05</span><span class="s2">, </span><span class="s4">.5</span><span class="s2">, </span><span class="s4">.95</span><span class="s2">, </span><span class="s4">.99</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s4">.1</span><span class="s2">, </span><span class="s4">.5</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[-</span><span class="s4">.9</span><span class="s2">, </span><span class="s1">-</span><span class="s4">.5</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">.3</span><span class="s2">, </span><span class="s4">.6</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">marks=pytest.mark.slow</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">pytest.param(</span>
                <span class="s1">[</span><span class="s4">.01</span><span class="s2">, </span><span class="s4">.05</span><span class="s2">, </span><span class="s4">.1</span><span class="s2">, </span><span class="s4">.25</span><span class="s2">, </span><span class="s4">.35</span><span class="s2">, </span><span class="s4">.5</span><span class="s2">, </span><span class="s4">.65</span><span class="s2">, </span><span class="s4">.75</span><span class="s2">, </span><span class="s4">.9</span><span class="s2">, </span><span class="s4">.95</span><span class="s2">, </span><span class="s4">.99</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">np.linspace(</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">20</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">np.linspace(-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">21</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">marks=pytest.mark.xslow</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_pdf_nolan_samples(</span>
            <span class="s1">self</span><span class="s2">, </span><span class="s1">nolan_pdf_sample_data</span><span class="s2">, </span><span class="s1">pct_range</span><span class="s2">, </span><span class="s1">alpha_range</span><span class="s2">, </span><span class="s1">beta_range</span>
    <span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Test pdf values against Nolan's stablec.exe output&quot;&quot;&quot;</span>
        <span class="s1">data = nolan_pdf_sample_data</span>

        <span class="s3"># some tests break on linux 32 bit</span>
        <span class="s1">uname = platform.uname()</span>
        <span class="s1">is_linux_32 = uname.system == </span><span class="s5">'Linux' </span><span class="s2">and </span><span class="s1">uname.machine == </span><span class="s5">'i686'</span>
        <span class="s1">platform_desc = </span><span class="s5">&quot;/&quot;</span><span class="s1">.join(</span>
            <span class="s1">[uname.system</span><span class="s2">, </span><span class="s1">uname.machine</span><span class="s2">, </span><span class="s1">uname.processor])</span>

        <span class="s3"># fmt: off</span>
        <span class="s3"># There are a number of cases which fail on some but not all platforms.</span>
        <span class="s3"># These are excluded by the filters below. TODO: Rewrite tests so that</span>
        <span class="s3"># the now filtered out test cases are still run but marked in pytest as</span>
        <span class="s3"># expected to fail.</span>
        <span class="s1">tests = [</span>
            <span class="s1">[</span>
                <span class="s5">'dni'</span><span class="s2">, </span><span class="s4">1e-7</span><span class="s2">, lambda </span><span class="s1">r: (</span>
                    <span class="s1">np.isin(r[</span><span class="s5">'pct'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">pct_range) &amp;</span>
                    <span class="s1">np.isin(r[</span><span class="s5">'alpha'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">alpha_range) &amp;</span>
                    <span class="s1">np.isin(r[</span><span class="s5">'beta'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">beta_range) &amp;</span>
                    <span class="s1">~(</span>
                        <span class="s1">(</span>
                            <span class="s1">(r[</span><span class="s5">'beta'</span><span class="s1">] == </span><span class="s4">0</span><span class="s1">) &amp;</span>
                            <span class="s1">(r[</span><span class="s5">'pct'</span><span class="s1">] == </span><span class="s4">0.5</span><span class="s1">)</span>
                        <span class="s1">) |</span>
                        <span class="s1">(</span>
                            <span class="s1">(r[</span><span class="s5">'beta'</span><span class="s1">] &gt;= </span><span class="s4">0.9</span><span class="s1">) &amp;</span>
                            <span class="s1">(r[</span><span class="s5">'alpha'</span><span class="s1">] &gt;= </span><span class="s4">1.6</span><span class="s1">) &amp;</span>
                            <span class="s1">(r[</span><span class="s5">'pct'</span><span class="s1">] == </span><span class="s4">0.5</span><span class="s1">)</span>
                        <span class="s1">) |</span>
                        <span class="s1">(</span>
                            <span class="s1">(r[</span><span class="s5">'alpha'</span><span class="s1">] &lt;= </span><span class="s4">0.4</span><span class="s1">) &amp;</span>
                            <span class="s1">np.isin(r[</span><span class="s5">'pct'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">.01</span><span class="s2">, </span><span class="s4">.99</span><span class="s1">])</span>
                        <span class="s1">) |</span>
                        <span class="s1">(</span>
                            <span class="s1">(r[</span><span class="s5">'alpha'</span><span class="s1">] &lt;= </span><span class="s4">0.3</span><span class="s1">) &amp;</span>
                            <span class="s1">np.isin(r[</span><span class="s5">'pct'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">.05</span><span class="s2">, </span><span class="s4">.95</span><span class="s1">])</span>
                        <span class="s1">) |</span>
                        <span class="s1">(</span>
                            <span class="s1">(r[</span><span class="s5">'alpha'</span><span class="s1">] &lt;= </span><span class="s4">0.2</span><span class="s1">) &amp;</span>
                            <span class="s1">np.isin(r[</span><span class="s5">'pct'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">.1</span><span class="s2">, </span><span class="s4">.9</span><span class="s1">])</span>
                        <span class="s1">) |</span>
                        <span class="s1">(</span>
                            <span class="s1">(r[</span><span class="s5">'alpha'</span><span class="s1">] == </span><span class="s4">0.1</span><span class="s1">) &amp;</span>
                            <span class="s1">np.isin(r[</span><span class="s5">'pct'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">.25</span><span class="s2">, </span><span class="s4">.75</span><span class="s1">]) &amp;</span>
                            <span class="s1">np.isin(np.abs(r[</span><span class="s5">'beta'</span><span class="s1">])</span><span class="s2">, </span><span class="s1">[</span><span class="s4">.5</span><span class="s2">, </span><span class="s4">.6</span><span class="s2">, </span><span class="s4">.7</span><span class="s1">])</span>
                        <span class="s1">) |</span>
                        <span class="s1">(</span>
                            <span class="s1">(r[</span><span class="s5">'alpha'</span><span class="s1">] == </span><span class="s4">0.1</span><span class="s1">) &amp;</span>
                            <span class="s1">np.isin(r[</span><span class="s5">'pct'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">.5</span><span class="s1">]) &amp;</span>
                            <span class="s1">np.isin(np.abs(r[</span><span class="s5">'beta'</span><span class="s1">])</span><span class="s2">, </span><span class="s1">[</span><span class="s4">.1</span><span class="s1">])</span>
                        <span class="s1">) |</span>
                        <span class="s1">(</span>
                            <span class="s1">(r[</span><span class="s5">'alpha'</span><span class="s1">] == </span><span class="s4">0.1</span><span class="s1">) &amp;</span>
                            <span class="s1">np.isin(r[</span><span class="s5">'pct'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">.35</span><span class="s2">, </span><span class="s4">.65</span><span class="s1">]) &amp;</span>
                            <span class="s1">np.isin(np.abs(r[</span><span class="s5">'beta'</span><span class="s1">])</span><span class="s2">, </span><span class="s1">[-</span><span class="s4">.4</span><span class="s2">, </span><span class="s1">-</span><span class="s4">.3</span><span class="s2">, </span><span class="s4">.3</span><span class="s2">, </span><span class="s4">.4</span><span class="s2">, </span><span class="s4">.5</span><span class="s1">])</span>
                        <span class="s1">) |</span>
                        <span class="s1">(</span>
                            <span class="s1">(r[</span><span class="s5">'alpha'</span><span class="s1">] == </span><span class="s4">0.2</span><span class="s1">) &amp;</span>
                            <span class="s1">(r[</span><span class="s5">'beta'</span><span class="s1">] == </span><span class="s4">0.5</span><span class="s1">) &amp;</span>
                            <span class="s1">(r[</span><span class="s5">'pct'</span><span class="s1">] == </span><span class="s4">0.25</span><span class="s1">)</span>
                        <span class="s1">) |</span>
                        <span class="s1">(</span>
                            <span class="s1">(r[</span><span class="s5">'alpha'</span><span class="s1">] == </span><span class="s4">0.2</span><span class="s1">) &amp;</span>
                            <span class="s1">(r[</span><span class="s5">'beta'</span><span class="s1">] == -</span><span class="s4">0.3</span><span class="s1">) &amp;</span>
                            <span class="s1">(r[</span><span class="s5">'pct'</span><span class="s1">] == </span><span class="s4">0.65</span><span class="s1">)</span>
                        <span class="s1">) |</span>
                        <span class="s1">(</span>
                            <span class="s1">(r[</span><span class="s5">'alpha'</span><span class="s1">] == </span><span class="s4">0.2</span><span class="s1">) &amp;</span>
                            <span class="s1">(r[</span><span class="s5">'beta'</span><span class="s1">] == </span><span class="s4">0.3</span><span class="s1">) &amp;</span>
                            <span class="s1">(r[</span><span class="s5">'pct'</span><span class="s1">] == </span><span class="s4">0.35</span><span class="s1">)</span>
                        <span class="s1">) |</span>
                        <span class="s1">(</span>
                            <span class="s1">(r[</span><span class="s5">'alpha'</span><span class="s1">] == </span><span class="s4">1.</span><span class="s1">) &amp;</span>
                            <span class="s1">np.isin(r[</span><span class="s5">'pct'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">.5</span><span class="s1">]) &amp;</span>
                            <span class="s1">np.isin(np.abs(r[</span><span class="s5">'beta'</span><span class="s1">])</span><span class="s2">, </span><span class="s1">[</span><span class="s4">.1</span><span class="s2">, </span><span class="s4">.2</span><span class="s2">, </span><span class="s4">.3</span><span class="s2">, </span><span class="s4">.4</span><span class="s1">])</span>
                        <span class="s1">) |</span>
                        <span class="s1">(</span>
                            <span class="s1">(r[</span><span class="s5">'alpha'</span><span class="s1">] == </span><span class="s4">1.</span><span class="s1">) &amp;</span>
                            <span class="s1">np.isin(r[</span><span class="s5">'pct'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">.35</span><span class="s2">, </span><span class="s4">.65</span><span class="s1">]) &amp;</span>
                            <span class="s1">np.isin(np.abs(r[</span><span class="s5">'beta'</span><span class="s1">])</span><span class="s2">, </span><span class="s1">[</span><span class="s4">.8</span><span class="s2">, </span><span class="s4">.9</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">])</span>
                        <span class="s1">) |</span>
                        <span class="s1">(</span>
                            <span class="s1">(r[</span><span class="s5">'alpha'</span><span class="s1">] == </span><span class="s4">1.</span><span class="s1">) &amp;</span>
                            <span class="s1">np.isin(r[</span><span class="s5">'pct'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">.01</span><span class="s2">, </span><span class="s4">.99</span><span class="s1">]) &amp;</span>
                            <span class="s1">np.isin(np.abs(r[</span><span class="s5">'beta'</span><span class="s1">])</span><span class="s2">, </span><span class="s1">[-</span><span class="s4">.1</span><span class="s2">, </span><span class="s4">.1</span><span class="s1">])</span>
                        <span class="s1">) |</span>
                        <span class="s3"># various points ok but too sparse to list</span>
                        <span class="s1">(r[</span><span class="s5">'alpha'</span><span class="s1">] &gt;= </span><span class="s4">1.1</span><span class="s1">)</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s3"># piecewise generally good accuracy</span>
            <span class="s1">[</span>
                <span class="s5">'piecewise'</span><span class="s2">, </span><span class="s4">1e-11</span><span class="s2">, lambda </span><span class="s1">r: (</span>
                    <span class="s1">np.isin(r[</span><span class="s5">'pct'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">pct_range) &amp;</span>
                    <span class="s1">np.isin(r[</span><span class="s5">'alpha'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">alpha_range) &amp;</span>
                    <span class="s1">np.isin(r[</span><span class="s5">'beta'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">beta_range) &amp;</span>
                    <span class="s1">(r[</span><span class="s5">'alpha'</span><span class="s1">] &gt; </span><span class="s4">0.2</span><span class="s1">) &amp;</span>
                    <span class="s1">(r[</span><span class="s5">'alpha'</span><span class="s1">] != </span><span class="s4">1.</span><span class="s1">)</span>
                <span class="s1">)</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s3"># for alpha = 1. for linux 32 bit optimize.bisect</span>
            <span class="s3"># has some issues for .01 and .99 percentile</span>
            <span class="s1">[</span>
                <span class="s5">'piecewise'</span><span class="s2">, </span><span class="s4">1e-11</span><span class="s2">, lambda </span><span class="s1">r: (</span>
                    <span class="s1">(r[</span><span class="s5">'alpha'</span><span class="s1">] == </span><span class="s4">1.</span><span class="s1">) &amp;</span>
                    <span class="s1">(</span><span class="s2">not </span><span class="s1">is_linux_32) &amp;</span>
                    <span class="s1">np.isin(r[</span><span class="s5">'pct'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">pct_range) &amp;</span>
                    <span class="s1">(</span><span class="s4">1. </span><span class="s2">in </span><span class="s1">alpha_range) &amp;</span>
                    <span class="s1">np.isin(r[</span><span class="s5">'beta'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">beta_range)</span>
                <span class="s1">)</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s3"># for small alpha very slightly reduced accuracy</span>
            <span class="s1">[</span>
                <span class="s5">'piecewise'</span><span class="s2">, </span><span class="s4">2.5e-10</span><span class="s2">, lambda </span><span class="s1">r: (</span>
                    <span class="s1">np.isin(r[</span><span class="s5">'pct'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">pct_range) &amp;</span>
                    <span class="s1">np.isin(r[</span><span class="s5">'alpha'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">alpha_range) &amp;</span>
                    <span class="s1">np.isin(r[</span><span class="s5">'beta'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">beta_range) &amp;</span>
                    <span class="s1">(r[</span><span class="s5">'alpha'</span><span class="s1">] &lt;= </span><span class="s4">0.2</span><span class="s1">)</span>
                <span class="s1">)</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s3"># fft accuracy reduces as alpha decreases</span>
            <span class="s1">[</span>
                <span class="s5">'fft-simpson'</span><span class="s2">, </span><span class="s4">1e-5</span><span class="s2">, lambda </span><span class="s1">r: (</span>
                    <span class="s1">(r[</span><span class="s5">'alpha'</span><span class="s1">] &gt;= </span><span class="s4">1.9</span><span class="s1">) &amp;</span>
                    <span class="s1">np.isin(r[</span><span class="s5">'pct'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">pct_range) &amp;</span>
                    <span class="s1">np.isin(r[</span><span class="s5">'alpha'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">alpha_range) &amp;</span>
                    <span class="s1">np.isin(r[</span><span class="s5">'beta'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">beta_range)</span>
                <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s5">'fft-simpson'</span><span class="s2">, </span><span class="s4">1e-6</span><span class="s2">, lambda </span><span class="s1">r: (</span>
                    <span class="s1">np.isin(r[</span><span class="s5">'pct'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">pct_range) &amp;</span>
                    <span class="s1">np.isin(r[</span><span class="s5">'alpha'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">alpha_range) &amp;</span>
                    <span class="s1">np.isin(r[</span><span class="s5">'beta'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">beta_range) &amp;</span>
                    <span class="s1">(r[</span><span class="s5">'alpha'</span><span class="s1">] &gt; </span><span class="s4">1</span><span class="s1">) &amp;</span>
                    <span class="s1">(r[</span><span class="s5">'alpha'</span><span class="s1">] &lt; </span><span class="s4">1.9</span><span class="s1">)</span>
                <span class="s1">)</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s3"># fft relative errors for alpha &lt; 1, will raise if enabled</span>
            <span class="s3"># ['fft-simpson', 1e-4, lambda r: r['alpha'] == 0.9],</span>
            <span class="s3"># ['fft-simpson', 1e-3, lambda r: r['alpha'] == 0.8],</span>
            <span class="s3"># ['fft-simpson', 1e-2, lambda r: r['alpha'] == 0.7],</span>
            <span class="s3"># ['fft-simpson', 1e-1, lambda r: r['alpha'] == 0.6],</span>
        <span class="s1">]</span>
        <span class="s3"># fmt: on</span>
        <span class="s2">for </span><span class="s1">ix</span><span class="s2">, </span><span class="s1">(default_method</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">,</span>
                 <span class="s1">filter_func) </span><span class="s2">in </span><span class="s1">enumerate(tests):</span>
            <span class="s1">stats.levy_stable.pdf_default_method = default_method</span>
            <span class="s1">subdata = data[filter_func(data)</span>
                           <span class="s1">] </span><span class="s2">if </span><span class="s1">filter_func </span><span class="s2">is not None else </span><span class="s1">data</span>
            <span class="s2">with </span><span class="s1">suppress_warnings() </span><span class="s2">as </span><span class="s1">sup:</span>
                <span class="s3"># occurs in FFT methods only</span>
                <span class="s1">sup.record(</span>
                    <span class="s1">RuntimeWarning</span><span class="s2">,</span>
                    <span class="s5">&quot;Density calculations experimental for FFT method.*&quot;</span>
                <span class="s1">)</span>
                <span class="s1">p = stats.levy_stable.pdf(</span>
                    <span class="s1">subdata[</span><span class="s5">'x'</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s1">subdata[</span><span class="s5">'alpha'</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s1">subdata[</span><span class="s5">'beta'</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s1">scale=</span><span class="s4">1</span><span class="s2">,</span>
                    <span class="s1">loc=</span><span class="s4">0</span>
                <span class="s1">)</span>
                <span class="s2">with </span><span class="s1">np.errstate(over=</span><span class="s5">&quot;ignore&quot;</span><span class="s1">):</span>
                    <span class="s1">subdata2 = rec_append_fields(</span>
                        <span class="s1">subdata</span><span class="s2">,</span>
                        <span class="s1">[</span><span class="s5">'calc'</span><span class="s2">, </span><span class="s5">'abserr'</span><span class="s2">, </span><span class="s5">'relerr'</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">[</span>
                            <span class="s1">p</span><span class="s2">,</span>
                            <span class="s1">np.abs(p - subdata[</span><span class="s5">'p'</span><span class="s1">])</span><span class="s2">,</span>
                            <span class="s1">np.abs(p - subdata[</span><span class="s5">'p'</span><span class="s1">]) / np.abs(subdata[</span><span class="s5">'p'</span><span class="s1">])</span>
                        <span class="s1">]</span>
                    <span class="s1">)</span>
                <span class="s1">failures = subdata2[</span>
                  <span class="s1">(subdata2[</span><span class="s5">'relerr'</span><span class="s1">] &gt;= rtol) |</span>
                  <span class="s1">np.isnan(p)</span>
                <span class="s1">]</span>
                <span class="s1">assert_allclose(</span>
                    <span class="s1">p</span><span class="s2">,</span>
                    <span class="s1">subdata[</span><span class="s5">'p'</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s1">rtol</span><span class="s2">,</span>
                    <span class="s1">err_msg=</span><span class="s5">&quot;pdf test %s failed with method '%s'&quot;</span>
                            <span class="s5">&quot; [platform: %s]</span><span class="s2">\n</span><span class="s5">%s</span><span class="s2">\n</span><span class="s5">%s&quot; </span><span class="s1">%</span>
                    <span class="s1">(ix</span><span class="s2">, </span><span class="s1">default_method</span><span class="s2">, </span><span class="s1">platform_desc</span><span class="s2">, </span><span class="s1">failures.dtype.names</span><span class="s2">,</span>
                        <span class="s1">failures)</span><span class="s2">,</span>
                    <span class="s1">verbose=</span><span class="s2">False</span>
                <span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s5">&quot;pct_range,alpha_range,beta_range&quot;</span><span class="s2">, </span><span class="s1">[</span>
            <span class="s1">pytest.param(</span>
                <span class="s1">[</span><span class="s4">.01</span><span class="s2">, </span><span class="s4">.5</span><span class="s2">, </span><span class="s4">.99</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s4">.1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">.8</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">pytest.param(</span>
                <span class="s1">[</span><span class="s4">.01</span><span class="s2">, </span><span class="s4">.05</span><span class="s2">, </span><span class="s4">.5</span><span class="s2">, </span><span class="s4">.95</span><span class="s2">, </span><span class="s4">.99</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s4">.1</span><span class="s2">, </span><span class="s4">.5</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[-</span><span class="s4">.9</span><span class="s2">, </span><span class="s1">-</span><span class="s4">.5</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">.3</span><span class="s2">, </span><span class="s4">.6</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">marks=pytest.mark.slow</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">pytest.param(</span>
                <span class="s1">[</span><span class="s4">.01</span><span class="s2">, </span><span class="s4">.05</span><span class="s2">, </span><span class="s4">.1</span><span class="s2">, </span><span class="s4">.25</span><span class="s2">, </span><span class="s4">.35</span><span class="s2">, </span><span class="s4">.5</span><span class="s2">, </span><span class="s4">.65</span><span class="s2">, </span><span class="s4">.75</span><span class="s2">, </span><span class="s4">.9</span><span class="s2">, </span><span class="s4">.95</span><span class="s2">, </span><span class="s4">.99</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">np.linspace(</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">20</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">np.linspace(-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">21</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s1">marks=pytest.mark.xslow</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_cdf_nolan_samples(</span>
            <span class="s1">self</span><span class="s2">, </span><span class="s1">nolan_cdf_sample_data</span><span class="s2">, </span><span class="s1">pct_range</span><span class="s2">, </span><span class="s1">alpha_range</span><span class="s2">, </span><span class="s1">beta_range</span>
    <span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; Test cdf values against Nolan's stablec.exe output.&quot;&quot;&quot;</span>
        <span class="s1">data = nolan_cdf_sample_data</span>
        <span class="s1">tests = [</span>
            <span class="s3"># piecewise generally good accuracy</span>
            <span class="s1">[</span>
                <span class="s5">'piecewise'</span><span class="s2">, </span><span class="s4">2e-12</span><span class="s2">, lambda </span><span class="s1">r: (</span>
                    <span class="s1">np.isin(r[</span><span class="s5">'pct'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">pct_range) &amp;</span>
                    <span class="s1">np.isin(r[</span><span class="s5">'alpha'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">alpha_range) &amp;</span>
                    <span class="s1">np.isin(r[</span><span class="s5">'beta'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">beta_range) &amp;</span>
                    <span class="s1">~(</span>
                        <span class="s1">(</span>
                            <span class="s1">(r[</span><span class="s5">'alpha'</span><span class="s1">] == </span><span class="s4">1.</span><span class="s1">) &amp;</span>
                            <span class="s1">np.isin(r[</span><span class="s5">'beta'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[-</span><span class="s4">0.3</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.2</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.1</span><span class="s1">]) &amp;</span>
                            <span class="s1">(r[</span><span class="s5">'pct'</span><span class="s1">] == </span><span class="s4">0.01</span><span class="s1">)</span>
                        <span class="s1">) |</span>
                        <span class="s1">(</span>
                            <span class="s1">(r[</span><span class="s5">'alpha'</span><span class="s1">] == </span><span class="s4">1.</span><span class="s1">) &amp;</span>
                            <span class="s1">np.isin(r[</span><span class="s5">'beta'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">0.3</span><span class="s1">]) &amp;</span>
                            <span class="s1">(r[</span><span class="s5">'pct'</span><span class="s1">] == </span><span class="s4">0.99</span><span class="s1">)</span>
                        <span class="s1">)</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s3"># for some points with alpha=1, Nolan's STABLE clearly</span>
            <span class="s3"># loses accuracy</span>
            <span class="s1">[</span>
                <span class="s5">'piecewise'</span><span class="s2">, </span><span class="s4">5e-2</span><span class="s2">, lambda </span><span class="s1">r: (</span>
                    <span class="s1">np.isin(r[</span><span class="s5">'pct'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">pct_range) &amp;</span>
                    <span class="s1">np.isin(r[</span><span class="s5">'alpha'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">alpha_range) &amp;</span>
                    <span class="s1">np.isin(r[</span><span class="s5">'beta'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">beta_range) &amp;</span>
                    <span class="s1">(</span>
                        <span class="s1">(r[</span><span class="s5">'alpha'</span><span class="s1">] == </span><span class="s4">1.</span><span class="s1">) &amp;</span>
                        <span class="s1">np.isin(r[</span><span class="s5">'beta'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[-</span><span class="s4">0.3</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.2</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.1</span><span class="s1">]) &amp;</span>
                        <span class="s1">(r[</span><span class="s5">'pct'</span><span class="s1">] == </span><span class="s4">0.01</span><span class="s1">)</span>
                    <span class="s1">) |</span>
                    <span class="s1">(</span>
                        <span class="s1">(r[</span><span class="s5">'alpha'</span><span class="s1">] == </span><span class="s4">1.</span><span class="s1">) &amp;</span>
                        <span class="s1">np.isin(r[</span><span class="s5">'beta'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">0.3</span><span class="s1">]) &amp;</span>
                        <span class="s1">(r[</span><span class="s5">'pct'</span><span class="s1">] == </span><span class="s4">0.99</span><span class="s1">)</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s3"># fft accuracy poor, very poor alpha &lt; 1</span>
            <span class="s1">[</span>
                <span class="s5">'fft-simpson'</span><span class="s2">, </span><span class="s4">1e-5</span><span class="s2">, lambda </span><span class="s1">r: (</span>
                    <span class="s1">np.isin(r[</span><span class="s5">'pct'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">pct_range) &amp;</span>
                    <span class="s1">np.isin(r[</span><span class="s5">'alpha'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">alpha_range) &amp;</span>
                    <span class="s1">np.isin(r[</span><span class="s5">'beta'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">beta_range) &amp;</span>
                    <span class="s1">(r[</span><span class="s5">'alpha'</span><span class="s1">] &gt; </span><span class="s4">1.7</span><span class="s1">)</span>
                <span class="s1">)</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s5">'fft-simpson'</span><span class="s2">, </span><span class="s4">1e-4</span><span class="s2">, lambda </span><span class="s1">r: (</span>
                    <span class="s1">np.isin(r[</span><span class="s5">'pct'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">pct_range) &amp;</span>
                    <span class="s1">np.isin(r[</span><span class="s5">'alpha'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">alpha_range) &amp;</span>
                    <span class="s1">np.isin(r[</span><span class="s5">'beta'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">beta_range) &amp;</span>
                    <span class="s1">(r[</span><span class="s5">'alpha'</span><span class="s1">] &gt; </span><span class="s4">1.5</span><span class="s1">) &amp;</span>
                    <span class="s1">(r[</span><span class="s5">'alpha'</span><span class="s1">] &lt;= </span><span class="s4">1.7</span><span class="s1">)</span>
                <span class="s1">)</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s5">'fft-simpson'</span><span class="s2">, </span><span class="s4">1e-3</span><span class="s2">, lambda </span><span class="s1">r: (</span>
                    <span class="s1">np.isin(r[</span><span class="s5">'pct'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">pct_range) &amp;</span>
                    <span class="s1">np.isin(r[</span><span class="s5">'alpha'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">alpha_range) &amp;</span>
                    <span class="s1">np.isin(r[</span><span class="s5">'beta'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">beta_range) &amp;</span>
                    <span class="s1">(r[</span><span class="s5">'alpha'</span><span class="s1">] &gt; </span><span class="s4">1.3</span><span class="s1">) &amp;</span>
                    <span class="s1">(r[</span><span class="s5">'alpha'</span><span class="s1">] &lt;= </span><span class="s4">1.5</span><span class="s1">)</span>
                <span class="s1">)</span>
            <span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s5">'fft-simpson'</span><span class="s2">, </span><span class="s4">1e-2</span><span class="s2">, lambda </span><span class="s1">r: (</span>
                    <span class="s1">np.isin(r[</span><span class="s5">'pct'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">pct_range) &amp;</span>
                    <span class="s1">np.isin(r[</span><span class="s5">'alpha'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">alpha_range) &amp;</span>
                    <span class="s1">np.isin(r[</span><span class="s5">'beta'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">beta_range) &amp;</span>
                    <span class="s1">(r[</span><span class="s5">'alpha'</span><span class="s1">] &gt; </span><span class="s4">1.0</span><span class="s1">) &amp;</span>
                    <span class="s1">(r[</span><span class="s5">'alpha'</span><span class="s1">] &lt;= </span><span class="s4">1.3</span><span class="s1">)</span>
                <span class="s1">)</span>
            <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">]</span>
        <span class="s2">for </span><span class="s1">ix</span><span class="s2">, </span><span class="s1">(default_method</span><span class="s2">, </span><span class="s1">rtol</span><span class="s2">,</span>
                 <span class="s1">filter_func) </span><span class="s2">in </span><span class="s1">enumerate(tests):</span>
            <span class="s1">stats.levy_stable.cdf_default_method = default_method</span>
            <span class="s1">subdata = data[filter_func(data)</span>
                           <span class="s1">] </span><span class="s2">if </span><span class="s1">filter_func </span><span class="s2">is not None else </span><span class="s1">data</span>
            <span class="s2">with </span><span class="s1">suppress_warnings() </span><span class="s2">as </span><span class="s1">sup:</span>
                <span class="s1">sup.record(</span>
                    <span class="s1">RuntimeWarning</span><span class="s2">,</span>
                    <span class="s5">'Cumulative density calculations experimental for FFT'</span>
                    <span class="s1">+ </span><span class="s5">' method. Use piecewise method instead.*'</span>
                <span class="s1">)</span>
                <span class="s1">p = stats.levy_stable.cdf(</span>
                    <span class="s1">subdata[</span><span class="s5">'x'</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s1">subdata[</span><span class="s5">'alpha'</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s1">subdata[</span><span class="s5">'beta'</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s1">scale=</span><span class="s4">1</span><span class="s2">,</span>
                    <span class="s1">loc=</span><span class="s4">0</span>
                <span class="s1">)</span>
                <span class="s2">with </span><span class="s1">np.errstate(over=</span><span class="s5">&quot;ignore&quot;</span><span class="s1">):</span>
                    <span class="s1">subdata2 = rec_append_fields(</span>
                        <span class="s1">subdata</span><span class="s2">,</span>
                        <span class="s1">[</span><span class="s5">'calc'</span><span class="s2">, </span><span class="s5">'abserr'</span><span class="s2">, </span><span class="s5">'relerr'</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">[</span>
                            <span class="s1">p</span><span class="s2">,</span>
                            <span class="s1">np.abs(p - subdata[</span><span class="s5">'p'</span><span class="s1">])</span><span class="s2">,</span>
                            <span class="s1">np.abs(p - subdata[</span><span class="s5">'p'</span><span class="s1">]) / np.abs(subdata[</span><span class="s5">'p'</span><span class="s1">])</span>
                        <span class="s1">]</span>
                    <span class="s1">)</span>
                <span class="s1">failures = subdata2[</span>
                  <span class="s1">(subdata2[</span><span class="s5">'relerr'</span><span class="s1">] &gt;= rtol) |</span>
                  <span class="s1">np.isnan(p)</span>
                <span class="s1">]</span>
                <span class="s1">assert_allclose(</span>
                    <span class="s1">p</span><span class="s2">,</span>
                    <span class="s1">subdata[</span><span class="s5">'p'</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s1">rtol</span><span class="s2">,</span>
                    <span class="s1">err_msg=</span><span class="s5">&quot;cdf test %s failed with method '%s'</span><span class="s2">\n</span><span class="s5">%s</span><span class="s2">\n</span><span class="s5">%s&quot; </span><span class="s1">%</span>
                    <span class="s1">(ix</span><span class="s2">, </span><span class="s1">default_method</span><span class="s2">, </span><span class="s1">failures.dtype.names</span><span class="s2">, </span><span class="s1">failures)</span><span class="s2">,</span>
                    <span class="s1">verbose=</span><span class="s2">False</span>
                <span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;param&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;case&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s5">&quot;pdf&quot;</span><span class="s2">, </span><span class="s5">&quot;cdf&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_location_scale(</span>
            <span class="s1">self</span><span class="s2">, </span><span class="s1">nolan_loc_scale_sample_data</span><span class="s2">, </span><span class="s1">param</span><span class="s2">, </span><span class="s1">case</span>
    <span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Tests for pdf and cdf where loc, scale are different from 0, 1 
        &quot;&quot;&quot;</span>

        <span class="s1">uname = platform.uname()</span>
        <span class="s1">is_linux_32 = uname.system == </span><span class="s5">'Linux' </span><span class="s2">and </span><span class="s5">&quot;32bit&quot; </span><span class="s2">in </span><span class="s1">platform.architecture()[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s3"># Test seems to be unstable (see gh-17839 for a bug report on Debian</span>
        <span class="s3"># i386), so skip it.</span>
        <span class="s2">if </span><span class="s1">is_linux_32 </span><span class="s2">and </span><span class="s1">case == </span><span class="s5">'pdf'</span><span class="s1">:</span>
            <span class="s1">pytest.skip(</span><span class="s5">&quot;Test unstable on some platforms; see gh-17839, 17859&quot;</span><span class="s1">)</span>

        <span class="s1">data = nolan_loc_scale_sample_data</span>
        <span class="s3"># We only test against piecewise as location/scale transforms</span>
        <span class="s3"># are same for other methods.</span>
        <span class="s1">stats.levy_stable.cdf_default_method = </span><span class="s5">&quot;piecewise&quot;</span>
        <span class="s1">stats.levy_stable.pdf_default_method = </span><span class="s5">&quot;piecewise&quot;</span>

        <span class="s1">subdata = data[data[</span><span class="s5">&quot;param&quot;</span><span class="s1">] == param]</span>
        <span class="s1">stats.levy_stable.parameterization = </span><span class="s5">f&quot;S</span><span class="s2">{</span><span class="s1">param</span><span class="s2">}</span><span class="s5">&quot;</span>

        <span class="s2">assert </span><span class="s1">case </span><span class="s2">in </span><span class="s1">[</span><span class="s5">&quot;pdf&quot;</span><span class="s2">, </span><span class="s5">&quot;cdf&quot;</span><span class="s1">]</span>
        <span class="s1">function = (</span>
            <span class="s1">stats.levy_stable.pdf </span><span class="s2">if </span><span class="s1">case == </span><span class="s5">&quot;pdf&quot; </span><span class="s2">else </span><span class="s1">stats.levy_stable.cdf</span>
        <span class="s1">)</span>

        <span class="s1">v1 = function(</span>
            <span class="s1">subdata[</span><span class="s5">'x'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">subdata[</span><span class="s5">'alpha'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">subdata[</span><span class="s5">'beta'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">3</span>
        <span class="s1">)</span>
        <span class="s1">assert_allclose(v1</span><span class="s2">, </span><span class="s1">subdata[case]</span><span class="s2">, </span><span class="s4">1e-5</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s5">&quot;method,decimal_places&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">[</span><span class="s5">'dni'</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s5">'piecewise'</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_pdf_alpha_equals_one_beta_non_zero(self</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">decimal_places):</span>
        <span class="s0">&quot;&quot;&quot; sample points extracted from Tables and Graphs of Stable 
        Probability Density Functions - Donald R Holt - 1973 - p 187. 
        &quot;&quot;&quot;</span>
        <span class="s1">xs = np.array(</span>
            <span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">density = np.array(</span>
            <span class="s1">[</span>
                <span class="s4">.3183</span><span class="s2">, </span><span class="s4">.3096</span><span class="s2">, </span><span class="s4">.2925</span><span class="s2">, </span><span class="s4">.2622</span><span class="s2">, </span><span class="s4">.1591</span><span class="s2">, </span><span class="s4">.1587</span><span class="s2">, </span><span class="s4">.1599</span><span class="s2">, </span><span class="s4">.1635</span><span class="s2">, </span><span class="s4">.0637</span><span class="s2">,</span>
                <span class="s4">.0729</span><span class="s2">, </span><span class="s4">.0812</span><span class="s2">, </span><span class="s4">.0955</span><span class="s2">, </span><span class="s4">.0318</span><span class="s2">, </span><span class="s4">.0390</span><span class="s2">, </span><span class="s4">.0458</span><span class="s2">, </span><span class="s4">.0586</span><span class="s2">, </span><span class="s4">.0187</span><span class="s2">, </span><span class="s4">.0236</span><span class="s2">,</span>
                <span class="s4">.0285</span><span class="s2">, </span><span class="s4">.0384</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s1">betas = np.array(</span>
            <span class="s1">[</span>
                <span class="s4">0</span><span class="s2">, </span><span class="s4">.25</span><span class="s2">, </span><span class="s4">.5</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">.25</span><span class="s2">, </span><span class="s4">.5</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">.25</span><span class="s2">, </span><span class="s4">.5</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">.25</span><span class="s2">, </span><span class="s4">.5</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">,</span>
                <span class="s4">.25</span><span class="s2">, </span><span class="s4">.5</span><span class="s2">, </span><span class="s4">1</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s2">with </span><span class="s1">np.errstate(all=</span><span class="s5">'ignore'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">suppress_warnings() </span><span class="s2">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(</span>
                <span class="s1">category=RuntimeWarning</span><span class="s2">,</span>
                <span class="s1">message=</span><span class="s5">&quot;Density calculation unstable.*&quot;</span>
            <span class="s1">)</span>
            <span class="s1">stats.levy_stable.pdf_default_method = method</span>
            <span class="s3"># stats.levy_stable.fft_grid_spacing = 0.0001</span>
            <span class="s1">pdf = stats.levy_stable.pdf(xs</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">betas</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">0</span><span class="s1">)</span>
            <span class="s1">assert_almost_equal(</span>
                <span class="s1">pdf</span><span class="s2">, </span><span class="s1">density</span><span class="s2">, </span><span class="s1">decimal_places</span><span class="s2">, </span><span class="s1">method</span>
            <span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s5">&quot;params,expected&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">[(</span><span class="s4">1.48</span><span class="s2">, </span><span class="s1">-</span><span class="s4">.22</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">np.inf</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan)]</span><span class="s2">,</span>
            <span class="s1">[(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">.9</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">1.5</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">10</span><span class="s2">, </span><span class="s4">4.5</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)]</span>
        <span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_stats(self</span><span class="s2">, </span><span class="s1">params</span><span class="s2">, </span><span class="s1">expected):</span>
        <span class="s1">observed = stats.levy_stable.stats(</span>
            <span class="s1">params[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">params[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">loc=params[</span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">scale=params[</span><span class="s4">3</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">moments=</span><span class="s5">'mvsk'</span>
        <span class="s1">)</span>
        <span class="s1">assert_almost_equal(observed</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'alpha'</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.25</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.75</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s5">'function,beta,points,expected'</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span>
                <span class="s1">stats.levy_stable.cdf</span><span class="s2">,</span>
                <span class="s4">1.0</span><span class="s2">,</span>
                <span class="s1">np.linspace(-</span><span class="s4">25</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s4">0.0</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span>
                <span class="s1">stats.levy_stable.pdf</span><span class="s2">,</span>
                <span class="s4">1.0</span><span class="s2">,</span>
                <span class="s1">np.linspace(-</span><span class="s4">25</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s4">0.0</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span>
                <span class="s1">stats.levy_stable.cdf</span><span class="s2">,</span>
                <span class="s1">-</span><span class="s4">1.0</span><span class="s2">,</span>
                <span class="s1">np.linspace(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">25</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s4">1.0</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span>
                <span class="s1">stats.levy_stable.pdf</span><span class="s2">,</span>
                <span class="s1">-</span><span class="s4">1.0</span><span class="s2">,</span>
                <span class="s1">np.linspace(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">25</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span><span class="s2">,</span>
                <span class="s4">0.0</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_distribution_outside_support(</span>
            <span class="s1">self</span><span class="s2">, </span><span class="s1">alpha</span><span class="s2">, </span><span class="s1">function</span><span class="s2">, </span><span class="s1">beta</span><span class="s2">, </span><span class="s1">points</span><span class="s2">, </span><span class="s1">expected</span>
    <span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Ensure the pdf/cdf routines do not return nan outside support. 
 
        This distribution's support becomes truncated in a few special cases: 
            support is [mu, infty) if alpha &lt; 1 and beta = 1 
            support is (-infty, mu] if alpha &lt; 1 and beta = -1 
        Otherwise, the support is all reals. Here, mu is zero by default. 
        &quot;&quot;&quot;</span>
        <span class="s2">assert </span><span class="s4">0 </span><span class="s1">&lt; alpha &lt; </span><span class="s4">1</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">function(points</span><span class="s2">, </span><span class="s1">alpha=alpha</span><span class="s2">, </span><span class="s1">beta=beta)</span><span class="s2">,</span>
            <span class="s1">np.full(len(points)</span><span class="s2">, </span><span class="s1">expected)</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestArrayArgument:  </span><span class="s3"># test for ticket:992</span>
    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">np.random.seed(</span><span class="s4">1234</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_noexception(self):</span>
        <span class="s1">rvs = stats.norm.rvs(loc=(np.arange(</span><span class="s4">5</span><span class="s1">))</span><span class="s2">, </span><span class="s1">scale=np.ones(</span><span class="s4">5</span><span class="s1">)</span><span class="s2">,</span>
                             <span class="s1">size=(</span><span class="s4">10</span><span class="s2">, </span><span class="s4">5</span><span class="s1">))</span>
        <span class="s1">assert_equal(rvs.shape</span><span class="s2">, </span><span class="s1">(</span><span class="s4">10</span><span class="s2">, </span><span class="s4">5</span><span class="s1">))</span>


<span class="s2">class </span><span class="s1">TestDocstring:</span>
    <span class="s2">def </span><span class="s1">test_docstrings(self):</span>
        <span class="s3"># See ticket #761</span>
        <span class="s2">if </span><span class="s1">stats.rayleigh.__doc__ </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">assert_(</span><span class="s5">&quot;rayleigh&quot; </span><span class="s2">in </span><span class="s1">stats.rayleigh.__doc__.lower())</span>
        <span class="s2">if </span><span class="s1">stats.bernoulli.__doc__ </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">assert_(</span><span class="s5">&quot;bernoulli&quot; </span><span class="s2">in </span><span class="s1">stats.bernoulli.__doc__.lower())</span>

    <span class="s2">def </span><span class="s1">test_no_name_arg(self):</span>
        <span class="s3"># If name is not given, construction shouldn't fail.  See #1508.</span>
        <span class="s1">stats.rv_continuous()</span>
        <span class="s1">stats.rv_discrete()</span>


<span class="s2">def </span><span class="s1">test_args_reduce():</span>
    <span class="s1">a = array([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s1">])</span>
    <span class="s1">b</span><span class="s2">, </span><span class="s1">c = argsreduce(a &gt; </span><span class="s4">1</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>

    <span class="s1">assert_array_equal(b</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(c</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2</span><span class="s1">])</span>

    <span class="s1">b</span><span class="s2">, </span><span class="s1">c = argsreduce(</span><span class="s4">2 </span><span class="s1">&gt; </span><span class="s4">1</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">assert_array_equal(b</span><span class="s2">, </span><span class="s1">a)</span>
    <span class="s1">assert_array_equal(c</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2</span><span class="s1">] * np.size(a))</span>

    <span class="s1">b</span><span class="s2">, </span><span class="s1">c = argsreduce(a &gt; </span><span class="s4">0</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">assert_array_equal(b</span><span class="s2">, </span><span class="s1">a)</span>
    <span class="s1">assert_array_equal(c</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2</span><span class="s1">] * np.size(a))</span>


<span class="s2">class </span><span class="s1">TestFitMethod:</span>
    <span class="s1">skip = [</span><span class="s5">'ncf'</span><span class="s2">, </span><span class="s5">'ksone'</span><span class="s2">, </span><span class="s5">'kstwo'</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">np.random.seed(</span><span class="s4">1234</span><span class="s1">)</span>

    <span class="s3"># skip these b/c deprecated, or only loc and scale arguments</span>
    <span class="s1">fitSkipNonFinite = [</span><span class="s5">'expon'</span><span class="s2">, </span><span class="s5">'norm'</span><span class="s2">, </span><span class="s5">'uniform'</span><span class="s1">]</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'dist,args'</span><span class="s2">, </span><span class="s1">distcont)</span>
    <span class="s2">def </span><span class="s1">test_fit_w_non_finite_data_values(self</span><span class="s2">, </span><span class="s1">dist</span><span class="s2">, </span><span class="s1">args):</span>
        <span class="s0">&quot;&quot;&quot;gh-10300&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">dist </span><span class="s2">in </span><span class="s1">self.fitSkipNonFinite:</span>
            <span class="s1">pytest.skip(</span><span class="s5">&quot;%s fit known to fail or deprecated&quot; </span><span class="s1">% dist)</span>
        <span class="s1">x = np.array([</span><span class="s4">1.6483</span><span class="s2">, </span><span class="s4">2.7169</span><span class="s2">, </span><span class="s4">2.4667</span><span class="s2">, </span><span class="s4">1.1791</span><span class="s2">, </span><span class="s4">3.5433</span><span class="s2">, </span><span class="s1">np.nan])</span>
        <span class="s1">y = np.array([</span><span class="s4">1.6483</span><span class="s2">, </span><span class="s4">2.7169</span><span class="s2">, </span><span class="s4">2.4667</span><span class="s2">, </span><span class="s4">1.1791</span><span class="s2">, </span><span class="s4">3.5433</span><span class="s2">, </span><span class="s1">np.inf])</span>
        <span class="s1">distfunc = getattr(stats</span><span class="s2">, </span><span class="s1">dist)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">distfunc.fit</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">fscale=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">distfunc.fit</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">fscale=</span><span class="s4">1</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_fix_fit_2args_lognorm(self):</span>
        <span class="s3"># Regression test for #1551.</span>
        <span class="s1">np.random.seed(</span><span class="s4">12345</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">np.errstate(all=</span><span class="s5">'ignore'</span><span class="s1">):</span>
            <span class="s1">x = stats.lognorm.rvs(</span><span class="s4">0.25</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">20.0</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">20</span><span class="s1">)</span>
            <span class="s1">expected_shape = np.sqrt(((np.log(x) - np.log(</span><span class="s4">20</span><span class="s1">))**</span><span class="s4">2</span><span class="s1">).mean())</span>
            <span class="s1">assert_allclose(np.array(stats.lognorm.fit(x</span><span class="s2">, </span><span class="s1">floc=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">fscale=</span><span class="s4">20</span><span class="s1">))</span><span class="s2">,</span>
                            <span class="s1">[expected_shape</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">20</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-8</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_fix_fit_norm(self):</span>
        <span class="s1">x = np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">6</span><span class="s1">)</span>

        <span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = stats.norm.fit(x)</span>
        <span class="s1">assert_almost_equal(loc</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(scale</span><span class="s2">, </span><span class="s1">np.sqrt(</span><span class="s4">2</span><span class="s1">))</span>

        <span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = stats.norm.fit(x</span><span class="s2">, </span><span class="s1">floc=</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">assert_equal(loc</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">assert_equal(scale</span><span class="s2">, </span><span class="s1">np.sqrt(</span><span class="s4">3</span><span class="s1">))</span>

        <span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = stats.norm.fit(x</span><span class="s2">, </span><span class="s1">fscale=</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(loc</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">assert_equal(scale</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_fix_fit_gamma(self):</span>
        <span class="s1">x = np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">6</span><span class="s1">)</span>
        <span class="s1">meanlog = np.log(x).mean()</span>

        <span class="s3"># A basic test of gamma.fit with floc=0.</span>
        <span class="s1">floc = </span><span class="s4">0</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = stats.gamma.fit(x</span><span class="s2">, </span><span class="s1">floc=floc)</span>
        <span class="s1">s = np.log(x.mean()) - meanlog</span>
        <span class="s1">assert_almost_equal(np.log(a) - special.digamma(a)</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">5</span><span class="s1">)</span>
        <span class="s1">assert_equal(loc</span><span class="s2">, </span><span class="s1">floc)</span>
        <span class="s1">assert_almost_equal(scale</span><span class="s2">, </span><span class="s1">x.mean()/a</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">8</span><span class="s1">)</span>

        <span class="s3"># Regression tests for gh-2514.</span>
        <span class="s3"># The problem was that if `floc=0` was given, any other fixed</span>
        <span class="s3"># parameters were ignored.</span>
        <span class="s1">f0 = </span><span class="s4">1</span>
        <span class="s1">floc = </span><span class="s4">0</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = stats.gamma.fit(x</span><span class="s2">, </span><span class="s1">f0=f0</span><span class="s2">, </span><span class="s1">floc=floc)</span>
        <span class="s1">assert_equal(a</span><span class="s2">, </span><span class="s1">f0)</span>
        <span class="s1">assert_equal(loc</span><span class="s2">, </span><span class="s1">floc)</span>
        <span class="s1">assert_almost_equal(scale</span><span class="s2">, </span><span class="s1">x.mean()/a</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">8</span><span class="s1">)</span>

        <span class="s1">f0 = </span><span class="s4">2</span>
        <span class="s1">floc = </span><span class="s4">0</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = stats.gamma.fit(x</span><span class="s2">, </span><span class="s1">f0=f0</span><span class="s2">, </span><span class="s1">floc=floc)</span>
        <span class="s1">assert_equal(a</span><span class="s2">, </span><span class="s1">f0)</span>
        <span class="s1">assert_equal(loc</span><span class="s2">, </span><span class="s1">floc)</span>
        <span class="s1">assert_almost_equal(scale</span><span class="s2">, </span><span class="s1">x.mean()/a</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">8</span><span class="s1">)</span>

        <span class="s3"># loc and scale fixed.</span>
        <span class="s1">floc = </span><span class="s4">0</span>
        <span class="s1">fscale = </span><span class="s4">2</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = stats.gamma.fit(x</span><span class="s2">, </span><span class="s1">floc=floc</span><span class="s2">, </span><span class="s1">fscale=fscale)</span>
        <span class="s1">assert_equal(loc</span><span class="s2">, </span><span class="s1">floc)</span>
        <span class="s1">assert_equal(scale</span><span class="s2">, </span><span class="s1">fscale)</span>
        <span class="s1">c = meanlog - np.log(fscale)</span>
        <span class="s1">assert_almost_equal(special.digamma(a)</span><span class="s2">, </span><span class="s1">c)</span>

    <span class="s2">def </span><span class="s1">test_fix_fit_beta(self):</span>
        <span class="s3"># Test beta.fit when both floc and fscale are given.</span>

        <span class="s2">def </span><span class="s1">mlefunc(a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">x):</span>
            <span class="s3"># Zeros of this function are critical points of</span>
            <span class="s3"># the maximum likelihood function.</span>
            <span class="s1">n = len(x)</span>
            <span class="s1">s1 = np.log(x).sum()</span>
            <span class="s1">s2 = np.log(</span><span class="s4">1</span><span class="s1">-x).sum()</span>
            <span class="s1">psiab = special.psi(a + b)</span>
            <span class="s1">func = [s1 - n * (-psiab + special.psi(a))</span><span class="s2">,</span>
                    <span class="s1">s2 - n * (-psiab + special.psi(b))]</span>
            <span class="s2">return </span><span class="s1">func</span>

        <span class="s3"># Basic test with floc and fscale given.</span>
        <span class="s1">x = np.array([</span><span class="s4">0.125</span><span class="s2">, </span><span class="s4">0.25</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">])</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = stats.beta.fit(x</span><span class="s2">, </span><span class="s1">floc=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">fscale=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(loc</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_equal(scale</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(mlefunc(a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">x)</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-6</span><span class="s1">)</span>

        <span class="s3"># Basic test with f0, floc and fscale given.</span>
        <span class="s3"># This is also a regression test for gh-2514.</span>
        <span class="s1">x = np.array([</span><span class="s4">0.125</span><span class="s2">, </span><span class="s4">0.25</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">])</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = stats.beta.fit(x</span><span class="s2">, </span><span class="s1">f0=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">floc=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">fscale=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(a</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">assert_equal(loc</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_equal(scale</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">da</span><span class="s2">, </span><span class="s1">db = mlefunc(a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">x)</span>
        <span class="s1">assert_allclose(db</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-5</span><span class="s1">)</span>

        <span class="s3"># Same floc and fscale values as above, but reverse the data</span>
        <span class="s3"># and fix b (f1).</span>
        <span class="s1">x2 = </span><span class="s4">1 </span><span class="s1">- x</span>
        <span class="s1">a2</span><span class="s2">, </span><span class="s1">b2</span><span class="s2">, </span><span class="s1">loc2</span><span class="s2">, </span><span class="s1">scale2 = stats.beta.fit(x2</span><span class="s2">, </span><span class="s1">f1=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">floc=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">fscale=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(b2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">assert_equal(loc2</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_equal(scale2</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">da</span><span class="s2">, </span><span class="s1">db = mlefunc(a2</span><span class="s2">, </span><span class="s1">b2</span><span class="s2">, </span><span class="s1">x2)</span>
        <span class="s1">assert_allclose(da</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-5</span><span class="s1">)</span>
        <span class="s3"># a2 of this test should equal b from above.</span>
        <span class="s1">assert_almost_equal(a2</span><span class="s2">, </span><span class="s1">b)</span>

        <span class="s3"># Check for detection of data out of bounds when floc and fscale</span>
        <span class="s3"># are given.</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.beta.fit</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">floc=</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">fscale=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">y = np.array([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">.5</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.beta.fit</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">floc=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">fscale=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.beta.fit</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">floc=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">fscale=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">f0=</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.beta.fit</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">floc=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">fscale=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">f1=</span><span class="s4">2</span><span class="s1">)</span>

        <span class="s3"># Check that attempting to fix all the parameters raises a ValueError.</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.beta.fit</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">f0=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">f1=</span><span class="s4">1</span><span class="s2">,</span>
                      <span class="s1">floc=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">fscale=</span><span class="s4">3</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_expon_fit(self):</span>
        <span class="s1">x = np.array([</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">8</span><span class="s1">])</span>

        <span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = stats.expon.fit(x)</span>
        <span class="s1">assert_equal(loc</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)    </span><span class="s3"># x.min()</span>
        <span class="s1">assert_equal(scale</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)  </span><span class="s3"># x.mean() - x.min()</span>

        <span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = stats.expon.fit(x</span><span class="s2">, </span><span class="s1">fscale=</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">assert_equal(loc</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)    </span><span class="s3"># x.min()</span>
        <span class="s1">assert_equal(scale</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)  </span><span class="s3"># fscale</span>

        <span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = stats.expon.fit(x</span><span class="s2">, </span><span class="s1">floc=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_equal(loc</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)    </span><span class="s3"># floc</span>
        <span class="s1">assert_equal(scale</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)  </span><span class="s3"># x.mean() - loc</span>

    <span class="s2">def </span><span class="s1">test_lognorm_fit(self):</span>
        <span class="s1">x = np.array([</span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">15</span><span class="s2">, </span><span class="s4">23</span><span class="s2">, </span><span class="s4">59</span><span class="s1">])</span>
        <span class="s1">lnxm1 = np.log(x - </span><span class="s4">1</span><span class="s1">)</span>

        <span class="s1">shape</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = stats.lognorm.fit(x</span><span class="s2">, </span><span class="s1">floc=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(shape</span><span class="s2">, </span><span class="s1">lnxm1.std()</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-12</span><span class="s1">)</span>
        <span class="s1">assert_equal(loc</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(scale</span><span class="s2">, </span><span class="s1">np.exp(lnxm1.mean())</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-12</span><span class="s1">)</span>

        <span class="s1">shape</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = stats.lognorm.fit(x</span><span class="s2">, </span><span class="s1">floc=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">fscale=</span><span class="s4">6</span><span class="s1">)</span>
        <span class="s1">assert_allclose(shape</span><span class="s2">, </span><span class="s1">np.sqrt(((lnxm1 - np.log(</span><span class="s4">6</span><span class="s1">))**</span><span class="s4">2</span><span class="s1">).mean())</span><span class="s2">,</span>
                        <span class="s1">rtol=</span><span class="s4">1e-12</span><span class="s1">)</span>
        <span class="s1">assert_equal(loc</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(scale</span><span class="s2">, </span><span class="s4">6</span><span class="s1">)</span>

        <span class="s1">shape</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = stats.lognorm.fit(x</span><span class="s2">, </span><span class="s1">floc=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">fix_s=</span><span class="s4">0.75</span><span class="s1">)</span>
        <span class="s1">assert_equal(shape</span><span class="s2">, </span><span class="s4">0.75</span><span class="s1">)</span>
        <span class="s1">assert_equal(loc</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(scale</span><span class="s2">, </span><span class="s1">np.exp(lnxm1.mean())</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-12</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_uniform_fit(self):</span>
        <span class="s1">x = np.array([</span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">1.1</span><span class="s2">, </span><span class="s4">1.2</span><span class="s2">, </span><span class="s4">9.0</span><span class="s1">])</span>

        <span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = stats.uniform.fit(x)</span>
        <span class="s1">assert_equal(loc</span><span class="s2">, </span><span class="s1">x.min())</span>
        <span class="s1">assert_equal(scale</span><span class="s2">, </span><span class="s1">x.ptp())</span>

        <span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = stats.uniform.fit(x</span><span class="s2">, </span><span class="s1">floc=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_equal(loc</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_equal(scale</span><span class="s2">, </span><span class="s1">x.max())</span>

        <span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = stats.uniform.fit(x</span><span class="s2">, </span><span class="s1">fscale=</span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">assert_equal(loc</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_equal(scale</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span>

        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.uniform.fit</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">floc=</span><span class="s4">2.0</span><span class="s1">)</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.uniform.fit</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">fscale=</span><span class="s4">5.0</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;method&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s5">&quot;MLE&quot;</span><span class="s2">, </span><span class="s5">&quot;MM&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_fshapes(self</span><span class="s2">, </span><span class="s1">method):</span>
        <span class="s3"># take a beta distribution, with shapes='a, b', and make sure that</span>
        <span class="s3"># fa is equivalent to f0, and fb is equivalent to f1</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">b = </span><span class="s4">3.</span><span class="s2">, </span><span class="s4">4.</span>
        <span class="s1">x = stats.beta.rvs(a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">100</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s4">1234</span><span class="s1">)</span>
        <span class="s1">res_1 = stats.beta.fit(x</span><span class="s2">, </span><span class="s1">f0=</span><span class="s4">3.</span><span class="s2">, </span><span class="s1">method=method)</span>
        <span class="s1">res_2 = stats.beta.fit(x</span><span class="s2">, </span><span class="s1">fa=</span><span class="s4">3.</span><span class="s2">, </span><span class="s1">method=method)</span>
        <span class="s1">assert_allclose(res_1</span><span class="s2">, </span><span class="s1">res_2</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-12</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-12</span><span class="s1">)</span>

        <span class="s1">res_2 = stats.beta.fit(x</span><span class="s2">, </span><span class="s1">fix_a=</span><span class="s4">3.</span><span class="s2">, </span><span class="s1">method=method)</span>
        <span class="s1">assert_allclose(res_1</span><span class="s2">, </span><span class="s1">res_2</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-12</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-12</span><span class="s1">)</span>

        <span class="s1">res_3 = stats.beta.fit(x</span><span class="s2">, </span><span class="s1">f1=</span><span class="s4">4.</span><span class="s2">, </span><span class="s1">method=method)</span>
        <span class="s1">res_4 = stats.beta.fit(x</span><span class="s2">, </span><span class="s1">fb=</span><span class="s4">4.</span><span class="s2">, </span><span class="s1">method=method)</span>
        <span class="s1">assert_allclose(res_3</span><span class="s2">, </span><span class="s1">res_4</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-12</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-12</span><span class="s1">)</span>

        <span class="s1">res_4 = stats.beta.fit(x</span><span class="s2">, </span><span class="s1">fix_b=</span><span class="s4">4.</span><span class="s2">, </span><span class="s1">method=method)</span>
        <span class="s1">assert_allclose(res_3</span><span class="s2">, </span><span class="s1">res_4</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-12</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-12</span><span class="s1">)</span>

        <span class="s3"># cannot specify both positional and named args at the same time</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.beta.fit</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">fa=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">f0=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">method=method)</span>

        <span class="s3"># check that attempting to fix all parameters raises a ValueError</span>
        <span class="s1">assert_raises(ValueError</span><span class="s2">, </span><span class="s1">stats.beta.fit</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">fa=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">f1=</span><span class="s4">1</span><span class="s2">,</span>
                      <span class="s1">floc=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">fscale=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">method=method)</span>

        <span class="s3"># check that specifying floc, fscale and fshapes works for</span>
        <span class="s3"># beta and gamma which override the generic fit method</span>
        <span class="s1">res_5 = stats.beta.fit(x</span><span class="s2">, </span><span class="s1">fa=</span><span class="s4">3.</span><span class="s2">, </span><span class="s1">floc=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">fscale=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">method=method)</span>
        <span class="s1">aa</span><span class="s2">, </span><span class="s1">bb</span><span class="s2">, </span><span class="s1">ll</span><span class="s2">, </span><span class="s1">ss = res_5</span>
        <span class="s1">assert_equal([aa</span><span class="s2">, </span><span class="s1">ll</span><span class="s2">, </span><span class="s1">ss]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3.</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>

        <span class="s3"># gamma distribution</span>
        <span class="s1">a = </span><span class="s4">3.</span>
        <span class="s1">data = stats.gamma.rvs(a</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">100</span><span class="s1">)</span>
        <span class="s1">aa</span><span class="s2">, </span><span class="s1">ll</span><span class="s2">, </span><span class="s1">ss = stats.gamma.fit(data</span><span class="s2">, </span><span class="s1">fa=a</span><span class="s2">, </span><span class="s1">method=method)</span>
        <span class="s1">assert_equal(aa</span><span class="s2">, </span><span class="s1">a)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;method&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s5">&quot;MLE&quot;</span><span class="s2">, </span><span class="s5">&quot;MM&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_extra_params(self</span><span class="s2">, </span><span class="s1">method):</span>
        <span class="s3"># unknown parameters should raise rather than be silently ignored</span>
        <span class="s1">dist = stats.exponnorm</span>
        <span class="s1">data = dist.rvs(K=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">100</span><span class="s1">)</span>
        <span class="s1">dct = dict(enikibeniki=-</span><span class="s4">101</span><span class="s1">)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s2">, </span><span class="s1">dist.fit</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">**dct</span><span class="s2">, </span><span class="s1">method=method)</span>


<span class="s2">class </span><span class="s1">TestFrozen:</span>
    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">np.random.seed(</span><span class="s4">1234</span><span class="s1">)</span>

    <span class="s3"># Test that a frozen distribution gives the same results as the original</span>
    <span class="s3"># object.</span>
    <span class="s3">#</span>
    <span class="s3"># Only tested for the normal distribution (with loc and scale specified)</span>
    <span class="s3"># and for the gamma distribution (with a shape parameter specified).</span>
    <span class="s2">def </span><span class="s1">test_norm(self):</span>
        <span class="s1">dist = stats.norm</span>
        <span class="s1">frozen = stats.norm(loc=</span><span class="s4">10.0</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">3.0</span><span class="s1">)</span>

        <span class="s1">result_f = frozen.pdf(</span><span class="s4">20.0</span><span class="s1">)</span>
        <span class="s1">result = dist.pdf(</span><span class="s4">20.0</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">10.0</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">3.0</span><span class="s1">)</span>
        <span class="s1">assert_equal(result_f</span><span class="s2">, </span><span class="s1">result)</span>

        <span class="s1">result_f = frozen.cdf(</span><span class="s4">20.0</span><span class="s1">)</span>
        <span class="s1">result = dist.cdf(</span><span class="s4">20.0</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">10.0</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">3.0</span><span class="s1">)</span>
        <span class="s1">assert_equal(result_f</span><span class="s2">, </span><span class="s1">result)</span>

        <span class="s1">result_f = frozen.ppf(</span><span class="s4">0.25</span><span class="s1">)</span>
        <span class="s1">result = dist.ppf(</span><span class="s4">0.25</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">10.0</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">3.0</span><span class="s1">)</span>
        <span class="s1">assert_equal(result_f</span><span class="s2">, </span><span class="s1">result)</span>

        <span class="s1">result_f = frozen.isf(</span><span class="s4">0.25</span><span class="s1">)</span>
        <span class="s1">result = dist.isf(</span><span class="s4">0.25</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">10.0</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">3.0</span><span class="s1">)</span>
        <span class="s1">assert_equal(result_f</span><span class="s2">, </span><span class="s1">result)</span>

        <span class="s1">result_f = frozen.sf(</span><span class="s4">10.0</span><span class="s1">)</span>
        <span class="s1">result = dist.sf(</span><span class="s4">10.0</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">10.0</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">3.0</span><span class="s1">)</span>
        <span class="s1">assert_equal(result_f</span><span class="s2">, </span><span class="s1">result)</span>

        <span class="s1">result_f = frozen.median()</span>
        <span class="s1">result = dist.median(loc=</span><span class="s4">10.0</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">3.0</span><span class="s1">)</span>
        <span class="s1">assert_equal(result_f</span><span class="s2">, </span><span class="s1">result)</span>

        <span class="s1">result_f = frozen.mean()</span>
        <span class="s1">result = dist.mean(loc=</span><span class="s4">10.0</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">3.0</span><span class="s1">)</span>
        <span class="s1">assert_equal(result_f</span><span class="s2">, </span><span class="s1">result)</span>

        <span class="s1">result_f = frozen.var()</span>
        <span class="s1">result = dist.var(loc=</span><span class="s4">10.0</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">3.0</span><span class="s1">)</span>
        <span class="s1">assert_equal(result_f</span><span class="s2">, </span><span class="s1">result)</span>

        <span class="s1">result_f = frozen.std()</span>
        <span class="s1">result = dist.std(loc=</span><span class="s4">10.0</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">3.0</span><span class="s1">)</span>
        <span class="s1">assert_equal(result_f</span><span class="s2">, </span><span class="s1">result)</span>

        <span class="s1">result_f = frozen.entropy()</span>
        <span class="s1">result = dist.entropy(loc=</span><span class="s4">10.0</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">3.0</span><span class="s1">)</span>
        <span class="s1">assert_equal(result_f</span><span class="s2">, </span><span class="s1">result)</span>

        <span class="s1">result_f = frozen.moment(</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">result = dist.moment(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">10.0</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">3.0</span><span class="s1">)</span>
        <span class="s1">assert_equal(result_f</span><span class="s2">, </span><span class="s1">result)</span>

        <span class="s1">assert_equal(frozen.a</span><span class="s2">, </span><span class="s1">dist.a)</span>
        <span class="s1">assert_equal(frozen.b</span><span class="s2">, </span><span class="s1">dist.b)</span>

    <span class="s2">def </span><span class="s1">test_gamma(self):</span>
        <span class="s1">a = </span><span class="s4">2.0</span>
        <span class="s1">dist = stats.gamma</span>
        <span class="s1">frozen = stats.gamma(a)</span>

        <span class="s1">result_f = frozen.pdf(</span><span class="s4">20.0</span><span class="s1">)</span>
        <span class="s1">result = dist.pdf(</span><span class="s4">20.0</span><span class="s2">, </span><span class="s1">a)</span>
        <span class="s1">assert_equal(result_f</span><span class="s2">, </span><span class="s1">result)</span>

        <span class="s1">result_f = frozen.cdf(</span><span class="s4">20.0</span><span class="s1">)</span>
        <span class="s1">result = dist.cdf(</span><span class="s4">20.0</span><span class="s2">, </span><span class="s1">a)</span>
        <span class="s1">assert_equal(result_f</span><span class="s2">, </span><span class="s1">result)</span>

        <span class="s1">result_f = frozen.ppf(</span><span class="s4">0.25</span><span class="s1">)</span>
        <span class="s1">result = dist.ppf(</span><span class="s4">0.25</span><span class="s2">, </span><span class="s1">a)</span>
        <span class="s1">assert_equal(result_f</span><span class="s2">, </span><span class="s1">result)</span>

        <span class="s1">result_f = frozen.isf(</span><span class="s4">0.25</span><span class="s1">)</span>
        <span class="s1">result = dist.isf(</span><span class="s4">0.25</span><span class="s2">, </span><span class="s1">a)</span>
        <span class="s1">assert_equal(result_f</span><span class="s2">, </span><span class="s1">result)</span>

        <span class="s1">result_f = frozen.sf(</span><span class="s4">10.0</span><span class="s1">)</span>
        <span class="s1">result = dist.sf(</span><span class="s4">10.0</span><span class="s2">, </span><span class="s1">a)</span>
        <span class="s1">assert_equal(result_f</span><span class="s2">, </span><span class="s1">result)</span>

        <span class="s1">result_f = frozen.median()</span>
        <span class="s1">result = dist.median(a)</span>
        <span class="s1">assert_equal(result_f</span><span class="s2">, </span><span class="s1">result)</span>

        <span class="s1">result_f = frozen.mean()</span>
        <span class="s1">result = dist.mean(a)</span>
        <span class="s1">assert_equal(result_f</span><span class="s2">, </span><span class="s1">result)</span>

        <span class="s1">result_f = frozen.var()</span>
        <span class="s1">result = dist.var(a)</span>
        <span class="s1">assert_equal(result_f</span><span class="s2">, </span><span class="s1">result)</span>

        <span class="s1">result_f = frozen.std()</span>
        <span class="s1">result = dist.std(a)</span>
        <span class="s1">assert_equal(result_f</span><span class="s2">, </span><span class="s1">result)</span>

        <span class="s1">result_f = frozen.entropy()</span>
        <span class="s1">result = dist.entropy(a)</span>
        <span class="s1">assert_equal(result_f</span><span class="s2">, </span><span class="s1">result)</span>

        <span class="s1">result_f = frozen.moment(</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">result = dist.moment(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">a)</span>
        <span class="s1">assert_equal(result_f</span><span class="s2">, </span><span class="s1">result)</span>

        <span class="s1">assert_equal(frozen.a</span><span class="s2">, </span><span class="s1">frozen.dist.a)</span>
        <span class="s1">assert_equal(frozen.b</span><span class="s2">, </span><span class="s1">frozen.dist.b)</span>

    <span class="s2">def </span><span class="s1">test_regression_ticket_1293(self):</span>
        <span class="s3"># Create a frozen distribution.</span>
        <span class="s1">frozen = stats.lognorm(</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s3"># Call one of its methods that does not take any keyword arguments.</span>
        <span class="s1">m1 = frozen.moment(</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s3"># Now call a method that takes a keyword argument.</span>
        <span class="s1">frozen.stats(moments=</span><span class="s5">'mvsk'</span><span class="s1">)</span>
        <span class="s3"># Call moment(2) again.</span>
        <span class="s3"># After calling stats(), the following was raising an exception.</span>
        <span class="s3"># So this test passes if the following does not raise an exception.</span>
        <span class="s1">m2 = frozen.moment(</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s3"># The following should also be true, of course.  But it is not</span>
        <span class="s3"># the focus of this test.</span>
        <span class="s1">assert_equal(m1</span><span class="s2">, </span><span class="s1">m2)</span>

    <span class="s2">def </span><span class="s1">test_ab(self):</span>
        <span class="s3"># test that the support of a frozen distribution</span>
        <span class="s3"># (i) remains frozen even if it changes for the original one</span>
        <span class="s3"># (ii) is actually correct if the shape parameters are such that</span>
        <span class="s3">#      the values of [a, b] are not the default [0, inf]</span>
        <span class="s3"># take a genpareto as an example where the support</span>
        <span class="s3"># depends on the value of the shape parameter:</span>
        <span class="s3"># for c &gt; 0: a, b = 0, inf</span>
        <span class="s3"># for c &lt; 0: a, b = 0, -1/c</span>

        <span class="s1">c = -</span><span class="s4">0.1</span>
        <span class="s1">rv = stats.genpareto(c=c)</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">b = rv.dist._get_support(c)</span>
        <span class="s1">assert_equal([a</span><span class="s2">, </span><span class="s1">b]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.</span><span class="s2">, </span><span class="s4">10.</span><span class="s1">])</span>

        <span class="s1">c = </span><span class="s4">0.1</span>
        <span class="s1">stats.genpareto.pdf(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">c=c)</span>
        <span class="s1">assert_equal(rv.dist._get_support(c)</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s1">np.inf])</span>

        <span class="s1">c = -</span><span class="s4">0.1</span>
        <span class="s1">rv = stats.genpareto(c=c)</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">b = rv.dist._get_support(c)</span>
        <span class="s1">assert_equal([a</span><span class="s2">, </span><span class="s1">b]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.</span><span class="s2">, </span><span class="s4">10.</span><span class="s1">])</span>

        <span class="s1">c = </span><span class="s4">0.1</span>
        <span class="s1">stats.genpareto.pdf(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">c)  </span><span class="s3"># this should NOT change genpareto.b</span>
        <span class="s1">assert_equal((rv.dist.a</span><span class="s2">, </span><span class="s1">rv.dist.b)</span><span class="s2">, </span><span class="s1">stats.genpareto._get_support(c))</span>

        <span class="s1">rv1 = stats.genpareto(c=</span><span class="s4">0.1</span><span class="s1">)</span>
        <span class="s1">assert_(rv1.dist </span><span class="s2">is not </span><span class="s1">rv.dist)</span>

        <span class="s3"># c &gt;= 0: a, b = [0, inf]</span>
        <span class="s2">for </span><span class="s1">c </span><span class="s2">in </span><span class="s1">[</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0.</span><span class="s1">]:</span>
            <span class="s1">c = np.asarray(c)</span>
            <span class="s1">rv = stats.genpareto(c=c)</span>
            <span class="s1">a</span><span class="s2">, </span><span class="s1">b = rv.a</span><span class="s2">, </span><span class="s1">rv.b</span>
            <span class="s1">assert_equal(a</span><span class="s2">, </span><span class="s4">0.</span><span class="s1">)</span>
            <span class="s1">assert_(np.isposinf(b))</span>

            <span class="s3"># c &lt; 0: a=0, b=1/|c|</span>
            <span class="s1">c = np.asarray(-</span><span class="s4">2.</span><span class="s1">)</span>
            <span class="s1">a</span><span class="s2">, </span><span class="s1">b = stats.genpareto._get_support(c)</span>
            <span class="s1">assert_allclose([a</span><span class="s2">, </span><span class="s1">b]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_rv_frozen_in_namespace(self):</span>
        <span class="s3"># Regression test for gh-3522</span>
        <span class="s1">assert_(hasattr(stats.distributions</span><span class="s2">, </span><span class="s5">'rv_frozen'</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_random_state(self):</span>
        <span class="s3"># only check that the random_state attribute exists,</span>
        <span class="s1">frozen = stats.norm()</span>
        <span class="s1">assert_(hasattr(frozen</span><span class="s2">, </span><span class="s5">'random_state'</span><span class="s1">))</span>

        <span class="s3"># ... that it can be set,</span>
        <span class="s1">frozen.random_state = </span><span class="s4">42</span>
        <span class="s1">assert_equal(frozen.random_state.get_state()</span><span class="s2">,</span>
                     <span class="s1">np.random.RandomState(</span><span class="s4">42</span><span class="s1">).get_state())</span>

        <span class="s3"># ... and that .rvs method accepts it as an argument</span>
        <span class="s1">rndm = np.random.RandomState(</span><span class="s4">1234</span><span class="s1">)</span>
        <span class="s1">frozen.rvs(size=</span><span class="s4">8</span><span class="s2">, </span><span class="s1">random_state=rndm)</span>

    <span class="s2">def </span><span class="s1">test_pickling(self):</span>
        <span class="s3"># test that a frozen instance pickles and unpickles</span>
        <span class="s3"># (this method is a clone of common_tests.check_pickling)</span>
        <span class="s1">beta = stats.beta(</span><span class="s4">2.3098496451481823</span><span class="s2">, </span><span class="s4">0.62687954300963677</span><span class="s1">)</span>
        <span class="s1">poiss = stats.poisson(</span><span class="s4">3.</span><span class="s1">)</span>
        <span class="s1">sample = stats.rv_discrete(values=([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">]</span><span class="s2">,</span>
                                           <span class="s1">[</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">0.3</span><span class="s2">, </span><span class="s4">0.4</span><span class="s1">]))</span>

        <span class="s2">for </span><span class="s1">distfn </span><span class="s2">in </span><span class="s1">[beta</span><span class="s2">, </span><span class="s1">poiss</span><span class="s2">, </span><span class="s1">sample]:</span>
            <span class="s1">distfn.random_state = </span><span class="s4">1234</span>
            <span class="s1">distfn.rvs(size=</span><span class="s4">8</span><span class="s1">)</span>
            <span class="s1">s = pickle.dumps(distfn)</span>
            <span class="s1">r0 = distfn.rvs(size=</span><span class="s4">8</span><span class="s1">)</span>

            <span class="s1">unpickled = pickle.loads(s)</span>
            <span class="s1">r1 = unpickled.rvs(size=</span><span class="s4">8</span><span class="s1">)</span>
            <span class="s1">assert_equal(r0</span><span class="s2">, </span><span class="s1">r1)</span>

            <span class="s3"># also smoke test some methods</span>
            <span class="s1">medians = [distfn.ppf(</span><span class="s4">0.5</span><span class="s1">)</span><span class="s2">, </span><span class="s1">unpickled.ppf(</span><span class="s4">0.5</span><span class="s1">)]</span>
            <span class="s1">assert_equal(medians[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">medians[</span><span class="s4">1</span><span class="s1">])</span>
            <span class="s1">assert_equal(distfn.cdf(medians[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">,</span>
                         <span class="s1">unpickled.cdf(medians[</span><span class="s4">1</span><span class="s1">]))</span>

    <span class="s2">def </span><span class="s1">test_expect(self):</span>
        <span class="s3"># smoke test the expect method of the frozen distribution</span>
        <span class="s3"># only take a gamma w/loc and scale and poisson with loc specified</span>
        <span class="s2">def </span><span class="s1">func(x):</span>
            <span class="s2">return </span><span class="s1">x</span>

        <span class="s1">gm = stats.gamma(a=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">4</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">np.errstate(invalid=</span><span class="s5">&quot;ignore&quot;</span><span class="s2">, </span><span class="s1">divide=</span><span class="s5">&quot;ignore&quot;</span><span class="s1">):</span>
            <span class="s1">gm_val = gm.expect(func</span><span class="s2">, </span><span class="s1">lb=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">ub=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">conditional=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s1">gamma_val = stats.gamma.expect(func</span><span class="s2">, </span><span class="s1">args=(</span><span class="s4">2</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">4</span><span class="s2">,</span>
                                           <span class="s1">lb=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">ub=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">conditional=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">assert_allclose(gm_val</span><span class="s2">, </span><span class="s1">gamma_val)</span>

        <span class="s1">p = stats.poisson(</span><span class="s4">3</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">p_val = p.expect(func)</span>
        <span class="s1">poisson_val = stats.poisson.expect(func</span><span class="s2">, </span><span class="s1">args=(</span><span class="s4">3</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">assert_allclose(p_val</span><span class="s2">, </span><span class="s1">poisson_val)</span>


<span class="s2">class </span><span class="s1">TestExpect:</span>
    <span class="s3"># Test for expect method.</span>
    <span class="s3">#</span>
    <span class="s3"># Uses normal distribution and beta distribution for finite bounds, and</span>
    <span class="s3"># hypergeom for discrete distribution with finite support</span>
    <span class="s2">def </span><span class="s1">test_norm(self):</span>
        <span class="s1">v = stats.norm.expect(</span><span class="s2">lambda </span><span class="s1">x: (x-</span><span class="s4">5</span><span class="s1">)*(x-</span><span class="s4">5</span><span class="s1">)</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(v</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">14</span><span class="s1">)</span>

        <span class="s1">m = stats.norm.expect(</span><span class="s2">lambda </span><span class="s1">x: (x)</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(m</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">14</span><span class="s1">)</span>

        <span class="s1">lb = stats.norm.ppf(</span><span class="s4">0.05</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">ub = stats.norm.ppf(</span><span class="s4">0.95</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">prob90 = stats.norm.expect(</span><span class="s2">lambda </span><span class="s1">x: </span><span class="s4">1</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">lb=lb</span><span class="s2">, </span><span class="s1">ub=ub)</span>
        <span class="s1">assert_almost_equal(prob90</span><span class="s2">, </span><span class="s4">0.9</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">14</span><span class="s1">)</span>

        <span class="s1">prob90c = stats.norm.expect(</span><span class="s2">lambda </span><span class="s1">x: </span><span class="s4">1</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">lb=lb</span><span class="s2">, </span><span class="s1">ub=ub</span><span class="s2">,</span>
                                    <span class="s1">conditional=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(prob90c</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">14</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_beta(self):</span>
        <span class="s3"># case with finite support interval</span>
        <span class="s1">v = stats.beta.expect(</span><span class="s2">lambda </span><span class="s1">x: (x-</span><span class="s4">19</span><span class="s1">/</span><span class="s4">3.</span><span class="s1">)*(x-</span><span class="s4">19</span><span class="s1">/</span><span class="s4">3.</span><span class="s1">)</span><span class="s2">, </span><span class="s1">args=(</span><span class="s4">10</span><span class="s2">, </span><span class="s4">5</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">loc=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(v</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">/</span><span class="s4">18.</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">13</span><span class="s1">)</span>

        <span class="s1">m = stats.beta.expect(</span><span class="s2">lambda </span><span class="s1">x: x</span><span class="s2">, </span><span class="s1">args=(</span><span class="s4">10</span><span class="s2">, </span><span class="s4">5</span><span class="s1">)</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">5.</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">2.</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(m</span><span class="s2">, </span><span class="s4">19</span><span class="s1">/</span><span class="s4">3.</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">13</span><span class="s1">)</span>

        <span class="s1">ub = stats.beta.ppf(</span><span class="s4">0.95</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">lb = stats.beta.ppf(</span><span class="s4">0.05</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">prob90 = stats.beta.expect(</span><span class="s2">lambda </span><span class="s1">x: </span><span class="s4">1.</span><span class="s2">, </span><span class="s1">args=(</span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">5.</span><span class="s2">,</span>
                                   <span class="s1">scale=</span><span class="s4">2.</span><span class="s2">, </span><span class="s1">lb=lb</span><span class="s2">, </span><span class="s1">ub=ub</span><span class="s2">, </span><span class="s1">conditional=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(prob90</span><span class="s2">, </span><span class="s4">0.9</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">13</span><span class="s1">)</span>

        <span class="s1">prob90c = stats.beta.expect(</span><span class="s2">lambda </span><span class="s1">x: </span><span class="s4">1</span><span class="s2">, </span><span class="s1">args=(</span><span class="s4">10</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">5</span><span class="s2">,</span>
                                    <span class="s1">scale=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">lb=lb</span><span class="s2">, </span><span class="s1">ub=ub</span><span class="s2">, </span><span class="s1">conditional=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(prob90c</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">13</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_hypergeom(self):</span>
        <span class="s3"># test case with finite bounds</span>

        <span class="s3"># without specifying bounds</span>
        <span class="s1">m_true</span><span class="s2">, </span><span class="s1">v_true = stats.hypergeom.stats(</span><span class="s4">20</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">5.</span><span class="s1">)</span>
        <span class="s1">m = stats.hypergeom.expect(</span><span class="s2">lambda </span><span class="s1">x: x</span><span class="s2">, </span><span class="s1">args=(</span><span class="s4">20</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">8</span><span class="s1">)</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">5.</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(m</span><span class="s2">, </span><span class="s1">m_true</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">13</span><span class="s1">)</span>

        <span class="s1">v = stats.hypergeom.expect(</span><span class="s2">lambda </span><span class="s1">x: (x-</span><span class="s4">9.</span><span class="s1">)**</span><span class="s4">2</span><span class="s2">, </span><span class="s1">args=(</span><span class="s4">20</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">8</span><span class="s1">)</span><span class="s2">,</span>
                                   <span class="s1">loc=</span><span class="s4">5.</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(v</span><span class="s2">, </span><span class="s1">v_true</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">14</span><span class="s1">)</span>

        <span class="s3"># with bounds, bounds equal to shifted support</span>
        <span class="s1">v_bounds = stats.hypergeom.expect(</span><span class="s2">lambda </span><span class="s1">x: (x-</span><span class="s4">9.</span><span class="s1">)**</span><span class="s4">2</span><span class="s2">,</span>
                                          <span class="s1">args=(</span><span class="s4">20</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">8</span><span class="s1">)</span><span class="s2">,</span>
                                          <span class="s1">loc=</span><span class="s4">5.</span><span class="s2">, </span><span class="s1">lb=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">ub=</span><span class="s4">13</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(v_bounds</span><span class="s2">, </span><span class="s1">v_true</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">14</span><span class="s1">)</span>

        <span class="s3"># drop boundary points</span>
        <span class="s1">prob_true = </span><span class="s4">1</span><span class="s1">-stats.hypergeom.pmf([</span><span class="s4">5</span><span class="s2">, </span><span class="s4">13</span><span class="s1">]</span><span class="s2">, </span><span class="s4">20</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">5</span><span class="s1">).sum()</span>
        <span class="s1">prob_bounds = stats.hypergeom.expect(</span><span class="s2">lambda </span><span class="s1">x: </span><span class="s4">1</span><span class="s2">, </span><span class="s1">args=(</span><span class="s4">20</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">8</span><span class="s1">)</span><span class="s2">,</span>
                                             <span class="s1">loc=</span><span class="s4">5.</span><span class="s2">, </span><span class="s1">lb=</span><span class="s4">6</span><span class="s2">, </span><span class="s1">ub=</span><span class="s4">12</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(prob_bounds</span><span class="s2">, </span><span class="s1">prob_true</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">13</span><span class="s1">)</span>

        <span class="s3"># conditional</span>
        <span class="s1">prob_bc = stats.hypergeom.expect(</span><span class="s2">lambda </span><span class="s1">x: </span><span class="s4">1</span><span class="s2">, </span><span class="s1">args=(</span><span class="s4">20</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">8</span><span class="s1">)</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">5.</span><span class="s2">,</span>
                                         <span class="s1">lb=</span><span class="s4">6</span><span class="s2">, </span><span class="s1">ub=</span><span class="s4">12</span><span class="s2">, </span><span class="s1">conditional=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(prob_bc</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">14</span><span class="s1">)</span>

        <span class="s3"># check simple integral</span>
        <span class="s1">prob_b = stats.hypergeom.expect(</span><span class="s2">lambda </span><span class="s1">x: </span><span class="s4">1</span><span class="s2">, </span><span class="s1">args=(</span><span class="s4">20</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">8</span><span class="s1">)</span><span class="s2">,</span>
                                        <span class="s1">lb=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">ub=</span><span class="s4">8</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(prob_b</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">13</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_poisson(self):</span>
        <span class="s3"># poisson, use lower bound only</span>
        <span class="s1">prob_bounds = stats.poisson.expect(</span><span class="s2">lambda </span><span class="s1">x: </span><span class="s4">1</span><span class="s2">, </span><span class="s1">args=(</span><span class="s4">2</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">lb=</span><span class="s4">3</span><span class="s2">,</span>
                                           <span class="s1">conditional=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">prob_b_true = </span><span class="s4">1</span><span class="s1">-stats.poisson.cdf(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(prob_bounds</span><span class="s2">, </span><span class="s1">prob_b_true</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">14</span><span class="s1">)</span>

        <span class="s1">prob_lb = stats.poisson.expect(</span><span class="s2">lambda </span><span class="s1">x: </span><span class="s4">1</span><span class="s2">, </span><span class="s1">args=(</span><span class="s4">2</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">lb=</span><span class="s4">2</span><span class="s2">,</span>
                                       <span class="s1">conditional=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(prob_lb</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">14</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_genhalflogistic(self):</span>
        <span class="s3"># genhalflogistic, changes upper bound of support in _argcheck</span>
        <span class="s3"># regression test for gh-2622</span>
        <span class="s1">halflog = stats.genhalflogistic</span>
        <span class="s3"># check consistency when calling expect twice with the same input</span>
        <span class="s1">res1 = halflog.expect(args=(</span><span class="s4">1.5</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s1">halflog.expect(args=(</span><span class="s4">0.5</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s1">res2 = halflog.expect(args=(</span><span class="s4">1.5</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s1">assert_almost_equal(res1</span><span class="s2">, </span><span class="s1">res2</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">14</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_rice_overflow(self):</span>
        <span class="s3"># rice.pdf(999, 0.74) was inf since special.i0 silentyly overflows</span>
        <span class="s3"># check that using i0e fixes it</span>
        <span class="s1">assert_(np.isfinite(stats.rice.pdf(</span><span class="s4">999</span><span class="s2">, </span><span class="s4">0.74</span><span class="s1">)))</span>

        <span class="s1">assert_(np.isfinite(stats.rice.expect(</span><span class="s2">lambda </span><span class="s1">x: </span><span class="s4">1</span><span class="s2">, </span><span class="s1">args=(</span><span class="s4">0.74</span><span class="s2">,</span><span class="s1">))))</span>
        <span class="s1">assert_(np.isfinite(stats.rice.expect(</span><span class="s2">lambda </span><span class="s1">x: </span><span class="s4">2</span><span class="s2">, </span><span class="s1">args=(</span><span class="s4">0.74</span><span class="s2">,</span><span class="s1">))))</span>
        <span class="s1">assert_(np.isfinite(stats.rice.expect(</span><span class="s2">lambda </span><span class="s1">x: </span><span class="s4">3</span><span class="s2">, </span><span class="s1">args=(</span><span class="s4">0.74</span><span class="s2">,</span><span class="s1">))))</span>

    <span class="s2">def </span><span class="s1">test_logser(self):</span>
        <span class="s3"># test a discrete distribution with infinite support and loc</span>
        <span class="s1">p</span><span class="s2">, </span><span class="s1">loc = </span><span class="s4">0.3</span><span class="s2">, </span><span class="s4">3</span>
        <span class="s1">res_0 = stats.logser.expect(</span><span class="s2">lambda </span><span class="s1">k: k</span><span class="s2">, </span><span class="s1">args=(p</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s3"># check against the correct answer (sum of a geom series)</span>
        <span class="s1">assert_allclose(res_0</span><span class="s2">,</span>
                        <span class="s1">p / (p - </span><span class="s4">1.</span><span class="s1">) / np.log(</span><span class="s4">1. </span><span class="s1">- p)</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-15</span><span class="s1">)</span>

        <span class="s3"># now check it with `loc`</span>
        <span class="s1">res_l = stats.logser.expect(</span><span class="s2">lambda </span><span class="s1">k: k</span><span class="s2">, </span><span class="s1">args=(p</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">loc=loc)</span>
        <span class="s1">assert_allclose(res_l</span><span class="s2">, </span><span class="s1">res_0 + loc</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-15</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_skellam(self):</span>
        <span class="s3"># Use a discrete distribution w/ bi-infinite support. Compute two first</span>
        <span class="s3"># moments and compare to known values (cf skellam.stats)</span>
        <span class="s1">p1</span><span class="s2">, </span><span class="s1">p2 = </span><span class="s4">18</span><span class="s2">, </span><span class="s4">22</span>
        <span class="s1">m1 = stats.skellam.expect(</span><span class="s2">lambda </span><span class="s1">x: x</span><span class="s2">, </span><span class="s1">args=(p1</span><span class="s2">, </span><span class="s1">p2))</span>
        <span class="s1">m2 = stats.skellam.expect(</span><span class="s2">lambda </span><span class="s1">x: x**</span><span class="s4">2</span><span class="s2">, </span><span class="s1">args=(p1</span><span class="s2">, </span><span class="s1">p2))</span>
        <span class="s1">assert_allclose(m1</span><span class="s2">, </span><span class="s1">p1 - p2</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-12</span><span class="s1">)</span>
        <span class="s1">assert_allclose(m2 - m1**</span><span class="s4">2</span><span class="s2">, </span><span class="s1">p1 + p2</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-12</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_randint(self):</span>
        <span class="s3"># Use a discrete distribution w/ parameter-dependent support, which</span>
        <span class="s3"># is larger than the default chunksize</span>
        <span class="s1">lo</span><span class="s2">, </span><span class="s1">hi = </span><span class="s4">0</span><span class="s2">, </span><span class="s4">113</span>
        <span class="s1">res = stats.randint.expect(</span><span class="s2">lambda </span><span class="s1">x: x</span><span class="s2">, </span><span class="s1">(lo</span><span class="s2">, </span><span class="s1">hi))</span>
        <span class="s1">assert_allclose(res</span><span class="s2">,</span>
                        <span class="s1">sum(_ </span><span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">range(lo</span><span class="s2">, </span><span class="s1">hi)) / (hi - lo)</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-15</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_zipf(self):</span>
        <span class="s3"># Test that there is no infinite loop even if the sum diverges</span>
        <span class="s1">assert_warns(RuntimeWarning</span><span class="s2">, </span><span class="s1">stats.zipf.expect</span><span class="s2">,</span>
                     <span class="s2">lambda </span><span class="s1">x: x**</span><span class="s4">2</span><span class="s2">, </span><span class="s1">(</span><span class="s4">2</span><span class="s2">,</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_discrete_kwds(self):</span>
        <span class="s3"># check that discrete expect accepts keywords to control the summation</span>
        <span class="s1">n0 = stats.poisson.expect(</span><span class="s2">lambda </span><span class="s1">x: </span><span class="s4">1</span><span class="s2">, </span><span class="s1">args=(</span><span class="s4">2</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s1">n1 = stats.poisson.expect(</span><span class="s2">lambda </span><span class="s1">x: </span><span class="s4">1</span><span class="s2">, </span><span class="s1">args=(</span><span class="s4">2</span><span class="s2">,</span><span class="s1">)</span><span class="s2">,</span>
                                  <span class="s1">maxcount=</span><span class="s4">1001</span><span class="s2">, </span><span class="s1">chunksize=</span><span class="s4">32</span><span class="s2">, </span><span class="s1">tolerance=</span><span class="s4">1e-8</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(n0</span><span class="s2">, </span><span class="s1">n1</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">14</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_moment(self):</span>
        <span class="s3"># test the .moment() method: compute a higher moment and compare to</span>
        <span class="s3"># a known value</span>
        <span class="s2">def </span><span class="s1">poiss_moment5(mu):</span>
            <span class="s2">return </span><span class="s1">mu**</span><span class="s4">5 </span><span class="s1">+ </span><span class="s4">10</span><span class="s1">*mu**</span><span class="s4">4 </span><span class="s1">+ </span><span class="s4">25</span><span class="s1">*mu**</span><span class="s4">3 </span><span class="s1">+ </span><span class="s4">15</span><span class="s1">*mu**</span><span class="s4">2 </span><span class="s1">+ mu</span>

        <span class="s2">for </span><span class="s1">mu </span><span class="s2">in </span><span class="s1">[</span><span class="s4">5</span><span class="s2">, </span><span class="s4">7</span><span class="s1">]:</span>
            <span class="s1">m5 = stats.poisson.moment(</span><span class="s4">5</span><span class="s2">, </span><span class="s1">mu)</span>
            <span class="s1">assert_allclose(m5</span><span class="s2">, </span><span class="s1">poiss_moment5(mu)</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-10</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_challenging_cases_gh8928(self):</span>
        <span class="s3"># Several cases where `expect` failed to produce a correct result were</span>
        <span class="s3"># reported in gh-8928. Check that these cases have been resolved.</span>
        <span class="s1">assert_allclose(stats.norm.expect(loc=</span><span class="s4">36</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">1.0</span><span class="s1">)</span><span class="s2">, </span><span class="s4">36</span><span class="s1">)</span>
        <span class="s1">assert_allclose(stats.norm.expect(loc=</span><span class="s4">40</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">1.0</span><span class="s1">)</span><span class="s2">, </span><span class="s4">40</span><span class="s1">)</span>
        <span class="s1">assert_allclose(stats.norm.expect(loc=</span><span class="s4">10</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">0.1</span><span class="s1">)</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">assert_allclose(stats.gamma.expect(args=(</span><span class="s4">148</span><span class="s2">,</span><span class="s1">))</span><span class="s2">, </span><span class="s4">148</span><span class="s1">)</span>
        <span class="s1">assert_allclose(stats.logistic.expect(loc=</span><span class="s4">85</span><span class="s1">)</span><span class="s2">, </span><span class="s4">85</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_lb_ub_gh15855(self):</span>
        <span class="s3"># Make sure changes to `expect` made in gh15855 treat lb/ub correctly</span>
        <span class="s1">dist = stats.uniform</span>
        <span class="s1">ref = dist.mean(loc=</span><span class="s4">10</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">5</span><span class="s1">)  </span><span class="s3"># 12.5</span>
        <span class="s3"># moment over whole distribution</span>
        <span class="s1">assert_allclose(dist.expect(loc=</span><span class="s4">10</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">5</span><span class="s1">)</span><span class="s2">, </span><span class="s1">ref)</span>
        <span class="s3"># moment over whole distribution, lb and ub outside of support</span>
        <span class="s1">assert_allclose(dist.expect(loc=</span><span class="s4">10</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">lb=</span><span class="s4">9</span><span class="s2">, </span><span class="s1">ub=</span><span class="s4">16</span><span class="s1">)</span><span class="s2">, </span><span class="s1">ref)</span>
        <span class="s3"># moment over 60% of distribution, [lb, ub] centered within support</span>
        <span class="s1">assert_allclose(dist.expect(loc=</span><span class="s4">10</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">lb=</span><span class="s4">11</span><span class="s2">, </span><span class="s1">ub=</span><span class="s4">14</span><span class="s1">)</span><span class="s2">, </span><span class="s1">ref*</span><span class="s4">0.6</span><span class="s1">)</span>
        <span class="s3"># moment over truncated distribution, essentially</span>
        <span class="s1">assert_allclose(dist.expect(loc=</span><span class="s4">10</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">lb=</span><span class="s4">11</span><span class="s2">, </span><span class="s1">ub=</span><span class="s4">14</span><span class="s2">,</span>
                                    <span class="s1">conditional=</span><span class="s2">True</span><span class="s1">)</span><span class="s2">, </span><span class="s1">ref)</span>
        <span class="s3"># moment over 40% of distribution, [lb, ub] not centered within support</span>
        <span class="s1">assert_allclose(dist.expect(loc=</span><span class="s4">10</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">lb=</span><span class="s4">11</span><span class="s2">, </span><span class="s1">ub=</span><span class="s4">13</span><span class="s1">)</span><span class="s2">, </span><span class="s4">12</span><span class="s1">*</span><span class="s4">0.4</span><span class="s1">)</span>
        <span class="s3"># moment with lb &gt; ub</span>
        <span class="s1">assert_allclose(dist.expect(loc=</span><span class="s4">10</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">lb=</span><span class="s4">13</span><span class="s2">, </span><span class="s1">ub=</span><span class="s4">11</span><span class="s1">)</span><span class="s2">, </span><span class="s1">-</span><span class="s4">12</span><span class="s1">*</span><span class="s4">0.4</span><span class="s1">)</span>
        <span class="s3"># moment with lb &gt; ub, conditional</span>
        <span class="s1">assert_allclose(dist.expect(loc=</span><span class="s4">10</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">lb=</span><span class="s4">13</span><span class="s2">, </span><span class="s1">ub=</span><span class="s4">11</span><span class="s2">,</span>
                                    <span class="s1">conditional=</span><span class="s2">True</span><span class="s1">)</span><span class="s2">, </span><span class="s4">12</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestNct:</span>
    <span class="s2">def </span><span class="s1">test_nc_parameter(self):</span>
        <span class="s3"># Parameter values c&lt;=0 were not enabled (gh-2402).</span>
        <span class="s3"># For negative values c and for c=0 results of rv.cdf(0) below were nan</span>
        <span class="s1">rv = stats.nct(</span><span class="s4">5</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_equal(rv.cdf(</span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)</span>
        <span class="s1">rv = stats.nct(</span><span class="s4">5</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(rv.cdf(</span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0.841344746069</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">10</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_broadcasting(self):</span>
        <span class="s1">res = stats.nct.pdf(</span><span class="s4">5</span><span class="s2">, </span><span class="s1">np.arange(</span><span class="s4">4</span><span class="s2">, </span><span class="s4">7</span><span class="s1">)[:</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
                            <span class="s1">np.linspace(</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">4</span><span class="s1">))</span>
        <span class="s1">expected = array([[</span><span class="s4">0.00321886</span><span class="s2">, </span><span class="s4">0.00557466</span><span class="s2">, </span><span class="s4">0.00918418</span><span class="s2">, </span><span class="s4">0.01442997</span><span class="s1">]</span><span class="s2">,</span>
                          <span class="s1">[</span><span class="s4">0.00217142</span><span class="s2">, </span><span class="s4">0.00395366</span><span class="s2">, </span><span class="s4">0.00683888</span><span class="s2">, </span><span class="s4">0.01126276</span><span class="s1">]</span><span class="s2">,</span>
                          <span class="s1">[</span><span class="s4">0.00153078</span><span class="s2">, </span><span class="s4">0.00291093</span><span class="s2">, </span><span class="s4">0.00525206</span><span class="s2">, </span><span class="s4">0.00900815</span><span class="s1">]])</span>
        <span class="s1">assert_allclose(res</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-5</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_variance_gh_issue_2401(self):</span>
        <span class="s3"># Computation of the variance of a non-central t-distribution resulted</span>
        <span class="s3"># in a TypeError: ufunc 'isinf' not supported for the input types,</span>
        <span class="s3"># and the inputs could not be safely coerced to any supported types</span>
        <span class="s3"># according to the casting rule 'safe'</span>
        <span class="s1">rv = stats.nct(</span><span class="s4">4</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_equal(rv.var()</span><span class="s2">, </span><span class="s4">2.0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_nct_inf_moments(self):</span>
        <span class="s3"># n-th moment of nct only exists for df &gt; n</span>
        <span class="s1">m</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">k = stats.nct.stats(df=</span><span class="s4">0.9</span><span class="s2">, </span><span class="s1">nc=</span><span class="s4">0.3</span><span class="s2">, </span><span class="s1">moments=</span><span class="s5">'mvsk'</span><span class="s1">)</span>
        <span class="s1">assert_equal([m</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">k]</span><span class="s2">, </span><span class="s1">[np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan])</span>

        <span class="s1">m</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">k = stats.nct.stats(df=</span><span class="s4">1.9</span><span class="s2">, </span><span class="s1">nc=</span><span class="s4">0.3</span><span class="s2">, </span><span class="s1">moments=</span><span class="s5">'mvsk'</span><span class="s1">)</span>
        <span class="s1">assert_(np.isfinite(m))</span>
        <span class="s1">assert_equal([v</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">k]</span><span class="s2">, </span><span class="s1">[np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan])</span>

        <span class="s1">m</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">k = stats.nct.stats(df=</span><span class="s4">3.1</span><span class="s2">, </span><span class="s1">nc=</span><span class="s4">0.3</span><span class="s2">, </span><span class="s1">moments=</span><span class="s5">'mvsk'</span><span class="s1">)</span>
        <span class="s1">assert_(np.isfinite([m</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">s]).all())</span>
        <span class="s1">assert_equal(k</span><span class="s2">, </span><span class="s1">np.nan)</span>

    <span class="s2">def </span><span class="s1">test_nct_stats_large_df_values(self):</span>
        <span class="s3"># previously gamma function was used which lost precision at df=345</span>
        <span class="s3"># cf. https://github.com/scipy/scipy/issues/12919 for details</span>
        <span class="s1">nct_mean_df_1000 = stats.nct.mean(</span><span class="s4">1000</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">nct_stats_df_1000 = stats.nct.stats(</span><span class="s4">1000</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s3"># These expected values were computed with mpmath. They were also</span>
        <span class="s3"># verified with the Wolfram Alpha expressions:</span>
        <span class="s3">#     Mean[NoncentralStudentTDistribution[1000, 2]]</span>
        <span class="s3">#     Var[NoncentralStudentTDistribution[1000, 2]]</span>
        <span class="s1">expected_stats_df_1000 = [</span><span class="s4">2.0015015641422464</span><span class="s2">, </span><span class="s4">1.0040115288163005</span><span class="s1">]</span>
        <span class="s1">assert_allclose(nct_mean_df_1000</span><span class="s2">, </span><span class="s1">expected_stats_df_1000[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">rtol=</span><span class="s4">1e-10</span><span class="s1">)</span>
        <span class="s1">assert_allclose(nct_stats_df_1000</span><span class="s2">, </span><span class="s1">expected_stats_df_1000</span><span class="s2">,</span>
                        <span class="s1">rtol=</span><span class="s4">1e-10</span><span class="s1">)</span>
        <span class="s3"># and a bigger df value</span>
        <span class="s1">nct_mean = stats.nct.mean(</span><span class="s4">100000</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">nct_stats = stats.nct.stats(</span><span class="s4">100000</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s3"># These expected values were computed with mpmath.</span>
        <span class="s1">expected_stats = [</span><span class="s4">2.0000150001562518</span><span class="s2">, </span><span class="s4">1.0000400011500288</span><span class="s1">]</span>
        <span class="s1">assert_allclose(nct_mean</span><span class="s2">, </span><span class="s1">expected_stats[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-10</span><span class="s1">)</span>
        <span class="s1">assert_allclose(nct_stats</span><span class="s2">, </span><span class="s1">expected_stats</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-9</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_cdf_large_nc(self):</span>
        <span class="s3"># gh-17916 reported a crash with large `nc` values</span>
        <span class="s1">assert_allclose(stats.nct.cdf(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s1">float(</span><span class="s4">2</span><span class="s1">**</span><span class="s4">16</span><span class="s1">))</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestRecipInvGauss:</span>

    <span class="s2">def </span><span class="s1">test_pdf_endpoint(self):</span>
        <span class="s1">p = stats.recipinvgauss.pdf(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0.6</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">p == </span><span class="s4">0.0</span>

    <span class="s2">def </span><span class="s1">test_logpdf_endpoint(self):</span>
        <span class="s1">logp = stats.recipinvgauss.logpdf(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0.6</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">logp == -np.inf</span>

    <span class="s2">def </span><span class="s1">test_cdf_small_x(self):</span>
        <span class="s3"># The expected value was computer with mpmath:</span>
        <span class="s3">#</span>
        <span class="s3"># import mpmath</span>
        <span class="s3">#</span>
        <span class="s3"># mpmath.mp.dps = 100</span>
        <span class="s3">#</span>
        <span class="s3"># def recipinvgauss_cdf_mp(x, mu):</span>
        <span class="s3">#     x = mpmath.mpf(x)</span>
        <span class="s3">#     mu = mpmath.mpf(mu)</span>
        <span class="s3">#     trm1 = 1/mu - x</span>
        <span class="s3">#     trm2 = 1/mu + x</span>
        <span class="s3">#     isqx = 1/mpmath.sqrt(x)</span>
        <span class="s3">#     return (mpmath.ncdf(-isqx*trm1)</span>
        <span class="s3">#             - mpmath.exp(2/mu)*mpmath.ncdf(-isqx*trm2))</span>
        <span class="s3">#</span>
        <span class="s1">p = stats.recipinvgauss.cdf(</span><span class="s4">0.05</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)</span>
        <span class="s1">expected = </span><span class="s4">6.590396159501331e-20</span>
        <span class="s1">assert_allclose(p</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-14</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_sf_large_x(self):</span>
        <span class="s3"># The expected value was computed with mpmath; see test_cdf_small.</span>
        <span class="s1">p = stats.recipinvgauss.sf(</span><span class="s4">80</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)</span>
        <span class="s1">expected = </span><span class="s4">2.699819200556787e-18</span>
        <span class="s1">assert_allclose(p</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s4">5e-15</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestRice:</span>
    <span class="s2">def </span><span class="s1">test_rice_zero_b(self):</span>
        <span class="s3"># rice distribution should work with b=0, cf gh-2164</span>
        <span class="s1">x = [</span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">1.</span><span class="s2">, </span><span class="s4">5.</span><span class="s1">]</span>
        <span class="s1">assert_(np.isfinite(stats.rice.pdf(x</span><span class="s2">, </span><span class="s1">b=</span><span class="s4">0.</span><span class="s1">)).all())</span>
        <span class="s1">assert_(np.isfinite(stats.rice.logpdf(x</span><span class="s2">, </span><span class="s1">b=</span><span class="s4">0.</span><span class="s1">)).all())</span>
        <span class="s1">assert_(np.isfinite(stats.rice.cdf(x</span><span class="s2">, </span><span class="s1">b=</span><span class="s4">0.</span><span class="s1">)).all())</span>
        <span class="s1">assert_(np.isfinite(stats.rice.logcdf(x</span><span class="s2">, </span><span class="s1">b=</span><span class="s4">0.</span><span class="s1">)).all())</span>

        <span class="s1">q = [</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.9</span><span class="s1">]</span>
        <span class="s1">assert_(np.isfinite(stats.rice.ppf(q</span><span class="s2">, </span><span class="s1">b=</span><span class="s4">0.</span><span class="s1">)).all())</span>

        <span class="s1">mvsk = stats.rice.stats(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">moments=</span><span class="s5">'mvsk'</span><span class="s1">)</span>
        <span class="s1">assert_(np.isfinite(mvsk).all())</span>

        <span class="s3"># furthermore, pdf is continuous as b\to 0</span>
        <span class="s3"># rice.pdf(x, b\to 0) = x exp(-x^2/2) + O(b^2)</span>
        <span class="s3"># see e.g. Abramovich &amp; Stegun 9.6.7 &amp; 9.6.10</span>
        <span class="s1">b = </span><span class="s4">1e-8</span>
        <span class="s1">assert_allclose(stats.rice.pdf(x</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">stats.rice.pdf(x</span><span class="s2">, </span><span class="s1">b)</span><span class="s2">,</span>
                        <span class="s1">atol=b</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_rice_rvs(self):</span>
        <span class="s1">rvs = stats.rice.rvs</span>
        <span class="s1">assert_equal(rvs(b=</span><span class="s4">3.</span><span class="s1">).size</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(rvs(b=</span><span class="s4">3.</span><span class="s2">, </span><span class="s1">size=(</span><span class="s4">3</span><span class="s2">, </span><span class="s4">5</span><span class="s1">)).shape</span><span class="s2">, </span><span class="s1">(</span><span class="s4">3</span><span class="s2">, </span><span class="s4">5</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_rice_gh9836(self):</span>
        <span class="s3"># test that gh-9836 is resolved; previously jumped to 1 at the end</span>

        <span class="s1">cdf = stats.rice.cdf(np.arange(</span><span class="s4">10</span><span class="s2">, </span><span class="s4">160</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.arange(</span><span class="s4">10</span><span class="s2">, </span><span class="s4">160</span><span class="s2">, </span><span class="s4">10</span><span class="s1">))</span>
        <span class="s3"># Generated in R</span>
        <span class="s3"># library(VGAM)</span>
        <span class="s3"># options(digits=16)</span>
        <span class="s3"># x = seq(10, 150, 10)</span>
        <span class="s3"># print(price(x, sigma=1, vee=x))</span>
        <span class="s1">cdf_exp = [</span><span class="s4">0.4800278103504522</span><span class="s2">, </span><span class="s4">0.4900233218590353</span><span class="s2">, </span><span class="s4">0.4933500379379548</span><span class="s2">,</span>
                   <span class="s4">0.4950128317658719</span><span class="s2">, </span><span class="s4">0.4960103776798502</span><span class="s2">, </span><span class="s4">0.4966753655438764</span><span class="s2">,</span>
                   <span class="s4">0.4971503395812474</span><span class="s2">, </span><span class="s4">0.4975065620443196</span><span class="s2">, </span><span class="s4">0.4977836197921638</span><span class="s2">,</span>
                   <span class="s4">0.4980052636649550</span><span class="s2">, </span><span class="s4">0.4981866072661382</span><span class="s2">, </span><span class="s4">0.4983377260666599</span><span class="s2">,</span>
                   <span class="s4">0.4984655952615694</span><span class="s2">, </span><span class="s4">0.4985751970541413</span><span class="s2">, </span><span class="s4">0.4986701850071265</span><span class="s1">]</span>
        <span class="s1">assert_allclose(cdf</span><span class="s2">, </span><span class="s1">cdf_exp)</span>

        <span class="s1">probabilities = np.arange(</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.1</span><span class="s1">)</span>
        <span class="s1">ppf = stats.rice.ppf(probabilities</span><span class="s2">, </span><span class="s4">500</span><span class="s1">/</span><span class="s4">4</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">4</span><span class="s1">)</span>
        <span class="s3"># Generated in R</span>
        <span class="s3"># library(VGAM)</span>
        <span class="s3"># options(digits=16)</span>
        <span class="s3"># p = seq(0.1, .9, by = .1)</span>
        <span class="s3"># print(qrice(p, vee = 500, sigma = 4))</span>
        <span class="s1">ppf_exp = [</span><span class="s4">494.8898762347361</span><span class="s2">, </span><span class="s4">496.6495690858350</span><span class="s2">, </span><span class="s4">497.9184315188069</span><span class="s2">,</span>
                   <span class="s4">499.0026277378915</span><span class="s2">, </span><span class="s4">500.0159999146250</span><span class="s2">, </span><span class="s4">501.0293721352668</span><span class="s2">,</span>
                   <span class="s4">502.1135684981884</span><span class="s2">, </span><span class="s4">503.3824312270405</span><span class="s2">, </span><span class="s4">505.1421247157822</span><span class="s1">]</span>
        <span class="s1">assert_allclose(ppf</span><span class="s2">, </span><span class="s1">ppf_exp)</span>

        <span class="s1">ppf = scipy.stats.rice.ppf(</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">np.arange(</span><span class="s4">10</span><span class="s2">, </span><span class="s4">150</span><span class="s2">, </span><span class="s4">10</span><span class="s1">))</span>
        <span class="s3"># Generated in R</span>
        <span class="s3"># library(VGAM)</span>
        <span class="s3"># options(digits=16)</span>
        <span class="s3"># b &lt;- seq(10, 140, 10)</span>
        <span class="s3"># print(qrice(0.5, vee = b, sigma = 1))</span>
        <span class="s1">ppf_exp = [</span><span class="s4">10.04995862522287</span><span class="s2">, </span><span class="s4">20.02499480078302</span><span class="s2">, </span><span class="s4">30.01666512465732</span><span class="s2">,</span>
                   <span class="s4">40.01249934924363</span><span class="s2">, </span><span class="s4">50.00999966676032</span><span class="s2">, </span><span class="s4">60.00833314046875</span><span class="s2">,</span>
                   <span class="s4">70.00714273568241</span><span class="s2">, </span><span class="s4">80.00624991862573</span><span class="s2">, </span><span class="s4">90.00555549840364</span><span class="s2">,</span>
                   <span class="s4">100.00499995833597</span><span class="s2">, </span><span class="s4">110.00454542324384</span><span class="s2">, </span><span class="s4">120.00416664255323</span><span class="s2">,</span>
                   <span class="s4">130.00384613488120</span><span class="s2">, </span><span class="s4">140.00357141338748</span><span class="s1">]</span>
        <span class="s1">assert_allclose(ppf</span><span class="s2">, </span><span class="s1">ppf_exp)</span>


<span class="s2">class </span><span class="s1">TestErlang:</span>
    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">np.random.seed(</span><span class="s4">1234</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_erlang_runtimewarning(self):</span>
        <span class="s3"># erlang should generate a RuntimeWarning if a non-integer</span>
        <span class="s3"># shape parameter is used.</span>
        <span class="s2">with </span><span class="s1">warnings.catch_warnings():</span>
            <span class="s1">warnings.simplefilter(</span><span class="s5">&quot;error&quot;</span><span class="s2">, </span><span class="s1">RuntimeWarning)</span>

            <span class="s3"># The non-integer shape parameter 1.3 should trigger a</span>
            <span class="s3"># RuntimeWarning</span>
            <span class="s1">assert_raises(RuntimeWarning</span><span class="s2">,</span>
                          <span class="s1">stats.erlang.rvs</span><span class="s2">, </span><span class="s4">1.3</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">4</span><span class="s1">)</span>

            <span class="s3"># Calling the fit method with `f0` set to an integer should</span>
            <span class="s3"># *not* trigger a RuntimeWarning.  It should return the same</span>
            <span class="s3"># values as gamma.fit(...).</span>
            <span class="s1">data = [</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">4.0</span><span class="s1">]</span>
            <span class="s1">result_erlang = stats.erlang.fit(data</span><span class="s2">, </span><span class="s1">f0=</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">result_gamma = stats.gamma.fit(data</span><span class="s2">, </span><span class="s1">f0=</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">assert_allclose(result_erlang</span><span class="s2">, </span><span class="s1">result_gamma</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-3</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_gh_pr_10949_argcheck(self):</span>
        <span class="s1">assert_equal(stats.erlang.pdf(</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">a=[</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">])</span><span class="s2">,</span>
                     <span class="s1">stats.gamma.pdf(</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">a=[</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">]))</span>


<span class="s2">class </span><span class="s1">TestRayleigh:</span>
    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">np.random.seed(</span><span class="s4">987654321</span><span class="s1">)</span>

    <span class="s3"># gh-6227</span>
    <span class="s2">def </span><span class="s1">test_logpdf(self):</span>
        <span class="s1">y = stats.rayleigh.logpdf(</span><span class="s4">50</span><span class="s1">)</span>
        <span class="s1">assert_allclose(y</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1246.0879769945718</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_logsf(self):</span>
        <span class="s1">y = stats.rayleigh.logsf(</span><span class="s4">50</span><span class="s1">)</span>
        <span class="s1">assert_allclose(y</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1250</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;rvs_loc,rvs_scale&quot;</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">0.85373171</span><span class="s2">, </span><span class="s4">0.86932204</span><span class="s1">)</span><span class="s2">,</span>
                                                   <span class="s1">(</span><span class="s4">0.20558821</span><span class="s2">, </span><span class="s4">0.61621008</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_fit(self</span><span class="s2">, </span><span class="s1">rvs_loc</span><span class="s2">, </span><span class="s1">rvs_scale):</span>
        <span class="s1">data = stats.rayleigh.rvs(size=</span><span class="s4">250</span><span class="s2">, </span><span class="s1">loc=rvs_loc</span><span class="s2">, </span><span class="s1">scale=rvs_scale)</span>

        <span class="s2">def </span><span class="s1">scale_mle(data</span><span class="s2">, </span><span class="s1">floc):</span>
            <span class="s2">return </span><span class="s1">(np.sum((data - floc) ** </span><span class="s4">2</span><span class="s1">) / (</span><span class="s4">2 </span><span class="s1">* len(data))) ** </span><span class="s4">.5</span>

        <span class="s3"># when `floc` is provided, `scale` is found with an analytical formula</span>
        <span class="s1">scale_expect = scale_mle(data</span><span class="s2">, </span><span class="s1">rvs_loc)</span>
        <span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = stats.rayleigh.fit(data</span><span class="s2">, </span><span class="s1">floc=rvs_loc)</span>
        <span class="s1">assert_equal(loc</span><span class="s2">, </span><span class="s1">rvs_loc)</span>
        <span class="s1">assert_equal(scale</span><span class="s2">, </span><span class="s1">scale_expect)</span>

        <span class="s3"># when `fscale` is fixed, superclass fit is used to determine `loc`.</span>
        <span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = stats.rayleigh.fit(data</span><span class="s2">, </span><span class="s1">fscale=</span><span class="s4">.6</span><span class="s1">)</span>
        <span class="s1">assert_equal(scale</span><span class="s2">, </span><span class="s4">.6</span><span class="s1">)</span>

        <span class="s3"># with both parameters free, one dimensional optimization is done</span>
        <span class="s3"># over a new function that takes into account the dependent relation</span>
        <span class="s3"># of `scale` to `loc`.</span>
        <span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = stats.rayleigh.fit(data)</span>
        <span class="s3"># test that `scale` is defined by its relation to `loc`</span>
        <span class="s1">assert_equal(scale</span><span class="s2">, </span><span class="s1">scale_mle(data</span><span class="s2">, </span><span class="s1">loc))</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;rvs_loc,rvs_scale&quot;</span><span class="s2">, </span><span class="s1">[[</span><span class="s4">0.74</span><span class="s2">, </span><span class="s4">0.01</span><span class="s1">]</span><span class="s2">,</span>
                                                   <span class="s1">[</span><span class="s4">0.08464463</span><span class="s2">, </span><span class="s4">0.12069025</span><span class="s1">]])</span>
    <span class="s2">def </span><span class="s1">test_fit_comparison_super_method(self</span><span class="s2">, </span><span class="s1">rvs_loc</span><span class="s2">, </span><span class="s1">rvs_scale):</span>
        <span class="s3"># test that the objective function result of the analytical MLEs is</span>
        <span class="s3"># less than or equal to that of the numerically optimized estimate</span>
        <span class="s1">data = stats.rayleigh.rvs(size=</span><span class="s4">250</span><span class="s2">, </span><span class="s1">loc=rvs_loc</span><span class="s2">, </span><span class="s1">scale=rvs_scale)</span>
        <span class="s1">_assert_less_or_close_loglike(stats.rayleigh</span><span class="s2">, </span><span class="s1">data)</span>

    <span class="s2">def </span><span class="s1">test_fit_warnings(self):</span>
        <span class="s1">assert_fit_warnings(stats.rayleigh)</span>

    <span class="s2">def </span><span class="s1">test_fit_gh17088(self):</span>
        <span class="s3"># `rayleigh.fit` could return a location that was inconsistent with</span>
        <span class="s3"># the data. See gh-17088.</span>
        <span class="s1">rng = np.random.default_rng(</span><span class="s4">456</span><span class="s1">)</span>
        <span class="s1">loc</span><span class="s2">, </span><span class="s1">scale</span><span class="s2">, </span><span class="s1">size = </span><span class="s4">50</span><span class="s2">, </span><span class="s4">600</span><span class="s2">, </span><span class="s4">500</span>
        <span class="s1">rvs = stats.rayleigh.rvs(loc</span><span class="s2">, </span><span class="s1">scale</span><span class="s2">, </span><span class="s1">size=size</span><span class="s2">, </span><span class="s1">random_state=rng)</span>
        <span class="s1">loc_fit</span><span class="s2">, </span><span class="s1">_ = stats.rayleigh.fit(rvs)</span>
        <span class="s2">assert </span><span class="s1">loc_fit &lt; np.min(rvs)</span>
        <span class="s1">loc_fit</span><span class="s2">, </span><span class="s1">scale_fit = stats.rayleigh.fit(rvs</span><span class="s2">, </span><span class="s1">fscale=scale)</span>
        <span class="s2">assert </span><span class="s1">loc_fit &lt; np.min(rvs)</span>
        <span class="s2">assert </span><span class="s1">scale_fit == scale</span>


<span class="s2">class </span><span class="s1">TestExponWeib:</span>

    <span class="s2">def </span><span class="s1">test_pdf_logpdf(self):</span>
        <span class="s3"># Regression test for gh-3508.</span>
        <span class="s1">x = </span><span class="s4">0.1</span>
        <span class="s1">a = </span><span class="s4">1.0</span>
        <span class="s1">c = </span><span class="s4">100.0</span>
        <span class="s1">p = stats.exponweib.pdf(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">c)</span>
        <span class="s1">logp = stats.exponweib.logpdf(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">c)</span>
        <span class="s3"># Expected values were computed with mpmath.</span>
        <span class="s1">assert_allclose([p</span><span class="s2">, </span><span class="s1">logp]</span><span class="s2">,</span>
                        <span class="s1">[</span><span class="s4">1.0000000000000054e-97</span><span class="s2">, </span><span class="s1">-</span><span class="s4">223.35075402042244</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_a_is_1(self):</span>
        <span class="s3"># For issue gh-3508.</span>
        <span class="s3"># Check that when a=1, the pdf and logpdf methods of exponweib are the</span>
        <span class="s3"># same as those of weibull_min.</span>
        <span class="s1">x = np.logspace(-</span><span class="s4">4</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>
        <span class="s1">a = </span><span class="s4">1</span>
        <span class="s1">c = </span><span class="s4">100</span>

        <span class="s1">p = stats.exponweib.pdf(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">c)</span>
        <span class="s1">expected = stats.weibull_min.pdf(x</span><span class="s2">, </span><span class="s1">c)</span>
        <span class="s1">assert_allclose(p</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">logp = stats.exponweib.logpdf(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">c)</span>
        <span class="s1">expected = stats.weibull_min.logpdf(x</span><span class="s2">, </span><span class="s1">c)</span>
        <span class="s1">assert_allclose(logp</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_a_is_1_c_is_1(self):</span>
        <span class="s3"># When a = 1 and c = 1, the distribution is exponential.</span>
        <span class="s1">x = np.logspace(-</span><span class="s4">8</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">a = </span><span class="s4">1</span>
        <span class="s1">c = </span><span class="s4">1</span>

        <span class="s1">p = stats.exponweib.pdf(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">c)</span>
        <span class="s1">expected = stats.expon.pdf(x)</span>
        <span class="s1">assert_allclose(p</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">logp = stats.exponweib.logpdf(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">c)</span>
        <span class="s1">expected = stats.expon.logpdf(x)</span>
        <span class="s1">assert_allclose(logp</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s3"># Reference values were computed with mpmath, e.g:</span>
    <span class="s3">#</span>
    <span class="s3">#     from mpmath import mp</span>
    <span class="s3">#</span>
    <span class="s3">#     def mp_sf(x, a, c):</span>
    <span class="s3">#         x = mp.mpf(x)</span>
    <span class="s3">#         a = mp.mpf(a)</span>
    <span class="s3">#         c = mp.mpf(c)</span>
    <span class="s3">#         return -mp.powm1(-mp.expm1(-x**c)), a)</span>
    <span class="s3">#</span>
    <span class="s3">#     mp.dps = 100</span>
    <span class="s3">#     print(float(mp_sf(1, 2.5, 0.75)))</span>
    <span class="s3">#</span>
    <span class="s3"># prints</span>
    <span class="s3">#</span>
    <span class="s3">#     0.6823127476985246</span>
    <span class="s3">#</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s5">'x, a, c, ref'</span><span class="s2">,</span>
        <span class="s1">[(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2.5</span><span class="s2">, </span><span class="s4">0.75</span><span class="s2">, </span><span class="s4">0.6823127476985246</span><span class="s1">)</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">50</span><span class="s2">, </span><span class="s4">2.5</span><span class="s2">, </span><span class="s4">0.75</span><span class="s2">, </span><span class="s4">1.7056666054719663e-08</span><span class="s1">)</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">125</span><span class="s2">, </span><span class="s4">2.5</span><span class="s2">, </span><span class="s4">0.75</span><span class="s2">, </span><span class="s4">1.4534393150714602e-16</span><span class="s1">)</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">250</span><span class="s2">, </span><span class="s4">2.5</span><span class="s2">, </span><span class="s4">0.75</span><span class="s2">, </span><span class="s4">1.2391389689773512e-27</span><span class="s1">)</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">250</span><span class="s2">, </span><span class="s4">0.03125</span><span class="s2">, </span><span class="s4">0.75</span><span class="s2">, </span><span class="s4">1.548923711221689e-29</span><span class="s1">)</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">3</span><span class="s2">, </span><span class="s4">0.03125</span><span class="s2">, </span><span class="s4">3.0</span><span class="s2">,  </span><span class="s4">5.873527551689983e-14</span><span class="s1">)</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">2e80</span><span class="s2">, </span><span class="s4">10.0</span><span class="s2">, </span><span class="s4">0.02</span><span class="s2">, </span><span class="s4">2.9449084156902135e-17</span><span class="s1">)]</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_sf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">ref):</span>
        <span class="s1">sf = stats.exponweib.sf(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">c)</span>
        <span class="s1">assert_allclose(sf</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-14</span><span class="s1">)</span>

    <span class="s3"># Reference values were computed with mpmath, e.g.</span>
    <span class="s3">#</span>
    <span class="s3">#     from mpmath import mp</span>
    <span class="s3">#</span>
    <span class="s3">#     def mp_isf(p, a, c):</span>
    <span class="s3">#         p = mp.mpf(p)</span>
    <span class="s3">#         a = mp.mpf(a)</span>
    <span class="s3">#         c = mp.mpf(c)</span>
    <span class="s3">#         return (-mp.log(-mp.expm1(mp.log1p(-p)/a)))**(1/c)</span>
    <span class="s3">#</span>
    <span class="s3">#     mp.dps = 100</span>
    <span class="s3">#     print(float(mp_isf(0.25, 2.5, 0.75)))</span>
    <span class="s3">#</span>
    <span class="s3"># prints</span>
    <span class="s3">#</span>
    <span class="s3">#     2.8946008178158924</span>
    <span class="s3">#</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s5">'p, a, c, ref'</span><span class="s2">,</span>
        <span class="s1">[(</span><span class="s4">0.25</span><span class="s2">, </span><span class="s4">2.5</span><span class="s2">, </span><span class="s4">0.75</span><span class="s2">, </span><span class="s4">2.8946008178158924</span><span class="s1">)</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">3e-16</span><span class="s2">, </span><span class="s4">2.5</span><span class="s2">, </span><span class="s4">0.75</span><span class="s2">, </span><span class="s4">121.77966713102938</span><span class="s1">)</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">1e-12</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">5.256521769756932</span><span class="s1">)</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">2e-13</span><span class="s2">, </span><span class="s4">0.03125</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">2.953915059484589</span><span class="s1">)</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">5e-14</span><span class="s2">, </span><span class="s4">10.0</span><span class="s2">, </span><span class="s4">0.02</span><span class="s2">, </span><span class="s4">7.57094886384687e+75</span><span class="s1">)]</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_isf(self</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">ref):</span>
        <span class="s1">isf = stats.exponweib.isf(p</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">c)</span>
        <span class="s1">assert_allclose(isf</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">5e-14</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestFatigueLife:</span>

    <span class="s2">def </span><span class="s1">test_sf_tail(self):</span>
        <span class="s3"># Expected value computed with mpmath:</span>
        <span class="s3">#     import mpmath</span>
        <span class="s3">#     mpmath.mp.dps = 80</span>
        <span class="s3">#     x = mpmath.mpf(800.0)</span>
        <span class="s3">#     c = mpmath.mpf(2.5)</span>
        <span class="s3">#     s = float(1 - mpmath.ncdf(1/c * (mpmath.sqrt(x)</span>
        <span class="s3">#                                      - 1/mpmath.sqrt(x))))</span>
        <span class="s3">#     print(s)</span>
        <span class="s3"># Output:</span>
        <span class="s3">#     6.593376447038406e-30</span>
        <span class="s1">s = stats.fatiguelife.sf(</span><span class="s4">800.0</span><span class="s2">, </span><span class="s4">2.5</span><span class="s1">)</span>
        <span class="s1">assert_allclose(s</span><span class="s2">, </span><span class="s4">6.593376447038406e-30</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-13</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_isf_tail(self):</span>
        <span class="s3"># See test_sf_tail for the mpmath code.</span>
        <span class="s1">p = </span><span class="s4">6.593376447038406e-30</span>
        <span class="s1">q = stats.fatiguelife.isf(p</span><span class="s2">, </span><span class="s4">2.5</span><span class="s1">)</span>
        <span class="s1">assert_allclose(q</span><span class="s2">, </span><span class="s4">800.0</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-13</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestWeibull:</span>

    <span class="s2">def </span><span class="s1">test_logpdf(self):</span>
        <span class="s3"># gh-6217</span>
        <span class="s1">y = stats.weibull_min.logpdf(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(y</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_with_maxima_distrib(self):</span>
        <span class="s3"># Tests for weibull_min and weibull_max.</span>
        <span class="s3"># The expected values were computed using the symbolic algebra</span>
        <span class="s3"># program 'maxima' with the package 'distrib', which has</span>
        <span class="s3"># 'pdf_weibull' and 'cdf_weibull'.  The mapping between the</span>
        <span class="s3"># scipy and maxima functions is as follows:</span>
        <span class="s3"># -----------------------------------------------------------------</span>
        <span class="s3"># scipy                              maxima</span>
        <span class="s3"># ---------------------------------  ------------------------------</span>
        <span class="s3"># weibull_min.pdf(x, a, scale=b)     pdf_weibull(x, a, b)</span>
        <span class="s3"># weibull_min.logpdf(x, a, scale=b)  log(pdf_weibull(x, a, b))</span>
        <span class="s3"># weibull_min.cdf(x, a, scale=b)     cdf_weibull(x, a, b)</span>
        <span class="s3"># weibull_min.logcdf(x, a, scale=b)  log(cdf_weibull(x, a, b))</span>
        <span class="s3"># weibull_min.sf(x, a, scale=b)      1 - cdf_weibull(x, a, b)</span>
        <span class="s3"># weibull_min.logsf(x, a, scale=b)   log(1 - cdf_weibull(x, a, b))</span>
        <span class="s3">#</span>
        <span class="s3"># weibull_max.pdf(x, a, scale=b)     pdf_weibull(-x, a, b)</span>
        <span class="s3"># weibull_max.logpdf(x, a, scale=b)  log(pdf_weibull(-x, a, b))</span>
        <span class="s3"># weibull_max.cdf(x, a, scale=b)     1 - cdf_weibull(-x, a, b)</span>
        <span class="s3"># weibull_max.logcdf(x, a, scale=b)  log(1 - cdf_weibull(-x, a, b))</span>
        <span class="s3"># weibull_max.sf(x, a, scale=b)      cdf_weibull(-x, a, b)</span>
        <span class="s3"># weibull_max.logsf(x, a, scale=b)   log(cdf_weibull(-x, a, b))</span>
        <span class="s3"># -----------------------------------------------------------------</span>
        <span class="s1">x = </span><span class="s4">1.5</span>
        <span class="s1">a = </span><span class="s4">2.0</span>
        <span class="s1">b = </span><span class="s4">3.0</span>

        <span class="s3"># weibull_min</span>

        <span class="s1">p = stats.weibull_min.pdf(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">scale=b)</span>
        <span class="s1">assert_allclose(p</span><span class="s2">, </span><span class="s1">np.exp(-</span><span class="s4">0.25</span><span class="s1">)/</span><span class="s4">3</span><span class="s1">)</span>

        <span class="s1">lp = stats.weibull_min.logpdf(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">scale=b)</span>
        <span class="s1">assert_allclose(lp</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.25 </span><span class="s1">- np.log(</span><span class="s4">3</span><span class="s1">))</span>

        <span class="s1">c = stats.weibull_min.cdf(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">scale=b)</span>
        <span class="s1">assert_allclose(c</span><span class="s2">, </span><span class="s1">-special.expm1(-</span><span class="s4">0.25</span><span class="s1">))</span>

        <span class="s1">lc = stats.weibull_min.logcdf(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">scale=b)</span>
        <span class="s1">assert_allclose(lc</span><span class="s2">, </span><span class="s1">np.log(-special.expm1(-</span><span class="s4">0.25</span><span class="s1">)))</span>

        <span class="s1">s = stats.weibull_min.sf(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">scale=b)</span>
        <span class="s1">assert_allclose(s</span><span class="s2">, </span><span class="s1">np.exp(-</span><span class="s4">0.25</span><span class="s1">))</span>

        <span class="s1">ls = stats.weibull_min.logsf(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">scale=b)</span>
        <span class="s1">assert_allclose(ls</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.25</span><span class="s1">)</span>

        <span class="s3"># Also test using a large value x, for which computing the survival</span>
        <span class="s3"># function using the CDF would result in 0.</span>
        <span class="s1">s = stats.weibull_min.sf(</span><span class="s4">30</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">assert_allclose(s</span><span class="s2">, </span><span class="s1">np.exp(-</span><span class="s4">100</span><span class="s1">))</span>

        <span class="s1">ls = stats.weibull_min.logsf(</span><span class="s4">30</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">assert_allclose(ls</span><span class="s2">, </span><span class="s1">-</span><span class="s4">100</span><span class="s1">)</span>

        <span class="s3"># weibull_max</span>
        <span class="s1">x = -</span><span class="s4">1.5</span>

        <span class="s1">p = stats.weibull_max.pdf(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">scale=b)</span>
        <span class="s1">assert_allclose(p</span><span class="s2">, </span><span class="s1">np.exp(-</span><span class="s4">0.25</span><span class="s1">)/</span><span class="s4">3</span><span class="s1">)</span>

        <span class="s1">lp = stats.weibull_max.logpdf(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">scale=b)</span>
        <span class="s1">assert_allclose(lp</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.25 </span><span class="s1">- np.log(</span><span class="s4">3</span><span class="s1">))</span>

        <span class="s1">c = stats.weibull_max.cdf(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">scale=b)</span>
        <span class="s1">assert_allclose(c</span><span class="s2">, </span><span class="s1">np.exp(-</span><span class="s4">0.25</span><span class="s1">))</span>

        <span class="s1">lc = stats.weibull_max.logcdf(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">scale=b)</span>
        <span class="s1">assert_allclose(lc</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.25</span><span class="s1">)</span>

        <span class="s1">s = stats.weibull_max.sf(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">scale=b)</span>
        <span class="s1">assert_allclose(s</span><span class="s2">, </span><span class="s1">-special.expm1(-</span><span class="s4">0.25</span><span class="s1">))</span>

        <span class="s1">ls = stats.weibull_max.logsf(x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">scale=b)</span>
        <span class="s1">assert_allclose(ls</span><span class="s2">, </span><span class="s1">np.log(-special.expm1(-</span><span class="s4">0.25</span><span class="s1">)))</span>

        <span class="s3"># Also test using a value of x close to 0, for which computing the</span>
        <span class="s3"># survival function using the CDF would result in 0.</span>
        <span class="s1">s = stats.weibull_max.sf(-</span><span class="s4">1e-9</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">assert_allclose(s</span><span class="s2">, </span><span class="s1">-special.expm1(-</span><span class="s4">1</span><span class="s1">/</span><span class="s4">9000000000000000000</span><span class="s1">))</span>

        <span class="s1">ls = stats.weibull_max.logsf(-</span><span class="s4">1e-9</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">assert_allclose(ls</span><span class="s2">, </span><span class="s1">np.log(-special.expm1(-</span><span class="s4">1</span><span class="s1">/</span><span class="s4">9000000000000000000</span><span class="s1">)))</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'scale'</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">0.1</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_delta_cdf(self</span><span class="s2">, </span><span class="s1">scale):</span>
        <span class="s3"># Expected value computed with mpmath:</span>
        <span class="s3">#</span>
        <span class="s3"># def weibull_min_sf(x, k, scale):</span>
        <span class="s3">#     x = mpmath.mpf(x)</span>
        <span class="s3">#     k = mpmath.mpf(k)</span>
        <span class="s3">#     scale =mpmath.mpf(scale)</span>
        <span class="s3">#     return mpmath.exp(-(x/scale)**k)</span>
        <span class="s3">#</span>
        <span class="s3"># &gt;&gt;&gt; import mpmath</span>
        <span class="s3"># &gt;&gt;&gt; mpmath.mp.dps = 60</span>
        <span class="s3"># &gt;&gt;&gt; sf1 = weibull_min_sf(7.5, 3, 1)</span>
        <span class="s3"># &gt;&gt;&gt; sf2 = weibull_min_sf(8.0, 3, 1)</span>
        <span class="s3"># &gt;&gt;&gt; float(sf1 - sf2)</span>
        <span class="s3"># 6.053624060118734e-184</span>
        <span class="s3">#</span>
        <span class="s1">delta = stats.weibull_min._delta_cdf(scale*</span><span class="s4">7.5</span><span class="s2">, </span><span class="s1">scale*</span><span class="s4">8</span><span class="s2">, </span><span class="s4">3</span><span class="s2">,</span>
                                             <span class="s1">scale=scale)</span>
        <span class="s1">assert_allclose(delta</span><span class="s2">, </span><span class="s4">6.053624060118734e-184</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_fit_min(self):</span>
        <span class="s1">rng = np.random.default_rng(</span><span class="s4">5985959307161735394</span><span class="s1">)</span>

        <span class="s1">c</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3.5</span><span class="s2">, </span><span class="s4">0.5  </span><span class="s3"># arbitrary, valid parameters</span>
        <span class="s1">dist = stats.weibull_min(c</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale)</span>
        <span class="s1">rvs = dist.rvs(size=</span><span class="s4">100</span><span class="s2">, </span><span class="s1">random_state=rng)</span>

        <span class="s3"># test that MLE still honors guesses and fixed parameters</span>
        <span class="s1">c2</span><span class="s2">, </span><span class="s1">loc2</span><span class="s2">, </span><span class="s1">scale2 = stats.weibull_min.fit(rvs</span><span class="s2">, </span><span class="s4">1.5</span><span class="s2">, </span><span class="s1">floc=</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">c3</span><span class="s2">, </span><span class="s1">loc3</span><span class="s2">, </span><span class="s1">scale3 = stats.weibull_min.fit(rvs</span><span class="s2">, </span><span class="s4">1.6</span><span class="s2">, </span><span class="s1">floc=</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">loc2 == loc3 == </span><span class="s4">3  </span><span class="s3"># fixed parameter is respected</span>
        <span class="s2">assert </span><span class="s1">c2 != c3  </span><span class="s3"># different guess -&gt; (slightly) different outcome</span>
        <span class="s3"># quality of fit is tested elsewhere</span>

        <span class="s3"># test that MoM honors fixed parameters, accepts (but ignores) guesses</span>
        <span class="s1">c4</span><span class="s2">, </span><span class="s1">loc4</span><span class="s2">, </span><span class="s1">scale4 = stats.weibull_min.fit(rvs</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s1">fscale=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">method=</span><span class="s5">'mm'</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">scale4 == </span><span class="s4">3</span>
        <span class="s3"># because scale was fixed, only the mean and skewness will be matched</span>
        <span class="s1">dist4 = stats.weibull_min(c4</span><span class="s2">, </span><span class="s1">loc4</span><span class="s2">, </span><span class="s1">scale4)</span>
        <span class="s1">res = dist4.stats(moments=</span><span class="s5">'ms'</span><span class="s1">)</span>
        <span class="s1">ref = np.mean(rvs)</span><span class="s2">, </span><span class="s1">stats.skew(rvs)</span>
        <span class="s1">assert_allclose(res</span><span class="s2">, </span><span class="s1">ref)</span>

    <span class="s3"># reference values were computed via mpmath</span>
    <span class="s3"># from mpmath import mp</span>
    <span class="s3"># def weibull_sf_mpmath(x, c):</span>
    <span class="s3">#     x = mp.mpf(x)</span>
    <span class="s3">#     c = mp.mpf(c)</span>
    <span class="s3">#     return float(mp.exp(-x**c))</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'x, c, ref'</span><span class="s2">, </span><span class="s1">[(</span><span class="s4">50</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1.9287498479639178e-22</span><span class="s1">)</span><span class="s2">,</span>
                                           <span class="s1">(</span><span class="s4">1000</span><span class="s2">, </span><span class="s4">0.8</span><span class="s2">,</span>
                                            <span class="s4">8.131269637872743e-110</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_sf_isf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">ref):</span>
        <span class="s1">assert_allclose(stats.weibull_min.sf(x</span><span class="s2">, </span><span class="s1">c)</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">5e-14</span><span class="s1">)</span>
        <span class="s1">assert_allclose(stats.weibull_min.isf(ref</span><span class="s2">, </span><span class="s1">c)</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">5e-14</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestDweibull:</span>
    <span class="s2">def </span><span class="s1">test_entropy(self):</span>
        <span class="s3"># Test that dweibull entropy follows that of weibull_min.</span>
        <span class="s3"># (Generic tests check that the dweibull entropy is consistent</span>
        <span class="s3">#  with its PDF. As for accuracy, dweibull entropy should be just</span>
        <span class="s3">#  as accurate as weibull_min entropy. Checks of accuracy against</span>
        <span class="s3">#  a reference need only be applied to the fundamental distribution -</span>
        <span class="s3">#  weibull_min.)</span>
        <span class="s1">rng = np.random.default_rng(</span><span class="s4">8486259129157041777</span><span class="s1">)</span>
        <span class="s1">c = </span><span class="s4">10</span><span class="s1">**rng.normal(scale=</span><span class="s4">100</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">res = stats.dweibull.entropy(c)</span>
        <span class="s1">ref = stats.weibull_min.entropy(c) - np.log(</span><span class="s4">0.5</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-15</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_sf(self):</span>
        <span class="s3"># test that for positive values the dweibull survival function is half</span>
        <span class="s3"># the weibull_min survival function</span>
        <span class="s1">rng = np.random.default_rng(</span><span class="s4">8486259129157041777</span><span class="s1">)</span>
        <span class="s1">c = </span><span class="s4">10</span><span class="s1">**rng.normal(scale=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">x = </span><span class="s4">10 </span><span class="s1">* rng.uniform()</span>
        <span class="s1">res = stats.dweibull.sf(x</span><span class="s2">, </span><span class="s1">c)</span>
        <span class="s1">ref = </span><span class="s4">0.5 </span><span class="s1">* stats.weibull_min.sf(x</span><span class="s2">, </span><span class="s1">c)</span>
        <span class="s1">assert_allclose(res</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-15</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestTruncWeibull:</span>

    <span class="s2">def </span><span class="s1">test_pdf_bounds(self):</span>
        <span class="s3"># test bounds</span>
        <span class="s1">y = stats.truncweibull_min.pdf([</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">2.0</span><span class="s1">]</span><span class="s2">, </span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">0.11</span><span class="s2">, </span><span class="s4">1.99</span><span class="s1">)</span>
        <span class="s1">assert_equal(y</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_logpdf(self):</span>
        <span class="s1">y = stats.truncweibull_min.logpdf(</span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">2.0</span><span class="s2">, </span><span class="s1">np.inf)</span>
        <span class="s1">assert_equal(y</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">)</span>

        <span class="s3"># hand calculation</span>
        <span class="s1">y = stats.truncweibull_min.logpdf(</span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">4.0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(y</span><span class="s2">, </span><span class="s4">0.14541345786885884</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_ppf_bounds(self):</span>
        <span class="s3"># test bounds</span>
        <span class="s1">y = stats.truncweibull_min.ppf([</span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">]</span><span class="s2">, </span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">2.0</span><span class="s1">)</span>
        <span class="s1">assert_equal(y</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">2.0</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_cdf_to_ppf(self):</span>
        <span class="s1">q = [</span><span class="s4">0.</span><span class="s2">, </span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">.25</span><span class="s2">, </span><span class="s4">0.50</span><span class="s2">, </span><span class="s4">0.75</span><span class="s2">, </span><span class="s4">0.90</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]</span>
        <span class="s1">x = stats.truncweibull_min.ppf(q</span><span class="s2">, </span><span class="s4">2.</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">3.</span><span class="s1">)</span>
        <span class="s1">q_out = stats.truncweibull_min.cdf(x</span><span class="s2">, </span><span class="s4">2.</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">3.</span><span class="s1">)</span>
        <span class="s1">assert_allclose(q</span><span class="s2">, </span><span class="s1">q_out)</span>

    <span class="s2">def </span><span class="s1">test_sf_to_isf(self):</span>
        <span class="s1">q = [</span><span class="s4">0.</span><span class="s2">, </span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">.25</span><span class="s2">, </span><span class="s4">0.50</span><span class="s2">, </span><span class="s4">0.75</span><span class="s2">, </span><span class="s4">0.90</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]</span>
        <span class="s1">x = stats.truncweibull_min.isf(q</span><span class="s2">, </span><span class="s4">2.</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">3.</span><span class="s1">)</span>
        <span class="s1">q_out = stats.truncweibull_min.sf(x</span><span class="s2">, </span><span class="s4">2.</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">3.</span><span class="s1">)</span>
        <span class="s1">assert_allclose(q</span><span class="s2">, </span><span class="s1">q_out)</span>

    <span class="s2">def </span><span class="s1">test_munp(self):</span>
        <span class="s1">c = </span><span class="s4">2.</span>
        <span class="s1">a = </span><span class="s4">1.</span>
        <span class="s1">b = </span><span class="s4">3.</span>

        <span class="s2">def </span><span class="s1">xnpdf(x</span><span class="s2">, </span><span class="s1">n):</span>
            <span class="s2">return </span><span class="s1">x**n*stats.truncweibull_min.pdf(x</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b)</span>

        <span class="s1">m0 = stats.truncweibull_min.moment(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b)</span>
        <span class="s1">assert_equal(m0</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">)</span>

        <span class="s1">m1 = stats.truncweibull_min.moment(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b)</span>
        <span class="s1">m1_expected</span><span class="s2">, </span><span class="s1">_ = quad(</span><span class="s2">lambda </span><span class="s1">x: xnpdf(x</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b)</span>
        <span class="s1">assert_allclose(m1</span><span class="s2">, </span><span class="s1">m1_expected)</span>

        <span class="s1">m2 = stats.truncweibull_min.moment(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b)</span>
        <span class="s1">m2_expected</span><span class="s2">, </span><span class="s1">_ = quad(</span><span class="s2">lambda </span><span class="s1">x: xnpdf(x</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b)</span>
        <span class="s1">assert_allclose(m2</span><span class="s2">, </span><span class="s1">m2_expected)</span>

        <span class="s1">m3 = stats.truncweibull_min.moment(</span><span class="s4">3</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b)</span>
        <span class="s1">m3_expected</span><span class="s2">, </span><span class="s1">_ = quad(</span><span class="s2">lambda </span><span class="s1">x: xnpdf(x</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b)</span>
        <span class="s1">assert_allclose(m3</span><span class="s2">, </span><span class="s1">m3_expected)</span>

        <span class="s1">m4 = stats.truncweibull_min.moment(</span><span class="s4">4</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b)</span>
        <span class="s1">m4_expected</span><span class="s2">, </span><span class="s1">_ = quad(</span><span class="s2">lambda </span><span class="s1">x: xnpdf(x</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b)</span>
        <span class="s1">assert_allclose(m4</span><span class="s2">, </span><span class="s1">m4_expected)</span>

    <span class="s2">def </span><span class="s1">test_reference_values(self):</span>
        <span class="s1">a = </span><span class="s4">1.</span>
        <span class="s1">b = </span><span class="s4">3.</span>
        <span class="s1">c = </span><span class="s4">2.</span>
        <span class="s1">x_med = np.sqrt(</span><span class="s4">1 </span><span class="s1">- np.log(</span><span class="s4">0.5 </span><span class="s1">+ np.exp(-(</span><span class="s4">8. </span><span class="s1">+ np.log(</span><span class="s4">2.</span><span class="s1">)))))</span>

        <span class="s1">cdf = stats.truncweibull_min.cdf(x_med</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b)</span>
        <span class="s1">assert_allclose(cdf</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)</span>

        <span class="s1">lc = stats.truncweibull_min.logcdf(x_med</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b)</span>
        <span class="s1">assert_allclose(lc</span><span class="s2">, </span><span class="s1">-np.log(</span><span class="s4">2.</span><span class="s1">))</span>

        <span class="s1">ppf = stats.truncweibull_min.ppf(</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b)</span>
        <span class="s1">assert_allclose(ppf</span><span class="s2">, </span><span class="s1">x_med)</span>

        <span class="s1">sf = stats.truncweibull_min.sf(x_med</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b)</span>
        <span class="s1">assert_allclose(sf</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)</span>

        <span class="s1">ls = stats.truncweibull_min.logsf(x_med</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b)</span>
        <span class="s1">assert_allclose(ls</span><span class="s2">, </span><span class="s1">-np.log(</span><span class="s4">2.</span><span class="s1">))</span>

        <span class="s1">isf = stats.truncweibull_min.isf(</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b)</span>
        <span class="s1">assert_allclose(isf</span><span class="s2">, </span><span class="s1">x_med)</span>

    <span class="s2">def </span><span class="s1">test_compare_weibull_min(self):</span>
        <span class="s3"># Verify that the truncweibull_min distribution gives the same results</span>
        <span class="s3"># as the original weibull_min</span>
        <span class="s1">x = </span><span class="s4">1.5</span>
        <span class="s1">c = </span><span class="s4">2.0</span>
        <span class="s1">a = </span><span class="s4">0.0</span>
        <span class="s1">b = np.inf</span>
        <span class="s1">scale = </span><span class="s4">3.0</span>

        <span class="s1">p = stats.weibull_min.pdf(x</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">scale=scale)</span>
        <span class="s1">p_trunc = stats.truncweibull_min.pdf(x</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">scale=scale)</span>
        <span class="s1">assert_allclose(p</span><span class="s2">, </span><span class="s1">p_trunc)</span>

        <span class="s1">lp = stats.weibull_min.logpdf(x</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">scale=scale)</span>
        <span class="s1">lp_trunc = stats.truncweibull_min.logpdf(x</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">scale=scale)</span>
        <span class="s1">assert_allclose(lp</span><span class="s2">, </span><span class="s1">lp_trunc)</span>

        <span class="s1">cdf = stats.weibull_min.cdf(x</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">scale=scale)</span>
        <span class="s1">cdf_trunc = stats.truncweibull_min.cdf(x</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">scale=scale)</span>
        <span class="s1">assert_allclose(cdf</span><span class="s2">, </span><span class="s1">cdf_trunc)</span>

        <span class="s1">lc = stats.weibull_min.logcdf(x</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">scale=scale)</span>
        <span class="s1">lc_trunc = stats.truncweibull_min.logcdf(x</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">scale=scale)</span>
        <span class="s1">assert_allclose(lc</span><span class="s2">, </span><span class="s1">lc_trunc)</span>

        <span class="s1">s = stats.weibull_min.sf(x</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">scale=scale)</span>
        <span class="s1">s_trunc = stats.truncweibull_min.sf(x</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">scale=scale)</span>
        <span class="s1">assert_allclose(s</span><span class="s2">, </span><span class="s1">s_trunc)</span>

        <span class="s1">ls = stats.weibull_min.logsf(x</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">scale=scale)</span>
        <span class="s1">ls_trunc = stats.truncweibull_min.logsf(x</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">scale=scale)</span>
        <span class="s1">assert_allclose(ls</span><span class="s2">, </span><span class="s1">ls_trunc)</span>

        <span class="s3"># # Also test using a large value x, for which computing the survival</span>
        <span class="s3"># # function using the CDF would result in 0.</span>
        <span class="s1">s = stats.truncweibull_min.sf(</span><span class="s4">30</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">assert_allclose(s</span><span class="s2">, </span><span class="s1">np.exp(-</span><span class="s4">100</span><span class="s1">))</span>

        <span class="s1">ls = stats.truncweibull_min.logsf(</span><span class="s4">30</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">assert_allclose(ls</span><span class="s2">, </span><span class="s1">-</span><span class="s4">100</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_compare_weibull_min2(self):</span>
        <span class="s3"># Verify that the truncweibull_min distribution PDF and CDF results</span>
        <span class="s3"># are the same as those calculated from truncating weibull_min</span>
        <span class="s1">c</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b = </span><span class="s4">2.5</span><span class="s2">, </span><span class="s4">0.25</span><span class="s2">, </span><span class="s4">1.25</span>
        <span class="s1">x = np.linspace(a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s4">100</span><span class="s1">)</span>

        <span class="s1">pdf1 = stats.truncweibull_min.pdf(x</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b)</span>
        <span class="s1">cdf1 = stats.truncweibull_min.cdf(x</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b)</span>

        <span class="s1">norm = stats.weibull_min.cdf(b</span><span class="s2">, </span><span class="s1">c) - stats.weibull_min.cdf(a</span><span class="s2">, </span><span class="s1">c)</span>
        <span class="s1">pdf2 = stats.weibull_min.pdf(x</span><span class="s2">, </span><span class="s1">c) / norm</span>
        <span class="s1">cdf2 = (stats.weibull_min.cdf(x</span><span class="s2">, </span><span class="s1">c) - stats.weibull_min.cdf(a</span><span class="s2">, </span><span class="s1">c))/norm</span>

        <span class="s1">np.testing.assert_allclose(pdf1</span><span class="s2">, </span><span class="s1">pdf2)</span>
        <span class="s1">np.testing.assert_allclose(cdf1</span><span class="s2">, </span><span class="s1">cdf2)</span>


<span class="s2">class </span><span class="s1">TestRdist:</span>
    <span class="s2">def </span><span class="s1">test_rdist_cdf_gh1285(self):</span>
        <span class="s3"># check workaround in rdist._cdf for issue gh-1285.</span>
        <span class="s1">distfn = stats.rdist</span>
        <span class="s1">values = [</span><span class="s4">0.001</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.999</span><span class="s1">]</span>
        <span class="s1">assert_almost_equal(distfn.cdf(distfn.ppf(values</span><span class="s2">, </span><span class="s4">541.0</span><span class="s1">)</span><span class="s2">, </span><span class="s4">541.0</span><span class="s1">)</span><span class="s2">,</span>
                            <span class="s1">values</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">5</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_rdist_beta(self):</span>
        <span class="s3"># rdist is a special case of stats.beta</span>
        <span class="s1">x = np.linspace(-</span><span class="s4">0.99</span><span class="s2">, </span><span class="s4">0.99</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">c = </span><span class="s4">2.7</span>
        <span class="s1">assert_almost_equal(</span><span class="s4">0.5</span><span class="s1">*stats.beta(c/</span><span class="s4">2</span><span class="s2">, </span><span class="s1">c/</span><span class="s4">2</span><span class="s1">).pdf((x + </span><span class="s4">1</span><span class="s1">)/</span><span class="s4">2</span><span class="s1">)</span><span class="s2">,</span>
                            <span class="s1">stats.rdist(c).pdf(x))</span>


<span class="s2">class </span><span class="s1">TestTrapezoid:</span>
    <span class="s2">def </span><span class="s1">test_reduces_to_triang(self):</span>
        <span class="s1">modes = [</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0.3</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span>
        <span class="s2">for </span><span class="s1">mode </span><span class="s2">in </span><span class="s1">modes:</span>
            <span class="s1">x = [</span><span class="s4">0</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span>
            <span class="s1">assert_almost_equal(stats.trapezoid.pdf(x</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">, </span><span class="s1">mode)</span><span class="s2">,</span>
                                <span class="s1">stats.triang.pdf(x</span><span class="s2">, </span><span class="s1">mode))</span>
            <span class="s1">assert_almost_equal(stats.trapezoid.cdf(x</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">, </span><span class="s1">mode)</span><span class="s2">,</span>
                                <span class="s1">stats.triang.cdf(x</span><span class="s2">, </span><span class="s1">mode))</span>

    <span class="s2">def </span><span class="s1">test_reduces_to_uniform(self):</span>
        <span class="s1">x = np.linspace(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(stats.trapezoid.pdf(x</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">stats.uniform.pdf(x))</span>
        <span class="s1">assert_almost_equal(stats.trapezoid.cdf(x</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">stats.uniform.cdf(x))</span>

    <span class="s2">def </span><span class="s1">test_cases(self):</span>
        <span class="s3"># edge cases</span>
        <span class="s1">assert_almost_equal(stats.trapezoid.pdf(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(stats.trapezoid.pdf(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(stats.trapezoid.pdf(</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0.8</span><span class="s1">)</span><span class="s2">,</span>
                            <span class="s4">1.11111111111111111</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(stats.trapezoid.pdf(</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">)</span><span class="s2">,</span>
                            <span class="s4">1.11111111111111111</span><span class="s1">)</span>

        <span class="s3"># straightforward case</span>
        <span class="s1">assert_almost_equal(stats.trapezoid.pdf(</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">0.8</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0.625</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(stats.trapezoid.pdf(</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">0.8</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1.25</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(stats.trapezoid.pdf(</span><span class="s4">0.9</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">0.8</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0.625</span><span class="s1">)</span>

        <span class="s1">assert_almost_equal(stats.trapezoid.cdf(</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">0.8</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0.03125</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(stats.trapezoid.cdf(</span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">0.8</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0.125</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(stats.trapezoid.cdf(</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">0.8</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(stats.trapezoid.cdf(</span><span class="s4">0.9</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">0.8</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0.96875</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(stats.trapezoid.cdf(</span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">0.8</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_moments_and_entropy(self):</span>
        <span class="s3"># issue #11795: improve precision of trapezoid stats</span>
        <span class="s3"># Apply formulas from Wikipedia for the following parameters:</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">d = -</span><span class="s4">3</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3  </span><span class="s3"># =&gt; 1/3, 5/6, -3, 6</span>
        <span class="s1">p1</span><span class="s2">, </span><span class="s1">p2</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = (b-a) / (d-a)</span><span class="s2">, </span><span class="s1">(c-a) / (d-a)</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">d-a</span>
        <span class="s1">h = </span><span class="s4">2 </span><span class="s1">/ (d+c-b-a)</span>

        <span class="s2">def </span><span class="s1">moment(n):</span>
            <span class="s2">return </span><span class="s1">(h * ((d**(n+</span><span class="s4">2</span><span class="s1">) - c**(n+</span><span class="s4">2</span><span class="s1">)) / (d-c)</span>
                         <span class="s1">- (b**(n+</span><span class="s4">2</span><span class="s1">) - a**(n+</span><span class="s4">2</span><span class="s1">)) / (b-a)) /</span>
                    <span class="s1">(n+</span><span class="s4">1</span><span class="s1">) / (n+</span><span class="s4">2</span><span class="s1">))</span>

        <span class="s1">mean = moment(</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">var = moment(</span><span class="s4">2</span><span class="s1">) - mean**</span><span class="s4">2</span>
        <span class="s1">entropy = </span><span class="s4">0.5 </span><span class="s1">* (d-c+b-a) / (d+c-b-a) + np.log(</span><span class="s4">0.5 </span><span class="s1">* (d+c-b-a))</span>
        <span class="s1">assert_almost_equal(stats.trapezoid.mean(p1</span><span class="s2">, </span><span class="s1">p2</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale)</span><span class="s2">,</span>
                            <span class="s1">mean</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">13</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(stats.trapezoid.var(p1</span><span class="s2">, </span><span class="s1">p2</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale)</span><span class="s2">,</span>
                            <span class="s1">var</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">13</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(stats.trapezoid.entropy(p1</span><span class="s2">, </span><span class="s1">p2</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale)</span><span class="s2">,</span>
                            <span class="s1">entropy</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">13</span><span class="s1">)</span>

        <span class="s3"># Check boundary cases where scipy d=0 or d=1.</span>
        <span class="s1">assert_almost_equal(stats.trapezoid.mean(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">3</span><span class="s2">, </span><span class="s4">6</span><span class="s1">)</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">13</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(stats.trapezoid.mean(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">3</span><span class="s2">, </span><span class="s4">6</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">13</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(stats.trapezoid.var(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">3</span><span class="s2">, </span><span class="s4">6</span><span class="s1">)</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">13</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_trapezoid_vect(self):</span>
        <span class="s3"># test that array-valued shapes and arguments are handled</span>
        <span class="s1">c = np.array([</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">0.3</span><span class="s1">])</span>
        <span class="s1">d = np.array([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.6</span><span class="s1">])[:</span><span class="s2">, None</span><span class="s1">]</span>
        <span class="s1">x = np.array([</span><span class="s4">0.15</span><span class="s2">, </span><span class="s4">0.25</span><span class="s2">, </span><span class="s4">0.9</span><span class="s1">])</span>
        <span class="s1">v = stats.trapezoid.pdf(x</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">d)</span>

        <span class="s1">cc</span><span class="s2">, </span><span class="s1">dd</span><span class="s2">, </span><span class="s1">xx = np.broadcast_arrays(c</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">x)</span>

        <span class="s1">res = np.empty(xx.size</span><span class="s2">, </span><span class="s1">dtype=xx.dtype)</span>
        <span class="s1">ind = np.arange(xx.size)</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">c1</span><span class="s2">, </span><span class="s1">d1 </span><span class="s2">in </span><span class="s1">zip(ind</span><span class="s2">, </span><span class="s1">xx.ravel()</span><span class="s2">, </span><span class="s1">cc.ravel()</span><span class="s2">, </span><span class="s1">dd.ravel()):</span>
            <span class="s1">res[i] = stats.trapezoid.pdf(x1</span><span class="s2">, </span><span class="s1">c1</span><span class="s2">, </span><span class="s1">d1)</span>

        <span class="s1">assert_allclose(v</span><span class="s2">, </span><span class="s1">res.reshape(v.shape)</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-15</span><span class="s1">)</span>

        <span class="s3"># Check that the stats() method supports vector arguments.</span>
        <span class="s1">v = np.asarray(stats.trapezoid.stats(c</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">moments=</span><span class="s5">&quot;mvsk&quot;</span><span class="s1">))</span>
        <span class="s1">cc</span><span class="s2">, </span><span class="s1">dd = np.broadcast_arrays(c</span><span class="s2">, </span><span class="s1">d)</span>
        <span class="s1">res = np.empty((cc.size</span><span class="s2">, </span><span class="s4">4</span><span class="s1">))  </span><span class="s3"># 4 stats returned per value</span>
        <span class="s1">ind = np.arange(cc.size)</span>
        <span class="s2">for </span><span class="s1">i</span><span class="s2">, </span><span class="s1">c1</span><span class="s2">, </span><span class="s1">d1 </span><span class="s2">in </span><span class="s1">zip(ind</span><span class="s2">, </span><span class="s1">cc.ravel()</span><span class="s2">, </span><span class="s1">dd.ravel()):</span>
            <span class="s1">res[i] = stats.trapezoid.stats(c1</span><span class="s2">, </span><span class="s1">d1</span><span class="s2">, </span><span class="s1">moments=</span><span class="s5">&quot;mvsk&quot;</span><span class="s1">)</span>

        <span class="s1">assert_allclose(v</span><span class="s2">, </span><span class="s1">res.T.reshape(v.shape)</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-15</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_trapz(self):</span>
        <span class="s3"># Basic test for alias</span>
        <span class="s1">x = np.linspace(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(stats.trapz.pdf(x</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">stats.uniform.pdf(x))</span>


<span class="s2">class </span><span class="s1">TestTriang:</span>
    <span class="s2">def </span><span class="s1">test_edge_cases(self):</span>
        <span class="s2">with </span><span class="s1">np.errstate(all=</span><span class="s5">'raise'</span><span class="s1">):</span>
            <span class="s1">assert_equal(stats.triang.pdf(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s4">2.</span><span class="s1">)</span>
            <span class="s1">assert_equal(stats.triang.pdf(</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">)</span>
            <span class="s1">assert_equal(stats.triang.pdf(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0.</span><span class="s1">)</span>

            <span class="s1">assert_equal(stats.triang.pdf(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
            <span class="s1">assert_equal(stats.triang.pdf(</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">)</span>
            <span class="s1">assert_equal(stats.triang.pdf(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>

            <span class="s1">assert_equal(stats.triang.cdf(</span><span class="s4">0.</span><span class="s2">, </span><span class="s4">0.</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0.</span><span class="s1">)</span>
            <span class="s1">assert_equal(stats.triang.cdf(</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0.75</span><span class="s1">)</span>
            <span class="s1">assert_equal(stats.triang.cdf(</span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">0.</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">)</span>

            <span class="s1">assert_equal(stats.triang.cdf(</span><span class="s4">0.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0.</span><span class="s1">)</span>
            <span class="s1">assert_equal(stats.triang.cdf(</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0.25</span><span class="s1">)</span>
            <span class="s1">assert_equal(stats.triang.cdf(</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestMaxwell:</span>

    <span class="s3"># reference values were computed with wolfram alpha</span>
    <span class="s3"># erfc(x/sqrt(2)) + sqrt(2/pi) * x * e^(-x^2/2)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;x, ref&quot;</span><span class="s2">,</span>
                             <span class="s1">[(</span><span class="s4">20</span><span class="s2">, </span><span class="s4">2.2138865931011177e-86</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">0.01</span><span class="s2">, </span><span class="s4">0.999999734046458435</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_sf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">ref):</span>
        <span class="s1">assert_allclose(stats.maxwell.sf(x)</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-14</span><span class="s1">)</span>

    <span class="s3"># reference values were computed with wolfram alpha</span>
    <span class="s3"># sqrt(2) * sqrt(Q^(-1)(3/2, q))</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;q, ref&quot;</span><span class="s2">,</span>
                             <span class="s1">[(</span><span class="s4">0.001</span><span class="s2">, </span><span class="s4">4.033142223656157022</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">0.9999847412109375</span><span class="s2">, </span><span class="s4">0.0385743284050381</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">2</span><span class="s1">**-</span><span class="s4">55</span><span class="s2">, </span><span class="s4">8.95564974719481</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_isf(self</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">ref):</span>
        <span class="s1">assert_allclose(stats.maxwell.isf(q)</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-15</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestMielke:</span>
    <span class="s2">def </span><span class="s1">test_moments(self):</span>
        <span class="s1">k</span><span class="s2">, </span><span class="s1">s = </span><span class="s4">4.642</span><span class="s2">, </span><span class="s4">0.597</span>
        <span class="s3"># n-th moment exists only if n &lt; s</span>
        <span class="s1">assert_equal(stats.mielke(k</span><span class="s2">, </span><span class="s1">s).moment(</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.inf)</span>
        <span class="s1">assert_equal(stats.mielke(k</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">).moment(</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.inf)</span>
        <span class="s1">assert_(np.isfinite(stats.mielke(k</span><span class="s2">, </span><span class="s4">1.01</span><span class="s1">).moment(</span><span class="s4">1</span><span class="s1">)))</span>

    <span class="s2">def </span><span class="s1">test_burr_equivalence(self):</span>
        <span class="s1">x = np.linspace(</span><span class="s4">0.01</span><span class="s2">, </span><span class="s4">100</span><span class="s2">, </span><span class="s4">50</span><span class="s1">)</span>
        <span class="s1">k</span><span class="s2">, </span><span class="s1">s = </span><span class="s4">2.45</span><span class="s2">, </span><span class="s4">5.32</span>
        <span class="s1">assert_allclose(stats.burr.pdf(x</span><span class="s2">, </span><span class="s1">s</span><span class="s2">, </span><span class="s1">k/s)</span><span class="s2">, </span><span class="s1">stats.mielke.pdf(x</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">s))</span>


<span class="s2">class </span><span class="s1">TestBurr:</span>
    <span class="s2">def </span><span class="s1">test_endpoints_7491(self):</span>
        <span class="s3"># gh-7491</span>
        <span class="s3"># Compute the pdf at the left endpoint dst.a.</span>
        <span class="s1">data = [</span>
            <span class="s1">[stats.fisk</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[stats.burr</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[stats.burr</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[stats.burr</span><span class="s2">, </span><span class="s1">(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[stats.burr12</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[stats.burr12</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[stats.burr12</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s4">2.0</span><span class="s1">]]</span>

        <span class="s1">ans = [_f.pdf(_f.a</span><span class="s2">, </span><span class="s1">*_args) </span><span class="s2">for </span><span class="s1">_f</span><span class="s2">, </span><span class="s1">_args</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">data]</span>
        <span class="s1">correct = [_correct_ </span><span class="s2">for </span><span class="s1">_f</span><span class="s2">, </span><span class="s1">_args</span><span class="s2">, </span><span class="s1">_correct_ </span><span class="s2">in </span><span class="s1">data]</span>
        <span class="s1">assert_array_almost_equal(ans</span><span class="s2">, </span><span class="s1">correct)</span>

        <span class="s1">ans = [_f.logpdf(_f.a</span><span class="s2">, </span><span class="s1">*_args) </span><span class="s2">for </span><span class="s1">_f</span><span class="s2">, </span><span class="s1">_args</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">data]</span>
        <span class="s1">correct = [np.log(_correct_) </span><span class="s2">for </span><span class="s1">_f</span><span class="s2">, </span><span class="s1">_args</span><span class="s2">, </span><span class="s1">_correct_ </span><span class="s2">in </span><span class="s1">data]</span>
        <span class="s1">assert_array_almost_equal(ans</span><span class="s2">, </span><span class="s1">correct)</span>

    <span class="s2">def </span><span class="s1">test_burr_stats_9544(self):</span>
        <span class="s3"># gh-9544.  Test from gh-9978</span>
        <span class="s1">c</span><span class="s2">, </span><span class="s1">d = </span><span class="s4">5.0</span><span class="s2">, </span><span class="s4">3</span>
        <span class="s1">mean</span><span class="s2">, </span><span class="s1">variance = stats.burr(c</span><span class="s2">, </span><span class="s1">d).stats()</span>
        <span class="s3"># mean = sc.beta(3 + 1/5, 1. - 1/5) * 3  = 1.4110263...</span>
        <span class="s3"># var =  sc.beta(3 + 2 / 5, 1. - 2 / 5) * 3 -</span>
        <span class="s3">#        (sc.beta(3 + 1 / 5, 1. - 1 / 5) * 3) ** 2</span>
        <span class="s1">mean_hc</span><span class="s2">, </span><span class="s1">variance_hc = </span><span class="s4">1.4110263183925857</span><span class="s2">, </span><span class="s4">0.22879948026191643</span>
        <span class="s1">assert_allclose(mean</span><span class="s2">, </span><span class="s1">mean_hc)</span>
        <span class="s1">assert_allclose(variance</span><span class="s2">, </span><span class="s1">variance_hc)</span>

    <span class="s2">def </span><span class="s1">test_burr_nan_mean_var_9544(self):</span>
        <span class="s3"># gh-9544.  Test from gh-9978</span>
        <span class="s1">c</span><span class="s2">, </span><span class="s1">d = </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">3</span>
        <span class="s1">mean</span><span class="s2">, </span><span class="s1">variance = stats.burr(c</span><span class="s2">, </span><span class="s1">d).stats()</span>
        <span class="s1">assert_(np.isnan(mean))</span>
        <span class="s1">assert_(np.isnan(variance))</span>
        <span class="s1">c</span><span class="s2">, </span><span class="s1">d = </span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">3</span>
        <span class="s1">mean</span><span class="s2">, </span><span class="s1">variance = stats.burr(c</span><span class="s2">, </span><span class="s1">d).stats()</span>
        <span class="s1">assert_(np.isfinite(mean))</span>
        <span class="s1">assert_(np.isnan(variance))</span>

        <span class="s1">c</span><span class="s2">, </span><span class="s1">d = </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">3</span>
        <span class="s1">e1</span><span class="s2">, </span><span class="s1">e2</span><span class="s2">, </span><span class="s1">e3</span><span class="s2">, </span><span class="s1">e4 = stats.burr._munp(np.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">])</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">d)</span>
        <span class="s1">assert_(np.isnan(e1))</span>
        <span class="s1">assert_(np.isnan(e2))</span>
        <span class="s1">assert_(np.isnan(e3))</span>
        <span class="s1">assert_(np.isnan(e4))</span>
        <span class="s1">c</span><span class="s2">, </span><span class="s1">d = </span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">3</span>
        <span class="s1">e1</span><span class="s2">, </span><span class="s1">e2</span><span class="s2">, </span><span class="s1">e3</span><span class="s2">, </span><span class="s1">e4 = stats.burr._munp([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">d)</span>
        <span class="s1">assert_(np.isfinite(e1))</span>
        <span class="s1">assert_(np.isnan(e2))</span>
        <span class="s1">assert_(np.isnan(e3))</span>
        <span class="s1">assert_(np.isnan(e4))</span>
        <span class="s1">c</span><span class="s2">, </span><span class="s1">d = </span><span class="s4">2.5</span><span class="s2">, </span><span class="s4">3</span>
        <span class="s1">e1</span><span class="s2">, </span><span class="s1">e2</span><span class="s2">, </span><span class="s1">e3</span><span class="s2">, </span><span class="s1">e4 = stats.burr._munp([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">d)</span>
        <span class="s1">assert_(np.isfinite(e1))</span>
        <span class="s1">assert_(np.isfinite(e2))</span>
        <span class="s1">assert_(np.isnan(e3))</span>
        <span class="s1">assert_(np.isnan(e4))</span>
        <span class="s1">c</span><span class="s2">, </span><span class="s1">d = </span><span class="s4">3.5</span><span class="s2">, </span><span class="s4">3</span>
        <span class="s1">e1</span><span class="s2">, </span><span class="s1">e2</span><span class="s2">, </span><span class="s1">e3</span><span class="s2">, </span><span class="s1">e4 = stats.burr._munp([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">d)</span>
        <span class="s1">assert_(np.isfinite(e1))</span>
        <span class="s1">assert_(np.isfinite(e2))</span>
        <span class="s1">assert_(np.isfinite(e3))</span>
        <span class="s1">assert_(np.isnan(e4))</span>
        <span class="s1">c</span><span class="s2">, </span><span class="s1">d = </span><span class="s4">4.5</span><span class="s2">, </span><span class="s4">3</span>
        <span class="s1">e1</span><span class="s2">, </span><span class="s1">e2</span><span class="s2">, </span><span class="s1">e3</span><span class="s2">, </span><span class="s1">e4 = stats.burr._munp([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">d)</span>
        <span class="s1">assert_(np.isfinite(e1))</span>
        <span class="s1">assert_(np.isfinite(e2))</span>
        <span class="s1">assert_(np.isfinite(e3))</span>
        <span class="s1">assert_(np.isfinite(e4))</span>


<span class="s2">class </span><span class="s1">TestBurr12:</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'scale, expected'</span><span class="s2">,</span>
                             <span class="s1">[(</span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">2.3283064359965952e-170</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">3.5</span><span class="s2">, </span><span class="s4">5.987114417447875e-153</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_delta_cdf(self</span><span class="s2">, </span><span class="s1">scale</span><span class="s2">, </span><span class="s1">expected):</span>
        <span class="s3"># Expected value computed with mpmath:</span>
        <span class="s3">#</span>
        <span class="s3"># def burr12sf(x, c, d, scale):</span>
        <span class="s3">#     x = mpmath.mpf(x)</span>
        <span class="s3">#     c = mpmath.mpf(c)</span>
        <span class="s3">#     d = mpmath.mpf(d)</span>
        <span class="s3">#     scale = mpmath.mpf(scale)</span>
        <span class="s3">#     return (mpmath.mp.one + (x/scale)**c)**(-d)</span>
        <span class="s3">#</span>
        <span class="s3"># &gt;&gt;&gt; import mpmath</span>
        <span class="s3"># &gt;&gt;&gt; mpmath.mp.dps = 60</span>
        <span class="s3"># &gt;&gt;&gt; float(burr12sf(2e5, 4, 8, 1) - burr12sf(4e5, 4, 8, 1))</span>
        <span class="s3"># 2.3283064359965952e-170</span>
        <span class="s3"># &gt;&gt;&gt; float(burr12sf(2e5, 4, 8, 3.5) - burr12sf(4e5, 4, 8, 3.5))</span>
        <span class="s3"># 5.987114417447875e-153</span>
        <span class="s3">#</span>
        <span class="s1">delta = stats.burr12._delta_cdf(</span><span class="s4">2e5</span><span class="s2">, </span><span class="s4">4e5</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s1">scale=scale)</span>
        <span class="s1">assert_allclose(delta</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-13</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestStudentizedRange:</span>
    <span class="s3"># For alpha = .05, .01, and .001, and for each value of</span>
    <span class="s3"># v = [1, 3, 10, 20, 120, inf], a Q was picked from each table for</span>
    <span class="s3"># k = [2, 8, 14, 20].</span>

    <span class="s3"># these arrays are written with `k` as column, and `v` as rows.</span>
    <span class="s3"># Q values are taken from table 3:</span>
    <span class="s3"># https://www.jstor.org/stable/2237810</span>
    <span class="s1">q05 = [</span><span class="s4">17.97</span><span class="s2">, </span><span class="s4">45.40</span><span class="s2">, </span><span class="s4">54.33</span><span class="s2">, </span><span class="s4">59.56</span><span class="s2">,</span>
           <span class="s4">4.501</span><span class="s2">, </span><span class="s4">8.853</span><span class="s2">, </span><span class="s4">10.35</span><span class="s2">, </span><span class="s4">11.24</span><span class="s2">,</span>
           <span class="s4">3.151</span><span class="s2">, </span><span class="s4">5.305</span><span class="s2">, </span><span class="s4">6.028</span><span class="s2">, </span><span class="s4">6.467</span><span class="s2">,</span>
           <span class="s4">2.950</span><span class="s2">, </span><span class="s4">4.768</span><span class="s2">, </span><span class="s4">5.357</span><span class="s2">, </span><span class="s4">5.714</span><span class="s2">,</span>
           <span class="s4">2.800</span><span class="s2">, </span><span class="s4">4.363</span><span class="s2">, </span><span class="s4">4.842</span><span class="s2">, </span><span class="s4">5.126</span><span class="s2">,</span>
           <span class="s4">2.772</span><span class="s2">, </span><span class="s4">4.286</span><span class="s2">, </span><span class="s4">4.743</span><span class="s2">, </span><span class="s4">5.012</span><span class="s1">]</span>
    <span class="s1">q01 = [</span><span class="s4">90.03</span><span class="s2">, </span><span class="s4">227.2</span><span class="s2">, </span><span class="s4">271.8</span><span class="s2">, </span><span class="s4">298.0</span><span class="s2">,</span>
           <span class="s4">8.261</span><span class="s2">, </span><span class="s4">15.64</span><span class="s2">, </span><span class="s4">18.22</span><span class="s2">, </span><span class="s4">19.77</span><span class="s2">,</span>
           <span class="s4">4.482</span><span class="s2">, </span><span class="s4">6.875</span><span class="s2">, </span><span class="s4">7.712</span><span class="s2">, </span><span class="s4">8.226</span><span class="s2">,</span>
           <span class="s4">4.024</span><span class="s2">, </span><span class="s4">5.839</span><span class="s2">, </span><span class="s4">6.450</span><span class="s2">, </span><span class="s4">6.823</span><span class="s2">,</span>
           <span class="s4">3.702</span><span class="s2">, </span><span class="s4">5.118</span><span class="s2">, </span><span class="s4">5.562</span><span class="s2">, </span><span class="s4">5.827</span><span class="s2">,</span>
           <span class="s4">3.643</span><span class="s2">, </span><span class="s4">4.987</span><span class="s2">, </span><span class="s4">5.400</span><span class="s2">, </span><span class="s4">5.645</span><span class="s1">]</span>
    <span class="s1">q001 = [</span><span class="s4">900.3</span><span class="s2">, </span><span class="s4">2272</span><span class="s2">, </span><span class="s4">2718</span><span class="s2">, </span><span class="s4">2980</span><span class="s2">,</span>
            <span class="s4">18.28</span><span class="s2">, </span><span class="s4">34.12</span><span class="s2">, </span><span class="s4">39.69</span><span class="s2">, </span><span class="s4">43.05</span><span class="s2">,</span>
            <span class="s4">6.487</span><span class="s2">, </span><span class="s4">9.352</span><span class="s2">, </span><span class="s4">10.39</span><span class="s2">, </span><span class="s4">11.03</span><span class="s2">,</span>
            <span class="s4">5.444</span><span class="s2">, </span><span class="s4">7.313</span><span class="s2">, </span><span class="s4">7.966</span><span class="s2">, </span><span class="s4">8.370</span><span class="s2">,</span>
            <span class="s4">4.772</span><span class="s2">, </span><span class="s4">6.039</span><span class="s2">, </span><span class="s4">6.448</span><span class="s2">, </span><span class="s4">6.695</span><span class="s2">,</span>
            <span class="s4">4.654</span><span class="s2">, </span><span class="s4">5.823</span><span class="s2">, </span><span class="s4">6.191</span><span class="s2">, </span><span class="s4">6.411</span><span class="s1">]</span>
    <span class="s1">qs = np.concatenate((q05</span><span class="s2">, </span><span class="s1">q01</span><span class="s2">, </span><span class="s1">q001))</span>
    <span class="s1">ps = [</span><span class="s4">.95</span><span class="s2">, </span><span class="s4">.99</span><span class="s2">, </span><span class="s4">.999</span><span class="s1">]</span>
    <span class="s1">vs = [</span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">20</span><span class="s2">, </span><span class="s4">120</span><span class="s2">, </span><span class="s1">np.inf]</span>
    <span class="s1">ks = [</span><span class="s4">2</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">14</span><span class="s2">, </span><span class="s4">20</span><span class="s1">]</span>

    <span class="s1">data = list(zip(product(ps</span><span class="s2">, </span><span class="s1">vs</span><span class="s2">, </span><span class="s1">ks)</span><span class="s2">, </span><span class="s1">qs))</span>

    <span class="s3"># A small selection of large-v cases generated with R's `ptukey`</span>
    <span class="s3"># Each case is in the format (q, k, v, r_result)</span>
    <span class="s1">r_data = [</span>
        <span class="s1">(</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">9001</span><span class="s2">, </span><span class="s4">0.002752818526842</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">1000</span><span class="s2">, </span><span class="s4">0.000526142388912</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s1">np.inf</span><span class="s2">, </span><span class="s4">0.240712641229283</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">4</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s1">np.inf</span><span class="s2">, </span><span class="s4">0.987012338626815</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s1">np.inf</span><span class="s2">, </span><span class="s4">0.000519869467083</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">]</span>

    <span class="s2">def </span><span class="s1">test_cdf_against_tables(self):</span>
        <span class="s2">for </span><span class="s1">pvk</span><span class="s2">, </span><span class="s1">q </span><span class="s2">in </span><span class="s1">self.data:</span>
            <span class="s1">p_expected</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">k = pvk</span>
            <span class="s1">res_p = stats.studentized_range.cdf(q</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v)</span>
            <span class="s1">assert_allclose(res_p</span><span class="s2">, </span><span class="s1">p_expected</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-4</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s2">def </span><span class="s1">test_ppf_against_tables(self):</span>
        <span class="s2">for </span><span class="s1">pvk</span><span class="s2">, </span><span class="s1">q_expected </span><span class="s2">in </span><span class="s1">self.data:</span>
            <span class="s1">p</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">k = pvk</span>
            <span class="s1">res_q = stats.studentized_range.ppf(p</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v)</span>
            <span class="s1">assert_allclose(res_q</span><span class="s2">, </span><span class="s1">q_expected</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">5e-4</span><span class="s1">)</span>

    <span class="s1">path_prefix = os.path.dirname(__file__)</span>
    <span class="s1">relative_path = </span><span class="s5">&quot;data/studentized_range_mpmath_ref.json&quot;</span>
    <span class="s2">with </span><span class="s1">open(os.path.join(path_prefix</span><span class="s2">, </span><span class="s1">relative_path)) </span><span class="s2">as </span><span class="s1">file:</span>
        <span class="s1">pregenerated_data = json.load(file)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;case_result&quot;</span><span class="s2">, </span><span class="s1">pregenerated_data[</span><span class="s5">&quot;cdf_data&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_cdf_against_mp(self</span><span class="s2">, </span><span class="s1">case_result):</span>
        <span class="s1">src_case = case_result[</span><span class="s5">&quot;src_case&quot;</span><span class="s1">]</span>
        <span class="s1">mp_result = case_result[</span><span class="s5">&quot;mp_result&quot;</span><span class="s1">]</span>
        <span class="s1">qkv = src_case[</span><span class="s5">&quot;q&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">src_case[</span><span class="s5">&quot;k&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">src_case[</span><span class="s5">&quot;v&quot;</span><span class="s1">]</span>
        <span class="s1">res = stats.studentized_range.cdf(*qkv)</span>

        <span class="s1">assert_allclose(res</span><span class="s2">, </span><span class="s1">mp_result</span><span class="s2">,</span>
                        <span class="s1">atol=src_case[</span><span class="s5">&quot;expected_atol&quot;</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">rtol=src_case[</span><span class="s5">&quot;expected_rtol&quot;</span><span class="s1">])</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;case_result&quot;</span><span class="s2">, </span><span class="s1">pregenerated_data[</span><span class="s5">&quot;pdf_data&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_pdf_against_mp(self</span><span class="s2">, </span><span class="s1">case_result):</span>
        <span class="s1">src_case = case_result[</span><span class="s5">&quot;src_case&quot;</span><span class="s1">]</span>
        <span class="s1">mp_result = case_result[</span><span class="s5">&quot;mp_result&quot;</span><span class="s1">]</span>
        <span class="s1">qkv = src_case[</span><span class="s5">&quot;q&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">src_case[</span><span class="s5">&quot;k&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">src_case[</span><span class="s5">&quot;v&quot;</span><span class="s1">]</span>
        <span class="s1">res = stats.studentized_range.pdf(*qkv)</span>

        <span class="s1">assert_allclose(res</span><span class="s2">, </span><span class="s1">mp_result</span><span class="s2">,</span>
                        <span class="s1">atol=src_case[</span><span class="s5">&quot;expected_atol&quot;</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">rtol=src_case[</span><span class="s5">&quot;expected_rtol&quot;</span><span class="s1">])</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s1">@pytest.mark.xfail_on_32bit(</span><span class="s5">&quot;intermittent RuntimeWarning: invalid value.&quot;</span><span class="s1">)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;case_result&quot;</span><span class="s2">, </span><span class="s1">pregenerated_data[</span><span class="s5">&quot;moment_data&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_moment_against_mp(self</span><span class="s2">, </span><span class="s1">case_result):</span>
        <span class="s1">src_case = case_result[</span><span class="s5">&quot;src_case&quot;</span><span class="s1">]</span>
        <span class="s1">mp_result = case_result[</span><span class="s5">&quot;mp_result&quot;</span><span class="s1">]</span>
        <span class="s1">mkv = src_case[</span><span class="s5">&quot;m&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">src_case[</span><span class="s5">&quot;k&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">src_case[</span><span class="s5">&quot;v&quot;</span><span class="s1">]</span>

        <span class="s3"># Silence invalid value encountered warnings. Actual problems will be</span>
        <span class="s3"># caught by the result comparison.</span>
        <span class="s2">with </span><span class="s1">np.errstate(invalid=</span><span class="s5">'ignore'</span><span class="s1">):</span>
            <span class="s1">res = stats.studentized_range.moment(*mkv)</span>

        <span class="s1">assert_allclose(res</span><span class="s2">, </span><span class="s1">mp_result</span><span class="s2">,</span>
                        <span class="s1">atol=src_case[</span><span class="s5">&quot;expected_atol&quot;</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">rtol=src_case[</span><span class="s5">&quot;expected_rtol&quot;</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">test_pdf_integration(self):</span>
        <span class="s1">k</span><span class="s2">, </span><span class="s1">v = </span><span class="s4">3</span><span class="s2">, </span><span class="s4">10</span>
        <span class="s3"># Test whether PDF integration is 1 like it should be.</span>
        <span class="s1">res = quad(stats.studentized_range.pdf</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">np.inf</span><span class="s2">, </span><span class="s1">args=(k</span><span class="s2">, </span><span class="s1">v))</span>
        <span class="s1">assert_allclose(res[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.xslow</span>
    <span class="s2">def </span><span class="s1">test_pdf_against_cdf(self):</span>
        <span class="s1">k</span><span class="s2">, </span><span class="s1">v = </span><span class="s4">3</span><span class="s2">, </span><span class="s4">10</span>

        <span class="s3"># Test whether the integrated PDF matches the CDF using cumulative</span>
        <span class="s3"># integration. Use a small step size to reduce error due to the</span>
        <span class="s3"># summation. This is slow, but tests the results well.</span>
        <span class="s1">x = np.arange(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s1">step=</span><span class="s4">0.01</span><span class="s1">)</span>

        <span class="s1">y_cdf = stats.studentized_range.cdf(x</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v)[</span><span class="s4">1</span><span class="s1">:]</span>
        <span class="s1">y_pdf_raw = stats.studentized_range.pdf(x</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v)</span>
        <span class="s1">y_pdf_cumulative = cumulative_trapezoid(y_pdf_raw</span><span class="s2">, </span><span class="s1">x)</span>

        <span class="s3"># Because of error caused by the summation, use a relatively large rtol</span>
        <span class="s1">assert_allclose(y_pdf_cumulative</span><span class="s2">, </span><span class="s1">y_cdf</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-4</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;r_case_result&quot;</span><span class="s2">, </span><span class="s1">r_data)</span>
    <span class="s2">def </span><span class="s1">test_cdf_against_r(self</span><span class="s2">, </span><span class="s1">r_case_result):</span>
        <span class="s3"># Test large `v` values using R</span>
        <span class="s1">q</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v</span><span class="s2">, </span><span class="s1">r_res = r_case_result</span>
        <span class="s2">with </span><span class="s1">np.errstate(invalid=</span><span class="s5">'ignore'</span><span class="s1">):</span>
            <span class="s1">res = stats.studentized_range.cdf(q</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v)</span>
        <span class="s1">assert_allclose(res</span><span class="s2">, </span><span class="s1">r_res)</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s1">@pytest.mark.xfail_on_32bit(</span><span class="s5">&quot;intermittent RuntimeWarning: invalid value.&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_moment_vectorization(self):</span>
        <span class="s3"># Test moment broadcasting. Calls `_munp` directly because</span>
        <span class="s3"># `rv_continuous.moment` is broken at time of writing. See gh-12192</span>

        <span class="s3"># Silence invalid value encountered warnings. Actual problems will be</span>
        <span class="s3"># caught by the result comparison.</span>
        <span class="s2">with </span><span class="s1">np.errstate(invalid=</span><span class="s5">'ignore'</span><span class="s1">):</span>
            <span class="s1">m = stats.studentized_range._munp([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">10</span><span class="s2">, </span><span class="s4">11</span><span class="s1">])</span>

        <span class="s1">assert_allclose(m.shape</span><span class="s2">, </span><span class="s1">(</span><span class="s4">2</span><span class="s2">,</span><span class="s1">))</span>

        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s5">&quot;...could not be broadcast...&quot;</span><span class="s1">):</span>
            <span class="s1">stats.studentized_range._munp(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">[</span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">10</span><span class="s2">, </span><span class="s4">11</span><span class="s2">, </span><span class="s4">12</span><span class="s1">])</span>

    <span class="s1">@pytest.mark.xslow</span>
    <span class="s2">def </span><span class="s1">test_fitstart_valid(self):</span>
        <span class="s2">with </span><span class="s1">suppress_warnings() </span><span class="s2">as </span><span class="s1">sup</span><span class="s2">, </span><span class="s1">np.errstate(invalid=</span><span class="s5">&quot;ignore&quot;</span><span class="s1">):</span>
            <span class="s3"># the integration warning message may differ</span>
            <span class="s1">sup.filter(IntegrationWarning)</span>
            <span class="s1">k</span><span class="s2">, </span><span class="s1">df</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">_ = stats.studentized_range._fitstart([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">])</span>
        <span class="s1">assert_(stats.studentized_range._argcheck(k</span><span class="s2">, </span><span class="s1">df))</span>

    <span class="s2">def </span><span class="s1">test_infinite_df(self):</span>
        <span class="s3"># Check that the CDF and PDF infinite and normal integrators</span>
        <span class="s3"># roughly match for a high df case</span>
        <span class="s1">res = stats.studentized_range.pdf(</span><span class="s4">3</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s1">np.inf)</span>
        <span class="s1">res_finite = stats.studentized_range.pdf(</span><span class="s4">3</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">99999</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res</span><span class="s2">, </span><span class="s1">res_finite</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-4</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-4</span><span class="s1">)</span>

        <span class="s1">res = stats.studentized_range.cdf(</span><span class="s4">3</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s1">np.inf)</span>
        <span class="s1">res_finite = stats.studentized_range.cdf(</span><span class="s4">3</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">99999</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res</span><span class="s2">, </span><span class="s1">res_finite</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-4</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-4</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_df_cutoff(self):</span>
        <span class="s3"># Test that the CDF and PDF properly switch integrators at df=100,000.</span>
        <span class="s3"># The infinite integrator should be different enough that it fails</span>
        <span class="s3"># an allclose assertion. Also sanity check that using the same</span>
        <span class="s3"># integrator does pass the allclose with a 1-df difference, which</span>
        <span class="s3"># should be tiny.</span>

        <span class="s1">res = stats.studentized_range.pdf(</span><span class="s4">3</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">100000</span><span class="s1">)</span>
        <span class="s1">res_finite = stats.studentized_range.pdf(</span><span class="s4">3</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">99999</span><span class="s1">)</span>
        <span class="s1">res_sanity = stats.studentized_range.pdf(</span><span class="s4">3</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">99998</span><span class="s1">)</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s2">, </span><span class="s1">assert_allclose</span><span class="s2">, </span><span class="s1">res</span><span class="s2">, </span><span class="s1">res_finite</span><span class="s2">,</span>
                      <span class="s1">atol=</span><span class="s4">1e-6</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-6</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res_finite</span><span class="s2">, </span><span class="s1">res_sanity</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-6</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-6</span><span class="s1">)</span>

        <span class="s1">res = stats.studentized_range.cdf(</span><span class="s4">3</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">100000</span><span class="s1">)</span>
        <span class="s1">res_finite = stats.studentized_range.cdf(</span><span class="s4">3</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">99999</span><span class="s1">)</span>
        <span class="s1">res_sanity = stats.studentized_range.cdf(</span><span class="s4">3</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">99998</span><span class="s1">)</span>
        <span class="s1">assert_raises(AssertionError</span><span class="s2">, </span><span class="s1">assert_allclose</span><span class="s2">, </span><span class="s1">res</span><span class="s2">, </span><span class="s1">res_finite</span><span class="s2">,</span>
                      <span class="s1">atol=</span><span class="s4">1e-6</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-6</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res_finite</span><span class="s2">, </span><span class="s1">res_sanity</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-6</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-6</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_clipping(self):</span>
        <span class="s3"># The result of this computation was -9.9253938401489e-14 on some</span>
        <span class="s3"># systems. The correct result is very nearly zero, but should not be</span>
        <span class="s3"># negative.</span>
        <span class="s1">q</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v = </span><span class="s4">34.6413996195345746</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">339</span>
        <span class="s1">p = stats.studentized_range.sf(q</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v)</span>
        <span class="s1">assert_allclose(p</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-10</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">p &gt;= </span><span class="s4">0</span>


<span class="s2">def </span><span class="s1">test_540_567():</span>
    <span class="s3"># test for nan returned in tickets 540, 567</span>
    <span class="s1">assert_almost_equal(stats.norm.cdf(-</span><span class="s4">1.7624320982</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0.03899815971089126</span><span class="s2">,</span>
                        <span class="s1">decimal=</span><span class="s4">10</span><span class="s2">, </span><span class="s1">err_msg=</span><span class="s5">'test_540_567'</span><span class="s1">)</span>
    <span class="s1">assert_almost_equal(stats.norm.cdf(-</span><span class="s4">1.7624320983</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0.038998159702449846</span><span class="s2">,</span>
                        <span class="s1">decimal=</span><span class="s4">10</span><span class="s2">, </span><span class="s1">err_msg=</span><span class="s5">'test_540_567'</span><span class="s1">)</span>
    <span class="s1">assert_almost_equal(stats.norm.cdf(</span><span class="s4">1.38629436112</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">0.950273420309</span><span class="s2">,</span>
                                       <span class="s1">scale=</span><span class="s4">0.204423758009</span><span class="s1">)</span><span class="s2">,</span>
                        <span class="s4">0.98353464004309321</span><span class="s2">,</span>
                        <span class="s1">decimal=</span><span class="s4">10</span><span class="s2">, </span><span class="s1">err_msg=</span><span class="s5">'test_540_567'</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_regression_ticket_1326():</span>
    <span class="s3"># adjust to avoid nan with 0*log(0)</span>
    <span class="s1">assert_almost_equal(stats.chi2.pdf(</span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">14</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_regression_tukey_lambda():</span>
    <span class="s3"># Make sure that Tukey-Lambda distribution correctly handles</span>
    <span class="s3"># non-positive lambdas.</span>
    <span class="s1">x = np.linspace(-</span><span class="s4">5.0</span><span class="s2">, </span><span class="s4">5.0</span><span class="s2">, </span><span class="s4">101</span><span class="s1">)</span>

    <span class="s2">with </span><span class="s1">np.errstate(divide=</span><span class="s5">'ignore'</span><span class="s1">):</span>
        <span class="s2">for </span><span class="s1">lam </span><span class="s2">in </span><span class="s1">[</span><span class="s4">0.0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2.0</span><span class="s2">, </span><span class="s1">np.array([[-</span><span class="s4">1.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[-</span><span class="s4">2.0</span><span class="s1">]])]:</span>
            <span class="s1">p = stats.tukeylambda.pdf(x</span><span class="s2">, </span><span class="s1">lam)</span>
            <span class="s1">assert_((p != </span><span class="s4">0.0</span><span class="s1">).all())</span>
            <span class="s1">assert_(~np.isnan(p).all())</span>

        <span class="s1">lam = np.array([[-</span><span class="s4">1.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2.0</span><span class="s1">]])</span>
        <span class="s1">p = stats.tukeylambda.pdf(x</span><span class="s2">, </span><span class="s1">lam)</span>

    <span class="s1">assert_(~np.isnan(p).all())</span>
    <span class="s1">assert_((p[</span><span class="s4">0</span><span class="s1">] != </span><span class="s4">0.0</span><span class="s1">).all())</span>
    <span class="s1">assert_((p[</span><span class="s4">1</span><span class="s1">] != </span><span class="s4">0.0</span><span class="s1">).all())</span>
    <span class="s1">assert_((p[</span><span class="s4">2</span><span class="s1">] != </span><span class="s4">0.0</span><span class="s1">).any())</span>
    <span class="s1">assert_((p[</span><span class="s4">2</span><span class="s1">] == </span><span class="s4">0.0</span><span class="s1">).any())</span>


<span class="s1">@pytest.mark.skipif(DOCSTRINGS_STRIPPED</span><span class="s2">, </span><span class="s1">reason=</span><span class="s5">&quot;docstrings stripped&quot;</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_regression_ticket_1421():</span>
    <span class="s1">assert_(</span><span class="s5">'pdf(x, mu, loc=0, scale=1)' </span><span class="s2">not in </span><span class="s1">stats.poisson.__doc__)</span>
    <span class="s1">assert_(</span><span class="s5">'pmf(x,' </span><span class="s2">in </span><span class="s1">stats.poisson.__doc__)</span>


<span class="s2">def </span><span class="s1">test_nan_arguments_gh_issue_1362():</span>
    <span class="s2">with </span><span class="s1">np.errstate(invalid=</span><span class="s5">'ignore'</span><span class="s1">):</span>
        <span class="s1">assert_(np.isnan(stats.t.logcdf(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">np.nan)))</span>
        <span class="s1">assert_(np.isnan(stats.t.cdf(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">np.nan)))</span>
        <span class="s1">assert_(np.isnan(stats.t.logsf(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">np.nan)))</span>
        <span class="s1">assert_(np.isnan(stats.t.sf(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">np.nan)))</span>
        <span class="s1">assert_(np.isnan(stats.t.pdf(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">np.nan)))</span>
        <span class="s1">assert_(np.isnan(stats.t.logpdf(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">np.nan)))</span>
        <span class="s1">assert_(np.isnan(stats.t.ppf(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">np.nan)))</span>
        <span class="s1">assert_(np.isnan(stats.t.isf(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">np.nan)))</span>

        <span class="s1">assert_(np.isnan(stats.bernoulli.logcdf(np.nan</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)))</span>
        <span class="s1">assert_(np.isnan(stats.bernoulli.cdf(np.nan</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)))</span>
        <span class="s1">assert_(np.isnan(stats.bernoulli.logsf(np.nan</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)))</span>
        <span class="s1">assert_(np.isnan(stats.bernoulli.sf(np.nan</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)))</span>
        <span class="s1">assert_(np.isnan(stats.bernoulli.pmf(np.nan</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)))</span>
        <span class="s1">assert_(np.isnan(stats.bernoulli.logpmf(np.nan</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)))</span>
        <span class="s1">assert_(np.isnan(stats.bernoulli.ppf(np.nan</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)))</span>
        <span class="s1">assert_(np.isnan(stats.bernoulli.isf(np.nan</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)))</span>


<span class="s2">def </span><span class="s1">test_frozen_fit_ticket_1536():</span>
    <span class="s1">np.random.seed(</span><span class="s4">5678</span><span class="s1">)</span>
    <span class="s1">true = np.array([</span><span class="s4">0.25</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">])</span>
    <span class="s1">x = stats.lognorm.rvs(true[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">true[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">true[</span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">100</span><span class="s1">)</span>

    <span class="s2">with </span><span class="s1">np.errstate(divide=</span><span class="s5">'ignore'</span><span class="s1">):</span>
        <span class="s1">params = np.array(stats.lognorm.fit(x</span><span class="s2">, </span><span class="s1">floc=</span><span class="s4">0.</span><span class="s1">))</span>

    <span class="s1">assert_almost_equal(params</span><span class="s2">, </span><span class="s1">true</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">2</span><span class="s1">)</span>

    <span class="s1">params = np.array(stats.lognorm.fit(x</span><span class="s2">, </span><span class="s1">fscale=</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">0</span><span class="s1">))</span>
    <span class="s1">assert_almost_equal(params</span><span class="s2">, </span><span class="s1">true</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">2</span><span class="s1">)</span>

    <span class="s1">params = np.array(stats.lognorm.fit(x</span><span class="s2">, </span><span class="s1">f0=</span><span class="s4">0.25</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">0</span><span class="s1">))</span>
    <span class="s1">assert_almost_equal(params</span><span class="s2">, </span><span class="s1">true</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">2</span><span class="s1">)</span>

    <span class="s1">params = np.array(stats.lognorm.fit(x</span><span class="s2">, </span><span class="s1">f0=</span><span class="s4">0.25</span><span class="s2">, </span><span class="s1">floc=</span><span class="s4">0</span><span class="s1">))</span>
    <span class="s1">assert_almost_equal(params</span><span class="s2">, </span><span class="s1">true</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">2</span><span class="s1">)</span>

    <span class="s1">np.random.seed(</span><span class="s4">5678</span><span class="s1">)</span>
    <span class="s1">loc = </span><span class="s4">1</span>
    <span class="s1">floc = </span><span class="s4">0.9</span>
    <span class="s1">x = stats.norm.rvs(loc</span><span class="s2">, </span><span class="s4">2.</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">100</span><span class="s1">)</span>
    <span class="s1">params = np.array(stats.norm.fit(x</span><span class="s2">, </span><span class="s1">floc=floc))</span>
    <span class="s1">expected = np.array([floc</span><span class="s2">, </span><span class="s1">np.sqrt(((x-floc)**</span><span class="s4">2</span><span class="s1">).mean())])</span>
    <span class="s1">assert_almost_equal(params</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">4</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_regression_ticket_1530():</span>
    <span class="s3"># Check the starting value works for Cauchy distribution fit.</span>
    <span class="s1">np.random.seed(</span><span class="s4">654321</span><span class="s1">)</span>
    <span class="s1">rvs = stats.cauchy.rvs(size=</span><span class="s4">100</span><span class="s1">)</span>
    <span class="s1">params = stats.cauchy.fit(rvs)</span>
    <span class="s1">expected = (</span><span class="s4">0.045</span><span class="s2">, </span><span class="s4">1.142</span><span class="s1">)</span>
    <span class="s1">assert_almost_equal(params</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">1</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_gh_pr_4806():</span>
    <span class="s3"># Check starting values for Cauchy distribution fit.</span>
    <span class="s1">np.random.seed(</span><span class="s4">1234</span><span class="s1">)</span>
    <span class="s1">x = np.random.randn(</span><span class="s4">42</span><span class="s1">)</span>
    <span class="s2">for </span><span class="s1">offset </span><span class="s2">in </span><span class="s4">10000.0</span><span class="s2">, </span><span class="s4">1222333444.0</span><span class="s1">:</span>
        <span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = stats.cauchy.fit(x + offset)</span>
        <span class="s1">assert_allclose(loc</span><span class="s2">, </span><span class="s1">offset</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1.0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(scale</span><span class="s2">, </span><span class="s4">0.6</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1.0</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_tukeylambda_stats_ticket_1545():</span>
    <span class="s3"># Some test for the variance and kurtosis of the Tukey Lambda distr.</span>
    <span class="s3"># See test_tukeylamdba_stats.py for more tests.</span>

    <span class="s1">mv = stats.tukeylambda.stats(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">moments=</span><span class="s5">'mvsk'</span><span class="s1">)</span>
    <span class="s3"># Known exact values:</span>
    <span class="s1">expected = [</span><span class="s4">0</span><span class="s2">, </span><span class="s1">np.pi**</span><span class="s4">2</span><span class="s1">/</span><span class="s4">3</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1.2</span><span class="s1">]</span>
    <span class="s1">assert_almost_equal(mv</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">10</span><span class="s1">)</span>

    <span class="s1">mv = stats.tukeylambda.stats(</span><span class="s4">3.13</span><span class="s2">, </span><span class="s1">moments=</span><span class="s5">'mvsk'</span><span class="s1">)</span>
    <span class="s3"># 'expected' computed with mpmath.</span>
    <span class="s1">expected = [</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0.0269220858861465102</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.898062386219224104</span><span class="s1">]</span>
    <span class="s1">assert_almost_equal(mv</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">10</span><span class="s1">)</span>

    <span class="s1">mv = stats.tukeylambda.stats(</span><span class="s4">0.14</span><span class="s2">, </span><span class="s1">moments=</span><span class="s5">'mvsk'</span><span class="s1">)</span>
    <span class="s3"># 'expected' computed with mpmath.</span>
    <span class="s1">expected = [</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2.11029702221450250</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.02708377353223019456</span><span class="s1">]</span>
    <span class="s1">assert_almost_equal(mv</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">10</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_poisson_logpmf_ticket_1436():</span>
    <span class="s1">assert_(np.isfinite(stats.poisson.logpmf(</span><span class="s4">1500</span><span class="s2">, </span><span class="s4">200</span><span class="s1">)))</span>


<span class="s2">def </span><span class="s1">test_powerlaw_stats():</span>
    <span class="s0">&quot;&quot;&quot;Test the powerlaw stats function. 
 
    This unit test is also a regression test for ticket 1548. 
 
    The exact values are: 
    mean: 
        mu = a / (a + 1) 
    variance: 
        sigma**2 = a / ((a + 2) * (a + 1) ** 2) 
    skewness: 
        One formula (see https://en.wikipedia.org/wiki/Skewness) is 
            gamma_1 = (E[X**3] - 3*mu*E[X**2] + 2*mu**3) / sigma**3 
        A short calculation shows that E[X**k] is a / (a + k), so gamma_1 
        can be implemented as 
            n = a/(a+3) - 3*(a/(a+1))*a/(a+2) + 2*(a/(a+1))**3 
            d = sqrt(a/((a+2)*(a+1)**2)) ** 3 
            gamma_1 = n/d 
        Either by simplifying, or by a direct calculation of mu_3 / sigma**3, 
        one gets the more concise formula: 
            gamma_1 = -2.0 * ((a - 1) / (a + 3)) * sqrt((a + 2) / a) 
    kurtosis: (See https://en.wikipedia.org/wiki/Kurtosis) 
        The excess kurtosis is 
            gamma_2 = mu_4 / sigma**4 - 3 
        A bit of calculus and algebra (sympy helps) shows that 
            mu_4 = 3*a*(3*a**2 - a + 2) / ((a+1)**4 * (a+2) * (a+3) * (a+4)) 
        so 
            gamma_2 = 3*(3*a**2 - a + 2) * (a+2) / (a*(a+3)*(a+4)) - 3 
        which can be rearranged to 
            gamma_2 = 6 * (a**3 - a**2 - 6*a + 2) / (a*(a+3)*(a+4)) 
    &quot;&quot;&quot;</span>
    <span class="s1">cases = [(</span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">/</span><span class="s4">12</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.2</span><span class="s1">))</span><span class="s2">,</span>
             <span class="s1">(</span><span class="s4">2.0</span><span class="s2">, </span><span class="s1">(</span><span class="s4">2.</span><span class="s1">/</span><span class="s4">3</span><span class="s2">, </span><span class="s4">2.</span><span class="s1">/</span><span class="s4">36</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.56568542494924734</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.6</span><span class="s1">))]</span>
    <span class="s2">for </span><span class="s1">a</span><span class="s2">, </span><span class="s1">exact_mvsk </span><span class="s2">in </span><span class="s1">cases:</span>
        <span class="s1">mvsk = stats.powerlaw.stats(a</span><span class="s2">, </span><span class="s1">moments=</span><span class="s5">&quot;mvsk&quot;</span><span class="s1">)</span>
        <span class="s1">assert_array_almost_equal(mvsk</span><span class="s2">, </span><span class="s1">exact_mvsk)</span>


<span class="s2">def </span><span class="s1">test_powerlaw_edge():</span>
    <span class="s3"># Regression test for gh-3986.</span>
    <span class="s1">p = stats.powerlaw.logpdf(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(p</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_exponpow_edge():</span>
    <span class="s3"># Regression test for gh-3982.</span>
    <span class="s1">p = stats.exponpow.logpdf(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(p</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">)</span>

    <span class="s3"># Check pdf and logpdf at x = 0 for other values of b.</span>
    <span class="s1">p = stats.exponpow.pdf(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.25</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">1.5</span><span class="s1">])</span>
    <span class="s1">assert_equal(p</span><span class="s2">, </span><span class="s1">[np.inf</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">])</span>
    <span class="s1">p = stats.exponpow.logpdf(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.25</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">1.5</span><span class="s1">])</span>
    <span class="s1">assert_equal(p</span><span class="s2">, </span><span class="s1">[np.inf</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s1">-np.inf])</span>


<span class="s2">def </span><span class="s1">test_gengamma_edge():</span>
    <span class="s3"># Regression test for gh-3985.</span>
    <span class="s1">p = stats.gengamma.pdf(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(p</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;a, c, ref, tol&quot;</span><span class="s2">,</span>
                         <span class="s1">[(</span><span class="s4">1500000.0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">8.529426144018633</span><span class="s2">, </span><span class="s4">1e-15</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">(</span><span class="s4">1e+30</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">35.95771492811536</span><span class="s2">, </span><span class="s4">1e-15</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">(</span><span class="s4">1e+100</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">116.54819318290696</span><span class="s2">, </span><span class="s4">1e-15</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">(</span><span class="s4">3e3</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">5.422011196659015</span><span class="s2">, </span><span class="s4">1e-13</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">(</span><span class="s4">3e6</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1e100</span><span class="s2">, </span><span class="s1">-</span><span class="s4">236.29663213396054</span><span class="s2">, </span><span class="s4">1e-15</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">(</span><span class="s4">3e60</span><span class="s2">, </span><span class="s4">1e-100</span><span class="s2">, </span><span class="s4">1.3925371786831085e+102</span><span class="s2">, </span><span class="s4">1e-15</span><span class="s1">)])</span>
<span class="s2">def </span><span class="s1">test_gengamma_extreme_entropy(a</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">tol):</span>
    <span class="s3"># The reference values were calculated with mpmath:</span>
    <span class="s3"># from mpmath import mp</span>
    <span class="s3"># mp.dps = 500</span>
    <span class="s3">#</span>
    <span class="s3"># def gen_entropy(a, c):</span>
    <span class="s3">#     a, c = mp.mpf(a), mp.mpf(c)</span>
    <span class="s3">#     val = mp.digamma(a)</span>
    <span class="s3">#     h = (a * (mp.one - val) + val/c + mp.loggamma(a) - mp.log(abs(c)))</span>
    <span class="s3">#     return float(h)</span>
    <span class="s1">assert_allclose(stats.gengamma.entropy(a</span><span class="s2">, </span><span class="s1">c)</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">rtol=tol)</span>


<span class="s2">def </span><span class="s1">test_gengamma_endpoint_with_neg_c():</span>
    <span class="s1">p = stats.gengamma.pdf(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">p == </span><span class="s4">0.0</span>
    <span class="s1">logp = stats.gengamma.logpdf(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">logp == -np.inf</span>


<span class="s2">def </span><span class="s1">test_gengamma_munp():</span>
    <span class="s3"># Regression tests for gh-4724.</span>
    <span class="s1">p = stats.gengamma._munp(-</span><span class="s4">2</span><span class="s2">, </span><span class="s4">200</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">)</span>
    <span class="s1">assert_almost_equal(p</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">/</span><span class="s4">199</span><span class="s1">/</span><span class="s4">198</span><span class="s1">)</span>

    <span class="s1">p = stats.gengamma._munp(-</span><span class="s4">2</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">)</span>
    <span class="s1">assert_almost_equal(p</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">/</span><span class="s4">9</span><span class="s1">/</span><span class="s4">8</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_ksone_fit_freeze():</span>
    <span class="s3"># Regression test for ticket #1638.</span>
    <span class="s1">d = np.array(</span>
        <span class="s1">[-</span><span class="s4">0.18879233</span><span class="s2">, </span><span class="s4">0.15734249</span><span class="s2">, </span><span class="s4">0.18695107</span><span class="s2">, </span><span class="s4">0.27908787</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.248649</span><span class="s2">,</span>
         <span class="s1">-</span><span class="s4">0.2171497</span><span class="s2">, </span><span class="s4">0.12233512</span><span class="s2">, </span><span class="s4">0.15126419</span><span class="s2">, </span><span class="s4">0.03119282</span><span class="s2">, </span><span class="s4">0.4365294</span><span class="s2">,</span>
         <span class="s4">0.08930393</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.23509903</span><span class="s2">, </span><span class="s4">0.28231224</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.09974875</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.25196048</span><span class="s2">,</span>
         <span class="s4">0.11102028</span><span class="s2">, </span><span class="s4">0.1427649</span><span class="s2">, </span><span class="s4">0.10176452</span><span class="s2">, </span><span class="s4">0.18754054</span><span class="s2">, </span><span class="s4">0.25826724</span><span class="s2">,</span>
         <span class="s4">0.05988819</span><span class="s2">, </span><span class="s4">0.0531668</span><span class="s2">, </span><span class="s4">0.21906056</span><span class="s2">, </span><span class="s4">0.32106729</span><span class="s2">, </span><span class="s4">0.2117662</span><span class="s2">,</span>
         <span class="s4">0.10886442</span><span class="s2">, </span><span class="s4">0.09375789</span><span class="s2">, </span><span class="s4">0.24583286</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.22968366</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.07842391</span><span class="s2">,</span>
         <span class="s1">-</span><span class="s4">0.31195432</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.21271196</span><span class="s2">, </span><span class="s4">0.1114243</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.13293002</span><span class="s2">, </span><span class="s4">0.01331725</span><span class="s2">,</span>
         <span class="s1">-</span><span class="s4">0.04330977</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.09485776</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.28434547</span><span class="s2">, </span><span class="s4">0.22245721</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.18518199</span><span class="s2">,</span>
         <span class="s1">-</span><span class="s4">0.10943985</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.35243174</span><span class="s2">, </span><span class="s4">0.06897665</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.03553363</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.0701746</span><span class="s2">,</span>
         <span class="s1">-</span><span class="s4">0.06037974</span><span class="s2">, </span><span class="s4">0.37670779</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.21684405</span><span class="s1">])</span>

    <span class="s2">with </span><span class="s1">np.errstate(invalid=</span><span class="s5">'ignore'</span><span class="s1">):</span>
        <span class="s2">with </span><span class="s1">suppress_warnings() </span><span class="s2">as </span><span class="s1">sup:</span>
            <span class="s1">sup.filter(IntegrationWarning</span><span class="s2">,</span>
                       <span class="s5">&quot;The maximum number of subdivisions .50. has been &quot;</span>
                       <span class="s5">&quot;achieved.&quot;</span><span class="s1">)</span>
            <span class="s1">sup.filter(RuntimeWarning</span><span class="s2">,</span>
                       <span class="s5">&quot;floating point number truncated to an integer&quot;</span><span class="s1">)</span>
            <span class="s1">stats.ksone.fit(d)</span>


<span class="s2">def </span><span class="s1">test_norm_logcdf():</span>
    <span class="s3"># Test precision of the logcdf of the normal distribution.</span>
    <span class="s3"># This precision was enhanced in ticket 1614.</span>
    <span class="s1">x = -np.asarray(list(range(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">120</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)))</span>
    <span class="s3"># Values from R</span>
    <span class="s1">expected = [-</span><span class="s4">0.69314718</span><span class="s2">, </span><span class="s1">-</span><span class="s4">10.36010149</span><span class="s2">, </span><span class="s1">-</span><span class="s4">35.01343716</span><span class="s2">, </span><span class="s1">-</span><span class="s4">75.41067300</span><span class="s2">,</span>
                <span class="s1">-</span><span class="s4">131.69539607</span><span class="s2">, </span><span class="s1">-</span><span class="s4">203.91715537</span><span class="s2">, </span><span class="s1">-</span><span class="s4">292.09872100</span><span class="s2">, </span><span class="s1">-</span><span class="s4">396.25241451</span><span class="s2">,</span>
                <span class="s1">-</span><span class="s4">516.38564863</span><span class="s2">, </span><span class="s1">-</span><span class="s4">652.50322759</span><span class="s2">, </span><span class="s1">-</span><span class="s4">804.60844201</span><span class="s2">, </span><span class="s1">-</span><span class="s4">972.70364403</span><span class="s2">,</span>
                <span class="s1">-</span><span class="s4">1156.79057310</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1356.87055173</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1572.94460885</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1805.01356068</span><span class="s2">,</span>
                <span class="s1">-</span><span class="s4">2053.07806561</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2317.13866238</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2597.19579746</span><span class="s2">, </span><span class="s1">-</span><span class="s4">2893.24984493</span><span class="s2">,</span>
                <span class="s1">-</span><span class="s4">3205.30112136</span><span class="s2">, </span><span class="s1">-</span><span class="s4">3533.34989701</span><span class="s2">, </span><span class="s1">-</span><span class="s4">3877.39640444</span><span class="s2">, </span><span class="s1">-</span><span class="s4">4237.44084522</span><span class="s2">,</span>
                <span class="s1">-</span><span class="s4">4613.48339520</span><span class="s2">, </span><span class="s1">-</span><span class="s4">5005.52420869</span><span class="s2">, </span><span class="s1">-</span><span class="s4">5413.56342187</span><span class="s2">, </span><span class="s1">-</span><span class="s4">5837.60115548</span><span class="s2">,</span>
                <span class="s1">-</span><span class="s4">6277.63751711</span><span class="s2">, </span><span class="s1">-</span><span class="s4">6733.67260303</span><span class="s1">]</span>

    <span class="s1">assert_allclose(stats.norm().logcdf(x)</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-8</span><span class="s1">)</span>

    <span class="s3"># also test the complex-valued code path</span>
    <span class="s1">assert_allclose(stats.norm().logcdf(x + </span><span class="s4">1e-14j</span><span class="s1">).real</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-8</span><span class="s1">)</span>

    <span class="s3"># test the accuracy: d(logcdf)/dx = pdf / cdf \equiv exp(logpdf - logcdf)</span>
    <span class="s1">deriv = (stats.norm.logcdf(x + </span><span class="s4">1e-10j</span><span class="s1">)/</span><span class="s4">1e-10</span><span class="s1">).imag</span>
    <span class="s1">deriv_expected = np.exp(stats.norm.logpdf(x) - stats.norm.logcdf(x))</span>
    <span class="s1">assert_allclose(deriv</span><span class="s2">, </span><span class="s1">deriv_expected</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-10</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_levy_cdf_ppf():</span>
    <span class="s3"># Test levy.cdf, including small arguments.</span>
    <span class="s1">x = np.array([</span><span class="s4">1000</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.01</span><span class="s2">, </span><span class="s4">0.001</span><span class="s1">])</span>

    <span class="s3"># Expected values were calculated separately with mpmath.</span>
    <span class="s3"># E.g.</span>
    <span class="s3"># &gt;&gt;&gt; mpmath.mp.dps = 100</span>
    <span class="s3"># &gt;&gt;&gt; x = mpmath.mp.mpf('0.01')</span>
    <span class="s3"># &gt;&gt;&gt; cdf = mpmath.erfc(mpmath.sqrt(1/(2*x)))</span>
    <span class="s1">expected = np.array([</span><span class="s4">0.9747728793699604</span><span class="s2">,</span>
                         <span class="s4">0.3173105078629141</span><span class="s2">,</span>
                         <span class="s4">0.1572992070502851</span><span class="s2">,</span>
                         <span class="s4">0.0015654022580025495</span><span class="s2">,</span>
                         <span class="s4">1.523970604832105e-23</span><span class="s2">,</span>
                         <span class="s4">1.795832784800726e-219</span><span class="s1">])</span>

    <span class="s1">y = stats.levy.cdf(x)</span>
    <span class="s1">assert_allclose(y</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-10</span><span class="s1">)</span>

    <span class="s3"># ppf(expected) should get us back to x.</span>
    <span class="s1">xx = stats.levy.ppf(expected)</span>
    <span class="s1">assert_allclose(xx</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-13</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_levy_sf():</span>
    <span class="s3"># Large values, far into the tail of the distribution.</span>
    <span class="s1">x = np.array([</span><span class="s4">1e15</span><span class="s2">, </span><span class="s4">1e25</span><span class="s2">, </span><span class="s4">1e35</span><span class="s2">, </span><span class="s4">1e50</span><span class="s1">])</span>
    <span class="s3"># Expected values were calculated with mpmath.</span>
    <span class="s1">expected = np.array([</span><span class="s4">2.5231325220201597e-08</span><span class="s2">,</span>
                         <span class="s4">2.52313252202016e-13</span><span class="s2">,</span>
                         <span class="s4">2.52313252202016e-18</span><span class="s2">,</span>
                         <span class="s4">7.978845608028653e-26</span><span class="s1">])</span>
    <span class="s1">y = stats.levy.sf(x)</span>
    <span class="s1">assert_allclose(y</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-14</span><span class="s1">)</span>


<span class="s3"># The expected values for levy.isf(p) were calculated with mpmath.</span>
<span class="s3"># For loc=0 and scale=1, the inverse SF can be computed with</span>
<span class="s3">#</span>
<span class="s3">#     import mpmath</span>
<span class="s3">#</span>
<span class="s3">#     def levy_invsf(p):</span>
<span class="s3">#         return 1/(2*mpmath.erfinv(p)**2)</span>
<span class="s3">#</span>
<span class="s3"># For example, with mpmath.mp.dps set to 60, float(levy_invsf(1e-20))</span>
<span class="s3"># returns 6.366197723675814e+39.</span>
<span class="s3">#</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s5">'p, expected_isf'</span><span class="s2">,</span>
                         <span class="s1">[(</span><span class="s4">1e-20</span><span class="s2">, </span><span class="s4">6.366197723675814e+39</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">(</span><span class="s4">1e-8</span><span class="s2">, </span><span class="s4">6366197723675813.0</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">(</span><span class="s4">0.375</span><span class="s2">, </span><span class="s4">4.185810119346273</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">(</span><span class="s4">0.875</span><span class="s2">, </span><span class="s4">0.42489442055310134</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">(</span><span class="s4">0.999</span><span class="s2">, </span><span class="s4">0.09235685880262713</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">(</span><span class="s4">0.9999999962747097</span><span class="s2">, </span><span class="s4">0.028766845244146945</span><span class="s1">)])</span>
<span class="s2">def </span><span class="s1">test_levy_isf(p</span><span class="s2">, </span><span class="s1">expected_isf):</span>
    <span class="s1">x = stats.levy.isf(p)</span>
    <span class="s1">assert_allclose(x</span><span class="s2">, </span><span class="s1">expected_isf</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">5e-15</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_levy_l_sf():</span>
    <span class="s3"># Test levy_l.sf for small arguments.</span>
    <span class="s1">x = np.array([-</span><span class="s4">0.016</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.01</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.005</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.0015</span><span class="s1">])</span>
    <span class="s3"># Expected values were calculated with mpmath.</span>
    <span class="s1">expected = np.array([</span><span class="s4">2.6644463892359302e-15</span><span class="s2">,</span>
                         <span class="s4">1.523970604832107e-23</span><span class="s2">,</span>
                         <span class="s4">2.0884875837625492e-45</span><span class="s2">,</span>
                         <span class="s4">5.302850374626878e-147</span><span class="s1">])</span>
    <span class="s1">y = stats.levy_l.sf(x)</span>
    <span class="s1">assert_allclose(y</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-13</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_levy_l_isf():</span>
    <span class="s3"># Test roundtrip sf(isf(p)), including a small input value.</span>
    <span class="s1">p = np.array([</span><span class="s4">3.0e-15</span><span class="s2">, </span><span class="s4">0.25</span><span class="s2">, </span><span class="s4">0.99</span><span class="s1">])</span>
    <span class="s1">x = stats.levy_l.isf(p)</span>
    <span class="s1">q = stats.levy_l.sf(x)</span>
    <span class="s1">assert_allclose(q</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">5e-14</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_hypergeom_interval_1802():</span>
    <span class="s3"># these two had endless loops</span>
    <span class="s1">assert_equal(stats.hypergeom.interval(</span><span class="s4">.95</span><span class="s2">, </span><span class="s4">187601</span><span class="s2">, </span><span class="s4">43192</span><span class="s2">, </span><span class="s4">757</span><span class="s1">)</span><span class="s2">,</span>
                 <span class="s1">(</span><span class="s4">152.0</span><span class="s2">, </span><span class="s4">197.0</span><span class="s1">))</span>
    <span class="s1">assert_equal(stats.hypergeom.interval(</span><span class="s4">.945</span><span class="s2">, </span><span class="s4">187601</span><span class="s2">, </span><span class="s4">43192</span><span class="s2">, </span><span class="s4">757</span><span class="s1">)</span><span class="s2">,</span>
                 <span class="s1">(</span><span class="s4">152.0</span><span class="s2">, </span><span class="s4">197.0</span><span class="s1">))</span>
    <span class="s3"># this was working also before</span>
    <span class="s1">assert_equal(stats.hypergeom.interval(</span><span class="s4">.94</span><span class="s2">, </span><span class="s4">187601</span><span class="s2">, </span><span class="s4">43192</span><span class="s2">, </span><span class="s4">757</span><span class="s1">)</span><span class="s2">,</span>
                 <span class="s1">(</span><span class="s4">153.0</span><span class="s2">, </span><span class="s4">196.0</span><span class="s1">))</span>

    <span class="s3"># degenerate case .a == .b</span>
    <span class="s1">assert_equal(stats.hypergeom.ppf(</span><span class="s4">0.02</span><span class="s2">, </span><span class="s4">100</span><span class="s2">, </span><span class="s4">100</span><span class="s2">, </span><span class="s4">8</span><span class="s1">)</span><span class="s2">, </span><span class="s4">8</span><span class="s1">)</span>
    <span class="s1">assert_equal(stats.hypergeom.ppf(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">100</span><span class="s2">, </span><span class="s4">100</span><span class="s2">, </span><span class="s4">8</span><span class="s1">)</span><span class="s2">, </span><span class="s4">8</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_distribution_too_many_args():</span>
    <span class="s1">np.random.seed(</span><span class="s4">1234</span><span class="s1">)</span>

    <span class="s3"># Check that a TypeError is raised when too many args are given to a method</span>
    <span class="s3"># Regression test for ticket 1815.</span>
    <span class="s1">x = np.linspace(</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.7</span><span class="s2">, </span><span class="s1">num=</span><span class="s4">5</span><span class="s1">)</span>
    <span class="s1">assert_raises(TypeError</span><span class="s2">, </span><span class="s1">stats.gamma.pdf</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">1.0</span><span class="s1">)</span>
    <span class="s1">assert_raises(TypeError</span><span class="s2">, </span><span class="s1">stats.gamma.pdf</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">1.0</span><span class="s1">)</span>
    <span class="s1">assert_raises(TypeError</span><span class="s2">, </span><span class="s1">stats.gamma.pdf</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s1">)</span>
    <span class="s1">assert_raises(TypeError</span><span class="s2">, </span><span class="s1">stats.gamma.pdf</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">0.5</span><span class="s1">)</span>
    <span class="s1">assert_raises(TypeError</span><span class="s2">, </span><span class="s1">stats.gamma.rvs</span><span class="s2">, </span><span class="s4">2.</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">0.5</span><span class="s1">)</span>
    <span class="s1">assert_raises(TypeError</span><span class="s2">, </span><span class="s1">stats.gamma.cdf</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s4">2.</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">0.5</span><span class="s1">)</span>
    <span class="s1">assert_raises(TypeError</span><span class="s2">, </span><span class="s1">stats.gamma.ppf</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s4">2.</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">0.5</span><span class="s1">)</span>
    <span class="s1">assert_raises(TypeError</span><span class="s2">, </span><span class="s1">stats.gamma.stats</span><span class="s2">, </span><span class="s4">2.</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">0.5</span><span class="s1">)</span>
    <span class="s1">assert_raises(TypeError</span><span class="s2">, </span><span class="s1">stats.gamma.entropy</span><span class="s2">, </span><span class="s4">2.</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">0.5</span><span class="s1">)</span>
    <span class="s1">assert_raises(TypeError</span><span class="s2">, </span><span class="s1">stats.gamma.fit</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s4">2.</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">0.5</span><span class="s1">)</span>

    <span class="s3"># These should not give errors</span>
    <span class="s1">stats.gamma.pdf(x</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)  </span><span class="s3"># loc=3</span>
    <span class="s1">stats.gamma.pdf(x</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)  </span><span class="s3"># loc=3, scale=4</span>
    <span class="s1">stats.gamma.stats(</span><span class="s4">2.</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span>
    <span class="s1">stats.gamma.stats(</span><span class="s4">2.</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>
    <span class="s1">stats.gamma.stats(</span><span class="s4">2.</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s5">'mv'</span><span class="s1">)</span>
    <span class="s1">stats.gamma.rvs(</span><span class="s4">2.</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s1">)</span>
    <span class="s1">stats.gamma.fit(stats.gamma.rvs(</span><span class="s4">2.</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">7</span><span class="s1">)</span><span class="s2">, </span><span class="s4">2.</span><span class="s1">)</span>

    <span class="s3"># Also for a discrete distribution</span>
    <span class="s1">stats.geom.pmf(x</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">3</span><span class="s1">)  </span><span class="s3"># no error, loc=3</span>
    <span class="s1">assert_raises(TypeError</span><span class="s2">, </span><span class="s1">stats.geom.pmf</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>
    <span class="s1">assert_raises(TypeError</span><span class="s2">, </span><span class="s1">stats.geom.pmf</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">4</span><span class="s1">)</span>

    <span class="s3"># And for distributions with 0, 2 and 3 args respectively</span>
    <span class="s1">assert_raises(TypeError</span><span class="s2">, </span><span class="s1">stats.expon.pdf</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">1.0</span><span class="s1">)</span>
    <span class="s1">assert_raises(TypeError</span><span class="s2">, </span><span class="s1">stats.exponweib.pdf</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">1.0</span><span class="s1">)</span>
    <span class="s1">assert_raises(TypeError</span><span class="s2">, </span><span class="s1">stats.exponweib.pdf</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.1</span><span class="s1">)</span>
    <span class="s1">assert_raises(TypeError</span><span class="s2">, </span><span class="s1">stats.ncf.pdf</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">1.0</span><span class="s1">)</span>
    <span class="s1">assert_raises(TypeError</span><span class="s2">, </span><span class="s1">stats.ncf.pdf</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">0.5</span><span class="s1">)</span>
    <span class="s1">stats.ncf.pdf(x</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">)  </span><span class="s3"># 3 args, plus loc/scale</span>


<span class="s2">def </span><span class="s1">test_ncx2_tails_ticket_955():</span>
    <span class="s3"># Trac #955 -- check that the cdf computed by special functions</span>
    <span class="s3"># matches the integrated pdf</span>
    <span class="s1">a = stats.ncx2.cdf(np.arange(</span><span class="s4">20</span><span class="s2">, </span><span class="s4">25</span><span class="s2">, </span><span class="s4">0.2</span><span class="s1">)</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1.07458615e+02</span><span class="s1">)</span>
    <span class="s1">b = stats.ncx2._cdfvec(np.arange(</span><span class="s4">20</span><span class="s2">, </span><span class="s4">25</span><span class="s2">, </span><span class="s4">0.2</span><span class="s1">)</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">1.07458615e+02</span><span class="s1">)</span>
    <span class="s1">assert_allclose(a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-3</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">0</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_ncx2_tails_pdf():</span>
    <span class="s3"># ncx2.pdf does not return nans in extreme tails(example from gh-1577)</span>
    <span class="s3"># NB: this is to check that nan_to_num is not needed in ncx2.pdf</span>
    <span class="s2">with </span><span class="s1">warnings.catch_warnings():</span>
        <span class="s1">warnings.simplefilter(</span><span class="s5">'error'</span><span class="s2">, </span><span class="s1">RuntimeWarning)</span>
        <span class="s1">assert_equal(stats.ncx2.pdf(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">np.arange(</span><span class="s4">340</span><span class="s2">, </span><span class="s4">350</span><span class="s1">)</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">logval = stats.ncx2.logpdf(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">np.arange(</span><span class="s4">340</span><span class="s2">, </span><span class="s4">350</span><span class="s1">)</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>

    <span class="s1">assert_(np.isneginf(logval).all())</span>

    <span class="s3"># Verify logpdf has extended precision when pdf underflows to 0</span>
    <span class="s2">with </span><span class="s1">warnings.catch_warnings():</span>
        <span class="s1">warnings.simplefilter(</span><span class="s5">'error'</span><span class="s2">, </span><span class="s1">RuntimeWarning)</span>
        <span class="s1">assert_equal(stats.ncx2.pdf(</span><span class="s4">10000</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">12</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(stats.ncx2.logpdf(</span><span class="s4">10000</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">12</span><span class="s1">)</span><span class="s2">, </span><span class="s1">-</span><span class="s4">4662.444377524883</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s5">'method, expected'</span><span class="s2">, </span><span class="s1">[</span>
    <span class="s1">(</span><span class="s5">'cdf'</span><span class="s2">, </span><span class="s1">np.array([</span><span class="s4">2.497951336e-09</span><span class="s2">, </span><span class="s4">3.437288941e-10</span><span class="s1">]))</span><span class="s2">,</span>
    <span class="s1">(</span><span class="s5">'pdf'</span><span class="s2">, </span><span class="s1">np.array([</span><span class="s4">1.238579980e-07</span><span class="s2">, </span><span class="s4">1.710041145e-08</span><span class="s1">]))</span><span class="s2">,</span>
    <span class="s1">(</span><span class="s5">'logpdf'</span><span class="s2">, </span><span class="s1">np.array([-</span><span class="s4">15.90413011</span><span class="s2">, </span><span class="s1">-</span><span class="s4">17.88416331</span><span class="s1">]))</span><span class="s2">,</span>
    <span class="s1">(</span><span class="s5">'ppf'</span><span class="s2">, </span><span class="s1">np.array([</span><span class="s4">4.865182052</span><span class="s2">, </span><span class="s4">7.017182271</span><span class="s1">]))</span>
<span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_ncx2_zero_nc(method</span><span class="s2">, </span><span class="s1">expected):</span>
    <span class="s3"># gh-5441</span>
    <span class="s3"># ncx2 with nc=0 is identical to chi2</span>
    <span class="s3"># Comparison to R (v3.5.1)</span>
    <span class="s3"># &gt; options(digits=10)</span>
    <span class="s3"># &gt; pchisq(0.1, df=10, ncp=c(0,4))</span>
    <span class="s3"># &gt; dchisq(0.1, df=10, ncp=c(0,4))</span>
    <span class="s3"># &gt; dchisq(0.1, df=10, ncp=c(0,4), log=TRUE)</span>
    <span class="s3"># &gt; qchisq(0.1, df=10, ncp=c(0,4))</span>

    <span class="s1">result = getattr(stats.ncx2</span><span class="s2">, </span><span class="s1">method)(</span><span class="s4">0.1</span><span class="s2">, </span><span class="s1">nc=[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">df=</span><span class="s4">10</span><span class="s1">)</span>
    <span class="s1">assert_allclose(result</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-15</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_ncx2_zero_nc_rvs():</span>
    <span class="s3"># gh-5441</span>
    <span class="s3"># ncx2 with nc=0 is identical to chi2</span>
    <span class="s1">result = stats.ncx2.rvs(df=</span><span class="s4">10</span><span class="s2">, </span><span class="s1">nc=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">expected = stats.chi2.rvs(df=</span><span class="s4">10</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">assert_allclose(result</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-15</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_ncx2_gh12731():</span>
    <span class="s3"># test that gh-12731 is resolved; previously these were all 0.5</span>
    <span class="s1">nc = </span><span class="s4">10</span><span class="s1">**np.arange(</span><span class="s4">5</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span>
    <span class="s1">assert_equal(stats.ncx2.cdf(</span><span class="s4">1e4</span><span class="s2">, </span><span class="s1">df=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">nc=nc)</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_ncx2_gh8665():</span>
    <span class="s3"># test that gh-8665 is resolved; previously this tended to nonzero value</span>
    <span class="s1">x = np.array([</span><span class="s4">4.99515382e+00</span><span class="s2">, </span><span class="s4">1.07617327e+01</span><span class="s2">, </span><span class="s4">2.31854502e+01</span><span class="s2">,</span>
                  <span class="s4">4.99515382e+01</span><span class="s2">, </span><span class="s4">1.07617327e+02</span><span class="s2">, </span><span class="s4">2.31854502e+02</span><span class="s2">,</span>
                  <span class="s4">4.99515382e+02</span><span class="s2">, </span><span class="s4">1.07617327e+03</span><span class="s2">, </span><span class="s4">2.31854502e+03</span><span class="s2">,</span>
                  <span class="s4">4.99515382e+03</span><span class="s2">, </span><span class="s4">1.07617327e+04</span><span class="s2">, </span><span class="s4">2.31854502e+04</span><span class="s2">,</span>
                  <span class="s4">4.99515382e+04</span><span class="s1">])</span>
    <span class="s1">nu</span><span class="s2">, </span><span class="s1">lam = </span><span class="s4">20</span><span class="s2">, </span><span class="s4">499.51538166556196</span>

    <span class="s1">sf = stats.ncx2.sf(x</span><span class="s2">, </span><span class="s1">df=nu</span><span class="s2">, </span><span class="s1">nc=lam)</span>
    <span class="s3"># computed in R. Couldn't find a survival function implementation</span>
    <span class="s3"># options(digits=16)</span>
    <span class="s3"># x &lt;- c(4.99515382e+00, 1.07617327e+01, 2.31854502e+01, 4.99515382e+01,</span>
    <span class="s3">#        1.07617327e+02, 2.31854502e+02, 4.99515382e+02, 1.07617327e+03,</span>
    <span class="s3">#        2.31854502e+03, 4.99515382e+03, 1.07617327e+04, 2.31854502e+04,</span>
    <span class="s3">#        4.99515382e+04)</span>
    <span class="s3"># nu &lt;- 20</span>
    <span class="s3"># lam &lt;- 499.51538166556196</span>
    <span class="s3"># 1 - pchisq(x, df = nu, ncp = lam)</span>
    <span class="s1">sf_expected = [</span><span class="s4">1.0000000000000000</span><span class="s2">, </span><span class="s4">1.0000000000000000</span><span class="s2">, </span><span class="s4">1.0000000000000000</span><span class="s2">,</span>
                   <span class="s4">1.0000000000000000</span><span class="s2">, </span><span class="s4">1.0000000000000000</span><span class="s2">, </span><span class="s4">0.9999999999999888</span><span class="s2">,</span>
                   <span class="s4">0.6646525582135460</span><span class="s2">, </span><span class="s4">0.0000000000000000</span><span class="s2">, </span><span class="s4">0.0000000000000000</span><span class="s2">,</span>
                   <span class="s4">0.0000000000000000</span><span class="s2">, </span><span class="s4">0.0000000000000000</span><span class="s2">, </span><span class="s4">0.0000000000000000</span><span class="s2">,</span>
                   <span class="s4">0.0000000000000000</span><span class="s1">]</span>
    <span class="s1">assert_allclose(sf</span><span class="s2">, </span><span class="s1">sf_expected</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-12</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_ncx2_gh11777():</span>
    <span class="s3"># regression test for gh-11777:</span>
    <span class="s3"># At high values of degrees of freedom df, ensure the pdf of ncx2 does</span>
    <span class="s3"># not get clipped to zero when the non-centrality parameter is</span>
    <span class="s3"># sufficiently less than df</span>
    <span class="s1">df = </span><span class="s4">6700</span>
    <span class="s1">nc = </span><span class="s4">5300</span>
    <span class="s1">x = np.linspace(stats.ncx2.ppf(</span><span class="s4">0.001</span><span class="s2">, </span><span class="s1">df</span><span class="s2">, </span><span class="s1">nc)</span><span class="s2">,</span>
                    <span class="s1">stats.ncx2.ppf(</span><span class="s4">0.999</span><span class="s2">, </span><span class="s1">df</span><span class="s2">, </span><span class="s1">nc)</span><span class="s2">, </span><span class="s1">num=</span><span class="s4">10000</span><span class="s1">)</span>
    <span class="s1">ncx2_pdf = stats.ncx2.pdf(x</span><span class="s2">, </span><span class="s1">df</span><span class="s2">, </span><span class="s1">nc)</span>
    <span class="s1">gauss_approx = stats.norm.pdf(x</span><span class="s2">, </span><span class="s1">df + nc</span><span class="s2">, </span><span class="s1">np.sqrt(</span><span class="s4">2 </span><span class="s1">* df + </span><span class="s4">4 </span><span class="s1">* nc))</span>
    <span class="s3"># use huge tolerance as we're only looking for obvious discrepancy</span>
    <span class="s1">assert_allclose(ncx2_pdf</span><span class="s2">, </span><span class="s1">gauss_approx</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-4</span><span class="s1">)</span>


<span class="s3"># Expected values for foldnorm.sf were computed with mpmath:</span>
<span class="s3">#</span>
<span class="s3">#    from mpmath import mp</span>
<span class="s3">#    mp.dps = 60</span>
<span class="s3">#    def foldcauchy_sf(x, c):</span>
<span class="s3">#        x = mp.mpf(x)</span>
<span class="s3">#        c = mp.mpf(c)</span>
<span class="s3">#        return mp.one - (mp.atan(x - c) + mp.atan(x + c))/mp.pi</span>
<span class="s3">#</span>
<span class="s3"># E.g.</span>
<span class="s3">#</span>
<span class="s3">#    &gt;&gt;&gt; float(foldcauchy_sf(2, 1))</span>
<span class="s3">#    0.35241638234956674</span>
<span class="s3">#</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s5">'x, c, expected'</span><span class="s2">,</span>
                         <span class="s1">[(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.35241638234956674</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">0.5779791303773694</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">(</span><span class="s4">1e13</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">6.366197723675813e-14</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">(</span><span class="s4">2e16</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">3.183098861837907e-17</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">(</span><span class="s4">1e13</span><span class="s2">, </span><span class="s4">2e11</span><span class="s2">, </span><span class="s4">6.368745221764519e-14</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">(</span><span class="s4">0.125</span><span class="s2">, </span><span class="s4">200</span><span class="s2">, </span><span class="s4">0.999998010612169</span><span class="s1">)])</span>
<span class="s2">def </span><span class="s1">test_foldcauchy_sf(x</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">expected):</span>
    <span class="s1">sf = stats.foldcauchy.sf(x</span><span class="s2">, </span><span class="s1">c)</span>
    <span class="s1">assert_allclose(sf</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s4">2e-15</span><span class="s1">)</span>


<span class="s3"># The same mpmath code shown in the comments above test_foldcauchy_sf()</span>
<span class="s3"># is used to create these expected values.</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s5">'x, expected'</span><span class="s2">,</span>
                         <span class="s1">[(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">0.2951672353008665</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">(</span><span class="s4">1e13</span><span class="s2">, </span><span class="s4">6.366197723675813e-14</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">(</span><span class="s4">2e16</span><span class="s2">, </span><span class="s4">3.183098861837907e-17</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">(</span><span class="s4">5e80</span><span class="s2">, </span><span class="s4">1.2732395447351629e-81</span><span class="s1">)])</span>
<span class="s2">def </span><span class="s1">test_halfcauchy_sf(x</span><span class="s2">, </span><span class="s1">expected):</span>
    <span class="s1">sf = stats.halfcauchy.sf(x)</span>
    <span class="s1">assert_allclose(sf</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s4">2e-15</span><span class="s1">)</span>


<span class="s3"># Expected value computed with mpmath:</span>
<span class="s3">#     expected = mp.cot(mp.pi*p/2)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s5">'p, expected'</span><span class="s2">,</span>
                         <span class="s1">[(</span><span class="s4">0.9999995</span><span class="s2">, </span><span class="s4">7.853981633329977e-07</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">(</span><span class="s4">0.975</span><span class="s2">, </span><span class="s4">0.039290107007669675</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">(</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">(</span><span class="s4">0.01</span><span class="s2">, </span><span class="s4">63.65674116287158</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">(</span><span class="s4">1e-14</span><span class="s2">, </span><span class="s4">63661977236758.13</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">(</span><span class="s4">5e-80</span><span class="s2">, </span><span class="s4">1.2732395447351627e+79</span><span class="s1">)])</span>
<span class="s2">def </span><span class="s1">test_halfcauchy_isf(p</span><span class="s2">, </span><span class="s1">expected):</span>
    <span class="s1">x = stats.halfcauchy.isf(p)</span>
    <span class="s1">assert_allclose(x</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s2">def </span><span class="s1">test_foldnorm_zero():</span>
    <span class="s3"># Parameter value c=0 was not enabled, see gh-2399.</span>
    <span class="s1">rv = stats.foldnorm(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">assert_equal(rv.cdf(</span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)  </span><span class="s3"># rv.cdf(0) previously resulted in: nan</span>


<span class="s3"># Expected values for foldnorm.sf were computed with mpmath:</span>
<span class="s3">#</span>
<span class="s3">#    from mpmath import mp</span>
<span class="s3">#    mp.dps = 60</span>
<span class="s3">#    def foldnorm_sf(x, c):</span>
<span class="s3">#        x = mp.mpf(x)</span>
<span class="s3">#        c = mp.mpf(c)</span>
<span class="s3">#        return mp.ncdf(-x+c) + mp.ncdf(-x-c)</span>
<span class="s3">#</span>
<span class="s3"># E.g.</span>
<span class="s3">#</span>
<span class="s3">#    &gt;&gt;&gt; float(foldnorm_sf(2, 1))</span>
<span class="s3">#    0.16000515196308715</span>
<span class="s3">#</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s5">'x, c, expected'</span><span class="s2">,</span>
                         <span class="s1">[(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.16000515196308715</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">(</span><span class="s4">20</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">8.527223952630977e-81</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">(</span><span class="s4">10</span><span class="s2">, </span><span class="s4">15</span><span class="s2">, </span><span class="s4">0.9999997133484281</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">(</span><span class="s4">25</span><span class="s2">, </span><span class="s4">15</span><span class="s2">, </span><span class="s4">7.619853024160525e-24</span><span class="s1">)])</span>
<span class="s2">def </span><span class="s1">test_foldnorm_sf(x</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">expected):</span>
    <span class="s1">sf = stats.foldnorm.sf(x</span><span class="s2">, </span><span class="s1">c)</span>
    <span class="s1">assert_allclose(sf</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s4">1e-14</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_stats_shapes_argcheck():</span>
    <span class="s3"># stats method was failing for vector shapes if some of the values</span>
    <span class="s3"># were outside of the allowed range, see gh-2678</span>
    <span class="s1">mv3 = stats.invgamma.stats([</span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">]</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)  </span><span class="s3"># 0 is not a legal `a`</span>
    <span class="s1">mv2 = stats.invgamma.stats([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">]</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">)</span>
    <span class="s1">mv2_augmented = tuple(np.r_[np.nan</span><span class="s2">, </span><span class="s1">_] </span><span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">mv2)</span>
    <span class="s1">assert_equal(mv2_augmented</span><span class="s2">, </span><span class="s1">mv3)</span>

    <span class="s3"># -1 is not a legal shape parameter</span>
    <span class="s1">mv3 = stats.lognorm.stats([</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2.4</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">mv2 = stats.lognorm.stats([</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2.4</span><span class="s1">])</span>
    <span class="s1">mv2_augmented = tuple(np.r_[_</span><span class="s2">, </span><span class="s1">np.nan] </span><span class="s2">for </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">mv2)</span>
    <span class="s1">assert_equal(mv2_augmented</span><span class="s2">, </span><span class="s1">mv3)</span>

    <span class="s3"># FIXME: this is only a quick-and-dirty test of a quick-and-dirty bugfix.</span>
    <span class="s3"># stats method with multiple shape parameters is not properly vectorized</span>
    <span class="s3"># anyway, so some distributions may or may not fail.</span>


<span class="s3"># Test subclassing distributions w/ explicit shapes</span>

<span class="s2">class </span><span class="s1">_distr_gen(stats.rv_continuous):</span>
    <span class="s2">def </span><span class="s1">_pdf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">a):</span>
        <span class="s2">return </span><span class="s4">42</span>


<span class="s2">class </span><span class="s1">_distr2_gen(stats.rv_continuous):</span>
    <span class="s2">def </span><span class="s1">_cdf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">a):</span>
        <span class="s2">return </span><span class="s4">42 </span><span class="s1">* a + x</span>


<span class="s2">class </span><span class="s1">_distr3_gen(stats.rv_continuous):</span>
    <span class="s2">def </span><span class="s1">_pdf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b):</span>
        <span class="s2">return </span><span class="s1">a + b</span>

    <span class="s2">def </span><span class="s1">_cdf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">a):</span>
        <span class="s3"># Different # of shape params from _pdf, to be able to check that</span>
        <span class="s3"># inspection catches the inconsistency.</span>
        <span class="s2">return </span><span class="s4">42 </span><span class="s1">* a + x</span>


<span class="s2">class </span><span class="s1">_distr6_gen(stats.rv_continuous):</span>
    <span class="s3"># Two shape parameters (both _pdf and _cdf defined, consistent shapes.)</span>
    <span class="s2">def </span><span class="s1">_pdf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b):</span>
        <span class="s2">return </span><span class="s1">a*x + b</span>

    <span class="s2">def </span><span class="s1">_cdf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">b):</span>
        <span class="s2">return </span><span class="s4">42 </span><span class="s1">* a + x</span>


<span class="s2">class </span><span class="s1">TestSubclassingExplicitShapes:</span>
    <span class="s3"># Construct a distribution w/ explicit shapes parameter and test it.</span>

    <span class="s2">def </span><span class="s1">test_correct_shapes(self):</span>
        <span class="s1">dummy_distr = _distr_gen(name=</span><span class="s5">'dummy'</span><span class="s2">, </span><span class="s1">shapes=</span><span class="s5">'a'</span><span class="s1">)</span>
        <span class="s1">assert_equal(dummy_distr.pdf(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">a=</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s4">42</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_wrong_shapes_1(self):</span>
        <span class="s1">dummy_distr = _distr_gen(name=</span><span class="s5">'dummy'</span><span class="s2">, </span><span class="s1">shapes=</span><span class="s5">'A'</span><span class="s1">)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s2">, </span><span class="s1">dummy_distr.pdf</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">**dict(a=</span><span class="s4">1</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_wrong_shapes_2(self):</span>
        <span class="s1">dummy_distr = _distr_gen(name=</span><span class="s5">'dummy'</span><span class="s2">, </span><span class="s1">shapes=</span><span class="s5">'a, b, c'</span><span class="s1">)</span>
        <span class="s1">dct = dict(a=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">b=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">c=</span><span class="s4">3</span><span class="s1">)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s2">, </span><span class="s1">dummy_distr.pdf</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">**dct)</span>

    <span class="s2">def </span><span class="s1">test_shapes_string(self):</span>
        <span class="s3"># shapes must be a string</span>
        <span class="s1">dct = dict(name=</span><span class="s5">'dummy'</span><span class="s2">, </span><span class="s1">shapes=</span><span class="s4">42</span><span class="s1">)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s2">, </span><span class="s1">_distr_gen</span><span class="s2">, </span><span class="s1">**dct)</span>

    <span class="s2">def </span><span class="s1">test_shapes_identifiers_1(self):</span>
        <span class="s3"># shapes must be a comma-separated list of valid python identifiers</span>
        <span class="s1">dct = dict(name=</span><span class="s5">'dummy'</span><span class="s2">, </span><span class="s1">shapes=</span><span class="s5">'(!)'</span><span class="s1">)</span>
        <span class="s1">assert_raises(SyntaxError</span><span class="s2">, </span><span class="s1">_distr_gen</span><span class="s2">, </span><span class="s1">**dct)</span>

    <span class="s2">def </span><span class="s1">test_shapes_identifiers_2(self):</span>
        <span class="s1">dct = dict(name=</span><span class="s5">'dummy'</span><span class="s2">, </span><span class="s1">shapes=</span><span class="s5">'4chan'</span><span class="s1">)</span>
        <span class="s1">assert_raises(SyntaxError</span><span class="s2">, </span><span class="s1">_distr_gen</span><span class="s2">, </span><span class="s1">**dct)</span>

    <span class="s2">def </span><span class="s1">test_shapes_identifiers_3(self):</span>
        <span class="s1">dct = dict(name=</span><span class="s5">'dummy'</span><span class="s2">, </span><span class="s1">shapes=</span><span class="s5">'m(fti)'</span><span class="s1">)</span>
        <span class="s1">assert_raises(SyntaxError</span><span class="s2">, </span><span class="s1">_distr_gen</span><span class="s2">, </span><span class="s1">**dct)</span>

    <span class="s2">def </span><span class="s1">test_shapes_identifiers_nodefaults(self):</span>
        <span class="s1">dct = dict(name=</span><span class="s5">'dummy'</span><span class="s2">, </span><span class="s1">shapes=</span><span class="s5">'a=2'</span><span class="s1">)</span>
        <span class="s1">assert_raises(SyntaxError</span><span class="s2">, </span><span class="s1">_distr_gen</span><span class="s2">, </span><span class="s1">**dct)</span>

    <span class="s2">def </span><span class="s1">test_shapes_args(self):</span>
        <span class="s1">dct = dict(name=</span><span class="s5">'dummy'</span><span class="s2">, </span><span class="s1">shapes=</span><span class="s5">'*args'</span><span class="s1">)</span>
        <span class="s1">assert_raises(SyntaxError</span><span class="s2">, </span><span class="s1">_distr_gen</span><span class="s2">, </span><span class="s1">**dct)</span>

    <span class="s2">def </span><span class="s1">test_shapes_kwargs(self):</span>
        <span class="s1">dct = dict(name=</span><span class="s5">'dummy'</span><span class="s2">, </span><span class="s1">shapes=</span><span class="s5">'**kwargs'</span><span class="s1">)</span>
        <span class="s1">assert_raises(SyntaxError</span><span class="s2">, </span><span class="s1">_distr_gen</span><span class="s2">, </span><span class="s1">**dct)</span>

    <span class="s2">def </span><span class="s1">test_shapes_keywords(self):</span>
        <span class="s3"># python keywords cannot be used for shape parameters</span>
        <span class="s1">dct = dict(name=</span><span class="s5">'dummy'</span><span class="s2">, </span><span class="s1">shapes=</span><span class="s5">'a, b, c, lambda'</span><span class="s1">)</span>
        <span class="s1">assert_raises(SyntaxError</span><span class="s2">, </span><span class="s1">_distr_gen</span><span class="s2">, </span><span class="s1">**dct)</span>

    <span class="s2">def </span><span class="s1">test_shapes_signature(self):</span>
        <span class="s3"># test explicit shapes which agree w/ the signature of _pdf</span>
        <span class="s2">class </span><span class="s1">_dist_gen(stats.rv_continuous):</span>
            <span class="s2">def </span><span class="s1">_pdf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">a):</span>
                <span class="s2">return </span><span class="s1">stats.norm._pdf(x) * a</span>

        <span class="s1">dist = _dist_gen(shapes=</span><span class="s5">'a'</span><span class="s1">)</span>
        <span class="s1">assert_equal(dist.pdf(</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">a=</span><span class="s4">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">stats.norm.pdf(</span><span class="s4">0.5</span><span class="s1">)*</span><span class="s4">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_shapes_signature_inconsistent(self):</span>
        <span class="s3"># test explicit shapes which do not agree w/ the signature of _pdf</span>
        <span class="s2">class </span><span class="s1">_dist_gen(stats.rv_continuous):</span>
            <span class="s2">def </span><span class="s1">_pdf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">a):</span>
                <span class="s2">return </span><span class="s1">stats.norm._pdf(x) * a</span>

        <span class="s1">dist = _dist_gen(shapes=</span><span class="s5">'a, b'</span><span class="s1">)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s2">, </span><span class="s1">dist.pdf</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">**dict(a=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">b=</span><span class="s4">2</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_star_args(self):</span>
        <span class="s3"># test _pdf with only starargs</span>
        <span class="s3"># NB: **kwargs of pdf will never reach _pdf</span>
        <span class="s2">class </span><span class="s1">_dist_gen(stats.rv_continuous):</span>
            <span class="s2">def </span><span class="s1">_pdf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">*args):</span>
                <span class="s1">extra_kwarg = args[</span><span class="s4">0</span><span class="s1">]</span>
                <span class="s2">return </span><span class="s1">stats.norm._pdf(x) * extra_kwarg</span>

        <span class="s1">dist = _dist_gen(shapes=</span><span class="s5">'extra_kwarg'</span><span class="s1">)</span>
        <span class="s1">assert_equal(dist.pdf(</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">extra_kwarg=</span><span class="s4">33</span><span class="s1">)</span><span class="s2">, </span><span class="s1">stats.norm.pdf(</span><span class="s4">0.5</span><span class="s1">)*</span><span class="s4">33</span><span class="s1">)</span>
        <span class="s1">assert_equal(dist.pdf(</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">33</span><span class="s1">)</span><span class="s2">, </span><span class="s1">stats.norm.pdf(</span><span class="s4">0.5</span><span class="s1">)*</span><span class="s4">33</span><span class="s1">)</span>
        <span class="s1">assert_raises(TypeError</span><span class="s2">, </span><span class="s1">dist.pdf</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">**dict(xxx=</span><span class="s4">33</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_star_args_2(self):</span>
        <span class="s3"># test _pdf with named &amp; starargs</span>
        <span class="s3"># NB: **kwargs of pdf will never reach _pdf</span>
        <span class="s2">class </span><span class="s1">_dist_gen(stats.rv_continuous):</span>
            <span class="s2">def </span><span class="s1">_pdf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">offset</span><span class="s2">, </span><span class="s1">*args):</span>
                <span class="s1">extra_kwarg = args[</span><span class="s4">0</span><span class="s1">]</span>
                <span class="s2">return </span><span class="s1">stats.norm._pdf(x) * extra_kwarg + offset</span>

        <span class="s1">dist = _dist_gen(shapes=</span><span class="s5">'offset, extra_kwarg'</span><span class="s1">)</span>
        <span class="s1">assert_equal(dist.pdf(</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">offset=</span><span class="s4">111</span><span class="s2">, </span><span class="s1">extra_kwarg=</span><span class="s4">33</span><span class="s1">)</span><span class="s2">,</span>
                     <span class="s1">stats.norm.pdf(</span><span class="s4">0.5</span><span class="s1">)*</span><span class="s4">33 </span><span class="s1">+ </span><span class="s4">111</span><span class="s1">)</span>
        <span class="s1">assert_equal(dist.pdf(</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">111</span><span class="s2">, </span><span class="s4">33</span><span class="s1">)</span><span class="s2">,</span>
                     <span class="s1">stats.norm.pdf(</span><span class="s4">0.5</span><span class="s1">)*</span><span class="s4">33 </span><span class="s1">+ </span><span class="s4">111</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_extra_kwarg(self):</span>
        <span class="s3"># **kwargs to _pdf are ignored.</span>
        <span class="s3"># this is a limitation of the framework (_pdf(x, *goodargs))</span>
        <span class="s2">class </span><span class="s1">_distr_gen(stats.rv_continuous):</span>
            <span class="s2">def </span><span class="s1">_pdf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
                <span class="s3"># _pdf should handle *args, **kwargs itself.  Here &quot;handling&quot;</span>
                <span class="s3"># is ignoring *args and looking for ``extra_kwarg`` and using</span>
                <span class="s3"># that.</span>
                <span class="s1">extra_kwarg = kwargs.pop(</span><span class="s5">'extra_kwarg'</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
                <span class="s2">return </span><span class="s1">stats.norm._pdf(x) * extra_kwarg</span>

        <span class="s1">dist = _distr_gen(shapes=</span><span class="s5">'extra_kwarg'</span><span class="s1">)</span>
        <span class="s1">assert_equal(dist.pdf(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">extra_kwarg=</span><span class="s4">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">stats.norm.pdf(</span><span class="s4">1</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_shapes_empty_string(self):</span>
        <span class="s3"># shapes='' is equivalent to shapes=None</span>
        <span class="s2">class </span><span class="s1">_dist_gen(stats.rv_continuous):</span>
            <span class="s2">def </span><span class="s1">_pdf(self</span><span class="s2">, </span><span class="s1">x):</span>
                <span class="s2">return </span><span class="s1">stats.norm.pdf(x)</span>

        <span class="s1">dist = _dist_gen(shapes=</span><span class="s5">''</span><span class="s1">)</span>
        <span class="s1">assert_equal(dist.pdf(</span><span class="s4">0.5</span><span class="s1">)</span><span class="s2">, </span><span class="s1">stats.norm.pdf(</span><span class="s4">0.5</span><span class="s1">))</span>


<span class="s2">class </span><span class="s1">TestSubclassingNoShapes:</span>
    <span class="s3"># Construct a distribution w/o explicit shapes parameter and test it.</span>

    <span class="s2">def </span><span class="s1">test_only__pdf(self):</span>
        <span class="s1">dummy_distr = _distr_gen(name=</span><span class="s5">'dummy'</span><span class="s1">)</span>
        <span class="s1">assert_equal(dummy_distr.pdf(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">a=</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s4">42</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_only__cdf(self):</span>
        <span class="s3"># _pdf is determined from _cdf by taking numerical derivative</span>
        <span class="s1">dummy_distr = _distr2_gen(name=</span><span class="s5">'dummy'</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(dummy_distr.pdf(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">a=</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.skipif(DOCSTRINGS_STRIPPED</span><span class="s2">, </span><span class="s1">reason=</span><span class="s5">&quot;docstring stripped&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_signature_inspection(self):</span>
        <span class="s3"># check that _pdf signature inspection works correctly, and is used in</span>
        <span class="s3"># the class docstring</span>
        <span class="s1">dummy_distr = _distr_gen(name=</span><span class="s5">'dummy'</span><span class="s1">)</span>
        <span class="s1">assert_equal(dummy_distr.numargs</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_equal(dummy_distr.shapes</span><span class="s2">, </span><span class="s5">'a'</span><span class="s1">)</span>
        <span class="s1">res = re.findall(</span><span class="s5">r'logpdf\(x, a, loc=0, scale=1\)'</span><span class="s2">,</span>
                         <span class="s1">dummy_distr.__doc__)</span>
        <span class="s1">assert_(len(res) == </span><span class="s4">1</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.skipif(DOCSTRINGS_STRIPPED</span><span class="s2">, </span><span class="s1">reason=</span><span class="s5">&quot;docstring stripped&quot;</span><span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_signature_inspection_2args(self):</span>
        <span class="s3"># same for 2 shape params and both _pdf and _cdf defined</span>
        <span class="s1">dummy_distr = _distr6_gen(name=</span><span class="s5">'dummy'</span><span class="s1">)</span>
        <span class="s1">assert_equal(dummy_distr.numargs</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">assert_equal(dummy_distr.shapes</span><span class="s2">, </span><span class="s5">'a, b'</span><span class="s1">)</span>
        <span class="s1">res = re.findall(</span><span class="s5">r'logpdf\(x, a, b, loc=0, scale=1\)'</span><span class="s2">,</span>
                         <span class="s1">dummy_distr.__doc__)</span>
        <span class="s1">assert_(len(res) == </span><span class="s4">1</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_signature_inspection_2args_incorrect_shapes(self):</span>
        <span class="s3"># both _pdf and _cdf defined, but shapes are inconsistent: raises</span>
        <span class="s1">assert_raises(TypeError</span><span class="s2">, </span><span class="s1">_distr3_gen</span><span class="s2">, </span><span class="s1">name=</span><span class="s5">'dummy'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_defaults_raise(self):</span>
        <span class="s3"># default arguments should raise</span>
        <span class="s2">class </span><span class="s1">_dist_gen(stats.rv_continuous):</span>
            <span class="s2">def </span><span class="s1">_pdf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">a=</span><span class="s4">42</span><span class="s1">):</span>
                <span class="s2">return </span><span class="s4">42</span>
        <span class="s1">assert_raises(TypeError</span><span class="s2">, </span><span class="s1">_dist_gen</span><span class="s2">, </span><span class="s1">**dict(name=</span><span class="s5">'dummy'</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_starargs_raise(self):</span>
        <span class="s3"># without explicit shapes, *args are not allowed</span>
        <span class="s2">class </span><span class="s1">_dist_gen(stats.rv_continuous):</span>
            <span class="s2">def </span><span class="s1">_pdf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">*args):</span>
                <span class="s2">return </span><span class="s4">42</span>
        <span class="s1">assert_raises(TypeError</span><span class="s2">, </span><span class="s1">_dist_gen</span><span class="s2">, </span><span class="s1">**dict(name=</span><span class="s5">'dummy'</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_kwargs_raise(self):</span>
        <span class="s3"># without explicit shapes, **kwargs are not allowed</span>
        <span class="s2">class </span><span class="s1">_dist_gen(stats.rv_continuous):</span>
            <span class="s2">def </span><span class="s1">_pdf(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">a</span><span class="s2">, </span><span class="s1">**kwargs):</span>
                <span class="s2">return </span><span class="s4">42</span>
        <span class="s1">assert_raises(TypeError</span><span class="s2">, </span><span class="s1">_dist_gen</span><span class="s2">, </span><span class="s1">**dict(name=</span><span class="s5">'dummy'</span><span class="s1">))</span>


<span class="s1">@pytest.mark.skipif(DOCSTRINGS_STRIPPED</span><span class="s2">, </span><span class="s1">reason=</span><span class="s5">&quot;docstring stripped&quot;</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_docstrings():</span>
    <span class="s1">badones = [</span><span class="s5">r',\s*,'</span><span class="s2">, </span><span class="s5">r'\(\s*,'</span><span class="s2">, </span><span class="s5">r'^\s*:'</span><span class="s1">]</span>
    <span class="s2">for </span><span class="s1">distname </span><span class="s2">in </span><span class="s1">stats.__all__:</span>
        <span class="s1">dist = getattr(stats</span><span class="s2">, </span><span class="s1">distname)</span>
        <span class="s2">if </span><span class="s1">isinstance(dist</span><span class="s2">, </span><span class="s1">(stats.rv_discrete</span><span class="s2">, </span><span class="s1">stats.rv_continuous)):</span>
            <span class="s2">for </span><span class="s1">regex </span><span class="s2">in </span><span class="s1">badones:</span>
                <span class="s1">assert_(re.search(regex</span><span class="s2">, </span><span class="s1">dist.__doc__) </span><span class="s2">is None</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_infinite_input():</span>
    <span class="s1">assert_almost_equal(stats.skellam.sf(np.inf</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">11</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">assert_almost_equal(stats.ncx2._cdf(np.inf</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">0.1</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_lomax_accuracy():</span>
    <span class="s3"># regression test for gh-4033</span>
    <span class="s1">p = stats.lomax.ppf(stats.lomax.cdf(</span><span class="s4">1e-100</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">assert_allclose(p</span><span class="s2">, </span><span class="s4">1e-100</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_truncexpon_accuracy():</span>
    <span class="s3"># regression test for gh-4035</span>
    <span class="s1">p = stats.truncexpon.ppf(stats.truncexpon.cdf(</span><span class="s4">1e-100</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">assert_allclose(p</span><span class="s2">, </span><span class="s4">1e-100</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_rayleigh_accuracy():</span>
    <span class="s3"># regression test for gh-4034</span>
    <span class="s1">p = stats.rayleigh.isf(stats.rayleigh.sf(</span><span class="s4">9</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">assert_almost_equal(p</span><span class="s2">, </span><span class="s4">9.0</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">15</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_genextreme_give_no_warnings():</span>
    <span class="s0">&quot;&quot;&quot;regression test for gh-6219&quot;&quot;&quot;</span>

    <span class="s2">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s2">True</span><span class="s1">) </span><span class="s2">as </span><span class="s1">w:</span>
        <span class="s1">warnings.simplefilter(</span><span class="s5">&quot;always&quot;</span><span class="s1">)</span>

        <span class="s1">stats.genextreme.cdf(</span><span class="s4">.5</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">stats.genextreme.pdf(</span><span class="s4">.5</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">stats.genextreme.ppf(</span><span class="s4">.5</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">stats.genextreme.logpdf(-np.inf</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">)</span>
        <span class="s1">number_of_warnings_thrown = len(w)</span>
        <span class="s1">assert_equal(number_of_warnings_thrown</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_genextreme_entropy():</span>
    <span class="s3"># regression test for gh-5181</span>
    <span class="s1">euler_gamma = </span><span class="s4">0.5772156649015329</span>

    <span class="s1">h = stats.genextreme.entropy(-</span><span class="s4">1.0</span><span class="s1">)</span>
    <span class="s1">assert_allclose(h</span><span class="s2">, </span><span class="s4">2</span><span class="s1">*euler_gamma + </span><span class="s4">1</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-14</span><span class="s1">)</span>

    <span class="s1">h = stats.genextreme.entropy(</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">assert_allclose(h</span><span class="s2">, </span><span class="s1">euler_gamma + </span><span class="s4">1</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-14</span><span class="s1">)</span>

    <span class="s1">h = stats.genextreme.entropy(</span><span class="s4">1.0</span><span class="s1">)</span>
    <span class="s1">assert_equal(h</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>

    <span class="s1">h = stats.genextreme.entropy(-</span><span class="s4">2.0</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">10</span><span class="s1">)</span>
    <span class="s1">assert_allclose(h</span><span class="s2">, </span><span class="s1">euler_gamma*</span><span class="s4">3 </span><span class="s1">+ np.log(</span><span class="s4">10</span><span class="s1">) + </span><span class="s4">1</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-14</span><span class="s1">)</span>

    <span class="s1">h = stats.genextreme.entropy(</span><span class="s4">10</span><span class="s1">)</span>
    <span class="s1">assert_allclose(h</span><span class="s2">, </span><span class="s1">-</span><span class="s4">9</span><span class="s1">*euler_gamma + </span><span class="s4">1</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-14</span><span class="s1">)</span>

    <span class="s1">h = stats.genextreme.entropy(-</span><span class="s4">10</span><span class="s1">)</span>
    <span class="s1">assert_allclose(h</span><span class="s2">, </span><span class="s4">11</span><span class="s1">*euler_gamma + </span><span class="s4">1</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-14</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_genextreme_sf_isf():</span>
    <span class="s3"># Expected values were computed using mpmath:</span>
    <span class="s3">#</span>
    <span class="s3">#    import mpmath</span>
    <span class="s3">#</span>
    <span class="s3">#    def mp_genextreme_sf(x, xi, mu=0, sigma=1):</span>
    <span class="s3">#        # Formula from wikipedia, which has a sign convention for xi that</span>
    <span class="s3">#        # is the opposite of scipy's shape parameter.</span>
    <span class="s3">#        if xi != 0:</span>
    <span class="s3">#            t = mpmath.power(1 + ((x - mu)/sigma)*xi, -1/xi)</span>
    <span class="s3">#        else:</span>
    <span class="s3">#            t = mpmath.exp(-(x - mu)/sigma)</span>
    <span class="s3">#        return 1 - mpmath.exp(-t)</span>
    <span class="s3">#</span>
    <span class="s3"># &gt;&gt;&gt; mpmath.mp.dps = 1000</span>
    <span class="s3"># &gt;&gt;&gt; s = mp_genextreme_sf(mpmath.mp.mpf(&quot;1e8&quot;), mpmath.mp.mpf(&quot;0.125&quot;))</span>
    <span class="s3"># &gt;&gt;&gt; float(s)</span>
    <span class="s3"># 1.6777205262585625e-57</span>
    <span class="s3"># &gt;&gt;&gt; s = mp_genextreme_sf(mpmath.mp.mpf(&quot;7.98&quot;), mpmath.mp.mpf(&quot;-0.125&quot;))</span>
    <span class="s3"># &gt;&gt;&gt; float(s)</span>
    <span class="s3"># 1.52587890625e-21</span>
    <span class="s3"># &gt;&gt;&gt; s = mp_genextreme_sf(mpmath.mp.mpf(&quot;7.98&quot;), mpmath.mp.mpf(&quot;0&quot;))</span>
    <span class="s3"># &gt;&gt;&gt; float(s)</span>
    <span class="s3"># 0.00034218086528426593</span>

    <span class="s1">x = </span><span class="s4">1e8</span>
    <span class="s1">s = stats.genextreme.sf(x</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.125</span><span class="s1">)</span>
    <span class="s1">assert_allclose(s</span><span class="s2">, </span><span class="s4">1.6777205262585625e-57</span><span class="s1">)</span>
    <span class="s1">x2 = stats.genextreme.isf(s</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.125</span><span class="s1">)</span>
    <span class="s1">assert_allclose(x2</span><span class="s2">, </span><span class="s1">x)</span>

    <span class="s1">x = </span><span class="s4">7.98</span>
    <span class="s1">s = stats.genextreme.sf(x</span><span class="s2">, </span><span class="s4">0.125</span><span class="s1">)</span>
    <span class="s1">assert_allclose(s</span><span class="s2">, </span><span class="s4">1.52587890625e-21</span><span class="s1">)</span>
    <span class="s1">x2 = stats.genextreme.isf(s</span><span class="s2">, </span><span class="s4">0.125</span><span class="s1">)</span>
    <span class="s1">assert_allclose(x2</span><span class="s2">, </span><span class="s1">x)</span>

    <span class="s1">x = </span><span class="s4">7.98</span>
    <span class="s1">s = stats.genextreme.sf(x</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">assert_allclose(s</span><span class="s2">, </span><span class="s4">0.00034218086528426593</span><span class="s1">)</span>
    <span class="s1">x2 = stats.genextreme.isf(s</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">assert_allclose(x2</span><span class="s2">, </span><span class="s1">x)</span>


<span class="s2">def </span><span class="s1">test_burr12_ppf_small_arg():</span>
    <span class="s1">prob = </span><span class="s4">1e-16</span>
    <span class="s1">quantile = stats.burr12.ppf(prob</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span>
    <span class="s3"># The expected quantile was computed using mpmath:</span>
    <span class="s3">#   &gt;&gt;&gt; import mpmath</span>
    <span class="s3">#   &gt;&gt;&gt; mpmath.mp.dps = 100</span>
    <span class="s3">#   &gt;&gt;&gt; prob = mpmath.mpf('1e-16')</span>
    <span class="s3">#   &gt;&gt;&gt; c = mpmath.mpf(2)</span>
    <span class="s3">#   &gt;&gt;&gt; d = mpmath.mpf(3)</span>
    <span class="s3">#   &gt;&gt;&gt; float(((1-prob)**(-1/d) - 1)**(1/c))</span>
    <span class="s3">#   5.7735026918962575e-09</span>
    <span class="s1">assert_allclose(quantile</span><span class="s2">, </span><span class="s4">5.7735026918962575e-09</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_crystalball_function():</span>
    <span class="s0">&quot;&quot;&quot; 
    All values are calculated using the independent implementation of the 
    ROOT framework (see https://root.cern.ch/). 
    Corresponding ROOT code is given in the comments. 
    &quot;&quot;&quot;</span>
    <span class="s1">X = np.linspace(-</span><span class="s4">5.0</span><span class="s2">, </span><span class="s4">5.0</span><span class="s2">, </span><span class="s4">21</span><span class="s1">)[:-</span><span class="s4">1</span><span class="s1">]</span>

    <span class="s3"># for(float x = -5.0; x &lt; 5.0; x+=0.5)</span>
    <span class="s3">#   std::cout &lt;&lt; ROOT::Math::crystalball_pdf(x, 1.0, 2.0, 1.0) &lt;&lt; &quot;, &quot;;</span>
    <span class="s1">calculated = stats.crystalball.pdf(X</span><span class="s2">, </span><span class="s1">beta=</span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">m=</span><span class="s4">2.0</span><span class="s1">)</span>
    <span class="s1">expected = np.array([</span><span class="s4">0.0202867</span><span class="s2">, </span><span class="s4">0.0241428</span><span class="s2">, </span><span class="s4">0.0292128</span><span class="s2">, </span><span class="s4">0.0360652</span><span class="s2">, </span><span class="s4">0.045645</span><span class="s2">,</span>
                         <span class="s4">0.059618</span><span class="s2">, </span><span class="s4">0.0811467</span><span class="s2">, </span><span class="s4">0.116851</span><span class="s2">, </span><span class="s4">0.18258</span><span class="s2">, </span><span class="s4">0.265652</span><span class="s2">,</span>
                         <span class="s4">0.301023</span><span class="s2">, </span><span class="s4">0.265652</span><span class="s2">, </span><span class="s4">0.18258</span><span class="s2">, </span><span class="s4">0.097728</span><span class="s2">, </span><span class="s4">0.0407391</span><span class="s2">,</span>
                         <span class="s4">0.013226</span><span class="s2">, </span><span class="s4">0.00334407</span><span class="s2">, </span><span class="s4">0.000658486</span><span class="s2">, </span><span class="s4">0.000100982</span><span class="s2">,</span>
                         <span class="s4">1.20606e-05</span><span class="s1">])</span>
    <span class="s1">assert_allclose(expected</span><span class="s2">, </span><span class="s1">calculated</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.001</span><span class="s1">)</span>

    <span class="s3"># for(float x = -5.0; x &lt; 5.0; x+=0.5)</span>
    <span class="s3">#   std::cout &lt;&lt; ROOT::Math::crystalball_pdf(x, 2.0, 3.0, 1.0) &lt;&lt; &quot;, &quot;;</span>
    <span class="s1">calculated = stats.crystalball.pdf(X</span><span class="s2">, </span><span class="s1">beta=</span><span class="s4">2.0</span><span class="s2">, </span><span class="s1">m=</span><span class="s4">3.0</span><span class="s1">)</span>
    <span class="s1">expected = np.array([</span><span class="s4">0.0019648</span><span class="s2">, </span><span class="s4">0.00279754</span><span class="s2">, </span><span class="s4">0.00417592</span><span class="s2">, </span><span class="s4">0.00663121</span><span class="s2">,</span>
                         <span class="s4">0.0114587</span><span class="s2">, </span><span class="s4">0.0223803</span><span class="s2">, </span><span class="s4">0.0530497</span><span class="s2">, </span><span class="s4">0.12726</span><span class="s2">, </span><span class="s4">0.237752</span><span class="s2">,</span>
                         <span class="s4">0.345928</span><span class="s2">, </span><span class="s4">0.391987</span><span class="s2">, </span><span class="s4">0.345928</span><span class="s2">, </span><span class="s4">0.237752</span><span class="s2">, </span><span class="s4">0.12726</span><span class="s2">,</span>
                         <span class="s4">0.0530497</span><span class="s2">, </span><span class="s4">0.0172227</span><span class="s2">, </span><span class="s4">0.00435458</span><span class="s2">, </span><span class="s4">0.000857469</span><span class="s2">,</span>
                         <span class="s4">0.000131497</span><span class="s2">, </span><span class="s4">1.57051e-05</span><span class="s1">])</span>
    <span class="s1">assert_allclose(expected</span><span class="s2">, </span><span class="s1">calculated</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.001</span><span class="s1">)</span>

    <span class="s3"># for(float x = -5.0; x &lt; 5.0; x+=0.5) {</span>
    <span class="s3">#   std::cout &lt;&lt; ROOT::Math::crystalball_pdf(x, 2.0, 3.0, 2.0, 0.5);</span>
    <span class="s3">#   std::cout &lt;&lt; &quot;, &quot;;</span>
    <span class="s3"># }</span>
    <span class="s1">calculated = stats.crystalball.pdf(X</span><span class="s2">, </span><span class="s1">beta=</span><span class="s4">2.0</span><span class="s2">, </span><span class="s1">m=</span><span class="s4">3.0</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">2.0</span><span class="s1">)</span>
    <span class="s1">expected = np.array([</span><span class="s4">0.00785921</span><span class="s2">, </span><span class="s4">0.0111902</span><span class="s2">, </span><span class="s4">0.0167037</span><span class="s2">, </span><span class="s4">0.0265249</span><span class="s2">,</span>
                         <span class="s4">0.0423866</span><span class="s2">, </span><span class="s4">0.0636298</span><span class="s2">, </span><span class="s4">0.0897324</span><span class="s2">, </span><span class="s4">0.118876</span><span class="s2">, </span><span class="s4">0.147944</span><span class="s2">,</span>
                         <span class="s4">0.172964</span><span class="s2">, </span><span class="s4">0.189964</span><span class="s2">, </span><span class="s4">0.195994</span><span class="s2">, </span><span class="s4">0.189964</span><span class="s2">, </span><span class="s4">0.172964</span><span class="s2">,</span>
                         <span class="s4">0.147944</span><span class="s2">, </span><span class="s4">0.118876</span><span class="s2">, </span><span class="s4">0.0897324</span><span class="s2">, </span><span class="s4">0.0636298</span><span class="s2">, </span><span class="s4">0.0423866</span><span class="s2">,</span>
                         <span class="s4">0.0265249</span><span class="s1">])</span>
    <span class="s1">assert_allclose(expected</span><span class="s2">, </span><span class="s1">calculated</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.001</span><span class="s1">)</span>

    <span class="s3"># for(float x = -5.0; x &lt; 5.0; x+=0.5)</span>
    <span class="s3">#   std::cout &lt;&lt; ROOT::Math::crystalball_cdf(x, 1.0, 2.0, 1.0) &lt;&lt; &quot;, &quot;;</span>
    <span class="s1">calculated = stats.crystalball.cdf(X</span><span class="s2">, </span><span class="s1">beta=</span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">m=</span><span class="s4">2.0</span><span class="s1">)</span>
    <span class="s1">expected = np.array([</span><span class="s4">0.12172</span><span class="s2">, </span><span class="s4">0.132785</span><span class="s2">, </span><span class="s4">0.146064</span><span class="s2">, </span><span class="s4">0.162293</span><span class="s2">, </span><span class="s4">0.18258</span><span class="s2">,</span>
                         <span class="s4">0.208663</span><span class="s2">, </span><span class="s4">0.24344</span><span class="s2">, </span><span class="s4">0.292128</span><span class="s2">, </span><span class="s4">0.36516</span><span class="s2">, </span><span class="s4">0.478254</span><span class="s2">,</span>
                         <span class="s4">0.622723</span><span class="s2">, </span><span class="s4">0.767192</span><span class="s2">, </span><span class="s4">0.880286</span><span class="s2">, </span><span class="s4">0.94959</span><span class="s2">, </span><span class="s4">0.982834</span><span class="s2">,</span>
                         <span class="s4">0.995314</span><span class="s2">, </span><span class="s4">0.998981</span><span class="s2">, </span><span class="s4">0.999824</span><span class="s2">, </span><span class="s4">0.999976</span><span class="s2">, </span><span class="s4">0.999997</span><span class="s1">])</span>
    <span class="s1">assert_allclose(expected</span><span class="s2">, </span><span class="s1">calculated</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.001</span><span class="s1">)</span>

    <span class="s3"># for(float x = -5.0; x &lt; 5.0; x+=0.5)</span>
    <span class="s3">#   std::cout &lt;&lt; ROOT::Math::crystalball_cdf(x, 2.0, 3.0, 1.0) &lt;&lt; &quot;, &quot;;</span>
    <span class="s1">calculated = stats.crystalball.cdf(X</span><span class="s2">, </span><span class="s1">beta=</span><span class="s4">2.0</span><span class="s2">, </span><span class="s1">m=</span><span class="s4">3.0</span><span class="s1">)</span>
    <span class="s1">expected = np.array([</span><span class="s4">0.00442081</span><span class="s2">, </span><span class="s4">0.00559509</span><span class="s2">, </span><span class="s4">0.00730787</span><span class="s2">, </span><span class="s4">0.00994682</span><span class="s2">,</span>
                         <span class="s4">0.0143234</span><span class="s2">, </span><span class="s4">0.0223803</span><span class="s2">, </span><span class="s4">0.0397873</span><span class="s2">, </span><span class="s4">0.0830763</span><span class="s2">, </span><span class="s4">0.173323</span><span class="s2">,</span>
                         <span class="s4">0.320592</span><span class="s2">, </span><span class="s4">0.508717</span><span class="s2">, </span><span class="s4">0.696841</span><span class="s2">, </span><span class="s4">0.844111</span><span class="s2">, </span><span class="s4">0.934357</span><span class="s2">,</span>
                         <span class="s4">0.977646</span><span class="s2">, </span><span class="s4">0.993899</span><span class="s2">, </span><span class="s4">0.998674</span><span class="s2">, </span><span class="s4">0.999771</span><span class="s2">, </span><span class="s4">0.999969</span><span class="s2">,</span>
                         <span class="s4">0.999997</span><span class="s1">])</span>
    <span class="s1">assert_allclose(expected</span><span class="s2">, </span><span class="s1">calculated</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.001</span><span class="s1">)</span>

    <span class="s3"># for(float x = -5.0; x &lt; 5.0; x+=0.5) {</span>
    <span class="s3">#   std::cout &lt;&lt; ROOT::Math::crystalball_cdf(x, 2.0, 3.0, 2.0, 0.5);</span>
    <span class="s3">#   std::cout &lt;&lt; &quot;, &quot;;</span>
    <span class="s3"># }</span>
    <span class="s1">calculated = stats.crystalball.cdf(X</span><span class="s2">, </span><span class="s1">beta=</span><span class="s4">2.0</span><span class="s2">, </span><span class="s1">m=</span><span class="s4">3.0</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">2.0</span><span class="s1">)</span>
    <span class="s1">expected = np.array([</span><span class="s4">0.0176832</span><span class="s2">, </span><span class="s4">0.0223803</span><span class="s2">, </span><span class="s4">0.0292315</span><span class="s2">, </span><span class="s4">0.0397873</span><span class="s2">, </span><span class="s4">0.0567945</span><span class="s2">,</span>
                         <span class="s4">0.0830763</span><span class="s2">, </span><span class="s4">0.121242</span><span class="s2">, </span><span class="s4">0.173323</span><span class="s2">, </span><span class="s4">0.24011</span><span class="s2">, </span><span class="s4">0.320592</span><span class="s2">,</span>
                         <span class="s4">0.411731</span><span class="s2">, </span><span class="s4">0.508717</span><span class="s2">, </span><span class="s4">0.605702</span><span class="s2">, </span><span class="s4">0.696841</span><span class="s2">, </span><span class="s4">0.777324</span><span class="s2">,</span>
                         <span class="s4">0.844111</span><span class="s2">, </span><span class="s4">0.896192</span><span class="s2">, </span><span class="s4">0.934357</span><span class="s2">, </span><span class="s4">0.960639</span><span class="s2">, </span><span class="s4">0.977646</span><span class="s1">])</span>
    <span class="s1">assert_allclose(expected</span><span class="s2">, </span><span class="s1">calculated</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.001</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_crystalball_function_moments():</span>
    <span class="s0">&quot;&quot;&quot; 
    All values are calculated using the pdf formula and the integrate function 
    of Mathematica 
    &quot;&quot;&quot;</span>
    <span class="s3"># The Last two (alpha, n) pairs test the special case n == alpha**2</span>
    <span class="s1">beta = np.array([</span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">3.0</span><span class="s2">, </span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">3.0</span><span class="s1">])</span>
    <span class="s1">m = np.array([</span><span class="s4">3.0</span><span class="s2">, </span><span class="s4">3.0</span><span class="s2">, </span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">4.0</span><span class="s2">, </span><span class="s4">9.0</span><span class="s1">])</span>

    <span class="s3"># The distribution should be correctly normalised</span>
    <span class="s1">expected_0th_moment = np.array([</span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">])</span>
    <span class="s1">calculated_0th_moment = stats.crystalball._munp(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">beta</span><span class="s2">, </span><span class="s1">m)</span>
    <span class="s1">assert_allclose(expected_0th_moment</span><span class="s2">, </span><span class="s1">calculated_0th_moment</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.001</span><span class="s1">)</span>

    <span class="s3"># calculated using wolframalpha.com</span>
    <span class="s3"># e.g. for beta = 2 and m = 3 we calculate the norm like this:</span>
    <span class="s3">#   integrate exp(-x^2/2) from -2 to infinity +</span>
    <span class="s3">#   integrate (3/2)^3*exp(-2^2/2)*(3/2-2-x)^(-3) from -infinity to -2</span>
    <span class="s1">norm = np.array([</span><span class="s4">2.5511</span><span class="s2">, </span><span class="s4">3.01873</span><span class="s2">, </span><span class="s4">2.51065</span><span class="s2">, </span><span class="s4">2.53983</span><span class="s2">, </span><span class="s4">2.507410455</span><span class="s1">])</span>

    <span class="s1">a = np.array([-</span><span class="s4">0.21992</span><span class="s2">, </span><span class="s1">-</span><span class="s4">3.03265</span><span class="s2">, </span><span class="s1">np.inf</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.135335</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.003174</span><span class="s1">])</span>
    <span class="s1">expected_1th_moment = a / norm</span>
    <span class="s1">calculated_1th_moment = stats.crystalball._munp(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">beta</span><span class="s2">, </span><span class="s1">m)</span>
    <span class="s1">assert_allclose(expected_1th_moment</span><span class="s2">, </span><span class="s1">calculated_1th_moment</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.001</span><span class="s1">)</span>

    <span class="s1">a = np.array([np.inf</span><span class="s2">, </span><span class="s1">np.inf</span><span class="s2">, </span><span class="s1">np.inf</span><span class="s2">, </span><span class="s4">3.2616</span><span class="s2">, </span><span class="s4">2.519908</span><span class="s1">])</span>
    <span class="s1">expected_2th_moment = a / norm</span>
    <span class="s1">calculated_2th_moment = stats.crystalball._munp(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">beta</span><span class="s2">, </span><span class="s1">m)</span>
    <span class="s1">assert_allclose(expected_2th_moment</span><span class="s2">, </span><span class="s1">calculated_2th_moment</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.001</span><span class="s1">)</span>

    <span class="s1">a = np.array([np.inf</span><span class="s2">, </span><span class="s1">np.inf</span><span class="s2">, </span><span class="s1">np.inf</span><span class="s2">, </span><span class="s1">np.inf</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.0577668</span><span class="s1">])</span>
    <span class="s1">expected_3th_moment = a / norm</span>
    <span class="s1">calculated_3th_moment = stats.crystalball._munp(</span><span class="s4">3</span><span class="s2">, </span><span class="s1">beta</span><span class="s2">, </span><span class="s1">m)</span>
    <span class="s1">assert_allclose(expected_3th_moment</span><span class="s2">, </span><span class="s1">calculated_3th_moment</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.001</span><span class="s1">)</span>

    <span class="s1">a = np.array([np.inf</span><span class="s2">, </span><span class="s1">np.inf</span><span class="s2">, </span><span class="s1">np.inf</span><span class="s2">, </span><span class="s1">np.inf</span><span class="s2">, </span><span class="s4">7.78468</span><span class="s1">])</span>
    <span class="s1">expected_4th_moment = a / norm</span>
    <span class="s1">calculated_4th_moment = stats.crystalball._munp(</span><span class="s4">4</span><span class="s2">, </span><span class="s1">beta</span><span class="s2">, </span><span class="s1">m)</span>
    <span class="s1">assert_allclose(expected_4th_moment</span><span class="s2">, </span><span class="s1">calculated_4th_moment</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.001</span><span class="s1">)</span>

    <span class="s1">a = np.array([np.inf</span><span class="s2">, </span><span class="s1">np.inf</span><span class="s2">, </span><span class="s1">np.inf</span><span class="s2">, </span><span class="s1">np.inf</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.31086</span><span class="s1">])</span>
    <span class="s1">expected_5th_moment = a / norm</span>
    <span class="s1">calculated_5th_moment = stats.crystalball._munp(</span><span class="s4">5</span><span class="s2">, </span><span class="s1">beta</span><span class="s2">, </span><span class="s1">m)</span>
    <span class="s1">assert_allclose(expected_5th_moment</span><span class="s2">, </span><span class="s1">calculated_5th_moment</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.001</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_crystalball_entropy():</span>
    <span class="s3"># regression test for gh-13602</span>
    <span class="s1">cb = stats.crystalball(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s1">)</span>
    <span class="s1">res1 = cb.entropy()</span>
    <span class="s3"># -20000 and 30 are negative and positive infinity, respectively</span>
    <span class="s1">lo</span><span class="s2">, </span><span class="s1">hi</span><span class="s2">, </span><span class="s1">N = -</span><span class="s4">20000</span><span class="s2">, </span><span class="s4">30</span><span class="s2">, </span><span class="s4">200000</span>
    <span class="s1">x = np.linspace(lo</span><span class="s2">, </span><span class="s1">hi</span><span class="s2">, </span><span class="s1">N)</span>
    <span class="s1">res2 = trapezoid(entr(cb.pdf(x))</span><span class="s2">, </span><span class="s1">x)</span>
    <span class="s1">assert_allclose(res1</span><span class="s2">, </span><span class="s1">res2</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-7</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_invweibull_fit():</span>
    <span class="s0">&quot;&quot;&quot; 
    Test fitting invweibull to data. 
 
    Here is a the same calculation in R: 
 
    &gt; library(evd) 
    &gt; library(fitdistrplus) 
    &gt; x = c(1, 1.25, 2, 2.5, 2.8,  3, 3.8, 4, 5, 8, 10, 12, 64, 99) 
    &gt; result = fitdist(x, 'frechet', control=list(reltol=1e-13), 
    +                  fix.arg=list(loc=0), start=list(shape=2, scale=3)) 
    &gt; result 
    Fitting of the distribution ' frechet ' by maximum likelihood 
    Parameters: 
          estimate Std. Error 
    shape 1.048482  0.2261815 
    scale 3.099456  0.8292887 
    Fixed parameters: 
        value 
    loc     0 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">optimizer(func</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">args=()</span><span class="s2">, </span><span class="s1">disp=</span><span class="s4">0</span><span class="s1">):</span>
        <span class="s2">return </span><span class="s1">fmin(func</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">args=args</span><span class="s2">, </span><span class="s1">disp=disp</span><span class="s2">, </span><span class="s1">xtol=</span><span class="s4">1e-12</span><span class="s2">, </span><span class="s1">ftol=</span><span class="s4">1e-12</span><span class="s1">)</span>

    <span class="s1">x = np.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1.25</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2.5</span><span class="s2">, </span><span class="s4">2.8</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">3.8</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">12</span><span class="s2">, </span><span class="s4">64</span><span class="s2">, </span><span class="s4">99</span><span class="s1">])</span>
    <span class="s1">c</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = stats.invweibull.fit(x</span><span class="s2">, </span><span class="s1">floc=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">optimizer=optimizer)</span>
    <span class="s1">assert_allclose(c</span><span class="s2">, </span><span class="s4">1.048482</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">5e-6</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">loc == </span><span class="s4">0</span>
    <span class="s1">assert_allclose(scale</span><span class="s2">, </span><span class="s4">3.099456</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">5e-6</span><span class="s1">)</span>


<span class="s3"># Expected values were computed with mpmath.</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s5">'x, c, expected'</span><span class="s2">,</span>
                         <span class="s1">[(</span><span class="s4">3</span><span class="s2">, </span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">0.175064510070713299327</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">(</span><span class="s4">2000</span><span class="s2">, </span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">1.11802773877318715787e-5</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">(</span><span class="s4">2000</span><span class="s2">, </span><span class="s4">9.25</span><span class="s2">, </span><span class="s4">2.92060308832269637092e-31</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">(</span><span class="s4">1e15</span><span class="s2">, </span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">3.16227766016837933199884e-23</span><span class="s1">)])</span>
<span class="s2">def </span><span class="s1">test_invweibull_sf(x</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">expected):</span>
    <span class="s1">computed = stats.invweibull.sf(x</span><span class="s2">, </span><span class="s1">c)</span>
    <span class="s1">assert_allclose(computed</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-15</span><span class="s1">)</span>


<span class="s3"># Expected values were computed with mpmath.</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s5">'p, c, expected'</span><span class="s2">,</span>
                         <span class="s1">[(</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">2.5</span><span class="s2">, </span><span class="s4">1.15789669836468183976</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">(</span><span class="s4">3e-18</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">3195.77171838060906447</span><span class="s1">)])</span>
<span class="s2">def </span><span class="s1">test_invweibull_isf(p</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">expected):</span>
    <span class="s1">computed = stats.invweibull.isf(p</span><span class="s2">, </span><span class="s1">c)</span>
    <span class="s1">assert_allclose(computed</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-15</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s5">'df1,df2,x'</span><span class="s2">,</span>
    <span class="s1">[(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s1">[-</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">2.3</span><span class="s1">])</span><span class="s2">,</span>
     <span class="s1">(</span><span class="s4">4</span><span class="s2">, </span><span class="s4">11</span><span class="s2">, </span><span class="s1">[-</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">2.3</span><span class="s1">])</span><span class="s2">,</span>
     <span class="s1">(</span><span class="s4">7</span><span class="s2">, </span><span class="s4">17</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s1">])]</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_ncf_edge_case(df1</span><span class="s2">, </span><span class="s1">df2</span><span class="s2">, </span><span class="s1">x):</span>
    <span class="s3"># Test for edge case described in gh-11660.</span>
    <span class="s3"># Non-central Fisher distribution when nc = 0</span>
    <span class="s3"># should be the same as Fisher distribution.</span>
    <span class="s1">nc = </span><span class="s4">0</span>
    <span class="s1">expected_cdf = stats.f.cdf(x</span><span class="s2">, </span><span class="s1">df1</span><span class="s2">, </span><span class="s1">df2)</span>
    <span class="s1">calculated_cdf = stats.ncf.cdf(x</span><span class="s2">, </span><span class="s1">df1</span><span class="s2">, </span><span class="s1">df2</span><span class="s2">, </span><span class="s1">nc)</span>
    <span class="s1">assert_allclose(expected_cdf</span><span class="s2">, </span><span class="s1">calculated_cdf</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-14</span><span class="s1">)</span>

    <span class="s3"># when ncf_gen._skip_pdf will be used instead of generic pdf,</span>
    <span class="s3"># this additional test will be useful.</span>
    <span class="s1">expected_pdf = stats.f.pdf(x</span><span class="s2">, </span><span class="s1">df1</span><span class="s2">, </span><span class="s1">df2)</span>
    <span class="s1">calculated_pdf = stats.ncf.pdf(x</span><span class="s2">, </span><span class="s1">df1</span><span class="s2">, </span><span class="s1">df2</span><span class="s2">, </span><span class="s1">nc)</span>
    <span class="s1">assert_allclose(expected_pdf</span><span class="s2">, </span><span class="s1">calculated_pdf</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-6</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_ncf_variance():</span>
    <span class="s3"># Regression test for gh-10658 (incorrect variance formula for ncf).</span>
    <span class="s3"># The correct value of ncf.var(2, 6, 4), 42.75, can be verified with, for</span>
    <span class="s3"># example, Wolfram Alpha with the expression</span>
    <span class="s3">#     Variance[NoncentralFRatioDistribution[2, 6, 4]]</span>
    <span class="s3"># or with the implementation of the noncentral F distribution in the C++</span>
    <span class="s3"># library Boost.</span>
    <span class="s1">v = stats.ncf.var(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>
    <span class="s1">assert_allclose(v</span><span class="s2">, </span><span class="s4">42.75</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-14</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_ncf_cdf_spotcheck():</span>
    <span class="s3"># Regression test for gh-15582 testing against values from R/MATLAB</span>
    <span class="s3"># Generate check_val from R or MATLAB as follows:</span>
    <span class="s3">#          R: pf(20, df1 = 6, df2 = 33, ncp = 30.4) = 0.998921</span>
    <span class="s3">#     MATLAB: ncfcdf(20, 6, 33, 30.4) = 0.998921</span>
    <span class="s1">scipy_val = stats.ncf.cdf(</span><span class="s4">20</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">33</span><span class="s2">, </span><span class="s4">30.4</span><span class="s1">)</span>
    <span class="s1">check_val = </span><span class="s4">0.998921</span>
    <span class="s1">assert_allclose(check_val</span><span class="s2">, </span><span class="s1">np.round(scipy_val</span><span class="s2">, </span><span class="s1">decimals=</span><span class="s4">6</span><span class="s1">))</span>


<span class="s1">@pytest.mark.skipif(sys.maxsize &lt;= </span><span class="s4">2</span><span class="s1">**</span><span class="s4">32</span><span class="s2">,</span>
                    <span class="s1">reason=</span><span class="s5">&quot;On some 32-bit the warning is not raised&quot;</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_ncf_ppf_issue_17026():</span>
    <span class="s3"># Regression test for gh-17026</span>
    <span class="s1">x = np.linspace(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">600</span><span class="s1">)</span>
    <span class="s1">x[</span><span class="s4">0</span><span class="s1">] = </span><span class="s4">1e-16</span>
    <span class="s1">par = (</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.warns(RuntimeWarning):</span>
        <span class="s1">q = stats.ncf.ppf(x</span><span class="s2">, </span><span class="s1">*par)</span>
        <span class="s1">q0 = [stats.ncf.ppf(xi</span><span class="s2">, </span><span class="s1">*par) </span><span class="s2">for </span><span class="s1">xi </span><span class="s2">in </span><span class="s1">x]</span>
    <span class="s1">assert_allclose(q</span><span class="s2">, </span><span class="s1">q0)</span>


<span class="s2">class </span><span class="s1">TestHistogram:</span>
    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">np.random.seed(</span><span class="s4">1234</span><span class="s1">)</span>

        <span class="s3"># We have 8 bins</span>
        <span class="s3"># [1,2), [2,3), [3,4), [4,5), [5,6), [6,7), [7,8), [8,9)</span>
        <span class="s3"># But actually np.histogram will put the last 9 also in the [8,9) bin!</span>
        <span class="s3"># Therefore there is a slight difference below for the last bin, from</span>
        <span class="s3"># what you might have expected.</span>
        <span class="s1">histogram = np.histogram([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">4</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">5</span><span class="s2">,</span>
                                  <span class="s4">6</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">6</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">7</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">8</span><span class="s2">, </span><span class="s4">9</span><span class="s1">]</span><span class="s2">, </span><span class="s1">bins=</span><span class="s4">8</span><span class="s1">)</span>
        <span class="s1">self.template = stats.rv_histogram(histogram)</span>

        <span class="s1">data = stats.norm.rvs(loc=</span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">2.5</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">10000</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s4">123</span><span class="s1">)</span>
        <span class="s1">norm_histogram = np.histogram(data</span><span class="s2">, </span><span class="s1">bins=</span><span class="s4">50</span><span class="s1">)</span>
        <span class="s1">self.norm_template = stats.rv_histogram(norm_histogram)</span>

    <span class="s2">def </span><span class="s1">test_pdf(self):</span>
        <span class="s1">values = np.array([</span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">2.5</span><span class="s2">, </span><span class="s4">3.0</span><span class="s2">, </span><span class="s4">3.5</span><span class="s2">, </span><span class="s4">4.0</span><span class="s2">, </span><span class="s4">4.5</span><span class="s2">,</span>
                           <span class="s4">5.0</span><span class="s2">, </span><span class="s4">5.5</span><span class="s2">, </span><span class="s4">6.0</span><span class="s2">, </span><span class="s4">6.5</span><span class="s2">, </span><span class="s4">7.0</span><span class="s2">, </span><span class="s4">7.5</span><span class="s2">, </span><span class="s4">8.0</span><span class="s2">, </span><span class="s4">8.5</span><span class="s2">, </span><span class="s4">9.0</span><span class="s2">, </span><span class="s4">9.5</span><span class="s1">])</span>
        <span class="s1">pdf_values = np.asarray([</span><span class="s4">0.0</span><span class="s1">/</span><span class="s4">25.0</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">/</span><span class="s4">25.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">/</span><span class="s4">25.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">/</span><span class="s4">25.0</span><span class="s2">,</span>
                                 <span class="s4">2.0</span><span class="s1">/</span><span class="s4">25.0</span><span class="s2">, </span><span class="s4">2.0</span><span class="s1">/</span><span class="s4">25.0</span><span class="s2">, </span><span class="s4">3.0</span><span class="s1">/</span><span class="s4">25.0</span><span class="s2">, </span><span class="s4">3.0</span><span class="s1">/</span><span class="s4">25.0</span><span class="s2">,</span>
                                 <span class="s4">4.0</span><span class="s1">/</span><span class="s4">25.0</span><span class="s2">, </span><span class="s4">4.0</span><span class="s1">/</span><span class="s4">25.0</span><span class="s2">, </span><span class="s4">5.0</span><span class="s1">/</span><span class="s4">25.0</span><span class="s2">, </span><span class="s4">5.0</span><span class="s1">/</span><span class="s4">25.0</span><span class="s2">,</span>
                                 <span class="s4">4.0</span><span class="s1">/</span><span class="s4">25.0</span><span class="s2">, </span><span class="s4">4.0</span><span class="s1">/</span><span class="s4">25.0</span><span class="s2">, </span><span class="s4">3.0</span><span class="s1">/</span><span class="s4">25.0</span><span class="s2">, </span><span class="s4">3.0</span><span class="s1">/</span><span class="s4">25.0</span><span class="s2">,</span>
                                 <span class="s4">3.0</span><span class="s1">/</span><span class="s4">25.0</span><span class="s2">, </span><span class="s4">3.0</span><span class="s1">/</span><span class="s4">25.0</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">/</span><span class="s4">25.0</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">/</span><span class="s4">25.0</span><span class="s1">])</span>
        <span class="s1">assert_allclose(self.template.pdf(values)</span><span class="s2">, </span><span class="s1">pdf_values)</span>

        <span class="s3"># Test explicitly the corner cases:</span>
        <span class="s3"># As stated above the pdf in the bin [8,9) is greater than</span>
        <span class="s3"># one would naively expect because np.histogram putted the 9</span>
        <span class="s3"># into the [8,9) bin.</span>
        <span class="s1">assert_almost_equal(self.template.pdf(</span><span class="s4">8.0</span><span class="s1">)</span><span class="s2">, </span><span class="s4">3.0</span><span class="s1">/</span><span class="s4">25.0</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(self.template.pdf(</span><span class="s4">8.5</span><span class="s1">)</span><span class="s2">, </span><span class="s4">3.0</span><span class="s1">/</span><span class="s4">25.0</span><span class="s1">)</span>
        <span class="s3"># 9 is outside our defined bins [8,9) hence the pdf is already 0</span>
        <span class="s3"># for a continuous distribution this is fine, because a single value</span>
        <span class="s3"># does not have a finite probability!</span>
        <span class="s1">assert_almost_equal(self.template.pdf(</span><span class="s4">9.0</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">/</span><span class="s4">25.0</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(self.template.pdf(</span><span class="s4">10.0</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">/</span><span class="s4">25.0</span><span class="s1">)</span>

        <span class="s1">x = np.linspace(-</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">assert_allclose(self.norm_template.pdf(x)</span><span class="s2">,</span>
                        <span class="s1">stats.norm.pdf(x</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">2.5</span><span class="s1">)</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.1</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_cdf_ppf(self):</span>
        <span class="s1">values = np.array([</span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">1.5</span><span class="s2">, </span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">2.5</span><span class="s2">, </span><span class="s4">3.0</span><span class="s2">, </span><span class="s4">3.5</span><span class="s2">, </span><span class="s4">4.0</span><span class="s2">, </span><span class="s4">4.5</span><span class="s2">,</span>
                           <span class="s4">5.0</span><span class="s2">, </span><span class="s4">5.5</span><span class="s2">, </span><span class="s4">6.0</span><span class="s2">, </span><span class="s4">6.5</span><span class="s2">, </span><span class="s4">7.0</span><span class="s2">, </span><span class="s4">7.5</span><span class="s2">, </span><span class="s4">8.0</span><span class="s2">, </span><span class="s4">8.5</span><span class="s2">, </span><span class="s4">9.0</span><span class="s2">, </span><span class="s4">9.5</span><span class="s1">])</span>
        <span class="s1">cdf_values = np.asarray([</span><span class="s4">0.0</span><span class="s1">/</span><span class="s4">25.0</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">/</span><span class="s4">25.0</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">/</span><span class="s4">25.0</span><span class="s2">, </span><span class="s4">0.5</span><span class="s1">/</span><span class="s4">25.0</span><span class="s2">,</span>
                                 <span class="s4">1.0</span><span class="s1">/</span><span class="s4">25.0</span><span class="s2">, </span><span class="s4">2.0</span><span class="s1">/</span><span class="s4">25.0</span><span class="s2">, </span><span class="s4">3.0</span><span class="s1">/</span><span class="s4">25.0</span><span class="s2">, </span><span class="s4">4.5</span><span class="s1">/</span><span class="s4">25.0</span><span class="s2">,</span>
                                 <span class="s4">6.0</span><span class="s1">/</span><span class="s4">25.0</span><span class="s2">, </span><span class="s4">8.0</span><span class="s1">/</span><span class="s4">25.0</span><span class="s2">, </span><span class="s4">10.0</span><span class="s1">/</span><span class="s4">25.0</span><span class="s2">, </span><span class="s4">12.5</span><span class="s1">/</span><span class="s4">25.0</span><span class="s2">,</span>
                                 <span class="s4">15.0</span><span class="s1">/</span><span class="s4">25.0</span><span class="s2">, </span><span class="s4">17.0</span><span class="s1">/</span><span class="s4">25.0</span><span class="s2">, </span><span class="s4">19.0</span><span class="s1">/</span><span class="s4">25.0</span><span class="s2">, </span><span class="s4">20.5</span><span class="s1">/</span><span class="s4">25.0</span><span class="s2">,</span>
                                 <span class="s4">22.0</span><span class="s1">/</span><span class="s4">25.0</span><span class="s2">, </span><span class="s4">23.5</span><span class="s1">/</span><span class="s4">25.0</span><span class="s2">, </span><span class="s4">25.0</span><span class="s1">/</span><span class="s4">25.0</span><span class="s2">, </span><span class="s4">25.0</span><span class="s1">/</span><span class="s4">25.0</span><span class="s1">])</span>
        <span class="s1">assert_allclose(self.template.cdf(values)</span><span class="s2">, </span><span class="s1">cdf_values)</span>
        <span class="s3"># First three and last two values in cdf_value are not unique</span>
        <span class="s1">assert_allclose(self.template.ppf(cdf_values[</span><span class="s4">2</span><span class="s1">:-</span><span class="s4">1</span><span class="s1">])</span><span class="s2">, </span><span class="s1">values[</span><span class="s4">2</span><span class="s1">:-</span><span class="s4">1</span><span class="s1">])</span>

        <span class="s3"># Test of cdf and ppf are inverse functions</span>
        <span class="s1">x = np.linspace(</span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">9.0</span><span class="s2">, </span><span class="s4">100</span><span class="s1">)</span>
        <span class="s1">assert_allclose(self.template.ppf(self.template.cdf(x))</span><span class="s2">, </span><span class="s1">x)</span>
        <span class="s1">x = np.linspace(</span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">100</span><span class="s1">)</span>
        <span class="s1">assert_allclose(self.template.cdf(self.template.ppf(x))</span><span class="s2">, </span><span class="s1">x)</span>

        <span class="s1">x = np.linspace(-</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">assert_allclose(self.norm_template.cdf(x)</span><span class="s2">,</span>
                        <span class="s1">stats.norm.cdf(x</span><span class="s2">, </span><span class="s1">loc=</span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">2.5</span><span class="s1">)</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.1</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_rvs(self):</span>
        <span class="s1">N = </span><span class="s4">10000</span>
        <span class="s1">sample = self.template.rvs(size=N</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s4">123</span><span class="s1">)</span>
        <span class="s1">assert_equal(np.sum(sample &lt; </span><span class="s4">1.0</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(np.sum(sample &lt;= </span><span class="s4">2.0</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">/</span><span class="s4">25.0 </span><span class="s1">* N</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.2</span><span class="s1">)</span>
        <span class="s1">assert_allclose(np.sum(sample &lt;= </span><span class="s4">2.5</span><span class="s1">)</span><span class="s2">, </span><span class="s4">2.0</span><span class="s1">/</span><span class="s4">25.0 </span><span class="s1">* N</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.2</span><span class="s1">)</span>
        <span class="s1">assert_allclose(np.sum(sample &lt;= </span><span class="s4">3.0</span><span class="s1">)</span><span class="s2">, </span><span class="s4">3.0</span><span class="s1">/</span><span class="s4">25.0 </span><span class="s1">* N</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(np.sum(sample &lt;= </span><span class="s4">3.5</span><span class="s1">)</span><span class="s2">, </span><span class="s4">4.5</span><span class="s1">/</span><span class="s4">25.0 </span><span class="s1">* N</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(np.sum(sample &lt;= </span><span class="s4">4.0</span><span class="s1">)</span><span class="s2">, </span><span class="s4">6.0</span><span class="s1">/</span><span class="s4">25.0 </span><span class="s1">* N</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(np.sum(sample &lt;= </span><span class="s4">4.5</span><span class="s1">)</span><span class="s2">, </span><span class="s4">8.0</span><span class="s1">/</span><span class="s4">25.0 </span><span class="s1">* N</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(np.sum(sample &lt;= </span><span class="s4">5.0</span><span class="s1">)</span><span class="s2">, </span><span class="s4">10.0</span><span class="s1">/</span><span class="s4">25.0 </span><span class="s1">* N</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.05</span><span class="s1">)</span>
        <span class="s1">assert_allclose(np.sum(sample &lt;= </span><span class="s4">5.5</span><span class="s1">)</span><span class="s2">, </span><span class="s4">12.5</span><span class="s1">/</span><span class="s4">25.0 </span><span class="s1">* N</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.05</span><span class="s1">)</span>
        <span class="s1">assert_allclose(np.sum(sample &lt;= </span><span class="s4">6.0</span><span class="s1">)</span><span class="s2">, </span><span class="s4">15.0</span><span class="s1">/</span><span class="s4">25.0 </span><span class="s1">* N</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.05</span><span class="s1">)</span>
        <span class="s1">assert_allclose(np.sum(sample &lt;= </span><span class="s4">6.5</span><span class="s1">)</span><span class="s2">, </span><span class="s4">17.0</span><span class="s1">/</span><span class="s4">25.0 </span><span class="s1">* N</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.05</span><span class="s1">)</span>
        <span class="s1">assert_allclose(np.sum(sample &lt;= </span><span class="s4">7.0</span><span class="s1">)</span><span class="s2">, </span><span class="s4">19.0</span><span class="s1">/</span><span class="s4">25.0 </span><span class="s1">* N</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.05</span><span class="s1">)</span>
        <span class="s1">assert_allclose(np.sum(sample &lt;= </span><span class="s4">7.5</span><span class="s1">)</span><span class="s2">, </span><span class="s4">20.5</span><span class="s1">/</span><span class="s4">25.0 </span><span class="s1">* N</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.05</span><span class="s1">)</span>
        <span class="s1">assert_allclose(np.sum(sample &lt;= </span><span class="s4">8.0</span><span class="s1">)</span><span class="s2">, </span><span class="s4">22.0</span><span class="s1">/</span><span class="s4">25.0 </span><span class="s1">* N</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.05</span><span class="s1">)</span>
        <span class="s1">assert_allclose(np.sum(sample &lt;= </span><span class="s4">8.5</span><span class="s1">)</span><span class="s2">, </span><span class="s4">23.5</span><span class="s1">/</span><span class="s4">25.0 </span><span class="s1">* N</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.05</span><span class="s1">)</span>
        <span class="s1">assert_allclose(np.sum(sample &lt;= </span><span class="s4">9.0</span><span class="s1">)</span><span class="s2">, </span><span class="s4">25.0</span><span class="s1">/</span><span class="s4">25.0 </span><span class="s1">* N</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.05</span><span class="s1">)</span>
        <span class="s1">assert_allclose(np.sum(sample &lt;= </span><span class="s4">9.0</span><span class="s1">)</span><span class="s2">, </span><span class="s4">25.0</span><span class="s1">/</span><span class="s4">25.0 </span><span class="s1">* N</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.05</span><span class="s1">)</span>
        <span class="s1">assert_equal(np.sum(sample &gt; </span><span class="s4">9.0</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0.0</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_munp(self):</span>
        <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">4</span><span class="s1">):</span>
            <span class="s1">assert_allclose(self.norm_template._munp(n)</span><span class="s2">,</span>
                            <span class="s1">stats.norm(</span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">2.5</span><span class="s1">).moment(n)</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.05</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_entropy(self):</span>
        <span class="s1">assert_allclose(self.norm_template.entropy()</span><span class="s2">,</span>
                        <span class="s1">stats.norm.entropy(loc=</span><span class="s4">1.0</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">2.5</span><span class="s1">)</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.05</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_histogram_non_uniform():</span>
    <span class="s3"># Tests rv_histogram works even for non-uniform bin widths</span>
    <span class="s1">counts</span><span class="s2">, </span><span class="s1">bins = ([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1001</span><span class="s1">])</span>

    <span class="s1">dist = stats.rv_histogram((counts</span><span class="s2">, </span><span class="s1">bins)</span><span class="s2">, </span><span class="s1">density=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">np.testing.assert_allclose(dist.pdf([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">200</span><span class="s1">])</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.0005</span><span class="s1">])</span>
    <span class="s2">assert </span><span class="s1">dist.median() == </span><span class="s4">1</span>

    <span class="s1">dist = stats.rv_histogram((counts</span><span class="s2">, </span><span class="s1">bins)</span><span class="s2">, </span><span class="s1">density=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">np.testing.assert_allclose(dist.pdf([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">200</span><span class="s1">])</span><span class="s2">, </span><span class="s4">1</span><span class="s1">/</span><span class="s4">1001</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">dist.median() == </span><span class="s4">1001</span><span class="s1">/</span><span class="s4">2</span>

    <span class="s3"># Omitting density produces a warning for non-uniform bins...</span>
    <span class="s1">message = </span><span class="s5">&quot;Bin widths are not constant. Assuming...&quot;</span>
    <span class="s2">with </span><span class="s1">assert_warns(RuntimeWarning</span><span class="s2">, </span><span class="s1">match=message):</span>
        <span class="s1">dist = stats.rv_histogram((counts</span><span class="s2">, </span><span class="s1">bins))</span>
        <span class="s2">assert </span><span class="s1">dist.median() == </span><span class="s4">1001</span><span class="s1">/</span><span class="s4">2  </span><span class="s3"># default is like `density=True`</span>

    <span class="s3"># ... but not for uniform bins</span>
    <span class="s1">dist = stats.rv_histogram((counts</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]))</span>
    <span class="s2">assert </span><span class="s1">dist.median() == </span><span class="s4">1</span>


<span class="s2">class </span><span class="s1">TestLogUniform:</span>
    <span class="s2">def </span><span class="s1">test_alias(self):</span>
        <span class="s3"># This test makes sure that &quot;reciprocal&quot; and &quot;loguniform&quot; are</span>
        <span class="s3"># aliases of the same distribution and that both are log-uniform</span>
        <span class="s1">rng = np.random.default_rng(</span><span class="s4">98643218961</span><span class="s1">)</span>
        <span class="s1">rv = stats.loguniform(</span><span class="s4">10 </span><span class="s1">** -</span><span class="s4">3</span><span class="s2">, </span><span class="s4">10 </span><span class="s1">** </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">rvs = rv.rvs(size=</span><span class="s4">10000</span><span class="s2">, </span><span class="s1">random_state=rng)</span>

        <span class="s1">rng = np.random.default_rng(</span><span class="s4">98643218961</span><span class="s1">)</span>
        <span class="s1">rv2 = stats.reciprocal(</span><span class="s4">10 </span><span class="s1">** -</span><span class="s4">3</span><span class="s2">, </span><span class="s4">10 </span><span class="s1">** </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">rvs2 = rv2.rvs(size=</span><span class="s4">10000</span><span class="s2">, </span><span class="s1">random_state=rng)</span>

        <span class="s1">assert_allclose(rvs2</span><span class="s2">, </span><span class="s1">rvs)</span>

        <span class="s1">vals</span><span class="s2">, </span><span class="s1">_ = np.histogram(np.log10(rvs)</span><span class="s2">, </span><span class="s1">bins=</span><span class="s4">10</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s4">900 </span><span class="s1">&lt;= vals.min() &lt;= vals.max() &lt;= </span><span class="s4">1100</span>
        <span class="s2">assert </span><span class="s1">np.abs(np.median(vals) - </span><span class="s4">1000</span><span class="s1">) &lt;= </span><span class="s4">10</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;method&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s5">'mle'</span><span class="s2">, </span><span class="s5">'mm'</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_fit_override(self</span><span class="s2">, </span><span class="s1">method):</span>
        <span class="s3"># loguniform is overparameterized, so check that fit override enforces</span>
        <span class="s3"># scale=1 unless fscale is provided by the user</span>
        <span class="s1">rng = np.random.default_rng(</span><span class="s4">98643218961</span><span class="s1">)</span>
        <span class="s1">rvs = stats.loguniform.rvs(</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">1000</span><span class="s2">, </span><span class="s1">random_state=rng)</span>

        <span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = stats.loguniform.fit(rvs</span><span class="s2">, </span><span class="s1">method=method)</span>
        <span class="s2">assert </span><span class="s1">scale == </span><span class="s4">1</span>

        <span class="s1">a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = stats.loguniform.fit(rvs</span><span class="s2">, </span><span class="s1">fscale=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">method=method)</span>
        <span class="s2">assert </span><span class="s1">scale == </span><span class="s4">2</span>

    <span class="s2">def </span><span class="s1">test_overflow(self):</span>
        <span class="s3"># original formulation had overflow issues; check that this is resolved</span>
        <span class="s3"># Extensive accuracy tests elsewhere, no need to test all methods</span>
        <span class="s1">rng = np.random.default_rng(</span><span class="s4">7136519550773909093</span><span class="s1">)</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">b = </span><span class="s4">1e-200</span><span class="s2">, </span><span class="s4">1e200</span>
        <span class="s1">dist = stats.loguniform(a</span><span class="s2">, </span><span class="s1">b)</span>

        <span class="s3"># test roundtrip error</span>
        <span class="s1">cdf = rng.uniform(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">1000</span><span class="s1">)</span>
        <span class="s1">assert_allclose(dist.cdf(dist.ppf(cdf))</span><span class="s2">, </span><span class="s1">cdf)</span>
        <span class="s1">rvs = dist.rvs(size=</span><span class="s4">1000</span><span class="s1">)</span>
        <span class="s1">assert_allclose(dist.ppf(dist.cdf(rvs))</span><span class="s2">, </span><span class="s1">rvs)</span>

        <span class="s3"># test a property of the pdf (and that there is no overflow)</span>
        <span class="s1">x = </span><span class="s4">10.</span><span class="s1">**np.arange(-</span><span class="s4">200</span><span class="s2">, </span><span class="s4">200</span><span class="s1">)</span>
        <span class="s1">pdf = dist.pdf(x)  </span><span class="s3"># no overflow</span>
        <span class="s1">assert_allclose(pdf[:-</span><span class="s4">1</span><span class="s1">]/pdf[</span><span class="s4">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span>

        <span class="s3"># check munp against wikipedia reference</span>
        <span class="s1">mean = (b - a)/(np.log(b) - np.log(a))</span>
        <span class="s1">assert_allclose(dist.mean()</span><span class="s2">, </span><span class="s1">mean)</span>


<span class="s2">class </span><span class="s1">TestArgus:</span>
    <span class="s2">def </span><span class="s1">test_argus_rvs_large_chi(self):</span>
        <span class="s3"># test that the algorithm can handle large values of chi</span>
        <span class="s1">x = stats.argus.rvs(</span><span class="s4">50</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">500</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s4">325</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(stats.argus(</span><span class="s4">50</span><span class="s1">).mean()</span><span class="s2">, </span><span class="s1">x.mean()</span><span class="s2">, </span><span class="s1">decimal=</span><span class="s4">4</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'chi, random_state'</span><span class="s2">, </span><span class="s1">[</span>
            <span class="s1">[</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">325</span><span class="s1">]</span><span class="s2">,   </span><span class="s3"># chi &lt;= 0.5: rejection method case 1</span>
            <span class="s1">[</span><span class="s4">1.3</span><span class="s2">, </span><span class="s4">155</span><span class="s1">]</span><span class="s2">,   </span><span class="s3"># 0.5 &lt; chi &lt;= 1.8: rejection method case 2</span>
            <span class="s1">[</span><span class="s4">3.5</span><span class="s2">, </span><span class="s4">135</span><span class="s1">]    </span><span class="s3"># chi &gt; 1.8: transform conditional Gamma distribution</span>
        <span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_rvs(self</span><span class="s2">, </span><span class="s1">chi</span><span class="s2">, </span><span class="s1">random_state):</span>
        <span class="s1">x = stats.argus.rvs(chi</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">500</span><span class="s2">, </span><span class="s1">random_state=random_state)</span>
        <span class="s1">_</span><span class="s2">, </span><span class="s1">p = stats.kstest(x</span><span class="s2">, </span><span class="s5">&quot;argus&quot;</span><span class="s2">, </span><span class="s1">(chi</span><span class="s2">, </span><span class="s1">))</span>
        <span class="s1">assert_(p &gt; </span><span class="s4">0.05</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'chi'</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1e-9</span><span class="s2">, </span><span class="s4">1e-6</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_rvs_small_chi(self</span><span class="s2">, </span><span class="s1">chi):</span>
        <span class="s3"># test for gh-11699 =&gt; rejection method case 1 can even handle chi=0</span>
        <span class="s3"># the CDF of the distribution for chi=0 is 1 - (1 - x**2)**(3/2)</span>
        <span class="s3"># test rvs against distribution of limit chi=0</span>
        <span class="s1">r = stats.argus.rvs(chi</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">500</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s4">890981</span><span class="s1">)</span>
        <span class="s1">_</span><span class="s2">, </span><span class="s1">p = stats.kstest(r</span><span class="s2">, lambda </span><span class="s1">x: </span><span class="s4">1 </span><span class="s1">- (</span><span class="s4">1 </span><span class="s1">- x**</span><span class="s4">2</span><span class="s1">)**(</span><span class="s4">3</span><span class="s1">/</span><span class="s4">2</span><span class="s1">))</span>
        <span class="s1">assert_(p &gt; </span><span class="s4">0.05</span><span class="s1">)</span>

    <span class="s3"># Expected values were computed with mpmath.</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'chi, expected_mean'</span><span class="s2">,</span>
                             <span class="s1">[(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.6187026683551835</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">10</span><span class="s2">, </span><span class="s4">0.984805536783744</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">40</span><span class="s2">, </span><span class="s4">0.9990617659702923</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">60</span><span class="s2">, </span><span class="s4">0.9995831885165300</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">99</span><span class="s2">, </span><span class="s4">0.9998469348663028</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_mean(self</span><span class="s2">, </span><span class="s1">chi</span><span class="s2">, </span><span class="s1">expected_mean):</span>
        <span class="s1">m = stats.argus.mean(chi</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(m</span><span class="s2">, </span><span class="s1">expected_mean</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-13</span><span class="s1">)</span>

    <span class="s3"># Expected values were computed with mpmath.</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'chi, expected_var, rtol'</span><span class="s2">,</span>
                             <span class="s1">[(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0.05215651254197807</span><span class="s2">, </span><span class="s4">1e-13</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">10</span><span class="s2">, </span><span class="s4">0.00015805472008165595</span><span class="s2">, </span><span class="s4">1e-11</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">40</span><span class="s2">, </span><span class="s4">5.877763210262901e-07</span><span class="s2">, </span><span class="s4">1e-8</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">60</span><span class="s2">, </span><span class="s4">1.1590179389611416e-07</span><span class="s2">, </span><span class="s4">1e-8</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">99</span><span class="s2">, </span><span class="s4">1.5623277006064666e-08</span><span class="s2">, </span><span class="s4">1e-8</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_var(self</span><span class="s2">, </span><span class="s1">chi</span><span class="s2">, </span><span class="s1">expected_var</span><span class="s2">, </span><span class="s1">rtol):</span>
        <span class="s1">v = stats.argus.var(chi</span><span class="s2">, </span><span class="s1">scale=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(v</span><span class="s2">, </span><span class="s1">expected_var</span><span class="s2">, </span><span class="s1">rtol=rtol)</span>

    <span class="s3"># Expected values were computed with mpmath (code: see gh-13370).</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'chi, expected, rtol'</span><span class="s2">,</span>
                             <span class="s1">[(</span><span class="s4">0.9</span><span class="s2">, </span><span class="s4">0.07646314974436118</span><span class="s2">, </span><span class="s4">1e-14</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.015429797891863365</span><span class="s2">, </span><span class="s4">1e-14</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.0001325825293278049</span><span class="s2">, </span><span class="s4">1e-14</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">0.01</span><span class="s2">, </span><span class="s4">1.3297677078224565e-07</span><span class="s2">, </span><span class="s4">1e-15</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">1e-3</span><span class="s2">, </span><span class="s4">1.3298072023958999e-10</span><span class="s2">, </span><span class="s4">1e-14</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">1e-4</span><span class="s2">, </span><span class="s4">1.3298075973486862e-13</span><span class="s2">, </span><span class="s4">1e-14</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">1e-6</span><span class="s2">, </span><span class="s4">1.32980760133771e-19</span><span class="s2">, </span><span class="s4">1e-14</span><span class="s1">)</span><span class="s2">,</span>
                              <span class="s1">(</span><span class="s4">1e-9</span><span class="s2">, </span><span class="s4">1.329807601338109e-28</span><span class="s2">, </span><span class="s4">1e-15</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_argus_phi_small_chi(self</span><span class="s2">, </span><span class="s1">chi</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">rtol):</span>
        <span class="s1">assert_allclose(_argus_phi(chi)</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">rtol=rtol)</span>

    <span class="s3"># Expected values were computed with mpmath (code: see gh-13370).</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s5">'chi, expected'</span><span class="s2">,</span>
        <span class="s1">[(</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.28414073302940573</span><span class="s2">, </span><span class="s4">1.2742227939992954</span><span class="s2">, </span><span class="s4">1.2381254688255896</span><span class="s1">))</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">0.2</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.296172952995264</span><span class="s2">, </span><span class="s4">1.2951290588110516</span><span class="s2">, </span><span class="s4">1.1865767100877576</span><span class="s1">))</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">0.1</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.29791447523536274</span><span class="s2">, </span><span class="s4">1.29806307956989</span><span class="s2">, </span><span class="s4">1.1793168289857412</span><span class="s1">))</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">0.01</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.2984904104866452</span><span class="s2">, </span><span class="s4">1.2990283628160553</span><span class="s2">, </span><span class="s4">1.1769268414080531</span><span class="s1">))</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">1e-3</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.298496172925224</span><span class="s2">, </span><span class="s4">1.2990380082487925</span><span class="s2">, </span><span class="s4">1.176902956021053</span><span class="s1">))</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">1e-4</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.29849623054991836</span><span class="s2">, </span><span class="s4">1.2990381047023793</span><span class="s2">, </span><span class="s4">1.1769027171686324</span><span class="s1">))</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">1e-6</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.2984962311319278</span><span class="s2">, </span><span class="s4">1.2990381056765605</span><span class="s2">, </span><span class="s4">1.1769027147562232</span><span class="s1">))</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">1e-9</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.298496231131986</span><span class="s2">, </span><span class="s4">1.299038105676658</span><span class="s2">, </span><span class="s4">1.1769027147559818</span><span class="s1">))])</span>
    <span class="s2">def </span><span class="s1">test_pdf_small_chi(self</span><span class="s2">, </span><span class="s1">chi</span><span class="s2">, </span><span class="s1">expected):</span>
        <span class="s1">x = np.array([</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.9</span><span class="s1">])</span>
        <span class="s1">assert_allclose(stats.argus.pdf(x</span><span class="s2">, </span><span class="s1">chi)</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-13</span><span class="s1">)</span>

    <span class="s3"># Expected values were computed with mpmath (code: see gh-13370).</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s5">'chi, expected'</span><span class="s2">,</span>
        <span class="s1">[(</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.9857660526895221</span><span class="s2">, </span><span class="s4">0.6616565930168475</span><span class="s2">, </span><span class="s4">0.08796070398429937</span><span class="s1">))</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">0.2</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.9851555052359501</span><span class="s2">, </span><span class="s4">0.6514666238985464</span><span class="s2">, </span><span class="s4">0.08362690023746594</span><span class="s1">))</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">0.1</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.9850670974995661</span><span class="s2">, </span><span class="s4">0.6500061310508574</span><span class="s2">, </span><span class="s4">0.08302050640683846</span><span class="s1">))</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">0.01</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.9850378582451867</span><span class="s2">, </span><span class="s4">0.6495239242251358</span><span class="s2">, </span><span class="s4">0.08282109244852445</span><span class="s1">))</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">1e-3</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.9850375656906663</span><span class="s2">, </span><span class="s4">0.6495191015522573</span><span class="s2">, </span><span class="s4">0.08281910005231098</span><span class="s1">))</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">1e-4</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.9850375627651049</span><span class="s2">, </span><span class="s4">0.6495190533254682</span><span class="s2">, </span><span class="s4">0.08281908012852317</span><span class="s1">))</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">1e-6</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.9850375627355568</span><span class="s2">, </span><span class="s4">0.6495190528383777</span><span class="s2">, </span><span class="s4">0.08281907992729293</span><span class="s1">))</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">1e-9</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.9850375627355538</span><span class="s2">, </span><span class="s4">0.649519052838329</span><span class="s2">, </span><span class="s4">0.0828190799272728</span><span class="s1">))])</span>
    <span class="s2">def </span><span class="s1">test_sf_small_chi(self</span><span class="s2">, </span><span class="s1">chi</span><span class="s2">, </span><span class="s1">expected):</span>
        <span class="s1">x = np.array([</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.9</span><span class="s1">])</span>
        <span class="s1">assert_allclose(stats.argus.sf(x</span><span class="s2">, </span><span class="s1">chi)</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-14</span><span class="s1">)</span>

    <span class="s3"># Expected values were computed with mpmath (code: see gh-13370).</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s5">'chi, expected'</span><span class="s2">,</span>
        <span class="s1">[(</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.0142339473104779</span><span class="s2">, </span><span class="s4">0.3383434069831524</span><span class="s2">, </span><span class="s4">0.9120392960157007</span><span class="s1">))</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">0.2</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.014844494764049919</span><span class="s2">, </span><span class="s4">0.34853337610145363</span><span class="s2">, </span><span class="s4">0.916373099762534</span><span class="s1">))</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">0.1</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.014932902500433911</span><span class="s2">, </span><span class="s4">0.34999386894914264</span><span class="s2">, </span><span class="s4">0.9169794935931616</span><span class="s1">))</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">0.01</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.014962141754813293</span><span class="s2">, </span><span class="s4">0.35047607577486417</span><span class="s2">, </span><span class="s4">0.9171789075514756</span><span class="s1">))</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">1e-3</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.01496243430933372</span><span class="s2">, </span><span class="s4">0.35048089844774266</span><span class="s2">, </span><span class="s4">0.917180899947689</span><span class="s1">))</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">1e-4</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.014962437234895118</span><span class="s2">, </span><span class="s4">0.3504809466745317</span><span class="s2">, </span><span class="s4">0.9171809198714769</span><span class="s1">))</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">1e-6</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.01496243726444329</span><span class="s2">, </span><span class="s4">0.3504809471616223</span><span class="s2">, </span><span class="s4">0.9171809200727071</span><span class="s1">))</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">1e-9</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.014962437264446245</span><span class="s2">, </span><span class="s4">0.350480947161671</span><span class="s2">, </span><span class="s4">0.9171809200727272</span><span class="s1">))])</span>
    <span class="s2">def </span><span class="s1">test_cdf_small_chi(self</span><span class="s2">, </span><span class="s1">chi</span><span class="s2">, </span><span class="s1">expected):</span>
        <span class="s1">x = np.array([</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.9</span><span class="s1">])</span>
        <span class="s1">assert_allclose(stats.argus.cdf(x</span><span class="s2">, </span><span class="s1">chi)</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-12</span><span class="s1">)</span>

    <span class="s3"># Expected values were computed with mpmath (code: see gh-13370).</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s5">'chi, expected, rtol'</span><span class="s2">,</span>
        <span class="s1">[(</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.5964284712757741</span><span class="s2">, </span><span class="s4">0.052890651988588604</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1e-12</span><span class="s1">)</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">0.101</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.5893490968089076</span><span class="s2">, </span><span class="s4">0.053017469847275685</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1e-11</span><span class="s1">)</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">0.1</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.5893431757009437</span><span class="s2">, </span><span class="s4">0.05301755449499372</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1e-13</span><span class="s1">)</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">0.01</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.5890515677940915</span><span class="s2">, </span><span class="s4">0.05302167905837031</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1e-13</span><span class="s1">)</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">1e-3</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.5890486520005177</span><span class="s2">, </span><span class="s4">0.053021719862088104</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1e-13</span><span class="s1">)</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">1e-4</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.5890486228426105</span><span class="s2">, </span><span class="s4">0.0530217202700811</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1e-13</span><span class="s1">)</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">1e-6</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.5890486225481156</span><span class="s2">, </span><span class="s4">0.05302172027420182</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1e-13</span><span class="s1">)</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">1e-9</span><span class="s2">, </span><span class="s1">(</span><span class="s4">0.5890486225480862</span><span class="s2">, </span><span class="s4">0.05302172027420224</span><span class="s1">)</span><span class="s2">, </span><span class="s4">1e-13</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_stats_small_chi(self</span><span class="s2">, </span><span class="s1">chi</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">rtol):</span>
        <span class="s1">val = stats.argus.stats(chi</span><span class="s2">, </span><span class="s1">moments=</span><span class="s5">'mv'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(val</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">rtol=rtol)</span>


<span class="s2">class </span><span class="s1">TestNakagami:</span>

    <span class="s2">def </span><span class="s1">test_logpdf(self):</span>
        <span class="s3"># Test nakagami logpdf for an input where the PDF is smaller</span>
        <span class="s3"># than can be represented with 64 bit floating point.</span>
        <span class="s3"># The expected value of logpdf was computed with mpmath:</span>
        <span class="s3">#</span>
        <span class="s3">#   def logpdf(x, nu):</span>
        <span class="s3">#       x = mpmath.mpf(x)</span>
        <span class="s3">#       nu = mpmath.mpf(nu)</span>
        <span class="s3">#       return (mpmath.log(2) + nu*mpmath.log(nu) -</span>
        <span class="s3">#               mpmath.loggamma(nu) + (2*nu - 1)*mpmath.log(x) -</span>
        <span class="s3">#               nu*x**2)</span>
        <span class="s3">#</span>
        <span class="s1">nu = </span><span class="s4">2.5</span>
        <span class="s1">x = </span><span class="s4">25</span>
        <span class="s1">logp = stats.nakagami.logpdf(x</span><span class="s2">, </span><span class="s1">nu)</span>
        <span class="s1">assert_allclose(logp</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1546.9253055607549</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_sf_isf(self):</span>
        <span class="s3"># Test nakagami sf and isf when the survival function</span>
        <span class="s3"># value is very small.</span>
        <span class="s3"># The expected value of the survival function was computed</span>
        <span class="s3"># with mpmath:</span>
        <span class="s3">#</span>
        <span class="s3">#   def sf(x, nu):</span>
        <span class="s3">#       x = mpmath.mpf(x)</span>
        <span class="s3">#       nu = mpmath.mpf(nu)</span>
        <span class="s3">#       return mpmath.gammainc(nu, nu*x*x, regularized=True)</span>
        <span class="s3">#</span>
        <span class="s1">nu = </span><span class="s4">2.5</span>
        <span class="s1">x0 = </span><span class="s4">5.0</span>
        <span class="s1">sf = stats.nakagami.sf(x0</span><span class="s2">, </span><span class="s1">nu)</span>
        <span class="s1">assert_allclose(sf</span><span class="s2">, </span><span class="s4">2.736273158588307e-25</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-13</span><span class="s1">)</span>
        <span class="s3"># Check round trip back to x0.</span>
        <span class="s1">x1 = stats.nakagami.isf(sf</span><span class="s2">, </span><span class="s1">nu)</span>
        <span class="s1">assert_allclose(x1</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-13</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;m, ref&quot;</span><span class="s2">,</span>
        <span class="s1">[(</span><span class="s4">5</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.097341814372152</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.7257913526447274</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">10</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.43426184310934907</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_entropy(self</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">ref):</span>
        <span class="s3"># from sympy import *</span>
        <span class="s3"># from mpmath import mp</span>
        <span class="s3"># import numpy as np</span>
        <span class="s3"># v, x = symbols('v, x', real=True, positive=True)</span>
        <span class="s3"># pdf = 2 * v ** v / gamma(v) * x ** (2 * v - 1) * exp(-v * x ** 2)</span>
        <span class="s3"># h = simplify(simplify(integrate(-pdf * log(pdf), (x, 0, oo))))</span>
        <span class="s3"># entropy = lambdify(v, h, 'mpmath')</span>
        <span class="s3"># mp.dps = 200</span>
        <span class="s3"># nu = 5</span>
        <span class="s3"># ref = np.float64(entropy(mp.mpf(nu)))</span>
        <span class="s3"># print(ref)</span>
        <span class="s1">assert_allclose(stats.nakagami.entropy(m)</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1.1e-14</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;m, ref&quot;</span><span class="s2">,</span>
        <span class="s1">[(</span><span class="s4">1e-100</span><span class="s2">, </span><span class="s1">-</span><span class="s4">5.0e+99</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1e-10</span><span class="s2">, </span><span class="s1">-</span><span class="s4">4999999965.442979</span><span class="s1">)</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">9.999e6</span><span class="s2">, </span><span class="s1">-</span><span class="s4">7.333206478668433</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1.001e7</span><span class="s2">, </span><span class="s1">-</span><span class="s4">7.3337562313259825</span><span class="s1">)</span><span class="s2">,</span>
         <span class="s1">(</span><span class="s4">1e10</span><span class="s2">, </span><span class="s1">-</span><span class="s4">10.787134112333835</span><span class="s1">)</span><span class="s2">, </span><span class="s1">(</span><span class="s4">1e100</span><span class="s2">, </span><span class="s1">-</span><span class="s4">114.40346329705756</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_extreme_nu(self</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">ref):</span>
        <span class="s1">assert_allclose(stats.nakagami.entropy(m)</span><span class="s2">, </span><span class="s1">ref)</span>

    <span class="s2">def </span><span class="s1">test_entropy_overflow(self):</span>
        <span class="s2">assert </span><span class="s1">np.isfinite(stats.nakagami._entropy(</span><span class="s4">1e100</span><span class="s1">))</span>
        <span class="s2">assert </span><span class="s1">np.isfinite(stats.nakagami._entropy(</span><span class="s4">1e-100</span><span class="s1">))</span>

    <span class="s1">@pytest.mark.xfail(reason=</span><span class="s5">&quot;Fit of nakagami not reliable, see gh-10908.&quot;</span><span class="s1">)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'nu'</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1.6</span><span class="s2">, </span><span class="s4">2.5</span><span class="s2">, </span><span class="s4">3.9</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'loc'</span><span class="s2">, </span><span class="s1">[</span><span class="s4">25.0</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">35</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'scale'</span><span class="s2">, </span><span class="s1">[</span><span class="s4">13</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">20</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_fit(self</span><span class="s2">, </span><span class="s1">nu</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale):</span>
        <span class="s3"># Regression test for gh-13396 (21/27 cases failed previously)</span>
        <span class="s3"># The first tuple of the parameters' values is discussed in gh-10908</span>
        <span class="s1">N = </span><span class="s4">100</span>
        <span class="s1">samples = stats.nakagami.rvs(size=N</span><span class="s2">, </span><span class="s1">nu=nu</span><span class="s2">, </span><span class="s1">loc=loc</span><span class="s2">,</span>
                                     <span class="s1">scale=scale</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s4">1337</span><span class="s1">)</span>
        <span class="s1">nu_est</span><span class="s2">, </span><span class="s1">loc_est</span><span class="s2">, </span><span class="s1">scale_est = stats.nakagami.fit(samples)</span>
        <span class="s1">assert_allclose(nu_est</span><span class="s2">, </span><span class="s1">nu</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.2</span><span class="s1">)</span>
        <span class="s1">assert_allclose(loc_est</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.2</span><span class="s1">)</span>
        <span class="s1">assert_allclose(scale_est</span><span class="s2">, </span><span class="s1">scale</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">0.2</span><span class="s1">)</span>

        <span class="s2">def </span><span class="s1">dlogl_dnu(nu</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale):</span>
            <span class="s2">return </span><span class="s1">((-</span><span class="s4">2</span><span class="s1">*nu + </span><span class="s4">1</span><span class="s1">) * np.sum(</span><span class="s4">1</span><span class="s1">/(samples - loc))</span>
                    <span class="s1">+ </span><span class="s4">2</span><span class="s1">*nu/scale**</span><span class="s4">2 </span><span class="s1">* np.sum(samples - loc))</span>

        <span class="s2">def </span><span class="s1">dlogl_dloc(nu</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale):</span>
            <span class="s2">return </span><span class="s1">(N * (</span><span class="s4">1 </span><span class="s1">+ np.log(nu) - polygamma(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">nu)) +</span>
                    <span class="s4">2 </span><span class="s1">* np.sum(np.log((samples - loc) / scale))</span>
                    <span class="s1">- np.sum(((samples - loc) / scale)**</span><span class="s4">2</span><span class="s1">))</span>

        <span class="s2">def </span><span class="s1">dlogl_dscale(nu</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale):</span>
            <span class="s2">return </span><span class="s1">(- </span><span class="s4">2 </span><span class="s1">* N * nu / scale</span>
                    <span class="s1">+ </span><span class="s4">2 </span><span class="s1">* nu / scale ** </span><span class="s4">3 </span><span class="s1">* np.sum((samples - loc) ** </span><span class="s4">2</span><span class="s1">))</span>

        <span class="s1">assert_allclose(dlogl_dnu(nu_est</span><span class="s2">, </span><span class="s1">loc_est</span><span class="s2">, </span><span class="s1">scale_est)</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-3</span><span class="s1">)</span>
        <span class="s1">assert_allclose(dlogl_dloc(nu_est</span><span class="s2">, </span><span class="s1">loc_est</span><span class="s2">, </span><span class="s1">scale_est)</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-3</span><span class="s1">)</span>
        <span class="s1">assert_allclose(dlogl_dscale(nu_est</span><span class="s2">, </span><span class="s1">loc_est</span><span class="s2">, </span><span class="s1">scale_est)</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-3</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'loc'</span><span class="s2">, </span><span class="s1">[</span><span class="s4">25.0</span><span class="s2">, </span><span class="s4">10</span><span class="s2">, </span><span class="s4">35</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'scale'</span><span class="s2">, </span><span class="s1">[</span><span class="s4">13</span><span class="s2">, </span><span class="s4">5</span><span class="s2">, </span><span class="s4">20</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_fit_nu(self</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale):</span>
        <span class="s3"># For nu = 0.5, we have analytical values for</span>
        <span class="s3"># the MLE of the loc and the scale</span>
        <span class="s1">nu = </span><span class="s4">0.5</span>
        <span class="s1">n = </span><span class="s4">100</span>
        <span class="s1">samples = stats.nakagami.rvs(size=n</span><span class="s2">, </span><span class="s1">nu=nu</span><span class="s2">, </span><span class="s1">loc=loc</span><span class="s2">,</span>
                                     <span class="s1">scale=scale</span><span class="s2">, </span><span class="s1">random_state=</span><span class="s4">1337</span><span class="s1">)</span>
        <span class="s1">nu_est</span><span class="s2">, </span><span class="s1">loc_est</span><span class="s2">, </span><span class="s1">scale_est = stats.nakagami.fit(samples</span><span class="s2">, </span><span class="s1">f0=nu)</span>

        <span class="s3"># Analytical values</span>
        <span class="s1">loc_theo = np.min(samples)</span>
        <span class="s1">scale_theo = np.sqrt(np.mean((samples - loc_est) ** </span><span class="s4">2</span><span class="s1">))</span>

        <span class="s1">assert_allclose(nu_est</span><span class="s2">, </span><span class="s1">nu</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-7</span><span class="s1">)</span>
        <span class="s1">assert_allclose(loc_est</span><span class="s2">, </span><span class="s1">loc_theo</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-7</span><span class="s1">)</span>
        <span class="s1">assert_allclose(scale_est</span><span class="s2">, </span><span class="s1">scale_theo</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-7</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestWrapCauchy:</span>

    <span class="s2">def </span><span class="s1">test_cdf_shape_broadcasting(self):</span>
        <span class="s3"># Regression test for gh-13791.</span>
        <span class="s3"># Check that wrapcauchy.cdf broadcasts the shape parameter</span>
        <span class="s3"># correctly.</span>
        <span class="s1">c = np.array([[</span><span class="s4">0.03</span><span class="s2">, </span><span class="s4">0.25</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.75</span><span class="s1">]])</span>
        <span class="s1">x = np.array([[</span><span class="s4">1.0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">4.0</span><span class="s1">]])</span>
        <span class="s1">p = stats.wrapcauchy.cdf(x</span><span class="s2">, </span><span class="s1">c)</span>
        <span class="s2">assert </span><span class="s1">p.shape == (</span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">scalar_values = [stats.wrapcauchy.cdf(x1</span><span class="s2">, </span><span class="s1">c1)</span>
                         <span class="s2">for </span><span class="s1">(x1</span><span class="s2">, </span><span class="s1">c1) </span><span class="s2">in </span><span class="s1">np.nditer((x</span><span class="s2">, </span><span class="s1">c))]</span>
        <span class="s1">assert_allclose(p.ravel()</span><span class="s2">, </span><span class="s1">scalar_values</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-13</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_cdf_center(self):</span>
        <span class="s1">p = stats.wrapcauchy.cdf(np.pi</span><span class="s2">, </span><span class="s4">0.03</span><span class="s1">)</span>
        <span class="s1">assert_allclose(p</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-14</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_cdf(self):</span>
        <span class="s1">x1 = </span><span class="s4">1.0  </span><span class="s3"># less than pi</span>
        <span class="s1">x2 = </span><span class="s4">4.0  </span><span class="s3"># greater than pi</span>
        <span class="s1">c = </span><span class="s4">0.75</span>
        <span class="s1">p = stats.wrapcauchy.cdf([x1</span><span class="s2">, </span><span class="s1">x2]</span><span class="s2">, </span><span class="s1">c)</span>
        <span class="s1">cr = (</span><span class="s4">1 </span><span class="s1">+ c)/(</span><span class="s4">1 </span><span class="s1">- c)</span>
        <span class="s1">assert_allclose(p[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.arctan(cr*np.tan(x1/</span><span class="s4">2</span><span class="s1">))/np.pi)</span>
        <span class="s1">assert_allclose(p[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s4">1 </span><span class="s1">- np.arctan(cr*np.tan(np.pi - x2/</span><span class="s4">2</span><span class="s1">))/np.pi)</span>


<span class="s2">def </span><span class="s1">test_rvs_no_size_error():</span>
    <span class="s3"># _rvs methods must have parameter `size`; see gh-11394</span>
    <span class="s2">class </span><span class="s1">rvs_no_size_gen(stats.rv_continuous):</span>
        <span class="s2">def </span><span class="s1">_rvs(self):</span>
            <span class="s2">return </span><span class="s4">1</span>

    <span class="s1">rvs_no_size = rvs_no_size_gen(name=</span><span class="s5">'rvs_no_size'</span><span class="s1">)</span>

    <span class="s2">with </span><span class="s1">assert_raises(TypeError</span><span class="s2">, </span><span class="s1">match=</span><span class="s5">r&quot;_rvs\(\) got (an|\d) unexpected&quot;</span><span class="s1">):</span>
        <span class="s1">rvs_no_size.rvs()</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s5">'distname, args'</span><span class="s2">, </span><span class="s1">invdistdiscrete + invdistcont)</span>
<span class="s2">def </span><span class="s1">test_support_gh13294_regression(distname</span><span class="s2">, </span><span class="s1">args):</span>
    <span class="s2">if </span><span class="s1">distname </span><span class="s2">in </span><span class="s1">skip_test_support_gh13294_regression:</span>
        <span class="s1">pytest.skip(</span><span class="s5">f&quot;skipping test for the support method for &quot;</span>
                    <span class="s5">f&quot;distribution </span><span class="s2">{</span><span class="s1">distname</span><span class="s2">}</span><span class="s5">.&quot;</span><span class="s1">)</span>
    <span class="s1">dist = getattr(stats</span><span class="s2">, </span><span class="s1">distname)</span>
    <span class="s3"># test support method with invalid arguents</span>
    <span class="s2">if </span><span class="s1">isinstance(dist</span><span class="s2">, </span><span class="s1">stats.rv_continuous):</span>
        <span class="s3"># test with valid scale</span>
        <span class="s2">if </span><span class="s1">len(args) != </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">a0</span><span class="s2">, </span><span class="s1">b0 = dist.support(*args)</span>
            <span class="s1">assert_equal(a0</span><span class="s2">, </span><span class="s1">np.nan)</span>
            <span class="s1">assert_equal(b0</span><span class="s2">, </span><span class="s1">np.nan)</span>
        <span class="s3"># test with invalid scale</span>
        <span class="s3"># For some distributions, that take no parameters,</span>
        <span class="s3"># the case of only invalid scale occurs and hence,</span>
        <span class="s3"># it is implicitly tested in this test case.</span>
        <span class="s1">loc1</span><span class="s2">, </span><span class="s1">scale1 = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span>
        <span class="s1">a1</span><span class="s2">, </span><span class="s1">b1 = dist.support(*args</span><span class="s2">, </span><span class="s1">loc1</span><span class="s2">, </span><span class="s1">scale1)</span>
        <span class="s1">assert_equal(a1</span><span class="s2">, </span><span class="s1">np.nan)</span>
        <span class="s1">assert_equal(b1</span><span class="s2">, </span><span class="s1">np.nan)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">a</span><span class="s2">, </span><span class="s1">b = dist.support(*args)</span>
        <span class="s1">assert_equal(a</span><span class="s2">, </span><span class="s1">np.nan)</span>
        <span class="s1">assert_equal(b</span><span class="s2">, </span><span class="s1">np.nan)</span>


<span class="s2">def </span><span class="s1">test_support_broadcasting_gh13294_regression():</span>
    <span class="s1">a0</span><span class="s2">, </span><span class="s1">b0 = stats.norm.support([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">ex_a0 = np.array([-np.inf</span><span class="s2">, </span><span class="s1">-np.inf</span><span class="s2">, </span><span class="s1">-np.inf</span><span class="s2">, </span><span class="s1">np.nan])</span>
    <span class="s1">ex_b0 = np.array([np.inf</span><span class="s2">, </span><span class="s1">np.inf</span><span class="s2">, </span><span class="s1">np.inf</span><span class="s2">, </span><span class="s1">np.nan])</span>
    <span class="s1">assert_equal(a0</span><span class="s2">, </span><span class="s1">ex_a0)</span>
    <span class="s1">assert_equal(b0</span><span class="s2">, </span><span class="s1">ex_b0)</span>
    <span class="s2">assert </span><span class="s1">a0.shape == ex_a0.shape</span>
    <span class="s2">assert </span><span class="s1">b0.shape == ex_b0.shape</span>

    <span class="s1">a1</span><span class="s2">, </span><span class="s1">b1 = stats.norm.support([]</span><span class="s2">, </span><span class="s1">[])</span>
    <span class="s1">ex_a1</span><span class="s2">, </span><span class="s1">ex_b1 = np.array([])</span><span class="s2">, </span><span class="s1">np.array([])</span>
    <span class="s1">assert_equal(a1</span><span class="s2">, </span><span class="s1">ex_a1)</span>
    <span class="s1">assert_equal(b1</span><span class="s2">, </span><span class="s1">ex_b1)</span>
    <span class="s2">assert </span><span class="s1">a1.shape == ex_a1.shape</span>
    <span class="s2">assert </span><span class="s1">b1.shape == ex_b1.shape</span>

    <span class="s1">a2</span><span class="s2">, </span><span class="s1">b2 = stats.norm.support([</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[-</span><span class="s4">1</span><span class="s1">])</span>
    <span class="s1">ex_a2 = np.array(</span><span class="s4">4</span><span class="s1">*[np.nan])</span>
    <span class="s1">ex_b2 = np.array(</span><span class="s4">4</span><span class="s1">*[np.nan])</span>
    <span class="s1">assert_equal(a2</span><span class="s2">, </span><span class="s1">ex_a2)</span>
    <span class="s1">assert_equal(b2</span><span class="s2">, </span><span class="s1">ex_b2)</span>
    <span class="s2">assert </span><span class="s1">a2.shape == ex_a2.shape</span>
    <span class="s2">assert </span><span class="s1">b2.shape == ex_b2.shape</span>


<span class="s2">def </span><span class="s1">test_stats_broadcasting_gh14953_regression():</span>
    <span class="s3"># test case in gh14953</span>
    <span class="s1">loc = [</span><span class="s4">0.</span><span class="s2">, </span><span class="s4">0.</span><span class="s1">]</span>
    <span class="s1">scale = [[</span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">2.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3.</span><span class="s1">]]</span>
    <span class="s1">assert_equal(stats.norm.var(loc</span><span class="s2">, </span><span class="s1">scale)</span><span class="s2">, </span><span class="s1">[[</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">4.</span><span class="s2">, </span><span class="s4">4.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">9.</span><span class="s2">, </span><span class="s4">9.</span><span class="s1">]])</span>
    <span class="s3"># test some edge cases</span>
    <span class="s1">loc = np.empty((</span><span class="s4">0</span><span class="s2">, </span><span class="s1">))</span>
    <span class="s1">scale = np.empty((</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">))</span>
    <span class="s2">assert </span><span class="s1">stats.norm.var(loc</span><span class="s2">, </span><span class="s1">scale).shape == (</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>


<span class="s3"># Check a few values of the cosine distribution's cdf, sf, ppf and</span>
<span class="s3"># isf methods.  Expected values were computed with mpmath.</span>

<span class="s1">@pytest.mark.parametrize(</span><span class="s5">'x, expected'</span><span class="s2">,</span>
                         <span class="s1">[(-</span><span class="s4">3.14159</span><span class="s2">, </span><span class="s4">4.956444476505336e-19</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">(</span><span class="s4">3.14</span><span class="s2">, </span><span class="s4">0.9999999998928399</span><span class="s1">)])</span>
<span class="s2">def </span><span class="s1">test_cosine_cdf_sf(x</span><span class="s2">, </span><span class="s1">expected):</span>
    <span class="s1">assert_allclose(stats.cosine.cdf(x)</span><span class="s2">, </span><span class="s1">expected)</span>
    <span class="s1">assert_allclose(stats.cosine.sf(-x)</span><span class="s2">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s5">'p, expected'</span><span class="s2">,</span>
                         <span class="s1">[(</span><span class="s4">1e-6</span><span class="s2">, </span><span class="s1">-</span><span class="s4">3.1080612413765905</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">(</span><span class="s4">1e-17</span><span class="s2">, </span><span class="s1">-</span><span class="s4">3.141585429601399</span><span class="s1">)</span><span class="s2">,</span>
                          <span class="s1">(</span><span class="s4">0.975</span><span class="s2">, </span><span class="s4">2.1447547020964923</span><span class="s1">)])</span>
<span class="s2">def </span><span class="s1">test_cosine_ppf_isf(p</span><span class="s2">, </span><span class="s1">expected):</span>
    <span class="s1">assert_allclose(stats.cosine.ppf(p)</span><span class="s2">, </span><span class="s1">expected)</span>
    <span class="s1">assert_allclose(stats.cosine.isf(p)</span><span class="s2">, </span><span class="s1">-expected)</span>


<span class="s2">def </span><span class="s1">test_cosine_logpdf_endpoints():</span>
    <span class="s1">logp = stats.cosine.logpdf([-np.pi</span><span class="s2">, </span><span class="s1">np.pi])</span>
    <span class="s3"># reference value calculated using mpmath assuming `np.cos(-1)` is four</span>
    <span class="s3"># floating point numbers too high. See gh-18382.</span>
    <span class="s1">assert_array_less(logp</span><span class="s2">, </span><span class="s1">-</span><span class="s4">37.18838327496655</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_distr_params_lists():</span>
    <span class="s3"># distribution objects are extra distributions added in</span>
    <span class="s3"># test_discrete_basic. All other distributions are strings (names)</span>
    <span class="s3"># and so we only choose those to compare whether both lists match.</span>
    <span class="s1">discrete_distnames = {name </span><span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">distdiscrete</span>
                          <span class="s2">if </span><span class="s1">isinstance(name</span><span class="s2">, </span><span class="s1">str)}</span>
    <span class="s1">invdiscrete_distnames = {name </span><span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">invdistdiscrete}</span>
    <span class="s2">assert </span><span class="s1">discrete_distnames == invdiscrete_distnames</span>

    <span class="s1">cont_distnames = {name </span><span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">distcont}</span>
    <span class="s1">invcont_distnames = {name </span><span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">_ </span><span class="s2">in </span><span class="s1">invdistcont}</span>
    <span class="s2">assert </span><span class="s1">cont_distnames == invcont_distnames</span>


<span class="s2">def </span><span class="s1">test_moment_order_4():</span>
    <span class="s3"># gh-13655 reported that if a distribution has a `_stats` method that</span>
    <span class="s3"># accepts the `moments` parameter, then if the distribution's `moment`</span>
    <span class="s3"># method is called with `order=4`, the faster/more accurate`_stats` gets</span>
    <span class="s3"># called, but the results aren't used, and the generic `_munp` method is</span>
    <span class="s3"># called to calculate the moment anyway. This tests that the issue has</span>
    <span class="s3"># been fixed.</span>
    <span class="s3"># stats.skewnorm._stats accepts the `moments` keyword</span>
    <span class="s1">stats.skewnorm._stats(a=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">moments=</span><span class="s5">'k'</span><span class="s1">)  </span><span class="s3"># no failure = has `moments`</span>
    <span class="s3"># When `moment` is called, `_stats` is used, so the moment is very accurate</span>
    <span class="s3"># (exactly equal to Pearson's kurtosis of the normal distribution, 3)</span>
    <span class="s2">assert </span><span class="s1">stats.skewnorm.moment(order=</span><span class="s4">4</span><span class="s2">, </span><span class="s1">a=</span><span class="s4">0</span><span class="s1">) == </span><span class="s4">3.0</span>
    <span class="s3"># At the time of gh-13655, skewnorm._munp() used the generic method</span>
    <span class="s3"># to compute its result, which was inefficient and not very accurate.</span>
    <span class="s3"># At that time, the following assertion would fail.  skewnorm._munp()</span>
    <span class="s3"># has since been made more accurate and efficient, so now this test</span>
    <span class="s3"># is expected to pass.</span>
    <span class="s2">assert </span><span class="s1">stats.skewnorm._munp(</span><span class="s4">4</span><span class="s2">, </span><span class="s4">0</span><span class="s1">) == </span><span class="s4">3.0</span>


<span class="s2">class </span><span class="s1">TestRelativisticBW:</span>
    <span class="s1">@pytest.fixture</span>
    <span class="s2">def </span><span class="s1">ROOT_pdf_sample_data(self):</span>
        <span class="s0">&quot;&quot;&quot;Sample data points for pdf computed with CERN's ROOT 
 
        See - https://root.cern/ 
 
        Uses ROOT.TMath.BreitWignerRelativistic, available in ROOT 
        versions 6.27+ 
 
        pdf calculated for Z0 Boson, W Boson, and Higgs Boson for 
        x in `np.linspace(0, 200, 401)`. 
        &quot;&quot;&quot;</span>
        <span class="s1">data = np.load(</span>
            <span class="s1">Path(__file__).parent /</span>
            <span class="s5">'data/rel_breitwigner_pdf_sample_data_ROOT.npy'</span>
        <span class="s1">)</span>
        <span class="s1">data = np.core.records.fromarrays(data.T</span><span class="s2">, </span><span class="s1">names=</span><span class="s5">'x,pdf,rho,gamma'</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">data</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s5">&quot;rho,gamma,rtol&quot;</span><span class="s2">, </span><span class="s1">[</span>
            <span class="s1">(</span><span class="s4">36.545206797050334</span><span class="s2">, </span><span class="s4">2.4952</span><span class="s2">, </span><span class="s4">5e-14</span><span class="s1">)</span><span class="s2">,  </span><span class="s3"># Z0 Boson</span>
            <span class="s1">(</span><span class="s4">38.55107913669065</span><span class="s2">, </span><span class="s4">2.085</span><span class="s2">, </span><span class="s4">1e-14</span><span class="s1">)</span><span class="s2">,  </span><span class="s3"># W Boson</span>
            <span class="s1">(</span><span class="s4">96292.3076923077</span><span class="s2">, </span><span class="s4">0.0013</span><span class="s2">, </span><span class="s4">5e-13</span><span class="s1">)</span><span class="s2">,  </span><span class="s3"># Higgs Boson</span>
        <span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_pdf_against_ROOT(self</span><span class="s2">, </span><span class="s1">ROOT_pdf_sample_data</span><span class="s2">, </span><span class="s1">rho</span><span class="s2">, </span><span class="s1">gamma</span><span class="s2">, </span><span class="s1">rtol):</span>
        <span class="s1">data = ROOT_pdf_sample_data[</span>
            <span class="s1">(ROOT_pdf_sample_data[</span><span class="s5">'rho'</span><span class="s1">] == rho)</span>
            <span class="s1">&amp; (ROOT_pdf_sample_data[</span><span class="s5">'gamma'</span><span class="s1">] == gamma)</span>
        <span class="s1">]</span>
        <span class="s1">x</span><span class="s2">, </span><span class="s1">pdf = data[</span><span class="s5">'x'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">data[</span><span class="s5">'pdf'</span><span class="s1">]</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">pdf</span><span class="s2">, </span><span class="s1">stats.rel_breitwigner.pdf(x</span><span class="s2">, </span><span class="s1">rho</span><span class="s2">, </span><span class="s1">scale=gamma)</span><span class="s2">, </span><span class="s1">rtol=rtol</span>
        <span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;rho, Gamma, rtol&quot;</span><span class="s2">, </span><span class="s1">[</span>
              <span class="s1">(</span><span class="s4">36.545206797050334</span><span class="s2">, </span><span class="s4">2.4952</span><span class="s2">, </span><span class="s4">5e-13</span><span class="s1">)</span><span class="s2">,  </span><span class="s3"># Z0 Boson</span>
              <span class="s1">(</span><span class="s4">38.55107913669065</span><span class="s2">, </span><span class="s4">2.085</span><span class="s2">, </span><span class="s4">5e-13</span><span class="s1">)</span><span class="s2">,  </span><span class="s3"># W Boson</span>
              <span class="s1">(</span><span class="s4">96292.3076923077</span><span class="s2">, </span><span class="s4">0.0013</span><span class="s2">, </span><span class="s4">5e-10</span><span class="s1">)</span><span class="s2">,  </span><span class="s3"># Higgs Boson</span>
          <span class="s1">]</span>
      <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_pdf_against_simple_implementation(self</span><span class="s2">, </span><span class="s1">rho</span><span class="s2">, </span><span class="s1">Gamma</span><span class="s2">, </span><span class="s1">rtol):</span>
        <span class="s3"># reference implementation straight from formulas on Wikipedia [1]</span>
        <span class="s2">def </span><span class="s1">pdf(E</span><span class="s2">, </span><span class="s1">M</span><span class="s2">, </span><span class="s1">Gamma):</span>
            <span class="s1">gamma = np.sqrt(M**</span><span class="s4">2 </span><span class="s1">* (M**</span><span class="s4">2 </span><span class="s1">+ Gamma**</span><span class="s4">2</span><span class="s1">))</span>
            <span class="s1">k = (</span><span class="s4">2 </span><span class="s1">* np.sqrt(</span><span class="s4">2</span><span class="s1">) * M * Gamma * gamma</span>
                 <span class="s1">/ (np.pi * np.sqrt(M**</span><span class="s4">2 </span><span class="s1">+ gamma)))</span>
            <span class="s2">return </span><span class="s1">k / ((E**</span><span class="s4">2 </span><span class="s1">- M**</span><span class="s4">2</span><span class="s1">)**</span><span class="s4">2 </span><span class="s1">+ M**</span><span class="s4">2</span><span class="s1">*Gamma**</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s3"># get reasonable values at which to evaluate the CDF</span>
        <span class="s1">p = np.linspace(</span><span class="s4">0.05</span><span class="s2">, </span><span class="s4">0.95</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">x = stats.rel_breitwigner.ppf(p</span><span class="s2">, </span><span class="s1">rho</span><span class="s2">, </span><span class="s1">scale=Gamma)</span>
        <span class="s1">res = stats.rel_breitwigner.pdf(x</span><span class="s2">, </span><span class="s1">rho</span><span class="s2">, </span><span class="s1">scale=Gamma)</span>
        <span class="s1">ref = pdf(x</span><span class="s2">, </span><span class="s1">rho*Gamma</span><span class="s2">, </span><span class="s1">Gamma)</span>
        <span class="s1">assert_allclose(res</span><span class="s2">, </span><span class="s1">ref</span><span class="s2">, </span><span class="s1">rtol=rtol)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s5">&quot;rho,gamma&quot;</span><span class="s2">, </span><span class="s1">[</span>
            <span class="s1">pytest.param(</span>
                <span class="s4">36.545206797050334</span><span class="s2">, </span><span class="s4">2.4952</span><span class="s2">, </span><span class="s1">marks=pytest.mark.slow</span>
            <span class="s1">)</span><span class="s2">,  </span><span class="s3"># Z0 Boson</span>
            <span class="s1">pytest.param(</span>
                <span class="s4">38.55107913669065</span><span class="s2">, </span><span class="s4">2.085</span><span class="s2">, </span><span class="s1">marks=pytest.mark.xslow</span>
            <span class="s1">)</span><span class="s2">,  </span><span class="s3"># W Boson</span>
            <span class="s1">pytest.param(</span>
                <span class="s4">96292.3076923077</span><span class="s2">, </span><span class="s4">0.0013</span><span class="s2">, </span><span class="s1">marks=pytest.mark.xslow</span>
            <span class="s1">)</span><span class="s2">,  </span><span class="s3"># Higgs Boson</span>
        <span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_fit_floc(self</span><span class="s2">, </span><span class="s1">rho</span><span class="s2">, </span><span class="s1">gamma):</span>
        <span class="s0">&quot;&quot;&quot;Tests fit for cases where floc is set. 
 
        `rel_breitwigner` has special handling for these cases. 
        &quot;&quot;&quot;</span>
        <span class="s1">seed = </span><span class="s4">6936804688480013683</span>
        <span class="s1">rng = np.random.default_rng(seed)</span>
        <span class="s1">data = stats.rel_breitwigner.rvs(</span>
            <span class="s1">rho</span><span class="s2">, </span><span class="s1">scale=gamma</span><span class="s2">, </span><span class="s1">size=</span><span class="s4">1000</span><span class="s2">, </span><span class="s1">random_state=rng</span>
        <span class="s1">)</span>
        <span class="s1">fit = stats.rel_breitwigner.fit(data</span><span class="s2">, </span><span class="s1">floc=</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose((fit[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">fit[</span><span class="s4">2</span><span class="s1">])</span><span class="s2">, </span><span class="s1">(rho</span><span class="s2">, </span><span class="s1">gamma)</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">2e-1</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">fit[</span><span class="s4">1</span><span class="s1">] == </span><span class="s4">0</span>
        <span class="s3"># Check again with fscale set.</span>
        <span class="s1">fit = stats.rel_breitwigner.fit(data</span><span class="s2">, </span><span class="s1">floc=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">fscale=gamma)</span>
        <span class="s1">assert_allclose(fit[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">rho</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-2</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">(fit[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">fit[</span><span class="s4">2</span><span class="s1">]) == (</span><span class="s4">0</span><span class="s2">, </span><span class="s1">gamma)</span>


<span class="s2">class </span><span class="s1">TestJohnsonSU:</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">&quot;case&quot;</span><span class="s2">, </span><span class="s1">[  </span><span class="s3"># a, b, loc, scale, m1, m2, g1, g2</span>
            <span class="s1">(-</span><span class="s4">0.01</span><span class="s2">, </span><span class="s4">1.1</span><span class="s2">, </span><span class="s4">0.02</span><span class="s2">, </span><span class="s4">0.0001</span><span class="s2">, </span><span class="s4">0.02000137427557091</span><span class="s2">,</span>
             <span class="s4">2.1112742956578063e-08</span><span class="s2">, </span><span class="s4">0.05989781342460999</span><span class="s2">, </span><span class="s4">20.36324408592951</span><span class="s1">-</span><span class="s4">3</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s4">2.554395574161155</span><span class="s2">, </span><span class="s4">2.2482281679651965</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.54215386737391</span><span class="s2">,</span>
             <span class="s4">0.7629882028469993</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.256656139406788</span><span class="s2">, </span><span class="s4">6.303058419339775</span><span class="s1">-</span><span class="s4">3</span><span class="s1">)])</span>
    <span class="s2">def </span><span class="s1">test_moment_gh18071(self</span><span class="s2">, </span><span class="s1">case):</span>
        <span class="s3"># gh-18071 reported an IntegrationWarning emitted by johnsonsu.stats</span>
        <span class="s3"># Check that the warning is no longer emitted and that the values</span>
        <span class="s3"># are accurate compared against results from Mathematica.</span>
        <span class="s3"># Reference values from Mathematica, e.g.</span>
        <span class="s3"># Mean[JohnsonDistribution[&quot;SU&quot;,-0.01, 1.1, 0.02, 0.0001]]</span>
        <span class="s1">res = stats.johnsonsu.stats(*case[:</span><span class="s4">4</span><span class="s1">]</span><span class="s2">, </span><span class="s1">moments=</span><span class="s5">'mvsk'</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res</span><span class="s2">, </span><span class="s1">case[</span><span class="s4">4</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s4">1e-14</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestTruncPareto:</span>
    <span class="s2">def </span><span class="s1">test_pdf(self):</span>
        <span class="s3"># PDF is that of the truncated pareto distribution</span>
        <span class="s1">b</span><span class="s2">, </span><span class="s1">c = </span><span class="s4">1.8</span><span class="s2">, </span><span class="s4">5.3</span>
        <span class="s1">x = np.linspace(</span><span class="s4">1.8</span><span class="s2">, </span><span class="s4">5.3</span><span class="s1">)</span>
        <span class="s1">res = stats.truncpareto(b</span><span class="s2">, </span><span class="s1">c).pdf(x)</span>
        <span class="s1">ref = stats.pareto(b).pdf(x) / stats.pareto(b).cdf(c)</span>
        <span class="s1">assert_allclose(res</span><span class="s2">, </span><span class="s1">ref)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'fix_loc'</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'fix_scale'</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'fix_b'</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s5">'fix_c'</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_fit(self</span><span class="s2">, </span><span class="s1">fix_loc</span><span class="s2">, </span><span class="s1">fix_scale</span><span class="s2">, </span><span class="s1">fix_b</span><span class="s2">, </span><span class="s1">fix_c):</span>

        <span class="s1">rng = np.random.default_rng(</span><span class="s4">6747363148258237171</span><span class="s1">)</span>
        <span class="s1">b</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">loc</span><span class="s2">, </span><span class="s1">scale = </span><span class="s4">1.8</span><span class="s2">, </span><span class="s4">5.3</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2.5</span>
        <span class="s1">dist = stats.truncpareto(b</span><span class="s2">, </span><span class="s1">c</span><span class="s2">, </span><span class="s1">loc=loc</span><span class="s2">, </span><span class="s1">scale=scale)</span>
        <span class="s1">data = dist.rvs(size=</span><span class="s4">500</span><span class="s2">, </span><span class="s1">random_state=rng)</span>

        <span class="s1">kwds = {}</span>
        <span class="s2">if </span><span class="s1">fix_loc:</span>
            <span class="s1">kwds[</span><span class="s5">'floc'</span><span class="s1">] = loc</span>
        <span class="s2">if </span><span class="s1">fix_scale:</span>
            <span class="s1">kwds[</span><span class="s5">'fscale'</span><span class="s1">] = scale</span>
        <span class="s2">if </span><span class="s1">fix_b:</span>
            <span class="s1">kwds[</span><span class="s5">'f0'</span><span class="s1">] = b</span>
        <span class="s2">if </span><span class="s1">fix_c:</span>
            <span class="s1">kwds[</span><span class="s5">'f1'</span><span class="s1">] = c</span>

        <span class="s2">if </span><span class="s1">fix_loc </span><span class="s2">and </span><span class="s1">fix_scale </span><span class="s2">and </span><span class="s1">fix_b </span><span class="s2">and </span><span class="s1">fix_c:</span>
            <span class="s1">message = </span><span class="s5">&quot;All parameters fixed. There is nothing to optimize.&quot;</span>
            <span class="s2">with </span><span class="s1">pytest.raises(RuntimeError</span><span class="s2">, </span><span class="s1">match=message):</span>
                <span class="s1">stats.truncpareto.fit(data</span><span class="s2">, </span><span class="s1">**kwds)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">_assert_less_or_close_loglike(stats.truncpareto</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">**kwds)</span>
</pre>
</body>
</html>