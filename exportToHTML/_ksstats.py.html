<html>
<head>
<title>_ksstats.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_ksstats.py</font>
</center></td></tr></table>
<pre><span class="s0"># Compute the two-sided one-sample Kolmogorov-Smirnov Prob(Dn &lt;= d) where:</span>
<span class="s0">#    D_n = sup_x{|F_n(x) - F(x)|},</span>
<span class="s0">#    F_n(x) is the empirical CDF for a sample of size n {x_i: i=1,...,n},</span>
<span class="s0">#    F(x) is the CDF of a probability distribution.</span>
<span class="s0">#</span>
<span class="s0"># Exact methods:</span>
<span class="s0"># Prob(D_n &gt;= d) can be computed via a matrix algorithm of Durbin[1]</span>
<span class="s0">#   or a recursion algorithm due to Pomeranz[2].</span>
<span class="s0"># Marsaglia, Tsang &amp; Wang[3] gave a computation-efficient way to perform</span>
<span class="s0">#   the Durbin algorithm.</span>
<span class="s0">#   D_n &gt;= d &lt;==&gt;  D_n+ &gt;= d or D_n- &gt;= d (the one-sided K-S statistics), hence</span>
<span class="s0">#   Prob(D_n &gt;= d) = 2*Prob(D_n+ &gt;= d) - Prob(D_n+ &gt;= d and D_n- &gt;= d).</span>
<span class="s0">#   For d &gt; 0.5, the latter intersection probability is 0.</span>
<span class="s0">#</span>
<span class="s0"># Approximate methods:</span>
<span class="s0"># For d close to 0.5, ignoring that intersection term may still give a</span>
<span class="s0">#   reasonable approximation.</span>
<span class="s0"># Li-Chien[4] and Korolyuk[5] gave an asymptotic formula extending</span>
<span class="s0"># Kolmogorov's initial asymptotic, suitable for large d. (See</span>
<span class="s0">#   scipy.special.kolmogorov for that asymptotic)</span>
<span class="s0"># Pelz-Good[6] used the functional equation for Jacobi theta functions to</span>
<span class="s0">#   transform the Li-Chien/Korolyuk formula produce a computational formula</span>
<span class="s0">#   suitable for small d.</span>
<span class="s0">#</span>
<span class="s0"># Simard and L'Ecuyer[7] provided an algorithm to decide when to use each of</span>
<span class="s0">#   the above approaches and it is that which is used here.</span>
<span class="s0">#</span>
<span class="s0"># Other approaches:</span>
<span class="s0"># Carvalho[8] optimizes Durbin's matrix algorithm for large values of d.</span>
<span class="s0"># Moscovich and Nadler[9] use FFTs to compute the convolutions.</span>

<span class="s0"># References:</span>
<span class="s0"># [1] Durbin J (1968).</span>
<span class="s0">#     &quot;The Probability that the Sample Distribution Function Lies Between Two</span>
<span class="s0">#     Parallel Straight Lines.&quot;</span>
<span class="s0">#     Annals of Mathematical Statistics, 39, 398-411.</span>
<span class="s0"># [2] Pomeranz J (1974).</span>
<span class="s0">#     &quot;Exact Cumulative Distribution of the Kolmogorov-Smirnov Statistic for</span>
<span class="s0">#     Small Samples (Algorithm 487).&quot;</span>
<span class="s0">#     Communications of the ACM, 17(12), 703-704.</span>
<span class="s0"># [3] Marsaglia G, Tsang WW, Wang J (2003).</span>
<span class="s0">#     &quot;Evaluating Kolmogorov's Distribution.&quot;</span>
<span class="s0">#     Journal of Statistical Software, 8(18), 1-4.</span>
<span class="s0"># [4] LI-CHIEN, C. (1956).</span>
<span class="s0">#     &quot;On the exact distribution of the statistics of A. N. Kolmogorov and</span>
<span class="s0">#     their asymptotic expansion.&quot;</span>
<span class="s0">#     Acta Matematica Sinica, 6, 55-81.</span>
<span class="s0"># [5] KOROLYUK, V. S. (1960).</span>
<span class="s0">#     &quot;Asymptotic analysis of the distribution of the maximum deviation in</span>
<span class="s0">#     the Bernoulli scheme.&quot;</span>
<span class="s0">#     Theor. Probability Appl., 4, 339-366.</span>
<span class="s0"># [6] Pelz W, Good IJ (1976).</span>
<span class="s0">#     &quot;Approximating the Lower Tail-areas of the Kolmogorov-Smirnov One-sample</span>
<span class="s0">#     Statistic.&quot;</span>
<span class="s0">#     Journal of the Royal Statistical Society, Series B, 38(2), 152-156.</span>
<span class="s0">#  [7] Simard, R., L'Ecuyer, P. (2011)</span>
<span class="s0">#     &quot;Computing the Two-Sided Kolmogorov-Smirnov Distribution&quot;,</span>
<span class="s0">#     Journal of Statistical Software, Vol 39, 11, 1-18.</span>
<span class="s0">#  [8] Carvalho, Luis (2015)</span>
<span class="s0">#     &quot;An Improved Evaluation of Kolmogorov's Distribution&quot;</span>
<span class="s0">#     Journal of Statistical Software, Code Snippets; Vol 65(3), 1-8.</span>
<span class="s0">#  [9] Amit Moscovich, Boaz Nadler (2017)</span>
<span class="s0">#     &quot;Fast calculation of boundary crossing probabilities for Poisson</span>
<span class="s0">#     processes&quot;,</span>
<span class="s0">#     Statistics &amp; Probability Letters, Vol 123, 177-182.</span>


<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">scipy.special</span>
<span class="s2">import </span><span class="s1">scipy.special._ufuncs </span><span class="s2">as </span><span class="s1">scu</span>
<span class="s2">from </span><span class="s1">scipy._lib._finite_differences </span><span class="s2">import </span><span class="s1">_derivative</span>

<span class="s1">_E128 = </span><span class="s3">128</span>
<span class="s1">_EP128 = np.ldexp(np.longdouble(</span><span class="s3">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">_E128)</span>
<span class="s1">_EM128 = np.ldexp(np.longdouble(</span><span class="s3">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">-_E128)</span>

<span class="s1">_SQRT2PI = np.sqrt(</span><span class="s3">2 </span><span class="s1">* np.pi)</span>
<span class="s1">_LOG_2PI = np.log(</span><span class="s3">2 </span><span class="s1">* np.pi)</span>
<span class="s1">_MIN_LOG = -</span><span class="s3">708</span>
<span class="s1">_SQRT3 = np.sqrt(</span><span class="s3">3</span><span class="s1">)</span>
<span class="s1">_PI_SQUARED = np.pi ** </span><span class="s3">2</span>
<span class="s1">_PI_FOUR = np.pi ** </span><span class="s3">4</span>
<span class="s1">_PI_SIX = np.pi ** </span><span class="s3">6</span>

<span class="s0"># [Lifted from _loggamma.pxd.] If B_m are the Bernoulli numbers,</span>
<span class="s0"># then Stirling coeffs are B_{2j}/(2j)/(2j-1) for j=8,...1.</span>
<span class="s1">_STIRLING_COEFFS = [-</span><span class="s3">2.955065359477124183e-2</span><span class="s2">, </span><span class="s3">6.4102564102564102564e-3</span><span class="s2">,</span>
                    <span class="s1">-</span><span class="s3">1.9175269175269175269e-3</span><span class="s2">, </span><span class="s3">8.4175084175084175084e-4</span><span class="s2">,</span>
                    <span class="s1">-</span><span class="s3">5.952380952380952381e-4</span><span class="s2">, </span><span class="s3">7.9365079365079365079e-4</span><span class="s2">,</span>
                    <span class="s1">-</span><span class="s3">2.7777777777777777778e-3</span><span class="s2">, </span><span class="s3">8.3333333333333333333e-2</span><span class="s1">]</span>


<span class="s2">def </span><span class="s1">_log_nfactorial_div_n_pow_n(n):</span>
    <span class="s0"># Computes n! / n**n</span>
    <span class="s0">#    = (n-1)! / n**(n-1)</span>
    <span class="s0"># Uses Stirling's approximation, but removes n*log(n) up-front to</span>
    <span class="s0"># avoid subtractive cancellation.</span>
    <span class="s0">#    = log(n)/2 - n + log(sqrt(2pi)) + sum B_{2j}/(2j)/(2j-1)/n**(2j-1)</span>
    <span class="s1">rn = </span><span class="s3">1.0</span><span class="s1">/n</span>
    <span class="s2">return </span><span class="s1">np.log(n)/</span><span class="s3">2 </span><span class="s1">- n + _LOG_2PI/</span><span class="s3">2 </span><span class="s1">+ rn * np.polyval(_STIRLING_COEFFS</span><span class="s2">, </span><span class="s1">rn/n)</span>


<span class="s2">def </span><span class="s1">_clip_prob(p):</span>
    <span class="s4">&quot;&quot;&quot;clips a probability to range 0&lt;=p&lt;=1.&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">np.clip(p</span><span class="s2">, </span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">1.0</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_select_and_clip_prob(cdfprob</span><span class="s2">, </span><span class="s1">sfprob</span><span class="s2">, </span><span class="s1">cdf=</span><span class="s2">True</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot;Selects either the CDF or SF, and then clips to range 0&lt;=p&lt;=1.&quot;&quot;&quot;</span>
    <span class="s1">p = np.where(cdf</span><span class="s2">, </span><span class="s1">cdfprob</span><span class="s2">, </span><span class="s1">sfprob)</span>
    <span class="s2">return </span><span class="s1">_clip_prob(p)</span>


<span class="s2">def </span><span class="s1">_kolmogn_DMTW(n</span><span class="s2">, </span><span class="s1">d</span><span class="s2">, </span><span class="s1">cdf=</span><span class="s2">True</span><span class="s1">):</span>
    <span class="s4">r&quot;&quot;&quot;Computes the Kolmogorov CDF:  Pr(D_n &lt;= d) using the MTW approach to 
    the Durbin matrix algorithm. 
 
    Durbin (1968); Marsaglia, Tsang, Wang (2003). [1], [3]. 
    &quot;&quot;&quot;</span>
    <span class="s0"># Write d = (k-h)/n, where k is positive integer and 0 &lt;= h &lt; 1</span>
    <span class="s0"># Generate initial matrix H of size m*m where m=(2k-1)</span>
    <span class="s0"># Compute k-th row of (n!/n^n) * H^n, scaling intermediate results.</span>
    <span class="s0"># Requires memory O(m^2) and computation O(m^2 log(n)).</span>
    <span class="s0"># Most suitable for small m.</span>

    <span class="s2">if </span><span class="s1">d &gt;= </span><span class="s3">1.0</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">_select_and_clip_prob(</span><span class="s3">1.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s2">, </span><span class="s1">cdf)</span>
    <span class="s1">nd = n * d</span>
    <span class="s2">if </span><span class="s1">nd &lt;= </span><span class="s3">0.5</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">_select_and_clip_prob(</span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">1.0</span><span class="s2">, </span><span class="s1">cdf)</span>
    <span class="s1">k = int(np.ceil(nd))</span>
    <span class="s1">h = k - nd</span>
    <span class="s1">m = </span><span class="s3">2 </span><span class="s1">* k - </span><span class="s3">1</span>

    <span class="s1">H = np.zeros([m</span><span class="s2">, </span><span class="s1">m])</span>

    <span class="s0"># Initialize: v is first column (and last row) of H</span>
    <span class="s0">#  v[j] = (1-h^(j+1)/(j+1)!  (except for v[-1])</span>
    <span class="s0">#  w[j] = 1/(j)!</span>
    <span class="s0"># q = k-th row of H (actually i!/n^i*H^i)</span>
    <span class="s1">intm = np.arange(</span><span class="s3">1</span><span class="s2">, </span><span class="s1">m + </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">v = </span><span class="s3">1.0 </span><span class="s1">- h ** intm</span>
    <span class="s1">w = np.empty(m)</span>
    <span class="s1">fac = </span><span class="s3">1.0</span>
    <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">intm:</span>
        <span class="s1">w[j - </span><span class="s3">1</span><span class="s1">] = fac</span>
        <span class="s1">fac /= j  </span><span class="s0"># This might underflow.  Isn't a problem.</span>
        <span class="s1">v[j - </span><span class="s3">1</span><span class="s1">] *= fac</span>
    <span class="s1">tt = max(</span><span class="s3">2 </span><span class="s1">* h - </span><span class="s3">1.0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)**m - </span><span class="s3">2</span><span class="s1">*h**m</span>
    <span class="s1">v[-</span><span class="s3">1</span><span class="s1">] = (</span><span class="s3">1.0 </span><span class="s1">+ tt) * fac</span>

    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s3">1</span><span class="s2">, </span><span class="s1">m):</span>
        <span class="s1">H[i - </span><span class="s3">1</span><span class="s1">:</span><span class="s2">, </span><span class="s1">i] = w[:m - i + </span><span class="s3">1</span><span class="s1">]</span>
    <span class="s1">H[:</span><span class="s2">, </span><span class="s3">0</span><span class="s1">] = v</span>
    <span class="s1">H[-</span><span class="s3">1</span><span class="s2">, </span><span class="s1">:] = np.flip(v</span><span class="s2">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)</span>

    <span class="s1">Hpwr = np.eye(np.shape(H)[</span><span class="s3">0</span><span class="s1">])  </span><span class="s0"># Holds intermediate powers of H</span>
    <span class="s1">nn = n</span>
    <span class="s1">expnt = </span><span class="s3">0  </span><span class="s0"># Scaling of Hpwr</span>
    <span class="s1">Hexpnt = </span><span class="s3">0  </span><span class="s0"># Scaling of H</span>
    <span class="s2">while </span><span class="s1">nn &gt; </span><span class="s3">0</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">nn % </span><span class="s3">2</span><span class="s1">:</span>
            <span class="s1">Hpwr = np.matmul(Hpwr</span><span class="s2">, </span><span class="s1">H)</span>
            <span class="s1">expnt += Hexpnt</span>
        <span class="s1">H = np.matmul(H</span><span class="s2">, </span><span class="s1">H)</span>
        <span class="s1">Hexpnt *= </span><span class="s3">2</span>
        <span class="s0"># Scale as needed.</span>
        <span class="s2">if </span><span class="s1">np.abs(H[k - </span><span class="s3">1</span><span class="s2">, </span><span class="s1">k - </span><span class="s3">1</span><span class="s1">]) &gt; _EP128:</span>
            <span class="s1">H /= _EP128</span>
            <span class="s1">Hexpnt += _E128</span>
        <span class="s1">nn = nn // </span><span class="s3">2</span>

    <span class="s1">p = Hpwr[k - </span><span class="s3">1</span><span class="s2">, </span><span class="s1">k - </span><span class="s3">1</span><span class="s1">]</span>

    <span class="s0"># Multiply by n!/n^n</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s3">1</span><span class="s2">, </span><span class="s1">n + </span><span class="s3">1</span><span class="s1">):</span>
        <span class="s1">p = i * p / n</span>
        <span class="s2">if </span><span class="s1">np.abs(p) &lt; _EM128:</span>
            <span class="s1">p *= _EP128</span>
            <span class="s1">expnt -= _E128</span>

    <span class="s0"># unscale</span>
    <span class="s2">if </span><span class="s1">expnt != </span><span class="s3">0</span><span class="s1">:</span>
        <span class="s1">p = np.ldexp(p</span><span class="s2">, </span><span class="s1">expnt)</span>

    <span class="s2">return </span><span class="s1">_select_and_clip_prob(p</span><span class="s2">, </span><span class="s3">1.0</span><span class="s1">-p</span><span class="s2">, </span><span class="s1">cdf)</span>


<span class="s2">def </span><span class="s1">_pomeranz_compute_j1j2(i</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">ll</span><span class="s2">, </span><span class="s1">ceilf</span><span class="s2">, </span><span class="s1">roundf):</span>
    <span class="s4">&quot;&quot;&quot;Compute the endpoints of the interval for row i.&quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">i == </span><span class="s3">0</span><span class="s1">:</span>
        <span class="s1">j1</span><span class="s2">, </span><span class="s1">j2 = -ll - ceilf - </span><span class="s3">1</span><span class="s2">, </span><span class="s1">ll + ceilf - </span><span class="s3">1</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s0"># i + 1 = 2*ip1div2 + ip1mod2</span>
        <span class="s1">ip1div2</span><span class="s2">, </span><span class="s1">ip1mod2 = divmod(i + </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">ip1mod2 == </span><span class="s3">0</span><span class="s1">:  </span><span class="s0"># i is odd</span>
            <span class="s2">if </span><span class="s1">ip1div2 == n + </span><span class="s3">1</span><span class="s1">:</span>
                <span class="s1">j1</span><span class="s2">, </span><span class="s1">j2 = n - ll - ceilf - </span><span class="s3">1</span><span class="s2">, </span><span class="s1">n + ll + ceilf - </span><span class="s3">1</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">j1</span><span class="s2">, </span><span class="s1">j2 = ip1div2 - </span><span class="s3">1 </span><span class="s1">- ll - roundf - </span><span class="s3">1</span><span class="s2">, </span><span class="s1">ip1div2 + ll - </span><span class="s3">1 </span><span class="s1">+ ceilf - </span><span class="s3">1</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">j1</span><span class="s2">, </span><span class="s1">j2 = ip1div2 - </span><span class="s3">1 </span><span class="s1">- ll - </span><span class="s3">1</span><span class="s2">, </span><span class="s1">ip1div2 + ll + roundf - </span><span class="s3">1</span>

    <span class="s2">return </span><span class="s1">max(j1 + </span><span class="s3">2</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">min(j2</span><span class="s2">, </span><span class="s1">n)</span>


<span class="s2">def </span><span class="s1">_kolmogn_Pomeranz(n</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">cdf=</span><span class="s2">True</span><span class="s1">):</span>
    <span class="s4">r&quot;&quot;&quot;Computes Pr(D_n &lt;= d) using the Pomeranz recursion algorithm. 
 
    Pomeranz (1974) [2] 
    &quot;&quot;&quot;</span>

    <span class="s0"># V is n*(2n+2) matrix.</span>
    <span class="s0"># Each row is convolution of the previous row and probabilities from a</span>
    <span class="s0">#  Poisson distribution.</span>
    <span class="s0"># Desired CDF probability is n! V[n-1, 2n+1]  (final entry in final row).</span>
    <span class="s0"># Only two rows are needed at any given stage:</span>
    <span class="s0">#  - Call them V0 and V1.</span>
    <span class="s0">#  - Swap each iteration</span>
    <span class="s0"># Only a few (contiguous) entries in each row can be non-zero.</span>
    <span class="s0">#  - Keep track of start and end (j1 and j2 below)</span>
    <span class="s0">#  - V0s and V1s track the start in the two rows</span>
    <span class="s0"># Scale intermediate results as needed.</span>
    <span class="s0"># Only a few different Poisson distributions can occur</span>
    <span class="s1">t = n * x</span>
    <span class="s1">ll = int(np.floor(t))</span>
    <span class="s1">f = </span><span class="s3">1.0 </span><span class="s1">* (t - ll)  </span><span class="s0"># fractional part of t</span>
    <span class="s1">g = min(f</span><span class="s2">, </span><span class="s3">1.0 </span><span class="s1">- f)</span>
    <span class="s1">ceilf = (</span><span class="s3">1 </span><span class="s2">if </span><span class="s1">f &gt; </span><span class="s3">0 </span><span class="s2">else </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">roundf = (</span><span class="s3">1 </span><span class="s2">if </span><span class="s1">f &gt; </span><span class="s3">0.5 </span><span class="s2">else </span><span class="s3">0</span><span class="s1">)</span>
    <span class="s1">npwrs = </span><span class="s3">2 </span><span class="s1">* (ll + </span><span class="s3">1</span><span class="s1">)    </span><span class="s0"># Maximum number of powers needed in convolutions</span>
    <span class="s1">gpower = np.empty(npwrs)  </span><span class="s0"># gpower = (g/n)^m/m!</span>
    <span class="s1">twogpower = np.empty(npwrs)  </span><span class="s0"># twogpower = (2g/n)^m/m!</span>
    <span class="s1">onem2gpower = np.empty(npwrs)  </span><span class="s0"># onem2gpower = ((1-2g)/n)^m/m!</span>
    <span class="s0"># gpower etc are *almost* Poisson probs, just missing normalizing factor.</span>

    <span class="s1">gpower[</span><span class="s3">0</span><span class="s1">] = </span><span class="s3">1.0</span>
    <span class="s1">twogpower[</span><span class="s3">0</span><span class="s1">] = </span><span class="s3">1.0</span>
    <span class="s1">onem2gpower[</span><span class="s3">0</span><span class="s1">] = </span><span class="s3">1.0</span>
    <span class="s1">expnt = </span><span class="s3">0</span>
    <span class="s1">g_over_n</span><span class="s2">, </span><span class="s1">two_g_over_n</span><span class="s2">, </span><span class="s1">one_minus_two_g_over_n = g/n</span><span class="s2">, </span><span class="s3">2</span><span class="s1">*g/n</span><span class="s2">, </span><span class="s1">(</span><span class="s3">1 </span><span class="s1">- </span><span class="s3">2</span><span class="s1">*g)/n</span>
    <span class="s2">for </span><span class="s1">m </span><span class="s2">in </span><span class="s1">range(</span><span class="s3">1</span><span class="s2">, </span><span class="s1">npwrs):</span>
        <span class="s1">gpower[m] = gpower[m - </span><span class="s3">1</span><span class="s1">] * g_over_n / m</span>
        <span class="s1">twogpower[m] = twogpower[m - </span><span class="s3">1</span><span class="s1">] * two_g_over_n / m</span>
        <span class="s1">onem2gpower[m] = onem2gpower[m - </span><span class="s3">1</span><span class="s1">] * one_minus_two_g_over_n / m</span>

    <span class="s1">V0 = np.zeros([npwrs])</span>
    <span class="s1">V1 = np.zeros([npwrs])</span>
    <span class="s1">V1[</span><span class="s3">0</span><span class="s1">] = </span><span class="s3">1  </span><span class="s0"># first row</span>
    <span class="s1">V0s</span><span class="s2">, </span><span class="s1">V1s = </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0  </span><span class="s0"># start indices of the two rows</span>

    <span class="s1">j1</span><span class="s2">, </span><span class="s1">j2 = _pomeranz_compute_j1j2(</span><span class="s3">0</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">ll</span><span class="s2">, </span><span class="s1">ceilf</span><span class="s2">, </span><span class="s1">roundf)</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2 </span><span class="s1">* n + </span><span class="s3">2</span><span class="s1">):</span>
        <span class="s0"># Preserve j1, V1, V1s, V0s from last iteration</span>
        <span class="s1">k1 = j1</span>
        <span class="s1">V0</span><span class="s2">, </span><span class="s1">V1 = V1</span><span class="s2">, </span><span class="s1">V0</span>
        <span class="s1">V0s</span><span class="s2">, </span><span class="s1">V1s = V1s</span><span class="s2">, </span><span class="s1">V0s</span>
        <span class="s1">V1.fill(</span><span class="s3">0.0</span><span class="s1">)</span>
        <span class="s1">j1</span><span class="s2">, </span><span class="s1">j2 = _pomeranz_compute_j1j2(i</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">ll</span><span class="s2">, </span><span class="s1">ceilf</span><span class="s2">, </span><span class="s1">roundf)</span>
        <span class="s2">if </span><span class="s1">i == </span><span class="s3">1 </span><span class="s2">or </span><span class="s1">i == </span><span class="s3">2 </span><span class="s1">* n + </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s1">pwrs = gpower</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">pwrs = (twogpower </span><span class="s2">if </span><span class="s1">i % </span><span class="s3">2 </span><span class="s2">else </span><span class="s1">onem2gpower)</span>
        <span class="s1">ln2 = j2 - k1 + </span><span class="s3">1</span>
        <span class="s2">if </span><span class="s1">ln2 &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">conv = np.convolve(V0[k1 - V0s:k1 - V0s + ln2]</span><span class="s2">, </span><span class="s1">pwrs[:ln2])</span>
            <span class="s1">conv_start = j1 - k1  </span><span class="s0"># First index to use from conv</span>
            <span class="s1">conv_len = j2 - j1 + </span><span class="s3">1  </span><span class="s0"># Number of entries to use from conv</span>
            <span class="s1">V1[:conv_len] = conv[conv_start:conv_start + conv_len]</span>
            <span class="s0"># Scale to avoid underflow.</span>
            <span class="s2">if </span><span class="s3">0 </span><span class="s1">&lt; np.max(V1) &lt; _EM128:</span>
                <span class="s1">V1 *= _EP128</span>
                <span class="s1">expnt -= _E128</span>
            <span class="s1">V1s = V0s + j1 - k1</span>

    <span class="s0"># multiply by n!</span>
    <span class="s1">ans = V1[n - V1s]</span>
    <span class="s2">for </span><span class="s1">m </span><span class="s2">in </span><span class="s1">range(</span><span class="s3">1</span><span class="s2">, </span><span class="s1">n + </span><span class="s3">1</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">np.abs(ans) &gt; _EP128:</span>
            <span class="s1">ans *= _EM128</span>
            <span class="s1">expnt += _E128</span>
        <span class="s1">ans *= m</span>

    <span class="s0"># Undo any intermediate scaling</span>
    <span class="s2">if </span><span class="s1">expnt != </span><span class="s3">0</span><span class="s1">:</span>
        <span class="s1">ans = np.ldexp(ans</span><span class="s2">, </span><span class="s1">expnt)</span>
    <span class="s1">ans = _select_and_clip_prob(ans</span><span class="s2">, </span><span class="s3">1.0 </span><span class="s1">- ans</span><span class="s2">, </span><span class="s1">cdf)</span>
    <span class="s2">return </span><span class="s1">ans</span>


<span class="s2">def </span><span class="s1">_kolmogn_PelzGood(n</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">cdf=</span><span class="s2">True</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot;Computes the Pelz-Good approximation to Prob(Dn &lt;= x) with 0&lt;=x&lt;=1. 
 
    Start with Li-Chien, Korolyuk approximation: 
        Prob(Dn &lt;= x) ~ K0(z) + K1(z)/sqrt(n) + K2(z)/n + K3(z)/n**1.5 
    where z = x*sqrt(n). 
    Transform each K_(z) using Jacobi theta functions into a form suitable 
    for small z. 
    Pelz-Good (1976). [6] 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">x &lt;= </span><span class="s3">0.0</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">_select_and_clip_prob(</span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">1.0</span><span class="s2">, </span><span class="s1">cdf=cdf)</span>
    <span class="s2">if </span><span class="s1">x &gt;= </span><span class="s3">1.0</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">_select_and_clip_prob(</span><span class="s3">1.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s2">, </span><span class="s1">cdf=cdf)</span>

    <span class="s1">z = np.sqrt(n) * x</span>
    <span class="s1">zsquared</span><span class="s2">, </span><span class="s1">zthree</span><span class="s2">, </span><span class="s1">zfour</span><span class="s2">, </span><span class="s1">zsix = z**</span><span class="s3">2</span><span class="s2">, </span><span class="s1">z**</span><span class="s3">3</span><span class="s2">, </span><span class="s1">z**</span><span class="s3">4</span><span class="s2">, </span><span class="s1">z**</span><span class="s3">6</span>

    <span class="s1">qlog = -_PI_SQUARED / </span><span class="s3">8 </span><span class="s1">/ zsquared</span>
    <span class="s2">if </span><span class="s1">qlog &lt; _MIN_LOG:  </span><span class="s0"># z ~ 0.041743441416853426</span>
        <span class="s2">return </span><span class="s1">_select_and_clip_prob(</span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">1.0</span><span class="s2">, </span><span class="s1">cdf=cdf)</span>

    <span class="s1">q = np.exp(qlog)</span>

    <span class="s0"># Coefficients of terms in the sums for K1, K2 and K3</span>
    <span class="s1">k1a = -zsquared</span>
    <span class="s1">k1b = _PI_SQUARED / </span><span class="s3">4</span>

    <span class="s1">k2a = </span><span class="s3">6 </span><span class="s1">* zsix + </span><span class="s3">2 </span><span class="s1">* zfour</span>
    <span class="s1">k2b = (</span><span class="s3">2 </span><span class="s1">* zfour - </span><span class="s3">5 </span><span class="s1">* zsquared) * _PI_SQUARED / </span><span class="s3">4</span>
    <span class="s1">k2c = _PI_FOUR * (</span><span class="s3">1 </span><span class="s1">- </span><span class="s3">2 </span><span class="s1">* zsquared) / </span><span class="s3">16</span>

    <span class="s1">k3d = _PI_SIX * (</span><span class="s3">5 </span><span class="s1">- </span><span class="s3">30 </span><span class="s1">* zsquared) / </span><span class="s3">64</span>
    <span class="s1">k3c = _PI_FOUR * (-</span><span class="s3">60 </span><span class="s1">* zsquared + </span><span class="s3">212 </span><span class="s1">* zfour) / </span><span class="s3">16</span>
    <span class="s1">k3b = _PI_SQUARED * (</span><span class="s3">135 </span><span class="s1">* zfour - </span><span class="s3">96 </span><span class="s1">* zsix) / </span><span class="s3">4</span>
    <span class="s1">k3a = -</span><span class="s3">30 </span><span class="s1">* zsix - </span><span class="s3">90 </span><span class="s1">* z**</span><span class="s3">8</span>

    <span class="s1">K0to3 = np.zeros(</span><span class="s3">4</span><span class="s1">)</span>
    <span class="s0"># Use a Horner scheme to evaluate sum c_i q^(i^2)</span>
    <span class="s0"># Reduces to a sum over odd integers.</span>
    <span class="s1">maxk = int(np.ceil(</span><span class="s3">16 </span><span class="s1">* z / np.pi))</span>
    <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range(maxk</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">):</span>
        <span class="s1">m = </span><span class="s3">2 </span><span class="s1">* k - </span><span class="s3">1</span>
        <span class="s1">msquared</span><span class="s2">, </span><span class="s1">mfour</span><span class="s2">, </span><span class="s1">msix = m**</span><span class="s3">2</span><span class="s2">, </span><span class="s1">m**</span><span class="s3">4</span><span class="s2">, </span><span class="s1">m**</span><span class="s3">6</span>
        <span class="s1">qpower = np.power(q</span><span class="s2">, </span><span class="s3">8 </span><span class="s1">* k)</span>
        <span class="s1">coeffs = np.array([</span><span class="s3">1.0</span><span class="s2">,</span>
                           <span class="s1">k1a + k1b*msquared</span><span class="s2">,</span>
                           <span class="s1">k2a + k2b*msquared + k2c*mfour</span><span class="s2">,</span>
                           <span class="s1">k3a + k3b*msquared + k3c*mfour + k3d*msix])</span>
        <span class="s1">K0to3 *= qpower</span>
        <span class="s1">K0to3 += coeffs</span>
    <span class="s1">K0to3 *= q</span>
    <span class="s1">K0to3 *= _SQRT2PI</span>
    <span class="s0"># z**10 &gt; 0 as z &gt; 0.04</span>
    <span class="s1">K0to3 /= np.array([z</span><span class="s2">, </span><span class="s3">6 </span><span class="s1">* zfour</span><span class="s2">, </span><span class="s3">72 </span><span class="s1">* z**</span><span class="s3">7</span><span class="s2">, </span><span class="s3">6480 </span><span class="s1">* z**</span><span class="s3">10</span><span class="s1">])</span>

    <span class="s0"># Now do the other sum over the other terms, all integers k</span>
    <span class="s0"># K_2:  (pi^2 k^2) q^(k^2),</span>
    <span class="s0"># K_3:  (3pi^2 k^2 z^2 - pi^4 k^4)*q^(k^2)</span>
    <span class="s0"># Don't expect much subtractive cancellation so use direct calculation</span>
    <span class="s1">q = np.exp(-_PI_SQUARED / </span><span class="s3">2 </span><span class="s1">/ zsquared)</span>
    <span class="s1">ks = np.arange(maxk</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">ksquared = ks ** </span><span class="s3">2</span>
    <span class="s1">sqrt3z = _SQRT3 * z</span>
    <span class="s1">kspi = np.pi * ks</span>
    <span class="s1">qpwers = q ** ksquared</span>
    <span class="s1">k2extra = np.sum(ksquared * qpwers)</span>
    <span class="s1">k2extra *= _PI_SQUARED * _SQRT2PI/(-</span><span class="s3">36 </span><span class="s1">* zthree)</span>
    <span class="s1">K0to3[</span><span class="s3">2</span><span class="s1">] += k2extra</span>
    <span class="s1">k3extra = np.sum((sqrt3z + kspi) * (sqrt3z - kspi) * ksquared * qpwers)</span>
    <span class="s1">k3extra *= _PI_SQUARED * _SQRT2PI/(</span><span class="s3">216 </span><span class="s1">* zsix)</span>
    <span class="s1">K0to3[</span><span class="s3">3</span><span class="s1">] += k3extra</span>
    <span class="s1">powers_of_n = np.power(n * </span><span class="s3">1.0</span><span class="s2">, </span><span class="s1">np.arange(len(K0to3)) / </span><span class="s3">2.0</span><span class="s1">)</span>
    <span class="s1">K0to3 /= powers_of_n</span>

    <span class="s2">if not </span><span class="s1">cdf:</span>
        <span class="s1">K0to3 *= -</span><span class="s3">1</span>
        <span class="s1">K0to3[</span><span class="s3">0</span><span class="s1">] += </span><span class="s3">1</span>

    <span class="s1">Ksum = sum(K0to3)</span>
    <span class="s2">return </span><span class="s1">Ksum</span>


<span class="s2">def </span><span class="s1">_kolmogn(n</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">cdf=</span><span class="s2">True</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot;Computes the CDF(or SF) for the two-sided Kolmogorov-Smirnov statistic. 
 
    x must be of type float, n of type integer. 
 
    Simard &amp; L'Ecuyer (2011) [7]. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">np.isnan(n):</span>
        <span class="s2">return </span><span class="s1">n  </span><span class="s0"># Keep the same type of nan</span>
    <span class="s2">if </span><span class="s1">int(n) != n </span><span class="s2">or </span><span class="s1">n &lt;= </span><span class="s3">0</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">np.nan</span>
    <span class="s2">if </span><span class="s1">x &gt;= </span><span class="s3">1.0</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">_select_and_clip_prob(</span><span class="s3">1.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s2">, </span><span class="s1">cdf=cdf)</span>
    <span class="s2">if </span><span class="s1">x &lt;= </span><span class="s3">0.0</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">_select_and_clip_prob(</span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">1.0</span><span class="s2">, </span><span class="s1">cdf=cdf)</span>
    <span class="s1">t = n * x</span>
    <span class="s2">if </span><span class="s1">t &lt;= </span><span class="s3">1.0</span><span class="s1">:  </span><span class="s0"># Ruben-Gambino: 1/2n &lt;= x &lt;= 1/n</span>
        <span class="s2">if </span><span class="s1">t &lt;= </span><span class="s3">0.5</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">_select_and_clip_prob(</span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">1.0</span><span class="s2">, </span><span class="s1">cdf=cdf)</span>
        <span class="s2">if </span><span class="s1">n &lt;= </span><span class="s3">140</span><span class="s1">:</span>
            <span class="s1">prob = np.prod(np.arange(</span><span class="s3">1</span><span class="s2">, </span><span class="s1">n+</span><span class="s3">1</span><span class="s1">) * (</span><span class="s3">1.0</span><span class="s1">/n) * (</span><span class="s3">2</span><span class="s1">*t - </span><span class="s3">1</span><span class="s1">))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">prob = np.exp(_log_nfactorial_div_n_pow_n(n) + n * np.log(</span><span class="s3">2</span><span class="s1">*t-</span><span class="s3">1</span><span class="s1">))</span>
        <span class="s2">return </span><span class="s1">_select_and_clip_prob(prob</span><span class="s2">, </span><span class="s3">1.0 </span><span class="s1">- prob</span><span class="s2">, </span><span class="s1">cdf=cdf)</span>
    <span class="s2">if </span><span class="s1">t &gt;= n - </span><span class="s3">1</span><span class="s1">:  </span><span class="s0"># Ruben-Gambino</span>
        <span class="s1">prob = </span><span class="s3">2 </span><span class="s1">* (</span><span class="s3">1.0 </span><span class="s1">- x)**n</span>
        <span class="s2">return </span><span class="s1">_select_and_clip_prob(</span><span class="s3">1 </span><span class="s1">- prob</span><span class="s2">, </span><span class="s1">prob</span><span class="s2">, </span><span class="s1">cdf=cdf)</span>
    <span class="s2">if </span><span class="s1">x &gt;= </span><span class="s3">0.5</span><span class="s1">:  </span><span class="s0"># Exact: 2 * smirnov</span>
        <span class="s1">prob = </span><span class="s3">2 </span><span class="s1">* scipy.special.smirnov(n</span><span class="s2">, </span><span class="s1">x)</span>
        <span class="s2">return </span><span class="s1">_select_and_clip_prob(</span><span class="s3">1.0 </span><span class="s1">- prob</span><span class="s2">, </span><span class="s1">prob</span><span class="s2">, </span><span class="s1">cdf=cdf)</span>

    <span class="s1">nxsquared = t * x</span>
    <span class="s2">if </span><span class="s1">n &lt;= </span><span class="s3">140</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">nxsquared &lt;= </span><span class="s3">0.754693</span><span class="s1">:</span>
            <span class="s1">prob = _kolmogn_DMTW(n</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">cdf=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">_select_and_clip_prob(prob</span><span class="s2">, </span><span class="s3">1.0 </span><span class="s1">- prob</span><span class="s2">, </span><span class="s1">cdf=cdf)</span>
        <span class="s2">if </span><span class="s1">nxsquared &lt;= </span><span class="s3">4</span><span class="s1">:</span>
            <span class="s1">prob = _kolmogn_Pomeranz(n</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">cdf=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">_select_and_clip_prob(prob</span><span class="s2">, </span><span class="s3">1.0 </span><span class="s1">- prob</span><span class="s2">, </span><span class="s1">cdf=cdf)</span>
        <span class="s0"># Now use Miller approximation of 2*smirnov</span>
        <span class="s1">prob = </span><span class="s3">2 </span><span class="s1">* scipy.special.smirnov(n</span><span class="s2">, </span><span class="s1">x)</span>
        <span class="s2">return </span><span class="s1">_select_and_clip_prob(</span><span class="s3">1.0 </span><span class="s1">- prob</span><span class="s2">, </span><span class="s1">prob</span><span class="s2">, </span><span class="s1">cdf=cdf)</span>

    <span class="s0"># Split CDF and SF as they have different cutoffs on nxsquared.</span>
    <span class="s2">if not </span><span class="s1">cdf:</span>
        <span class="s2">if </span><span class="s1">nxsquared &gt;= </span><span class="s3">370.0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s3">0.0</span>
        <span class="s2">if </span><span class="s1">nxsquared &gt;= </span><span class="s3">2.2</span><span class="s1">:</span>
            <span class="s1">prob = </span><span class="s3">2 </span><span class="s1">* scipy.special.smirnov(n</span><span class="s2">, </span><span class="s1">x)</span>
            <span class="s2">return </span><span class="s1">_clip_prob(prob)</span>
        <span class="s0"># Fall through and compute the SF as 1.0-CDF</span>
    <span class="s2">if </span><span class="s1">nxsquared &gt;= </span><span class="s3">18.0</span><span class="s1">:</span>
        <span class="s1">cdfprob = </span><span class="s3">1.0</span>
    <span class="s2">elif </span><span class="s1">n &lt;= </span><span class="s3">100000 </span><span class="s2">and </span><span class="s1">n * x**</span><span class="s3">1.5 </span><span class="s1">&lt;= </span><span class="s3">1.4</span><span class="s1">:</span>
        <span class="s1">cdfprob = _kolmogn_DMTW(n</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">cdf=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">cdfprob = _kolmogn_PelzGood(n</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">cdf=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">_select_and_clip_prob(cdfprob</span><span class="s2">, </span><span class="s3">1.0 </span><span class="s1">- cdfprob</span><span class="s2">, </span><span class="s1">cdf=cdf)</span>


<span class="s2">def </span><span class="s1">_kolmogn_p(n</span><span class="s2">, </span><span class="s1">x):</span>
    <span class="s4">&quot;&quot;&quot;Computes the PDF for the two-sided Kolmogorov-Smirnov statistic. 
 
    x must be of type float, n of type integer. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">np.isnan(n):</span>
        <span class="s2">return </span><span class="s1">n  </span><span class="s0"># Keep the same type of nan</span>
    <span class="s2">if </span><span class="s1">int(n) != n </span><span class="s2">or </span><span class="s1">n &lt;= </span><span class="s3">0</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">np.nan</span>
    <span class="s2">if </span><span class="s1">x &gt;= </span><span class="s3">1.0 </span><span class="s2">or </span><span class="s1">x &lt;= </span><span class="s3">0</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s3">0</span>
    <span class="s1">t = n * x</span>
    <span class="s2">if </span><span class="s1">t &lt;= </span><span class="s3">1.0</span><span class="s1">:</span>
        <span class="s0"># Ruben-Gambino: n!/n^n * (2t-1)^n -&gt; 2 n!/n^n * n^2 * (2t-1)^(n-1)</span>
        <span class="s2">if </span><span class="s1">t &lt;= </span><span class="s3">0.5</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s3">0.0</span>
        <span class="s2">if </span><span class="s1">n &lt;= </span><span class="s3">140</span><span class="s1">:</span>
            <span class="s1">prd = np.prod(np.arange(</span><span class="s3">1</span><span class="s2">, </span><span class="s1">n) * (</span><span class="s3">1.0 </span><span class="s1">/ n) * (</span><span class="s3">2 </span><span class="s1">* t - </span><span class="s3">1</span><span class="s1">))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">prd = np.exp(_log_nfactorial_div_n_pow_n(n) + (n-</span><span class="s3">1</span><span class="s1">) * np.log(</span><span class="s3">2 </span><span class="s1">* t - </span><span class="s3">1</span><span class="s1">))</span>
        <span class="s2">return </span><span class="s1">prd * </span><span class="s3">2 </span><span class="s1">* n**</span><span class="s3">2</span>
    <span class="s2">if </span><span class="s1">t &gt;= n - </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s0"># Ruben-Gambino : 1-2(1-x)**n -&gt; 2n*(1-x)**(n-1)</span>
        <span class="s2">return </span><span class="s3">2 </span><span class="s1">* (</span><span class="s3">1.0 </span><span class="s1">- x) ** (n-</span><span class="s3">1</span><span class="s1">) * n</span>
    <span class="s2">if </span><span class="s1">x &gt;= </span><span class="s3">0.5</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s3">2 </span><span class="s1">* scipy.stats.ksone.pdf(x</span><span class="s2">, </span><span class="s1">n)</span>

    <span class="s0"># Just take a small delta.</span>
    <span class="s0"># Ideally x +/- delta would stay within [i/n, (i+1)/n] for some integer a.</span>
    <span class="s0"># as the CDF is a piecewise degree n polynomial.</span>
    <span class="s0"># It has knots at 1/n, 2/n, ... (n-1)/n</span>
    <span class="s0"># and is not a C-infinity function at the knots</span>
    <span class="s1">delta = x / </span><span class="s3">2.0</span><span class="s1">**</span><span class="s3">16</span>
    <span class="s1">delta = min(delta</span><span class="s2">, </span><span class="s1">x - </span><span class="s3">1.0</span><span class="s1">/n)</span>
    <span class="s1">delta = min(delta</span><span class="s2">, </span><span class="s3">0.5 </span><span class="s1">- x)</span>

    <span class="s2">def </span><span class="s1">_kk(_x):</span>
        <span class="s2">return </span><span class="s1">kolmogn(n</span><span class="s2">, </span><span class="s1">_x)</span>

    <span class="s2">return </span><span class="s1">_derivative(_kk</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">dx=delta</span><span class="s2">, </span><span class="s1">order=</span><span class="s3">5</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">_kolmogni(n</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">q):</span>
    <span class="s4">&quot;&quot;&quot;Computes the PPF/ISF of kolmogn. 
 
    n of type integer, n&gt;= 1 
    p is the CDF, q the SF, p+q=1 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">np.isnan(n):</span>
        <span class="s2">return </span><span class="s1">n  </span><span class="s0"># Keep the same type of nan</span>
    <span class="s2">if </span><span class="s1">int(n) != n </span><span class="s2">or </span><span class="s1">n &lt;= </span><span class="s3">0</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">np.nan</span>
    <span class="s2">if </span><span class="s1">p &lt;= </span><span class="s3">0</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s3">1.0</span><span class="s1">/n</span>
    <span class="s2">if </span><span class="s1">q &lt;= </span><span class="s3">0</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s3">1.0</span>
    <span class="s1">delta = np.exp((np.log(p) - scipy.special.loggamma(n+</span><span class="s3">1</span><span class="s1">))/n)</span>
    <span class="s2">if </span><span class="s1">delta &lt;= </span><span class="s3">1.0</span><span class="s1">/n:</span>
        <span class="s2">return </span><span class="s1">(delta + </span><span class="s3">1.0 </span><span class="s1">/ n) / </span><span class="s3">2</span>
    <span class="s1">x = -np.expm1(np.log(q/</span><span class="s3">2.0</span><span class="s1">)/n)</span>
    <span class="s2">if </span><span class="s1">x &gt;= </span><span class="s3">1 </span><span class="s1">- </span><span class="s3">1.0</span><span class="s1">/n:</span>
        <span class="s2">return </span><span class="s1">x</span>
    <span class="s1">x1 = scu._kolmogci(p)/np.sqrt(n)</span>
    <span class="s1">x1 = min(x1</span><span class="s2">, </span><span class="s3">1.0 </span><span class="s1">- </span><span class="s3">1.0</span><span class="s1">/n)</span>

    <span class="s2">def </span><span class="s1">_f(x):</span>
        <span class="s2">return </span><span class="s1">_kolmogn(n</span><span class="s2">, </span><span class="s1">x) - p</span>

    <span class="s2">return </span><span class="s1">scipy.optimize.brentq(_f</span><span class="s2">, </span><span class="s3">1.0</span><span class="s1">/n</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">xtol=</span><span class="s3">1e-14</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">kolmogn(n</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">cdf=</span><span class="s2">True</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot;Computes the CDF for the two-sided Kolmogorov-Smirnov distribution. 
 
    The two-sided Kolmogorov-Smirnov distribution has as its CDF Pr(D_n &lt;= x), 
    for a sample of size n drawn from a distribution with CDF F(t), where 
    D_n &amp;= sup_t |F_n(t) - F(t)|, and 
    F_n(t) is the Empirical Cumulative Distribution Function of the sample. 
 
    Parameters 
    ---------- 
    n : integer, array_like 
        the number of samples 
    x : float, array_like 
        The K-S statistic, float between 0 and 1 
    cdf : bool, optional 
        whether to compute the CDF(default=true) or the SF. 
 
    Returns 
    ------- 
    cdf : ndarray 
        CDF (or SF it cdf is False) at the specified locations. 
 
    The return value has shape the result of numpy broadcasting n and x. 
    &quot;&quot;&quot;</span>
    <span class="s1">it = np.nditer([n</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">cdf</span><span class="s2">, None</span><span class="s1">]</span><span class="s2">,</span>
                   <span class="s1">op_dtypes=[</span><span class="s2">None, </span><span class="s1">np.float64</span><span class="s2">, </span><span class="s1">np.bool_</span><span class="s2">, </span><span class="s1">np.float64])</span>
    <span class="s2">for </span><span class="s1">_n</span><span class="s2">, </span><span class="s1">_x</span><span class="s2">, </span><span class="s1">_cdf</span><span class="s2">, </span><span class="s1">z </span><span class="s2">in </span><span class="s1">it:</span>
        <span class="s2">if </span><span class="s1">np.isnan(_n):</span>
            <span class="s1">z[...] = _n</span>
            <span class="s2">continue</span>
        <span class="s2">if </span><span class="s1">int(_n) != _n:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">f'n is not integral: </span><span class="s2">{</span><span class="s1">_n</span><span class="s2">}</span><span class="s5">'</span><span class="s1">)</span>
        <span class="s1">z[...] = _kolmogn(int(_n)</span><span class="s2">, </span><span class="s1">_x</span><span class="s2">, </span><span class="s1">cdf=_cdf)</span>
    <span class="s1">result = it.operands[-</span><span class="s3">1</span><span class="s1">]</span>
    <span class="s2">return </span><span class="s1">result</span>


<span class="s2">def </span><span class="s1">kolmognp(n</span><span class="s2">, </span><span class="s1">x):</span>
    <span class="s4">&quot;&quot;&quot;Computes the PDF for the two-sided Kolmogorov-Smirnov distribution. 
 
    Parameters 
    ---------- 
    n : integer, array_like 
        the number of samples 
    x : float, array_like 
        The K-S statistic, float between 0 and 1 
 
    Returns 
    ------- 
    pdf : ndarray 
        The PDF at the specified locations 
 
    The return value has shape the result of numpy broadcasting n and x. 
    &quot;&quot;&quot;</span>
    <span class="s1">it = np.nditer([n</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, None</span><span class="s1">])</span>
    <span class="s2">for </span><span class="s1">_n</span><span class="s2">, </span><span class="s1">_x</span><span class="s2">, </span><span class="s1">z </span><span class="s2">in </span><span class="s1">it:</span>
        <span class="s2">if </span><span class="s1">np.isnan(_n):</span>
            <span class="s1">z[...] = _n</span>
            <span class="s2">continue</span>
        <span class="s2">if </span><span class="s1">int(_n) != _n:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">f'n is not integral: </span><span class="s2">{</span><span class="s1">_n</span><span class="s2">}</span><span class="s5">'</span><span class="s1">)</span>
        <span class="s1">z[...] = _kolmogn_p(int(_n)</span><span class="s2">, </span><span class="s1">_x)</span>
    <span class="s1">result = it.operands[-</span><span class="s3">1</span><span class="s1">]</span>
    <span class="s2">return </span><span class="s1">result</span>


<span class="s2">def </span><span class="s1">kolmogni(n</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">cdf=</span><span class="s2">True</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot;Computes the PPF(or ISF) for the two-sided Kolmogorov-Smirnov distribution. 
 
    Parameters 
    ---------- 
    n : integer, array_like 
        the number of samples 
    q : float, array_like 
        Probabilities, float between 0 and 1 
    cdf : bool, optional 
        whether to compute the PPF(default=true) or the ISF. 
 
    Returns 
    ------- 
    ppf : ndarray 
        PPF (or ISF if cdf is False) at the specified locations 
 
    The return value has shape the result of numpy broadcasting n and x. 
    &quot;&quot;&quot;</span>
    <span class="s1">it = np.nditer([n</span><span class="s2">, </span><span class="s1">q</span><span class="s2">, </span><span class="s1">cdf</span><span class="s2">, None</span><span class="s1">])</span>
    <span class="s2">for </span><span class="s1">_n</span><span class="s2">, </span><span class="s1">_q</span><span class="s2">, </span><span class="s1">_cdf</span><span class="s2">, </span><span class="s1">z </span><span class="s2">in </span><span class="s1">it:</span>
        <span class="s2">if </span><span class="s1">np.isnan(_n):</span>
            <span class="s1">z[...] = _n</span>
            <span class="s2">continue</span>
        <span class="s2">if </span><span class="s1">int(_n) != _n:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">f'n is not integral: </span><span class="s2">{</span><span class="s1">_n</span><span class="s2">}</span><span class="s5">'</span><span class="s1">)</span>
        <span class="s1">_pcdf</span><span class="s2">, </span><span class="s1">_psf = (_q</span><span class="s2">, </span><span class="s3">1</span><span class="s1">-_q) </span><span class="s2">if </span><span class="s1">_cdf </span><span class="s2">else </span><span class="s1">(</span><span class="s3">1</span><span class="s1">-_q</span><span class="s2">, </span><span class="s1">_q)</span>
        <span class="s1">z[...] = _kolmogni(int(_n)</span><span class="s2">, </span><span class="s1">_pcdf</span><span class="s2">, </span><span class="s1">_psf)</span>
    <span class="s1">result = it.operands[-</span><span class="s3">1</span><span class="s1">]</span>
    <span class="s2">return </span><span class="s1">result</span>
</pre>
</body>
</html>