<html>
<head>
<title>multivariate_ols.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
multivariate_ols.py</font>
</center></td></tr></table>
<pre><span class="s0"># -*- coding: utf-8 -*-</span>

<span class="s2">&quot;&quot;&quot;General linear model 
 
author: Yichuan Liu 
&quot;&quot;&quot;</span>
<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">from </span><span class="s1">numpy.linalg </span><span class="s3">import </span><span class="s1">eigvals</span><span class="s3">, </span><span class="s1">inv</span><span class="s3">, </span><span class="s1">solve</span><span class="s3">, </span><span class="s1">matrix_rank</span><span class="s3">, </span><span class="s1">pinv</span><span class="s3">, </span><span class="s1">svd</span>
<span class="s3">from </span><span class="s1">scipy </span><span class="s3">import </span><span class="s1">stats</span>
<span class="s3">import </span><span class="s1">pandas </span><span class="s3">as </span><span class="s1">pd</span>
<span class="s3">from </span><span class="s1">patsy </span><span class="s3">import </span><span class="s1">DesignInfo</span>

<span class="s3">from </span><span class="s1">statsmodels.compat.pandas </span><span class="s3">import </span><span class="s1">Substitution</span>
<span class="s3">from </span><span class="s1">statsmodels.base.model </span><span class="s3">import </span><span class="s1">Model</span>
<span class="s3">from </span><span class="s1">statsmodels.iolib </span><span class="s3">import </span><span class="s1">summary2</span>
<span class="s1">__docformat__ = </span><span class="s4">'restructuredtext en'</span>

<span class="s1">_hypotheses_doc = \</span>
<span class="s4">&quot;&quot;&quot;hypotheses : list[tuple] 
    Hypothesis `L*B*M = C` to be tested where B is the parameters in 
    regression Y = X*B. Each element is a tuple of length 2, 3, or 4: 
 
      * (name, contrast_L) 
      * (name, contrast_L, transform_M) 
      * (name, contrast_L, transform_M, constant_C) 
 
    containing a string `name`, the contrast matrix L, the transform 
    matrix M (for transforming dependent variables), and right-hand side 
    constant matrix constant_C, respectively. 
 
    contrast_L : 2D array or an array of strings 
        Left-hand side contrast matrix for hypotheses testing. 
        If 2D array, each row is an hypotheses and each column is an 
        independent variable. At least 1 row 
        (1 by k_exog, the number of independent variables) is required. 
        If an array of strings, it will be passed to 
        patsy.DesignInfo().linear_constraint. 
 
    transform_M : 2D array or an array of strings or None, optional 
        Left hand side transform matrix. 
        If `None` or left out, it is set to a k_endog by k_endog 
        identity matrix (i.e. do not transform y matrix). 
        If an array of strings, it will be passed to 
        patsy.DesignInfo().linear_constraint. 
 
    constant_C : 2D array or None, optional 
        Right-hand side constant matrix. 
        if `None` or left out it is set to a matrix of zeros 
        Must has the same number of rows as contrast_L and the same 
        number of columns as transform_M 
 
    If `hypotheses` is None: 1) the effect of each independent variable 
    on the dependent variables will be tested. Or 2) if model is created 
    using a formula,  `hypotheses` will be created according to 
    `design_info`. 1) and 2) is equivalent if no additional variables 
    are created by the formula (e.g. dummy variables for categorical 
    variables and interaction terms) 
&quot;&quot;&quot;</span>


<span class="s3">def </span><span class="s1">_multivariate_ols_fit(endog</span><span class="s3">, </span><span class="s1">exog</span><span class="s3">, </span><span class="s1">method=</span><span class="s4">'svd'</span><span class="s3">, </span><span class="s1">tolerance=</span><span class="s5">1e-8</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    Solve multivariate linear model y = x * params 
    where y is dependent variables, x is independent variables 
 
    Parameters 
    ---------- 
    endog : array_like 
        each column is a dependent variable 
    exog : array_like 
        each column is a independent variable 
    method : str 
        'svd' - Singular value decomposition 
        'pinv' - Moore-Penrose pseudoinverse 
    tolerance : float, a small positive number 
        Tolerance for eigenvalue. Values smaller than tolerance is considered 
        zero. 
    Returns 
    ------- 
    a tuple of matrices or values necessary for hypotheses testing 
 
    .. [*] https://support.sas.com/documentation/cdl/en/statug/63033/HTML/default/viewer.htm#statug_introreg_sect012.htm 
    Notes 
    ----- 
    Status: experimental and incomplete 
    &quot;&quot;&quot;</span>
    <span class="s1">y = endog</span>
    <span class="s1">x = exog</span>
    <span class="s1">nobs</span><span class="s3">, </span><span class="s1">k_endog = y.shape</span>
    <span class="s1">nobs1</span><span class="s3">, </span><span class="s1">k_exog= x.shape</span>
    <span class="s3">if </span><span class="s1">nobs != nobs1:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'x(n=%d) and y(n=%d) should have the same number of '</span>
                         <span class="s4">'rows!' </span><span class="s1">% (nobs1</span><span class="s3">, </span><span class="s1">nobs))</span>

    <span class="s0"># Calculate the matrices necessary for hypotheses testing</span>
    <span class="s1">df_resid = nobs - k_exog</span>
    <span class="s3">if </span><span class="s1">method == </span><span class="s4">'pinv'</span><span class="s1">:</span>
        <span class="s0"># Regression coefficients matrix</span>
        <span class="s1">pinv_x = pinv(x)</span>
        <span class="s1">params = pinv_x.dot(y)</span>

        <span class="s0"># inverse of x'x</span>
        <span class="s1">inv_cov = pinv_x.dot(pinv_x.T)</span>
        <span class="s3">if </span><span class="s1">matrix_rank(inv_cov</span><span class="s3">,</span><span class="s1">tol=tolerance) &lt; k_exog:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'Covariance of x singular!'</span><span class="s1">)</span>

        <span class="s0"># Sums of squares and cross-products of residuals</span>
        <span class="s0"># Y'Y - (X * params)'B * params</span>
        <span class="s1">t = x.dot(params)</span>
        <span class="s1">sscpr = np.subtract(y.T.dot(y)</span><span class="s3">, </span><span class="s1">t.T.dot(t))</span>
        <span class="s3">return </span><span class="s1">(params</span><span class="s3">, </span><span class="s1">df_resid</span><span class="s3">, </span><span class="s1">inv_cov</span><span class="s3">, </span><span class="s1">sscpr)</span>
    <span class="s3">elif </span><span class="s1">method == </span><span class="s4">'svd'</span><span class="s1">:</span>
        <span class="s1">u</span><span class="s3">, </span><span class="s1">s</span><span class="s3">, </span><span class="s1">v = svd(x</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">(s &gt; tolerance).sum() &lt; len(s):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'Covariance of x singular!'</span><span class="s1">)</span>
        <span class="s1">invs = </span><span class="s5">1. </span><span class="s1">/ s</span>

        <span class="s1">params = v.T.dot(np.diag(invs)).dot(u.T).dot(y)</span>
        <span class="s1">inv_cov = v.T.dot(np.diag(np.power(invs</span><span class="s3">, </span><span class="s5">2</span><span class="s1">))).dot(v)</span>
        <span class="s1">t = np.diag(s).dot(v).dot(params)</span>
        <span class="s1">sscpr = np.subtract(y.T.dot(y)</span><span class="s3">, </span><span class="s1">t.T.dot(t))</span>
        <span class="s3">return </span><span class="s1">(params</span><span class="s3">, </span><span class="s1">df_resid</span><span class="s3">, </span><span class="s1">inv_cov</span><span class="s3">, </span><span class="s1">sscpr)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'%s is not a supported method!' </span><span class="s1">% method)</span>


<span class="s3">def </span><span class="s1">multivariate_stats(eigenvals</span><span class="s3">,</span>
                       <span class="s1">r_err_sscp</span><span class="s3">,</span>
                       <span class="s1">r_contrast</span><span class="s3">, </span><span class="s1">df_resid</span><span class="s3">, </span><span class="s1">tolerance=</span><span class="s5">1e-8</span><span class="s1">):</span>
    <span class="s2">&quot;&quot;&quot; 
    For multivariate linear model Y = X * B 
    Testing hypotheses 
        L*B*M = 0 
    where L is contrast matrix, B is the parameters of the 
    multivariate linear model and M is dependent variable transform matrix. 
        T = L*inv(X'X)*L' 
        H = M'B'L'*inv(T)*LBM 
        E =  M'(Y'Y - B'X'XB)M 
 
    Parameters 
    ---------- 
    eigenvals : ndarray 
        The eigenvalues of inv(E + H)*H 
    r_err_sscp : int 
        Rank of E + H 
    r_contrast : int 
        Rank of T matrix 
    df_resid : int 
        Residual degree of freedom (n_samples minus n_variables of X) 
    tolerance : float 
        smaller than which eigenvalue is considered 0 
 
    Returns 
    ------- 
    A DataFrame 
 
    References 
    ---------- 
    .. [*] https://support.sas.com/documentation/cdl/en/statug/63033/HTML/default/viewer.htm#statug_introreg_sect012.htm 
    &quot;&quot;&quot;</span>
    <span class="s1">v = df_resid</span>
    <span class="s1">p = r_err_sscp</span>
    <span class="s1">q = r_contrast</span>
    <span class="s1">s = np.min([p</span><span class="s3">, </span><span class="s1">q])</span>
    <span class="s1">ind = eigenvals &gt; tolerance</span>
    <span class="s1">n_e = ind.sum()</span>
    <span class="s1">eigv2 = eigenvals[ind]</span>
    <span class="s1">eigv1 = np.array([i / (</span><span class="s5">1 </span><span class="s1">- i) </span><span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">eigv2])</span>
    <span class="s1">m = (np.abs(p - q) - </span><span class="s5">1</span><span class="s1">) / </span><span class="s5">2</span>
    <span class="s1">n = (v - p - </span><span class="s5">1</span><span class="s1">) / </span><span class="s5">2</span>

    <span class="s1">cols = [</span><span class="s4">'Value'</span><span class="s3">, </span><span class="s4">'Num DF'</span><span class="s3">, </span><span class="s4">'Den DF'</span><span class="s3">, </span><span class="s4">'F Value'</span><span class="s3">, </span><span class="s4">'Pr &gt; F'</span><span class="s1">]</span>
    <span class="s1">index = [</span><span class="s4">&quot;Wilks' lambda&quot;</span><span class="s3">, </span><span class="s4">&quot;Pillai's trace&quot;</span><span class="s3">,</span>
             <span class="s4">&quot;Hotelling-Lawley trace&quot;</span><span class="s3">, </span><span class="s4">&quot;Roy's greatest root&quot;</span><span class="s1">]</span>
    <span class="s1">results = pd.DataFrame(columns=cols</span><span class="s3">,</span>
                           <span class="s1">index=index)</span>

    <span class="s3">def </span><span class="s1">fn(x):</span>
        <span class="s3">return </span><span class="s1">np.real([x])[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s1">results.loc[</span><span class="s4">&quot;Wilks' lambda&quot;</span><span class="s3">, </span><span class="s4">'Value'</span><span class="s1">] = fn(np.prod(</span><span class="s5">1 </span><span class="s1">- eigv2))</span>

    <span class="s1">results.loc[</span><span class="s4">&quot;Pillai's trace&quot;</span><span class="s3">, </span><span class="s4">'Value'</span><span class="s1">] = fn(eigv2.sum())</span>

    <span class="s1">results.loc[</span><span class="s4">&quot;Hotelling-Lawley trace&quot;</span><span class="s3">, </span><span class="s4">'Value'</span><span class="s1">] = fn(eigv1.sum())</span>

    <span class="s1">results.loc[</span><span class="s4">&quot;Roy's greatest root&quot;</span><span class="s3">, </span><span class="s4">'Value'</span><span class="s1">] = fn(eigv1.max())</span>

    <span class="s1">r = v - (p - q + </span><span class="s5">1</span><span class="s1">)/</span><span class="s5">2</span>
    <span class="s1">u = (p*q - </span><span class="s5">2</span><span class="s1">) / </span><span class="s5">4</span>
    <span class="s1">df1 = p * q</span>
    <span class="s3">if </span><span class="s1">p*p + q*q - </span><span class="s5">5 </span><span class="s1">&gt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">t = np.sqrt((p*p*q*q - </span><span class="s5">4</span><span class="s1">) / (p*p + q*q - </span><span class="s5">5</span><span class="s1">))</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">t = </span><span class="s5">1</span>
    <span class="s1">df2 = r*t - </span><span class="s5">2</span><span class="s1">*u</span>
    <span class="s1">lmd = results.loc[</span><span class="s4">&quot;Wilks' lambda&quot;</span><span class="s3">, </span><span class="s4">'Value'</span><span class="s1">]</span>
    <span class="s1">lmd = np.power(lmd</span><span class="s3">, </span><span class="s5">1 </span><span class="s1">/ t)</span>
    <span class="s1">F = (</span><span class="s5">1 </span><span class="s1">- lmd) / lmd * df2 / df1</span>
    <span class="s1">results.loc[</span><span class="s4">&quot;Wilks' lambda&quot;</span><span class="s3">, </span><span class="s4">'Num DF'</span><span class="s1">] = df1</span>
    <span class="s1">results.loc[</span><span class="s4">&quot;Wilks' lambda&quot;</span><span class="s3">, </span><span class="s4">'Den DF'</span><span class="s1">] = df2</span>
    <span class="s1">results.loc[</span><span class="s4">&quot;Wilks' lambda&quot;</span><span class="s3">, </span><span class="s4">'F Value'</span><span class="s1">] = F</span>
    <span class="s1">pval = stats.f.sf(F</span><span class="s3">, </span><span class="s1">df1</span><span class="s3">, </span><span class="s1">df2)</span>
    <span class="s1">results.loc[</span><span class="s4">&quot;Wilks' lambda&quot;</span><span class="s3">, </span><span class="s4">'Pr &gt; F'</span><span class="s1">] = pval</span>

    <span class="s1">V = results.loc[</span><span class="s4">&quot;Pillai's trace&quot;</span><span class="s3">, </span><span class="s4">'Value'</span><span class="s1">]</span>
    <span class="s1">df1 = s * (</span><span class="s5">2</span><span class="s1">*m + s + </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">df2 = s * (</span><span class="s5">2</span><span class="s1">*n + s + </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">F = df2 / df1 * V / (s - V)</span>
    <span class="s1">results.loc[</span><span class="s4">&quot;Pillai's trace&quot;</span><span class="s3">, </span><span class="s4">'Num DF'</span><span class="s1">] = df1</span>
    <span class="s1">results.loc[</span><span class="s4">&quot;Pillai's trace&quot;</span><span class="s3">, </span><span class="s4">'Den DF'</span><span class="s1">] = df2</span>
    <span class="s1">results.loc[</span><span class="s4">&quot;Pillai's trace&quot;</span><span class="s3">, </span><span class="s4">'F Value'</span><span class="s1">] = F</span>
    <span class="s1">pval = stats.f.sf(F</span><span class="s3">, </span><span class="s1">df1</span><span class="s3">, </span><span class="s1">df2)</span>
    <span class="s1">results.loc[</span><span class="s4">&quot;Pillai's trace&quot;</span><span class="s3">, </span><span class="s4">'Pr &gt; F'</span><span class="s1">] = pval</span>

    <span class="s1">U = results.loc[</span><span class="s4">&quot;Hotelling-Lawley trace&quot;</span><span class="s3">, </span><span class="s4">'Value'</span><span class="s1">]</span>
    <span class="s3">if </span><span class="s1">n &gt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">b = (p + </span><span class="s5">2</span><span class="s1">*n) * (q + </span><span class="s5">2</span><span class="s1">*n) / </span><span class="s5">2 </span><span class="s1">/ (</span><span class="s5">2</span><span class="s1">*n + </span><span class="s5">1</span><span class="s1">) / (n - </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">df1 = p * q</span>
        <span class="s1">df2 = </span><span class="s5">4 </span><span class="s1">+ (p*q + </span><span class="s5">2</span><span class="s1">) / (b - </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">c = (df2 - </span><span class="s5">2</span><span class="s1">) / </span><span class="s5">2 </span><span class="s1">/ n</span>
        <span class="s1">F = df2 / df1 * U / c</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">df1 = s * (</span><span class="s5">2</span><span class="s1">*m + s + </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">df2 = s * (s*n + </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">F = df2 / df1 / s * U</span>
    <span class="s1">results.loc[</span><span class="s4">&quot;Hotelling-Lawley trace&quot;</span><span class="s3">, </span><span class="s4">'Num DF'</span><span class="s1">] = df1</span>
    <span class="s1">results.loc[</span><span class="s4">&quot;Hotelling-Lawley trace&quot;</span><span class="s3">, </span><span class="s4">'Den DF'</span><span class="s1">] = df2</span>
    <span class="s1">results.loc[</span><span class="s4">&quot;Hotelling-Lawley trace&quot;</span><span class="s3">, </span><span class="s4">'F Value'</span><span class="s1">] = F</span>
    <span class="s1">pval = stats.f.sf(F</span><span class="s3">, </span><span class="s1">df1</span><span class="s3">, </span><span class="s1">df2)</span>
    <span class="s1">results.loc[</span><span class="s4">&quot;Hotelling-Lawley trace&quot;</span><span class="s3">, </span><span class="s4">'Pr &gt; F'</span><span class="s1">] = pval</span>

    <span class="s1">sigma = results.loc[</span><span class="s4">&quot;Roy's greatest root&quot;</span><span class="s3">, </span><span class="s4">'Value'</span><span class="s1">]</span>
    <span class="s1">r = np.max([p</span><span class="s3">, </span><span class="s1">q])</span>
    <span class="s1">df1 = r</span>
    <span class="s1">df2 = v - r + q</span>
    <span class="s1">F = df2 / df1 * sigma</span>
    <span class="s1">results.loc[</span><span class="s4">&quot;Roy's greatest root&quot;</span><span class="s3">, </span><span class="s4">'Num DF'</span><span class="s1">] = df1</span>
    <span class="s1">results.loc[</span><span class="s4">&quot;Roy's greatest root&quot;</span><span class="s3">, </span><span class="s4">'Den DF'</span><span class="s1">] = df2</span>
    <span class="s1">results.loc[</span><span class="s4">&quot;Roy's greatest root&quot;</span><span class="s3">, </span><span class="s4">'F Value'</span><span class="s1">] = F</span>
    <span class="s1">pval = stats.f.sf(F</span><span class="s3">, </span><span class="s1">df1</span><span class="s3">, </span><span class="s1">df2)</span>
    <span class="s1">results.loc[</span><span class="s4">&quot;Roy's greatest root&quot;</span><span class="s3">, </span><span class="s4">'Pr &gt; F'</span><span class="s1">] = pval</span>
    <span class="s3">return </span><span class="s1">results</span>


<span class="s3">def </span><span class="s1">_multivariate_ols_test(hypotheses</span><span class="s3">, </span><span class="s1">fit_results</span><span class="s3">, </span><span class="s1">exog_names</span><span class="s3">,</span>
                            <span class="s1">endog_names):</span>
    <span class="s3">def </span><span class="s1">fn(L</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">C):</span>
        <span class="s0"># .. [1] https://support.sas.com/documentation/cdl/en/statug/63033</span>
        <span class="s0">#        /HTML/default/viewer.htm#statug_introreg_sect012.htm</span>
        <span class="s1">params</span><span class="s3">, </span><span class="s1">df_resid</span><span class="s3">, </span><span class="s1">inv_cov</span><span class="s3">, </span><span class="s1">sscpr = fit_results</span>
        <span class="s0"># t1 = (L * params)M</span>
        <span class="s1">t1 = L.dot(params).dot(M) - C</span>
        <span class="s0"># H = t1'L(X'X)^L't1</span>
        <span class="s1">t2 = L.dot(inv_cov).dot(L.T)</span>
        <span class="s1">q = matrix_rank(t2)</span>
        <span class="s1">H = t1.T.dot(inv(t2)).dot(t1)</span>

        <span class="s0"># E = M'(Y'Y - B'(X'X)B)M</span>
        <span class="s1">E = M.T.dot(sscpr).dot(M)</span>
        <span class="s3">return </span><span class="s1">E</span><span class="s3">, </span><span class="s1">H</span><span class="s3">, </span><span class="s1">q</span><span class="s3">, </span><span class="s1">df_resid</span>

    <span class="s3">return </span><span class="s1">_multivariate_test(hypotheses</span><span class="s3">, </span><span class="s1">exog_names</span><span class="s3">, </span><span class="s1">endog_names</span><span class="s3">, </span><span class="s1">fn)</span>


<span class="s1">@Substitution(hypotheses_doc=_hypotheses_doc)</span>
<span class="s3">def </span><span class="s1">_multivariate_test(hypotheses</span><span class="s3">, </span><span class="s1">exog_names</span><span class="s3">, </span><span class="s1">endog_names</span><span class="s3">, </span><span class="s1">fn):</span>
    <span class="s2">&quot;&quot;&quot; 
    Multivariate linear model hypotheses testing 
 
    For y = x * params, where y are the dependent variables and x are the 
    independent variables, testing L * params * M = 0 where L is the contrast 
    matrix for hypotheses testing and M is the transformation matrix for 
    transforming the dependent variables in y. 
 
    Algorithm: 
        T = L*inv(X'X)*L' 
        H = M'B'L'*inv(T)*LBM 
        E =  M'(Y'Y - B'X'XB)M 
    where H and E correspond to the numerator and denominator of a univariate 
    F-test. Then find the eigenvalues of inv(H + E)*H from which the 
    multivariate test statistics are calculated. 
 
    .. [*] https://support.sas.com/documentation/cdl/en/statug/63033/HTML 
           /default/viewer.htm#statug_introreg_sect012.htm 
 
    Parameters 
    ---------- 
    %(hypotheses_doc)s 
    k_xvar : int 
        The number of independent variables 
    k_yvar : int 
        The number of dependent variables 
    fn : function 
        a function fn(contrast_L, transform_M) that returns E, H, q, df_resid 
        where q is the rank of T matrix 
 
    Returns 
    ------- 
    results : MANOVAResults 
    &quot;&quot;&quot;</span>

    <span class="s1">k_xvar = len(exog_names)</span>
    <span class="s1">k_yvar = len(endog_names)</span>
    <span class="s1">results = {}</span>
    <span class="s3">for </span><span class="s1">hypo </span><span class="s3">in </span><span class="s1">hypotheses:</span>
        <span class="s3">if </span><span class="s1">len(hypo) ==</span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">name</span><span class="s3">, </span><span class="s1">L = hypo</span>
            <span class="s1">M = </span><span class="s3">None</span>
            <span class="s1">C = </span><span class="s3">None</span>
        <span class="s3">elif </span><span class="s1">len(hypo) == </span><span class="s5">3</span><span class="s1">:</span>
            <span class="s1">name</span><span class="s3">, </span><span class="s1">L</span><span class="s3">, </span><span class="s1">M = hypo</span>
            <span class="s1">C = </span><span class="s3">None</span>
        <span class="s3">elif </span><span class="s1">len(hypo) == </span><span class="s5">4</span><span class="s1">:</span>
            <span class="s1">name</span><span class="s3">, </span><span class="s1">L</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">C = hypo</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'hypotheses must be a tuple of length 2, 3 or 4.'</span>
                             <span class="s4">' len(hypotheses)=%d' </span><span class="s1">% len(hypo))</span>
        <span class="s3">if </span><span class="s1">any(isinstance(j</span><span class="s3">, </span><span class="s1">str) </span><span class="s3">for </span><span class="s1">j </span><span class="s3">in </span><span class="s1">L):</span>
            <span class="s1">L = DesignInfo(exog_names).linear_constraint(L).coefs</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if not </span><span class="s1">isinstance(L</span><span class="s3">, </span><span class="s1">np.ndarray) </span><span class="s3">or </span><span class="s1">len(L.shape) != </span><span class="s5">2</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'Contrast matrix L must be a 2-d array!'</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">L.shape[</span><span class="s5">1</span><span class="s1">] != k_xvar:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'Contrast matrix L should have the same '</span>
                                 <span class="s4">'number of columns as exog! %d != %d' </span><span class="s1">%</span>
                                 <span class="s1">(L.shape[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">k_xvar))</span>
        <span class="s3">if </span><span class="s1">M </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">M = np.eye(k_yvar)</span>
        <span class="s3">elif </span><span class="s1">any(isinstance(j</span><span class="s3">, </span><span class="s1">str) </span><span class="s3">for </span><span class="s1">j </span><span class="s3">in </span><span class="s1">M):</span>
            <span class="s1">M = DesignInfo(endog_names).linear_constraint(M).coefs.T</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">M </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s3">if not </span><span class="s1">isinstance(M</span><span class="s3">, </span><span class="s1">np.ndarray) </span><span class="s3">or </span><span class="s1">len(M.shape) != </span><span class="s5">2</span><span class="s1">:</span>
                    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'Transform matrix M must be a 2-d array!'</span><span class="s1">)</span>
                <span class="s3">if </span><span class="s1">M.shape[</span><span class="s5">0</span><span class="s1">] != k_yvar:</span>
                    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'Transform matrix M should have the same '</span>
                                     <span class="s4">'number of rows as the number of columns '</span>
                                     <span class="s4">'of endog! %d != %d' </span><span class="s1">%</span>
                                     <span class="s1">(M.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">k_yvar))</span>
        <span class="s3">if </span><span class="s1">C </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">C = np.zeros([L.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">M.shape[</span><span class="s5">1</span><span class="s1">]])</span>
        <span class="s3">elif not </span><span class="s1">isinstance(C</span><span class="s3">, </span><span class="s1">np.ndarray):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'Constant matrix C must be a 2-d array!'</span><span class="s1">)</span>

        <span class="s3">if </span><span class="s1">C.shape[</span><span class="s5">0</span><span class="s1">] != L.shape[</span><span class="s5">0</span><span class="s1">]:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'contrast L and constant C must have the same '</span>
                             <span class="s4">'number of rows! %d!=%d'</span>
                             <span class="s1">% (L.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">C.shape[</span><span class="s5">0</span><span class="s1">]))</span>
        <span class="s3">if </span><span class="s1">C.shape[</span><span class="s5">1</span><span class="s1">] != M.shape[</span><span class="s5">1</span><span class="s1">]:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'transform M and constant C must have the same '</span>
                             <span class="s4">'number of columns! %d!=%d'</span>
                             <span class="s1">% (M.shape[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">C.shape[</span><span class="s5">1</span><span class="s1">]))</span>
        <span class="s1">E</span><span class="s3">, </span><span class="s1">H</span><span class="s3">, </span><span class="s1">q</span><span class="s3">, </span><span class="s1">df_resid = fn(L</span><span class="s3">, </span><span class="s1">M</span><span class="s3">, </span><span class="s1">C)</span>
        <span class="s1">EH = np.add(E</span><span class="s3">, </span><span class="s1">H)</span>
        <span class="s1">p = matrix_rank(EH)</span>

        <span class="s0"># eigenvalues of inv(E + H)H</span>
        <span class="s1">eigv2 = np.sort(eigvals(solve(EH</span><span class="s3">, </span><span class="s1">H)))</span>
        <span class="s1">stat_table = multivariate_stats(eigv2</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">q</span><span class="s3">, </span><span class="s1">df_resid)</span>

        <span class="s1">results[name] = {</span><span class="s4">'stat'</span><span class="s1">: stat_table</span><span class="s3">, </span><span class="s4">'contrast_L'</span><span class="s1">: L</span><span class="s3">,</span>
                         <span class="s4">'transform_M'</span><span class="s1">: M</span><span class="s3">, </span><span class="s4">'constant_C'</span><span class="s1">: C</span><span class="s3">,</span>
                         <span class="s4">'E'</span><span class="s1">: E</span><span class="s3">, </span><span class="s4">'H'</span><span class="s1">: H}</span>
    <span class="s3">return </span><span class="s1">results</span>


<span class="s3">class </span><span class="s1">_MultivariateOLS(Model):</span>
    <span class="s2">&quot;&quot;&quot; 
    Multivariate linear model via least squares 
 
 
    Parameters 
    ---------- 
    endog : array_like 
        Dependent variables. A nobs x k_endog array where nobs is 
        the number of observations and k_endog is the number of dependent 
        variables 
    exog : array_like 
        Independent variables. A nobs x k_exog array where nobs is the 
        number of observations and k_exog is the number of independent 
        variables. An intercept is not included by default and should be added 
        by the user (models specified using a formula include an intercept by 
        default) 
 
    Attributes 
    ---------- 
    endog : ndarray 
        See Parameters. 
    exog : ndarray 
        See Parameters. 
    &quot;&quot;&quot;</span>
    <span class="s1">_formula_max_endog = </span><span class="s3">None</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">endog</span><span class="s3">, </span><span class="s1">exog</span><span class="s3">, </span><span class="s1">missing=</span><span class="s4">'none'</span><span class="s3">, </span><span class="s1">hasconst=</span><span class="s3">None, </span><span class="s1">**kwargs):</span>
        <span class="s3">if </span><span class="s1">len(endog.shape) == </span><span class="s5">1 </span><span class="s3">or </span><span class="s1">endog.shape[</span><span class="s5">1</span><span class="s1">] == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'There must be more than one dependent variable'</span>
                             <span class="s4">' to fit multivariate OLS!'</span><span class="s1">)</span>
        <span class="s1">super(_MultivariateOLS</span><span class="s3">, </span><span class="s1">self).__init__(endog</span><span class="s3">, </span><span class="s1">exog</span><span class="s3">, </span><span class="s1">missing=missing</span><span class="s3">,</span>
                                               <span class="s1">hasconst=hasconst</span><span class="s3">, </span><span class="s1">**kwargs)</span>

    <span class="s3">def </span><span class="s1">fit(self</span><span class="s3">, </span><span class="s1">method=</span><span class="s4">'svd'</span><span class="s1">):</span>
        <span class="s1">self._fittedmod = _multivariate_ols_fit(</span>
            <span class="s1">self.endog</span><span class="s3">, </span><span class="s1">self.exog</span><span class="s3">, </span><span class="s1">method=method)</span>
        <span class="s3">return </span><span class="s1">_MultivariateOLSResults(self)</span>


<span class="s3">class </span><span class="s1">_MultivariateOLSResults:</span>
    <span class="s2">&quot;&quot;&quot; 
    _MultivariateOLS results class 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">fitted_mv_ols):</span>
        <span class="s3">if </span><span class="s1">(hasattr(fitted_mv_ols</span><span class="s3">, </span><span class="s4">'data'</span><span class="s1">) </span><span class="s3">and</span>
                <span class="s1">hasattr(fitted_mv_ols.data</span><span class="s3">, </span><span class="s4">'design_info'</span><span class="s1">)):</span>
            <span class="s1">self.design_info = fitted_mv_ols.data.design_info</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.design_info = </span><span class="s3">None</span>
        <span class="s1">self.exog_names = fitted_mv_ols.exog_names</span>
        <span class="s1">self.endog_names = fitted_mv_ols.endog_names</span>
        <span class="s1">self._fittedmod = fitted_mv_ols._fittedmod</span>

    <span class="s3">def </span><span class="s1">__str__(self):</span>
        <span class="s3">return </span><span class="s1">self.summary().__str__()</span>

    <span class="s1">@Substitution(hypotheses_doc=_hypotheses_doc)</span>
    <span class="s3">def </span><span class="s1">mv_test(self</span><span class="s3">, </span><span class="s1">hypotheses=</span><span class="s3">None, </span><span class="s1">skip_intercept_test=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Linear hypotheses testing 
 
        Parameters 
        ---------- 
        %(hypotheses_doc)s 
        skip_intercept_test : bool 
            If true, then testing the intercept is skipped, the model is not 
            changed. 
            Note: If a term has a numerically insignificant effect, then 
            an exception because of emtpy arrays may be raised. This can 
            happen for the intercept if the data has been demeaned. 
 
        Returns 
        ------- 
        results: _MultivariateOLSResults 
 
        Notes 
        ----- 
        Tests hypotheses of the form 
 
            L * params * M = C 
 
        where `params` is the regression coefficient matrix for the 
        linear model y = x * params, `L` is the contrast matrix, `M` is the 
        dependent variable transform matrix and C is the constant matrix. 
        &quot;&quot;&quot;</span>
        <span class="s1">k_xvar = len(self.exog_names)</span>
        <span class="s3">if </span><span class="s1">hypotheses </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">self.design_info </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">terms = self.design_info.term_name_slices</span>
                <span class="s1">hypotheses = []</span>
                <span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">terms:</span>
                    <span class="s3">if </span><span class="s1">skip_intercept_test </span><span class="s3">and </span><span class="s1">key == </span><span class="s4">'Intercept'</span><span class="s1">:</span>
                        <span class="s3">continue</span>
                    <span class="s1">L_contrast = np.eye(k_xvar)[terms[key]</span><span class="s3">, </span><span class="s1">:]</span>
                    <span class="s1">hypotheses.append([key</span><span class="s3">, </span><span class="s1">L_contrast</span><span class="s3">, None</span><span class="s1">])</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">hypotheses = []</span>
                <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(k_xvar):</span>
                    <span class="s1">name = </span><span class="s4">'x%d' </span><span class="s1">% (i)</span>
                    <span class="s1">L = np.zeros([</span><span class="s5">1</span><span class="s3">, </span><span class="s1">k_xvar])</span>
                    <span class="s1">L[i] = </span><span class="s5">1</span>
                    <span class="s1">hypotheses.append([name</span><span class="s3">, </span><span class="s1">L</span><span class="s3">, None</span><span class="s1">])</span>

        <span class="s1">results = _multivariate_ols_test(hypotheses</span><span class="s3">, </span><span class="s1">self._fittedmod</span><span class="s3">,</span>
                                          <span class="s1">self.exog_names</span><span class="s3">, </span><span class="s1">self.endog_names)</span>

        <span class="s3">return </span><span class="s1">MultivariateTestResults(results</span><span class="s3">,</span>
                                       <span class="s1">self.endog_names</span><span class="s3">,</span>
                                       <span class="s1">self.exog_names)</span>

    <span class="s3">def </span><span class="s1">summary(self):</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span>


<span class="s3">class </span><span class="s1">MultivariateTestResults:</span>
    <span class="s2">&quot;&quot;&quot; 
    Multivariate test results class 
 
    Returned by `mv_test` method of `_MultivariateOLSResults` class 
 
    Parameters 
    ---------- 
    results : dict[str, dict] 
        Dictionary containing test results. See the description 
        below for the expected format. 
    endog_names : sequence[str] 
        A list or other sequence of endogenous variables names 
    exog_names : sequence[str] 
        A list of other sequence of exogenous variables names 
 
    Attributes 
    ---------- 
    results : dict 
        Each hypothesis is contained in a single`key`. Each test must 
        have the following keys: 
 
        * 'stat' - contains the multivariate test results 
        * 'contrast_L' - contains the contrast_L matrix 
        * 'transform_M' - contains the transform_M matrix 
        * 'constant_C' - contains the constant_C matrix 
        * 'H' - contains an intermediate Hypothesis matrix, 
          or the between groups sums of squares and cross-products matrix, 
          corresponding to the numerator of the univariate F test. 
        * 'E' - contains an intermediate Error matrix, 
          corresponding to the denominator of the univariate F test. 
          The Hypotheses and Error matrices can be used to calculate 
          the same test statistics in 'stat', as well as to calculate 
          the discriminant function (canonical correlates) from the 
          eigenvectors of inv(E)H. 
 
    endog_names : list[str] 
        The endogenous names 
    exog_names : list[str] 
        The exogenous names 
    summary_frame : DataFrame 
        Returns results as a MultiIndex DataFrame 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">results</span><span class="s3">, </span><span class="s1">endog_names</span><span class="s3">, </span><span class="s1">exog_names):</span>
        <span class="s1">self.results = results</span>
        <span class="s1">self.endog_names = list(endog_names)</span>
        <span class="s1">self.exog_names = list(exog_names)</span>

    <span class="s3">def </span><span class="s1">__str__(self):</span>
        <span class="s3">return </span><span class="s1">self.summary().__str__()</span>

    <span class="s3">def </span><span class="s1">__getitem__(self</span><span class="s3">, </span><span class="s1">item):</span>
        <span class="s3">return </span><span class="s1">self.results[item]</span>

    <span class="s1">@property</span>
    <span class="s3">def </span><span class="s1">summary_frame(self):</span>
        <span class="s2">&quot;&quot;&quot; 
        Return results as a multiindex dataframe 
        &quot;&quot;&quot;</span>
        <span class="s1">df = []</span>
        <span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">self.results:</span>
            <span class="s1">tmp = self.results[key][</span><span class="s4">'stat'</span><span class="s1">].copy()</span>
            <span class="s1">tmp.loc[:</span><span class="s3">, </span><span class="s4">'Effect'</span><span class="s1">] = key</span>
            <span class="s1">df.append(tmp.reset_index())</span>
        <span class="s1">df = pd.concat(df</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">df = df.set_index([</span><span class="s4">'Effect'</span><span class="s3">, </span><span class="s4">'index'</span><span class="s1">])</span>
        <span class="s1">df.index.set_names([</span><span class="s4">'Effect'</span><span class="s3">, </span><span class="s4">'Statistic'</span><span class="s1">]</span><span class="s3">, </span><span class="s1">inplace=</span><span class="s3">True</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">df</span>

    <span class="s3">def </span><span class="s1">summary(self</span><span class="s3">, </span><span class="s1">show_contrast_L=</span><span class="s3">False, </span><span class="s1">show_transform_M=</span><span class="s3">False,</span>
                <span class="s1">show_constant_C=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s2">&quot;&quot;&quot; 
        Summary of test results 
 
        Parameters 
        ---------- 
        show_contrast_L : bool 
            Whether to show contrast_L matrix 
        show_transform_M : bool 
            Whether to show transform_M matrix 
        show_constant_C : bool 
            Whether to show the constant_C 
        &quot;&quot;&quot;</span>
        <span class="s1">summ = summary2.Summary()</span>
        <span class="s1">summ.add_title(</span><span class="s4">'Multivariate linear model'</span><span class="s1">)</span>
        <span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">self.results:</span>
            <span class="s1">summ.add_dict({</span><span class="s4">''</span><span class="s1">: </span><span class="s4">''</span><span class="s1">})</span>
            <span class="s1">df = self.results[key][</span><span class="s4">'stat'</span><span class="s1">].copy()</span>
            <span class="s1">df = df.reset_index()</span>
            <span class="s1">c = df.columns.values</span>
            <span class="s1">c[</span><span class="s5">0</span><span class="s1">] = key</span>
            <span class="s1">df.columns = c</span>
            <span class="s1">df.index = [</span><span class="s4">''</span><span class="s3">, </span><span class="s4">''</span><span class="s3">, </span><span class="s4">''</span><span class="s3">, </span><span class="s4">''</span><span class="s1">]</span>
            <span class="s1">summ.add_df(df)</span>
            <span class="s3">if </span><span class="s1">show_contrast_L:</span>
                <span class="s1">summ.add_dict({key: </span><span class="s4">' contrast L='</span><span class="s1">})</span>
                <span class="s1">df = pd.DataFrame(self.results[key][</span><span class="s4">'contrast_L'</span><span class="s1">]</span><span class="s3">,</span>
                                  <span class="s1">columns=self.exog_names)</span>
                <span class="s1">summ.add_df(df)</span>
            <span class="s3">if </span><span class="s1">show_transform_M:</span>
                <span class="s1">summ.add_dict({key: </span><span class="s4">' transform M='</span><span class="s1">})</span>
                <span class="s1">df = pd.DataFrame(self.results[key][</span><span class="s4">'transform_M'</span><span class="s1">]</span><span class="s3">,</span>
                                  <span class="s1">index=self.endog_names)</span>
                <span class="s1">summ.add_df(df)</span>
            <span class="s3">if </span><span class="s1">show_constant_C:</span>
                <span class="s1">summ.add_dict({key: </span><span class="s4">' constant C='</span><span class="s1">})</span>
                <span class="s1">df = pd.DataFrame(self.results[key][</span><span class="s4">'constant_C'</span><span class="s1">])</span>
                <span class="s1">summ.add_df(df)</span>
        <span class="s3">return </span><span class="s1">summ</span>
</pre>
</body>
</html>