<html>
<head>
<title>sarimax.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #6a8759;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
sarimax.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
SARIMAX Model 
 
Author: Chad Fulton 
License: Simplified-BSD 
&quot;&quot;&quot;</span>
<span class="s2">from </span><span class="s1">warnings </span><span class="s2">import </span><span class="s1">warn</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pandas </span><span class="s2">as </span><span class="s1">pd</span>

<span class="s2">from </span><span class="s1">statsmodels.compat.pandas </span><span class="s2">import </span><span class="s1">Appender</span>

<span class="s2">from </span><span class="s1">statsmodels.tools.tools </span><span class="s2">import </span><span class="s1">Bunch</span>
<span class="s2">from </span><span class="s1">statsmodels.tools.data </span><span class="s2">import </span><span class="s1">_is_using_pandas</span>
<span class="s2">from </span><span class="s1">statsmodels.tools.decorators </span><span class="s2">import </span><span class="s1">cache_readonly</span>
<span class="s2">import </span><span class="s1">statsmodels.base.wrapper </span><span class="s2">as </span><span class="s1">wrap</span>

<span class="s2">from </span><span class="s1">statsmodels.tsa.arima.specification </span><span class="s2">import </span><span class="s1">SARIMAXSpecification</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.arima.params </span><span class="s2">import </span><span class="s1">SARIMAXParams</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.tsatools </span><span class="s2">import </span><span class="s1">lagmat</span>

<span class="s2">from </span><span class="s1">.initialization </span><span class="s2">import </span><span class="s1">Initialization</span>
<span class="s2">from </span><span class="s1">.mlemodel </span><span class="s2">import </span><span class="s1">MLEModel</span><span class="s2">, </span><span class="s1">MLEResults</span><span class="s2">, </span><span class="s1">MLEResultsWrapper</span>
<span class="s2">from </span><span class="s1">.tools </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">companion_matrix</span><span class="s2">, </span><span class="s1">diff</span><span class="s2">, </span><span class="s1">is_invertible</span><span class="s2">, </span><span class="s1">constrain_stationary_univariate</span><span class="s2">,</span>
    <span class="s1">unconstrain_stationary_univariate</span><span class="s2">,</span>
    <span class="s1">prepare_exog</span><span class="s2">, </span><span class="s1">prepare_trend_spec</span><span class="s2">, </span><span class="s1">prepare_trend_data)</span>


<span class="s2">class </span><span class="s1">SARIMAX(MLEModel):</span>
    <span class="s0">r&quot;&quot;&quot; 
    Seasonal AutoRegressive Integrated Moving Average with eXogenous regressors 
    model 
 
    Parameters 
    ---------- 
    endog : array_like 
        The observed time-series process :math:`y` 
    exog : array_like, optional 
        Array of exogenous regressors, shaped nobs x k. 
    order : iterable or iterable of iterables, optional 
        The (p,d,q) order of the model for the number of AR parameters, 
        differences, and MA parameters. `d` must be an integer 
        indicating the integration order of the process, while 
        `p` and `q` may either be an integers indicating the AR and MA 
        orders (so that all lags up to those orders are included) or else 
        iterables giving specific AR and / or MA lags to include. Default is 
        an AR(1) model: (1,0,0). 
    seasonal_order : iterable, optional 
        The (P,D,Q,s) order of the seasonal component of the model for the 
        AR parameters, differences, MA parameters, and periodicity. 
        `D` must be an integer indicating the integration order of the process, 
        while `P` and `Q` may either be an integers indicating the AR and MA 
        orders (so that all lags up to those orders are included) or else 
        iterables giving specific AR and / or MA lags to include. `s` is an 
        integer giving the periodicity (number of periods in season), often it 
        is 4 for quarterly data or 12 for monthly data. Default is no seasonal 
        effect. 
    trend : str{'n','c','t','ct'} or iterable, optional 
        Parameter controlling the deterministic trend polynomial :math:`A(t)`. 
        Can be specified as a string where 'c' indicates a constant (i.e. a 
        degree zero component of the trend polynomial), 't' indicates a 
        linear trend with time, and 'ct' is both. Can also be specified as an 
        iterable defining the non-zero polynomial exponents to include, in 
        increasing order. For example, `[1,1,0,1]` denotes 
        :math:`a + bt + ct^3`. Default is to not include a trend component. 
    measurement_error : bool, optional 
        Whether or not to assume the endogenous observations `endog` were 
        measured with error. Default is False. 
    time_varying_regression : bool, optional 
        Used when an explanatory variables, `exog`, are provided 
        to select whether or not coefficients on the exogenous regressors are 
        allowed to vary over time. Default is False. 
    mle_regression : bool, optional 
        Whether or not to use estimate the regression coefficients for the 
        exogenous variables as part of maximum likelihood estimation or through 
        the Kalman filter (i.e. recursive least squares). If 
        `time_varying_regression` is True, this must be set to False. Default 
        is True. 
    simple_differencing : bool, optional 
        Whether or not to use partially conditional maximum likelihood 
        estimation. If True, differencing is performed prior to estimation, 
        which discards the first :math:`s D + d` initial rows but results in a 
        smaller state-space formulation. See the Notes section for important 
        details about interpreting results when this option is used. If False, 
        the full SARIMAX model is put in state-space form so that all 
        datapoints can be used in estimation. Default is False. 
    enforce_stationarity : bool, optional 
        Whether or not to transform the AR parameters to enforce stationarity 
        in the autoregressive component of the model. Default is True. 
    enforce_invertibility : bool, optional 
        Whether or not to transform the MA parameters to enforce invertibility 
        in the moving average component of the model. Default is True. 
    hamilton_representation : bool, optional 
        Whether or not to use the Hamilton representation of an ARMA process 
        (if True) or the Harvey representation (if False). Default is False. 
    concentrate_scale : bool, optional 
        Whether or not to concentrate the scale (variance of the error term) 
        out of the likelihood. This reduces the number of parameters estimated 
        by maximum likelihood by one, but standard errors will then not 
        be available for the scale parameter. 
    trend_offset : int, optional 
        The offset at which to start time trend values. Default is 1, so that 
        if `trend='t'` the trend is equal to 1, 2, ..., nobs. Typically is only 
        set when the model created by extending a previous dataset. 
    use_exact_diffuse : bool, optional 
        Whether or not to use exact diffuse initialization for non-stationary 
        states. Default is False (in which case approximate diffuse 
        initialization is used). 
    **kwargs 
        Keyword arguments may be used to provide default values for state space 
        matrices or for Kalman filtering options. See `Representation`, and 
        `KalmanFilter` for more details. 
 
    Attributes 
    ---------- 
    measurement_error : bool 
        Whether or not to assume the endogenous 
        observations `endog` were measured with error. 
    state_error : bool 
        Whether or not the transition equation has an error component. 
    mle_regression : bool 
        Whether or not the regression coefficients for 
        the exogenous variables were estimated via maximum 
        likelihood estimation. 
    state_regression : bool 
        Whether or not the regression coefficients for 
        the exogenous variables are included as elements 
        of the state space and estimated via the Kalman 
        filter. 
    time_varying_regression : bool 
        Whether or not coefficients on the exogenous 
        regressors are allowed to vary over time. 
    simple_differencing : bool 
        Whether or not to use partially conditional maximum likelihood 
        estimation. 
    enforce_stationarity : bool 
        Whether or not to transform the AR parameters 
        to enforce stationarity in the autoregressive 
        component of the model. 
    enforce_invertibility : bool 
        Whether or not to transform the MA parameters 
        to enforce invertibility in the moving average 
        component of the model. 
    hamilton_representation : bool 
        Whether or not to use the Hamilton representation of an ARMA process. 
    trend : str{'n','c','t','ct'} or iterable 
        Parameter controlling the deterministic 
        trend polynomial :math:`A(t)`. See the class 
        parameter documentation for more information. 
    polynomial_ar : ndarray 
        Array containing autoregressive lag polynomial lags, ordered from 
        lowest degree to highest. The polynomial begins with lag 0. 
        Initialized with ones, unless a coefficient is constrained to be 
        zero (in which case it is zero). 
    polynomial_ma : ndarray 
        Array containing moving average lag polynomial lags, ordered from 
        lowest degree to highest. Initialized with ones, unless a coefficient 
        is constrained to be zero (in which case it is zero). 
    polynomial_seasonal_ar : ndarray 
        Array containing seasonal moving average lag 
        polynomial lags, ordered from lowest degree 
        to highest. Initialized with ones, unless a 
        coefficient is constrained to be zero (in which 
        case it is zero). 
    polynomial_seasonal_ma : ndarray 
        Array containing seasonal moving average lag 
        polynomial lags, ordered from lowest degree 
        to highest. Initialized with ones, unless a 
        coefficient is constrained to be zero (in which 
        case it is zero). 
    polynomial_trend : ndarray 
        Array containing trend polynomial coefficients, 
        ordered from lowest degree to highest. Initialized 
        with ones, unless a coefficient is constrained to be 
        zero (in which case it is zero). 
    k_ar : int 
        Highest autoregressive order in the model, zero-indexed. 
    k_ar_params : int 
        Number of autoregressive parameters to be estimated. 
    k_diff : int 
        Order of integration. 
    k_ma : int 
        Highest moving average order in the model, zero-indexed. 
    k_ma_params : int 
        Number of moving average parameters to be estimated. 
    seasonal_periods : int 
        Number of periods in a season. 
    k_seasonal_ar : int 
        Highest seasonal autoregressive order in the model, zero-indexed. 
    k_seasonal_ar_params : int 
        Number of seasonal autoregressive parameters to be estimated. 
    k_seasonal_diff : int 
        Order of seasonal integration. 
    k_seasonal_ma : int 
        Highest seasonal moving average order in the model, zero-indexed. 
    k_seasonal_ma_params : int 
        Number of seasonal moving average parameters to be estimated. 
    k_trend : int 
        Order of the trend polynomial plus one (i.e. the constant polynomial 
        would have `k_trend=1`). 
    k_exog : int 
        Number of exogenous regressors. 
 
    Notes 
    ----- 
    The SARIMA model is specified :math:`(p, d, q) \times (P, D, Q)_s`. 
 
    .. math:: 
 
        \phi_p (L) \tilde \phi_P (L^s) \Delta^d \Delta_s^D y_t = A(t) + 
            \theta_q (L) \tilde \theta_Q (L^s) \zeta_t 
 
    In terms of a univariate structural model, this can be represented as 
 
    .. math:: 
 
        y_t &amp; = u_t + \eta_t \\ 
        \phi_p (L) \tilde \phi_P (L^s) \Delta^d \Delta_s^D u_t &amp; = A(t) + 
            \theta_q (L) \tilde \theta_Q (L^s) \zeta_t 
 
    where :math:`\eta_t` is only applicable in the case of measurement error 
    (although it is also used in the case of a pure regression model, i.e. if 
    p=q=0). 
 
    In terms of this model, regression with SARIMA errors can be represented 
    easily as 
 
    .. math:: 
 
        y_t &amp; = \beta_t x_t + u_t \\ 
        \phi_p (L) \tilde \phi_P (L^s) \Delta^d \Delta_s^D u_t &amp; = A(t) + 
            \theta_q (L) \tilde \theta_Q (L^s) \zeta_t 
 
    this model is the one used when exogenous regressors are provided. 
 
    Note that the reduced form lag polynomials will be written as: 
 
    .. math:: 
 
        \Phi (L) \equiv \phi_p (L) \tilde \phi_P (L^s) \\ 
        \Theta (L) \equiv \theta_q (L) \tilde \theta_Q (L^s) 
 
    If `mle_regression` is True, regression coefficients are treated as 
    additional parameters to be estimated via maximum likelihood. Otherwise 
    they are included as part of the state with a diffuse initialization. 
    In this case, however, with approximate diffuse initialization, results 
    can be sensitive to the initial variance. 
 
    This class allows two different underlying representations of ARMA models 
    as state space models: that of Hamilton and that of Harvey. Both are 
    equivalent in the sense that they are analytical representations of the 
    ARMA model, but the state vectors of each have different meanings. For 
    this reason, maximum likelihood does not result in identical parameter 
    estimates and even the same set of parameters will result in different 
    loglikelihoods. 
 
    The Harvey representation is convenient because it allows integrating 
    differencing into the state vector to allow using all observations for 
    estimation. 
 
    In this implementation of differenced models, the Hamilton representation 
    is not able to accommodate differencing in the state vector, so 
    `simple_differencing` (which performs differencing prior to estimation so 
    that the first d + sD observations are lost) must be used. 
 
    Many other packages use the Hamilton representation, so that tests against 
    Stata and R require using it along with simple differencing (as Stata 
    does). 
 
    If `filter_concentrated = True` is used, then the scale of the model is 
    concentrated out of the likelihood. A benefit of this is that there the 
    dimension of the parameter vector is reduced so that numerical maximization 
    of the log-likelihood function may be faster and more stable. If this 
    option in a model with measurement error, it is important to note that the 
    estimated measurement error parameter will be relative to the scale, and 
    is named &quot;snr.measurement_error&quot; instead of &quot;var.measurement_error&quot;. To 
    compute the variance of the measurement error in this case one would 
    multiply `snr.measurement_error` parameter by the scale. 
 
    If `simple_differencing = True` is used, then the `endog` and `exog` data 
    are differenced prior to putting the model in state-space form. This has 
    the same effect as if the user differenced the data prior to constructing 
    the model, which has implications for using the results: 
 
    - Forecasts and predictions will be about the *differenced* data, not about 
      the original data. (while if `simple_differencing = False` is used, then 
      forecasts and predictions will be about the original data). 
    - If the original data has an Int64Index, a new RangeIndex will be created 
      for the differenced data that starts from one, and forecasts and 
      predictions will use this new index. 
 
    Detailed information about state space models can be found in [1]_. Some 
    specific references are: 
 
    - Chapter 3.4 describes ARMA and ARIMA models in state space form (using 
      the Harvey representation), and gives references for basic seasonal 
      models and models with a multiplicative form (for example the airline 
      model). It also shows a state space model for a full ARIMA process (this 
      is what is done here if `simple_differencing=False`). 
    - Chapter 3.6 describes estimating regression effects via the Kalman filter 
      (this is performed if `mle_regression` is False), regression with 
      time-varying coefficients, and regression with ARMA errors (recall from 
      above that if regression effects are present, the model estimated by this 
      class is regression with SARIMA errors). 
    - Chapter 8.4 describes the application of an ARMA model to an example 
      dataset. A replication of this section is available in an example 
      IPython notebook in the documentation. 
 
    References 
    ---------- 
    .. [1] Durbin, James, and Siem Jan Koopman. 2012. 
       Time Series Analysis by State Space Methods: Second Edition. 
       Oxford University Press. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">endog</span><span class="s2">, </span><span class="s1">exog=</span><span class="s2">None, </span><span class="s1">order=(</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span><span class="s2">,</span>
                 <span class="s1">seasonal_order=(</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s2">None,</span>
                 <span class="s1">measurement_error=</span><span class="s2">False, </span><span class="s1">time_varying_regression=</span><span class="s2">False,</span>
                 <span class="s1">mle_regression=</span><span class="s2">True, </span><span class="s1">simple_differencing=</span><span class="s2">False,</span>
                 <span class="s1">enforce_stationarity=</span><span class="s2">True, </span><span class="s1">enforce_invertibility=</span><span class="s2">True,</span>
                 <span class="s1">hamilton_representation=</span><span class="s2">False, </span><span class="s1">concentrate_scale=</span><span class="s2">False,</span>
                 <span class="s1">trend_offset=</span><span class="s3">1</span><span class="s2">, </span><span class="s1">use_exact_diffuse=</span><span class="s2">False, </span><span class="s1">dates=</span><span class="s2">None,</span>
                 <span class="s1">freq=</span><span class="s2">None, </span><span class="s1">missing=</span><span class="s4">'none'</span><span class="s2">, </span><span class="s1">validate_specification=</span><span class="s2">True,</span>
                 <span class="s1">**kwargs):</span>

        <span class="s1">self._spec = SARIMAXSpecification(</span>
            <span class="s1">endog</span><span class="s2">, </span><span class="s1">exog=exog</span><span class="s2">, </span><span class="s1">order=order</span><span class="s2">, </span><span class="s1">seasonal_order=seasonal_order</span><span class="s2">,</span>
            <span class="s1">trend=trend</span><span class="s2">, </span><span class="s1">enforce_stationarity=</span><span class="s2">None, </span><span class="s1">enforce_invertibility=</span><span class="s2">None,</span>
            <span class="s1">concentrate_scale=concentrate_scale</span><span class="s2">, </span><span class="s1">dates=dates</span><span class="s2">, </span><span class="s1">freq=freq</span><span class="s2">,</span>
            <span class="s1">missing=missing</span><span class="s2">, </span><span class="s1">validate_specification=validate_specification)</span>
        <span class="s1">self._params = SARIMAXParams(self._spec)</span>

        <span class="s5"># Save given orders</span>
        <span class="s1">order = self._spec.order</span>
        <span class="s1">seasonal_order = self._spec.seasonal_order</span>
        <span class="s1">self.order = order</span>
        <span class="s1">self.seasonal_order = seasonal_order</span>

        <span class="s5"># Model parameters</span>
        <span class="s1">self.seasonal_periods = seasonal_order[</span><span class="s3">3</span><span class="s1">]</span>
        <span class="s1">self.measurement_error = measurement_error</span>
        <span class="s1">self.time_varying_regression = time_varying_regression</span>
        <span class="s1">self.mle_regression = mle_regression</span>
        <span class="s1">self.simple_differencing = simple_differencing</span>
        <span class="s1">self.enforce_stationarity = enforce_stationarity</span>
        <span class="s1">self.enforce_invertibility = enforce_invertibility</span>
        <span class="s1">self.hamilton_representation = hamilton_representation</span>
        <span class="s1">self.concentrate_scale = concentrate_scale</span>
        <span class="s1">self.use_exact_diffuse = use_exact_diffuse</span>

        <span class="s5"># Enforce non-MLE coefficients if time varying coefficients is</span>
        <span class="s5"># specified</span>
        <span class="s2">if </span><span class="s1">self.time_varying_regression </span><span class="s2">and </span><span class="s1">self.mle_regression:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'Models with time-varying regression coefficients'</span>
                             <span class="s4">' must integrate the coefficients as part of the'</span>
                             <span class="s4">' state vector, so that `mle_regression` must'</span>
                             <span class="s4">' be set to False.'</span><span class="s1">)</span>

        <span class="s5"># Lag polynomials</span>
        <span class="s1">self._params.ar_params = -</span><span class="s3">1</span>
        <span class="s1">self.polynomial_ar = self._params.ar_poly.coef</span>
        <span class="s1">self._polynomial_ar = self.polynomial_ar.copy()</span>

        <span class="s1">self._params.ma_params = </span><span class="s3">1</span>
        <span class="s1">self.polynomial_ma = self._params.ma_poly.coef</span>
        <span class="s1">self._polynomial_ma = self.polynomial_ma.copy()</span>

        <span class="s1">self._params.seasonal_ar_params = -</span><span class="s3">1</span>
        <span class="s1">self.polynomial_seasonal_ar = self._params.seasonal_ar_poly.coef</span>
        <span class="s1">self._polynomial_seasonal_ar = self.polynomial_seasonal_ar.copy()</span>

        <span class="s1">self._params.seasonal_ma_params = </span><span class="s3">1</span>
        <span class="s1">self.polynomial_seasonal_ma = self._params.seasonal_ma_poly.coef</span>
        <span class="s1">self._polynomial_seasonal_ma = self.polynomial_seasonal_ma.copy()</span>

        <span class="s5"># Deterministic trend polynomial</span>
        <span class="s1">self.trend = trend</span>
        <span class="s1">self.trend_offset = trend_offset</span>
        <span class="s1">self.polynomial_trend</span><span class="s2">, </span><span class="s1">self.k_trend = prepare_trend_spec(self.trend)</span>
        <span class="s1">self._polynomial_trend = self.polynomial_trend.copy()</span>
        <span class="s1">self._k_trend = self.k_trend</span>
        <span class="s5"># (we internally use _k_trend for mechanics so that the public</span>
        <span class="s5"># attribute can be overridden by subclasses)</span>

        <span class="s5"># Model orders</span>
        <span class="s5"># Note: k_ar, k_ma, k_seasonal_ar, k_seasonal_ma do not include the</span>
        <span class="s5"># constant term, so they may be zero.</span>
        <span class="s5"># Note: for a typical ARMA(p,q) model, p = k_ar_params = k_ar - 1 and</span>
        <span class="s5"># q = k_ma_params = k_ma - 1, although this may not be true for models</span>
        <span class="s5"># with arbitrary log polynomials.</span>
        <span class="s1">self.k_ar = self._spec.max_ar_order</span>
        <span class="s1">self.k_ar_params = self._spec.k_ar_params</span>
        <span class="s1">self.k_diff = int(order[</span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">self.k_ma = self._spec.max_ma_order</span>
        <span class="s1">self.k_ma_params = self._spec.k_ma_params</span>

        <span class="s1">self.k_seasonal_ar = (self._spec.max_seasonal_ar_order *</span>
                              <span class="s1">self._spec.seasonal_periods)</span>
        <span class="s1">self.k_seasonal_ar_params = self._spec.k_seasonal_ar_params</span>
        <span class="s1">self.k_seasonal_diff = int(seasonal_order[</span><span class="s3">1</span><span class="s1">])</span>
        <span class="s1">self.k_seasonal_ma = (self._spec.max_seasonal_ma_order *</span>
                              <span class="s1">self._spec.seasonal_periods)</span>
        <span class="s1">self.k_seasonal_ma_params = self._spec.k_seasonal_ma_params</span>

        <span class="s5"># Make internal copies of the differencing orders because if we use</span>
        <span class="s5"># simple differencing, then we will need to internally use zeros after</span>
        <span class="s5"># the simple differencing has been performed</span>
        <span class="s1">self._k_diff = self.k_diff</span>
        <span class="s1">self._k_seasonal_diff = self.k_seasonal_diff</span>

        <span class="s5"># We can only use the Hamilton representation if differencing is not</span>
        <span class="s5"># performed as a part of the state space</span>
        <span class="s2">if </span><span class="s1">(self.hamilton_representation </span><span class="s2">and not </span><span class="s1">(self.simple_differencing </span><span class="s2">or</span>
           <span class="s1">self._k_diff == self._k_seasonal_diff == </span><span class="s3">0</span><span class="s1">)):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'The Hamilton representation is only available'</span>
                             <span class="s4">' for models in which there is no differencing'</span>
                             <span class="s4">' integrated into the state vector. Set'</span>
                             <span class="s4">' `simple_differencing` to True or set'</span>
                             <span class="s4">' `hamilton_representation` to False'</span><span class="s1">)</span>

        <span class="s5"># Model order</span>
        <span class="s5"># (this is used internally in a number of locations)</span>
        <span class="s1">self._k_order = max(self.k_ar + self.k_seasonal_ar</span><span class="s2">,</span>
                            <span class="s1">self.k_ma + self.k_seasonal_ma + </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self._k_order == </span><span class="s3">1 </span><span class="s2">and </span><span class="s1">self.k_ar + self.k_seasonal_ar == </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s5"># Handle time-varying regression</span>
            <span class="s2">if </span><span class="s1">self.time_varying_regression:</span>
                <span class="s1">self._k_order = </span><span class="s3">0</span>

        <span class="s5"># Exogenous data</span>
        <span class="s1">(self._k_exog</span><span class="s2">, </span><span class="s1">exog) = prepare_exog(exog)</span>
        <span class="s5"># (we internally use _k_exog for mechanics so that the public attribute</span>
        <span class="s5"># can be overridden by subclasses)</span>
        <span class="s1">self.k_exog = self._k_exog</span>

        <span class="s5"># Redefine mle_regression to be true only if it was previously set to</span>
        <span class="s5"># true and there are exogenous regressors</span>
        <span class="s1">self.mle_regression = (</span>
            <span class="s1">self.mle_regression </span><span class="s2">and </span><span class="s1">exog </span><span class="s2">is not None and </span><span class="s1">self._k_exog &gt; </span><span class="s3">0</span>
        <span class="s1">)</span>
        <span class="s5"># State regression is regression with coefficients estimated within</span>
        <span class="s5"># the state vector</span>
        <span class="s1">self.state_regression = (</span>
            <span class="s2">not </span><span class="s1">self.mle_regression </span><span class="s2">and </span><span class="s1">exog </span><span class="s2">is not None and </span><span class="s1">self._k_exog &gt; </span><span class="s3">0</span>
        <span class="s1">)</span>
        <span class="s5"># If all we have is a regression (so k_ar = k_ma = 0), then put the</span>
        <span class="s5"># error term as measurement error</span>
        <span class="s2">if </span><span class="s1">self.state_regression </span><span class="s2">and </span><span class="s1">self._k_order == </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">self.measurement_error = </span><span class="s2">True</span>

        <span class="s5"># Number of states</span>
        <span class="s1">k_states = self._k_order</span>
        <span class="s2">if not </span><span class="s1">self.simple_differencing:</span>
            <span class="s1">k_states += (self.seasonal_periods * self._k_seasonal_diff +</span>
                         <span class="s1">self._k_diff)</span>
        <span class="s2">if </span><span class="s1">self.state_regression:</span>
            <span class="s1">k_states += self._k_exog</span>

        <span class="s5"># Number of positive definite elements of the state covariance matrix</span>
        <span class="s1">k_posdef = int(self._k_order &gt; </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s5"># Only have an error component to the states if k_posdef &gt; 0</span>
        <span class="s1">self.state_error = k_posdef &gt; </span><span class="s3">0</span>
        <span class="s2">if </span><span class="s1">self.state_regression </span><span class="s2">and </span><span class="s1">self.time_varying_regression:</span>
            <span class="s1">k_posdef += self._k_exog</span>

        <span class="s5"># Diffuse initialization can be more sensistive to the variance value</span>
        <span class="s5"># in the case of state regression, so set a higher than usual default</span>
        <span class="s5"># variance</span>
        <span class="s2">if </span><span class="s1">self.state_regression:</span>
            <span class="s1">kwargs.setdefault(</span><span class="s4">'initial_variance'</span><span class="s2">, </span><span class="s3">1e10</span><span class="s1">)</span>

        <span class="s5"># Handle non-default loglikelihood burn</span>
        <span class="s1">self._loglikelihood_burn = kwargs.get(</span><span class="s4">'loglikelihood_burn'</span><span class="s2">, None</span><span class="s1">)</span>

        <span class="s5"># Number of parameters</span>
        <span class="s1">self.k_params = (</span>
            <span class="s1">self.k_ar_params + self.k_ma_params +</span>
            <span class="s1">self.k_seasonal_ar_params + self.k_seasonal_ma_params +</span>
            <span class="s1">self._k_trend +</span>
            <span class="s1">self.measurement_error +</span>
            <span class="s1">int(</span><span class="s2">not </span><span class="s1">self.concentrate_scale)</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self.mle_regression:</span>
            <span class="s1">self.k_params += self._k_exog</span>

        <span class="s5"># We need to have an array or pandas at this point</span>
        <span class="s1">self.orig_endog = endog</span>
        <span class="s1">self.orig_exog = exog</span>
        <span class="s2">if not </span><span class="s1">_is_using_pandas(endog</span><span class="s2">, None</span><span class="s1">):</span>
            <span class="s1">endog = np.asanyarray(endog)</span>

        <span class="s5"># Update the differencing dimensions if simple differencing is applied</span>
        <span class="s1">self.orig_k_diff = self._k_diff</span>
        <span class="s1">self.orig_k_seasonal_diff = self._k_seasonal_diff</span>
        <span class="s2">if </span><span class="s1">(self.simple_differencing </span><span class="s2">and</span>
           <span class="s1">(self._k_diff &gt; </span><span class="s3">0 </span><span class="s2">or </span><span class="s1">self._k_seasonal_diff &gt; </span><span class="s3">0</span><span class="s1">)):</span>
            <span class="s1">self._k_diff = </span><span class="s3">0</span>
            <span class="s1">self._k_seasonal_diff = </span><span class="s3">0</span>

        <span class="s5"># Internally used in several locations</span>
        <span class="s1">self._k_states_diff = (</span>
            <span class="s1">self._k_diff + self.seasonal_periods * self._k_seasonal_diff</span>
        <span class="s1">)</span>

        <span class="s5"># Set some model variables now so they will be available for the</span>
        <span class="s5"># initialize() method, below</span>
        <span class="s1">self.nobs = len(endog)</span>
        <span class="s1">self.k_states = k_states</span>
        <span class="s1">self.k_posdef = k_posdef</span>

        <span class="s5"># Initialize the statespace</span>
        <span class="s1">super(SARIMAX</span><span class="s2">, </span><span class="s1">self).__init__(</span>
            <span class="s1">endog</span><span class="s2">, </span><span class="s1">exog=exog</span><span class="s2">, </span><span class="s1">k_states=k_states</span><span class="s2">, </span><span class="s1">k_posdef=k_posdef</span><span class="s2">, </span><span class="s1">**kwargs</span>
        <span class="s1">)</span>

        <span class="s5"># Set the filter to concentrate out the scale if requested</span>
        <span class="s2">if </span><span class="s1">self.concentrate_scale:</span>
            <span class="s1">self.ssm.filter_concentrated = </span><span class="s2">True</span>

        <span class="s5"># Set as time-varying model if we have time-trend or exog</span>
        <span class="s2">if </span><span class="s1">self._k_exog &gt; </span><span class="s3">0 </span><span class="s2">or </span><span class="s1">len(self.polynomial_trend) &gt; </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s1">self.ssm._time_invariant = </span><span class="s2">False</span>

        <span class="s5"># Initialize the fixed components of the statespace model</span>
        <span class="s1">self.ssm[</span><span class="s4">'design'</span><span class="s1">] = self.initial_design</span>
        <span class="s1">self.ssm[</span><span class="s4">'state_intercept'</span><span class="s1">] = self.initial_state_intercept</span>
        <span class="s1">self.ssm[</span><span class="s4">'transition'</span><span class="s1">] = self.initial_transition</span>
        <span class="s1">self.ssm[</span><span class="s4">'selection'</span><span class="s1">] = self.initial_selection</span>
        <span class="s2">if </span><span class="s1">self.concentrate_scale:</span>
            <span class="s1">self.ssm[</span><span class="s4">'state_cov'</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">] = </span><span class="s3">1.</span>

        <span class="s5"># update _init_keys attached by super</span>
        <span class="s1">self._init_keys += [</span><span class="s4">'order'</span><span class="s2">, </span><span class="s4">'seasonal_order'</span><span class="s2">, </span><span class="s4">'trend'</span><span class="s2">,</span>
                            <span class="s4">'measurement_error'</span><span class="s2">, </span><span class="s4">'time_varying_regression'</span><span class="s2">,</span>
                            <span class="s4">'mle_regression'</span><span class="s2">, </span><span class="s4">'simple_differencing'</span><span class="s2">,</span>
                            <span class="s4">'enforce_stationarity'</span><span class="s2">, </span><span class="s4">'enforce_invertibility'</span><span class="s2">,</span>
                            <span class="s4">'hamilton_representation'</span><span class="s2">, </span><span class="s4">'concentrate_scale'</span><span class="s2">,</span>
                            <span class="s4">'trend_offset'</span><span class="s1">] + list(kwargs.keys())</span>
        <span class="s5"># TODO: I think the kwargs or not attached, need to recover from ???</span>

        <span class="s5"># Initialize the state</span>
        <span class="s2">if </span><span class="s1">self.ssm.initialization </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.initialize_default()</span>

    <span class="s2">def </span><span class="s1">prepare_data(self):</span>
        <span class="s1">endog</span><span class="s2">, </span><span class="s1">exog = super(SARIMAX</span><span class="s2">, </span><span class="s1">self).prepare_data()</span>

        <span class="s5"># Perform simple differencing if requested</span>
        <span class="s2">if </span><span class="s1">(self.simple_differencing </span><span class="s2">and</span>
           <span class="s1">(self.orig_k_diff &gt; </span><span class="s3">0 </span><span class="s2">or </span><span class="s1">self.orig_k_seasonal_diff &gt; </span><span class="s3">0</span><span class="s1">)):</span>
            <span class="s5"># Save the original length</span>
            <span class="s1">orig_length = endog.shape[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s5"># Perform simple differencing</span>
            <span class="s1">endog = diff(endog.copy()</span><span class="s2">, </span><span class="s1">self.orig_k_diff</span><span class="s2">,</span>
                         <span class="s1">self.orig_k_seasonal_diff</span><span class="s2">, </span><span class="s1">self.seasonal_periods)</span>
            <span class="s2">if </span><span class="s1">exog </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">exog = diff(exog.copy()</span><span class="s2">, </span><span class="s1">self.orig_k_diff</span><span class="s2">,</span>
                            <span class="s1">self.orig_k_seasonal_diff</span><span class="s2">, </span><span class="s1">self.seasonal_periods)</span>

            <span class="s5"># Reset the ModelData datasets and cache</span>
            <span class="s1">self.data.endog</span><span class="s2">, </span><span class="s1">self.data.exog = (</span>
                <span class="s1">self.data._convert_endog_exog(endog</span><span class="s2">, </span><span class="s1">exog))</span>

            <span class="s5"># Reset indexes, if provided</span>
            <span class="s1">new_length = self.data.endog.shape[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">self.data.row_labels </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">self.data._cache[</span><span class="s4">'row_labels'</span><span class="s1">] = (</span>
                    <span class="s1">self.data.row_labels[orig_length - new_length:])</span>
            <span class="s2">if </span><span class="s1">self._index </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">self._index_int64:</span>
                    <span class="s1">self._index = pd.RangeIndex(start=</span><span class="s3">1</span><span class="s2">, </span><span class="s1">stop=new_length + </span><span class="s3">1</span><span class="s1">)</span>
                <span class="s2">elif </span><span class="s1">self._index_generated:</span>
                    <span class="s1">self._index = self._index[:-(orig_length - new_length)]</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">self._index = self._index[orig_length - new_length:]</span>

        <span class="s5"># Reset the nobs</span>
        <span class="s1">self.nobs = endog.shape[</span><span class="s3">0</span><span class="s1">]</span>

        <span class="s5"># Cache the arrays for calculating the intercept from the trend</span>
        <span class="s5"># components</span>
        <span class="s1">self._trend_data = prepare_trend_data(</span>
            <span class="s1">self.polynomial_trend</span><span class="s2">, </span><span class="s1">self._k_trend</span><span class="s2">, </span><span class="s1">self.nobs</span><span class="s2">, </span><span class="s1">self.trend_offset)</span>

        <span class="s2">return </span><span class="s1">endog</span><span class="s2">, </span><span class="s1">exog</span>

    <span class="s2">def </span><span class="s1">initialize(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Initialize the SARIMAX model. 
 
        Notes 
        ----- 
        These initialization steps must occur following the parent class 
        __init__ function calls. 
        &quot;&quot;&quot;</span>
        <span class="s1">super(SARIMAX</span><span class="s2">, </span><span class="s1">self).initialize()</span>

        <span class="s5"># Cache the indexes of included polynomial orders (for update below)</span>
        <span class="s5"># (but we do not want the index of the constant term, so exclude the</span>
        <span class="s5"># first index)</span>
        <span class="s1">self._polynomial_ar_idx = np.nonzero(self.polynomial_ar)[</span><span class="s3">0</span><span class="s1">][</span><span class="s3">1</span><span class="s1">:]</span>
        <span class="s1">self._polynomial_ma_idx = np.nonzero(self.polynomial_ma)[</span><span class="s3">0</span><span class="s1">][</span><span class="s3">1</span><span class="s1">:]</span>
        <span class="s1">self._polynomial_seasonal_ar_idx = np.nonzero(</span>
            <span class="s1">self.polynomial_seasonal_ar</span>
        <span class="s1">)[</span><span class="s3">0</span><span class="s1">][</span><span class="s3">1</span><span class="s1">:]</span>
        <span class="s1">self._polynomial_seasonal_ma_idx = np.nonzero(</span>
            <span class="s1">self.polynomial_seasonal_ma</span>
        <span class="s1">)[</span><span class="s3">0</span><span class="s1">][</span><span class="s3">1</span><span class="s1">:]</span>

        <span class="s5"># Save the indices corresponding to the reduced form lag polynomial</span>
        <span class="s5"># parameters in the transition and selection matrices so that they</span>
        <span class="s5"># do not have to be recalculated for each update()</span>
        <span class="s1">start_row = self._k_states_diff</span>
        <span class="s1">end_row = start_row + self.k_ar + self.k_seasonal_ar</span>
        <span class="s1">col = self._k_states_diff</span>
        <span class="s2">if not </span><span class="s1">self.hamilton_representation:</span>
            <span class="s1">self.transition_ar_params_idx = (</span>
                <span class="s1">np.s_[</span><span class="s4">'transition'</span><span class="s2">, </span><span class="s1">start_row:end_row</span><span class="s2">, </span><span class="s1">col]</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.transition_ar_params_idx = (</span>
                <span class="s1">np.s_[</span><span class="s4">'transition'</span><span class="s2">, </span><span class="s1">col</span><span class="s2">, </span><span class="s1">start_row:end_row]</span>
            <span class="s1">)</span>

        <span class="s1">start_row += </span><span class="s3">1</span>
        <span class="s1">end_row = start_row + self.k_ma + self.k_seasonal_ma</span>
        <span class="s1">col = </span><span class="s3">0</span>
        <span class="s2">if not </span><span class="s1">self.hamilton_representation:</span>
            <span class="s1">self.selection_ma_params_idx = (</span>
                <span class="s1">np.s_[</span><span class="s4">'selection'</span><span class="s2">, </span><span class="s1">start_row:end_row</span><span class="s2">, </span><span class="s1">col]</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.design_ma_params_idx = (</span>
                <span class="s1">np.s_[</span><span class="s4">'design'</span><span class="s2">, </span><span class="s1">col</span><span class="s2">, </span><span class="s1">start_row:end_row]</span>
            <span class="s1">)</span>

        <span class="s5"># Cache indices for exog variances in the state covariance matrix</span>
        <span class="s2">if </span><span class="s1">self.state_regression </span><span class="s2">and </span><span class="s1">self.time_varying_regression:</span>
            <span class="s1">idx = np.diag_indices(self.k_posdef)</span>
            <span class="s1">self._exog_variance_idx = (</span><span class="s4">'state_cov'</span><span class="s2">, </span><span class="s1">idx[</span><span class="s3">0</span><span class="s1">][-self._k_exog:]</span><span class="s2">,</span>
                                       <span class="s1">idx[</span><span class="s3">1</span><span class="s1">][-self._k_exog:])</span>

    <span class="s2">def </span><span class="s1">initialize_default(self</span><span class="s2">, </span><span class="s1">approximate_diffuse_variance=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Initialize default&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">approximate_diffuse_variance </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">approximate_diffuse_variance = self.ssm.initial_variance</span>
        <span class="s2">if </span><span class="s1">self.use_exact_diffuse:</span>
            <span class="s1">diffuse_type = </span><span class="s4">'diffuse'</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">diffuse_type = </span><span class="s4">'approximate_diffuse'</span>

            <span class="s5"># Set the loglikelihood burn parameter, if not given in constructor</span>
            <span class="s2">if </span><span class="s1">self._loglikelihood_burn </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s1">k_diffuse_states = self.k_states</span>
                <span class="s2">if </span><span class="s1">self.enforce_stationarity:</span>
                    <span class="s1">k_diffuse_states -= self._k_order</span>
                <span class="s1">self.loglikelihood_burn = k_diffuse_states</span>

        <span class="s1">init = Initialization(</span>
            <span class="s1">self.k_states</span><span class="s2">,</span>
            <span class="s1">approximate_diffuse_variance=approximate_diffuse_variance)</span>

        <span class="s2">if </span><span class="s1">self.enforce_stationarity:</span>
            <span class="s5"># Differencing operators are at the beginning</span>
            <span class="s1">init.set((</span><span class="s3">0</span><span class="s2">, </span><span class="s1">self._k_states_diff)</span><span class="s2">, </span><span class="s1">diffuse_type)</span>
            <span class="s5"># Stationary component in the middle</span>
            <span class="s1">init.set((self._k_states_diff</span><span class="s2">,</span>
                      <span class="s1">self._k_states_diff + self._k_order)</span><span class="s2">,</span>
                     <span class="s4">'stationary'</span><span class="s1">)</span>
            <span class="s5"># Regression components at the end</span>
            <span class="s1">init.set((self._k_states_diff + self._k_order</span><span class="s2">,</span>
                      <span class="s1">self._k_states_diff + self._k_order + self._k_exog)</span><span class="s2">,</span>
                     <span class="s1">diffuse_type)</span>
        <span class="s5"># If we're not enforcing a stationarity, then we cannot initialize a</span>
        <span class="s5"># stationary component</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">init.set(</span><span class="s2">None, </span><span class="s1">diffuse_type)</span>

        <span class="s1">self.ssm.initialization = init</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">initial_design(self):</span>
        <span class="s0">&quot;&quot;&quot;Initial design matrix&quot;&quot;&quot;</span>
        <span class="s5"># Basic design matrix</span>
        <span class="s1">design = np.r_[</span>
            <span class="s1">[</span><span class="s3">1</span><span class="s1">] * self._k_diff</span><span class="s2">,</span>
            <span class="s1">([</span><span class="s3">0</span><span class="s1">] * (self.seasonal_periods - </span><span class="s3">1</span><span class="s1">) + [</span><span class="s3">1</span><span class="s1">]) * self._k_seasonal_diff</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">1</span><span class="s1">] * self.state_error</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s1">] * (self._k_order - </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">]</span>

        <span class="s2">if </span><span class="s1">len(design) == </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">design = np.r_[</span><span class="s3">0</span><span class="s1">]</span>

        <span class="s5"># If we have exogenous regressors included as part of the state vector</span>
        <span class="s5"># then the exogenous data is incorporated as a time-varying component</span>
        <span class="s5"># of the design matrix</span>
        <span class="s2">if </span><span class="s1">self.state_regression:</span>
            <span class="s2">if </span><span class="s1">self._k_order &gt; </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s1">design = np.c_[</span>
                    <span class="s1">np.reshape(</span>
                        <span class="s1">np.repeat(design</span><span class="s2">, </span><span class="s1">self.nobs)</span><span class="s2">,</span>
                        <span class="s1">(design.shape[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.nobs)</span>
                    <span class="s1">).T</span><span class="s2">,</span>
                    <span class="s1">self.exog</span>
                <span class="s1">].T[</span><span class="s2">None, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">:]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">design = self.exog.T[</span><span class="s2">None, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">:]</span>
        <span class="s2">return </span><span class="s1">design</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">initial_state_intercept(self):</span>
        <span class="s0">&quot;&quot;&quot;Initial state intercept vector&quot;&quot;&quot;</span>
        <span class="s5"># TODO make this self._k_trend &gt; 1 and adjust the update to take</span>
        <span class="s5"># into account that if the trend is a constant, it is not time-varying</span>
        <span class="s2">if </span><span class="s1">self._k_trend &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">state_intercept = np.zeros((self.k_states</span><span class="s2">, </span><span class="s1">self.nobs))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">state_intercept = np.zeros((self.k_states</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s2">return </span><span class="s1">state_intercept</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">initial_transition(self):</span>
        <span class="s0">&quot;&quot;&quot;Initial transition matrix&quot;&quot;&quot;</span>
        <span class="s1">transition = np.zeros((self.k_states</span><span class="s2">, </span><span class="s1">self.k_states))</span>

        <span class="s5"># Exogenous regressors component</span>
        <span class="s2">if </span><span class="s1">self.state_regression:</span>
            <span class="s1">start = -self._k_exog</span>
            <span class="s5"># T_\beta</span>
            <span class="s1">transition[start:</span><span class="s2">, </span><span class="s1">start:] = np.eye(self._k_exog)</span>

            <span class="s5"># Autoregressive component</span>
            <span class="s1">start = -(self._k_exog + self._k_order)</span>
            <span class="s1">end = -self._k_exog </span><span class="s2">if </span><span class="s1">self._k_exog &gt; </span><span class="s3">0 </span><span class="s2">else None</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s5"># Autoregressive component</span>
            <span class="s1">start = -self._k_order</span>
            <span class="s1">end = </span><span class="s2">None</span>

        <span class="s5"># T_c</span>
        <span class="s2">if </span><span class="s1">self._k_order &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">transition[start:end</span><span class="s2">, </span><span class="s1">start:end] = companion_matrix(self._k_order)</span>
            <span class="s2">if </span><span class="s1">self.hamilton_representation:</span>
                <span class="s1">transition[start:end</span><span class="s2">, </span><span class="s1">start:end] = np.transpose(</span>
                    <span class="s1">companion_matrix(self._k_order)</span>
                <span class="s1">)</span>

        <span class="s5"># Seasonal differencing component</span>
        <span class="s5"># T^*</span>
        <span class="s2">if </span><span class="s1">self._k_seasonal_diff &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">seasonal_companion = companion_matrix(self.seasonal_periods).T</span>
            <span class="s1">seasonal_companion[</span><span class="s3">0</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">] = </span><span class="s3">1</span>
            <span class="s2">for </span><span class="s1">d </span><span class="s2">in </span><span class="s1">range(self._k_seasonal_diff):</span>
                <span class="s1">start = self._k_diff + d * self.seasonal_periods</span>
                <span class="s1">end = self._k_diff + (d + </span><span class="s3">1</span><span class="s1">) * self.seasonal_periods</span>

                <span class="s5"># T_c^*</span>
                <span class="s1">transition[start:end</span><span class="s2">, </span><span class="s1">start:end] = seasonal_companion</span>

                <span class="s5"># i</span>
                <span class="s2">if </span><span class="s1">d &lt; self._k_seasonal_diff - </span><span class="s3">1</span><span class="s1">:</span>
                    <span class="s1">transition[start</span><span class="s2">, </span><span class="s1">end + self.seasonal_periods - </span><span class="s3">1</span><span class="s1">] = </span><span class="s3">1</span>

                <span class="s5"># \iota</span>
                <span class="s1">transition[start</span><span class="s2">, </span><span class="s1">self._k_states_diff] = </span><span class="s3">1</span>

        <span class="s5"># Differencing component</span>
        <span class="s2">if </span><span class="s1">self._k_diff &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">idx = np.triu_indices(self._k_diff)</span>
            <span class="s5"># T^**</span>
            <span class="s1">transition[idx] = </span><span class="s3">1</span>
            <span class="s5"># [0 1]</span>
            <span class="s2">if </span><span class="s1">self.seasonal_periods &gt; </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s1">start = self._k_diff</span>
                <span class="s1">end = self._k_states_diff</span>
                <span class="s1">transition[:self._k_diff</span><span class="s2">, </span><span class="s1">start:end] = (</span>
                    <span class="s1">([</span><span class="s3">0</span><span class="s1">] * (self.seasonal_periods - </span><span class="s3">1</span><span class="s1">) + [</span><span class="s3">1</span><span class="s1">]) *</span>
                    <span class="s1">self._k_seasonal_diff)</span>
            <span class="s5"># [1 0]</span>
            <span class="s1">column = self._k_states_diff</span>
            <span class="s1">transition[:self._k_diff</span><span class="s2">, </span><span class="s1">column] = </span><span class="s3">1</span>

        <span class="s2">return </span><span class="s1">transition</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">initial_selection(self):</span>
        <span class="s0">&quot;&quot;&quot;Initial selection matrix&quot;&quot;&quot;</span>
        <span class="s2">if not </span><span class="s1">(self.state_regression </span><span class="s2">and </span><span class="s1">self.time_varying_regression):</span>
            <span class="s2">if </span><span class="s1">self.k_posdef &gt; </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s1">selection = np.r_[</span>
                    <span class="s1">[</span><span class="s3">0</span><span class="s1">] * (self._k_states_diff)</span><span class="s2">,</span>
                    <span class="s1">[</span><span class="s3">1</span><span class="s1">] * (self._k_order &gt; </span><span class="s3">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0</span><span class="s1">] * (self._k_order - </span><span class="s3">1</span><span class="s1">)</span><span class="s2">,</span>
                    <span class="s1">[</span><span class="s3">0</span><span class="s1">] * ((</span><span class="s3">1 </span><span class="s1">- self.mle_regression) * self._k_exog)</span>
                <span class="s1">][:</span><span class="s2">, None</span><span class="s1">]</span>

                <span class="s2">if </span><span class="s1">len(selection) == </span><span class="s3">0</span><span class="s1">:</span>
                    <span class="s1">selection = np.zeros((self.k_states</span><span class="s2">, </span><span class="s1">self.k_posdef))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">selection = np.zeros((self.k_states</span><span class="s2">, </span><span class="s3">0</span><span class="s1">))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">selection = np.zeros((self.k_states</span><span class="s2">, </span><span class="s1">self.k_posdef))</span>
            <span class="s5"># Typical state variance</span>
            <span class="s2">if </span><span class="s1">self._k_order &gt; </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s1">selection[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">] = </span><span class="s3">1</span>
            <span class="s5"># Time-varying regression coefficient variances</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(self._k_exog</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">):</span>
                <span class="s1">selection[-i</span><span class="s2">, </span><span class="s1">-i] = </span><span class="s3">1</span>
        <span class="s2">return </span><span class="s1">selection</span>

    <span class="s2">def </span><span class="s1">clone(self</span><span class="s2">, </span><span class="s1">endog</span><span class="s2">, </span><span class="s1">exog=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s2">return </span><span class="s1">self._clone_from_init_kwds(endog</span><span class="s2">, </span><span class="s1">exog=exog</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_res_classes(self):</span>
        <span class="s2">return </span><span class="s1">{</span><span class="s4">'fit'</span><span class="s1">: (SARIMAXResults</span><span class="s2">, </span><span class="s1">SARIMAXResultsWrapper)}</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_conditional_sum_squares(endog</span><span class="s2">, </span><span class="s1">k_ar</span><span class="s2">, </span><span class="s1">polynomial_ar</span><span class="s2">, </span><span class="s1">k_ma</span><span class="s2">,</span>
                                 <span class="s1">polynomial_ma</span><span class="s2">, </span><span class="s1">k_trend=</span><span class="s3">0</span><span class="s2">, </span><span class="s1">trend_data=</span><span class="s2">None,</span>
                                 <span class="s1">warning_description=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">k = </span><span class="s3">2 </span><span class="s1">* k_ma</span>
        <span class="s1">r = max(k + k_ma</span><span class="s2">, </span><span class="s1">k_ar)</span>

        <span class="s1">k_params_ar = </span><span class="s3">0 </span><span class="s2">if </span><span class="s1">k_ar == </span><span class="s3">0 </span><span class="s2">else </span><span class="s1">len(polynomial_ar.nonzero()[</span><span class="s3">0</span><span class="s1">]) - </span><span class="s3">1</span>
        <span class="s1">k_params_ma = </span><span class="s3">0 </span><span class="s2">if </span><span class="s1">k_ma == </span><span class="s3">0 </span><span class="s2">else </span><span class="s1">len(polynomial_ma.nonzero()[</span><span class="s3">0</span><span class="s1">]) - </span><span class="s3">1</span>

        <span class="s1">residuals = </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">k_ar + k_ma + k_trend &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s5"># If we have MA terms, get residuals from an AR(k) model to use</span>
                <span class="s5"># as data for conditional sum of squares estimates of the MA</span>
                <span class="s5"># parameters</span>
                <span class="s2">if </span><span class="s1">k_ma &gt; </span><span class="s3">0</span><span class="s1">:</span>
                    <span class="s1">Y = endog[k:]</span>
                    <span class="s1">X = lagmat(endog</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">trim=</span><span class="s4">'both'</span><span class="s1">)</span>
                    <span class="s1">params_ar = np.linalg.pinv(X).dot(Y)</span>
                    <span class="s1">residuals = Y - np.dot(X</span><span class="s2">, </span><span class="s1">params_ar)</span>

                <span class="s5"># Run an ARMA(p,q) model using the just computed residuals as</span>
                <span class="s5"># data</span>
                <span class="s1">Y = endog[r:]</span>

                <span class="s1">X = np.empty((Y.shape[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s3">0</span><span class="s1">))</span>
                <span class="s2">if </span><span class="s1">k_trend &gt; </span><span class="s3">0</span><span class="s1">:</span>
                    <span class="s2">if </span><span class="s1">trend_data </span><span class="s2">is None</span><span class="s1">:</span>
                        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'Trend data must be provided if'</span>
                                         <span class="s4">' `k_trend` &gt; 0.'</span><span class="s1">)</span>
                    <span class="s1">X = np.c_[X</span><span class="s2">, </span><span class="s1">trend_data[:(-r </span><span class="s2">if </span><span class="s1">r &gt; </span><span class="s3">0 </span><span class="s2">else None</span><span class="s1">)</span><span class="s2">, </span><span class="s1">:]]</span>
                <span class="s2">if </span><span class="s1">k_ar &gt; </span><span class="s3">0</span><span class="s1">:</span>
                    <span class="s1">cols = polynomial_ar.nonzero()[</span><span class="s3">0</span><span class="s1">][</span><span class="s3">1</span><span class="s1">:] - </span><span class="s3">1</span>
                    <span class="s1">X = np.c_[X</span><span class="s2">, </span><span class="s1">lagmat(endog</span><span class="s2">, </span><span class="s1">k_ar)[r:</span><span class="s2">, </span><span class="s1">cols]]</span>
                <span class="s2">if </span><span class="s1">k_ma &gt; </span><span class="s3">0</span><span class="s1">:</span>
                    <span class="s1">cols = polynomial_ma.nonzero()[</span><span class="s3">0</span><span class="s1">][</span><span class="s3">1</span><span class="s1">:] - </span><span class="s3">1</span>
                    <span class="s1">X = np.c_[X</span><span class="s2">, </span><span class="s1">lagmat(residuals</span><span class="s2">, </span><span class="s1">k_ma)[r-k:</span><span class="s2">, </span><span class="s1">cols]]</span>

                <span class="s5"># Get the array of [ar_params, ma_params]</span>
                <span class="s1">params = np.linalg.pinv(X).dot(Y)</span>
                <span class="s1">residuals = Y - np.dot(X</span><span class="s2">, </span><span class="s1">params)</span>
            <span class="s2">except </span><span class="s1">ValueError:</span>
                <span class="s2">if </span><span class="s1">warning_description </span><span class="s2">is not None</span><span class="s1">:</span>
                    <span class="s1">warning_description = </span><span class="s4">' for %s' </span><span class="s1">% warning_description</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">warning_description = </span><span class="s4">''</span>
                <span class="s1">warn(</span><span class="s4">'Too few observations to estimate starting parameters%s.'</span>
                     <span class="s4">' All parameters except for variances will be set to'</span>
                     <span class="s4">' zeros.' </span><span class="s1">% warning_description)</span>
                <span class="s5"># Typically this will be raised if there are not enough</span>
                <span class="s5"># observations for the `lagmat` calls.</span>
                <span class="s1">params = np.zeros(k_trend + k_ar + k_ma</span><span class="s2">, </span><span class="s1">dtype=endog.dtype)</span>
                <span class="s2">if </span><span class="s1">len(endog) == </span><span class="s3">0</span><span class="s1">:</span>
                    <span class="s5"># This case usually happens when there are not even enough</span>
                    <span class="s5"># observations for a complete set of differencing</span>
                    <span class="s5"># operations (no hope of fitting, just set starting</span>
                    <span class="s5"># variance to 1)</span>
                    <span class="s1">residuals = np.ones(k_params_ma * </span><span class="s3">2 </span><span class="s1">+ </span><span class="s3">1</span><span class="s2">, </span><span class="s1">dtype=endog.dtype)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">residuals = np.r_[</span>
                        <span class="s1">np.zeros(k_params_ma * </span><span class="s3">2</span><span class="s2">, </span><span class="s1">dtype=endog.dtype)</span><span class="s2">,</span>
                        <span class="s1">endog - np.mean(endog)]</span>

        <span class="s5"># Default output</span>
        <span class="s1">params_trend = []</span>
        <span class="s1">params_ar = []</span>
        <span class="s1">params_ma = []</span>
        <span class="s1">params_variance = []</span>

        <span class="s5"># Get the params</span>
        <span class="s1">offset = </span><span class="s3">0</span>
        <span class="s2">if </span><span class="s1">k_trend &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">params_trend = params[offset:k_trend + offset]</span>
            <span class="s1">offset += k_trend</span>
        <span class="s2">if </span><span class="s1">k_ar &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">params_ar = params[offset:k_params_ar + offset]</span>
            <span class="s1">offset += k_params_ar</span>
        <span class="s2">if </span><span class="s1">k_ma &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">params_ma = params[offset:k_params_ma + offset]</span>
            <span class="s1">offset += k_params_ma</span>
        <span class="s2">if </span><span class="s1">residuals </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">len(residuals) &gt; max(</span><span class="s3">1</span><span class="s2">, </span><span class="s1">k_params_ma):</span>
                <span class="s1">params_variance = (residuals[k_params_ma:] ** </span><span class="s3">2</span><span class="s1">).mean()</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">params_variance = np.var(endog)</span>

        <span class="s2">return </span><span class="s1">(params_trend</span><span class="s2">, </span><span class="s1">params_ar</span><span class="s2">, </span><span class="s1">params_ma</span><span class="s2">,</span>
                <span class="s1">params_variance)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">start_params(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        Starting parameters for maximum likelihood estimation 
        &quot;&quot;&quot;</span>

        <span class="s5"># Perform differencing if necessary (i.e. if simple differencing is</span>
        <span class="s5"># false so that the state-space model will use the entire dataset)</span>
        <span class="s1">trend_data = self._trend_data</span>
        <span class="s2">if not </span><span class="s1">self.simple_differencing </span><span class="s2">and </span><span class="s1">(</span>
           <span class="s1">self._k_diff &gt; </span><span class="s3">0 </span><span class="s2">or </span><span class="s1">self._k_seasonal_diff &gt; </span><span class="s3">0</span><span class="s1">):</span>
            <span class="s1">endog = diff(self.endog</span><span class="s2">, </span><span class="s1">self._k_diff</span><span class="s2">,</span>
                         <span class="s1">self._k_seasonal_diff</span><span class="s2">, </span><span class="s1">self.seasonal_periods)</span>
            <span class="s2">if </span><span class="s1">self.exog </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">exog = diff(self.exog</span><span class="s2">, </span><span class="s1">self._k_diff</span><span class="s2">,</span>
                            <span class="s1">self._k_seasonal_diff</span><span class="s2">, </span><span class="s1">self.seasonal_periods)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">exog = </span><span class="s2">None</span>
            <span class="s1">trend_data = trend_data[:endog.shape[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">:]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">endog = self.endog.copy()</span>
            <span class="s1">exog = self.exog.copy() </span><span class="s2">if </span><span class="s1">self.exog </span><span class="s2">is not None else None</span>
        <span class="s1">endog = endog.squeeze()</span>

        <span class="s5"># Although the Kalman filter can deal with missing values in endog,</span>
        <span class="s5"># conditional sum of squares cannot</span>
        <span class="s2">if </span><span class="s1">np.any(np.isnan(endog)):</span>
            <span class="s1">mask = ~np.isnan(endog).squeeze()</span>
            <span class="s1">endog = endog[mask]</span>
            <span class="s2">if </span><span class="s1">exog </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">exog = exog[mask]</span>
            <span class="s2">if </span><span class="s1">trend_data </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">trend_data = trend_data[mask]</span>

        <span class="s5"># Regression effects via OLS</span>
        <span class="s1">params_exog = []</span>
        <span class="s2">if </span><span class="s1">self._k_exog &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">params_exog = np.linalg.pinv(exog).dot(endog)</span>
            <span class="s1">endog = endog - np.dot(exog</span><span class="s2">, </span><span class="s1">params_exog)</span>
        <span class="s2">if </span><span class="s1">self.state_regression:</span>
            <span class="s1">params_exog = []</span>

        <span class="s5"># Non-seasonal ARMA component and trend</span>
        <span class="s1">(params_trend</span><span class="s2">, </span><span class="s1">params_ar</span><span class="s2">, </span><span class="s1">params_ma</span><span class="s2">,</span>
         <span class="s1">params_variance) = self._conditional_sum_squares(</span>
            <span class="s1">endog</span><span class="s2">, </span><span class="s1">self.k_ar</span><span class="s2">, </span><span class="s1">self.polynomial_ar</span><span class="s2">, </span><span class="s1">self.k_ma</span><span class="s2">,</span>
            <span class="s1">self.polynomial_ma</span><span class="s2">, </span><span class="s1">self._k_trend</span><span class="s2">, </span><span class="s1">trend_data</span><span class="s2">,</span>
            <span class="s1">warning_description=</span><span class="s4">'ARMA and trend'</span><span class="s1">)</span>

        <span class="s5"># If we have estimated non-stationary start parameters but enforce</span>
        <span class="s5"># stationarity is on, start with 0 parameters and warn</span>
        <span class="s1">invalid_ar = (</span>
            <span class="s1">self.k_ar &gt; </span><span class="s3">0 </span><span class="s2">and</span>
            <span class="s1">self.enforce_stationarity </span><span class="s2">and</span>
            <span class="s2">not </span><span class="s1">is_invertible(np.r_[</span><span class="s3">1</span><span class="s2">, </span><span class="s1">-params_ar])</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">invalid_ar:</span>
            <span class="s1">warn(</span><span class="s4">'Non-stationary starting autoregressive parameters'</span>
                 <span class="s4">' found. Using zeros as starting parameters.'</span><span class="s1">)</span>
            <span class="s1">params_ar *= </span><span class="s3">0</span>

        <span class="s5"># If we have estimated non-invertible start parameters but enforce</span>
        <span class="s5"># invertibility is on, raise an error</span>
        <span class="s1">invalid_ma = (</span>
            <span class="s1">self.k_ma &gt; </span><span class="s3">0 </span><span class="s2">and</span>
            <span class="s1">self.enforce_invertibility </span><span class="s2">and</span>
            <span class="s2">not </span><span class="s1">is_invertible(np.r_[</span><span class="s3">1</span><span class="s2">, </span><span class="s1">params_ma])</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">invalid_ma:</span>
            <span class="s1">warn(</span><span class="s4">'Non-invertible starting MA parameters found.'</span>
                 <span class="s4">' Using zeros as starting parameters.'</span><span class="s1">)</span>
            <span class="s1">params_ma *= </span><span class="s3">0</span>

        <span class="s5"># Seasonal Parameters</span>
        <span class="s1">_</span><span class="s2">, </span><span class="s1">params_seasonal_ar</span><span class="s2">, </span><span class="s1">params_seasonal_ma</span><span class="s2">, </span><span class="s1">params_seasonal_variance = (</span>
            <span class="s1">self._conditional_sum_squares(</span>
                <span class="s1">endog</span><span class="s2">, </span><span class="s1">self.k_seasonal_ar</span><span class="s2">, </span><span class="s1">self.polynomial_seasonal_ar</span><span class="s2">,</span>
                <span class="s1">self.k_seasonal_ma</span><span class="s2">, </span><span class="s1">self.polynomial_seasonal_ma</span><span class="s2">,</span>
                <span class="s1">warning_description=</span><span class="s4">'seasonal ARMA'</span><span class="s1">))</span>

        <span class="s5"># If we have estimated non-stationary start parameters but enforce</span>
        <span class="s5"># stationarity is on, warn and set start params to 0</span>
        <span class="s1">invalid_seasonal_ar = (</span>
            <span class="s1">self.k_seasonal_ar &gt; </span><span class="s3">0 </span><span class="s2">and</span>
            <span class="s1">self.enforce_stationarity </span><span class="s2">and</span>
            <span class="s2">not </span><span class="s1">is_invertible(np.r_[</span><span class="s3">1</span><span class="s2">, </span><span class="s1">-params_seasonal_ar])</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">invalid_seasonal_ar:</span>
            <span class="s1">warn(</span><span class="s4">'Non-stationary starting seasonal autoregressive'</span>
                 <span class="s4">' Using zeros as starting parameters.'</span><span class="s1">)</span>
            <span class="s1">params_seasonal_ar *= </span><span class="s3">0</span>

        <span class="s5"># If we have estimated non-invertible start parameters but enforce</span>
        <span class="s5"># invertibility is on, raise an error</span>
        <span class="s1">invalid_seasonal_ma = (</span>
            <span class="s1">self.k_seasonal_ma &gt; </span><span class="s3">0 </span><span class="s2">and</span>
            <span class="s1">self.enforce_invertibility </span><span class="s2">and</span>
            <span class="s2">not </span><span class="s1">is_invertible(np.r_[</span><span class="s3">1</span><span class="s2">, </span><span class="s1">params_seasonal_ma])</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">invalid_seasonal_ma:</span>
            <span class="s1">warn(</span><span class="s4">'Non-invertible starting seasonal moving average'</span>
                 <span class="s4">' Using zeros as starting parameters.'</span><span class="s1">)</span>
            <span class="s1">params_seasonal_ma *= </span><span class="s3">0</span>

        <span class="s5"># Variances</span>
        <span class="s1">params_exog_variance = []</span>
        <span class="s2">if </span><span class="s1">self.state_regression </span><span class="s2">and </span><span class="s1">self.time_varying_regression:</span>
            <span class="s5"># TODO how to set the initial variance parameters?</span>
            <span class="s1">params_exog_variance = [</span><span class="s3">1</span><span class="s1">] * self._k_exog</span>
        <span class="s2">if </span><span class="s1">(self.state_error </span><span class="s2">and </span><span class="s1">type(params_variance) == list </span><span class="s2">and</span>
                <span class="s1">len(params_variance) == </span><span class="s3">0</span><span class="s1">):</span>
            <span class="s2">if not </span><span class="s1">(type(params_seasonal_variance) == list </span><span class="s2">and</span>
                    <span class="s1">len(params_seasonal_variance) == </span><span class="s3">0</span><span class="s1">):</span>
                <span class="s1">params_variance = params_seasonal_variance</span>
            <span class="s2">elif </span><span class="s1">self._k_exog &gt; </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s1">params_variance = np.inner(endog</span><span class="s2">, </span><span class="s1">endog)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">params_variance = np.inner(endog</span><span class="s2">, </span><span class="s1">endog) / self.nobs</span>
        <span class="s1">params_measurement_variance = </span><span class="s3">1 </span><span class="s2">if </span><span class="s1">self.measurement_error </span><span class="s2">else </span><span class="s1">[]</span>

        <span class="s5"># We want to bound the starting variance away from zero</span>
        <span class="s1">params_variance = np.atleast_1d(max(np.array(params_variance)</span><span class="s2">, </span><span class="s3">1e-10</span><span class="s1">))</span>

        <span class="s5"># Remove state variance as parameter if scale is concentrated out</span>
        <span class="s2">if </span><span class="s1">self.concentrate_scale:</span>
            <span class="s1">params_variance = []</span>

        <span class="s5"># Combine all parameters</span>
        <span class="s2">return </span><span class="s1">np.r_[</span>
            <span class="s1">params_trend</span><span class="s2">,</span>
            <span class="s1">params_exog</span><span class="s2">,</span>
            <span class="s1">params_ar</span><span class="s2">,</span>
            <span class="s1">params_ma</span><span class="s2">,</span>
            <span class="s1">params_seasonal_ar</span><span class="s2">,</span>
            <span class="s1">params_seasonal_ma</span><span class="s2">,</span>
            <span class="s1">params_exog_variance</span><span class="s2">,</span>
            <span class="s1">params_measurement_variance</span><span class="s2">,</span>
            <span class="s1">params_variance</span>
        <span class="s1">]</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">endog_names(self</span><span class="s2">, </span><span class="s1">latex=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Names of endogenous variables&quot;&quot;&quot;</span>
        <span class="s1">diff = </span><span class="s4">''</span>
        <span class="s2">if </span><span class="s1">self.k_diff &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.k_diff == </span><span class="s3">1</span><span class="s1">:</span>
                <span class="s1">diff = </span><span class="s4">r'\Delta' </span><span class="s2">if </span><span class="s1">latex </span><span class="s2">else </span><span class="s4">'D'</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">diff = (</span><span class="s4">r'\Delta^%d' </span><span class="s2">if </span><span class="s1">latex </span><span class="s2">else </span><span class="s4">'D%d'</span><span class="s1">) % self.k_diff</span>

        <span class="s1">seasonal_diff = </span><span class="s4">''</span>
        <span class="s2">if </span><span class="s1">self.k_seasonal_diff &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.k_seasonal_diff == </span><span class="s3">1</span><span class="s1">:</span>
                <span class="s1">seasonal_diff = ((</span><span class="s4">r'\Delta_%d' </span><span class="s2">if </span><span class="s1">latex </span><span class="s2">else </span><span class="s4">'DS%d'</span><span class="s1">) %</span>
                                 <span class="s1">(self.seasonal_periods))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">seasonal_diff = ((</span><span class="s4">r'\Delta_%d^%d' </span><span class="s2">if </span><span class="s1">latex </span><span class="s2">else </span><span class="s4">'D%dS%d'</span><span class="s1">) %</span>
                                 <span class="s1">(self.k_seasonal_diff</span><span class="s2">, </span><span class="s1">self.seasonal_periods))</span>
        <span class="s1">endog_diff = self.simple_differencing</span>
        <span class="s2">if </span><span class="s1">endog_diff </span><span class="s2">and </span><span class="s1">self.k_diff &gt; </span><span class="s3">0 </span><span class="s2">and </span><span class="s1">self.k_seasonal_diff &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">((</span><span class="s4">'%s%s %s' </span><span class="s2">if </span><span class="s1">latex </span><span class="s2">else </span><span class="s4">'%s.%s.%s'</span><span class="s1">) %</span>
                    <span class="s1">(diff</span><span class="s2">, </span><span class="s1">seasonal_diff</span><span class="s2">, </span><span class="s1">self.data.ynames))</span>
        <span class="s2">elif </span><span class="s1">endog_diff </span><span class="s2">and </span><span class="s1">self.k_diff &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">((</span><span class="s4">'%s %s' </span><span class="s2">if </span><span class="s1">latex </span><span class="s2">else </span><span class="s4">'%s.%s'</span><span class="s1">) %</span>
                    <span class="s1">(diff</span><span class="s2">, </span><span class="s1">self.data.ynames))</span>
        <span class="s2">elif </span><span class="s1">endog_diff </span><span class="s2">and </span><span class="s1">self.k_seasonal_diff &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">((</span><span class="s4">'%s %s' </span><span class="s2">if </span><span class="s1">latex </span><span class="s2">else </span><span class="s4">'%s.%s'</span><span class="s1">) %</span>
                    <span class="s1">(seasonal_diff</span><span class="s2">, </span><span class="s1">self.data.ynames))</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.data.ynames</span>

    <span class="s1">params_complete = [</span>
        <span class="s4">'trend'</span><span class="s2">, </span><span class="s4">'exog'</span><span class="s2">, </span><span class="s4">'ar'</span><span class="s2">, </span><span class="s4">'ma'</span><span class="s2">, </span><span class="s4">'seasonal_ar'</span><span class="s2">, </span><span class="s4">'seasonal_ma'</span><span class="s2">,</span>
        <span class="s4">'exog_variance'</span><span class="s2">, </span><span class="s4">'measurement_variance'</span><span class="s2">, </span><span class="s4">'variance'</span>
    <span class="s1">]</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">param_terms(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        List of parameters actually included in the model, in sorted order. 
 
        TODO Make this an dict with slice or indices as the values. 
        &quot;&quot;&quot;</span>
        <span class="s1">model_orders = self.model_orders</span>
        <span class="s5"># Get basic list from model orders</span>
        <span class="s1">params = [</span>
            <span class="s1">order </span><span class="s2">for </span><span class="s1">order </span><span class="s2">in </span><span class="s1">self.params_complete</span>
            <span class="s2">if </span><span class="s1">model_orders[order] &gt; </span><span class="s3">0</span>
        <span class="s1">]</span>
        <span class="s5"># k_exog may be positive without associated parameters if it is in the</span>
        <span class="s5"># state vector</span>
        <span class="s2">if </span><span class="s4">'exog' </span><span class="s2">in </span><span class="s1">params </span><span class="s2">and not </span><span class="s1">self.mle_regression:</span>
            <span class="s1">params.remove(</span><span class="s4">'exog'</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">params</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">param_names(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        List of human readable parameter names (for parameters actually 
        included in the model). 
        &quot;&quot;&quot;</span>
        <span class="s1">params_sort_order = self.param_terms</span>
        <span class="s1">model_names = self.model_names</span>
        <span class="s2">return </span><span class="s1">[</span>
            <span class="s1">name </span><span class="s2">for </span><span class="s1">param </span><span class="s2">in </span><span class="s1">params_sort_order </span><span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">model_names[param]</span>
        <span class="s1">]</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">state_names(self):</span>
        <span class="s5"># TODO: we may be able to revisit these states to get somewhat more</span>
        <span class="s5"># informative names, but ultimately probably not much better.</span>
        <span class="s5"># TODO: alternatively, we may be able to get better for certain models,</span>
        <span class="s5"># like pure AR models.</span>
        <span class="s1">k_ar_states = self._k_order</span>
        <span class="s2">if not </span><span class="s1">self.simple_differencing:</span>
            <span class="s1">k_ar_states += (self.seasonal_periods * self._k_seasonal_diff +</span>
                            <span class="s1">self._k_diff)</span>
        <span class="s1">names = [</span><span class="s4">'state.%d' </span><span class="s1">% i </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(k_ar_states)]</span>

        <span class="s2">if </span><span class="s1">self._k_exog &gt; </span><span class="s3">0 </span><span class="s2">and </span><span class="s1">self.state_regression:</span>
            <span class="s1">names += [</span><span class="s4">'beta.%s' </span><span class="s1">% self.exog_names[i]</span>
                      <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(self._k_exog)]</span>

        <span class="s2">return </span><span class="s1">names</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">model_orders(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        The orders of each of the polynomials in the model. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">{</span>
            <span class="s4">'trend'</span><span class="s1">: self._k_trend</span><span class="s2">,</span>
            <span class="s4">'exog'</span><span class="s1">: self._k_exog</span><span class="s2">,</span>
            <span class="s4">'ar'</span><span class="s1">: self.k_ar</span><span class="s2">,</span>
            <span class="s4">'ma'</span><span class="s1">: self.k_ma</span><span class="s2">,</span>
            <span class="s4">'seasonal_ar'</span><span class="s1">: self.k_seasonal_ar</span><span class="s2">,</span>
            <span class="s4">'seasonal_ma'</span><span class="s1">: self.k_seasonal_ma</span><span class="s2">,</span>
            <span class="s4">'reduced_ar'</span><span class="s1">: self.k_ar + self.k_seasonal_ar</span><span class="s2">,</span>
            <span class="s4">'reduced_ma'</span><span class="s1">: self.k_ma + self.k_seasonal_ma</span><span class="s2">,</span>
            <span class="s4">'exog_variance'</span><span class="s1">: self._k_exog </span><span class="s2">if </span><span class="s1">(</span>
                <span class="s1">self.state_regression </span><span class="s2">and </span><span class="s1">self.time_varying_regression) </span><span class="s2">else </span><span class="s3">0</span><span class="s2">,</span>
            <span class="s4">'measurement_variance'</span><span class="s1">: int(self.measurement_error)</span><span class="s2">,</span>
            <span class="s4">'variance'</span><span class="s1">: int(self.state_error </span><span class="s2">and not </span><span class="s1">self.concentrate_scale)</span><span class="s2">,</span>
        <span class="s1">}</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">model_names(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        The plain text names of all possible model parameters. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._get_model_names(latex=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">model_latex_names(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        The latex names of all possible model parameters. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._get_model_names(latex=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_get_model_names(self</span><span class="s2">, </span><span class="s1">latex=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s1">names = {</span>
            <span class="s4">'trend'</span><span class="s1">: </span><span class="s2">None,</span>
            <span class="s4">'exog'</span><span class="s1">: </span><span class="s2">None,</span>
            <span class="s4">'ar'</span><span class="s1">: </span><span class="s2">None,</span>
            <span class="s4">'ma'</span><span class="s1">: </span><span class="s2">None,</span>
            <span class="s4">'seasonal_ar'</span><span class="s1">: </span><span class="s2">None,</span>
            <span class="s4">'seasonal_ma'</span><span class="s1">: </span><span class="s2">None,</span>
            <span class="s4">'reduced_ar'</span><span class="s1">: </span><span class="s2">None,</span>
            <span class="s4">'reduced_ma'</span><span class="s1">: </span><span class="s2">None,</span>
            <span class="s4">'exog_variance'</span><span class="s1">: </span><span class="s2">None,</span>
            <span class="s4">'measurement_variance'</span><span class="s1">: </span><span class="s2">None,</span>
            <span class="s4">'variance'</span><span class="s1">: </span><span class="s2">None,</span>
        <span class="s1">}</span>

        <span class="s5"># Trend</span>
        <span class="s2">if </span><span class="s1">self._k_trend &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">trend_template = </span><span class="s4">'t_%d' </span><span class="s2">if </span><span class="s1">latex </span><span class="s2">else </span><span class="s4">'trend.%d'</span>
            <span class="s1">names[</span><span class="s4">'trend'</span><span class="s1">] = []</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.polynomial_trend.nonzero()[</span><span class="s3">0</span><span class="s1">]:</span>
                <span class="s2">if </span><span class="s1">i == </span><span class="s3">0</span><span class="s1">:</span>
                    <span class="s1">names[</span><span class="s4">'trend'</span><span class="s1">].append(</span><span class="s4">'intercept'</span><span class="s1">)</span>
                <span class="s2">elif </span><span class="s1">i == </span><span class="s3">1</span><span class="s1">:</span>
                    <span class="s1">names[</span><span class="s4">'trend'</span><span class="s1">].append(</span><span class="s4">'drift'</span><span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">names[</span><span class="s4">'trend'</span><span class="s1">].append(trend_template % i)</span>

        <span class="s5"># Exogenous coefficients</span>
        <span class="s2">if </span><span class="s1">self._k_exog &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">names[</span><span class="s4">'exog'</span><span class="s1">] = self.exog_names</span>

        <span class="s5"># Autoregressive</span>
        <span class="s2">if </span><span class="s1">self.k_ar &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">ar_template = </span><span class="s4">'$</span><span class="s2">\\</span><span class="s4">phi_%d$' </span><span class="s2">if </span><span class="s1">latex </span><span class="s2">else </span><span class="s4">'ar.L%d'</span>
            <span class="s1">names[</span><span class="s4">'ar'</span><span class="s1">] = []</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.polynomial_ar.nonzero()[</span><span class="s3">0</span><span class="s1">][</span><span class="s3">1</span><span class="s1">:]:</span>
                <span class="s1">names[</span><span class="s4">'ar'</span><span class="s1">].append(ar_template % i)</span>

        <span class="s5"># Moving Average</span>
        <span class="s2">if </span><span class="s1">self.k_ma &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">ma_template = </span><span class="s4">'$</span><span class="s2">\\</span><span class="s4">theta_%d$' </span><span class="s2">if </span><span class="s1">latex </span><span class="s2">else </span><span class="s4">'ma.L%d'</span>
            <span class="s1">names[</span><span class="s4">'ma'</span><span class="s1">] = []</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.polynomial_ma.nonzero()[</span><span class="s3">0</span><span class="s1">][</span><span class="s3">1</span><span class="s1">:]:</span>
                <span class="s1">names[</span><span class="s4">'ma'</span><span class="s1">].append(ma_template % i)</span>

        <span class="s5"># Seasonal Autoregressive</span>
        <span class="s2">if </span><span class="s1">self.k_seasonal_ar &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">seasonal_ar_template = (</span>
                <span class="s4">'$</span><span class="s2">\\</span><span class="s4">tilde </span><span class="s2">\\</span><span class="s4">phi_%d$' </span><span class="s2">if </span><span class="s1">latex </span><span class="s2">else </span><span class="s4">'ar.S.L%d'</span>
            <span class="s1">)</span>
            <span class="s1">names[</span><span class="s4">'seasonal_ar'</span><span class="s1">] = []</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.polynomial_seasonal_ar.nonzero()[</span><span class="s3">0</span><span class="s1">][</span><span class="s3">1</span><span class="s1">:]:</span>
                <span class="s1">names[</span><span class="s4">'seasonal_ar'</span><span class="s1">].append(seasonal_ar_template % i)</span>

        <span class="s5"># Seasonal Moving Average</span>
        <span class="s2">if </span><span class="s1">self.k_seasonal_ma &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">seasonal_ma_template = (</span>
                <span class="s4">'$</span><span class="s2">\\</span><span class="s4">tilde </span><span class="s2">\\</span><span class="s4">theta_%d$' </span><span class="s2">if </span><span class="s1">latex </span><span class="s2">else </span><span class="s4">'ma.S.L%d'</span>
            <span class="s1">)</span>
            <span class="s1">names[</span><span class="s4">'seasonal_ma'</span><span class="s1">] = []</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">self.polynomial_seasonal_ma.nonzero()[</span><span class="s3">0</span><span class="s1">][</span><span class="s3">1</span><span class="s1">:]:</span>
                <span class="s1">names[</span><span class="s4">'seasonal_ma'</span><span class="s1">].append(seasonal_ma_template % i)</span>

        <span class="s5"># Reduced Form Autoregressive</span>
        <span class="s2">if </span><span class="s1">self.k_ar &gt; </span><span class="s3">0 </span><span class="s2">or </span><span class="s1">self.k_seasonal_ar &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">reduced_polynomial_ar = reduced_polynomial_ar = -np.polymul(</span>
                <span class="s1">self.polynomial_ar</span><span class="s2">, </span><span class="s1">self.polynomial_seasonal_ar</span>
            <span class="s1">)</span>
            <span class="s1">ar_template = </span><span class="s4">'$</span><span class="s2">\\</span><span class="s4">Phi_%d$' </span><span class="s2">if </span><span class="s1">latex </span><span class="s2">else </span><span class="s4">'ar.R.L%d'</span>
            <span class="s1">names[</span><span class="s4">'reduced_ar'</span><span class="s1">] = []</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">reduced_polynomial_ar.nonzero()[</span><span class="s3">0</span><span class="s1">][</span><span class="s3">1</span><span class="s1">:]:</span>
                <span class="s1">names[</span><span class="s4">'reduced_ar'</span><span class="s1">].append(ar_template % i)</span>

        <span class="s5"># Reduced Form Moving Average</span>
        <span class="s2">if </span><span class="s1">self.k_ma &gt; </span><span class="s3">0 </span><span class="s2">or </span><span class="s1">self.k_seasonal_ma &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">reduced_polynomial_ma = np.polymul(</span>
                <span class="s1">self.polynomial_ma</span><span class="s2">, </span><span class="s1">self.polynomial_seasonal_ma</span>
            <span class="s1">)</span>
            <span class="s1">ma_template = </span><span class="s4">'$</span><span class="s2">\\</span><span class="s4">Theta_%d$' </span><span class="s2">if </span><span class="s1">latex </span><span class="s2">else </span><span class="s4">'ma.R.L%d'</span>
            <span class="s1">names[</span><span class="s4">'reduced_ma'</span><span class="s1">] = []</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">reduced_polynomial_ma.nonzero()[</span><span class="s3">0</span><span class="s1">][</span><span class="s3">1</span><span class="s1">:]:</span>
                <span class="s1">names[</span><span class="s4">'reduced_ma'</span><span class="s1">].append(ma_template % i)</span>

        <span class="s5"># Exogenous variances</span>
        <span class="s2">if </span><span class="s1">self.state_regression </span><span class="s2">and </span><span class="s1">self.time_varying_regression:</span>
            <span class="s2">if not </span><span class="s1">self.concentrate_scale:</span>
                <span class="s1">exog_var_template = (</span><span class="s4">'$</span><span class="s2">\\</span><span class="s4">sigma_</span><span class="s2">\\</span><span class="s4">text{%s}^2$' </span><span class="s2">if </span><span class="s1">latex</span>
                                     <span class="s2">else </span><span class="s4">'var.%s'</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">exog_var_template = (</span>
                    <span class="s4">'$</span><span class="s2">\\</span><span class="s4">sigma_</span><span class="s2">\\</span><span class="s4">text{%s}^2 / </span><span class="s2">\\</span><span class="s4">sigma_</span><span class="s2">\\</span><span class="s4">zeta^2$' </span><span class="s2">if </span><span class="s1">latex</span>
                    <span class="s2">else </span><span class="s4">'snr.%s'</span><span class="s1">)</span>
            <span class="s1">names[</span><span class="s4">'exog_variance'</span><span class="s1">] = [</span>
                <span class="s1">exog_var_template % exog_name </span><span class="s2">for </span><span class="s1">exog_name </span><span class="s2">in </span><span class="s1">self.exog_names</span>
            <span class="s1">]</span>

        <span class="s5"># Measurement error variance</span>
        <span class="s2">if </span><span class="s1">self.measurement_error:</span>
            <span class="s2">if not </span><span class="s1">self.concentrate_scale:</span>
                <span class="s1">meas_var_tpl = (</span>
                    <span class="s4">'$</span><span class="s2">\\</span><span class="s4">sigma_</span><span class="s2">\\</span><span class="s4">eta^2$' </span><span class="s2">if </span><span class="s1">latex </span><span class="s2">else </span><span class="s4">'var.measurement_error'</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">meas_var_tpl = (</span>
                    <span class="s4">'$</span><span class="s2">\\</span><span class="s4">sigma_</span><span class="s2">\\</span><span class="s4">eta^2 / </span><span class="s2">\\</span><span class="s4">sigma_</span><span class="s2">\\</span><span class="s4">zeta^2$' </span><span class="s2">if </span><span class="s1">latex</span>
                    <span class="s2">else </span><span class="s4">'snr.measurement_error'</span><span class="s1">)</span>
            <span class="s1">names[</span><span class="s4">'measurement_variance'</span><span class="s1">] = [meas_var_tpl]</span>

        <span class="s5"># State variance</span>
        <span class="s2">if </span><span class="s1">self.state_error </span><span class="s2">and not </span><span class="s1">self.concentrate_scale:</span>
            <span class="s1">var_tpl = </span><span class="s4">'$</span><span class="s2">\\</span><span class="s4">sigma_</span><span class="s2">\\</span><span class="s4">zeta^2$' </span><span class="s2">if </span><span class="s1">latex </span><span class="s2">else </span><span class="s4">'sigma2'</span>
            <span class="s1">names[</span><span class="s4">'variance'</span><span class="s1">] = [var_tpl]</span>

        <span class="s2">return </span><span class="s1">names</span>

    <span class="s2">def </span><span class="s1">transform_params(self</span><span class="s2">, </span><span class="s1">unconstrained):</span>
        <span class="s0">&quot;&quot;&quot; 
        Transform unconstrained parameters used by the optimizer to constrained 
        parameters used in likelihood evaluation. 
 
        Used primarily to enforce stationarity of the autoregressive lag 
        polynomial, invertibility of the moving average lag polynomial, and 
        positive variance parameters. 
 
        Parameters 
        ---------- 
        unconstrained : array_like 
            Unconstrained parameters used by the optimizer. 
 
        Returns 
        ------- 
        constrained : array_like 
            Constrained parameters used in likelihood evaluation. 
 
        Notes 
        ----- 
        If the lag polynomial has non-consecutive powers (so that the 
        coefficient is zero on some element of the polynomial), then the 
        constraint function is not onto the entire space of invertible 
        polynomials, although it only excludes a very small portion very close 
        to the invertibility boundary. 
        &quot;&quot;&quot;</span>
        <span class="s1">unconstrained = np.array(unconstrained</span><span class="s2">, </span><span class="s1">ndmin=</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">constrained = np.zeros(unconstrained.shape</span><span class="s2">, </span><span class="s1">unconstrained.dtype)</span>

        <span class="s1">start = end = </span><span class="s3">0</span>

        <span class="s5"># Retain the trend parameters</span>
        <span class="s2">if </span><span class="s1">self._k_trend &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">end += self._k_trend</span>
            <span class="s1">constrained[start:end] = unconstrained[start:end]</span>
            <span class="s1">start += self._k_trend</span>

        <span class="s5"># Retain any MLE regression coefficients</span>
        <span class="s2">if </span><span class="s1">self.mle_regression:</span>
            <span class="s1">end += self._k_exog</span>
            <span class="s1">constrained[start:end] = unconstrained[start:end]</span>
            <span class="s1">start += self._k_exog</span>

        <span class="s5"># Transform the AR parameters (phi) to be stationary</span>
        <span class="s2">if </span><span class="s1">self.k_ar_params &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">end += self.k_ar_params</span>
            <span class="s2">if </span><span class="s1">self.enforce_stationarity:</span>
                <span class="s1">constrained[start:end] = (</span>
                    <span class="s1">constrain_stationary_univariate(unconstrained[start:end])</span>
                <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">constrained[start:end] = unconstrained[start:end]</span>
            <span class="s1">start += self.k_ar_params</span>

        <span class="s5"># Transform the MA parameters (theta) to be invertible</span>
        <span class="s2">if </span><span class="s1">self.k_ma_params &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">end += self.k_ma_params</span>
            <span class="s2">if </span><span class="s1">self.enforce_invertibility:</span>
                <span class="s1">constrained[start:end] = (</span>
                    <span class="s1">-constrain_stationary_univariate(unconstrained[start:end])</span>
                <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">constrained[start:end] = unconstrained[start:end]</span>
            <span class="s1">start += self.k_ma_params</span>

        <span class="s5"># Transform the seasonal AR parameters (\tilde phi) to be stationary</span>
        <span class="s2">if </span><span class="s1">self.k_seasonal_ar &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">end += self.k_seasonal_ar_params</span>
            <span class="s2">if </span><span class="s1">self.enforce_stationarity:</span>
                <span class="s1">constrained[start:end] = (</span>
                    <span class="s1">constrain_stationary_univariate(unconstrained[start:end])</span>
                <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">constrained[start:end] = unconstrained[start:end]</span>
            <span class="s1">start += self.k_seasonal_ar_params</span>

        <span class="s5"># Transform the seasonal MA parameters (\tilde theta) to be invertible</span>
        <span class="s2">if </span><span class="s1">self.k_seasonal_ma_params &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">end += self.k_seasonal_ma_params</span>
            <span class="s2">if </span><span class="s1">self.enforce_invertibility:</span>
                <span class="s1">constrained[start:end] = (</span>
                    <span class="s1">-constrain_stationary_univariate(unconstrained[start:end])</span>
                <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">constrained[start:end] = unconstrained[start:end]</span>
            <span class="s1">start += self.k_seasonal_ma_params</span>

        <span class="s5"># Transform the standard deviation parameters to be positive</span>
        <span class="s2">if </span><span class="s1">self.state_regression </span><span class="s2">and </span><span class="s1">self.time_varying_regression:</span>
            <span class="s1">end += self._k_exog</span>
            <span class="s1">constrained[start:end] = unconstrained[start:end]**</span><span class="s3">2</span>
            <span class="s1">start += self._k_exog</span>
        <span class="s2">if </span><span class="s1">self.measurement_error:</span>
            <span class="s1">constrained[start] = unconstrained[start]**</span><span class="s3">2</span>
            <span class="s1">start += </span><span class="s3">1</span>
            <span class="s1">end += </span><span class="s3">1</span>
        <span class="s2">if </span><span class="s1">self.state_error </span><span class="s2">and not </span><span class="s1">self.concentrate_scale:</span>
            <span class="s1">constrained[start] = unconstrained[start]**</span><span class="s3">2</span>
            <span class="s5"># start += 1</span>
            <span class="s5"># end += 1</span>

        <span class="s2">return </span><span class="s1">constrained</span>

    <span class="s2">def </span><span class="s1">untransform_params(self</span><span class="s2">, </span><span class="s1">constrained):</span>
        <span class="s0">&quot;&quot;&quot; 
        Transform constrained parameters used in likelihood evaluation 
        to unconstrained parameters used by the optimizer 
 
        Used primarily to reverse enforcement of stationarity of the 
        autoregressive lag polynomial and invertibility of the moving average 
        lag polynomial. 
 
        Parameters 
        ---------- 
        constrained : array_like 
            Constrained parameters used in likelihood evaluation. 
 
        Returns 
        ------- 
        constrained : array_like 
            Unconstrained parameters used by the optimizer. 
 
        Notes 
        ----- 
        If the lag polynomial has non-consecutive powers (so that the 
        coefficient is zero on some element of the polynomial), then the 
        constraint function is not onto the entire space of invertible 
        polynomials, although it only excludes a very small portion very close 
        to the invertibility boundary. 
        &quot;&quot;&quot;</span>
        <span class="s1">constrained = np.array(constrained</span><span class="s2">, </span><span class="s1">ndmin=</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">unconstrained = np.zeros(constrained.shape</span><span class="s2">, </span><span class="s1">constrained.dtype)</span>

        <span class="s1">start = end = </span><span class="s3">0</span>

        <span class="s5"># Retain the trend parameters</span>
        <span class="s2">if </span><span class="s1">self._k_trend &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">end += self._k_trend</span>
            <span class="s1">unconstrained[start:end] = constrained[start:end]</span>
            <span class="s1">start += self._k_trend</span>

        <span class="s5"># Retain any MLE regression coefficients</span>
        <span class="s2">if </span><span class="s1">self.mle_regression:</span>
            <span class="s1">end += self._k_exog</span>
            <span class="s1">unconstrained[start:end] = constrained[start:end]</span>
            <span class="s1">start += self._k_exog</span>

        <span class="s5"># Transform the AR parameters (phi) to be stationary</span>
        <span class="s2">if </span><span class="s1">self.k_ar_params &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">end += self.k_ar_params</span>
            <span class="s2">if </span><span class="s1">self.enforce_stationarity:</span>
                <span class="s1">unconstrained[start:end] = (</span>
                    <span class="s1">unconstrain_stationary_univariate(constrained[start:end])</span>
                <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">unconstrained[start:end] = constrained[start:end]</span>
            <span class="s1">start += self.k_ar_params</span>

        <span class="s5"># Transform the MA parameters (theta) to be invertible</span>
        <span class="s2">if </span><span class="s1">self.k_ma_params &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">end += self.k_ma_params</span>
            <span class="s2">if </span><span class="s1">self.enforce_invertibility:</span>
                <span class="s1">unconstrained[start:end] = (</span>
                    <span class="s1">unconstrain_stationary_univariate(-constrained[start:end])</span>
                <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">unconstrained[start:end] = constrained[start:end]</span>
            <span class="s1">start += self.k_ma_params</span>

        <span class="s5"># Transform the seasonal AR parameters (\tilde phi) to be stationary</span>
        <span class="s2">if </span><span class="s1">self.k_seasonal_ar &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">end += self.k_seasonal_ar_params</span>
            <span class="s2">if </span><span class="s1">self.enforce_stationarity:</span>
                <span class="s1">unconstrained[start:end] = (</span>
                    <span class="s1">unconstrain_stationary_univariate(constrained[start:end])</span>
                <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">unconstrained[start:end] = constrained[start:end]</span>
            <span class="s1">start += self.k_seasonal_ar_params</span>

        <span class="s5"># Transform the seasonal MA parameters (\tilde theta) to be invertible</span>
        <span class="s2">if </span><span class="s1">self.k_seasonal_ma_params &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">end += self.k_seasonal_ma_params</span>
            <span class="s2">if </span><span class="s1">self.enforce_invertibility:</span>
                <span class="s1">unconstrained[start:end] = (</span>
                    <span class="s1">unconstrain_stationary_univariate(-constrained[start:end])</span>
                <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">unconstrained[start:end] = constrained[start:end]</span>
            <span class="s1">start += self.k_seasonal_ma_params</span>

        <span class="s5"># Untransform the standard deviation</span>
        <span class="s2">if </span><span class="s1">self.state_regression </span><span class="s2">and </span><span class="s1">self.time_varying_regression:</span>
            <span class="s1">end += self._k_exog</span>
            <span class="s1">unconstrained[start:end] = constrained[start:end]**</span><span class="s3">0.5</span>
            <span class="s1">start += self._k_exog</span>
        <span class="s2">if </span><span class="s1">self.measurement_error:</span>
            <span class="s1">unconstrained[start] = constrained[start]**</span><span class="s3">0.5</span>
            <span class="s1">start += </span><span class="s3">1</span>
            <span class="s1">end += </span><span class="s3">1</span>
        <span class="s2">if </span><span class="s1">self.state_error </span><span class="s2">and not </span><span class="s1">self.concentrate_scale:</span>
            <span class="s1">unconstrained[start] = constrained[start]**</span><span class="s3">0.5</span>
            <span class="s5"># start += 1</span>
            <span class="s5"># end += 1</span>

        <span class="s2">return </span><span class="s1">unconstrained</span>

    <span class="s2">def </span><span class="s1">_validate_can_fix_params(self</span><span class="s2">, </span><span class="s1">param_names):</span>
        <span class="s1">super(SARIMAX</span><span class="s2">, </span><span class="s1">self)._validate_can_fix_params(param_names)</span>
        <span class="s1">model_names = self.model_names</span>

        <span class="s1">items = [</span>
            <span class="s1">(</span><span class="s4">'ar'</span><span class="s2">, </span><span class="s4">'autoregressive'</span><span class="s2">, </span><span class="s1">self.enforce_stationarity</span><span class="s2">,</span>
                <span class="s4">'`enforce_stationarity=True`'</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s4">'seasonal_ar'</span><span class="s2">, </span><span class="s4">'seasonal autoregressive'</span><span class="s2">,</span>
                <span class="s1">self.enforce_stationarity</span><span class="s2">, </span><span class="s4">'`enforce_stationarity=True`'</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s4">'ma'</span><span class="s2">, </span><span class="s4">'moving average'</span><span class="s2">, </span><span class="s1">self.enforce_invertibility</span><span class="s2">,</span>
                <span class="s4">'`enforce_invertibility=True`'</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s4">'seasonal_ma'</span><span class="s2">, </span><span class="s4">'seasonal moving average'</span><span class="s2">,</span>
                <span class="s1">self.enforce_invertibility</span><span class="s2">, </span><span class="s4">'`enforce_invertibility=True`'</span><span class="s1">)]</span>

        <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">title</span><span class="s2">, </span><span class="s1">condition</span><span class="s2">, </span><span class="s1">condition_desc </span><span class="s2">in </span><span class="s1">items:</span>
            <span class="s1">names = set(model_names[name] </span><span class="s2">or </span><span class="s1">[])</span>
            <span class="s1">fix_all = param_names.issuperset(names)</span>
            <span class="s1">fix_any = len(param_names.intersection(names)) &gt; </span><span class="s3">0</span>
            <span class="s2">if </span><span class="s1">condition </span><span class="s2">and </span><span class="s1">fix_any </span><span class="s2">and not </span><span class="s1">fix_all:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">'Cannot fix individual %s parameters when'</span>
                                 <span class="s4">' %s. Must either fix all %s parameters or'</span>
                                 <span class="s4">' none.' </span><span class="s1">% (title</span><span class="s2">, </span><span class="s1">condition_desc</span><span class="s2">, </span><span class="s1">title))</span>

    <span class="s2">def </span><span class="s1">update(self</span><span class="s2">, </span><span class="s1">params</span><span class="s2">, </span><span class="s1">transformed=</span><span class="s2">True, </span><span class="s1">includes_fixed=</span><span class="s2">False,</span>
               <span class="s1">complex_step=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Update the parameters of the model 
 
        Updates the representation matrices to fill in the new parameter 
        values. 
 
        Parameters 
        ---------- 
        params : array_like 
            Array of new parameters. 
        transformed : bool, optional 
            Whether or not `params` is already transformed. If set to False, 
            `transform_params` is called. Default is True.. 
 
        Returns 
        ------- 
        params : array_like 
            Array of parameters. 
        &quot;&quot;&quot;</span>
        <span class="s1">params = self.handle_params(params</span><span class="s2">, </span><span class="s1">transformed=transformed</span><span class="s2">,</span>
                                    <span class="s1">includes_fixed=includes_fixed)</span>

        <span class="s1">params_trend = </span><span class="s2">None</span>
        <span class="s1">params_exog = </span><span class="s2">None</span>
        <span class="s1">params_ar = </span><span class="s2">None</span>
        <span class="s1">params_ma = </span><span class="s2">None</span>
        <span class="s1">params_seasonal_ar = </span><span class="s2">None</span>
        <span class="s1">params_seasonal_ma = </span><span class="s2">None</span>
        <span class="s1">params_exog_variance = </span><span class="s2">None</span>
        <span class="s1">params_measurement_variance = </span><span class="s2">None</span>
        <span class="s1">params_variance = </span><span class="s2">None</span>

        <span class="s5"># Extract the parameters</span>
        <span class="s1">start = end = </span><span class="s3">0</span>
        <span class="s1">end += self._k_trend</span>
        <span class="s1">params_trend = params[start:end]</span>
        <span class="s1">start += self._k_trend</span>
        <span class="s2">if </span><span class="s1">self.mle_regression:</span>
            <span class="s1">end += self._k_exog</span>
            <span class="s1">params_exog = params[start:end]</span>
            <span class="s1">start += self._k_exog</span>
        <span class="s1">end += self.k_ar_params</span>
        <span class="s1">params_ar = params[start:end]</span>
        <span class="s1">start += self.k_ar_params</span>
        <span class="s1">end += self.k_ma_params</span>
        <span class="s1">params_ma = params[start:end]</span>
        <span class="s1">start += self.k_ma_params</span>
        <span class="s1">end += self.k_seasonal_ar_params</span>
        <span class="s1">params_seasonal_ar = params[start:end]</span>
        <span class="s1">start += self.k_seasonal_ar_params</span>
        <span class="s1">end += self.k_seasonal_ma_params</span>
        <span class="s1">params_seasonal_ma = params[start:end]</span>
        <span class="s1">start += self.k_seasonal_ma_params</span>
        <span class="s2">if </span><span class="s1">self.state_regression </span><span class="s2">and </span><span class="s1">self.time_varying_regression:</span>
            <span class="s1">end += self._k_exog</span>
            <span class="s1">params_exog_variance = params[start:end]</span>
            <span class="s1">start += self._k_exog</span>
        <span class="s2">if </span><span class="s1">self.measurement_error:</span>
            <span class="s1">params_measurement_variance = params[start]</span>
            <span class="s1">start += </span><span class="s3">1</span>
            <span class="s1">end += </span><span class="s3">1</span>
        <span class="s2">if </span><span class="s1">self.state_error </span><span class="s2">and not </span><span class="s1">self.concentrate_scale:</span>
            <span class="s1">params_variance = params[start]</span>
        <span class="s5"># start += 1</span>
        <span class="s5"># end += 1</span>

        <span class="s5"># Update lag polynomials</span>
        <span class="s2">if </span><span class="s1">self.k_ar &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self._polynomial_ar.dtype == params.dtype:</span>
                <span class="s1">self._polynomial_ar[self._polynomial_ar_idx] = -params_ar</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">polynomial_ar = self._polynomial_ar.real.astype(params.dtype)</span>
                <span class="s1">polynomial_ar[self._polynomial_ar_idx] = -params_ar</span>
                <span class="s1">self._polynomial_ar = polynomial_ar</span>

        <span class="s2">if </span><span class="s1">self.k_ma &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self._polynomial_ma.dtype == params.dtype:</span>
                <span class="s1">self._polynomial_ma[self._polynomial_ma_idx] = params_ma</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">polynomial_ma = self._polynomial_ma.real.astype(params.dtype)</span>
                <span class="s1">polynomial_ma[self._polynomial_ma_idx] = params_ma</span>
                <span class="s1">self._polynomial_ma = polynomial_ma</span>

        <span class="s2">if </span><span class="s1">self.k_seasonal_ar &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">idx = self._polynomial_seasonal_ar_idx</span>
            <span class="s2">if </span><span class="s1">self._polynomial_seasonal_ar.dtype == params.dtype:</span>
                <span class="s1">self._polynomial_seasonal_ar[idx] = -params_seasonal_ar</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">polynomial_seasonal_ar = (</span>
                    <span class="s1">self._polynomial_seasonal_ar.real.astype(params.dtype)</span>
                <span class="s1">)</span>
                <span class="s1">polynomial_seasonal_ar[idx] = -params_seasonal_ar</span>
                <span class="s1">self._polynomial_seasonal_ar = polynomial_seasonal_ar</span>

        <span class="s2">if </span><span class="s1">self.k_seasonal_ma &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">idx = self._polynomial_seasonal_ma_idx</span>
            <span class="s2">if </span><span class="s1">self._polynomial_seasonal_ma.dtype == params.dtype:</span>
                <span class="s1">self._polynomial_seasonal_ma[idx] = params_seasonal_ma</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">polynomial_seasonal_ma = (</span>
                    <span class="s1">self._polynomial_seasonal_ma.real.astype(params.dtype)</span>
                <span class="s1">)</span>
                <span class="s1">polynomial_seasonal_ma[idx] = params_seasonal_ma</span>
                <span class="s1">self._polynomial_seasonal_ma = polynomial_seasonal_ma</span>

        <span class="s5"># Get the reduced form lag polynomial terms by multiplying the regular</span>
        <span class="s5"># and seasonal lag polynomials</span>
        <span class="s5"># Note: that although the numpy np.polymul examples assume that they</span>
        <span class="s5"># are ordered from highest degree to lowest, whereas our are from</span>
        <span class="s5"># lowest to highest, it does not matter.</span>
        <span class="s2">if </span><span class="s1">self.k_seasonal_ar &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">reduced_polynomial_ar = -np.polymul(</span>
                <span class="s1">self._polynomial_ar</span><span class="s2">, </span><span class="s1">self._polynomial_seasonal_ar</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">reduced_polynomial_ar = -self._polynomial_ar</span>
        <span class="s2">if </span><span class="s1">self.k_seasonal_ma &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">reduced_polynomial_ma = np.polymul(</span>
                <span class="s1">self._polynomial_ma</span><span class="s2">, </span><span class="s1">self._polynomial_seasonal_ma</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">reduced_polynomial_ma = self._polynomial_ma</span>

        <span class="s5"># Observation intercept</span>
        <span class="s5"># Exogenous data with MLE estimation of parameters enters through a</span>
        <span class="s5"># time-varying observation intercept (is equivalent to simply</span>
        <span class="s5"># subtracting it out of the endogenous variable first)</span>
        <span class="s2">if </span><span class="s1">self.mle_regression:</span>
            <span class="s1">self.ssm[</span><span class="s4">'obs_intercept'</span><span class="s1">] = np.dot(self.exog</span><span class="s2">, </span><span class="s1">params_exog)[</span><span class="s2">None, </span><span class="s1">:]</span>

        <span class="s5"># State intercept (Harvey) or additional observation intercept</span>
        <span class="s5"># (Hamilton)</span>
        <span class="s5"># SARIMA trend enters through the a time-varying state intercept,</span>
        <span class="s5"># associated with the first row of the stationary component of the</span>
        <span class="s5"># state vector (i.e. the first element of the state vector following</span>
        <span class="s5"># any differencing elements)</span>
        <span class="s2">if </span><span class="s1">self._k_trend &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">data = np.dot(self._trend_data</span><span class="s2">, </span><span class="s1">params_trend).astype(params.dtype)</span>
            <span class="s2">if not </span><span class="s1">self.hamilton_representation:</span>
                <span class="s1">self.ssm[</span><span class="s4">'state_intercept'</span><span class="s2">, </span><span class="s1">self._k_states_diff</span><span class="s2">, </span><span class="s1">:] = data</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s5"># The way the trend enters in the Hamilton representation means</span>
                <span class="s5"># that the parameter is not an ``intercept'' but instead the</span>
                <span class="s5"># mean of the process. The trend values in `data` are meant for</span>
                <span class="s5"># an intercept, and so must be transformed to represent the</span>
                <span class="s5"># mean instead</span>
                <span class="s2">if </span><span class="s1">self.hamilton_representation:</span>
                    <span class="s1">data /= np.sum(-reduced_polynomial_ar)</span>

                <span class="s5"># If we already set the observation intercept for MLE</span>
                <span class="s5"># regression, just add to it</span>
                <span class="s2">if </span><span class="s1">self.mle_regression:</span>
                    <span class="s1">self.ssm.obs_intercept += data[</span><span class="s2">None, </span><span class="s1">:]</span>
                <span class="s5"># Otherwise set it directly</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">self.ssm[</span><span class="s4">'obs_intercept'</span><span class="s1">] = data[</span><span class="s2">None, </span><span class="s1">:]</span>

        <span class="s5"># Observation covariance matrix</span>
        <span class="s2">if </span><span class="s1">self.measurement_error:</span>
            <span class="s1">self.ssm[</span><span class="s4">'obs_cov'</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">] = params_measurement_variance</span>

        <span class="s5"># Transition matrix</span>
        <span class="s2">if </span><span class="s1">self.k_ar &gt; </span><span class="s3">0 </span><span class="s2">or </span><span class="s1">self.k_seasonal_ar &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">self.ssm[self.transition_ar_params_idx] = reduced_polynomial_ar[</span><span class="s3">1</span><span class="s1">:]</span>
        <span class="s2">elif not </span><span class="s1">self.ssm.transition.dtype == params.dtype:</span>
            <span class="s5"># This is required if the transition matrix is not really in use</span>
            <span class="s5"># (e.g. for an MA(q) process) so that it's dtype never changes as</span>
            <span class="s5"># the parameters' dtype changes. This changes the dtype manually.</span>
            <span class="s1">self.ssm[</span><span class="s4">'transition'</span><span class="s1">] = self.ssm[</span><span class="s4">'transition'</span><span class="s1">].real.astype(</span>
                <span class="s1">params.dtype)</span>

        <span class="s5"># Selection matrix (Harvey) or Design matrix (Hamilton)</span>
        <span class="s2">if </span><span class="s1">self.k_ma &gt; </span><span class="s3">0 </span><span class="s2">or </span><span class="s1">self.k_seasonal_ma &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s2">if not </span><span class="s1">self.hamilton_representation:</span>
                <span class="s1">self.ssm[self.selection_ma_params_idx] = (</span>
                    <span class="s1">reduced_polynomial_ma[</span><span class="s3">1</span><span class="s1">:]</span>
                <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.ssm[self.design_ma_params_idx] = reduced_polynomial_ma[</span><span class="s3">1</span><span class="s1">:]</span>

        <span class="s5"># State covariance matrix</span>
        <span class="s2">if </span><span class="s1">self.k_posdef &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s2">if not </span><span class="s1">self.concentrate_scale:</span>
                <span class="s1">self[</span><span class="s4">'state_cov'</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">] = params_variance</span>
            <span class="s2">if </span><span class="s1">self.state_regression </span><span class="s2">and </span><span class="s1">self.time_varying_regression:</span>
                <span class="s1">self.ssm[self._exog_variance_idx] = params_exog_variance</span>

        <span class="s2">return </span><span class="s1">params</span>

    <span class="s2">def </span><span class="s1">_get_extension_time_varying_matrices(</span>
            <span class="s1">self</span><span class="s2">, </span><span class="s1">params</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">out_of_sample</span><span class="s2">, </span><span class="s1">extend_kwargs=</span><span class="s2">None,</span>
            <span class="s1">transformed=</span><span class="s2">True, </span><span class="s1">includes_fixed=</span><span class="s2">False, </span><span class="s1">**kwargs):</span>
        <span class="s0">&quot;&quot;&quot; 
        Get time-varying state space system matrices for extended model 
 
        Notes 
        ----- 
        We need to override this method for SARIMAX because we need some 
        special handling in the `simple_differencing=True` case. 
        &quot;&quot;&quot;</span>

        <span class="s5"># Get the appropriate exog for the extended sample</span>
        <span class="s1">exog = self._validate_out_of_sample_exog(exog</span><span class="s2">, </span><span class="s1">out_of_sample)</span>

        <span class="s5"># Get the tmp endog, exog</span>
        <span class="s2">if </span><span class="s1">self.simple_differencing:</span>
            <span class="s1">nobs = self.data.orig_endog.shape[</span><span class="s3">0</span><span class="s1">] + out_of_sample</span>
            <span class="s1">tmp_endog = np.zeros((nobs</span><span class="s2">, </span><span class="s1">self.k_endog))</span>
            <span class="s2">if </span><span class="s1">exog </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">tmp_exog = np.c_[self.data.orig_exog.T</span><span class="s2">, </span><span class="s1">exog.T].T</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">tmp_exog = </span><span class="s2">None</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">tmp_endog = np.zeros((out_of_sample</span><span class="s2">, </span><span class="s1">self.k_endog))</span>
            <span class="s1">tmp_exog = exog</span>

        <span class="s5"># Create extended model</span>
        <span class="s2">if </span><span class="s1">extend_kwargs </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">extend_kwargs = {}</span>
        <span class="s2">if not </span><span class="s1">self.simple_differencing </span><span class="s2">and </span><span class="s1">self.k_trend &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">extend_kwargs.setdefault(</span>
                <span class="s4">'trend_offset'</span><span class="s2">, </span><span class="s1">self.trend_offset + self.nobs)</span>
        <span class="s1">extend_kwargs.setdefault(</span><span class="s4">'validate_specification'</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s1">mod_extend = self.clone(</span>
            <span class="s1">endog=tmp_endog</span><span class="s2">, </span><span class="s1">exog=tmp_exog</span><span class="s2">, </span><span class="s1">**extend_kwargs)</span>
        <span class="s1">mod_extend.update(params</span><span class="s2">, </span><span class="s1">transformed=transformed</span><span class="s2">,</span>
                          <span class="s1">includes_fixed=includes_fixed</span><span class="s2">,</span><span class="s1">)</span>

        <span class="s5"># Retrieve the extensions to the time-varying system matrices and</span>
        <span class="s5"># put them in kwargs</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self.ssm.shapes.keys():</span>
            <span class="s2">if </span><span class="s1">name == </span><span class="s4">'obs' </span><span class="s2">or </span><span class="s1">name </span><span class="s2">in </span><span class="s1">kwargs:</span>
                <span class="s2">continue</span>
            <span class="s1">original = getattr(self.ssm</span><span class="s2">, </span><span class="s1">name)</span>
            <span class="s1">extended = getattr(mod_extend.ssm</span><span class="s2">, </span><span class="s1">name)</span>
            <span class="s1">so = original.shape[-</span><span class="s3">1</span><span class="s1">]</span>
            <span class="s1">se = extended.shape[-</span><span class="s3">1</span><span class="s1">]</span>
            <span class="s2">if </span><span class="s1">((so &gt; </span><span class="s3">1 </span><span class="s2">or </span><span class="s1">se &gt; </span><span class="s3">1</span><span class="s1">) </span><span class="s2">or </span><span class="s1">(</span>
                    <span class="s1">so == </span><span class="s3">1 </span><span class="s2">and </span><span class="s1">self.nobs == </span><span class="s3">1 </span><span class="s2">and</span>
                    <span class="s1">np.any(original[...</span><span class="s2">, </span><span class="s3">0</span><span class="s1">] != extended[...</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]))):</span>
                <span class="s1">kwargs[name] = extended[...</span><span class="s2">, </span><span class="s1">-out_of_sample:]</span>

        <span class="s2">return </span><span class="s1">kwargs</span>


<span class="s2">class </span><span class="s1">SARIMAXResults(MLEResults):</span>
    <span class="s0">&quot;&quot;&quot; 
    Class to hold results from fitting an SARIMAX model. 
 
    Parameters 
    ---------- 
    model : SARIMAX instance 
        The fitted model instance 
 
    Attributes 
    ---------- 
    specification : dictionary 
        Dictionary including all attributes from the SARIMAX model instance. 
    polynomial_ar : ndarray 
        Array containing autoregressive lag polynomial coefficients, 
        ordered from lowest degree to highest. Initialized with ones, unless 
        a coefficient is constrained to be zero (in which case it is zero). 
    polynomial_ma : ndarray 
        Array containing moving average lag polynomial coefficients, 
        ordered from lowest degree to highest. Initialized with ones, unless 
        a coefficient is constrained to be zero (in which case it is zero). 
    polynomial_seasonal_ar : ndarray 
        Array containing seasonal autoregressive lag polynomial coefficients, 
        ordered from lowest degree to highest. Initialized with ones, unless 
        a coefficient is constrained to be zero (in which case it is zero). 
    polynomial_seasonal_ma : ndarray 
        Array containing seasonal moving average lag polynomial coefficients, 
        ordered from lowest degree to highest. Initialized with ones, unless 
        a coefficient is constrained to be zero (in which case it is zero). 
    polynomial_trend : ndarray 
        Array containing trend polynomial coefficients, ordered from lowest 
        degree to highest. Initialized with ones, unless a coefficient is 
        constrained to be zero (in which case it is zero). 
    model_orders : list of int 
        The orders of each of the polynomials in the model. 
    param_terms : list of str 
        List of parameters actually included in the model, in sorted order. 
 
    See Also 
    -------- 
    statsmodels.tsa.statespace.kalman_filter.FilterResults 
    statsmodels.tsa.statespace.mlemodel.MLEResults 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">model</span><span class="s2">, </span><span class="s1">params</span><span class="s2">, </span><span class="s1">filter_results</span><span class="s2">, </span><span class="s1">cov_type=</span><span class="s2">None,</span>
                 <span class="s1">**kwargs):</span>
        <span class="s1">super(SARIMAXResults</span><span class="s2">, </span><span class="s1">self).__init__(model</span><span class="s2">, </span><span class="s1">params</span><span class="s2">, </span><span class="s1">filter_results</span><span class="s2">,</span>
                                             <span class="s1">cov_type</span><span class="s2">, </span><span class="s1">**kwargs)</span>

        <span class="s1">self.df_resid = np.inf  </span><span class="s5"># attribute required for wald tests</span>

        <span class="s5"># Save _init_kwds</span>
        <span class="s1">self._init_kwds = self.model._get_init_kwds()</span>

        <span class="s5"># Save model specification</span>
        <span class="s1">self.specification = Bunch(**{</span>
            <span class="s5"># Set additional model parameters</span>
            <span class="s4">'seasonal_periods'</span><span class="s1">: self.model.seasonal_periods</span><span class="s2">,</span>
            <span class="s4">'measurement_error'</span><span class="s1">: self.model.measurement_error</span><span class="s2">,</span>
            <span class="s4">'time_varying_regression'</span><span class="s1">: self.model.time_varying_regression</span><span class="s2">,</span>
            <span class="s4">'simple_differencing'</span><span class="s1">: self.model.simple_differencing</span><span class="s2">,</span>
            <span class="s4">'enforce_stationarity'</span><span class="s1">: self.model.enforce_stationarity</span><span class="s2">,</span>
            <span class="s4">'enforce_invertibility'</span><span class="s1">: self.model.enforce_invertibility</span><span class="s2">,</span>
            <span class="s4">'hamilton_representation'</span><span class="s1">: self.model.hamilton_representation</span><span class="s2">,</span>
            <span class="s4">'concentrate_scale'</span><span class="s1">: self.model.concentrate_scale</span><span class="s2">,</span>
            <span class="s4">'trend_offset'</span><span class="s1">: self.model.trend_offset</span><span class="s2">,</span>

            <span class="s4">'order'</span><span class="s1">: self.model.order</span><span class="s2">,</span>
            <span class="s4">'seasonal_order'</span><span class="s1">: self.model.seasonal_order</span><span class="s2">,</span>

            <span class="s5"># Model order</span>
            <span class="s4">'k_diff'</span><span class="s1">: self.model.k_diff</span><span class="s2">,</span>
            <span class="s4">'k_seasonal_diff'</span><span class="s1">: self.model.k_seasonal_diff</span><span class="s2">,</span>
            <span class="s4">'k_ar'</span><span class="s1">: self.model.k_ar</span><span class="s2">,</span>
            <span class="s4">'k_ma'</span><span class="s1">: self.model.k_ma</span><span class="s2">,</span>
            <span class="s4">'k_seasonal_ar'</span><span class="s1">: self.model.k_seasonal_ar</span><span class="s2">,</span>
            <span class="s4">'k_seasonal_ma'</span><span class="s1">: self.model.k_seasonal_ma</span><span class="s2">,</span>

            <span class="s5"># Param Numbers</span>
            <span class="s4">'k_ar_params'</span><span class="s1">: self.model.k_ar_params</span><span class="s2">,</span>
            <span class="s4">'k_ma_params'</span><span class="s1">: self.model.k_ma_params</span><span class="s2">,</span>

            <span class="s5"># Trend / Regression</span>
            <span class="s4">'trend'</span><span class="s1">: self.model.trend</span><span class="s2">,</span>
            <span class="s4">'k_trend'</span><span class="s1">: self.model.k_trend</span><span class="s2">,</span>
            <span class="s4">'k_exog'</span><span class="s1">: self.model.k_exog</span><span class="s2">,</span>

            <span class="s4">'mle_regression'</span><span class="s1">: self.model.mle_regression</span><span class="s2">,</span>
            <span class="s4">'state_regression'</span><span class="s1">: self.model.state_regression</span><span class="s2">,</span>
        <span class="s1">})</span>

        <span class="s5"># Polynomials</span>
        <span class="s1">self.polynomial_trend = self.model._polynomial_trend</span>
        <span class="s1">self.polynomial_ar = self.model._polynomial_ar</span>
        <span class="s1">self.polynomial_ma = self.model._polynomial_ma</span>
        <span class="s1">self.polynomial_seasonal_ar = self.model._polynomial_seasonal_ar</span>
        <span class="s1">self.polynomial_seasonal_ma = self.model._polynomial_seasonal_ma</span>
        <span class="s1">self.polynomial_reduced_ar = np.polymul(</span>
            <span class="s1">self.polynomial_ar</span><span class="s2">, </span><span class="s1">self.polynomial_seasonal_ar</span>
        <span class="s1">)</span>
        <span class="s1">self.polynomial_reduced_ma = np.polymul(</span>
            <span class="s1">self.polynomial_ma</span><span class="s2">, </span><span class="s1">self.polynomial_seasonal_ma</span>
        <span class="s1">)</span>

        <span class="s5"># Distinguish parameters</span>
        <span class="s1">self.model_orders = self.model.model_orders</span>
        <span class="s1">self.param_terms = self.model.param_terms</span>
        <span class="s1">start = end = </span><span class="s3">0</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">self.param_terms:</span>
            <span class="s2">if </span><span class="s1">name == </span><span class="s4">'ar'</span><span class="s1">:</span>
                <span class="s1">k = self.model.k_ar_params</span>
            <span class="s2">elif </span><span class="s1">name == </span><span class="s4">'ma'</span><span class="s1">:</span>
                <span class="s1">k = self.model.k_ma_params</span>
            <span class="s2">elif </span><span class="s1">name == </span><span class="s4">'seasonal_ar'</span><span class="s1">:</span>
                <span class="s1">k = self.model.k_seasonal_ar_params</span>
            <span class="s2">elif </span><span class="s1">name == </span><span class="s4">'seasonal_ma'</span><span class="s1">:</span>
                <span class="s1">k = self.model.k_seasonal_ma_params</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">k = self.model_orders[name]</span>
            <span class="s1">end += k</span>
            <span class="s1">setattr(self</span><span class="s2">, </span><span class="s4">'_params_%s' </span><span class="s1">% name</span><span class="s2">, </span><span class="s1">self.params[start:end])</span>
            <span class="s1">start += k</span>
        <span class="s5"># GH7527, all terms must be defined</span>
        <span class="s1">all_terms = [</span><span class="s4">'ar'</span><span class="s2">, </span><span class="s4">'ma'</span><span class="s2">, </span><span class="s4">'seasonal_ar'</span><span class="s2">, </span><span class="s4">'seasonal_ma'</span><span class="s2">, </span><span class="s4">'variance'</span><span class="s1">]</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">set(all_terms).difference(self.param_terms):</span>
            <span class="s1">setattr(self</span><span class="s2">, </span><span class="s4">'_params_%s' </span><span class="s1">% name</span><span class="s2">, </span><span class="s1">np.empty(</span><span class="s3">0</span><span class="s1">))</span>

        <span class="s5"># Handle removing data</span>
        <span class="s1">self._data_attr_model.extend([</span><span class="s4">'orig_endog'</span><span class="s2">, </span><span class="s4">'orig_exog'</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">extend(self</span><span class="s2">, </span><span class="s1">endog</span><span class="s2">, </span><span class="s1">exog=</span><span class="s2">None, </span><span class="s1">**kwargs):</span>
        <span class="s1">kwargs.setdefault(</span><span class="s4">'trend_offset'</span><span class="s2">, </span><span class="s1">self.nobs + </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">super(SARIMAXResults</span><span class="s2">, </span><span class="s1">self).extend(endog</span><span class="s2">, </span><span class="s1">exog=exog</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">arroots(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        (array) Roots of the reduced form autoregressive lag polynomial 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">np.roots(self.polynomial_reduced_ar)**-</span><span class="s3">1</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">maroots(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        (array) Roots of the reduced form moving average lag polynomial 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">np.roots(self.polynomial_reduced_ma)**-</span><span class="s3">1</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">arfreq(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        (array) Frequency of the roots of the reduced form autoregressive 
        lag polynomial 
        &quot;&quot;&quot;</span>
        <span class="s1">z = self.arroots</span>
        <span class="s2">if not </span><span class="s1">z.size:</span>
            <span class="s2">return</span>
        <span class="s2">return </span><span class="s1">np.arctan2(z.imag</span><span class="s2">, </span><span class="s1">z.real) / (</span><span class="s3">2 </span><span class="s1">* np.pi)</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">mafreq(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        (array) Frequency of the roots of the reduced form moving average 
        lag polynomial 
        &quot;&quot;&quot;</span>
        <span class="s1">z = self.maroots</span>
        <span class="s2">if not </span><span class="s1">z.size:</span>
            <span class="s2">return</span>
        <span class="s2">return </span><span class="s1">np.arctan2(z.imag</span><span class="s2">, </span><span class="s1">z.real) / (</span><span class="s3">2 </span><span class="s1">* np.pi)</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">arparams(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        (array) Autoregressive parameters actually estimated in the model. 
        Does not include seasonal autoregressive parameters (see 
        `seasonalarparams`) or parameters whose values are constrained to be 
        zero. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._params_ar</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">seasonalarparams(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        (array) Seasonal autoregressive parameters actually estimated in the 
        model. Does not include nonseasonal autoregressive parameters (see 
        `arparams`) or parameters whose values are constrained to be zero. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._params_seasonal_ar</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">maparams(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        (array) Moving average parameters actually estimated in the model. 
        Does not include seasonal moving average parameters (see 
        `seasonalmaparams`) or parameters whose values are constrained to be 
        zero. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._params_ma</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">seasonalmaparams(self):</span>
        <span class="s0">&quot;&quot;&quot; 
        (array) Seasonal moving average parameters actually estimated in the 
        model. Does not include nonseasonal moving average parameters (see 
        `maparams`) or parameters whose values are constrained to be zero. 
        &quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._params_seasonal_ma</span>

    <span class="s1">@Appender(MLEResults.summary.__doc__)</span>
    <span class="s2">def </span><span class="s1">summary(self</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s3">.05</span><span class="s2">, </span><span class="s1">start=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s5"># Create the model name</span>

        <span class="s5"># See if we have an ARIMA component</span>
        <span class="s1">order = </span><span class="s4">''</span>
        <span class="s2">if </span><span class="s1">self.model.k_ar + self.model.k_diff + self.model.k_ma &gt; </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.model.k_ar == self.model.k_ar_params:</span>
                <span class="s1">order_ar = self.model.k_ar</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">order_ar = list(self.model._spec.ar_lags)</span>
            <span class="s2">if </span><span class="s1">self.model.k_ma == self.model.k_ma_params:</span>
                <span class="s1">order_ma = self.model.k_ma</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">order_ma = list(self.model._spec.ma_lags)</span>
            <span class="s5"># If there is simple differencing, then that is reflected in the</span>
            <span class="s5"># dependent variable name</span>
            <span class="s1">k_diff = </span><span class="s3">0 </span><span class="s2">if </span><span class="s1">self.model.simple_differencing </span><span class="s2">else </span><span class="s1">self.model.k_diff</span>
            <span class="s1">order = </span><span class="s4">'(%s, %d, %s)' </span><span class="s1">% (order_ar</span><span class="s2">, </span><span class="s1">k_diff</span><span class="s2">, </span><span class="s1">order_ma)</span>
        <span class="s5"># See if we have an SARIMA component</span>
        <span class="s1">seasonal_order = </span><span class="s4">''</span>
        <span class="s1">has_seasonal = (</span>
            <span class="s1">self.model.k_seasonal_ar +</span>
            <span class="s1">self.model.k_seasonal_diff +</span>
            <span class="s1">self.model.k_seasonal_ma</span>
        <span class="s1">) &gt; </span><span class="s3">0</span>
        <span class="s2">if </span><span class="s1">has_seasonal:</span>
            <span class="s1">tmp = int(self.model.k_seasonal_ar / self.model.seasonal_periods)</span>
            <span class="s2">if </span><span class="s1">tmp == self.model.k_seasonal_ar_params:</span>
                <span class="s1">order_seasonal_ar = (</span>
                    <span class="s1">int(self.model.k_seasonal_ar / self.model.seasonal_periods)</span>
                <span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">order_seasonal_ar = list(self.model._spec.seasonal_ar_lags)</span>
            <span class="s1">tmp = int(self.model.k_seasonal_ma / self.model.seasonal_periods)</span>
            <span class="s2">if </span><span class="s1">tmp == self.model.k_ma_params:</span>
                <span class="s1">order_seasonal_ma = tmp</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">order_seasonal_ma = list(self.model._spec.seasonal_ma_lags)</span>
            <span class="s5"># If there is simple differencing, then that is reflected in the</span>
            <span class="s5"># dependent variable name</span>
            <span class="s1">k_seasonal_diff = self.model.k_seasonal_diff</span>
            <span class="s2">if </span><span class="s1">self.model.simple_differencing:</span>
                <span class="s1">k_seasonal_diff = </span><span class="s3">0</span>
            <span class="s1">seasonal_order = (</span><span class="s4">'(%s, %d, %s, %d)' </span><span class="s1">%</span>
                              <span class="s1">(str(order_seasonal_ar)</span><span class="s2">, </span><span class="s1">k_seasonal_diff</span><span class="s2">,</span>
                               <span class="s1">str(order_seasonal_ma)</span><span class="s2">,</span>
                               <span class="s1">self.model.seasonal_periods))</span>
            <span class="s2">if not </span><span class="s1">order == </span><span class="s4">''</span><span class="s1">:</span>
                <span class="s1">order += </span><span class="s4">'x'</span>
        <span class="s1">model_name = (</span>
            <span class="s4">'%s%s%s' </span><span class="s1">% (self.model.__class__.__name__</span><span class="s2">, </span><span class="s1">order</span><span class="s2">, </span><span class="s1">seasonal_order)</span>
            <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">super(SARIMAXResults</span><span class="s2">, </span><span class="s1">self).summary(</span>
            <span class="s1">alpha=alpha</span><span class="s2">, </span><span class="s1">start=start</span><span class="s2">, </span><span class="s1">title=</span><span class="s4">'SARIMAX Results'</span><span class="s2">,</span>
            <span class="s1">model_name=model_name</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">SARIMAXResultsWrapper(MLEResultsWrapper):</span>
    <span class="s1">_attrs = {}</span>
    <span class="s1">_wrap_attrs = wrap.union_dicts(MLEResultsWrapper._wrap_attrs</span><span class="s2">,</span>
                                   <span class="s1">_attrs)</span>
    <span class="s1">_methods = {}</span>
    <span class="s1">_wrap_methods = wrap.union_dicts(MLEResultsWrapper._wrap_methods</span><span class="s2">,</span>
                                     <span class="s1">_methods)</span>
<span class="s1">wrap.populate_wrapper(SARIMAXResultsWrapper</span><span class="s2">, </span><span class="s1">SARIMAXResults)  </span><span class="s5"># noqa:E305</span>
</pre>
</body>
</html>