<html>
<head>
<title>test_dynamic_factor_mq_monte_carlo.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6897bb;}
.s4 { color: #6a8759;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_dynamic_factor_mq_monte_carlo.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Monte Carlo-type tests for the BM model 
 
Note that that the actual tests that run are just regression tests against 
previously estimated values with small sample sizes that can be run quickly 
for continuous integration. However, this file can be used to re-run (slow) 
large-sample Monte Carlo tests. 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pandas </span><span class="s2">as </span><span class="s1">pd</span>

<span class="s2">import </span><span class="s1">pytest</span>

<span class="s2">from </span><span class="s1">numpy.testing </span><span class="s2">import </span><span class="s1">assert_allclose</span>
<span class="s2">from </span><span class="s1">scipy.signal </span><span class="s2">import </span><span class="s1">lfilter</span>

<span class="s2">from </span><span class="s1">statsmodels.tsa.statespace </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">dynamic_factor_mq</span><span class="s2">, </span><span class="s1">sarimax</span><span class="s2">, </span><span class="s1">varmax</span><span class="s2">, </span><span class="s1">dynamic_factor)</span>


<span class="s2">def </span><span class="s1">simulate_k_factor1(nobs=</span><span class="s3">1000</span><span class="s1">):</span>
    <span class="s1">mod_sim = dynamic_factor.DynamicFactor(np.zeros((</span><span class="s3">1</span><span class="s2">, </span><span class="s3">4</span><span class="s1">))</span><span class="s2">, </span><span class="s1">k_factors=</span><span class="s3">1</span><span class="s2">,</span>
                                           <span class="s1">factor_order=</span><span class="s3">1</span><span class="s2">, </span><span class="s1">error_order=</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">loadings = [</span><span class="s3">1.0</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.75</span><span class="s2">, </span><span class="s3">0.25</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.3</span><span class="s2">, </span><span class="s3">0.5</span><span class="s1">]</span>
    <span class="s1">p = np.r_[loadings[:mod_sim.k_endog]</span><span class="s2">,</span>
              <span class="s1">[</span><span class="s3">10</span><span class="s1">] * mod_sim.k_endog</span><span class="s2">,</span>
              <span class="s3">0.5</span><span class="s2">,</span>
              <span class="s1">[</span><span class="s3">0.</span><span class="s1">] * mod_sim.k_endog]</span>
    <span class="s1">ix = pd.period_range(start=</span><span class="s4">'1935-01'</span><span class="s2">, </span><span class="s1">periods=nobs</span><span class="s2">, </span><span class="s1">freq=</span><span class="s4">'M'</span><span class="s1">)</span>
    <span class="s1">endog = pd.DataFrame(mod_sim.simulate(p</span><span class="s2">, </span><span class="s1">nobs)</span><span class="s2">, </span><span class="s1">index=ix)</span>

    <span class="s1">true = pd.Series(p</span><span class="s2">, </span><span class="s1">index=mod_sim.param_names)</span>

    <span class="s5"># Compute levels series (M and Q)</span>
    <span class="s1">ix = pd.period_range(start=endog.index[</span><span class="s3">0</span><span class="s1">] - </span><span class="s3">1</span><span class="s2">, </span><span class="s1">end=endog.index[-</span><span class="s3">1</span><span class="s1">]</span><span class="s2">,</span>
                         <span class="s1">freq=endog.index.freq)</span>
    <span class="s1">levels_M = </span><span class="s3">1 </span><span class="s1">+ endog.reindex(ix) / </span><span class="s3">100</span>
    <span class="s1">levels_M.iloc[</span><span class="s3">0</span><span class="s1">] = </span><span class="s3">100</span>
    <span class="s1">levels_M = levels_M.cumprod()</span>
    <span class="s1">log_levels_M = np.log(levels_M) * </span><span class="s3">100</span>
    <span class="s1">log_levels_Q = (np.log(levels_M).resample(</span><span class="s4">'Q'</span><span class="s2">, </span><span class="s1">convention=</span><span class="s4">'e'</span><span class="s1">)</span>
                                    <span class="s1">.sum().iloc[:-</span><span class="s3">1</span><span class="s1">] * </span><span class="s3">100</span><span class="s1">)</span>

    <span class="s5"># This is an alternative way to compute the quarterly levels</span>
    <span class="s5"># endog_M = endog.iloc[:, :3]</span>
    <span class="s5"># x = endog.iloc[:, 3:]</span>
    <span class="s5"># endog_Q = (x + 2 * x.shift(1) + 3 * x.shift(2) + 2 * x.shift(3) +</span>
    <span class="s5">#            x.shift(4)).resample('Q', convention='e').last().iloc[:-1] / 3</span>
    <span class="s5"># levels_Q = 1 + endog.iloc[:, 3:] / 100</span>
    <span class="s5"># levels_Q.iloc[0] = 100</span>

    <span class="s5"># Here is another alternative way to compute the quarterly levels</span>
    <span class="s5"># weights = np.array([1, 2, 3, 2, 1])</span>
    <span class="s5"># def func(x, weights):</span>
    <span class="s5">#     return np.sum(weights * x)</span>
    <span class="s5"># r = endog_M.rolling(5)</span>
    <span class="s5"># (r.apply(func, args=(weights,), raw=False).resample('Q', convention='e')</span>
    <span class="s5">#                                           .last().iloc[:-1].tail())</span>

    <span class="s5"># Compute the growth rate series that we'll actually run the model on</span>
    <span class="s1">endog_M = log_levels_M.iloc[:</span><span class="s2">, </span><span class="s1">:</span><span class="s3">3</span><span class="s1">].diff()</span>
    <span class="s1">endog_Q = log_levels_Q.iloc[:</span><span class="s2">, </span><span class="s3">3</span><span class="s1">:].diff()</span>

    <span class="s2">return </span><span class="s1">endog_M</span><span class="s2">, </span><span class="s1">endog_Q</span><span class="s2">, </span><span class="s1">log_levels_M</span><span class="s2">, </span><span class="s1">log_levels_Q</span><span class="s2">, </span><span class="s1">true</span>


<span class="s2">def </span><span class="s1">simulate_k_factors3_blocks2(nobs=</span><span class="s3">1000</span><span class="s2">, </span><span class="s1">idiosyncratic_ar1=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s5"># Simulate the first two factors</span>
    <span class="s1">ix = pd.period_range(start=</span><span class="s4">'2000-01'</span><span class="s2">, </span><span class="s1">periods=</span><span class="s3">1</span><span class="s2">, </span><span class="s1">freq=</span><span class="s4">'M'</span><span class="s1">)</span>
    <span class="s1">endog = pd.DataFrame(np.zeros((</span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s1">))</span><span class="s2">, </span><span class="s1">columns=[</span><span class="s4">'f1'</span><span class="s2">, </span><span class="s4">'f2'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">index=ix)</span>
    <span class="s1">mod_f_12 = varmax.VARMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s4">'n'</span><span class="s1">)</span>
    <span class="s1">params = [</span><span class="s3">0.5</span><span class="s2">, </span><span class="s3">0.1</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.2</span><span class="s2">, </span><span class="s3">0.9</span><span class="s2">, </span><span class="s3">1.0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1.0</span><span class="s1">]</span>
    <span class="s1">f_12 = mod_f_12.simulate(params</span><span class="s2">, </span><span class="s1">nobs)</span>

    <span class="s5"># Simulate the third factor</span>
    <span class="s1">endog = pd.Series([</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name=</span><span class="s4">'f3'</span><span class="s2">, </span><span class="s1">index=ix)</span>
    <span class="s1">mod_f_3 = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s3">2</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">))</span>
    <span class="s1">params = [</span><span class="s3">0.7</span><span class="s2">, </span><span class="s3">0.1</span><span class="s2">, </span><span class="s3">1.</span><span class="s1">]</span>
    <span class="s1">f_3 = mod_f_3.simulate(params</span><span class="s2">, </span><span class="s1">nobs)</span>

    <span class="s5"># Combine the factors</span>
    <span class="s1">f = pd.concat([f_12</span><span class="s2">, </span><span class="s1">f_3]</span><span class="s2">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">)</span>

    <span class="s5"># Observed variables</span>
    <span class="s1">k_endog = </span><span class="s3">8</span>
    <span class="s1">design = np.zeros((k_endog</span><span class="s2">, </span><span class="s3">3</span><span class="s1">))</span>
    <span class="s1">design[</span><span class="s3">0</span><span class="s1">] = [</span><span class="s3">1.0</span><span class="s2">, </span><span class="s3">1.0</span><span class="s2">, </span><span class="s3">1.0</span><span class="s1">]</span>
    <span class="s1">design[</span><span class="s3">1</span><span class="s1">] = [</span><span class="s3">0.5</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.8</span><span class="s2">, </span><span class="s3">0.0</span><span class="s1">]</span>
    <span class="s1">design[</span><span class="s3">2</span><span class="s1">] = [</span><span class="s3">1.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s1">]</span>
    <span class="s1">design[</span><span class="s3">3</span><span class="s1">] = [</span><span class="s3">0.2</span><span class="s2">, </span><span class="s3">0.0</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.1</span><span class="s1">]</span>
    <span class="s1">design[</span><span class="s3">4</span><span class="s1">] = [</span><span class="s3">0.5</span><span class="s2">, </span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s1">]</span>
    <span class="s1">design[</span><span class="s3">5</span><span class="s1">] = [-</span><span class="s3">0.2</span><span class="s2">, </span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s1">]</span>
    <span class="s1">design[</span><span class="s3">6</span><span class="s1">] = [</span><span class="s3">1.0</span><span class="s2">, </span><span class="s3">1.0</span><span class="s2">, </span><span class="s3">1.0</span><span class="s1">]</span>
    <span class="s1">design[</span><span class="s3">7</span><span class="s1">] = [-</span><span class="s3">1.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.0</span><span class="s1">]</span>

    <span class="s1">rho = np.array([</span><span class="s3">0.5</span><span class="s2">, </span><span class="s3">0.2</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.1</span><span class="s2">, </span><span class="s3">0.0</span><span class="s2">, </span><span class="s3">0.4</span><span class="s2">, </span><span class="s3">0.9</span><span class="s2">, </span><span class="s3">0.05</span><span class="s2">, </span><span class="s3">0.05</span><span class="s1">])</span>
    <span class="s2">if not </span><span class="s1">idiosyncratic_ar1:</span>
        <span class="s1">rho *= </span><span class="s3">0.0</span>
    <span class="s1">eps = [lfilter([</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s1">-rho[i]]</span><span class="s2">, </span><span class="s1">np.random.normal(size=nobs))</span>
           <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(k_endog)]</span>
    <span class="s1">endog = (design @ f.T).T + eps</span>
    <span class="s1">endog.columns = [</span><span class="s4">f'y</span><span class="s2">{</span><span class="s1">i + </span><span class="s3">1</span><span class="s2">}</span><span class="s4">' </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(k_endog)]</span>

    <span class="s5"># True parameters</span>
    <span class="s1">tmp1 = design.ravel()</span>
    <span class="s1">tmp2 = np.linalg.cholesky(mod_f_12[</span><span class="s4">'state_cov'</span><span class="s1">])</span>
    <span class="s1">tmp3 = rho </span><span class="s2">if </span><span class="s1">idiosyncratic_ar1 </span><span class="s2">else </span><span class="s1">[]</span>
    <span class="s1">true = np.r_[</span>
        <span class="s1">tmp1[tmp1 != </span><span class="s3">0</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">mod_f_12[</span><span class="s4">'transition'</span><span class="s2">, </span><span class="s1">:</span><span class="s3">2</span><span class="s2">, </span><span class="s1">:].ravel()</span><span class="s2">,</span>
        <span class="s1">mod_f_3[</span><span class="s4">'transition'</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">tmp2[np.tril_indices_from(tmp2)]</span><span class="s2">,</span>
        <span class="s1">mod_f_3[</span><span class="s4">'state_cov'</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">tmp3</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">1</span><span class="s1">] * k_endog</span>
    <span class="s1">]</span>

    <span class="s5"># Compute levels series (M and Q)</span>
    <span class="s1">ix = pd.period_range(endog.index[</span><span class="s3">0</span><span class="s1">] - </span><span class="s3">1</span><span class="s2">, </span><span class="s1">endog.index[-</span><span class="s3">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">freq=</span><span class="s4">'M'</span><span class="s1">)</span>
    <span class="s1">levels_M = </span><span class="s3">1 </span><span class="s1">+ endog.reindex(ix) / </span><span class="s3">100</span>
    <span class="s1">levels_M.iloc[</span><span class="s3">0</span><span class="s1">] = </span><span class="s3">100</span>
    <span class="s1">levels_M = levels_M.cumprod()</span>
    <span class="s1">log_levels_M = np.log(levels_M) * </span><span class="s3">100</span>
    <span class="s1">log_levels_Q = (np.log(levels_M).resample(</span><span class="s4">'Q'</span><span class="s2">, </span><span class="s1">convention=</span><span class="s4">'e'</span><span class="s1">)</span>
                                    <span class="s1">.sum().iloc[:-</span><span class="s3">1</span><span class="s1">] * </span><span class="s3">100</span><span class="s1">)</span>

    <span class="s5"># Compute the growth rate series that we'll actually run the model on</span>
    <span class="s1">endog_M = log_levels_M.iloc[:</span><span class="s2">, </span><span class="s1">:</span><span class="s3">7</span><span class="s1">].diff().iloc[</span><span class="s3">1</span><span class="s1">:]</span>
    <span class="s1">endog_Q = log_levels_Q.iloc[:</span><span class="s2">, </span><span class="s3">7</span><span class="s1">:].diff().iloc[</span><span class="s3">2</span><span class="s1">:]</span>

    <span class="s5"># Specification</span>
    <span class="s1">factor_names = np.array([</span><span class="s4">'global'</span><span class="s2">, </span><span class="s4">'second'</span><span class="s2">, </span><span class="s4">'third'</span><span class="s1">])</span>
    <span class="s1">factors = {endog.columns[i]: factor_names[design[i] != </span><span class="s3">0</span><span class="s1">]</span>
               <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(k_endog)}</span>

    <span class="s1">factor_orders = {</span>
        <span class="s1">(</span><span class="s4">'global'</span><span class="s2">, </span><span class="s4">'second'</span><span class="s1">): </span><span class="s3">1</span><span class="s2">,</span>
        <span class="s4">'third'</span><span class="s1">: </span><span class="s3">2</span><span class="s2">,</span>
    <span class="s1">}</span>

    <span class="s2">return </span><span class="s1">(endog_M</span><span class="s2">, </span><span class="s1">endog_Q</span><span class="s2">, </span><span class="s1">log_levels_M</span><span class="s2">, </span><span class="s1">log_levels_Q</span><span class="s2">, </span><span class="s1">factors</span><span class="s2">,</span>
            <span class="s1">factor_orders</span><span class="s2">, </span><span class="s1">true</span><span class="s2">, </span><span class="s1">f)</span>


<span class="s1">@pytest.mark.skip(reason=</span><span class="s4">&quot;Monte carlo test, very slow, kept for manual runs&quot;</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_k_factor1(reset_randomstate):</span>
    <span class="s5"># Fitted parameters for np.random.seed(1234) replicate the true parameters</span>
    <span class="s5"># pretty well (flipped signs on loadings are just from usual factor sign</span>
    <span class="s5"># identification issue):</span>
    <span class="s5">#                       True  Fitted</span>
    <span class="s5"># loading.0-&gt;0          1.00   -0.98</span>
    <span class="s5"># loading.0-&gt;1         -0.75    0.75</span>
    <span class="s5"># loading.0)-&gt;2         0.25   -0.24</span>
    <span class="s5"># loading.0-&gt;3         -0.30    0.31</span>
    <span class="s5"># L1.0-&gt;0               0.50    0.50</span>
    <span class="s5"># sigma2.0             10.00   10.07</span>
    <span class="s5"># sigma2.1             10.00   10.06</span>
    <span class="s5"># sigma2.2             10.00    9.94</span>
    <span class="s5"># sigma2.3             10.00   11.60</span>
    <span class="s1">np.random.seed(</span><span class="s3">1234</span><span class="s1">)</span>
    <span class="s1">endog_M</span><span class="s2">, </span><span class="s1">endog_Q</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">true_params</span><span class="s2">, </span><span class="s1">_ = simulate_k_factor1(nobs=</span><span class="s3">100000</span><span class="s1">)</span>

    <span class="s1">mod = dynamic_factor_mq.DynamicFactorMQ(</span>
        <span class="s1">endog_M</span><span class="s2">, </span><span class="s1">endog_quarterly=endog_Q</span><span class="s2">, </span><span class="s1">factors=</span><span class="s3">1</span><span class="s2">, </span><span class="s1">factor_orders=</span><span class="s3">1</span><span class="s2">,</span>
        <span class="s1">idiosyncratic_ar1=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s5"># Fit the model with L-BFGS. Because the model doesn't impose identifying</span>
    <span class="s5"># assumptions on the factors, here we force identification by fixing the</span>
    <span class="s5"># factor error variance to be unity</span>
    <span class="s2">with </span><span class="s1">mod.fix_params({</span><span class="s4">'fb(0).cov.chol[1,1]'</span><span class="s1">: </span><span class="s3">1.</span><span class="s1">}):</span>
        <span class="s1">mod.fit(method=</span><span class="s4">'lbfgs'</span><span class="s2">, </span><span class="s1">disp=</span><span class="s2">False</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">gen_k_factor1_nonstationary(nobs=</span><span class="s3">1000</span><span class="s2">, </span><span class="s1">k=</span><span class="s3">1</span><span class="s2">, </span><span class="s1">idiosyncratic_ar1=</span><span class="s2">False,</span>
                                <span class="s1">idiosyncratic_var=</span><span class="s3">0.4</span><span class="s2">, </span><span class="s1">k_ar=</span><span class="s3">1</span><span class="s1">):</span>
    <span class="s5"># Simulate univariate random walk</span>
    <span class="s1">ix = pd.period_range(start=</span><span class="s4">'1950-01'</span><span class="s2">, </span><span class="s1">periods=</span><span class="s3">1</span><span class="s2">, </span><span class="s1">freq=</span><span class="s4">'M'</span><span class="s1">)</span>
    <span class="s1">faux = pd.Series([</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">index=ix)</span>
    <span class="s1">mod = sarimax.SARIMAX(faux</span><span class="s2">, </span><span class="s1">order=(k_ar</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">initialization=</span><span class="s4">'diffuse'</span><span class="s1">)</span>

    <span class="s1">params = np.r_[[</span><span class="s3">0</span><span class="s1">] * (k_ar - </span><span class="s3">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">[</span><span class="s3">1.0001</span><span class="s1">]</span><span class="s2">, </span><span class="s3">1.0</span><span class="s1">]</span>
    <span class="s1">factor = mod.simulate(params</span><span class="s2">, </span><span class="s1">nobs)</span>

    <span class="s2">if </span><span class="s1">idiosyncratic_ar1:</span>
        <span class="s1">mod_idio = sarimax.SARIMAX(faux</span><span class="s2">, </span><span class="s1">order=(</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">))</span>
        <span class="s1">endog = pd.concat([</span>
            <span class="s1">factor + mod_idio.simulate([</span><span class="s3">0.7</span><span class="s2">, </span><span class="s1">idiosyncratic_var]</span><span class="s2">, </span><span class="s1">nobs)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s3">2 </span><span class="s1">* k)]</span><span class="s2">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">endog = pd.concat([</span>
            <span class="s1">factor + np.random.normal(scale=idiosyncratic_var**</span><span class="s3">0.5</span><span class="s2">, </span><span class="s1">size=nobs)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s3">2 </span><span class="s1">* k)]</span><span class="s2">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">)</span>

    <span class="s5"># Construct the quarterly variable</span>
    <span class="s1">levels_M = </span><span class="s3">1 </span><span class="s1">+ endog / </span><span class="s3">100</span>
    <span class="s1">levels_M.iloc[</span><span class="s3">0</span><span class="s1">] = </span><span class="s3">100</span>
    <span class="s1">levels_M = levels_M.cumprod()</span>
    <span class="s1">log_levels_M = np.log(levels_M) * </span><span class="s3">100</span>
    <span class="s1">log_levels_Q = (np.log(levels_M).resample(</span><span class="s4">'Q'</span><span class="s2">, </span><span class="s1">convention=</span><span class="s4">'e'</span><span class="s1">)</span>
                                    <span class="s1">.sum().iloc[:-</span><span class="s3">1</span><span class="s1">] * </span><span class="s3">100</span><span class="s1">)</span>

    <span class="s5"># Compute the growth rate series that we'll actually run the model on</span>
    <span class="s1">endog_M = log_levels_M.diff().iloc[</span><span class="s3">1</span><span class="s1">:</span><span class="s2">, </span><span class="s1">:k]</span>
    <span class="s2">if </span><span class="s1">k &gt; </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s1">endog_M.columns = [</span><span class="s4">'yM%d_f1' </span><span class="s1">% (i + </span><span class="s3">1</span><span class="s1">) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(k)]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">endog_M.columns = [</span><span class="s4">'yM_f1'</span><span class="s1">]</span>
    <span class="s1">endog_Q = log_levels_Q.diff().iloc[</span><span class="s3">1</span><span class="s1">:</span><span class="s2">, </span><span class="s1">k:]</span>
    <span class="s2">if </span><span class="s1">k &gt; </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s1">endog_Q.columns = [</span><span class="s4">'yQ%d_f1' </span><span class="s1">% (i + </span><span class="s3">1</span><span class="s1">) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(k)]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">endog_Q.columns = [</span><span class="s4">'yQ_f1'</span><span class="s1">]</span>

    <span class="s2">return </span><span class="s1">endog_M</span><span class="s2">, </span><span class="s1">endog_Q</span><span class="s2">, </span><span class="s1">factor</span>


<span class="s2">def </span><span class="s1">test_em_nonstationary(reset_randomstate):</span>
    <span class="s5"># Test that when the EM algorithm estimates non-stationary parameters, that</span>
    <span class="s5"># it warns the user and switches to a diffuse initialization.</span>
    <span class="s1">ix = pd.period_range(start=</span><span class="s4">'2000'</span><span class="s2">, </span><span class="s1">periods=</span><span class="s3">20</span><span class="s2">, </span><span class="s1">freq=</span><span class="s4">'M'</span><span class="s1">)</span>
    <span class="s1">endog_M = pd.Series(np.arange(</span><span class="s3">20</span><span class="s1">)</span><span class="s2">, </span><span class="s1">index=ix)</span>
    <span class="s1">endog_M.iloc[</span><span class="s3">10</span><span class="s1">:</span><span class="s3">12</span><span class="s1">] += [</span><span class="s3">0.4</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.2</span><span class="s1">]  </span><span class="s5"># add in a little noise</span>
    <span class="s1">ix = pd.period_range(start=</span><span class="s4">'2000'</span><span class="s2">, </span><span class="s1">periods=</span><span class="s3">5</span><span class="s2">, </span><span class="s1">freq=</span><span class="s4">'Q'</span><span class="s1">)</span>
    <span class="s1">endog_Q = pd.Series(np.arange(</span><span class="s3">5</span><span class="s1">)</span><span class="s2">, </span><span class="s1">index=ix)</span>

    <span class="s1">mod = dynamic_factor_mq.DynamicFactorMQ(</span>
        <span class="s1">endog_M</span><span class="s2">, </span><span class="s1">endog_quarterly=endog_Q</span><span class="s2">, </span><span class="s1">idiosyncratic_ar1=</span><span class="s2">False,</span>
        <span class="s1">standardize=</span><span class="s2">False, </span><span class="s1">factors=[</span><span class="s4">'global'</span><span class="s1">])</span>
    <span class="s1">msg = (</span><span class="s4">'Non-stationary parameters found at EM iteration 1, which is not'</span>
           <span class="s4">' compatible with stationary initialization. Initialization was'</span>
           <span class="s4">r' switched to diffuse for the following:  \[&quot;factor block:'</span>
           <span class="s4">r' \(\'global\',\)&quot;\], and fitting was restarted.'</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.warns(UserWarning</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s2">return </span><span class="s1">mod.fit(maxiter=</span><span class="s3">2</span><span class="s2">, </span><span class="s1">em_initialization=</span><span class="s2">False</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">gen_k_factor1(nobs=</span><span class="s3">10000</span><span class="s2">, </span><span class="s1">k=</span><span class="s3">1</span><span class="s2">, </span><span class="s1">idiosyncratic_ar1=</span><span class="s2">False,</span>
                  <span class="s1">idiosyncratic_var=</span><span class="s3">0.4</span><span class="s2">, </span><span class="s1">k_ar=</span><span class="s3">6</span><span class="s1">):</span>
    <span class="s5"># Simulate univariate AR(6)</span>
    <span class="s1">ix = pd.period_range(start=</span><span class="s4">'1950-01'</span><span class="s2">, </span><span class="s1">periods=</span><span class="s3">1</span><span class="s2">, </span><span class="s1">freq=</span><span class="s4">'M'</span><span class="s1">)</span>
    <span class="s1">faux = pd.Series([</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">index=ix)</span>
    <span class="s1">mod = sarimax.SARIMAX(faux</span><span class="s2">, </span><span class="s1">order=(k_ar</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">))</span>

    <span class="s1">params = np.r_[[</span><span class="s3">0</span><span class="s1">] * (k_ar - </span><span class="s3">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">[</span><span class="s3">0.5</span><span class="s1">]</span><span class="s2">, </span><span class="s3">1.0</span><span class="s1">]</span>
    <span class="s1">factor = mod.simulate(params</span><span class="s2">, </span><span class="s1">nobs)</span>

    <span class="s2">if </span><span class="s1">idiosyncratic_ar1:</span>
        <span class="s1">mod_idio = sarimax.SARIMAX(faux</span><span class="s2">, </span><span class="s1">order=(</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">))</span>
        <span class="s1">endog = pd.concat([</span>
            <span class="s1">factor + mod_idio.simulate([</span><span class="s3">0.7</span><span class="s2">, </span><span class="s1">idiosyncratic_var]</span><span class="s2">, </span><span class="s1">nobs)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s3">2 </span><span class="s1">* k)]</span><span class="s2">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">endog = pd.concat([</span>
            <span class="s1">factor + np.random.normal(scale=idiosyncratic_var**</span><span class="s3">0.5</span><span class="s2">, </span><span class="s1">size=nobs)</span>
            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s3">2 </span><span class="s1">* k)]</span><span class="s2">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">)</span>

    <span class="s5"># Construct the quarterly variable</span>
    <span class="s1">levels_M = </span><span class="s3">1 </span><span class="s1">+ endog / </span><span class="s3">100</span>
    <span class="s1">levels_M.iloc[</span><span class="s3">0</span><span class="s1">] = </span><span class="s3">100</span>
    <span class="s1">levels_M = levels_M.cumprod()</span>
    <span class="s1">log_levels_M = np.log(levels_M) * </span><span class="s3">100</span>
    <span class="s1">log_levels_Q = (np.log(levels_M).resample(</span><span class="s4">'Q'</span><span class="s2">, </span><span class="s1">convention=</span><span class="s4">'e'</span><span class="s1">)</span>
                                    <span class="s1">.sum().iloc[:-</span><span class="s3">1</span><span class="s1">] * </span><span class="s3">100</span><span class="s1">)</span>

    <span class="s5"># Compute the growth rate series that we'll actually run the model on</span>
    <span class="s1">endog_M = log_levels_M.diff().iloc[</span><span class="s3">1</span><span class="s1">:</span><span class="s2">, </span><span class="s1">:k]</span>
    <span class="s2">if </span><span class="s1">k &gt; </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s1">endog_M.columns = [</span><span class="s4">'yM%d_f1' </span><span class="s1">% (i + </span><span class="s3">1</span><span class="s1">) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(k)]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">endog_M.columns = [</span><span class="s4">'yM_f1'</span><span class="s1">]</span>
    <span class="s1">endog_Q = log_levels_Q.diff().iloc[</span><span class="s3">1</span><span class="s1">:</span><span class="s2">, </span><span class="s1">k:]</span>
    <span class="s2">if </span><span class="s1">k &gt; </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s1">endog_Q.columns = [</span><span class="s4">'yQ%d_f1' </span><span class="s1">% (i + </span><span class="s3">1</span><span class="s1">) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(k)]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">endog_Q.columns = [</span><span class="s4">'yQ_f1'</span><span class="s1">]</span>

    <span class="s2">return </span><span class="s1">endog_M</span><span class="s2">, </span><span class="s1">endog_Q</span><span class="s2">, </span><span class="s1">factor</span>


<span class="s1">@pytest.mark.filterwarnings(</span><span class="s4">&quot;ignore:Log-likelihood decreased&quot;</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_k_factor1_factor_order_6(reset_randomstate):</span>
    <span class="s5"># This tests that the model is correctly set up when the lag order of the</span>
    <span class="s5"># factor is longer than 5 and we have a single factor. This is important</span>
    <span class="s5"># because 5 lags are always present when there is quarterly data, but we</span>
    <span class="s5"># want to check that, for example, we haven't accidentally relied on there</span>
    <span class="s5"># being exactly 5 lags available.</span>
    <span class="s5"># Note: as of 2020/07/25, the FRBNY code does not seem to work for 6 lags,</span>
    <span class="s5"># so we can't test against their code</span>
    <span class="s5"># Note: the case with only 100 nobs leads to issues with the EM algorithm</span>
    <span class="s5"># and a decrease in the log-likelihood</span>

    <span class="s5"># There is a description of the results from</span>
    <span class="s5"># a run with nobs=10000 that are a better indication of the model finding</span>
    <span class="s5"># the correct parameters.</span>

    <span class="s1">endog_M</span><span class="s2">, </span><span class="s1">endog_Q</span><span class="s2">, </span><span class="s1">_ = gen_k_factor1(</span>
        <span class="s1">nobs=</span><span class="s3">100</span><span class="s2">, </span><span class="s1">idiosyncratic_var=</span><span class="s3">0.0</span><span class="s1">)</span>

    <span class="s5"># Construct and fit the model</span>
    <span class="s1">mod = dynamic_factor_mq.DynamicFactorMQ(</span>
        <span class="s1">endog_M</span><span class="s2">, </span><span class="s1">endog_quarterly=endog_Q</span><span class="s2">,</span>
        <span class="s1">factor_orders=</span><span class="s3">6</span><span class="s2">,</span>
        <span class="s1">idiosyncratic_ar1=</span><span class="s2">False, </span><span class="s1">standardize=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">mod.fit()</span>

    <span class="s5"># From a run with 10000 observations, we get:</span>
    <span class="s5"># This results in the following fitted coefficients</span>
    <span class="s5">#                       True  Fitted</span>
    <span class="s5"># loading.0-&gt;y1         1.00    1.15</span>
    <span class="s5"># loading.0-&gt;y2         1.00    1.15</span>
    <span class="s5"># L1.0-&gt;0               0.00   -0.01</span>
    <span class="s5"># L2.0-&gt;0               0.00   -0.01</span>
    <span class="s5"># L3.0-&gt;0               0.00    0.01</span>
    <span class="s5"># L4.0-&gt;0               0.00    0.01</span>
    <span class="s5"># L5.0-&gt;0               0.00   -0.00</span>
    <span class="s5"># L6.0-&gt;0               0.50    0.50</span>
    <span class="s5"># fb(0).cov.chol[1,1]   1.00    0.87</span>
    <span class="s5"># sigma2.y1             0.00   -0.00</span>
    <span class="s5"># sigma2.y2             0.00    0.00</span>
    <span class="s5">#</span>
    <span class="s5"># Note that the fitted values are essentially exactly right, once we</span>
    <span class="s5"># account for the lack of factor identification. In particular, if we</span>
    <span class="s5"># normalize the loadings to one, then the estimated factor error variance</span>
    <span class="s5"># is (0.87 * 1.15)**2 = 1.0, as desired.</span>


<span class="s2">def </span><span class="s1">gen_k_factor2(nobs=</span><span class="s3">10000</span><span class="s2">, </span><span class="s1">k=</span><span class="s3">2</span><span class="s2">, </span><span class="s1">idiosyncratic_ar1=</span><span class="s2">False,</span>
                  <span class="s1">idiosyncratic_var=</span><span class="s3">0.4</span><span class="s2">, </span><span class="s1">k_ar=</span><span class="s3">6</span><span class="s1">):</span>
    <span class="s5"># Simulate bivariate VAR(6) for the factor</span>
    <span class="s1">ix = pd.period_range(start=</span><span class="s4">'1950-01'</span><span class="s2">, </span><span class="s1">periods=</span><span class="s3">1</span><span class="s2">, </span><span class="s1">freq=</span><span class="s4">'M'</span><span class="s1">)</span>
    <span class="s1">faux = pd.DataFrame([[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">index=ix</span><span class="s2">,</span>
                        <span class="s1">columns=[</span><span class="s4">'f1'</span><span class="s2">, </span><span class="s4">'f2'</span><span class="s1">])</span>
    <span class="s1">mod = varmax.VARMAX(faux</span><span class="s2">, </span><span class="s1">order=(k_ar</span><span class="s2">, </span><span class="s3">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s4">'n'</span><span class="s1">)</span>
    <span class="s1">A = np.zeros((</span><span class="s3">2</span><span class="s2">, </span><span class="s3">2 </span><span class="s1">* k_ar))</span>
    <span class="s1">A[:</span><span class="s2">, </span><span class="s1">-</span><span class="s3">2</span><span class="s1">:] = np.array([[</span><span class="s3">0.5</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.2</span><span class="s1">]</span><span class="s2">,</span>
                          <span class="s1">[</span><span class="s3">0.1</span><span class="s2">, </span><span class="s3">0.3</span><span class="s1">]])</span>
    <span class="s1">Q = np.array([[</span><span class="s3">1.5</span><span class="s2">, </span><span class="s3">0.2</span><span class="s1">]</span><span class="s2">,</span>
                  <span class="s1">[</span><span class="s3">0.2</span><span class="s2">, </span><span class="s3">0.5</span><span class="s1">]])</span>
    <span class="s1">L = np.linalg.cholesky(Q)</span>
    <span class="s1">params = np.r_[A.ravel()</span><span class="s2">, </span><span class="s1">L[np.tril_indices_from(L)]]</span>

    <span class="s5"># Simulate the factors</span>
    <span class="s1">factors = mod.simulate(params</span><span class="s2">, </span><span class="s1">nobs)</span>

    <span class="s5"># Add in the idiosyncratic part</span>
    <span class="s1">faux = pd.Series([</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">index=ix)</span>
    <span class="s1">mod_idio = sarimax.SARIMAX(faux</span><span class="s2">, </span><span class="s1">order=(</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">))</span>
    <span class="s1">phi = [</span><span class="s3">0.7</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.2</span><span class="s1">] </span><span class="s2">if </span><span class="s1">idiosyncratic_ar1 </span><span class="s2">else </span><span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0.</span><span class="s1">]</span>
    <span class="s1">tmp = factors.iloc[:</span><span class="s2">, </span><span class="s3">0</span><span class="s1">] + factors.iloc[:</span><span class="s2">, </span><span class="s3">1</span><span class="s1">]</span>

    <span class="s5"># Monthly variables</span>
    <span class="s1">endog_M = pd.concat([tmp.copy() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(k)]</span><span class="s2">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">columns = []</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(k):</span>
        <span class="s1">endog_M.iloc[:</span><span class="s2">, </span><span class="s1">i] = (</span>
            <span class="s1">endog_M.iloc[:</span><span class="s2">, </span><span class="s1">i] +</span>
            <span class="s1">mod_idio.simulate([phi[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">idiosyncratic_var]</span><span class="s2">, </span><span class="s1">nobs))</span>
        <span class="s1">columns += [</span><span class="s4">f'yM</span><span class="s2">{</span><span class="s1">i + </span><span class="s3">1</span><span class="s2">}</span><span class="s4">_f2'</span><span class="s1">]</span>
    <span class="s1">endog_M.columns = columns</span>

    <span class="s5"># Monthly versions of quarterly variables</span>
    <span class="s1">endog_Q_M = pd.concat([tmp.copy() </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(k)]</span><span class="s2">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">columns = []</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(k):</span>
        <span class="s1">endog_Q_M.iloc[:</span><span class="s2">, </span><span class="s1">i] = (</span>
            <span class="s1">endog_Q_M.iloc[:</span><span class="s2">, </span><span class="s1">i] +</span>
            <span class="s1">mod_idio.simulate([phi[</span><span class="s3">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">idiosyncratic_var]</span><span class="s2">, </span><span class="s1">nobs))</span>
        <span class="s1">columns += [</span><span class="s4">f'yQ</span><span class="s2">{</span><span class="s1">i + </span><span class="s3">1</span><span class="s2">}</span><span class="s4">_f2'</span><span class="s1">]</span>
    <span class="s1">endog_Q_M.columns = columns</span>

    <span class="s5"># Create quarterly versions of quarterly variables</span>
    <span class="s1">levels_M = </span><span class="s3">1 </span><span class="s1">+ endog_Q_M / </span><span class="s3">100</span>
    <span class="s1">levels_M.iloc[</span><span class="s3">0</span><span class="s1">] = </span><span class="s3">100</span>
    <span class="s1">levels_M = levels_M.cumprod()</span>
    <span class="s5"># log_levels_M = np.log(levels_M) * 100</span>
    <span class="s1">log_levels_Q = (np.log(levels_M).resample(</span><span class="s4">'Q'</span><span class="s2">, </span><span class="s1">convention=</span><span class="s4">'e'</span><span class="s1">)</span>
                                    <span class="s1">.sum().iloc[:-</span><span class="s3">1</span><span class="s1">] * </span><span class="s3">100</span><span class="s1">)</span>

    <span class="s5"># Compute the quarterly growth rate series</span>
    <span class="s1">endog_Q = log_levels_Q.diff()</span>

    <span class="s2">return </span><span class="s1">endog_M</span><span class="s2">, </span><span class="s1">endog_Q</span><span class="s2">, </span><span class="s1">factors</span>


<span class="s1">@pytest.mark.skip(reason=</span><span class="s4">&quot;Monte carlo test, very slow, kept for manual runs&quot;</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_k_factor2_factor_order_6(reset_randomstate):</span>
    <span class="s5"># This tests that the model is correctly set up when the lag order of the</span>
    <span class="s5"># factor is longer than 5 and we have two factors. This is important</span>
    <span class="s5"># because 5 lags are always present when there is quarterly data, but we</span>
    <span class="s5"># want to check that, for example, we haven't accidentally relied on there</span>
    <span class="s5"># being exactly 5 lags available.</span>
    <span class="s5"># Note: as of 2020/07/25, the FRBNY code does not seem to work for 6 lags,</span>
    <span class="s5"># so we can't test against their code</span>

    <span class="s1">endog_M</span><span class="s2">, </span><span class="s1">endog_Q</span><span class="s2">, </span><span class="s1">factors = gen_k_factor2()</span>

    <span class="s5"># Add the factors in to endog_M, which will allow us to identify them,</span>
    <span class="s5"># since endog_M and endog_Q are all the same linear combination of the</span>
    <span class="s5"># factors</span>
    <span class="s1">endog_M_aug = pd.concat([factors</span><span class="s2">, </span><span class="s1">endog_M]</span><span class="s2">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">)</span>

    <span class="s1">mod = dynamic_factor_mq.DynamicFactorMQ(</span>
        <span class="s1">endog_M_aug</span><span class="s2">, </span><span class="s1">endog_quarterly=endog_Q</span><span class="s2">,</span>
        <span class="s1">factor_multiplicities=</span><span class="s3">2</span><span class="s2">, </span><span class="s1">factor_orders=</span><span class="s3">6</span><span class="s2">,</span>
        <span class="s1">idiosyncratic_ar1=</span><span class="s2">False, </span><span class="s1">standardize=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">res = mod.fit()</span>

    <span class="s5"># The identification for the VAR system means that it is harder to visually</span>
    <span class="s5"># check that the estimation procedure produced good estimates.</span>

    <span class="s5"># This is the invertible matrix that we'll use to transform the factors</span>
    <span class="s5"># and parameter matrices into the original form</span>
    <span class="s1">M = np.kron(np.eye(</span><span class="s3">6</span><span class="s1">)</span><span class="s2">, </span><span class="s1">mod[</span><span class="s4">'design'</span><span class="s2">, </span><span class="s1">:</span><span class="s3">2</span><span class="s2">, </span><span class="s1">:</span><span class="s3">2</span><span class="s1">])</span>
    <span class="s1">Mi = np.linalg.inv(M)</span>

    <span class="s5"># Get the estimated parameter matrices</span>
    <span class="s1">Z = mod[</span><span class="s4">'design'</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">:</span><span class="s3">12</span><span class="s1">]</span>
    <span class="s1">A = mod[</span><span class="s4">'transition'</span><span class="s2">, </span><span class="s1">:</span><span class="s3">12</span><span class="s2">, </span><span class="s1">:</span><span class="s3">12</span><span class="s1">]</span>
    <span class="s1">R = mod[</span><span class="s4">'selection'</span><span class="s2">, </span><span class="s1">:</span><span class="s3">12</span><span class="s2">, </span><span class="s1">:</span><span class="s3">2</span><span class="s1">]</span>
    <span class="s1">Q = mod[</span><span class="s4">'state_cov'</span><span class="s2">, </span><span class="s1">:</span><span class="s3">2</span><span class="s2">, </span><span class="s1">:</span><span class="s3">2</span><span class="s1">]</span>
    <span class="s1">RQR = R @ Q @ R.T</span>

    <span class="s5"># Create the transformed matrices</span>
    <span class="s1">Z2 = Z @ Mi</span>
    <span class="s1">A2 = M @ A @ Mi</span>
    <span class="s1">Q2 = (M @ RQR @ M.T)</span>

    <span class="s5"># In this example, both endog_M and endog_Q are equal to the factors,</span>
    <span class="s5"># so we expect the loading matrix to look like, which can be confirmed</span>
    <span class="s5"># (up to some numerical precision) by printing Z2</span>
    <span class="s5"># [ I   0   0   0  0 ]</span>
    <span class="s5"># [ I  2I  3I  2I  I ]</span>
    <span class="s1">print(Z2.round(</span><span class="s3">2</span><span class="s1">))</span>
    <span class="s1">desired = np.array([</span>
        <span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">3</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">1</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]])</span>
    <span class="s1">assert_allclose(Z2</span><span class="s2">, </span><span class="s1">desired</span><span class="s2">, </span><span class="s1">atol=</span><span class="s3">0.1</span><span class="s1">)</span>
    <span class="s5"># Confirm that this is approximately:</span>
    <span class="s5"># [  0  0    0  0    0  0    0  0    0  0    0.5 -0.2 ]</span>
    <span class="s5"># [  0  0    0  0    0  0    0  0    0  0    0.1  0.3 ]</span>
    <span class="s1">print(A2.round(</span><span class="s3">2</span><span class="s1">))</span>
    <span class="s1">desired = np.array([</span>
        <span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0.02</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0.01</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.03</span><span class="s2">, </span><span class="s3">0.01</span><span class="s2">, </span><span class="s3">0.02</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.01</span><span class="s2">, </span><span class="s3">0.5</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.2</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0.02</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s1">-</span><span class="s3">0.01</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0.01</span><span class="s2">, </span><span class="s3">0.1</span><span class="s2">, </span><span class="s3">0.3</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">1.</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">1.</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1.</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1.</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1.</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1.</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1.</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1.</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1.</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">[</span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">1.</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s3">0</span><span class="s1">]])</span>
    <span class="s1">assert_allclose(A2</span><span class="s2">, </span><span class="s1">desired</span><span class="s2">, </span><span class="s1">atol=</span><span class="s3">1e-2</span><span class="s1">)</span>
    <span class="s5"># Confirm that this is approximately:</span>
    <span class="s5"># [ 1.5  0.2 ]</span>
    <span class="s5"># [ 0.2  0.5 ]</span>
    <span class="s5"># in the top left corner, and then zeros elsewhere</span>
    <span class="s1">print(Q2.round(</span><span class="s3">2</span><span class="s1">))</span>
    <span class="s1">desired = np.array([[</span><span class="s3">1.49</span><span class="s2">, </span><span class="s3">0.21</span><span class="s1">]</span><span class="s2">,</span>
                        <span class="s1">[</span><span class="s3">0.21</span><span class="s2">, </span><span class="s3">0.49</span><span class="s1">]])</span>
    <span class="s1">assert_allclose(Q2[:</span><span class="s3">2</span><span class="s2">, </span><span class="s1">:</span><span class="s3">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">desired</span><span class="s2">, </span><span class="s1">atol=</span><span class="s3">1e-2</span><span class="s1">)</span>
    <span class="s1">assert_allclose(Q2[:</span><span class="s3">2</span><span class="s2">, </span><span class="s3">2</span><span class="s1">:]</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s3">1e-2</span><span class="s1">)</span>
    <span class="s1">assert_allclose(Q2[</span><span class="s3">2</span><span class="s1">:</span><span class="s2">, </span><span class="s1">:</span><span class="s3">2</span><span class="s1">]</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s3">1e-2</span><span class="s1">)</span>
    <span class="s1">assert_allclose(Q2[</span><span class="s3">2</span><span class="s1">:</span><span class="s2">, </span><span class="s3">2</span><span class="s1">:]</span><span class="s2">, </span><span class="s3">0</span><span class="s2">, </span><span class="s1">atol=</span><span class="s3">1e-2</span><span class="s1">)</span>

    <span class="s5"># Finally, check that after the transformation, the factors are equal to</span>
    <span class="s5"># endog_M</span>
    <span class="s1">a = res.states.smoothed</span>
    <span class="s1">a2 = (M @ a.T.iloc[:</span><span class="s3">12</span><span class="s1">]).T</span>
    <span class="s1">assert_allclose(endog_M.values</span><span class="s2">, </span><span class="s1">a2.iloc[:</span><span class="s2">, </span><span class="s1">:</span><span class="s3">2</span><span class="s1">].values</span><span class="s2">, </span><span class="s1">atol=</span><span class="s3">1e-10</span><span class="s1">)</span>


<span class="s1">@pytest.mark.skip(reason=</span><span class="s4">&quot;Monte carlo test, very slow, kept for manual runs&quot;</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_two_blocks_factor_orders_6(reset_randomstate):</span>
    <span class="s5"># This tests that the model is correctly set up when the lag order of the</span>
    <span class="s5"># factor is longer than 5 and we have two blocks of factors, one block with</span>
    <span class="s5"># a single factor and one block with two factors.</span>

    <span class="s5"># For the results below, we use nobs=1000, since nobs=10000 takes a very</span>
    <span class="s5"># long time and a large amount of memory. As a result, the results below</span>
    <span class="s5"># are noisier than they could be, although they still provide pretty good</span>
    <span class="s5"># evidence that the model is performing as it should</span>
    <span class="s1">nobs = </span><span class="s3">1000</span>
    <span class="s1">idiosyncratic_ar1 = </span><span class="s2">True</span>
    <span class="s1">k1 = </span><span class="s3">3</span>
    <span class="s1">k2 = </span><span class="s3">10</span>
    <span class="s1">endog1_M</span><span class="s2">, </span><span class="s1">endog1_Q</span><span class="s2">, </span><span class="s1">f1 = gen_k_factor1(</span>
        <span class="s1">nobs</span><span class="s2">, </span><span class="s1">k=k1</span><span class="s2">, </span><span class="s1">idiosyncratic_ar1=idiosyncratic_ar1)</span>
    <span class="s1">endog2_M</span><span class="s2">, </span><span class="s1">endog2_Q</span><span class="s2">, </span><span class="s1">f2 = gen_k_factor2(</span>
        <span class="s1">nobs</span><span class="s2">, </span><span class="s1">k=k2</span><span class="s2">, </span><span class="s1">idiosyncratic_ar1=idiosyncratic_ar1)</span>

    <span class="s1">endog_M = pd.concat([endog1_M</span><span class="s2">, </span><span class="s1">f2</span><span class="s2">, </span><span class="s1">endog2_M]</span><span class="s2">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">endog_Q = pd.concat([endog1_Q</span><span class="s2">, </span><span class="s1">endog2_Q]</span><span class="s2">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">)</span>

    <span class="s1">factors = {</span><span class="s4">f'yM</span><span class="s2">{</span><span class="s1">i + </span><span class="s3">1</span><span class="s2">}</span><span class="s4">_f1'</span><span class="s1">: [</span><span class="s4">'a'</span><span class="s1">] </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(k1)}</span>
    <span class="s1">factors.update({</span><span class="s4">f'yQ</span><span class="s2">{</span><span class="s1">i + </span><span class="s3">1</span><span class="s2">}</span><span class="s4">_f1'</span><span class="s1">: [</span><span class="s4">'a'</span><span class="s1">] </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(k1)})</span>
    <span class="s1">factors.update({</span><span class="s4">f'f</span><span class="s2">{</span><span class="s1">i + </span><span class="s3">1</span><span class="s2">}</span><span class="s4">'</span><span class="s1">: [</span><span class="s4">'b'</span><span class="s1">] </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s3">2</span><span class="s1">)})</span>
    <span class="s1">factors.update({</span><span class="s4">f'yM</span><span class="s2">{</span><span class="s1">i + </span><span class="s3">1</span><span class="s2">}</span><span class="s4">_f2'</span><span class="s1">: [</span><span class="s4">'b'</span><span class="s1">] </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(k2)})</span>
    <span class="s1">factors.update({</span><span class="s4">f'yQ</span><span class="s2">{</span><span class="s1">i + </span><span class="s3">1</span><span class="s2">}</span><span class="s4">_f2'</span><span class="s1">: [</span><span class="s4">'b'</span><span class="s1">] </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(k2)})</span>
    <span class="s1">factor_multiplicities = {</span><span class="s4">'b'</span><span class="s1">: </span><span class="s3">2</span><span class="s1">}</span>

    <span class="s1">mod = dynamic_factor_mq.DynamicFactorMQ(</span>
        <span class="s1">endog_M</span><span class="s2">, </span><span class="s1">endog_quarterly=endog_Q</span><span class="s2">,</span>
        <span class="s1">factors=factors</span><span class="s2">, </span><span class="s1">factor_multiplicities=factor_multiplicities</span><span class="s2">,</span>
        <span class="s1">factor_orders=</span><span class="s3">6</span><span class="s2">, </span><span class="s1">idiosyncratic_ar1=idiosyncratic_ar1</span><span class="s2">,</span>
        <span class="s1">standardize=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">mod.fit()</span>

    <span class="s5"># For the 1-factor block:</span>
    <span class="s5"># From one run, the following fitted coefficients were estimated:</span>
    <span class="s5">#                       True  Fitted</span>
    <span class="s5"># loading.a-&gt;yM1_f1     1.00   -0.86</span>
    <span class="s5"># loading.a-&gt;yM2_f1     1.00   -0.85</span>
    <span class="s5"># loading.a-&gt;yM3_f1     1.00   -0.86</span>
    <span class="s5"># loading.a-&gt;yQ1_f1     1.00   -0.71</span>
    <span class="s5"># loading.a-&gt;yQ2_f1     1.00   -0.47</span>
    <span class="s5"># loading.a-&gt;yQ3_f1     1.00   -0.48</span>
    <span class="s5"># L1.a-&gt;a               0.00    0.05</span>
    <span class="s5"># L2.a-&gt;a               0.00    0.06</span>
    <span class="s5"># L3.a-&gt;a               0.00    0.04</span>
    <span class="s5"># L4.a-&gt;a               0.00   -0.03</span>
    <span class="s5"># L5.a-&gt;a               0.00   -0.06</span>
    <span class="s5"># L6.a-&gt;a               0.50    0.46</span>
    <span class="s5"># fb(0).cov.chol[1,1]   1.00    1.63</span>
    <span class="s5"># L1.eps_M.yM1_f1       0.70    0.65</span>
    <span class="s5"># L1.eps_M.yM2_f1       0.70    0.67</span>
    <span class="s5"># L1.eps_M.yM3_f1       0.70    0.68</span>
    <span class="s5"># L1.eps_Q.yQ1_f1       0.70    0.76</span>
    <span class="s5"># L1.eps_Q.yQ2_f1       0.70    0.59</span>
    <span class="s5"># L1.eps_Q.yQ3_f1       0.70    0.62</span>
    <span class="s5"># sigma2.yM1_f1         0.40    0.39</span>
    <span class="s5"># sigma2.yM2_f1         0.40    0.41</span>
    <span class="s5"># sigma2.yM3_f1         0.40    0.40</span>
    <span class="s5"># sigma2.yQ1_f1         0.40    0.43</span>
    <span class="s5"># sigma2.yQ2_f1         0.40    0.60</span>
    <span class="s5"># sigma2.yQ3_f1         0.40    0.59</span>
    <span class="s5"># These are pretty good:</span>
    <span class="s5"># 1. When we normalize the factor by the first loading, the monthly</span>
    <span class="s5">#    variables then all have loading close to 1.0. However, the factor</span>
    <span class="s5">#    standard deviation is 0.86 * 1.63 = 1.4, which is higher than it</span>
    <span class="s5">#    should be (this is largely due to the existence of the quarterly</span>
    <span class="s5">#    variables, which only have 1/3 the number of observations, and make</span>
    <span class="s5">#    the estimation more noisy)</span>
    <span class="s5"># 2. Similarly, the idiosyncratic AR(1) and error variance are pretty-well</span>
    <span class="s5">#    estimated, although more-so for monthly than quarterly variables</span>
    <span class="s5"># 3. The factor transition is pretty good, although there is some noise in</span>

    <span class="s5"># For the 2-factor block:</span>
    <span class="s5"># The identification for the VAR system means that it is harder to visually</span>
    <span class="s5"># check that the estimation procedure produced good estimates.</span>

    <span class="s5"># This is the invertible matrix that we'll use to transform the factors</span>
    <span class="s5"># and parameter matrices into the original form</span>
    <span class="s2">from </span><span class="s1">scipy.linalg </span><span class="s2">import </span><span class="s1">block_diag</span>
    <span class="s1">M1 = np.kron(np.eye(</span><span class="s3">6</span><span class="s1">)</span><span class="s2">, </span><span class="s1">mod[</span><span class="s4">'design'</span><span class="s2">, </span><span class="s3">3</span><span class="s1">:</span><span class="s3">5</span><span class="s2">, </span><span class="s1">:</span><span class="s3">2</span><span class="s1">])</span>
    <span class="s1">M2 = np.kron(np.eye(</span><span class="s3">6</span><span class="s1">)</span><span class="s2">, </span><span class="s1">mod[</span><span class="s4">'design'</span><span class="s2">, </span><span class="s3">0</span><span class="s1">:</span><span class="s3">1</span><span class="s2">, </span><span class="s3">12</span><span class="s1">:</span><span class="s3">13</span><span class="s1">])</span>
    <span class="s1">M = block_diag(M1</span><span class="s2">, </span><span class="s1">M2)</span>
    <span class="s1">Mi = np.linalg.inv(M)</span>

    <span class="s5"># Get the estimated parameter matrices</span>
    <span class="s1">Z = mod[</span><span class="s4">'design'</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">:</span><span class="s3">18</span><span class="s1">]</span>
    <span class="s1">A = mod[</span><span class="s4">'transition'</span><span class="s2">, </span><span class="s1">:</span><span class="s3">18</span><span class="s2">, </span><span class="s1">:</span><span class="s3">18</span><span class="s1">]</span>
    <span class="s1">R = mod[</span><span class="s4">'selection'</span><span class="s2">, </span><span class="s1">:</span><span class="s3">18</span><span class="s2">, </span><span class="s1">:</span><span class="s3">3</span><span class="s1">]</span>
    <span class="s1">Q = block_diag(mod[</span><span class="s4">'state_cov'</span><span class="s2">, </span><span class="s1">:</span><span class="s3">2</span><span class="s2">, </span><span class="s1">:</span><span class="s3">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">mod[</span><span class="s4">'state_cov'</span><span class="s2">, </span><span class="s3">12</span><span class="s1">:</span><span class="s3">13</span><span class="s2">, </span><span class="s3">12</span><span class="s1">:</span><span class="s3">13</span><span class="s1">])</span>
    <span class="s1">RQR = R @ Q @ R.T</span>

    <span class="s5"># Create the transformed matrices</span>
    <span class="s1">Z2 = Z @ Mi</span>
    <span class="s1">A2 = M @ A @ Mi</span>
    <span class="s1">Q2 = (M @ RQR @ M.T)</span>

    <span class="s5"># In this example, both endog_M and endog_Q are equal to the factors,</span>
    <span class="s5"># so we expect the loading matrix to look like, which can be confirmed</span>
    <span class="s5"># (up to some numerical precision) by printing Z2</span>
    <span class="s5"># (where the 1's, 2's, etc. are actually vectors of 1's and 2's, etc.)</span>
    <span class="s5"># [ 0 0   0 0   0 0   0 0   0 0  | 1  0  0  0  0 ]</span>
    <span class="s5"># [ 0 0   0 0   0 0   0 0   0 0  | 1  2  3  2  1 ]</span>
    <span class="s5"># [  I    0 0   0 0   0 0   0 0  | 0  0  0  0  0 ]</span>
    <span class="s5"># [ 1 1   0 0   0 0   0 0   0 0  | 0  0  0  0  0 ]</span>
    <span class="s5"># [ 1 1   2 2   3 3   2 2   1 1  | 0  0  0  0  0 ]</span>
    <span class="s1">print(Z2.round(</span><span class="s3">2</span><span class="s1">))</span>
    <span class="s5"># Confirm that for the first factor block this is approximately:</span>
    <span class="s5"># [  0  0    0  0    0  0    0  0    0  0    0.5 -0.2 ]</span>
    <span class="s5"># [  0  0    0  0    0  0    0  0    0  0    0.1  0.3 ]</span>
    <span class="s5"># and for the second factor block this is approximately</span>
    <span class="s5"># [  0  0  0  0  0  0.5 ]</span>
    <span class="s1">print(A2.round(</span><span class="s3">2</span><span class="s1">))</span>
    <span class="s5"># Confirm that this is approximately:</span>
    <span class="s5"># [ 1.5  0.2 ]</span>
    <span class="s5"># [ 0.2  0.5 ]</span>
    <span class="s5"># for the first factor block, and</span>
    <span class="s5"># [1.0]</span>
    <span class="s5"># for the second factor block (note: actually, this seems to be</span>
    <span class="s5"># about [0.3], underestimating this factor's error variance)</span>
    <span class="s1">print(Q2.round(</span><span class="s3">2</span><span class="s1">))</span>
</pre>
</body>
</html>