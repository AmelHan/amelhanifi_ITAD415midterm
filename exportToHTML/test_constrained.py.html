<html>
<head>
<title>test_constrained.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_constrained.py</font>
</center></td></tr></table>
<pre><span class="s0"># -*- coding: utf-8 -*-</span>
<span class="s2">&quot;&quot;&quot; 
Created on Fri May 30 16:22:29 2014 
 
Author: Josef Perktold 
License: BSD-3 
 
&quot;&quot;&quot;</span>
<span class="s3">from </span><span class="s1">io </span><span class="s3">import </span><span class="s1">StringIO</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">from </span><span class="s1">numpy.testing </span><span class="s3">import </span><span class="s1">assert_</span><span class="s3">, </span><span class="s1">assert_allclose</span><span class="s3">, </span><span class="s1">assert_equal</span>
<span class="s3">import </span><span class="s1">pandas </span><span class="s3">as </span><span class="s1">pd</span>
<span class="s3">import </span><span class="s1">patsy</span>
<span class="s3">import </span><span class="s1">pytest</span>

<span class="s3">from </span><span class="s1">statsmodels </span><span class="s3">import </span><span class="s1">datasets</span>
<span class="s3">from </span><span class="s1">statsmodels.base._constraints </span><span class="s3">import </span><span class="s1">fit_constrained</span>
<span class="s3">from </span><span class="s1">statsmodels.discrete.discrete_model </span><span class="s3">import </span><span class="s1">Poisson</span><span class="s3">, </span><span class="s1">Logit</span>
<span class="s3">from </span><span class="s1">statsmodels.genmod </span><span class="s3">import </span><span class="s1">families</span>
<span class="s3">from </span><span class="s1">statsmodels.genmod.generalized_linear_model </span><span class="s3">import </span><span class="s1">GLM</span>
<span class="s3">from </span><span class="s1">statsmodels.tools.tools </span><span class="s3">import </span><span class="s1">add_constant</span>

<span class="s3">from </span><span class="s1">.results </span><span class="s3">import </span><span class="s1">(</span>
    <span class="s1">results_glm_logit_constrained </span><span class="s3">as </span><span class="s1">reslogit</span><span class="s3">,</span>
    <span class="s1">results_poisson_constrained </span><span class="s3">as </span><span class="s1">results</span><span class="s3">,</span>
<span class="s1">)</span>

<span class="s1">spector_data = datasets.spector.load()</span>
<span class="s1">spector_data.endog = np.asarray(spector_data.endog)</span>
<span class="s1">spector_data.exog = np.asarray(spector_data.exog)</span>
<span class="s1">spector_data.exog = add_constant(spector_data.exog</span><span class="s3">, </span><span class="s1">prepend=</span><span class="s3">False</span><span class="s1">)</span>


<span class="s1">DEBUG = </span><span class="s3">False</span>

<span class="s1">ss = </span><span class="s4">'''</span><span class="s3">\ 
</span><span class="s4">agecat  smokes  deaths  pyears 
1   1   32  52407 
2   1   104 43248 
3   1   206 28612 
4   1   186 12663 
5   1   102 5317 
1   0   2   18790 
2   0   12  10673 
3   0   28  5710 
4   0   28  2585 
5   0   31  1462'''</span>

<span class="s1">data = pd.read_csv(StringIO(ss)</span><span class="s3">, </span><span class="s1">delimiter=</span><span class="s4">'</span><span class="s3">\t</span><span class="s4">'</span><span class="s1">)</span>
<span class="s1">data = data.astype(int)</span>
<span class="s1">data[</span><span class="s4">'logpyears'</span><span class="s1">] = np.log(data[</span><span class="s4">'pyears'</span><span class="s1">])</span>


<span class="s3">class </span><span class="s1">CheckPoissonConstrainedMixin:</span>

    <span class="s3">def </span><span class="s1">test_basic(self):</span>
        <span class="s1">res1 = self.res1</span>
        <span class="s1">res2 = self.res2</span>
        <span class="s1">assert_allclose(res1[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">res2.params[self.idx]</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s5">1e-6</span><span class="s1">)</span>
        <span class="s0"># see below Stata has nan, we have zero</span>
        <span class="s1">bse1 = np.sqrt(np.diag(res1[</span><span class="s5">1</span><span class="s1">]))</span>
        <span class="s1">mask = (bse1 == </span><span class="s5">0</span><span class="s1">) &amp; np.isnan(res2.bse[self.idx])</span>
        <span class="s1">assert_allclose(bse1[~mask]</span><span class="s3">, </span><span class="s1">res2.bse[self.idx][~mask]</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s5">1e-6</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_basic_method(self):</span>
        <span class="s3">if </span><span class="s1">hasattr(self</span><span class="s3">, </span><span class="s4">'res1m'</span><span class="s1">):</span>
            <span class="s1">res1 = (self.res1m </span><span class="s3">if not </span><span class="s1">hasattr(self.res1m</span><span class="s3">, </span><span class="s4">'_results'</span><span class="s1">)</span>
                    <span class="s3">else </span><span class="s1">self.res1m._results)</span>
            <span class="s1">res2 = self.res2</span>
            <span class="s1">assert_allclose(res1.params</span><span class="s3">, </span><span class="s1">res2.params[self.idx]</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s5">1e-6</span><span class="s1">)</span>

            <span class="s0"># when a parameter is fixed, the Stata has bse=nan, we have bse=0</span>
            <span class="s1">mask = (res1.bse == </span><span class="s5">0</span><span class="s1">) &amp; np.isnan(res2.bse[self.idx])</span>
            <span class="s1">assert_allclose(res1.bse[~mask]</span><span class="s3">, </span><span class="s1">res2.bse[self.idx][~mask]</span><span class="s3">,</span>
                            <span class="s1">rtol=</span><span class="s5">1e-6</span><span class="s1">)</span>

            <span class="s1">tvalues = res2.params_table[self.idx</span><span class="s3">, </span><span class="s5">2</span><span class="s1">]</span>
            <span class="s0"># when a parameter is fixed, the Stata has tvalue=nan,</span>
            <span class="s0">#  we have tvalue=inf</span>
            <span class="s1">mask = np.isinf(res1.tvalues) &amp; np.isnan(tvalues)</span>
            <span class="s1">assert_allclose(res1.tvalues[~mask]</span><span class="s3">, </span><span class="s1">tvalues[~mask]</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s5">1e-6</span><span class="s1">)</span>
            <span class="s1">pvalues = res2.params_table[self.idx</span><span class="s3">, </span><span class="s5">3</span><span class="s1">]</span>
            <span class="s0"># note most pvalues are very small</span>
            <span class="s0"># examples so far agree at 8 or more decimal, but rtol is stricter</span>
            <span class="s0"># see above</span>
            <span class="s1">mask = (res1.pvalues == </span><span class="s5">0</span><span class="s1">) &amp; np.isnan(pvalues)</span>
            <span class="s1">assert_allclose(res1.pvalues[~mask]</span><span class="s3">, </span><span class="s1">pvalues[~mask]</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s5">5e-5</span><span class="s1">)</span>

            <span class="s1">ci_low = res2.params_table[self.idx</span><span class="s3">, </span><span class="s5">4</span><span class="s1">]</span>
            <span class="s1">ci_upp = res2.params_table[self.idx</span><span class="s3">, </span><span class="s5">5</span><span class="s1">]</span>
            <span class="s1">ci = np.column_stack((ci_low</span><span class="s3">, </span><span class="s1">ci_upp))</span>
            <span class="s0"># note most pvalues are very small</span>
            <span class="s0"># examples so far agree at 8 or more decimal, but rtol is stricter</span>
            <span class="s0"># see above: nan versus value</span>
            <span class="s1">assert_allclose(res1.conf_int()[~np.isnan(ci)]</span><span class="s3">, </span><span class="s1">ci[~np.isnan(ci)]</span><span class="s3">,</span>
                            <span class="s1">rtol=</span><span class="s5">5e-5</span><span class="s1">)</span>

            <span class="s0"># other</span>
            <span class="s1">assert_allclose(res1.llf</span><span class="s3">, </span><span class="s1">res2.ll</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s5">1e-6</span><span class="s1">)</span>
            <span class="s1">assert_equal(res1.df_model</span><span class="s3">, </span><span class="s1">res2.df_m)</span>
            <span class="s0"># Stata does not have df_resid</span>
            <span class="s1">df_r = res2.N - res2.df_m - </span><span class="s5">1</span>
            <span class="s1">assert_equal(res1.df_resid</span><span class="s3">, </span><span class="s1">df_r)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">pytest.skip(</span><span class="s4">&quot;not available yet&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">test_other(self):</span>
        <span class="s0"># some results may not be valid or available for all models</span>
        <span class="s3">if </span><span class="s1">hasattr(self</span><span class="s3">, </span><span class="s4">'res1m'</span><span class="s1">):</span>
            <span class="s1">res1 = self.res1m</span>
            <span class="s1">res2 = self.res2</span>

            <span class="s3">if </span><span class="s1">hasattr(res2</span><span class="s3">, </span><span class="s4">'ll_0'</span><span class="s1">):</span>
                <span class="s1">assert_allclose(res1.llnull</span><span class="s3">, </span><span class="s1">res2.ll_0</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s5">1e-6</span><span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">DEBUG:</span>
                    <span class="s3">import </span><span class="s1">warnings</span>
                    <span class="s1">message = (</span><span class="s4">'test: ll_0 not available, llnull=%6.4F'</span>
                               <span class="s1">% res1.llnull)</span>
                    <span class="s1">warnings.warn(message)</span>

        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">pytest.skip(</span><span class="s4">&quot;not available yet&quot;</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">TestPoissonConstrained1a(CheckPoissonConstrainedMixin):</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">setup_class(cls):</span>

        <span class="s1">cls.res2 = results.results_noexposure_constraint</span>
        <span class="s0"># 2 is dropped baseline for categorical</span>
        <span class="s1">cls.idx = [</span><span class="s5">7</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">5</span><span class="s3">, </span><span class="s5">6</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]</span>

        <span class="s0"># example without offset</span>
        <span class="s1">formula = </span><span class="s4">'deaths ~ logpyears + smokes + C(agecat)'</span>
        <span class="s1">mod = Poisson.from_formula(formula</span><span class="s3">, </span><span class="s1">data=data)</span>
        <span class="s0"># get start_params, example fails to converge on one CI run</span>
        <span class="s1">k_vars = len(mod.exog_names)</span>
        <span class="s1">start_params = np.zeros(k_vars)</span>
        <span class="s1">start_params[</span><span class="s5">0</span><span class="s1">] = np.log(mod.endog.mean())</span>
        <span class="s0"># if we need it, this is desired params</span>
        <span class="s0">#  p = np.array([-3.93478643,  1.37276214,  2.33077032,  2.71338891,</span>
        <span class="s0">#                2.71338891, 0.57966535,  0.97254074])</span>

        <span class="s1">constr = </span><span class="s4">'C(agecat)[T.4] = C(agecat)[T.5]'</span>
        <span class="s1">lc = patsy.DesignInfo(mod.exog_names).linear_constraint(constr)</span>
        <span class="s1">cls.res1 = fit_constrained(mod</span><span class="s3">, </span><span class="s1">lc.coefs</span><span class="s3">, </span><span class="s1">lc.constants</span><span class="s3">,</span>
                                   <span class="s1">start_params=start_params</span><span class="s3">,</span>
                                   <span class="s1">fit_kwds={</span><span class="s4">'method'</span><span class="s1">: </span><span class="s4">'bfgs'</span><span class="s3">, </span><span class="s4">'disp'</span><span class="s1">: </span><span class="s5">0</span><span class="s1">})</span>
        <span class="s0"># TODO: Newton fails</span>

        <span class="s0"># test method of Poisson, not monkey patched</span>
        <span class="s1">cls.res1m = mod.fit_constrained(constr</span><span class="s3">, </span><span class="s1">start_params=start_params</span><span class="s3">,</span>
                                        <span class="s1">method=</span><span class="s4">'bfgs'</span><span class="s3">, </span><span class="s1">disp=</span><span class="s5">0</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.smoke</span>
    <span class="s3">def </span><span class="s1">test_summary(self):</span>
        <span class="s0"># trailing text in summary, assumes it's the first extra string</span>
        <span class="s0"># NOTE: see comment about convergence in llnull for self.res1m</span>
        <span class="s1">summ = self.res1m.summary()</span>
        <span class="s1">assert_(</span><span class="s4">'linear equality constraints' </span><span class="s3">in </span><span class="s1">summ.extra_txt)</span>

    <span class="s1">@pytest.mark.smoke</span>
    <span class="s3">def </span><span class="s1">test_summary2(self):</span>
        <span class="s0"># trailing text in summary, assumes it's the first extra string</span>
        <span class="s0"># NOTE: see comment about convergence in llnull for self.res1m</span>
        <span class="s1">summ = self.res1m.summary2()</span>
        <span class="s1">assert_(</span><span class="s4">'linear equality constraints' </span><span class="s3">in </span><span class="s1">summ.extra_txt[</span><span class="s5">0</span><span class="s1">])</span>


<span class="s3">class </span><span class="s1">TestPoissonConstrained1b(CheckPoissonConstrainedMixin):</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">setup_class(cls):</span>

        <span class="s1">cls.res2 = results.results_exposure_constraint</span>
        <span class="s1">cls.idx = [</span><span class="s5">6</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">5</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]  </span><span class="s0"># 2 is dropped baseline for categorical</span>

        <span class="s0"># example without offset</span>
        <span class="s1">formula = </span><span class="s4">'deaths ~ smokes + C(agecat)'</span>
        <span class="s1">mod = Poisson.from_formula(formula</span><span class="s3">, </span><span class="s1">data=data</span><span class="s3">,</span>
                                   <span class="s1">exposure=data[</span><span class="s4">'pyears'</span><span class="s1">].values)</span>
        <span class="s1">constr = </span><span class="s4">'C(agecat)[T.4] = C(agecat)[T.5]'</span>
        <span class="s1">lc = patsy.DesignInfo(mod.exog_names).linear_constraint(constr)</span>
        <span class="s1">cls.res1 = fit_constrained(mod</span><span class="s3">, </span><span class="s1">lc.coefs</span><span class="s3">, </span><span class="s1">lc.constants</span><span class="s3">,</span>
                                   <span class="s1">fit_kwds={</span><span class="s4">'method'</span><span class="s1">: </span><span class="s4">'newton'</span><span class="s3">,</span>
                                             <span class="s4">'disp'</span><span class="s1">: </span><span class="s5">0</span><span class="s1">})</span>
        <span class="s1">cls.constraints = lc</span>
        <span class="s0"># TODO: bfgs fails</span>
        <span class="s0"># test method of Poisson, not monkey patched</span>
        <span class="s1">cls.res1m = mod.fit_constrained(constr</span><span class="s3">, </span><span class="s1">method=</span><span class="s4">'newton'</span><span class="s3">,</span>
                                        <span class="s1">disp=</span><span class="s5">0</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">TestPoissonConstrained1c(CheckPoissonConstrainedMixin):</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">setup_class(cls):</span>

        <span class="s1">cls.res2 = results.results_exposure_constraint</span>
        <span class="s1">cls.idx = [</span><span class="s5">6</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">5</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]  </span><span class="s0"># 2 is dropped baseline for categorical</span>

        <span class="s0"># example without offset</span>
        <span class="s1">formula = </span><span class="s4">'deaths ~ smokes + C(agecat)'</span>
        <span class="s1">mod = Poisson.from_formula(formula</span><span class="s3">, </span><span class="s1">data=data</span><span class="s3">,</span>
                                   <span class="s1">offset=np.log(data[</span><span class="s4">'pyears'</span><span class="s1">].values))</span>
        <span class="s1">constr = </span><span class="s4">'C(agecat)[T.4] = C(agecat)[T.5]'</span>
        <span class="s1">lc = patsy.DesignInfo(mod.exog_names).linear_constraint(constr)</span>
        <span class="s1">cls.res1 = fit_constrained(mod</span><span class="s3">, </span><span class="s1">lc.coefs</span><span class="s3">, </span><span class="s1">lc.constants</span><span class="s3">,</span>
                                   <span class="s1">fit_kwds={</span><span class="s4">'method'</span><span class="s1">: </span><span class="s4">'newton'</span><span class="s3">,</span>
                                             <span class="s4">'disp'</span><span class="s1">: </span><span class="s5">0</span><span class="s1">})</span>
        <span class="s1">cls.constraints = lc</span>
        <span class="s0"># TODO: bfgs fails</span>

        <span class="s0"># test method of Poisson, not monkey patched</span>
        <span class="s1">cls.res1m = mod.fit_constrained(constr</span><span class="s3">, </span><span class="s1">method=</span><span class="s4">'newton'</span><span class="s3">, </span><span class="s1">disp=</span><span class="s5">0</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">TestPoissonNoConstrained(CheckPoissonConstrainedMixin):</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">setup_class(cls):</span>

        <span class="s1">cls.res2 = results.results_exposure_noconstraint</span>
        <span class="s1">cls.idx = [</span><span class="s5">6</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">5</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]  </span><span class="s0"># 1 is dropped baseline for categorical</span>

        <span class="s0"># example without offset</span>
        <span class="s1">formula = </span><span class="s4">'deaths ~ smokes + C(agecat)'</span>
        <span class="s1">mod = Poisson.from_formula(formula</span><span class="s3">, </span><span class="s1">data=data</span><span class="s3">,</span>
                                   <span class="s1">offset=np.log(data[</span><span class="s4">'pyears'</span><span class="s1">].values))</span>
        <span class="s1">res1 = mod.fit(disp=</span><span class="s5">0</span><span class="s1">)._results</span>
        <span class="s0"># res1 is duplicate check, so we can follow the same pattern</span>
        <span class="s1">cls.res1 = (res1.params</span><span class="s3">, </span><span class="s1">res1.cov_params())</span>
        <span class="s1">cls.res1m = res1</span>


<span class="s3">class </span><span class="s1">TestPoissonConstrained2a(CheckPoissonConstrainedMixin):</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">setup_class(cls):</span>

        <span class="s1">cls.res2 = results.results_noexposure_constraint2</span>
        <span class="s0"># 2 is dropped baseline for categorical</span>
        <span class="s1">cls.idx = [</span><span class="s5">7</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">5</span><span class="s3">, </span><span class="s5">6</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]</span>

        <span class="s0"># example without offset</span>
        <span class="s1">formula = </span><span class="s4">'deaths ~ logpyears + smokes + C(agecat)'</span>
        <span class="s1">mod = Poisson.from_formula(formula</span><span class="s3">, </span><span class="s1">data=data)</span>

        <span class="s0"># get start_params, example fails to converge on one CI run</span>
        <span class="s1">k_vars = len(mod.exog_names)</span>
        <span class="s1">start_params = np.zeros(k_vars)</span>
        <span class="s1">start_params[</span><span class="s5">0</span><span class="s1">] = np.log(mod.endog.mean())</span>
        <span class="s0"># if we need it, this is desired params</span>
        <span class="s0">#  p = np.array([-9.43762015,  1.52762442,  2.74155711,  3.58730007,</span>
        <span class="s0">#                4.08730007,  1.15987869,  0.12111539])</span>

        <span class="s1">constr = </span><span class="s4">'C(agecat)[T.5] - C(agecat)[T.4] = 0.5'</span>
        <span class="s1">lc = patsy.DesignInfo(mod.exog_names).linear_constraint(constr)</span>
        <span class="s1">cls.res1 = fit_constrained(mod</span><span class="s3">, </span><span class="s1">lc.coefs</span><span class="s3">, </span><span class="s1">lc.constants</span><span class="s3">,</span>
                                   <span class="s1">start_params=start_params</span><span class="s3">,</span>
                                   <span class="s1">fit_kwds={</span><span class="s4">'method'</span><span class="s1">: </span><span class="s4">'bfgs'</span><span class="s3">, </span><span class="s4">'disp'</span><span class="s1">: </span><span class="s5">0</span><span class="s1">})</span>
        <span class="s0"># TODO: Newton fails</span>

        <span class="s0"># test method of Poisson, not monkey patched</span>
        <span class="s1">cls.res1m = mod.fit_constrained(constr</span><span class="s3">, </span><span class="s1">start_params=start_params</span><span class="s3">,</span>
                                        <span class="s1">method=</span><span class="s4">'bfgs'</span><span class="s3">, </span><span class="s1">disp=</span><span class="s5">0</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">TestPoissonConstrained2b(CheckPoissonConstrainedMixin):</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">setup_class(cls):</span>

        <span class="s1">cls.res2 = results.results_exposure_constraint2</span>
        <span class="s1">cls.idx = [</span><span class="s5">6</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">5</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]  </span><span class="s0"># 2 is dropped baseline for categorical</span>

        <span class="s0"># example without offset</span>
        <span class="s1">formula = </span><span class="s4">'deaths ~ smokes + C(agecat)'</span>
        <span class="s1">mod = Poisson.from_formula(formula</span><span class="s3">, </span><span class="s1">data=data</span><span class="s3">,</span>
                                   <span class="s1">exposure=data[</span><span class="s4">'pyears'</span><span class="s1">].values)</span>
        <span class="s1">constr = </span><span class="s4">'C(agecat)[T.5] - C(agecat)[T.4] = 0.5'</span>
        <span class="s1">lc = patsy.DesignInfo(mod.exog_names).linear_constraint(constr)</span>
        <span class="s1">cls.res1 = fit_constrained(mod</span><span class="s3">, </span><span class="s1">lc.coefs</span><span class="s3">, </span><span class="s1">lc.constants</span><span class="s3">,</span>
                                   <span class="s1">fit_kwds={</span><span class="s4">'method'</span><span class="s1">: </span><span class="s4">'newton'</span><span class="s3">,</span>
                                             <span class="s4">'disp'</span><span class="s1">: </span><span class="s5">0</span><span class="s1">})</span>
        <span class="s1">cls.constraints = lc</span>
        <span class="s0"># TODO: bfgs fails to converge. overflow somewhere?</span>

        <span class="s0"># test method of Poisson, not monkey patched</span>
        <span class="s1">cls.res1m = mod.fit_constrained(constr</span><span class="s3">, </span><span class="s1">method=</span><span class="s4">'bfgs'</span><span class="s3">, </span><span class="s1">disp=</span><span class="s5">0</span><span class="s3">,</span>
                                        <span class="s1">start_params=cls.res1[</span><span class="s5">0</span><span class="s1">])</span>


<span class="s3">class </span><span class="s1">TestPoissonConstrained2c(CheckPoissonConstrainedMixin):</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">setup_class(cls):</span>

        <span class="s1">cls.res2 = results.results_exposure_constraint2</span>
        <span class="s1">cls.idx = [</span><span class="s5">6</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">5</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]  </span><span class="s0"># 2 is dropped baseline for categorical</span>

        <span class="s0"># example without offset</span>
        <span class="s1">formula = </span><span class="s4">'deaths ~ smokes + C(agecat)'</span>
        <span class="s1">mod = Poisson.from_formula(formula</span><span class="s3">, </span><span class="s1">data=data</span><span class="s3">,</span>
                                   <span class="s1">offset=np.log(data[</span><span class="s4">'pyears'</span><span class="s1">].values))</span>

        <span class="s1">constr = </span><span class="s4">'C(agecat)[T.5] - C(agecat)[T.4] = 0.5'</span>
        <span class="s1">lc = patsy.DesignInfo(mod.exog_names).linear_constraint(constr)</span>
        <span class="s1">cls.res1 = fit_constrained(mod</span><span class="s3">, </span><span class="s1">lc.coefs</span><span class="s3">, </span><span class="s1">lc.constants</span><span class="s3">,</span>
                                   <span class="s1">fit_kwds={</span><span class="s4">'method'</span><span class="s1">: </span><span class="s4">'newton'</span><span class="s3">, </span><span class="s4">'disp'</span><span class="s1">: </span><span class="s5">0</span><span class="s1">})</span>
        <span class="s1">cls.constraints = lc</span>
        <span class="s0"># TODO: bfgs fails</span>

        <span class="s0"># test method of Poisson, not monkey patched</span>
        <span class="s1">cls.res1m = mod.fit_constrained(constr</span><span class="s3">,</span>
                                        <span class="s1">method=</span><span class="s4">'bfgs'</span><span class="s3">, </span><span class="s1">disp=</span><span class="s5">0</span><span class="s3">,</span>
                                        <span class="s1">start_params=cls.res1[</span><span class="s5">0</span><span class="s1">])</span>


<span class="s3">class </span><span class="s1">TestGLMPoissonConstrained1a(CheckPoissonConstrainedMixin):</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">setup_class(cls):</span>
        <span class="s3">from </span><span class="s1">statsmodels.base._constraints </span><span class="s3">import </span><span class="s1">fit_constrained</span>

        <span class="s1">cls.res2 = results.results_noexposure_constraint</span>
        <span class="s0"># 2 is dropped baseline for categorical</span>
        <span class="s1">cls.idx = [</span><span class="s5">7</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">5</span><span class="s3">, </span><span class="s5">6</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">]</span>

        <span class="s0"># example without offset</span>
        <span class="s1">formula = </span><span class="s4">'deaths ~ logpyears + smokes + C(agecat)'</span>
        <span class="s1">mod = GLM.from_formula(formula</span><span class="s3">, </span><span class="s1">data=data</span><span class="s3">,</span>
                               <span class="s1">family=families.Poisson())</span>

        <span class="s1">constr = </span><span class="s4">'C(agecat)[T.4] = C(agecat)[T.5]'</span>
        <span class="s1">lc = patsy.DesignInfo(mod.exog_names).linear_constraint(constr)</span>
        <span class="s1">cls.res1 = fit_constrained(mod</span><span class="s3">, </span><span class="s1">lc.coefs</span><span class="s3">, </span><span class="s1">lc.constants</span><span class="s3">,</span>
                                   <span class="s1">fit_kwds={</span><span class="s4">'atol'</span><span class="s1">: </span><span class="s5">1e-10</span><span class="s1">})</span>
        <span class="s1">cls.constraints = lc</span>
        <span class="s1">cls.res1m = mod.fit_constrained(constr</span><span class="s3">, </span><span class="s1">atol=</span><span class="s5">1e-10</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">TestGLMPoissonConstrained1b(CheckPoissonConstrainedMixin):</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">setup_class(cls):</span>
        <span class="s3">from </span><span class="s1">statsmodels.base._constraints </span><span class="s3">import </span><span class="s1">fit_constrained</span>
        <span class="s3">from </span><span class="s1">statsmodels.genmod </span><span class="s3">import </span><span class="s1">families</span>
        <span class="s3">from </span><span class="s1">statsmodels.genmod.generalized_linear_model </span><span class="s3">import </span><span class="s1">GLM</span>

        <span class="s1">cls.res2 = results.results_exposure_constraint</span>
        <span class="s1">cls.idx = [</span><span class="s5">6</span><span class="s3">, </span><span class="s5">2</span><span class="s3">, </span><span class="s5">3</span><span class="s3">, </span><span class="s5">4</span><span class="s3">, </span><span class="s5">5</span><span class="s3">, </span><span class="s5">0</span><span class="s1">]  </span><span class="s0"># 2 is dropped baseline for categorical</span>

        <span class="s0"># example with offset</span>
        <span class="s1">formula = </span><span class="s4">'deaths ~ smokes + C(agecat)'</span>
        <span class="s1">mod = GLM.from_formula(formula</span><span class="s3">, </span><span class="s1">data=data</span><span class="s3">,</span>
                               <span class="s1">family=families.Poisson()</span><span class="s3">,</span>
                               <span class="s1">offset=np.log(data[</span><span class="s4">'pyears'</span><span class="s1">].values))</span>

        <span class="s1">constr = </span><span class="s4">'C(agecat)[T.4] = C(agecat)[T.5]'</span>
        <span class="s1">lc = patsy.DesignInfo(mod.exog_names).linear_constraint(constr)</span>

        <span class="s1">cls.res1 = fit_constrained(mod</span><span class="s3">, </span><span class="s1">lc.coefs</span><span class="s3">, </span><span class="s1">lc.constants</span><span class="s3">,</span>
                                   <span class="s1">fit_kwds={</span><span class="s4">'atol'</span><span class="s1">: </span><span class="s5">1e-10</span><span class="s1">})</span>
        <span class="s1">cls.constraints = lc</span>
        <span class="s1">cls.res1m = mod.fit_constrained(constr</span><span class="s3">, </span><span class="s1">atol=</span><span class="s5">1e-10</span><span class="s1">)._results</span>

    <span class="s3">def </span><span class="s1">test_compare_glm_poisson(self):</span>
        <span class="s1">res1 = self.res1m</span>
        <span class="s1">res2 = self.res2</span>

        <span class="s1">formula = </span><span class="s4">'deaths ~ smokes + C(agecat)'</span>
        <span class="s1">mod = Poisson.from_formula(formula</span><span class="s3">, </span><span class="s1">data=data</span><span class="s3">,</span>
                                   <span class="s1">exposure=data[</span><span class="s4">'pyears'</span><span class="s1">].values)</span>

        <span class="s1">constr = </span><span class="s4">'C(agecat)[T.4] = C(agecat)[T.5]'</span>
        <span class="s1">res2 = mod.fit_constrained(constr</span><span class="s3">, </span><span class="s1">start_params=self.res1m.params</span><span class="s3">,</span>
                                   <span class="s1">method=</span><span class="s4">'newton'</span><span class="s3">, </span><span class="s1">warn_convergence=</span><span class="s3">False,</span>
                                   <span class="s1">disp=</span><span class="s5">0</span><span class="s1">)</span>

        <span class="s0"># we get high precision because we use the params as start_params</span>

        <span class="s0"># basic, just as check that we have the same model</span>
        <span class="s1">assert_allclose(res1.params</span><span class="s3">, </span><span class="s1">res2.params</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s5">1e-12</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res1.bse</span><span class="s3">, </span><span class="s1">res2.bse</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s5">1e-11</span><span class="s1">)</span>

        <span class="s0"># check predict, fitted, ...</span>

        <span class="s1">predicted = res1.predict()</span>
        <span class="s1">assert_allclose(predicted</span><span class="s3">, </span><span class="s1">res2.predict()</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s5">1e-10</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res1.mu</span><span class="s3">, </span><span class="s1">predicted</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s5">1e-10</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res1.fittedvalues</span><span class="s3">, </span><span class="s1">predicted</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s5">1e-10</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res2.predict(which=</span><span class="s4">&quot;linear&quot;</span><span class="s1">)</span><span class="s3">,</span>
                        <span class="s1">res2.predict(which=</span><span class="s4">&quot;linear&quot;</span><span class="s1">)</span><span class="s3">,</span>
                        <span class="s1">rtol=</span><span class="s5">1e-10</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">CheckGLMConstrainedMixin(CheckPoissonConstrainedMixin):</span>
    <span class="s0"># add tests for some GLM specific attributes</span>

    <span class="s3">def </span><span class="s1">test_glm(self):</span>
        <span class="s1">res2 = self.res2  </span><span class="s0"># reference results</span>
        <span class="s1">res1 = self.res1m</span>

        <span class="s0"># assert_allclose(res1.aic, res2.aic, rtol=1e-10)  # far away</span>
        <span class="s0"># Stata aic in ereturn and in estat ic are very different</span>
        <span class="s0"># we have the same as estat ic</span>
        <span class="s0"># see issue GH#1733</span>
        <span class="s1">assert_allclose(res1.aic</span><span class="s3">, </span><span class="s1">res2.infocrit[</span><span class="s5">4</span><span class="s1">]</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s5">1e-10</span><span class="s1">)</span>

        <span class="s3">import </span><span class="s1">warnings</span>

        <span class="s3">with </span><span class="s1">warnings.catch_warnings():</span>
            <span class="s1">warnings.simplefilter(</span><span class="s4">&quot;ignore&quot;</span><span class="s3">, </span><span class="s1">FutureWarning)</span>
            <span class="s0"># FutureWarning for BIC changes</span>
            <span class="s1">assert_allclose(res1.bic</span><span class="s3">, </span><span class="s1">res2.bic</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s5">1e-10</span><span class="s1">)</span>
        <span class="s0"># bic is deviance based</span>
        <span class="s0">#  assert_allclose(res1.bic, res2.infocrit[5], rtol=1e-10)</span>
        <span class="s1">assert_allclose(res1.deviance</span><span class="s3">, </span><span class="s1">res2.deviance</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s5">1e-10</span><span class="s1">)</span>
        <span class="s0"># TODO: which chi2 are these</span>
        <span class="s0"># assert_allclose(res1.pearson_chi2, res2.chi2, rtol=1e-10)</span>


<span class="s3">class </span><span class="s1">TestGLMLogitConstrained1(CheckGLMConstrainedMixin):</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">cls.idx = slice(</span><span class="s3">None</span><span class="s1">)</span>
        <span class="s0"># params sequence same as Stata, but Stata reports param = nan</span>
        <span class="s0"># and we have param = value = 0</span>

        <span class="s1">cls.res2 = reslogit.results_constraint1</span>

        <span class="s1">mod1 = GLM(spector_data.endog</span><span class="s3">, </span><span class="s1">spector_data.exog</span><span class="s3">,</span>
                   <span class="s1">family=families.Binomial())</span>

        <span class="s1">constr = </span><span class="s4">'x1 = 2.8'</span>
        <span class="s1">cls.res1m = mod1.fit_constrained(constr)</span>

        <span class="s1">R</span><span class="s3">, </span><span class="s1">q = cls.res1m.constraints</span>
        <span class="s1">cls.res1 = fit_constrained(mod1</span><span class="s3">, </span><span class="s1">R</span><span class="s3">, </span><span class="s1">q)</span>


<span class="s3">class </span><span class="s1">TestLogitConstrained1(CheckGLMConstrainedMixin):</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">cls.idx = slice(</span><span class="s3">None</span><span class="s1">)</span>
        <span class="s0"># params sequence same as Stata, but Stata reports param = nan</span>
        <span class="s0"># and we have param = value = 0</span>

        <span class="s0"># res1ul = Logit(data.endog, data.exog).fit(method=&quot;newton&quot;, disp=0)</span>
        <span class="s1">cls.res2 = reslogit.results_constraint1</span>

        <span class="s1">mod1 = Logit(spector_data.endog</span><span class="s3">, </span><span class="s1">spector_data.exog)</span>

        <span class="s1">constr = </span><span class="s4">'x1 = 2.8'</span>
        <span class="s0"># newton doesn't work, raises hessian singular</span>
        <span class="s1">cls.res1m = mod1.fit_constrained(constr</span><span class="s3">, </span><span class="s1">method=</span><span class="s4">'bfgs'</span><span class="s1">)</span>

        <span class="s1">R</span><span class="s3">, </span><span class="s1">q = cls.res1m.constraints.coefs</span><span class="s3">, </span><span class="s1">cls.res1m.constraints.constants</span>
        <span class="s1">cls.res1 = fit_constrained(mod1</span><span class="s3">, </span><span class="s1">R</span><span class="s3">, </span><span class="s1">q</span><span class="s3">, </span><span class="s1">fit_kwds={</span><span class="s4">'method'</span><span class="s1">: </span><span class="s4">'bfgs'</span><span class="s1">})</span>

    <span class="s1">@pytest.mark.skip(reason=</span><span class="s4">'not a GLM'</span><span class="s1">)</span>
    <span class="s3">def </span><span class="s1">test_glm(self):</span>
        <span class="s3">return</span>


<span class="s3">class </span><span class="s1">TestGLMLogitConstrained2(CheckGLMConstrainedMixin):</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">cls.idx = slice(</span><span class="s3">None</span><span class="s1">)  </span><span class="s0"># params sequence same as Stata</span>
        <span class="s1">cls.res2 = reslogit.results_constraint2</span>

        <span class="s1">mod1 = GLM(spector_data.endog</span><span class="s3">, </span><span class="s1">spector_data.exog</span><span class="s3">,</span>
                   <span class="s1">family=families.Binomial())</span>

        <span class="s1">constr = </span><span class="s4">'x1 - x3 = 0'</span>
        <span class="s1">cls.res1m = mod1.fit_constrained(constr</span><span class="s3">, </span><span class="s1">atol=</span><span class="s5">1e-10</span><span class="s1">)</span>

        <span class="s0"># patsy compatible constraints</span>
        <span class="s1">R</span><span class="s3">, </span><span class="s1">q = cls.res1m.constraints.coefs</span><span class="s3">, </span><span class="s1">cls.res1m.constraints.constants</span>
        <span class="s1">cls.res1 = fit_constrained(mod1</span><span class="s3">, </span><span class="s1">R</span><span class="s3">, </span><span class="s1">q</span><span class="s3">, </span><span class="s1">fit_kwds={</span><span class="s4">'atol'</span><span class="s1">: </span><span class="s5">1e-10</span><span class="s1">})</span>
        <span class="s1">cls.constraints_rq = (R</span><span class="s3">, </span><span class="s1">q)</span>

    <span class="s3">def </span><span class="s1">test_predict(self):</span>
        <span class="s0"># results only available for this case</span>
        <span class="s1">res2 = self.res2  </span><span class="s0"># reference results</span>
        <span class="s1">res1 = self.res1m</span>

        <span class="s1">predicted = res1.predict()</span>
        <span class="s1">assert_allclose(predicted</span><span class="s3">, </span><span class="s1">res2.predict_mu</span><span class="s3">, </span><span class="s1">atol=</span><span class="s5">1e-7</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res1.mu</span><span class="s3">, </span><span class="s1">predicted</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s5">1e-10</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res1.fittedvalues</span><span class="s3">, </span><span class="s1">predicted</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s5">1e-10</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.smoke</span>
    <span class="s3">def </span><span class="s1">test_summary(self):</span>
        <span class="s0"># trailing text in summary, assumes it's the first extra string</span>
        <span class="s1">summ = self.res1m.summary()</span>
        <span class="s1">assert_(</span><span class="s4">'linear equality constraints' </span><span class="s3">in </span><span class="s1">summ.extra_txt)</span>

        <span class="s1">lc_string = str(self.res1m.constraints)</span>
        <span class="s3">assert </span><span class="s1">lc_string == </span><span class="s4">&quot;x1 - x3 = 0.0&quot;</span>

    <span class="s1">@pytest.mark.smoke</span>
    <span class="s3">def </span><span class="s1">test_summary2(self):</span>
        <span class="s0"># trailing text in summary, assumes it's the first extra string</span>
        <span class="s3">import </span><span class="s1">warnings</span>

        <span class="s3">with </span><span class="s1">warnings.catch_warnings():</span>
            <span class="s1">warnings.simplefilter(</span><span class="s4">&quot;ignore&quot;</span><span class="s3">, </span><span class="s1">FutureWarning)</span>
            <span class="s0"># FutureWarning for BIC changes</span>
            <span class="s1">summ = self.res1m.summary2()</span>

        <span class="s1">assert_(</span><span class="s4">'linear equality constraints' </span><span class="s3">in </span><span class="s1">summ.extra_txt[</span><span class="s5">0</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">test_fit_constrained_wrap(self):</span>
        <span class="s0"># minimal test</span>
        <span class="s1">res2 = self.res2  </span><span class="s0"># reference results</span>

        <span class="s3">from </span><span class="s1">statsmodels.base._constraints </span><span class="s3">import </span><span class="s1">fit_constrained_wrap</span>
        <span class="s1">res_wrap = fit_constrained_wrap(self.res1m.model</span><span class="s3">, </span><span class="s1">self.constraints_rq)</span>
        <span class="s1">assert_allclose(res_wrap.params</span><span class="s3">, </span><span class="s1">res2.params</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s5">1e-6</span><span class="s1">)</span>
        <span class="s1">assert_allclose(res_wrap.params</span><span class="s3">, </span><span class="s1">res2.params</span><span class="s3">, </span><span class="s1">rtol=</span><span class="s5">1e-6</span><span class="s1">)</span>


<span class="s3">class </span><span class="s1">TestGLMLogitConstrained2HC(CheckGLMConstrainedMixin):</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">cls.idx = slice(</span><span class="s3">None</span><span class="s1">)  </span><span class="s0"># params sequence same as Stata</span>
        <span class="s1">cls.res2 = reslogit.results_constraint2_robust</span>

        <span class="s1">mod1 = GLM(spector_data.endog</span><span class="s3">, </span><span class="s1">spector_data.exog</span><span class="s3">,</span>
                   <span class="s1">family=families.Binomial())</span>

        <span class="s0"># not used to match Stata for HC</span>
        <span class="s0"># nobs, k_params = mod1.exog.shape</span>
        <span class="s0"># k_params -= 1   # one constraint</span>
        <span class="s1">cov_type = </span><span class="s4">'HC0'</span>
        <span class="s1">cov_kwds = {</span><span class="s4">'scaling_factor'</span><span class="s1">: </span><span class="s5">32</span><span class="s1">/</span><span class="s5">31</span><span class="s1">}</span>
        <span class="s0"># looks like nobs / (nobs - 1) and not (nobs - 1.) / (nobs - k_params)}</span>
        <span class="s1">constr = </span><span class="s4">'x1 - x3 = 0'</span>
        <span class="s1">cls.res1m = mod1.fit_constrained(constr</span><span class="s3">, </span><span class="s1">cov_type=cov_type</span><span class="s3">,</span>
                                         <span class="s1">cov_kwds=cov_kwds</span><span class="s3">, </span><span class="s1">atol=</span><span class="s5">1e-10</span><span class="s1">)</span>

        <span class="s1">R</span><span class="s3">, </span><span class="s1">q = cls.res1m.constraints</span>
        <span class="s1">cls.res1 = fit_constrained(mod1</span><span class="s3">, </span><span class="s1">R</span><span class="s3">, </span><span class="s1">q</span><span class="s3">, </span><span class="s1">fit_kwds={</span><span class="s4">'atol'</span><span class="s1">: </span><span class="s5">1e-10</span><span class="s3">,</span>
                                                         <span class="s4">'cov_type'</span><span class="s1">: cov_type</span><span class="s3">,</span>
                                                         <span class="s4">'cov_kwds'</span><span class="s1">: cov_kwds})</span>
        <span class="s1">cls.constraints_rq = (R</span><span class="s3">, </span><span class="s1">q)</span>


<span class="s3">class </span><span class="s1">TestLogitConstrained2HC(CheckGLMConstrainedMixin):</span>

    <span class="s1">@classmethod</span>
    <span class="s3">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">cls.idx = slice(</span><span class="s3">None</span><span class="s1">)  </span><span class="s0"># params sequence same as Stata</span>
        <span class="s0"># res1ul = Logit(data.endog, data.exog).fit(method=&quot;newton&quot;, disp=0)</span>
        <span class="s1">cls.res2 = reslogit.results_constraint2_robust</span>

        <span class="s1">mod1 = Logit(spector_data.endog</span><span class="s3">, </span><span class="s1">spector_data.exog)</span>

        <span class="s0"># not used to match Stata for HC</span>
        <span class="s0"># nobs, k_params = mod1.exog.shape</span>
        <span class="s0"># k_params -= 1   # one constraint</span>
        <span class="s1">cov_type = </span><span class="s4">'HC0'</span>
        <span class="s1">cov_kwds = {</span><span class="s4">'scaling_factor'</span><span class="s1">: </span><span class="s5">32</span><span class="s1">/</span><span class="s5">31</span><span class="s1">}</span>
        <span class="s0"># looks like nobs / (nobs - 1) and not (nobs - 1.) / (nobs - k_params)}</span>
        <span class="s1">constr = </span><span class="s4">'x1 - x3 = 0'</span>
        <span class="s1">cls.res1m = mod1.fit_constrained(constr</span><span class="s3">, </span><span class="s1">cov_type=cov_type</span><span class="s3">,</span>
                                         <span class="s1">cov_kwds=cov_kwds</span><span class="s3">, </span><span class="s1">tol=</span><span class="s5">1e-10</span><span class="s3">,</span>
                                         <span class="s1">)</span>

        <span class="s1">R</span><span class="s3">, </span><span class="s1">q = cls.res1m.constraints.coefs</span><span class="s3">, </span><span class="s1">cls.res1m.constraints.constants</span>
        <span class="s1">cls.res1 = fit_constrained(mod1</span><span class="s3">, </span><span class="s1">R</span><span class="s3">, </span><span class="s1">q</span><span class="s3">, </span><span class="s1">fit_kwds={</span><span class="s4">'tol'</span><span class="s1">: </span><span class="s5">1e-10</span><span class="s3">,</span>
                                                         <span class="s4">'cov_type'</span><span class="s1">: cov_type</span><span class="s3">,</span>
                                                         <span class="s4">'cov_kwds'</span><span class="s1">: cov_kwds})</span>
        <span class="s1">cls.constraints_rq = (R</span><span class="s3">, </span><span class="s1">q)</span>

    <span class="s1">@pytest.mark.skip(reason=</span><span class="s4">'not a GLM'</span><span class="s1">)</span>
    <span class="s3">def </span><span class="s1">test_glm(self):</span>
        <span class="s3">return</span>


<span class="s3">def </span><span class="s1">junk():  </span><span class="s0"># FIXME: make this into a test, or move/remove</span>
    <span class="s0"># Singular Matrix in mod1a.fit()</span>

    <span class="s0"># same as Stata default</span>
    <span class="s1">formula2 = </span><span class="s4">'deaths ~ C(agecat) + C(smokes) : C(agecat)'</span>

    <span class="s1">mod = Poisson.from_formula(formula2</span><span class="s3">, </span><span class="s1">data=data</span><span class="s3">,</span>
                               <span class="s1">exposure=data[</span><span class="s4">'pyears'</span><span class="s1">].values)</span>

    <span class="s1">mod.fit()</span>

    <span class="s1">constraints = </span><span class="s4">'C(smokes)[T.1]:C(agecat)[3] = C(smokes)[T.1]:C(agec`at)[4]'</span>

    <span class="s3">import </span><span class="s1">patsy</span>
    <span class="s1">lc = patsy.DesignInfo(mod.exog_names).linear_constraint(constraints)</span>
    <span class="s1">R</span><span class="s3">, </span><span class="s1">q = lc.coefs</span><span class="s3">, </span><span class="s1">lc.constants</span>

    <span class="s1">mod.fit_constrained(R</span><span class="s3">, </span><span class="s1">q</span><span class="s3">, </span><span class="s1">fit_kwds={</span><span class="s4">'method'</span><span class="s1">: </span><span class="s4">'bfgs'</span><span class="s1">})</span>

    <span class="s0"># example without offset</span>
    <span class="s1">formula1a = </span><span class="s4">'deaths ~ logpyears + smokes + C(agecat)'</span>
    <span class="s1">mod1a = Poisson.from_formula(formula1a</span><span class="s3">, </span><span class="s1">data=data)</span>

    <span class="s1">mod1a.fit()</span>
    <span class="s1">lc_1a = patsy.DesignInfo(mod1a.exog_names).linear_constraint(</span>
        <span class="s4">'C(agecat)[T.4] = C(agecat)[T.5]'</span><span class="s1">)</span>
    <span class="s1">mod1a.fit_constrained(lc_1a.coefs</span><span class="s3">, </span><span class="s1">lc_1a.constants</span><span class="s3">,</span>
                          <span class="s1">fit_kwds={</span><span class="s4">'method'</span><span class="s1">: </span><span class="s4">'newton'</span><span class="s1">})</span>
</pre>
</body>
</html>