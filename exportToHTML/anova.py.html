<html>
<head>
<title>anova.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #808080;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
anova.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">scipy </span><span class="s0">import </span><span class="s1">stats</span>
<span class="s0">import </span><span class="s1">pandas </span><span class="s0">as </span><span class="s1">pd</span>
<span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">DataFrame</span><span class="s0">, </span><span class="s1">Index</span>
<span class="s0">import </span><span class="s1">patsy</span>

<span class="s0">from </span><span class="s1">statsmodels.regression.linear_model </span><span class="s0">import </span><span class="s1">OLS</span>
<span class="s0">from </span><span class="s1">statsmodels.compat.python </span><span class="s0">import </span><span class="s1">lrange</span>
<span class="s0">from </span><span class="s1">statsmodels.formula.formulatools </span><span class="s0">import </span><span class="s1">(_remove_intercept_patsy</span><span class="s0">,</span>
                                    <span class="s1">_has_intercept</span><span class="s0">, </span><span class="s1">_intercept_idx)</span>
<span class="s0">from </span><span class="s1">statsmodels.iolib </span><span class="s0">import </span><span class="s1">summary2</span>


<span class="s0">def </span><span class="s1">_get_covariance(model</span><span class="s0">, </span><span class="s1">robust):</span>
    <span class="s0">if </span><span class="s1">robust </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">model.cov_params()</span>
    <span class="s0">elif </span><span class="s1">robust == </span><span class="s2">&quot;hc0&quot;</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">model.cov_HC0</span>
    <span class="s0">elif </span><span class="s1">robust == </span><span class="s2">&quot;hc1&quot;</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">model.cov_HC1</span>
    <span class="s0">elif </span><span class="s1">robust == </span><span class="s2">&quot;hc2&quot;</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">model.cov_HC2</span>
    <span class="s0">elif </span><span class="s1">robust == </span><span class="s2">&quot;hc3&quot;</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">model.cov_HC3</span>
    <span class="s0">else</span><span class="s1">:  </span><span class="s3"># pragma: no cover</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;robust options %s not understood&quot; </span><span class="s1">% robust)</span>


<span class="s3"># NOTE: these need to take into account weights !</span>

<span class="s0">def </span><span class="s1">anova_single(model</span><span class="s0">, </span><span class="s1">**kwargs):</span>
    <span class="s4">&quot;&quot;&quot; 
    Anova table for one fitted linear model. 
 
    Parameters 
    ---------- 
    model : fitted linear model results instance 
        A fitted linear model 
    typ : int or str {1,2,3} or {&quot;I&quot;,&quot;II&quot;,&quot;III&quot;} 
        Type of sum of squares to use. 
 
    **kwargs** 
 
    scale : float 
        Estimate of variance, If None, will be estimated from the largest 
    model. Default is None. 
        test : str {&quot;F&quot;, &quot;Chisq&quot;, &quot;Cp&quot;} or None 
        Test statistics to provide. Default is &quot;F&quot;. 
 
    Notes 
    ----- 
    Use of this function is discouraged. Use anova_lm instead. 
    &quot;&quot;&quot;</span>
    <span class="s1">test = kwargs.get(</span><span class="s2">&quot;test&quot;</span><span class="s0">, </span><span class="s2">&quot;F&quot;</span><span class="s1">)</span>
    <span class="s1">scale = kwargs.get(</span><span class="s2">&quot;scale&quot;</span><span class="s0">, None</span><span class="s1">)</span>
    <span class="s1">typ = kwargs.get(</span><span class="s2">&quot;typ&quot;</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">robust = kwargs.get(</span><span class="s2">&quot;robust&quot;</span><span class="s0">, None</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">robust:</span>
        <span class="s1">robust = robust.lower()</span>

    <span class="s1">endog = model.model.endog</span>
    <span class="s1">exog = model.model.exog</span>
    <span class="s1">nobs = exog.shape[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s1">response_name = model.model.endog_names</span>
    <span class="s1">design_info = model.model.data.design_info</span>
    <span class="s1">exog_names = model.model.exog_names</span>
    <span class="s3"># +1 for resids</span>
    <span class="s1">n_rows = (len(design_info.terms) - _has_intercept(design_info) + </span><span class="s5">1</span><span class="s1">)</span>

    <span class="s1">pr_test = </span><span class="s2">&quot;PR(&gt;%s)&quot; </span><span class="s1">% test</span>
    <span class="s1">names = [</span><span class="s2">'df'</span><span class="s0">, </span><span class="s2">'sum_sq'</span><span class="s0">, </span><span class="s2">'mean_sq'</span><span class="s0">, </span><span class="s1">test</span><span class="s0">, </span><span class="s1">pr_test]</span>

    <span class="s1">table = DataFrame(np.zeros((n_rows</span><span class="s0">, </span><span class="s5">5</span><span class="s1">))</span><span class="s0">, </span><span class="s1">columns=names)</span>

    <span class="s0">if </span><span class="s1">typ </span><span class="s0">in </span><span class="s1">[</span><span class="s5">1</span><span class="s0">, </span><span class="s2">&quot;I&quot;</span><span class="s1">]:</span>
        <span class="s0">return </span><span class="s1">anova1_lm_single(model</span><span class="s0">, </span><span class="s1">endog</span><span class="s0">, </span><span class="s1">exog</span><span class="s0">, </span><span class="s1">nobs</span><span class="s0">, </span><span class="s1">design_info</span><span class="s0">, </span><span class="s1">table</span><span class="s0">,</span>
                                <span class="s1">n_rows</span><span class="s0">, </span><span class="s1">test</span><span class="s0">, </span><span class="s1">pr_test</span><span class="s0">, </span><span class="s1">robust)</span>
    <span class="s0">elif </span><span class="s1">typ </span><span class="s0">in </span><span class="s1">[</span><span class="s5">2</span><span class="s0">, </span><span class="s2">&quot;II&quot;</span><span class="s1">]:</span>
        <span class="s0">return </span><span class="s1">anova2_lm_single(model</span><span class="s0">, </span><span class="s1">design_info</span><span class="s0">, </span><span class="s1">n_rows</span><span class="s0">, </span><span class="s1">test</span><span class="s0">, </span><span class="s1">pr_test</span><span class="s0">,</span>
                                <span class="s1">robust)</span>
    <span class="s0">elif </span><span class="s1">typ </span><span class="s0">in </span><span class="s1">[</span><span class="s5">3</span><span class="s0">, </span><span class="s2">&quot;III&quot;</span><span class="s1">]:</span>
        <span class="s0">return </span><span class="s1">anova3_lm_single(model</span><span class="s0">, </span><span class="s1">design_info</span><span class="s0">, </span><span class="s1">n_rows</span><span class="s0">, </span><span class="s1">test</span><span class="s0">, </span><span class="s1">pr_test</span><span class="s0">,</span>
                                <span class="s1">robust)</span>
    <span class="s0">elif </span><span class="s1">typ </span><span class="s0">in </span><span class="s1">[</span><span class="s5">4</span><span class="s0">, </span><span class="s2">&quot;IV&quot;</span><span class="s1">]:</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError(</span><span class="s2">&quot;Type IV not yet implemented&quot;</span><span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:  </span><span class="s3"># pragma: no cover</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Type %s not understood&quot; </span><span class="s1">% str(typ))</span>


<span class="s0">def </span><span class="s1">anova1_lm_single(model</span><span class="s0">, </span><span class="s1">endog</span><span class="s0">, </span><span class="s1">exog</span><span class="s0">, </span><span class="s1">nobs</span><span class="s0">, </span><span class="s1">design_info</span><span class="s0">, </span><span class="s1">table</span><span class="s0">, </span><span class="s1">n_rows</span><span class="s0">, </span><span class="s1">test</span><span class="s0">,</span>
                     <span class="s1">pr_test</span><span class="s0">, </span><span class="s1">robust):</span>
    <span class="s4">&quot;&quot;&quot; 
    Anova table for one fitted linear model. 
 
    Parameters 
    ---------- 
    model : fitted linear model results instance 
        A fitted linear model 
 
    **kwargs** 
 
    scale : float 
        Estimate of variance, If None, will be estimated from the largest 
    model. Default is None. 
        test : str {&quot;F&quot;, &quot;Chisq&quot;, &quot;Cp&quot;} or None 
        Test statistics to provide. Default is &quot;F&quot;. 
 
    Notes 
    ----- 
    Use of this function is discouraged. Use anova_lm instead. 
    &quot;&quot;&quot;</span>
    <span class="s3">#maybe we should rethink using pinv &gt; qr in OLS/linear models?</span>
    <span class="s1">effects = getattr(model</span><span class="s0">, </span><span class="s2">'effects'</span><span class="s0">, None</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">effects </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">q</span><span class="s0">,</span><span class="s1">r = np.linalg.qr(exog)</span>
        <span class="s1">effects = np.dot(q.T</span><span class="s0">, </span><span class="s1">endog)</span>

    <span class="s1">arr = np.zeros((len(design_info.terms)</span><span class="s0">, </span><span class="s1">len(design_info.column_names)))</span>
    <span class="s1">slices = [design_info.slice(name) </span><span class="s0">for </span><span class="s1">name </span><span class="s0">in </span><span class="s1">design_info.term_names]</span>
    <span class="s0">for </span><span class="s1">i</span><span class="s0">,</span><span class="s1">slice_ </span><span class="s0">in </span><span class="s1">enumerate(slices):</span>
        <span class="s1">arr[i</span><span class="s0">, </span><span class="s1">slice_] = </span><span class="s5">1</span>

    <span class="s1">sum_sq = np.dot(arr</span><span class="s0">, </span><span class="s1">effects**</span><span class="s5">2</span><span class="s1">)</span>
    <span class="s3">#NOTE: assumes intercept is first column</span>
    <span class="s1">idx = _intercept_idx(design_info)</span>
    <span class="s1">sum_sq = sum_sq[~idx]</span>
    <span class="s1">term_names = np.array(design_info.term_names) </span><span class="s3"># want boolean indexing</span>
    <span class="s1">term_names = term_names[~idx]</span>

    <span class="s1">index = term_names.tolist()</span>
    <span class="s1">table.index = Index(index + [</span><span class="s2">'Residual'</span><span class="s1">])</span>
    <span class="s1">table.loc[index</span><span class="s0">, </span><span class="s1">[</span><span class="s2">'df'</span><span class="s0">, </span><span class="s2">'sum_sq'</span><span class="s1">]] = np.c_[arr[~idx].sum(</span><span class="s5">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">sum_sq]</span>
    <span class="s3"># fill in residual</span>
    <span class="s1">table.loc[</span><span class="s2">'Residual'</span><span class="s0">, </span><span class="s1">[</span><span class="s2">'sum_sq'</span><span class="s0">,</span><span class="s2">'df'</span><span class="s1">]] = model.ssr</span><span class="s0">, </span><span class="s1">model.df_resid</span>
    <span class="s0">if </span><span class="s1">test == </span><span class="s2">'F'</span><span class="s1">:</span>
        <span class="s1">table[test] = ((table[</span><span class="s2">'sum_sq'</span><span class="s1">] / table[</span><span class="s2">'df'</span><span class="s1">]) /</span>
                       <span class="s1">(model.ssr / model.df_resid))</span>
        <span class="s1">table[pr_test] = stats.f.sf(table[</span><span class="s2">&quot;F&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">table[</span><span class="s2">&quot;df&quot;</span><span class="s1">]</span><span class="s0">,</span>
                                    <span class="s1">model.df_resid)</span>
        <span class="s1">table.loc[</span><span class="s2">'Residual'</span><span class="s0">, </span><span class="s1">[test</span><span class="s0">, </span><span class="s1">pr_test]] = np.nan</span><span class="s0">, </span><span class="s1">np.nan</span>
    <span class="s1">table[</span><span class="s2">'mean_sq'</span><span class="s1">] = table[</span><span class="s2">'sum_sq'</span><span class="s1">] / table[</span><span class="s2">'df'</span><span class="s1">]</span>
    <span class="s0">return </span><span class="s1">table</span>

<span class="s3">#NOTE: the below is not agnostic about formula...</span>
<span class="s0">def </span><span class="s1">anova2_lm_single(model</span><span class="s0">, </span><span class="s1">design_info</span><span class="s0">, </span><span class="s1">n_rows</span><span class="s0">, </span><span class="s1">test</span><span class="s0">, </span><span class="s1">pr_test</span><span class="s0">, </span><span class="s1">robust):</span>
    <span class="s4">&quot;&quot;&quot; 
    Anova type II table for one fitted linear model. 
 
    Parameters 
    ---------- 
    model : fitted linear model results instance 
        A fitted linear model 
 
    **kwargs** 
 
    scale : float 
        Estimate of variance, If None, will be estimated from the largest 
    model. Default is None. 
        test : str {&quot;F&quot;, &quot;Chisq&quot;, &quot;Cp&quot;} or None 
        Test statistics to provide. Default is &quot;F&quot;. 
 
    Notes 
    ----- 
    Use of this function is discouraged. Use anova_lm instead. 
 
    Type II 
    Sum of Squares compares marginal contribution of terms. Thus, it is 
    not particularly useful for models with significant interaction terms. 
    &quot;&quot;&quot;</span>
    <span class="s1">terms_info = design_info.terms[:] </span><span class="s3"># copy</span>
    <span class="s1">terms_info = _remove_intercept_patsy(terms_info)</span>

    <span class="s1">names = [</span><span class="s2">'sum_sq'</span><span class="s0">, </span><span class="s2">'df'</span><span class="s0">, </span><span class="s1">test</span><span class="s0">, </span><span class="s1">pr_test]</span>

    <span class="s1">table = DataFrame(np.zeros((n_rows</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span><span class="s0">, </span><span class="s1">columns = names)</span>
    <span class="s1">cov = _get_covariance(model</span><span class="s0">, None</span><span class="s1">)</span>
    <span class="s1">robust_cov = _get_covariance(model</span><span class="s0">, </span><span class="s1">robust)</span>
    <span class="s1">col_order = []</span>
    <span class="s1">index = []</span>
    <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">term </span><span class="s0">in </span><span class="s1">enumerate(terms_info):</span>
        <span class="s3"># grab all varaibles except interaction effects that contain term</span>
        <span class="s3"># need two hypotheses matrices L1 is most restrictive, ie., term==0</span>
        <span class="s3"># L2 is everything except term==0</span>
        <span class="s1">cols = design_info.slice(term)</span>
        <span class="s1">L1 = lrange(cols.start</span><span class="s0">, </span><span class="s1">cols.stop)</span>
        <span class="s1">L2 = []</span>
        <span class="s1">term_set = set(term.factors)</span>
        <span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">terms_info: </span><span class="s3"># for the term you have</span>
            <span class="s1">other_set = set(t.factors)</span>
            <span class="s0">if </span><span class="s1">term_set.issubset(other_set) </span><span class="s0">and not </span><span class="s1">term_set == other_set:</span>
                <span class="s1">col = design_info.slice(t)</span>
                <span class="s3"># on a higher order term containing current `term`</span>
                <span class="s1">L1.extend(lrange(col.start</span><span class="s0">, </span><span class="s1">col.stop))</span>
                <span class="s1">L2.extend(lrange(col.start</span><span class="s0">, </span><span class="s1">col.stop))</span>

        <span class="s1">L1 = np.eye(model.model.exog.shape[</span><span class="s5">1</span><span class="s1">])[L1]</span>
        <span class="s1">L2 = np.eye(model.model.exog.shape[</span><span class="s5">1</span><span class="s1">])[L2]</span>

        <span class="s0">if </span><span class="s1">L2.size:</span>
            <span class="s1">LVL = np.dot(np.dot(L1</span><span class="s0">,</span><span class="s1">robust_cov)</span><span class="s0">,</span><span class="s1">L2.T)</span>
            <span class="s0">from </span><span class="s1">scipy </span><span class="s0">import </span><span class="s1">linalg</span>
            <span class="s1">orth_compl</span><span class="s0">,</span><span class="s1">_ = linalg.qr(LVL)</span>
            <span class="s1">r = L1.shape[</span><span class="s5">0</span><span class="s1">] - L2.shape[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s3"># L1|2</span>
            <span class="s3"># use the non-unique orthogonal completion since L12 is rank r</span>
            <span class="s1">L12 = np.dot(orth_compl[:</span><span class="s0">,</span><span class="s1">-r:].T</span><span class="s0">, </span><span class="s1">L1)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">L12 = L1</span>
            <span class="s1">r = L1.shape[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s3">#from IPython.core.debugger import Pdb; Pdb().set_trace()</span>
        <span class="s0">if </span><span class="s1">test == </span><span class="s2">'F'</span><span class="s1">:</span>
            <span class="s1">f = model.f_test(L12</span><span class="s0">, </span><span class="s1">cov_p=robust_cov)</span>
            <span class="s1">table.loc[table.index[i]</span><span class="s0">, </span><span class="s1">test] = test_value = f.fvalue</span>
            <span class="s1">table.loc[table.index[i]</span><span class="s0">, </span><span class="s1">pr_test] = f.pvalue</span>

        <span class="s3"># need to back out SSR from f_test</span>
        <span class="s1">table.loc[table.index[i]</span><span class="s0">, </span><span class="s2">'df'</span><span class="s1">] = r</span>
        <span class="s1">col_order.append(cols.start)</span>
        <span class="s1">index.append(term.name())</span>

    <span class="s1">table.index = Index(index + [</span><span class="s2">'Residual'</span><span class="s1">])</span>
    <span class="s1">table = table.iloc[np.argsort(col_order + [model.model.exog.shape[</span><span class="s5">1</span><span class="s1">]+</span><span class="s5">1</span><span class="s1">])]</span>
    <span class="s3"># back out sum of squares from f_test</span>
    <span class="s1">ssr = table[test] * table[</span><span class="s2">'df'</span><span class="s1">] * model.ssr/model.df_resid</span>
    <span class="s1">table[</span><span class="s2">'sum_sq'</span><span class="s1">] = ssr</span>
    <span class="s3"># fill in residual</span>
    <span class="s1">table.loc[</span><span class="s2">'Residual'</span><span class="s0">, </span><span class="s1">[</span><span class="s2">'sum_sq'</span><span class="s0">,</span><span class="s2">'df'</span><span class="s0">, </span><span class="s1">test</span><span class="s0">, </span><span class="s1">pr_test]] = (model.ssr</span><span class="s0">,</span>
                                                            <span class="s1">model.df_resid</span><span class="s0">,</span>
                                                            <span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan)</span>

    <span class="s0">return </span><span class="s1">table</span>

<span class="s0">def </span><span class="s1">anova3_lm_single(model</span><span class="s0">, </span><span class="s1">design_info</span><span class="s0">, </span><span class="s1">n_rows</span><span class="s0">, </span><span class="s1">test</span><span class="s0">, </span><span class="s1">pr_test</span><span class="s0">, </span><span class="s1">robust):</span>
    <span class="s1">n_rows += _has_intercept(design_info)</span>
    <span class="s1">terms_info = design_info.terms</span>

    <span class="s1">names = [</span><span class="s2">'sum_sq'</span><span class="s0">, </span><span class="s2">'df'</span><span class="s0">, </span><span class="s1">test</span><span class="s0">, </span><span class="s1">pr_test]</span>

    <span class="s1">table = DataFrame(np.zeros((n_rows</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span><span class="s0">, </span><span class="s1">columns = names)</span>
    <span class="s1">cov = _get_covariance(model</span><span class="s0">, </span><span class="s1">robust)</span>
    <span class="s1">col_order = []</span>
    <span class="s1">index = []</span>
    <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">term </span><span class="s0">in </span><span class="s1">enumerate(terms_info):</span>
        <span class="s3"># grab term, hypothesis is that term == 0</span>
        <span class="s1">cols = design_info.slice(term)</span>
        <span class="s1">L1 = np.eye(model.model.exog.shape[</span><span class="s5">1</span><span class="s1">])[cols]</span>
        <span class="s1">L12 = L1</span>
        <span class="s1">r = L1.shape[</span><span class="s5">0</span><span class="s1">]</span>

        <span class="s0">if </span><span class="s1">test == </span><span class="s2">'F'</span><span class="s1">:</span>
            <span class="s1">f = model.f_test(L12</span><span class="s0">, </span><span class="s1">cov_p=cov)</span>
            <span class="s1">table.loc[table.index[i]</span><span class="s0">, </span><span class="s1">test] = test_value = f.fvalue</span>
            <span class="s1">table.loc[table.index[i]</span><span class="s0">, </span><span class="s1">pr_test] = f.pvalue</span>

        <span class="s3"># need to back out SSR from f_test</span>
        <span class="s1">table.loc[table.index[i]</span><span class="s0">, </span><span class="s2">'df'</span><span class="s1">] = r</span>
        <span class="s3">#col_order.append(cols.start)</span>
        <span class="s1">index.append(term.name())</span>

    <span class="s1">table.index = Index(index + [</span><span class="s2">'Residual'</span><span class="s1">])</span>
    <span class="s3">#NOTE: Do not need to sort because terms are an ordered dict now</span>
    <span class="s3">#table = table.iloc[np.argsort(col_order + [model.model.exog.shape[1]+1])]</span>
    <span class="s3"># back out sum of squares from f_test</span>
    <span class="s1">ssr = table[test] * table[</span><span class="s2">'df'</span><span class="s1">] * model.ssr/model.df_resid</span>
    <span class="s1">table[</span><span class="s2">'sum_sq'</span><span class="s1">] = ssr</span>
    <span class="s3"># fill in residual</span>
    <span class="s1">table.loc[</span><span class="s2">'Residual'</span><span class="s0">, </span><span class="s1">[</span><span class="s2">'sum_sq'</span><span class="s0">,</span><span class="s2">'df'</span><span class="s0">, </span><span class="s1">test</span><span class="s0">, </span><span class="s1">pr_test]] = (model.ssr</span><span class="s0">,</span>
                                                            <span class="s1">model.df_resid</span><span class="s0">,</span>
                                                            <span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan)</span>
    <span class="s0">return </span><span class="s1">table</span>

<span class="s0">def </span><span class="s1">anova_lm(*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
    <span class="s4">&quot;&quot;&quot; 
    Anova table for one or more fitted linear models. 
 
    Parameters 
    ---------- 
    args : fitted linear model results instance 
        One or more fitted linear models 
    scale : float 
        Estimate of variance, If None, will be estimated from the largest 
        model. Default is None. 
    test : str {&quot;F&quot;, &quot;Chisq&quot;, &quot;Cp&quot;} or None 
        Test statistics to provide. Default is &quot;F&quot;. 
    typ : str or int {&quot;I&quot;,&quot;II&quot;,&quot;III&quot;} or {1,2,3} 
        The type of Anova test to perform. See notes. 
    robust : {None, &quot;hc0&quot;, &quot;hc1&quot;, &quot;hc2&quot;, &quot;hc3&quot;} 
        Use heteroscedasticity-corrected coefficient covariance matrix. 
        If robust covariance is desired, it is recommended to use `hc3`. 
 
    Returns 
    ------- 
    anova : DataFrame 
        When args is a single model, return is DataFrame with columns: 
 
        sum_sq : float64 
            Sum of squares for model terms. 
        df : float64 
            Degrees of freedom for model terms. 
        F : float64 
            F statistic value for significance of adding model terms. 
        PR(&gt;F) : float64 
            P-value for significance of adding model terms. 
 
        When args is multiple models, return is DataFrame with columns: 
 
        df_resid : float64 
            Degrees of freedom of residuals in models. 
        ssr : float64 
            Sum of squares of residuals in models. 
        df_diff : float64 
            Degrees of freedom difference from previous model in args 
        ss_dff : float64 
            Difference in ssr from previous model in args 
        F : float64 
            F statistic comparing to previous model in args 
        PR(&gt;F): float64 
            P-value for significance comparing to previous model in args 
 
    Notes 
    ----- 
    Model statistics are given in the order of args. Models must have been fit 
    using the formula api. 
 
    See Also 
    -------- 
    model_results.compare_f_test, model_results.compare_lm_test 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import statsmodels.api as sm 
    &gt;&gt;&gt; from statsmodels.formula.api import ols 
    &gt;&gt;&gt; moore = sm.datasets.get_rdataset(&quot;Moore&quot;, &quot;carData&quot;, cache=True) # load 
    &gt;&gt;&gt; data = moore.data 
    &gt;&gt;&gt; data = data.rename(columns={&quot;partner.status&quot; : 
    ...                             &quot;partner_status&quot;}) # make name pythonic 
    &gt;&gt;&gt; moore_lm = ols('conformity ~ C(fcategory, Sum)*C(partner_status, Sum)', 
    ...                 data=data).fit() 
    &gt;&gt;&gt; table = sm.stats.anova_lm(moore_lm, typ=2) # Type 2 Anova DataFrame 
    &gt;&gt;&gt; print(table) 
    &quot;&quot;&quot;</span>
    <span class="s1">typ = kwargs.get(</span><span class="s2">'typ'</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)</span>

    <span class="s3">### Farm Out Single model Anova Type I, II, III, and IV ###</span>

    <span class="s0">if </span><span class="s1">len(args) == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">model = args[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s0">return </span><span class="s1">anova_single(model</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s0">if </span><span class="s1">typ </span><span class="s0">not in </span><span class="s1">[</span><span class="s5">1</span><span class="s0">, </span><span class="s2">&quot;I&quot;</span><span class="s1">]:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Multiple models only supported for type I. &quot;</span>
                         <span class="s2">&quot;Got type %s&quot; </span><span class="s1">% str(typ))</span>

    <span class="s1">test = kwargs.get(</span><span class="s2">&quot;test&quot;</span><span class="s0">, </span><span class="s2">&quot;F&quot;</span><span class="s1">)</span>
    <span class="s1">scale = kwargs.get(</span><span class="s2">&quot;scale&quot;</span><span class="s0">, None</span><span class="s1">)</span>
    <span class="s1">n_models = len(args)</span>
    <span class="s1">pr_test = </span><span class="s2">&quot;Pr(&gt;%s)&quot; </span><span class="s1">% test</span>
    <span class="s1">names = [</span><span class="s2">'df_resid'</span><span class="s0">, </span><span class="s2">'ssr'</span><span class="s0">, </span><span class="s2">'df_diff'</span><span class="s0">, </span><span class="s2">'ss_diff'</span><span class="s0">, </span><span class="s1">test</span><span class="s0">, </span><span class="s1">pr_test]</span>
    <span class="s1">table = DataFrame(np.zeros((n_models</span><span class="s0">, </span><span class="s5">6</span><span class="s1">))</span><span class="s0">, </span><span class="s1">columns=names)</span>

    <span class="s0">if not </span><span class="s1">scale: </span><span class="s3"># assume biggest model is last</span>
        <span class="s1">scale = args[-</span><span class="s5">1</span><span class="s1">].scale</span>

    <span class="s1">table[</span><span class="s2">&quot;ssr&quot;</span><span class="s1">] = [mdl.ssr </span><span class="s0">for </span><span class="s1">mdl </span><span class="s0">in </span><span class="s1">args]</span>
    <span class="s1">table[</span><span class="s2">&quot;df_resid&quot;</span><span class="s1">] = [mdl.df_resid </span><span class="s0">for </span><span class="s1">mdl </span><span class="s0">in </span><span class="s1">args]</span>
    <span class="s1">table.loc[table.index[</span><span class="s5">1</span><span class="s1">:]</span><span class="s0">, </span><span class="s2">&quot;df_diff&quot;</span><span class="s1">] = -np.diff(table[</span><span class="s2">&quot;df_resid&quot;</span><span class="s1">].values)</span>
    <span class="s1">table[</span><span class="s2">&quot;ss_diff&quot;</span><span class="s1">] = -table[</span><span class="s2">&quot;ssr&quot;</span><span class="s1">].diff()</span>
    <span class="s0">if </span><span class="s1">test == </span><span class="s2">&quot;F&quot;</span><span class="s1">:</span>
        <span class="s1">table[</span><span class="s2">&quot;F&quot;</span><span class="s1">] = table[</span><span class="s2">&quot;ss_diff&quot;</span><span class="s1">] / table[</span><span class="s2">&quot;df_diff&quot;</span><span class="s1">] / scale</span>
        <span class="s1">table[pr_test] = stats.f.sf(table[</span><span class="s2">&quot;F&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">table[</span><span class="s2">&quot;df_diff&quot;</span><span class="s1">]</span><span class="s0">,</span>
                                    <span class="s1">table[</span><span class="s2">&quot;df_resid&quot;</span><span class="s1">])</span>
        <span class="s3"># for earlier scipy - stats.f.sf(np.nan, 10, 2) -&gt; 0 not nan</span>
        <span class="s1">table.loc[table[</span><span class="s2">'F'</span><span class="s1">].isnull()</span><span class="s0">, </span><span class="s1">pr_test] = np.nan</span>

    <span class="s0">return </span><span class="s1">table</span>


<span class="s0">def </span><span class="s1">_not_slice(slices</span><span class="s0">, </span><span class="s1">slices_to_exclude</span><span class="s0">, </span><span class="s1">n):</span>
    <span class="s1">ind = np.array([</span><span class="s0">True</span><span class="s1">]*n)</span>
    <span class="s0">for </span><span class="s1">term </span><span class="s0">in </span><span class="s1">slices_to_exclude:</span>
        <span class="s1">s = slices[term]</span>
        <span class="s1">ind[s] = </span><span class="s0">False</span>
    <span class="s0">return </span><span class="s1">ind</span>


<span class="s0">def </span><span class="s1">_ssr_reduced_model(y</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">term_slices</span><span class="s0">, </span><span class="s1">params</span><span class="s0">, </span><span class="s1">keys):</span>
    <span class="s4">&quot;&quot;&quot; 
    Residual sum of squares of OLS model excluding factors in `keys` 
    Assumes x matrix is orthogonal 
 
    Parameters 
    ---------- 
    y : array_like 
        dependent variable 
    x : array_like 
        independent variables 
    term_slices : a dict of slices 
        term_slices[key] is a boolean array specifies the parameters 
        associated with the factor `key` 
    params : ndarray 
        OLS solution of y = x * params 
    keys : keys for term_slices 
        factors to be excluded 
 
    Returns 
    ------- 
    rss : float 
        residual sum of squares 
    df : int 
        degrees of freedom 
    &quot;&quot;&quot;</span>
    <span class="s1">ind = _not_slice(term_slices</span><span class="s0">, </span><span class="s1">keys</span><span class="s0">, </span><span class="s1">x.shape[</span><span class="s5">1</span><span class="s1">])</span>
    <span class="s1">params1 = params[ind]</span>
    <span class="s1">ssr = np.subtract(y</span><span class="s0">, </span><span class="s1">x[:</span><span class="s0">, </span><span class="s1">ind].dot(params1))</span>
    <span class="s1">ssr = ssr.T.dot(ssr)</span>
    <span class="s1">df_resid = len(y) - len(params1)</span>
    <span class="s0">return </span><span class="s1">ssr</span><span class="s0">, </span><span class="s1">df_resid</span>


<span class="s0">class </span><span class="s1">AnovaRM:</span>
    <span class="s4">&quot;&quot;&quot; 
    Repeated measures Anova using least squares regression 
 
    The full model regression residual sum of squares is 
    used to compare with the reduced model for calculating the 
    within-subject effect sum of squares [1]. 
 
    Currently, only fully balanced within-subject designs are supported. 
    Calculation of between-subject effects and corrections for violation of 
    sphericity are not yet implemented. 
 
    Parameters 
    ---------- 
    data : DataFrame 
    depvar : str 
        The dependent variable in `data` 
    subject : str 
        Specify the subject id 
    within : list[str] 
        The within-subject factors 
    between : list[str] 
        The between-subject factors, this is not yet implemented 
    aggregate_func : {None, 'mean', callable} 
        If the data set contains more than a single observation per subject 
        and cell of the specified model, this function will be used to 
        aggregate the data before running the Anova. `None` (the default) will 
        not perform any aggregation; 'mean' is s shortcut to `numpy.mean`. 
        An exception will be raised if aggregation is required, but no 
        aggregation function was specified. 
 
    Returns 
    ------- 
    results : AnovaResults instance 
 
    Raises 
    ------ 
    ValueError 
        If the data need to be aggregated, but `aggregate_func` was not 
        specified. 
 
    Notes 
    ----- 
    This implementation currently only supports fully balanced designs. If the 
    data contain more than one observation per subject and cell of the design, 
    these observations need to be aggregated into a single observation 
    before the Anova is calculated, either manually or by passing an aggregation 
    function via the `aggregate_func` keyword argument. 
    Note that if the input data set was not balanced before performing the 
    aggregation, the implied heteroscedasticity of the data is ignored. 
 
    References 
    ---------- 
    .. [*] Rutherford, Andrew. Anova and ANCOVA: a GLM approach. John Wiley &amp; Sons, 2011. 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">data</span><span class="s0">, </span><span class="s1">depvar</span><span class="s0">, </span><span class="s1">subject</span><span class="s0">, </span><span class="s1">within=</span><span class="s0">None, </span><span class="s1">between=</span><span class="s0">None,</span>
                 <span class="s1">aggregate_func=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">self.data = data</span>
        <span class="s1">self.depvar = depvar</span>
        <span class="s1">self.within = within</span>
        <span class="s0">if </span><span class="s2">'C' </span><span class="s0">in </span><span class="s1">within:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Factor name cannot be 'C'! This is in conflict &quot;</span>
                             <span class="s2">&quot;with patsy's contrast function name.&quot;</span><span class="s1">)</span>
        <span class="s1">self.between = between</span>
        <span class="s0">if </span><span class="s1">between </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">NotImplementedError(</span><span class="s2">'Between subject effect not '</span>
                                      <span class="s2">'yet supported!'</span><span class="s1">)</span>
        <span class="s1">self.subject = subject</span>

        <span class="s0">if </span><span class="s1">aggregate_func == </span><span class="s2">'mean'</span><span class="s1">:</span>
            <span class="s1">self.aggregate_func = np.mean</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.aggregate_func = aggregate_func</span>

        <span class="s0">if not </span><span class="s1">data.equals(data.drop_duplicates(subset=[subject] + within)):</span>
            <span class="s0">if </span><span class="s1">self.aggregate_func </span><span class="s0">is not None</span><span class="s1">:</span>
                <span class="s1">self._aggregate()</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">msg = (</span><span class="s2">'The data set contains more than one observation per '</span>
                       <span class="s2">'subject and cell. Either aggregate the data manually, '</span>
                       <span class="s2">'or pass the `aggregate_func` parameter.'</span><span class="s1">)</span>
                <span class="s0">raise </span><span class="s1">ValueError(msg)</span>

        <span class="s1">self._check_data_balanced()</span>

    <span class="s0">def </span><span class="s1">_aggregate(self):</span>
        <span class="s1">self.data = (self.data</span>
                     <span class="s1">.groupby([self.subject] + self.within</span><span class="s0">,</span>
                              <span class="s1">as_index=</span><span class="s0">False</span><span class="s1">)[self.depvar]</span>
                     <span class="s1">.agg(self.aggregate_func))</span>

    <span class="s0">def </span><span class="s1">_check_data_balanced(self):</span>
        <span class="s4">&quot;&quot;&quot;raise if data is not balanced 
 
        This raises a ValueError if the data is not balanced, and 
        returns None if it is balance 
 
        Return might change 
        &quot;&quot;&quot;</span>
        <span class="s1">factor_levels = </span><span class="s5">1</span>
        <span class="s0">for </span><span class="s1">wi </span><span class="s0">in </span><span class="s1">self.within:</span>
            <span class="s1">factor_levels *= len(self.data[wi].unique())</span>

        <span class="s1">cell_count = {}</span>
        <span class="s0">for </span><span class="s1">index </span><span class="s0">in </span><span class="s1">range(self.data.shape[</span><span class="s5">0</span><span class="s1">]):</span>
            <span class="s1">key = []</span>
            <span class="s0">for </span><span class="s1">col </span><span class="s0">in </span><span class="s1">self.within:</span>
                <span class="s1">key.append(self.data[col].iloc[index])</span>
            <span class="s1">key = tuple(key)</span>
            <span class="s0">if </span><span class="s1">key </span><span class="s0">in </span><span class="s1">cell_count:</span>
                <span class="s1">cell_count[key] = cell_count[key] + </span><span class="s5">1</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">cell_count[key] = </span><span class="s5">1</span>
        <span class="s1">error_message = </span><span class="s2">&quot;Data is unbalanced.&quot;</span>
        <span class="s0">if </span><span class="s1">len(cell_count) != factor_levels:</span>
            <span class="s0">raise </span><span class="s1">ValueError(error_message)</span>
        <span class="s1">count = cell_count[key]</span>
        <span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">cell_count:</span>
            <span class="s0">if </span><span class="s1">count != cell_count[key]:</span>
                <span class="s0">raise </span><span class="s1">ValueError(error_message)</span>
        <span class="s0">if </span><span class="s1">self.data.shape[</span><span class="s5">0</span><span class="s1">] &gt; count * factor_levels:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">'There are more than 1 element in a cell! Missing'</span>
                             <span class="s2">' factors?'</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">fit(self):</span>
        <span class="s4">&quot;&quot;&quot;estimate the model and compute the Anova table 
 
        Returns 
        ------- 
        AnovaResults instance 
        &quot;&quot;&quot;</span>
        <span class="s1">y = self.data[self.depvar].values</span>

        <span class="s3"># Construct OLS endog and exog from string using patsy</span>
        <span class="s1">within = [</span><span class="s2">'C(%s, Sum)' </span><span class="s1">% i </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">self.within]</span>
        <span class="s1">subject = </span><span class="s2">'C(%s, Sum)' </span><span class="s1">% self.subject</span>
        <span class="s1">factors = within + [subject]</span>
        <span class="s1">x = patsy.dmatrix(</span><span class="s2">'*'</span><span class="s1">.join(factors)</span><span class="s0">, </span><span class="s1">data=self.data)</span>
        <span class="s1">term_slices = x.design_info.term_name_slices</span>
        <span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">term_slices:</span>
            <span class="s1">ind = np.array([</span><span class="s0">False</span><span class="s1">]*x.shape[</span><span class="s5">1</span><span class="s1">])</span>
            <span class="s1">ind[term_slices[key]] = </span><span class="s0">True</span>
            <span class="s1">term_slices[key] = np.array(ind)</span>
        <span class="s1">term_exclude = [</span><span class="s2">':'</span><span class="s1">.join(factors)]</span>
        <span class="s1">ind = _not_slice(term_slices</span><span class="s0">, </span><span class="s1">term_exclude</span><span class="s0">, </span><span class="s1">x.shape[</span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">x = x[:</span><span class="s0">, </span><span class="s1">ind]</span>

        <span class="s3"># Fit OLS</span>
        <span class="s1">model = OLS(y</span><span class="s0">, </span><span class="s1">x)</span>
        <span class="s1">results = model.fit()</span>
        <span class="s0">if </span><span class="s1">model.rank &lt; x.shape[</span><span class="s5">1</span><span class="s1">]:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">'Independent variables are collinear.'</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">term_exclude:</span>
            <span class="s1">term_slices.pop(i)</span>
        <span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">term_slices:</span>
            <span class="s1">term_slices[key] = term_slices[key][ind]</span>
        <span class="s1">params = results.params</span>
        <span class="s1">df_resid = results.df_resid</span>
        <span class="s1">ssr = results.ssr</span>

        <span class="s1">columns = [</span><span class="s2">'F Value'</span><span class="s0">, </span><span class="s2">'Num DF'</span><span class="s0">, </span><span class="s2">'Den DF'</span><span class="s0">, </span><span class="s2">'Pr &gt; F'</span><span class="s1">]</span>
        <span class="s1">anova_table = pd.DataFrame(np.zeros((</span><span class="s5">0</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span><span class="s0">, </span><span class="s1">columns=columns)</span>

        <span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">term_slices:</span>
            <span class="s0">if </span><span class="s1">self.subject </span><span class="s0">not in </span><span class="s1">key </span><span class="s0">and </span><span class="s1">key != </span><span class="s2">'Intercept'</span><span class="s1">:</span>
                <span class="s3">#  Independen variables are orthogonal</span>
                <span class="s1">ssr1</span><span class="s0">, </span><span class="s1">df_resid1 = _ssr_reduced_model(</span>
                    <span class="s1">y</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">term_slices</span><span class="s0">, </span><span class="s1">params</span><span class="s0">, </span><span class="s1">[key])</span>
                <span class="s1">df1 = df_resid1 - df_resid</span>
                <span class="s1">msm = (ssr1 - ssr) / df1</span>
                <span class="s0">if </span><span class="s1">(key == </span><span class="s2">':'</span><span class="s1">.join(factors[:-</span><span class="s5">1</span><span class="s1">]) </span><span class="s0">or</span>
                        <span class="s1">(key + </span><span class="s2">':' </span><span class="s1">+ subject </span><span class="s0">not in </span><span class="s1">term_slices)):</span>
                    <span class="s1">mse = ssr / df_resid</span>
                    <span class="s1">df2 = df_resid</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">ssr1</span><span class="s0">, </span><span class="s1">df_resid1 = _ssr_reduced_model(</span>
                        <span class="s1">y</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">term_slices</span><span class="s0">, </span><span class="s1">params</span><span class="s0">,</span>
                        <span class="s1">[key + </span><span class="s2">':' </span><span class="s1">+ subject])</span>
                    <span class="s1">df2 = df_resid1 - df_resid</span>
                    <span class="s1">mse = (ssr1 - ssr) / df2</span>
                <span class="s1">F = msm / mse</span>
                <span class="s1">p = stats.f.sf(F</span><span class="s0">, </span><span class="s1">df1</span><span class="s0">, </span><span class="s1">df2)</span>
                <span class="s1">term = key.replace(</span><span class="s2">'C('</span><span class="s0">, </span><span class="s2">''</span><span class="s1">).replace(</span><span class="s2">', Sum)'</span><span class="s0">, </span><span class="s2">''</span><span class="s1">)</span>
                <span class="s1">anova_table.loc[term</span><span class="s0">, </span><span class="s2">'F Value'</span><span class="s1">] = F</span>
                <span class="s1">anova_table.loc[term</span><span class="s0">, </span><span class="s2">'Num DF'</span><span class="s1">] = df1</span>
                <span class="s1">anova_table.loc[term</span><span class="s0">, </span><span class="s2">'Den DF'</span><span class="s1">] = df2</span>
                <span class="s1">anova_table.loc[term</span><span class="s0">, </span><span class="s2">'Pr &gt; F'</span><span class="s1">] = p</span>

        <span class="s0">return </span><span class="s1">AnovaResults(anova_table)</span>


<span class="s0">class </span><span class="s1">AnovaResults:</span>
    <span class="s4">&quot;&quot;&quot; 
    Anova results class 
 
    Attributes 
    ---------- 
    anova_table : DataFrame 
    &quot;&quot;&quot;</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">anova_table):</span>
        <span class="s1">self.anova_table = anova_table</span>

    <span class="s0">def </span><span class="s1">__str__(self):</span>
        <span class="s0">return </span><span class="s1">self.summary().__str__()</span>

    <span class="s0">def </span><span class="s1">summary(self):</span>
        <span class="s4">&quot;&quot;&quot;create summary results 
 
        Returns 
        ------- 
        summary : summary2.Summary instance 
        &quot;&quot;&quot;</span>
        <span class="s1">summ = summary2.Summary()</span>
        <span class="s1">summ.add_title(</span><span class="s2">'Anova'</span><span class="s1">)</span>
        <span class="s1">summ.add_df(self.anova_table)</span>

        <span class="s0">return </span><span class="s1">summ</span>


<span class="s0">if </span><span class="s1">__name__ == </span><span class="s2">&quot;__main__&quot;</span><span class="s1">:</span>
    <span class="s0">import </span><span class="s1">pandas</span>
    <span class="s0">from </span><span class="s1">statsmodels.formula.api </span><span class="s0">import </span><span class="s1">ols</span>
    <span class="s3"># in R</span>
    <span class="s3">#library(car)</span>
    <span class="s3">#write.csv(Moore, &quot;moore.csv&quot;, row.names=FALSE)</span>
    <span class="s1">moore = pandas.read_csv(</span><span class="s2">'moore.csv'</span><span class="s0">, </span><span class="s1">skiprows=</span><span class="s5">1</span><span class="s0">,</span>
                            <span class="s1">names=[</span><span class="s2">'partner_status'</span><span class="s0">,</span><span class="s2">'conformity'</span><span class="s0">,</span>
                                   <span class="s2">'fcategory'</span><span class="s0">,</span><span class="s2">'fscore'</span><span class="s1">])</span>
    <span class="s1">moore_lm = ols(</span><span class="s2">'conformity ~ C(fcategory, Sum)*C(partner_status, Sum)'</span><span class="s0">,</span>
                    <span class="s1">data=moore).fit()</span>

    <span class="s1">mooreB = ols(</span><span class="s2">'conformity ~ C(partner_status, Sum)'</span><span class="s0">, </span><span class="s1">data=moore).fit()</span>

    <span class="s3"># for each term you just want to test vs the model without its</span>
    <span class="s3"># higher-order terms</span>

    <span class="s3"># using Monette-Fox slides and Marden class notes for linear algebra /</span>
    <span class="s3"># orthogonal complement</span>
    <span class="s3"># https://netfiles.uiuc.edu/jimarden/www/Classes/STAT324/</span>

    <span class="s1">table = anova_lm(moore_lm</span><span class="s0">, </span><span class="s1">typ=</span><span class="s5">2</span><span class="s1">)</span>
</pre>
</body>
</html>