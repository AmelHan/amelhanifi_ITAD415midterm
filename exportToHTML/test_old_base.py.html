<html>
<head>
<title>test_old_base.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6897bb;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_old_base.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">from </span><span class="s1">datetime </span><span class="s0">import </span><span class="s1">datetime</span>
<span class="s0">import </span><span class="s1">gc</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">pytest</span>

<span class="s0">from </span><span class="s1">pandas._libs.tslibs </span><span class="s0">import </span><span class="s1">Timestamp</span>

<span class="s0">from </span><span class="s1">pandas.core.dtypes.common </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">is_integer_dtype</span><span class="s0">,</span>
    <span class="s1">is_numeric_dtype</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">pandas.core.dtypes.dtypes </span><span class="s0">import </span><span class="s1">CategoricalDtype</span>

<span class="s0">import </span><span class="s1">pandas </span><span class="s0">as </span><span class="s1">pd</span>
<span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">CategoricalIndex</span><span class="s0">,</span>
    <span class="s1">DatetimeIndex</span><span class="s0">,</span>
    <span class="s1">DatetimeTZDtype</span><span class="s0">,</span>
    <span class="s1">Index</span><span class="s0">,</span>
    <span class="s1">IntervalIndex</span><span class="s0">,</span>
    <span class="s1">MultiIndex</span><span class="s0">,</span>
    <span class="s1">PeriodIndex</span><span class="s0">,</span>
    <span class="s1">RangeIndex</span><span class="s0">,</span>
    <span class="s1">Series</span><span class="s0">,</span>
    <span class="s1">TimedeltaIndex</span><span class="s0">,</span>
    <span class="s1">isna</span><span class="s0">,</span>
    <span class="s1">period_range</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">import </span><span class="s1">pandas._testing </span><span class="s0">as </span><span class="s1">tm</span>
<span class="s0">from </span><span class="s1">pandas.core.arrays </span><span class="s0">import </span><span class="s1">BaseMaskedArray</span>


<span class="s0">class </span><span class="s1">TestBase:</span>
    <span class="s1">@pytest.fixture(</span>
        <span class="s1">params=[</span>
            <span class="s1">RangeIndex(start=</span><span class="s2">0</span><span class="s0">, </span><span class="s1">stop=</span><span class="s2">20</span><span class="s0">, </span><span class="s1">step=</span><span class="s2">2</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">Index(np.arange(</span><span class="s2">5</span><span class="s0">, </span><span class="s1">dtype=np.float64))</span><span class="s0">,</span>
            <span class="s1">Index(np.arange(</span><span class="s2">5</span><span class="s0">, </span><span class="s1">dtype=np.float32))</span><span class="s0">,</span>
            <span class="s1">Index(np.arange(</span><span class="s2">5</span><span class="s0">, </span><span class="s1">dtype=np.uint64))</span><span class="s0">,</span>
            <span class="s1">Index(range(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">20</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=np.int64)</span><span class="s0">,</span>
            <span class="s1">Index(range(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">20</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=np.int32)</span><span class="s0">,</span>
            <span class="s1">Index(range(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">20</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=np.int16)</span><span class="s0">,</span>
            <span class="s1">Index(range(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">20</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=np.int8)</span><span class="s0">,</span>
            <span class="s1">Index(list(</span><span class="s3">&quot;abcde&quot;</span><span class="s1">))</span><span class="s0">,</span>
            <span class="s1">Index([</span><span class="s2">0</span><span class="s0">, </span><span class="s3">&quot;a&quot;</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s3">&quot;b&quot;</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s3">&quot;c&quot;</span><span class="s1">])</span><span class="s0">,</span>
            <span class="s1">period_range(</span><span class="s3">&quot;20130101&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s2">5</span><span class="s0">, </span><span class="s1">freq=</span><span class="s3">&quot;D&quot;</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">TimedeltaIndex(</span>
                <span class="s1">[</span>
                    <span class="s3">&quot;0 days 01:00:00&quot;</span><span class="s0">,</span>
                    <span class="s3">&quot;1 days 01:00:00&quot;</span><span class="s0">,</span>
                    <span class="s3">&quot;2 days 01:00:00&quot;</span><span class="s0">,</span>
                    <span class="s3">&quot;3 days 01:00:00&quot;</span><span class="s0">,</span>
                    <span class="s3">&quot;4 days 01:00:00&quot;</span><span class="s0">,</span>
                <span class="s1">]</span><span class="s0">,</span>
                <span class="s1">dtype=</span><span class="s3">&quot;timedelta64[ns]&quot;</span><span class="s0">,</span>
                <span class="s1">freq=</span><span class="s3">&quot;D&quot;</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">DatetimeIndex(</span>
                <span class="s1">[</span><span class="s3">&quot;2013-01-01&quot;</span><span class="s0">, </span><span class="s3">&quot;2013-01-02&quot;</span><span class="s0">, </span><span class="s3">&quot;2013-01-03&quot;</span><span class="s0">, </span><span class="s3">&quot;2013-01-04&quot;</span><span class="s0">, </span><span class="s3">&quot;2013-01-05&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">dtype=</span><span class="s3">&quot;datetime64[ns]&quot;</span><span class="s0">,</span>
                <span class="s1">freq=</span><span class="s3">&quot;D&quot;</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">IntervalIndex.from_breaks(range(</span><span class="s2">11</span><span class="s1">)</span><span class="s0">, </span><span class="s1">closed=</span><span class="s3">&quot;right&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">simple_index(self</span><span class="s0">, </span><span class="s1">request):</span>
        <span class="s0">return </span><span class="s1">request.param</span>

    <span class="s0">def </span><span class="s1">test_pickle_compat_construction(self</span><span class="s0">, </span><span class="s1">simple_index):</span>
        <span class="s4"># need an object to create with</span>
        <span class="s0">if </span><span class="s1">isinstance(simple_index</span><span class="s0">, </span><span class="s1">RangeIndex):</span>
            <span class="s1">pytest.skip(</span><span class="s3">&quot;RangeIndex() is a valid constructor&quot;</span><span class="s1">)</span>
        <span class="s1">msg = </span><span class="s3">&quot;|&quot;</span><span class="s1">.join(</span>
            <span class="s1">[</span>
                <span class="s3">r&quot;Index\(\.\.\.\) must be called with a collection of some &quot;</span>
                <span class="s3">r&quot;kind, None was passed&quot;</span><span class="s0">,</span>
                <span class="s3">r&quot;DatetimeIndex\(\) must be called with a collection of some &quot;</span>
                <span class="s3">r&quot;kind, None was passed&quot;</span><span class="s0">,</span>
                <span class="s3">r&quot;TimedeltaIndex\(\) must be called with a collection of some &quot;</span>
                <span class="s3">r&quot;kind, None was passed&quot;</span><span class="s0">,</span>
                <span class="s3">r&quot;__new__\(\) missing 1 required positional argument: 'data'&quot;</span><span class="s0">,</span>
                <span class="s3">r&quot;__new__\(\) takes at least 2 arguments \(1 given\)&quot;</span><span class="s0">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">type(simple_index)()</span>

    <span class="s0">def </span><span class="s1">test_shift(self</span><span class="s0">, </span><span class="s1">simple_index):</span>
        <span class="s4"># GH8083 test the base class for shift</span>
        <span class="s0">if </span><span class="s1">isinstance(simple_index</span><span class="s0">, </span><span class="s1">(DatetimeIndex</span><span class="s0">, </span><span class="s1">TimedeltaIndex</span><span class="s0">, </span><span class="s1">PeriodIndex)):</span>
            <span class="s1">pytest.skip(</span><span class="s3">&quot;Tested in test_ops/test_arithmetic&quot;</span><span class="s1">)</span>
        <span class="s1">idx = simple_index</span>
        <span class="s1">msg = (</span>
            <span class="s3">f&quot;This method is only implemented for DatetimeIndex, PeriodIndex and &quot;</span>
            <span class="s3">f&quot;TimedeltaIndex; Got type </span><span class="s0">{</span><span class="s1">type(idx).__name__</span><span class="s0">}</span><span class="s3">&quot;</span>
        <span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">idx.shift(</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">idx.shift(</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_constructor_name_unhashable(self</span><span class="s0">, </span><span class="s1">simple_index):</span>
        <span class="s4"># GH#29069 check that name is hashable</span>
        <span class="s4"># See also same-named test in tests.series.test_constructors</span>
        <span class="s1">idx = simple_index</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">&quot;Index.name must be a hashable type&quot;</span><span class="s1">):</span>
            <span class="s1">type(idx)(idx</span><span class="s0">, </span><span class="s1">name=[])</span>

    <span class="s0">def </span><span class="s1">test_create_index_existing_name(self</span><span class="s0">, </span><span class="s1">simple_index):</span>
        <span class="s4"># GH11193, when an existing index is passed, and a new name is not</span>
        <span class="s4"># specified, the new index should inherit the previous object name</span>
        <span class="s1">expected = simple_index.copy()</span>
        <span class="s0">if not </span><span class="s1">isinstance(expected</span><span class="s0">, </span><span class="s1">MultiIndex):</span>
            <span class="s1">expected.name = </span><span class="s3">&quot;foo&quot;</span>
            <span class="s1">result = Index(expected)</span>
            <span class="s1">tm.assert_index_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

            <span class="s1">result = Index(expected</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;bar&quot;</span><span class="s1">)</span>
            <span class="s1">expected.name = </span><span class="s3">&quot;bar&quot;</span>
            <span class="s1">tm.assert_index_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">expected.names = [</span><span class="s3">&quot;foo&quot;</span><span class="s0">, </span><span class="s3">&quot;bar&quot;</span><span class="s1">]</span>
            <span class="s1">result = Index(expected)</span>
            <span class="s1">tm.assert_index_equal(</span>
                <span class="s1">result</span><span class="s0">,</span>
                <span class="s1">Index(</span>
                    <span class="s1">Index(</span>
                        <span class="s1">[</span>
                            <span class="s1">(</span><span class="s3">&quot;foo&quot;</span><span class="s0">, </span><span class="s3">&quot;one&quot;</span><span class="s1">)</span><span class="s0">,</span>
                            <span class="s1">(</span><span class="s3">&quot;foo&quot;</span><span class="s0">, </span><span class="s3">&quot;two&quot;</span><span class="s1">)</span><span class="s0">,</span>
                            <span class="s1">(</span><span class="s3">&quot;bar&quot;</span><span class="s0">, </span><span class="s3">&quot;one&quot;</span><span class="s1">)</span><span class="s0">,</span>
                            <span class="s1">(</span><span class="s3">&quot;baz&quot;</span><span class="s0">, </span><span class="s3">&quot;two&quot;</span><span class="s1">)</span><span class="s0">,</span>
                            <span class="s1">(</span><span class="s3">&quot;qux&quot;</span><span class="s0">, </span><span class="s3">&quot;one&quot;</span><span class="s1">)</span><span class="s0">,</span>
                            <span class="s1">(</span><span class="s3">&quot;qux&quot;</span><span class="s0">, </span><span class="s3">&quot;two&quot;</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">]</span><span class="s0">,</span>
                        <span class="s1">dtype=</span><span class="s3">&quot;object&quot;</span><span class="s0">,</span>
                    <span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">names=[</span><span class="s3">&quot;foo&quot;</span><span class="s0">, </span><span class="s3">&quot;bar&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">)</span>

            <span class="s1">result = Index(expected</span><span class="s0">, </span><span class="s1">names=[</span><span class="s3">&quot;A&quot;</span><span class="s0">, </span><span class="s3">&quot;B&quot;</span><span class="s1">])</span>
            <span class="s1">tm.assert_index_equal(</span>
                <span class="s1">result</span><span class="s0">,</span>
                <span class="s1">Index(</span>
                    <span class="s1">Index(</span>
                        <span class="s1">[</span>
                            <span class="s1">(</span><span class="s3">&quot;foo&quot;</span><span class="s0">, </span><span class="s3">&quot;one&quot;</span><span class="s1">)</span><span class="s0">,</span>
                            <span class="s1">(</span><span class="s3">&quot;foo&quot;</span><span class="s0">, </span><span class="s3">&quot;two&quot;</span><span class="s1">)</span><span class="s0">,</span>
                            <span class="s1">(</span><span class="s3">&quot;bar&quot;</span><span class="s0">, </span><span class="s3">&quot;one&quot;</span><span class="s1">)</span><span class="s0">,</span>
                            <span class="s1">(</span><span class="s3">&quot;baz&quot;</span><span class="s0">, </span><span class="s3">&quot;two&quot;</span><span class="s1">)</span><span class="s0">,</span>
                            <span class="s1">(</span><span class="s3">&quot;qux&quot;</span><span class="s0">, </span><span class="s3">&quot;one&quot;</span><span class="s1">)</span><span class="s0">,</span>
                            <span class="s1">(</span><span class="s3">&quot;qux&quot;</span><span class="s0">, </span><span class="s3">&quot;two&quot;</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">]</span><span class="s0">,</span>
                        <span class="s1">dtype=</span><span class="s3">&quot;object&quot;</span><span class="s0">,</span>
                    <span class="s1">)</span><span class="s0">,</span>
                    <span class="s1">names=[</span><span class="s3">&quot;A&quot;</span><span class="s0">, </span><span class="s3">&quot;B&quot;</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_numeric_compat(self</span><span class="s0">, </span><span class="s1">simple_index):</span>
        <span class="s1">idx = simple_index</span>
        <span class="s4"># Check that this doesn't cover MultiIndex case, if/when it does,</span>
        <span class="s4">#  we can remove multi.test_compat.test_numeric_compat</span>
        <span class="s0">assert not </span><span class="s1">isinstance(idx</span><span class="s0">, </span><span class="s1">MultiIndex)</span>
        <span class="s0">if </span><span class="s1">type(idx) </span><span class="s0">is </span><span class="s1">Index:</span>
            <span class="s1">pytest.skip(</span><span class="s3">&quot;Not applicable for Index&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">is_numeric_dtype(simple_index.dtype) </span><span class="s0">or </span><span class="s1">isinstance(</span>
            <span class="s1">simple_index</span><span class="s0">, </span><span class="s1">TimedeltaIndex</span>
        <span class="s1">):</span>
            <span class="s1">pytest.skip(</span><span class="s3">&quot;Tested elsewhere.&quot;</span><span class="s1">)</span>

        <span class="s1">typ = type(idx._data).__name__</span>
        <span class="s1">cls = type(idx).__name__</span>
        <span class="s1">lmsg = </span><span class="s3">&quot;|&quot;</span><span class="s1">.join(</span>
            <span class="s1">[</span>
                <span class="s3">rf&quot;unsupported operand type\(s\) for \*: '</span><span class="s0">{</span><span class="s1">typ</span><span class="s0">}</span><span class="s3">' and 'int'&quot;</span><span class="s0">,</span>
                <span class="s3">&quot;cannot perform (__mul__|__truediv__|__floordiv__) with &quot;</span>
                <span class="s3">f&quot;this index type: (</span><span class="s0">{</span><span class="s1">cls</span><span class="s0">}</span><span class="s3">|</span><span class="s0">{</span><span class="s1">typ</span><span class="s0">}</span><span class="s3">)&quot;</span><span class="s0">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=lmsg):</span>
            <span class="s1">idx * </span><span class="s2">1</span>
        <span class="s1">rmsg = </span><span class="s3">&quot;|&quot;</span><span class="s1">.join(</span>
            <span class="s1">[</span>
                <span class="s3">rf&quot;unsupported operand type\(s\) for \*: 'int' and '</span><span class="s0">{</span><span class="s1">typ</span><span class="s0">}</span><span class="s3">'&quot;</span><span class="s0">,</span>
                <span class="s3">&quot;cannot perform (__rmul__|__rtruediv__|__rfloordiv__) with &quot;</span>
                <span class="s3">f&quot;this index type: (</span><span class="s0">{</span><span class="s1">cls</span><span class="s0">}</span><span class="s3">|</span><span class="s0">{</span><span class="s1">typ</span><span class="s0">}</span><span class="s3">)&quot;</span><span class="s0">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=rmsg):</span>
            <span class="s2">1 </span><span class="s1">* idx</span>

        <span class="s1">div_err = lmsg.replace(</span><span class="s3">&quot;*&quot;</span><span class="s0">, </span><span class="s3">&quot;/&quot;</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=div_err):</span>
            <span class="s1">idx / </span><span class="s2">1</span>
        <span class="s1">div_err = rmsg.replace(</span><span class="s3">&quot;*&quot;</span><span class="s0">, </span><span class="s3">&quot;/&quot;</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=div_err):</span>
            <span class="s2">1 </span><span class="s1">/ idx</span>

        <span class="s1">floordiv_err = lmsg.replace(</span><span class="s3">&quot;*&quot;</span><span class="s0">, </span><span class="s3">&quot;//&quot;</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=floordiv_err):</span>
            <span class="s1">idx // </span><span class="s2">1</span>
        <span class="s1">floordiv_err = rmsg.replace(</span><span class="s3">&quot;*&quot;</span><span class="s0">, </span><span class="s3">&quot;//&quot;</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=floordiv_err):</span>
            <span class="s2">1 </span><span class="s1">// idx</span>

    <span class="s0">def </span><span class="s1">test_logical_compat(self</span><span class="s0">, </span><span class="s1">simple_index):</span>
        <span class="s0">if </span><span class="s1">simple_index.dtype == object:</span>
            <span class="s1">pytest.skip(</span><span class="s3">&quot;Tested elsewhere.&quot;</span><span class="s1">)</span>
        <span class="s1">idx = simple_index</span>
        <span class="s0">if </span><span class="s1">idx.dtype.kind </span><span class="s0">in </span><span class="s3">&quot;iufcbm&quot;</span><span class="s1">:</span>
            <span class="s0">assert </span><span class="s1">idx.all() == idx._values.all()</span>
            <span class="s0">assert </span><span class="s1">idx.all() == idx.to_series().all()</span>
            <span class="s0">assert </span><span class="s1">idx.any() == idx._values.any()</span>
            <span class="s0">assert </span><span class="s1">idx.any() == idx.to_series().any()</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s3">&quot;cannot perform (any|all)&quot;</span>
            <span class="s0">if </span><span class="s1">isinstance(idx</span><span class="s0">, </span><span class="s1">IntervalIndex):</span>
                <span class="s1">msg = (</span>
                    <span class="s3">r&quot;'IntervalArray' with dtype interval\[.*\] does &quot;</span>
                    <span class="s3">&quot;not support reduction '(any|all)'&quot;</span>
                <span class="s1">)</span>
            <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">idx.all()</span>
            <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">idx.any()</span>

    <span class="s0">def </span><span class="s1">test_repr_roundtrip(self</span><span class="s0">, </span><span class="s1">simple_index):</span>
        <span class="s0">if </span><span class="s1">isinstance(simple_index</span><span class="s0">, </span><span class="s1">IntervalIndex):</span>
            <span class="s1">pytest.skip(</span><span class="s3">f&quot;Not a valid repr for </span><span class="s0">{</span><span class="s1">type(simple_index).__name__</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s1">)</span>
        <span class="s1">idx = simple_index</span>
        <span class="s1">tm.assert_index_equal(eval(repr(idx))</span><span class="s0">, </span><span class="s1">idx)</span>

    <span class="s0">def </span><span class="s1">test_repr_max_seq_item_setting(self</span><span class="s0">, </span><span class="s1">simple_index):</span>
        <span class="s4"># GH10182</span>
        <span class="s0">if </span><span class="s1">isinstance(simple_index</span><span class="s0">, </span><span class="s1">IntervalIndex):</span>
            <span class="s1">pytest.skip(</span><span class="s3">f&quot;Not a valid repr for </span><span class="s0">{</span><span class="s1">type(simple_index).__name__</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s1">)</span>
        <span class="s1">idx = simple_index</span>
        <span class="s1">idx = idx.repeat(</span><span class="s2">50</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pd.option_context(</span><span class="s3">&quot;display.max_seq_items&quot;</span><span class="s0">, None</span><span class="s1">):</span>
            <span class="s1">repr(idx)</span>
            <span class="s0">assert </span><span class="s3">&quot;...&quot; </span><span class="s0">not in </span><span class="s1">str(idx)</span>

    <span class="s1">@pytest.mark.filterwarnings(</span><span class="s3">r&quot;ignore:PeriodDtype\[B\] is deprecated:FutureWarning&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_ensure_copied_data(self</span><span class="s0">, </span><span class="s1">index):</span>
        <span class="s4"># Check the &quot;copy&quot; argument of each Index.__new__ is honoured</span>
        <span class="s4"># GH12309</span>
        <span class="s1">init_kwargs = {}</span>
        <span class="s0">if </span><span class="s1">isinstance(index</span><span class="s0">, </span><span class="s1">PeriodIndex):</span>
            <span class="s4"># Needs &quot;freq&quot; specification:</span>
            <span class="s1">init_kwargs[</span><span class="s3">&quot;freq&quot;</span><span class="s1">] = index.freq</span>
        <span class="s0">elif </span><span class="s1">isinstance(index</span><span class="s0">, </span><span class="s1">(RangeIndex</span><span class="s0">, </span><span class="s1">MultiIndex</span><span class="s0">, </span><span class="s1">CategoricalIndex)):</span>
            <span class="s1">pytest.skip(</span>
                <span class="s3">&quot;RangeIndex cannot be initialized from data, &quot;</span>
                <span class="s3">&quot;MultiIndex and CategoricalIndex are tested separately&quot;</span>
            <span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">index.dtype == object </span><span class="s0">and </span><span class="s1">index.inferred_type == </span><span class="s3">&quot;boolean&quot;</span><span class="s1">:</span>
            <span class="s1">init_kwargs[</span><span class="s3">&quot;dtype&quot;</span><span class="s1">] = index.dtype</span>

        <span class="s1">index_type = type(index)</span>
        <span class="s1">result = index_type(index.values</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">True, </span><span class="s1">**init_kwargs)</span>
        <span class="s0">if </span><span class="s1">isinstance(index.dtype</span><span class="s0">, </span><span class="s1">DatetimeTZDtype):</span>
            <span class="s1">result = result.tz_localize(</span><span class="s3">&quot;UTC&quot;</span><span class="s1">).tz_convert(index.tz)</span>
        <span class="s0">if </span><span class="s1">isinstance(index</span><span class="s0">, </span><span class="s1">(DatetimeIndex</span><span class="s0">, </span><span class="s1">TimedeltaIndex)):</span>
            <span class="s1">index = index._with_freq(</span><span class="s0">None</span><span class="s1">)</span>

        <span class="s1">tm.assert_index_equal(index</span><span class="s0">, </span><span class="s1">result)</span>

        <span class="s0">if </span><span class="s1">isinstance(index</span><span class="s0">, </span><span class="s1">PeriodIndex):</span>
            <span class="s4"># .values an object array of Period, thus copied</span>
            <span class="s1">result = index_type(ordinal=index.asi8</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False, </span><span class="s1">**init_kwargs)</span>
            <span class="s1">tm.assert_numpy_array_equal(index.asi8</span><span class="s0">, </span><span class="s1">result.asi8</span><span class="s0">, </span><span class="s1">check_same=</span><span class="s3">&quot;same&quot;</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">isinstance(index</span><span class="s0">, </span><span class="s1">IntervalIndex):</span>
            <span class="s4"># checked in test_interval.py</span>
            <span class="s0">pass</span>
        <span class="s0">elif </span><span class="s1">type(index) </span><span class="s0">is </span><span class="s1">Index </span><span class="s0">and not </span><span class="s1">isinstance(index.dtype</span><span class="s0">, </span><span class="s1">np.dtype):</span>
            <span class="s1">result = index_type(index.values</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False, </span><span class="s1">**init_kwargs)</span>
            <span class="s1">tm.assert_index_equal(result</span><span class="s0">, </span><span class="s1">index)</span>

            <span class="s0">if </span><span class="s1">isinstance(index._values</span><span class="s0">, </span><span class="s1">BaseMaskedArray):</span>
                <span class="s0">assert </span><span class="s1">np.shares_memory(index._values._data</span><span class="s0">, </span><span class="s1">result._values._data)</span>
                <span class="s1">tm.assert_numpy_array_equal(</span>
                    <span class="s1">index._values._data</span><span class="s0">, </span><span class="s1">result._values._data</span><span class="s0">, </span><span class="s1">check_same=</span><span class="s3">&quot;same&quot;</span>
                <span class="s1">)</span>
                <span class="s0">assert </span><span class="s1">np.shares_memory(index._values._mask</span><span class="s0">, </span><span class="s1">result._values._mask)</span>
                <span class="s1">tm.assert_numpy_array_equal(</span>
                    <span class="s1">index._values._mask</span><span class="s0">, </span><span class="s1">result._values._mask</span><span class="s0">, </span><span class="s1">check_same=</span><span class="s3">&quot;same&quot;</span>
                <span class="s1">)</span>
            <span class="s0">elif </span><span class="s1">index.dtype == </span><span class="s3">&quot;string[python]&quot;</span><span class="s1">:</span>
                <span class="s0">assert </span><span class="s1">np.shares_memory(index._values._ndarray</span><span class="s0">, </span><span class="s1">result._values._ndarray)</span>
                <span class="s1">tm.assert_numpy_array_equal(</span>
                    <span class="s1">index._values._ndarray</span><span class="s0">, </span><span class="s1">result._values._ndarray</span><span class="s0">, </span><span class="s1">check_same=</span><span class="s3">&quot;same&quot;</span>
                <span class="s1">)</span>
            <span class="s0">elif </span><span class="s1">index.dtype == </span><span class="s3">&quot;string[pyarrow]&quot;</span><span class="s1">:</span>
                <span class="s0">assert </span><span class="s1">tm.shares_memory(result._values</span><span class="s0">, </span><span class="s1">index._values)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">NotImplementedError(index.dtype)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">result = index_type(index.values</span><span class="s0">, </span><span class="s1">copy=</span><span class="s0">False, </span><span class="s1">**init_kwargs)</span>
            <span class="s1">tm.assert_numpy_array_equal(index.values</span><span class="s0">, </span><span class="s1">result.values</span><span class="s0">, </span><span class="s1">check_same=</span><span class="s3">&quot;same&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_memory_usage(self</span><span class="s0">, </span><span class="s1">index):</span>
        <span class="s1">index._engine.clear_mapping()</span>
        <span class="s1">result = index.memory_usage()</span>
        <span class="s0">if </span><span class="s1">index.empty:</span>
            <span class="s4"># we report 0 for no-length</span>
            <span class="s0">assert </span><span class="s1">result == </span><span class="s2">0</span>
            <span class="s0">return</span>

        <span class="s4"># non-zero length</span>
        <span class="s1">index.get_loc(index[</span><span class="s2">0</span><span class="s1">])</span>
        <span class="s1">result2 = index.memory_usage()</span>
        <span class="s1">result3 = index.memory_usage(deep=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s4"># RangeIndex, IntervalIndex</span>
        <span class="s4"># don't have engines</span>
        <span class="s4"># Index[EA] has engine but it does not have a Hashtable .mapping</span>
        <span class="s0">if not </span><span class="s1">isinstance(index</span><span class="s0">, </span><span class="s1">(RangeIndex</span><span class="s0">, </span><span class="s1">IntervalIndex)) </span><span class="s0">and not </span><span class="s1">(</span>
            <span class="s1">type(index) </span><span class="s0">is </span><span class="s1">Index </span><span class="s0">and not </span><span class="s1">isinstance(index.dtype</span><span class="s0">, </span><span class="s1">np.dtype)</span>
        <span class="s1">):</span>
            <span class="s0">assert </span><span class="s1">result2 &gt; result</span>

        <span class="s0">if </span><span class="s1">index.inferred_type == </span><span class="s3">&quot;object&quot;</span><span class="s1">:</span>
            <span class="s0">assert </span><span class="s1">result3 &gt; result2</span>

    <span class="s0">def </span><span class="s1">test_argsort(self</span><span class="s0">, </span><span class="s1">index):</span>
        <span class="s0">if </span><span class="s1">isinstance(index</span><span class="s0">, </span><span class="s1">CategoricalIndex):</span>
            <span class="s1">pytest.skip(</span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">type(self).__name__</span><span class="s0">} </span><span class="s3">separately tested&quot;</span><span class="s1">)</span>

        <span class="s1">result = index.argsort()</span>
        <span class="s1">expected = np.array(index).argsort()</span>
        <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">check_dtype=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_numpy_argsort(self</span><span class="s0">, </span><span class="s1">index):</span>
        <span class="s1">result = np.argsort(index)</span>
        <span class="s1">expected = index.argsort()</span>
        <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">result = np.argsort(index</span><span class="s0">, </span><span class="s1">kind=</span><span class="s3">&quot;mergesort&quot;</span><span class="s1">)</span>
        <span class="s1">expected = index.argsort(kind=</span><span class="s3">&quot;mergesort&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s4"># these are the only two types that perform</span>
        <span class="s4"># pandas compatibility input validation - the</span>
        <span class="s4"># rest already perform separate (or no) such</span>
        <span class="s4"># validation via their 'values' attribute as</span>
        <span class="s4"># defined in pandas.core.indexes/base.py - they</span>
        <span class="s4"># cannot be changed at the moment due to</span>
        <span class="s4"># backwards compatibility concerns</span>
        <span class="s0">if </span><span class="s1">isinstance(index</span><span class="s0">, </span><span class="s1">(CategoricalIndex</span><span class="s0">, </span><span class="s1">RangeIndex)):</span>
            <span class="s1">msg = </span><span class="s3">&quot;the 'axis' parameter is not supported&quot;</span>
            <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">np.argsort(index</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">1</span><span class="s1">)</span>

            <span class="s1">msg = </span><span class="s3">&quot;the 'order' parameter is not supported&quot;</span>
            <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">np.argsort(index</span><span class="s0">, </span><span class="s1">order=(</span><span class="s3">&quot;a&quot;</span><span class="s0">, </span><span class="s3">&quot;b&quot;</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_repeat(self</span><span class="s0">, </span><span class="s1">simple_index):</span>
        <span class="s1">rep = </span><span class="s2">2</span>
        <span class="s1">idx = simple_index.copy()</span>
        <span class="s1">new_index_cls = idx._constructor</span>
        <span class="s1">expected = new_index_cls(idx.values.repeat(rep)</span><span class="s0">, </span><span class="s1">name=idx.name)</span>
        <span class="s1">tm.assert_index_equal(idx.repeat(rep)</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">idx = simple_index</span>
        <span class="s1">rep = np.arange(len(idx))</span>
        <span class="s1">expected = new_index_cls(idx.values.repeat(rep)</span><span class="s0">, </span><span class="s1">name=idx.name)</span>
        <span class="s1">tm.assert_index_equal(idx.repeat(rep)</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_numpy_repeat(self</span><span class="s0">, </span><span class="s1">simple_index):</span>
        <span class="s1">rep = </span><span class="s2">2</span>
        <span class="s1">idx = simple_index</span>
        <span class="s1">expected = idx.repeat(rep)</span>
        <span class="s1">tm.assert_index_equal(np.repeat(idx</span><span class="s0">, </span><span class="s1">rep)</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">msg = </span><span class="s3">&quot;the 'axis' parameter is not supported&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">np.repeat(idx</span><span class="s0">, </span><span class="s1">rep</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">0</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_where(self</span><span class="s0">, </span><span class="s1">listlike_box</span><span class="s0">, </span><span class="s1">simple_index):</span>
        <span class="s0">if </span><span class="s1">isinstance(simple_index</span><span class="s0">, </span><span class="s1">(IntervalIndex</span><span class="s0">, </span><span class="s1">PeriodIndex)) </span><span class="s0">or </span><span class="s1">is_numeric_dtype(</span>
            <span class="s1">simple_index.dtype</span>
        <span class="s1">):</span>
            <span class="s1">pytest.skip(</span><span class="s3">&quot;Tested elsewhere.&quot;</span><span class="s1">)</span>
        <span class="s1">klass = listlike_box</span>

        <span class="s1">idx = simple_index</span>
        <span class="s0">if </span><span class="s1">isinstance(idx</span><span class="s0">, </span><span class="s1">(DatetimeIndex</span><span class="s0">, </span><span class="s1">TimedeltaIndex)):</span>
            <span class="s4"># where does not preserve freq</span>
            <span class="s1">idx = idx._with_freq(</span><span class="s0">None</span><span class="s1">)</span>

        <span class="s1">cond = [</span><span class="s0">True</span><span class="s1">] * len(idx)</span>
        <span class="s1">result = idx.where(klass(cond))</span>
        <span class="s1">expected = idx</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">cond = [</span><span class="s0">False</span><span class="s1">] + [</span><span class="s0">True</span><span class="s1">] * len(idx[</span><span class="s2">1</span><span class="s1">:])</span>
        <span class="s1">expected = Index([idx._na_value] + idx[</span><span class="s2">1</span><span class="s1">:].tolist()</span><span class="s0">, </span><span class="s1">dtype=idx.dtype)</span>
        <span class="s1">result = idx.where(klass(cond))</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_insert_base(self</span><span class="s0">, </span><span class="s1">index):</span>
        <span class="s1">result = index[</span><span class="s2">1</span><span class="s1">:</span><span class="s2">4</span><span class="s1">]</span>

        <span class="s0">if not </span><span class="s1">len(index):</span>
            <span class="s1">pytest.skip(</span><span class="s3">&quot;Not applicable for empty index&quot;</span><span class="s1">)</span>

        <span class="s4"># test 0th element</span>
        <span class="s0">assert </span><span class="s1">index[</span><span class="s2">0</span><span class="s1">:</span><span class="s2">4</span><span class="s1">].equals(result.insert(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">index[</span><span class="s2">0</span><span class="s1">]))</span>

    <span class="s0">def </span><span class="s1">test_insert_out_of_bounds(self</span><span class="s0">, </span><span class="s1">index):</span>
        <span class="s4"># TypeError/IndexError matches what np.insert raises in these cases</span>

        <span class="s0">if </span><span class="s1">len(index) &gt; </span><span class="s2">0</span><span class="s1">:</span>
            <span class="s1">err = TypeError</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">err = IndexError</span>
        <span class="s0">if </span><span class="s1">len(index) == </span><span class="s2">0</span><span class="s1">:</span>
            <span class="s4"># 0 vs 0.5 in error message varies with numpy version</span>
            <span class="s1">msg = </span><span class="s3">&quot;index (0|0.5) is out of bounds for axis 0 with size 0&quot;</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s3">&quot;slice indices must be integers or None or have an __index__ method&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(err</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">index.insert(</span><span class="s2">0.5</span><span class="s0">, </span><span class="s3">&quot;foo&quot;</span><span class="s1">)</span>

        <span class="s1">msg = </span><span class="s3">&quot;|&quot;</span><span class="s1">.join(</span>
            <span class="s1">[</span>
                <span class="s3">r&quot;index -?\d+ is out of bounds for axis 0 with size \d+&quot;</span><span class="s0">,</span>
                <span class="s3">&quot;loc must be an integer between&quot;</span><span class="s0">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(IndexError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">index.insert(len(index) + </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">pytest.raises(IndexError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">index.insert(-len(index) - </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_delete_base(self</span><span class="s0">, </span><span class="s1">index):</span>
        <span class="s0">if not </span><span class="s1">len(index):</span>
            <span class="s1">pytest.skip(</span><span class="s3">&quot;Not applicable for empty index&quot;</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">isinstance(index</span><span class="s0">, </span><span class="s1">RangeIndex):</span>
            <span class="s4"># tested in class</span>
            <span class="s1">pytest.skip(</span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">type(self).__name__</span><span class="s0">} </span><span class="s3">tested elsewhere&quot;</span><span class="s1">)</span>

        <span class="s1">expected = index[</span><span class="s2">1</span><span class="s1">:]</span>
        <span class="s1">result = index.delete(</span><span class="s2">0</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">result.equals(expected)</span>
        <span class="s0">assert </span><span class="s1">result.name == expected.name</span>

        <span class="s1">expected = index[:-</span><span class="s2">1</span><span class="s1">]</span>
        <span class="s1">result = index.delete(-</span><span class="s2">1</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">result.equals(expected)</span>
        <span class="s0">assert </span><span class="s1">result.name == expected.name</span>

        <span class="s1">length = len(index)</span>
        <span class="s1">msg = </span><span class="s3">f&quot;index </span><span class="s0">{</span><span class="s1">length</span><span class="s0">} </span><span class="s3">is out of bounds for axis 0 with size </span><span class="s0">{</span><span class="s1">length</span><span class="s0">}</span><span class="s3">&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(IndexError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">index.delete(length)</span>

    <span class="s1">@pytest.mark.filterwarnings(</span><span class="s3">r&quot;ignore:PeriodDtype\[B\] is deprecated:FutureWarning&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_equals(self</span><span class="s0">, </span><span class="s1">index):</span>
        <span class="s0">if </span><span class="s1">isinstance(index</span><span class="s0">, </span><span class="s1">IntervalIndex):</span>
            <span class="s1">pytest.skip(</span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">type(index).__name__</span><span class="s0">} </span><span class="s3">tested elsewhere&quot;</span><span class="s1">)</span>

        <span class="s1">is_ea_idx = type(index) </span><span class="s0">is </span><span class="s1">Index </span><span class="s0">and not </span><span class="s1">isinstance(index.dtype</span><span class="s0">, </span><span class="s1">np.dtype)</span>

        <span class="s0">assert </span><span class="s1">index.equals(index)</span>
        <span class="s0">assert </span><span class="s1">index.equals(index.copy())</span>
        <span class="s0">if not </span><span class="s1">is_ea_idx:</span>
            <span class="s4"># doesn't hold for e.g. IntegerDtype</span>
            <span class="s0">assert </span><span class="s1">index.equals(index.astype(object))</span>

        <span class="s0">assert not </span><span class="s1">index.equals(list(index))</span>
        <span class="s0">assert not </span><span class="s1">index.equals(np.array(index))</span>

        <span class="s4"># Cannot pass in non-int64 dtype to RangeIndex</span>
        <span class="s0">if not </span><span class="s1">isinstance(index</span><span class="s0">, </span><span class="s1">RangeIndex) </span><span class="s0">and not </span><span class="s1">is_ea_idx:</span>
            <span class="s1">same_values = Index(index</span><span class="s0">, </span><span class="s1">dtype=object)</span>
            <span class="s0">assert </span><span class="s1">index.equals(same_values)</span>
            <span class="s0">assert </span><span class="s1">same_values.equals(index)</span>

        <span class="s0">if </span><span class="s1">index.nlevels == </span><span class="s2">1</span><span class="s1">:</span>
            <span class="s4"># do not test MultiIndex</span>
            <span class="s0">assert not </span><span class="s1">index.equals(Series(index))</span>

    <span class="s0">def </span><span class="s1">test_equals_op(self</span><span class="s0">, </span><span class="s1">simple_index):</span>
        <span class="s4"># GH9947, GH10637</span>
        <span class="s1">index_a = simple_index</span>

        <span class="s1">n = len(index_a)</span>
        <span class="s1">index_b = index_a[</span><span class="s2">0</span><span class="s1">:-</span><span class="s2">1</span><span class="s1">]</span>
        <span class="s1">index_c = index_a[</span><span class="s2">0</span><span class="s1">:-</span><span class="s2">1</span><span class="s1">].append(index_a[-</span><span class="s2">2</span><span class="s1">:-</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">index_d = index_a[</span><span class="s2">0</span><span class="s1">:</span><span class="s2">1</span><span class="s1">]</span>

        <span class="s1">msg = </span><span class="s3">&quot;Lengths must match|could not be broadcast&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">index_a == index_b</span>
        <span class="s1">expected1 = np.array([</span><span class="s0">True</span><span class="s1">] * n)</span>
        <span class="s1">expected2 = np.array([</span><span class="s0">True</span><span class="s1">] * (n - </span><span class="s2">1</span><span class="s1">) + [</span><span class="s0">False</span><span class="s1">])</span>
        <span class="s1">tm.assert_numpy_array_equal(index_a == index_a</span><span class="s0">, </span><span class="s1">expected1)</span>
        <span class="s1">tm.assert_numpy_array_equal(index_a == index_c</span><span class="s0">, </span><span class="s1">expected2)</span>

        <span class="s4"># test comparisons with numpy arrays</span>
        <span class="s1">array_a = np.array(index_a)</span>
        <span class="s1">array_b = np.array(index_a[</span><span class="s2">0</span><span class="s1">:-</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">array_c = np.array(index_a[</span><span class="s2">0</span><span class="s1">:-</span><span class="s2">1</span><span class="s1">].append(index_a[-</span><span class="s2">2</span><span class="s1">:-</span><span class="s2">1</span><span class="s1">]))</span>
        <span class="s1">array_d = np.array(index_a[</span><span class="s2">0</span><span class="s1">:</span><span class="s2">1</span><span class="s1">])</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">index_a == array_b</span>
        <span class="s1">tm.assert_numpy_array_equal(index_a == array_a</span><span class="s0">, </span><span class="s1">expected1)</span>
        <span class="s1">tm.assert_numpy_array_equal(index_a == array_c</span><span class="s0">, </span><span class="s1">expected2)</span>

        <span class="s4"># test comparisons with Series</span>
        <span class="s1">series_a = Series(array_a)</span>
        <span class="s1">series_b = Series(array_b)</span>
        <span class="s1">series_c = Series(array_c)</span>
        <span class="s1">series_d = Series(array_d)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">index_a == series_b</span>

        <span class="s1">tm.assert_numpy_array_equal(index_a == series_a</span><span class="s0">, </span><span class="s1">expected1)</span>
        <span class="s1">tm.assert_numpy_array_equal(index_a == series_c</span><span class="s0">, </span><span class="s1">expected2)</span>

        <span class="s4"># cases where length is 1 for one of them</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">&quot;Lengths must match&quot;</span><span class="s1">):</span>
            <span class="s1">index_a == index_d</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">&quot;Lengths must match&quot;</span><span class="s1">):</span>
            <span class="s1">index_a == series_d</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">&quot;Lengths must match&quot;</span><span class="s1">):</span>
            <span class="s1">index_a == array_d</span>
        <span class="s1">msg = </span><span class="s3">&quot;Can only compare identically-labeled Series objects&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">series_a == series_d</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s3">&quot;Lengths must match&quot;</span><span class="s1">):</span>
            <span class="s1">series_a == array_d</span>

        <span class="s4"># comparing with a scalar should broadcast; note that we are excluding</span>
        <span class="s4"># MultiIndex because in this case each item in the index is a tuple of</span>
        <span class="s4"># length 2, and therefore is considered an array of length 2 in the</span>
        <span class="s4"># comparison instead of a scalar</span>
        <span class="s0">if not </span><span class="s1">isinstance(index_a</span><span class="s0">, </span><span class="s1">MultiIndex):</span>
            <span class="s1">expected3 = np.array([</span><span class="s0">False</span><span class="s1">] * (len(index_a) - </span><span class="s2">2</span><span class="s1">) + [</span><span class="s0">True, False</span><span class="s1">])</span>
            <span class="s4"># assuming the 2nd to last item is unique in the data</span>
            <span class="s1">item = index_a[-</span><span class="s2">2</span><span class="s1">]</span>
            <span class="s1">tm.assert_numpy_array_equal(index_a == item</span><span class="s0">, </span><span class="s1">expected3)</span>
            <span class="s1">tm.assert_series_equal(series_a == item</span><span class="s0">, </span><span class="s1">Series(expected3))</span>

    <span class="s0">def </span><span class="s1">test_format(self</span><span class="s0">, </span><span class="s1">simple_index):</span>
        <span class="s4"># GH35439</span>
        <span class="s0">if </span><span class="s1">is_numeric_dtype(simple_index.dtype) </span><span class="s0">or </span><span class="s1">isinstance(</span>
            <span class="s1">simple_index</span><span class="s0">, </span><span class="s1">DatetimeIndex</span>
        <span class="s1">):</span>
            <span class="s1">pytest.skip(</span><span class="s3">&quot;Tested elsewhere.&quot;</span><span class="s1">)</span>
        <span class="s1">idx = simple_index</span>
        <span class="s1">expected = [str(x) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">idx]</span>
        <span class="s0">assert </span><span class="s1">idx.format() == expected</span>

    <span class="s0">def </span><span class="s1">test_format_empty(self</span><span class="s0">, </span><span class="s1">simple_index):</span>
        <span class="s4"># GH35712</span>
        <span class="s0">if </span><span class="s1">isinstance(simple_index</span><span class="s0">, </span><span class="s1">(PeriodIndex</span><span class="s0">, </span><span class="s1">RangeIndex)):</span>
            <span class="s1">pytest.skip(</span><span class="s3">&quot;Tested elsewhere&quot;</span><span class="s1">)</span>
        <span class="s1">empty_idx = type(simple_index)([])</span>
        <span class="s0">assert </span><span class="s1">empty_idx.format() == []</span>
        <span class="s0">assert </span><span class="s1">empty_idx.format(name=</span><span class="s0">True</span><span class="s1">) == [</span><span class="s3">&quot;&quot;</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">test_fillna(self</span><span class="s0">, </span><span class="s1">index):</span>
        <span class="s4"># GH 11343</span>
        <span class="s0">if </span><span class="s1">len(index) == </span><span class="s2">0</span><span class="s1">:</span>
            <span class="s1">pytest.skip(</span><span class="s3">&quot;Not relevant for empty index&quot;</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">index.dtype == bool:</span>
            <span class="s1">pytest.skip(</span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">index.dtype</span><span class="s0">} </span><span class="s3">cannot hold NAs&quot;</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">isinstance(index</span><span class="s0">, </span><span class="s1">Index) </span><span class="s0">and </span><span class="s1">is_integer_dtype(index.dtype):</span>
            <span class="s1">pytest.skip(</span><span class="s3">f&quot;Not relevant for Index with </span><span class="s0">{</span><span class="s1">index.dtype</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">isinstance(index</span><span class="s0">, </span><span class="s1">MultiIndex):</span>
            <span class="s1">idx = index.copy(deep=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s1">msg = </span><span class="s3">&quot;isna is not defined for MultiIndex&quot;</span>
            <span class="s0">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">idx.fillna(idx[</span><span class="s2">0</span><span class="s1">])</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">idx = index.copy(deep=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s1">result = idx.fillna(idx[</span><span class="s2">0</span><span class="s1">])</span>
            <span class="s1">tm.assert_index_equal(result</span><span class="s0">, </span><span class="s1">idx)</span>
            <span class="s0">assert </span><span class="s1">result </span><span class="s0">is not </span><span class="s1">idx</span>

            <span class="s1">msg = </span><span class="s3">&quot;'value' must be a scalar, passed: &quot;</span>
            <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">idx.fillna([idx[</span><span class="s2">0</span><span class="s1">]])</span>

            <span class="s1">idx = index.copy(deep=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s1">values = idx._values</span>

            <span class="s1">values[</span><span class="s2">1</span><span class="s1">] = np.nan</span>

            <span class="s1">idx = type(index)(values)</span>

            <span class="s1">msg = </span><span class="s3">&quot;does not support 'downcast'&quot;</span>
            <span class="s1">msg2 = </span><span class="s3">r&quot;The 'downcast' keyword in .*Index\.fillna is deprecated&quot;</span>
            <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s0">, </span><span class="s1">match=msg2):</span>
                <span class="s0">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                    <span class="s4"># For now at least, we only raise if there are NAs present</span>
                    <span class="s1">idx.fillna(idx[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">downcast=</span><span class="s3">&quot;infer&quot;</span><span class="s1">)</span>

            <span class="s1">expected = np.array([</span><span class="s0">False</span><span class="s1">] * len(idx)</span><span class="s0">, </span><span class="s1">dtype=bool)</span>
            <span class="s1">expected[</span><span class="s2">1</span><span class="s1">] = </span><span class="s0">True</span>
            <span class="s1">tm.assert_numpy_array_equal(idx._isnan</span><span class="s0">, </span><span class="s1">expected)</span>
            <span class="s0">assert </span><span class="s1">idx.hasnans </span><span class="s0">is True</span>

    <span class="s0">def </span><span class="s1">test_nulls(self</span><span class="s0">, </span><span class="s1">index):</span>
        <span class="s4"># this is really a smoke test for the methods</span>
        <span class="s4"># as these are adequately tested for function elsewhere</span>
        <span class="s0">if </span><span class="s1">len(index) == </span><span class="s2">0</span><span class="s1">:</span>
            <span class="s1">tm.assert_numpy_array_equal(index.isna()</span><span class="s0">, </span><span class="s1">np.array([]</span><span class="s0">, </span><span class="s1">dtype=bool))</span>
        <span class="s0">elif </span><span class="s1">isinstance(index</span><span class="s0">, </span><span class="s1">MultiIndex):</span>
            <span class="s1">idx = index.copy()</span>
            <span class="s1">msg = </span><span class="s3">&quot;isna is not defined for MultiIndex&quot;</span>
            <span class="s0">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">idx.isna()</span>
        <span class="s0">elif not </span><span class="s1">index.hasnans:</span>
            <span class="s1">tm.assert_numpy_array_equal(index.isna()</span><span class="s0">, </span><span class="s1">np.zeros(len(index)</span><span class="s0">, </span><span class="s1">dtype=bool))</span>
            <span class="s1">tm.assert_numpy_array_equal(index.notna()</span><span class="s0">, </span><span class="s1">np.ones(len(index)</span><span class="s0">, </span><span class="s1">dtype=bool))</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">result = isna(index)</span>
            <span class="s1">tm.assert_numpy_array_equal(index.isna()</span><span class="s0">, </span><span class="s1">result)</span>
            <span class="s1">tm.assert_numpy_array_equal(index.notna()</span><span class="s0">, </span><span class="s1">~result)</span>

    <span class="s0">def </span><span class="s1">test_empty(self</span><span class="s0">, </span><span class="s1">simple_index):</span>
        <span class="s4"># GH 15270</span>
        <span class="s1">idx = simple_index</span>
        <span class="s0">assert not </span><span class="s1">idx.empty</span>
        <span class="s0">assert </span><span class="s1">idx[:</span><span class="s2">0</span><span class="s1">].empty</span>

    <span class="s0">def </span><span class="s1">test_join_self_unique(self</span><span class="s0">, </span><span class="s1">join_type</span><span class="s0">, </span><span class="s1">simple_index):</span>
        <span class="s1">idx = simple_index</span>
        <span class="s0">if </span><span class="s1">idx.is_unique:</span>
            <span class="s1">joined = idx.join(idx</span><span class="s0">, </span><span class="s1">how=join_type)</span>
            <span class="s0">assert </span><span class="s1">(idx == joined).all()</span>

    <span class="s0">def </span><span class="s1">test_map(self</span><span class="s0">, </span><span class="s1">simple_index):</span>
        <span class="s4"># callable</span>
        <span class="s0">if </span><span class="s1">isinstance(simple_index</span><span class="s0">, </span><span class="s1">(TimedeltaIndex</span><span class="s0">, </span><span class="s1">PeriodIndex)):</span>
            <span class="s1">pytest.skip(</span><span class="s3">&quot;Tested elsewhere.&quot;</span><span class="s1">)</span>
        <span class="s1">idx = simple_index</span>

        <span class="s1">result = idx.map(</span><span class="s0">lambda </span><span class="s1">x: x)</span>
        <span class="s4"># RangeIndex are equivalent to the similar Index with int64 dtype</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s0">, </span><span class="s1">idx</span><span class="s0">, </span><span class="s1">exact=</span><span class="s3">&quot;equiv&quot;</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;mapper&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s0">lambda </span><span class="s1">values</span><span class="s0">, </span><span class="s1">index: {i: e </span><span class="s0">for </span><span class="s1">e</span><span class="s0">, </span><span class="s1">i </span><span class="s0">in </span><span class="s1">zip(values</span><span class="s0">, </span><span class="s1">index)}</span><span class="s0">,</span>
            <span class="s0">lambda </span><span class="s1">values</span><span class="s0">, </span><span class="s1">index: Series(values</span><span class="s0">, </span><span class="s1">index)</span><span class="s0">,</span>
        <span class="s1">]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">@pytest.mark.filterwarnings(</span><span class="s3">r&quot;ignore:PeriodDtype\[B\] is deprecated:FutureWarning&quot;</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_map_dictlike(self</span><span class="s0">, </span><span class="s1">mapper</span><span class="s0">, </span><span class="s1">simple_index</span><span class="s0">, </span><span class="s1">request):</span>
        <span class="s1">idx = simple_index</span>
        <span class="s0">if </span><span class="s1">isinstance(idx</span><span class="s0">, </span><span class="s1">(DatetimeIndex</span><span class="s0">, </span><span class="s1">TimedeltaIndex</span><span class="s0">, </span><span class="s1">PeriodIndex)):</span>
            <span class="s1">pytest.skip(</span><span class="s3">&quot;Tested elsewhere.&quot;</span><span class="s1">)</span>

        <span class="s1">identity = mapper(idx.values</span><span class="s0">, </span><span class="s1">idx)</span>

        <span class="s1">result = idx.map(identity)</span>
        <span class="s4"># RangeIndex are equivalent to the similar Index with int64 dtype</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s0">, </span><span class="s1">idx</span><span class="s0">, </span><span class="s1">exact=</span><span class="s3">&quot;equiv&quot;</span><span class="s1">)</span>

        <span class="s4"># empty mappable</span>
        <span class="s1">dtype = </span><span class="s0">None</span>
        <span class="s0">if </span><span class="s1">idx.dtype.kind == </span><span class="s3">&quot;f&quot;</span><span class="s1">:</span>
            <span class="s1">dtype = idx.dtype</span>

        <span class="s1">expected = Index([np.nan] * len(idx)</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">result = idx.map(mapper(expected</span><span class="s0">, </span><span class="s1">idx))</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_map_str(self</span><span class="s0">, </span><span class="s1">simple_index):</span>
        <span class="s4"># GH 31202</span>
        <span class="s0">if </span><span class="s1">isinstance(simple_index</span><span class="s0">, </span><span class="s1">CategoricalIndex):</span>
            <span class="s1">pytest.skip(</span><span class="s3">&quot;See test_map.py&quot;</span><span class="s1">)</span>
        <span class="s1">idx = simple_index</span>
        <span class="s1">result = idx.map(str)</span>
        <span class="s1">expected = Index([str(x) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">idx]</span><span class="s0">, </span><span class="s1">dtype=object)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;copy&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;name&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">None, </span><span class="s3">&quot;foo&quot;</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;ordered&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_astype_category(self</span><span class="s0">, </span><span class="s1">copy</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">ordered</span><span class="s0">, </span><span class="s1">simple_index):</span>
        <span class="s4"># GH 18630</span>
        <span class="s1">idx = simple_index</span>
        <span class="s0">if </span><span class="s1">name:</span>
            <span class="s1">idx = idx.rename(name)</span>

        <span class="s4"># standard categories</span>
        <span class="s1">dtype = CategoricalDtype(ordered=ordered)</span>
        <span class="s1">result = idx.astype(dtype</span><span class="s0">, </span><span class="s1">copy=copy)</span>
        <span class="s1">expected = CategoricalIndex(idx</span><span class="s0">, </span><span class="s1">name=name</span><span class="s0">, </span><span class="s1">ordered=ordered)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">exact=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s4"># non-standard categories</span>
        <span class="s1">dtype = CategoricalDtype(idx.unique().tolist()[:-</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">ordered)</span>
        <span class="s1">result = idx.astype(dtype</span><span class="s0">, </span><span class="s1">copy=copy)</span>
        <span class="s1">expected = CategoricalIndex(idx</span><span class="s0">, </span><span class="s1">name=name</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">exact=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">ordered </span><span class="s0">is False</span><span class="s1">:</span>
            <span class="s4"># dtype='category' defaults to ordered=False, so only test once</span>
            <span class="s1">result = idx.astype(</span><span class="s3">&quot;category&quot;</span><span class="s0">, </span><span class="s1">copy=copy)</span>
            <span class="s1">expected = CategoricalIndex(idx</span><span class="s0">, </span><span class="s1">name=name)</span>
            <span class="s1">tm.assert_index_equal(result</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">exact=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_is_unique(self</span><span class="s0">, </span><span class="s1">simple_index):</span>
        <span class="s4"># initialize a unique index</span>
        <span class="s1">index = simple_index.drop_duplicates()</span>
        <span class="s0">assert </span><span class="s1">index.is_unique </span><span class="s0">is True</span>

        <span class="s4"># empty index should be unique</span>
        <span class="s1">index_empty = index[:</span><span class="s2">0</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s1">index_empty.is_unique </span><span class="s0">is True</span>

        <span class="s4"># test basic dupes</span>
        <span class="s1">index_dup = index.insert(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">index[</span><span class="s2">0</span><span class="s1">])</span>
        <span class="s0">assert </span><span class="s1">index_dup.is_unique </span><span class="s0">is False</span>

        <span class="s4"># single NA should be unique</span>
        <span class="s1">index_na = index.insert(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">np.nan)</span>
        <span class="s0">assert </span><span class="s1">index_na.is_unique </span><span class="s0">is True</span>

        <span class="s4"># multiple NA should not be unique</span>
        <span class="s1">index_na_dup = index_na.insert(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">np.nan)</span>
        <span class="s0">assert </span><span class="s1">index_na_dup.is_unique </span><span class="s0">is False</span>

    <span class="s1">@pytest.mark.arm_slow</span>
    <span class="s0">def </span><span class="s1">test_engine_reference_cycle(self</span><span class="s0">, </span><span class="s1">simple_index):</span>
        <span class="s4"># GH27585</span>
        <span class="s1">index = simple_index</span>
        <span class="s1">nrefs_pre = len(gc.get_referrers(index))</span>
        <span class="s1">index._engine</span>
        <span class="s0">assert </span><span class="s1">len(gc.get_referrers(index)) == nrefs_pre</span>

    <span class="s0">def </span><span class="s1">test_getitem_2d_deprecated(self</span><span class="s0">, </span><span class="s1">simple_index):</span>
        <span class="s4"># GH#30588, GH#31479</span>
        <span class="s0">if </span><span class="s1">isinstance(simple_index</span><span class="s0">, </span><span class="s1">IntervalIndex):</span>
            <span class="s1">pytest.skip(</span><span class="s3">&quot;Tested elsewhere&quot;</span><span class="s1">)</span>
        <span class="s1">idx = simple_index</span>
        <span class="s1">msg = </span><span class="s3">&quot;Multi-dimensional indexing&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">idx[:</span><span class="s0">, None</span><span class="s1">]</span>

        <span class="s0">if not </span><span class="s1">isinstance(idx</span><span class="s0">, </span><span class="s1">RangeIndex):</span>
            <span class="s4"># GH#44051 RangeIndex already raised pre-2.0 with a different message</span>
            <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">idx[</span><span class="s0">True</span><span class="s1">]</span>
            <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">idx[</span><span class="s0">False</span><span class="s1">]</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s3">&quot;only integers, slices&quot;</span>
            <span class="s0">with </span><span class="s1">pytest.raises(IndexError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">idx[</span><span class="s0">True</span><span class="s1">]</span>
            <span class="s0">with </span><span class="s1">pytest.raises(IndexError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">idx[</span><span class="s0">False</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">test_copy_shares_cache(self</span><span class="s0">, </span><span class="s1">simple_index):</span>
        <span class="s4"># GH32898, GH36840</span>
        <span class="s1">idx = simple_index</span>
        <span class="s1">idx.get_loc(idx[</span><span class="s2">0</span><span class="s1">])  </span><span class="s4"># populates the _cache.</span>
        <span class="s1">copy = idx.copy()</span>

        <span class="s0">assert </span><span class="s1">copy._cache </span><span class="s0">is </span><span class="s1">idx._cache</span>

    <span class="s0">def </span><span class="s1">test_shallow_copy_shares_cache(self</span><span class="s0">, </span><span class="s1">simple_index):</span>
        <span class="s4"># GH32669, GH36840</span>
        <span class="s1">idx = simple_index</span>
        <span class="s1">idx.get_loc(idx[</span><span class="s2">0</span><span class="s1">])  </span><span class="s4"># populates the _cache.</span>
        <span class="s1">shallow_copy = idx._view()</span>

        <span class="s0">assert </span><span class="s1">shallow_copy._cache </span><span class="s0">is </span><span class="s1">idx._cache</span>

        <span class="s1">shallow_copy = idx._shallow_copy(idx._data)</span>
        <span class="s0">assert </span><span class="s1">shallow_copy._cache </span><span class="s0">is not </span><span class="s1">idx._cache</span>
        <span class="s0">assert </span><span class="s1">shallow_copy._cache == {}</span>

    <span class="s0">def </span><span class="s1">test_index_groupby(self</span><span class="s0">, </span><span class="s1">simple_index):</span>
        <span class="s1">idx = simple_index[:</span><span class="s2">5</span><span class="s1">]</span>
        <span class="s1">to_groupby = np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">])</span>
        <span class="s1">tm.assert_dict_equal(</span>
            <span class="s1">idx.groupby(to_groupby)</span><span class="s0">, </span><span class="s1">{</span><span class="s2">1.0</span><span class="s1">: idx[[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]]</span><span class="s0">, </span><span class="s2">2.0</span><span class="s1">: idx[[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]]}</span>
        <span class="s1">)</span>

        <span class="s1">to_groupby = DatetimeIndex(</span>
            <span class="s1">[</span>
                <span class="s1">datetime(</span><span class="s2">2011</span><span class="s0">, </span><span class="s2">11</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">datetime(</span><span class="s2">2011</span><span class="s0">, </span><span class="s2">12</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">pd.NaT</span><span class="s0">,</span>
                <span class="s1">datetime(</span><span class="s2">2011</span><span class="s0">, </span><span class="s2">12</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span><span class="s0">,</span>
                <span class="s1">datetime(</span><span class="s2">2011</span><span class="s0">, </span><span class="s2">11</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">]</span><span class="s0">,</span>
            <span class="s1">tz=</span><span class="s3">&quot;UTC&quot;</span><span class="s0">,</span>
        <span class="s1">).values</span>

        <span class="s1">ex_keys = [Timestamp(</span><span class="s3">&quot;2011-11-01&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;2011-12-01&quot;</span><span class="s1">)]</span>
        <span class="s1">expected = {ex_keys[</span><span class="s2">0</span><span class="s1">]: idx[[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">ex_keys[</span><span class="s2">1</span><span class="s1">]: idx[[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]]}</span>
        <span class="s1">tm.assert_dict_equal(idx.groupby(to_groupby)</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_append_preserves_dtype(self</span><span class="s0">, </span><span class="s1">simple_index):</span>
        <span class="s4"># In particular Index with dtype float32</span>
        <span class="s1">index = simple_index</span>
        <span class="s1">N = len(index)</span>

        <span class="s1">result = index.append(index)</span>
        <span class="s0">assert </span><span class="s1">result.dtype == index.dtype</span>
        <span class="s1">tm.assert_index_equal(result[:N]</span><span class="s0">, </span><span class="s1">index</span><span class="s0">, </span><span class="s1">check_exact=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result[N:]</span><span class="s0">, </span><span class="s1">index</span><span class="s0">, </span><span class="s1">check_exact=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s1">alt = index.take(list(range(N)) * </span><span class="s2">2</span><span class="s1">)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s0">, </span><span class="s1">alt</span><span class="s0">, </span><span class="s1">check_exact=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_inv(self</span><span class="s0">, </span><span class="s1">simple_index):</span>
        <span class="s1">idx = simple_index</span>

        <span class="s0">if </span><span class="s1">idx.dtype.kind </span><span class="s0">in </span><span class="s1">[</span><span class="s3">&quot;i&quot;</span><span class="s0">, </span><span class="s3">&quot;u&quot;</span><span class="s1">]:</span>
            <span class="s1">res = ~idx</span>
            <span class="s1">expected = Index(~idx.values</span><span class="s0">, </span><span class="s1">name=idx.name)</span>
            <span class="s1">tm.assert_index_equal(res</span><span class="s0">, </span><span class="s1">expected)</span>

            <span class="s4"># check that we are matching Series behavior</span>
            <span class="s1">res2 = ~Series(idx)</span>
            <span class="s1">tm.assert_series_equal(res2</span><span class="s0">, </span><span class="s1">Series(expected))</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">idx.dtype.kind == </span><span class="s3">&quot;f&quot;</span><span class="s1">:</span>
                <span class="s1">msg = </span><span class="s3">&quot;ufunc 'invert' not supported for the input types&quot;</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">msg = </span><span class="s3">&quot;bad operand&quot;</span>
            <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">~idx</span>

            <span class="s4"># check that we get the same behavior with Series</span>
            <span class="s0">with </span><span class="s1">pytest.raises(TypeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
                <span class="s1">~Series(idx)</span>

    <span class="s0">def </span><span class="s1">test_is_boolean_is_deprecated(self</span><span class="s0">, </span><span class="s1">simple_index):</span>
        <span class="s4"># GH50042</span>
        <span class="s1">idx = simple_index</span>
        <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning):</span>
            <span class="s1">idx.is_boolean()</span>

    <span class="s0">def </span><span class="s1">test_is_floating_is_deprecated(self</span><span class="s0">, </span><span class="s1">simple_index):</span>
        <span class="s4"># GH50042</span>
        <span class="s1">idx = simple_index</span>
        <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning):</span>
            <span class="s1">idx.is_floating()</span>

    <span class="s0">def </span><span class="s1">test_is_integer_is_deprecated(self</span><span class="s0">, </span><span class="s1">simple_index):</span>
        <span class="s4"># GH50042</span>
        <span class="s1">idx = simple_index</span>
        <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning):</span>
            <span class="s1">idx.is_integer()</span>

    <span class="s0">def </span><span class="s1">test_holds_integer_deprecated(self</span><span class="s0">, </span><span class="s1">simple_index):</span>
        <span class="s4"># GH50243</span>
        <span class="s1">idx = simple_index</span>
        <span class="s1">msg = </span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">type(idx).__name__</span><span class="s0">}</span><span class="s3">.holds_integer is deprecated. &quot;</span>
        <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">idx.holds_integer()</span>

    <span class="s0">def </span><span class="s1">test_is_numeric_is_deprecated(self</span><span class="s0">, </span><span class="s1">simple_index):</span>
        <span class="s4"># GH50042</span>
        <span class="s1">idx = simple_index</span>
        <span class="s0">with </span><span class="s1">tm.assert_produces_warning(</span>
            <span class="s1">FutureWarning</span><span class="s0">,</span>
            <span class="s1">match=</span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">type(idx).__name__</span><span class="s0">}</span><span class="s3">.is_numeric is deprecated. &quot;</span><span class="s0">,</span>
        <span class="s1">):</span>
            <span class="s1">idx.is_numeric()</span>

    <span class="s0">def </span><span class="s1">test_is_categorical_is_deprecated(self</span><span class="s0">, </span><span class="s1">simple_index):</span>
        <span class="s4"># GH50042</span>
        <span class="s1">idx = simple_index</span>
        <span class="s0">with </span><span class="s1">tm.assert_produces_warning(</span>
            <span class="s1">FutureWarning</span><span class="s0">,</span>
            <span class="s1">match=</span><span class="s3">r&quot;Use pandas\.api\.types\.is_categorical_dtype instead&quot;</span><span class="s0">,</span>
        <span class="s1">):</span>
            <span class="s1">idx.is_categorical()</span>

    <span class="s0">def </span><span class="s1">test_is_interval_is_deprecated(self</span><span class="s0">, </span><span class="s1">simple_index):</span>
        <span class="s4"># GH50042</span>
        <span class="s1">idx = simple_index</span>
        <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning):</span>
            <span class="s1">idx.is_interval()</span>

    <span class="s0">def </span><span class="s1">test_is_object_is_deprecated(self</span><span class="s0">, </span><span class="s1">simple_index):</span>
        <span class="s4"># GH50042</span>
        <span class="s1">idx = simple_index</span>
        <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning):</span>
            <span class="s1">idx.is_object()</span>


<span class="s0">class </span><span class="s1">TestNumericBase:</span>
    <span class="s1">@pytest.fixture(</span>
        <span class="s1">params=[</span>
            <span class="s1">RangeIndex(start=</span><span class="s2">0</span><span class="s0">, </span><span class="s1">stop=</span><span class="s2">20</span><span class="s0">, </span><span class="s1">step=</span><span class="s2">2</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">Index(np.arange(</span><span class="s2">5</span><span class="s0">, </span><span class="s1">dtype=np.float64))</span><span class="s0">,</span>
            <span class="s1">Index(np.arange(</span><span class="s2">5</span><span class="s0">, </span><span class="s1">dtype=np.float32))</span><span class="s0">,</span>
            <span class="s1">Index(np.arange(</span><span class="s2">5</span><span class="s0">, </span><span class="s1">dtype=np.uint64))</span><span class="s0">,</span>
            <span class="s1">Index(range(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">20</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=np.int64)</span><span class="s0">,</span>
            <span class="s1">Index(range(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">20</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=np.int32)</span><span class="s0">,</span>
            <span class="s1">Index(range(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">20</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=np.int16)</span><span class="s0">,</span>
            <span class="s1">Index(range(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">20</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=np.int8)</span><span class="s0">,</span>
        <span class="s1">]</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">simple_index(self</span><span class="s0">, </span><span class="s1">request):</span>
        <span class="s0">return </span><span class="s1">request.param</span>

    <span class="s0">def </span><span class="s1">test_constructor_unwraps_index(self</span><span class="s0">, </span><span class="s1">simple_index):</span>
        <span class="s0">if </span><span class="s1">isinstance(simple_index</span><span class="s0">, </span><span class="s1">RangeIndex):</span>
            <span class="s1">pytest.skip(</span><span class="s3">&quot;Tested elsewhere.&quot;</span><span class="s1">)</span>
        <span class="s1">index_cls = type(simple_index)</span>
        <span class="s1">dtype = simple_index.dtype</span>

        <span class="s1">idx = Index([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">result = index_cls(idx)</span>
        <span class="s1">expected = np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=idx.dtype)</span>
        <span class="s1">tm.assert_numpy_array_equal(result._data</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">def </span><span class="s1">test_can_hold_identifiers(self</span><span class="s0">, </span><span class="s1">simple_index):</span>
        <span class="s1">idx = simple_index</span>
        <span class="s1">key = idx[</span><span class="s2">0</span><span class="s1">]</span>
        <span class="s0">assert </span><span class="s1">idx._can_hold_identifiers_and_holds_name(key) </span><span class="s0">is False</span>

    <span class="s0">def </span><span class="s1">test_view(self</span><span class="s0">, </span><span class="s1">simple_index):</span>
        <span class="s0">if </span><span class="s1">isinstance(simple_index</span><span class="s0">, </span><span class="s1">RangeIndex):</span>
            <span class="s1">pytest.skip(</span><span class="s3">&quot;Tested elsewhere.&quot;</span><span class="s1">)</span>
        <span class="s1">index_cls = type(simple_index)</span>
        <span class="s1">dtype = simple_index.dtype</span>

        <span class="s1">idx = index_cls([]</span><span class="s0">, </span><span class="s1">dtype=dtype</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;Foo&quot;</span><span class="s1">)</span>
        <span class="s1">idx_view = idx.view()</span>
        <span class="s0">assert </span><span class="s1">idx_view.name == </span><span class="s3">&quot;Foo&quot;</span>

        <span class="s1">idx_view = idx.view(dtype)</span>
        <span class="s1">tm.assert_index_equal(idx</span><span class="s0">, </span><span class="s1">index_cls(idx_view</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;Foo&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">exact=</span><span class="s0">True</span><span class="s1">)</span>

        <span class="s1">idx_view = idx.view(index_cls)</span>
        <span class="s1">tm.assert_index_equal(idx</span><span class="s0">, </span><span class="s1">index_cls(idx_view</span><span class="s0">, </span><span class="s1">name=</span><span class="s3">&quot;Foo&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">exact=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_format(self</span><span class="s0">, </span><span class="s1">simple_index):</span>
        <span class="s4"># GH35439</span>
        <span class="s0">if </span><span class="s1">isinstance(simple_index</span><span class="s0">, </span><span class="s1">DatetimeIndex):</span>
            <span class="s1">pytest.skip(</span><span class="s3">&quot;Tested elsewhere&quot;</span><span class="s1">)</span>
        <span class="s1">idx = simple_index</span>
        <span class="s1">max_width = max(len(str(x)) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">idx)</span>
        <span class="s1">expected = [str(x).ljust(max_width) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">idx]</span>
        <span class="s0">assert </span><span class="s1">idx.format() == expected</span>

    <span class="s0">def </span><span class="s1">test_insert_non_na(self</span><span class="s0">, </span><span class="s1">simple_index):</span>
        <span class="s4"># GH#43921 inserting an element that we know we can hold should</span>
        <span class="s4">#  not change dtype or type (except for RangeIndex)</span>
        <span class="s1">index = simple_index</span>

        <span class="s1">result = index.insert(</span><span class="s2">0</span><span class="s0">, </span><span class="s1">index[</span><span class="s2">0</span><span class="s1">])</span>

        <span class="s1">expected = Index([index[</span><span class="s2">0</span><span class="s1">]] + list(index)</span><span class="s0">, </span><span class="s1">dtype=index.dtype)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">exact=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_insert_na(self</span><span class="s0">, </span><span class="s1">nulls_fixture</span><span class="s0">, </span><span class="s1">simple_index):</span>
        <span class="s4"># GH 18295 (test missing)</span>
        <span class="s1">index = simple_index</span>
        <span class="s1">na_val = nulls_fixture</span>

        <span class="s0">if </span><span class="s1">na_val </span><span class="s0">is </span><span class="s1">pd.NaT:</span>
            <span class="s1">expected = Index([index[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">pd.NaT] + list(index[</span><span class="s2">1</span><span class="s1">:])</span><span class="s0">, </span><span class="s1">dtype=object)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">expected = Index([index[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.nan] + list(index[</span><span class="s2">1</span><span class="s1">:]))</span>
            <span class="s4"># GH#43921 we preserve float dtype</span>
            <span class="s0">if </span><span class="s1">index.dtype.kind == </span><span class="s3">&quot;f&quot;</span><span class="s1">:</span>
                <span class="s1">expected = Index(expected</span><span class="s0">, </span><span class="s1">dtype=index.dtype)</span>

        <span class="s1">result = index.insert(</span><span class="s2">1</span><span class="s0">, </span><span class="s1">na_val)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">exact=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_arithmetic_explicit_conversions(self</span><span class="s0">, </span><span class="s1">simple_index):</span>
        <span class="s4"># GH 8608</span>
        <span class="s4"># add/sub are overridden explicitly for Float/Int Index</span>
        <span class="s1">index_cls = type(simple_index)</span>
        <span class="s0">if </span><span class="s1">index_cls </span><span class="s0">is </span><span class="s1">RangeIndex:</span>
            <span class="s1">idx = RangeIndex(</span><span class="s2">5</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">idx = index_cls(np.arange(</span><span class="s2">5</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s3">&quot;int64&quot;</span><span class="s1">))</span>

        <span class="s4"># float conversions</span>
        <span class="s1">arr = np.arange(</span><span class="s2">5</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s3">&quot;int64&quot;</span><span class="s1">) * </span><span class="s2">3.2</span>
        <span class="s1">expected = Index(arr</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s1">fidx = idx * </span><span class="s2">3.2</span>
        <span class="s1">tm.assert_index_equal(fidx</span><span class="s0">, </span><span class="s1">expected)</span>
        <span class="s1">fidx = </span><span class="s2">3.2 </span><span class="s1">* idx</span>
        <span class="s1">tm.assert_index_equal(fidx</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s4"># interops with numpy arrays</span>
        <span class="s1">expected = Index(arr</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s1">a = np.zeros(</span><span class="s2">5</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s3">&quot;float64&quot;</span><span class="s1">)</span>
        <span class="s1">result = fidx - a</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">expected = Index(-arr</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s1">a = np.zeros(</span><span class="s2">5</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s3">&quot;float64&quot;</span><span class="s1">)</span>
        <span class="s1">result = a - fidx</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;complex_dtype&quot;</span><span class="s0">, </span><span class="s1">[np.complex64</span><span class="s0">, </span><span class="s1">np.complex128])</span>
    <span class="s0">def </span><span class="s1">test_astype_to_complex(self</span><span class="s0">, </span><span class="s1">complex_dtype</span><span class="s0">, </span><span class="s1">simple_index):</span>
        <span class="s1">result = simple_index.astype(complex_dtype)</span>

        <span class="s0">assert </span><span class="s1">type(result) </span><span class="s0">is </span><span class="s1">Index </span><span class="s0">and </span><span class="s1">result.dtype == complex_dtype</span>

    <span class="s0">def </span><span class="s1">test_cast_string(self</span><span class="s0">, </span><span class="s1">simple_index):</span>
        <span class="s0">if </span><span class="s1">isinstance(simple_index</span><span class="s0">, </span><span class="s1">RangeIndex):</span>
            <span class="s1">pytest.skip(</span><span class="s3">&quot;casting of strings not relevant for RangeIndex&quot;</span><span class="s1">)</span>
        <span class="s1">result = type(simple_index)([</span><span class="s3">&quot;0&quot;</span><span class="s0">, </span><span class="s3">&quot;1&quot;</span><span class="s0">, </span><span class="s3">&quot;2&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=simple_index.dtype)</span>
        <span class="s1">expected = type(simple_index)([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=simple_index.dtype)</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>
</pre>
</body>
</html>