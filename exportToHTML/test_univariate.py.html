<html>
<head>
<title>test_univariate.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_univariate.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Tests for univariate treatment of multivariate models 
 
TODO skips the tests for measurement disturbance and measurement disturbance 
covariance, which do not pass. The univariate smoother *appears* to be 
correctly implemented against Durbin and Koopman (2012) chapter 6, yet still 
gives a different answer from the conventional smoother. It's not clear if 
this is intended (i.e. it has to be at least slightly different, since the 
conventional smoother can return a non-diagonal covariance matrix whereas the 
univariate smoother must return a diagonal covariance matrix). 
 
Author: Chad Fulton 
License: Simplified-BSD 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">os</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">numpy.testing </span><span class="s2">import </span><span class="s1">assert_almost_equal</span><span class="s2">, </span><span class="s1">assert_allclose</span>
<span class="s2">import </span><span class="s1">pandas </span><span class="s2">as </span><span class="s1">pd</span>
<span class="s2">import </span><span class="s1">pytest</span>

<span class="s2">from </span><span class="s1">statsmodels </span><span class="s2">import </span><span class="s1">datasets</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.statespace.mlemodel </span><span class="s2">import </span><span class="s1">MLEModel</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.statespace.tests.results </span><span class="s2">import </span><span class="s1">results_kalman_filter</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.statespace.sarimax </span><span class="s2">import </span><span class="s1">SARIMAX</span>

<span class="s1">current_path = os.path.dirname(os.path.abspath(__file__))</span>


<span class="s2">class </span><span class="s1">TestClark1989:</span>
    <span class="s0">&quot;&quot;&quot; 
    Clark's (1989) bivariate unobserved components model of real GDP (as 
    presented in Kim and Nelson, 1999) 
 
    Tests two-dimensional observation data. 
 
    Test data produced using GAUSS code described in Kim and Nelson (1999) and 
    found at http://econ.korea.ac.kr/~cjkim/SSMARKOV.htm 
 
    See `results.results_kalman_filter` for more information. 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">dtype=float</span><span class="s2">, </span><span class="s1">alternate_timing=</span><span class="s2">False, </span><span class="s1">**kwargs):</span>

        <span class="s1">cls.true = results_kalman_filter.uc_bi</span>
        <span class="s1">cls.true_states = pd.DataFrame(cls.true[</span><span class="s3">'states'</span><span class="s1">])</span>

        <span class="s4"># GDP and Unemployment, Quarterly, 1948.1 - 1995.3</span>
        <span class="s1">data = pd.DataFrame(</span>
            <span class="s1">cls.true[</span><span class="s3">'data'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">index=pd.date_range(</span><span class="s3">'1947-01-01'</span><span class="s2">, </span><span class="s3">'1995-07-01'</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">'QS'</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">columns=[</span><span class="s3">'GDP'</span><span class="s2">, </span><span class="s3">'UNEMP'</span><span class="s1">]</span>
        <span class="s1">)[</span><span class="s5">4</span><span class="s1">:]</span>
        <span class="s1">data[</span><span class="s3">'GDP'</span><span class="s1">] = np.log(data[</span><span class="s3">'GDP'</span><span class="s1">])</span>
        <span class="s1">data[</span><span class="s3">'UNEMP'</span><span class="s1">] = (data[</span><span class="s3">'UNEMP'</span><span class="s1">]/</span><span class="s5">100</span><span class="s1">)</span>

        <span class="s1">k_states = </span><span class="s5">6</span>
        <span class="s1">cls.mlemodel = MLEModel(data</span><span class="s2">, </span><span class="s1">k_states=k_states</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">cls.model = cls.mlemodel.ssm</span>

        <span class="s4"># Statespace representation</span>
        <span class="s1">cls.model.design[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] = [[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]]</span>
        <span class="s1">cls.model.transition[</span>
            <span class="s1">([</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s5">5</span><span class="s1">]</span><span class="s2">,</span>
             <span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s5">5</span><span class="s1">]</span><span class="s2">,</span>
             <span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">])</span>
        <span class="s1">] = [</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">cls.model.selection = np.eye(cls.model.k_states)</span>

        <span class="s4"># Update matrices with given parameters</span>
        <span class="s1">(sigma_v</span><span class="s2">, </span><span class="s1">sigma_e</span><span class="s2">, </span><span class="s1">sigma_w</span><span class="s2">, </span><span class="s1">sigma_vl</span><span class="s2">, </span><span class="s1">sigma_ec</span><span class="s2">,</span>
         <span class="s1">phi_1</span><span class="s2">, </span><span class="s1">phi_2</span><span class="s2">, </span><span class="s1">alpha_1</span><span class="s2">, </span><span class="s1">alpha_2</span><span class="s2">, </span><span class="s1">alpha_3) = np.array(</span>
            <span class="s1">cls.true[</span><span class="s3">'parameters'</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">cls.model.design[([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">])] = [</span>
            <span class="s1">alpha_1</span><span class="s2">, </span><span class="s1">alpha_2</span><span class="s2">, </span><span class="s1">alpha_3</span>
        <span class="s1">]</span>
        <span class="s1">cls.model.transition[([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">])] = [phi_1</span><span class="s2">, </span><span class="s1">phi_2]</span>
        <span class="s1">cls.model.obs_cov[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] = sigma_ec**</span><span class="s5">2</span>
        <span class="s1">cls.model.state_cov[</span>
            <span class="s1">np.diag_indices(k_states)+(np.zeros(k_states</span><span class="s2">, </span><span class="s1">dtype=int)</span><span class="s2">,</span><span class="s1">)] = [</span>
            <span class="s1">sigma_v**</span><span class="s5">2</span><span class="s2">, </span><span class="s1">sigma_e**</span><span class="s5">2</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">sigma_w**</span><span class="s5">2</span><span class="s2">, </span><span class="s1">sigma_vl**</span><span class="s5">2</span>
        <span class="s1">]</span>

        <span class="s4"># Initialization</span>
        <span class="s1">initial_state = np.zeros((k_states</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s1">initial_state_cov = np.eye(k_states)*</span><span class="s5">100</span>

        <span class="s4"># Initialization: cls.modification</span>
        <span class="s2">if not </span><span class="s1">alternate_timing:</span>
            <span class="s1">initial_state_cov = np.dot(</span>
                <span class="s1">np.dot(cls.model.transition[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">initial_state_cov)</span><span class="s2">,</span>
                <span class="s1">cls.model.transition[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">].T</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">cls.model.timing_init_filtered = </span><span class="s2">True</span>
        <span class="s1">cls.model.initialize_known(initial_state</span><span class="s2">, </span><span class="s1">initial_state_cov)</span>

        <span class="s4"># Conventional filtering, smoothing, and simulation smoothing</span>
        <span class="s1">cls.model.filter_conventional = </span><span class="s2">True</span>
        <span class="s1">cls.conventional_results = cls.model.smooth()</span>
        <span class="s1">n_disturbance_variates = (</span>
            <span class="s1">(cls.model.k_endog + cls.model.k_posdef) * cls.model.nobs</span>
        <span class="s1">)</span>
        <span class="s1">cls.conventional_sim = cls.model.simulation_smoother(</span>
            <span class="s1">disturbance_variates=np.zeros(n_disturbance_variates)</span><span class="s2">,</span>
            <span class="s1">initial_state_variates=np.zeros(cls.model.k_states)</span>
        <span class="s1">)</span>

        <span class="s4"># Univariate filtering, smoothing, and simulation smoothing</span>
        <span class="s1">cls.model.filter_univariate = </span><span class="s2">True</span>
        <span class="s1">cls.univariate_results = cls.model.smooth()</span>
        <span class="s1">cls.univariate_sim = cls.model.simulation_smoother(</span>
            <span class="s1">disturbance_variates=np.zeros(n_disturbance_variates)</span><span class="s2">,</span>
            <span class="s1">initial_state_variates=np.zeros(cls.model.k_states)</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_using_univariate(self):</span>
        <span class="s4"># Regression test to make sure the univariate_results actually</span>
        <span class="s4"># used the univariate Kalman filtering approach (i.e. that the flag</span>
        <span class="s4"># being set actually caused the filter to not use the conventional</span>
        <span class="s4"># filter)</span>
        <span class="s2">assert not </span><span class="s1">self.conventional_results.filter_univariate</span>
        <span class="s2">assert </span><span class="s1">self.univariate_results.filter_univariate</span>

        <span class="s1">assert_allclose(</span>
            <span class="s1">self.conventional_results.forecasts_error_cov[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s5">143.03724478030821</span>
        <span class="s1">)</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.univariate_results.forecasts_error_cov[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s5">120.66208525029386</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_forecasts(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.conventional_results.forecasts[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">,</span>
            <span class="s1">self.univariate_results.forecasts[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">, </span><span class="s5">9</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_forecasts_error(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.conventional_results.forecasts_error[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">,</span>
            <span class="s1">self.univariate_results.forecasts_error[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">, </span><span class="s5">9</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_forecasts_error_cov(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.conventional_results.forecasts_error_cov[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">,</span>
            <span class="s1">self.univariate_results.forecasts_error_cov[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">, </span><span class="s5">9</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_filtered_state(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.conventional_results.filtered_state</span><span class="s2">,</span>
            <span class="s1">self.univariate_results.filtered_state</span><span class="s2">, </span><span class="s5">8</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_filtered_state_cov(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.conventional_results.filtered_state_cov</span><span class="s2">,</span>
            <span class="s1">self.univariate_results.filtered_state_cov</span><span class="s2">, </span><span class="s5">9</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_predicted_state(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.conventional_results.predicted_state</span><span class="s2">,</span>
            <span class="s1">self.univariate_results.predicted_state</span><span class="s2">, </span><span class="s5">8</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_predicted_state_cov(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.conventional_results.predicted_state_cov</span><span class="s2">,</span>
            <span class="s1">self.univariate_results.predicted_state_cov</span><span class="s2">, </span><span class="s5">9</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_loglike(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.conventional_results.llf_obs</span><span class="s2">,</span>
            <span class="s1">self.univariate_results.llf_obs</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_smoothed_states(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.conventional_results.smoothed_state</span><span class="s2">,</span>
            <span class="s1">self.univariate_results.smoothed_state</span><span class="s2">, </span><span class="s5">7</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_smoothed_states_cov(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.conventional_results.smoothed_state_cov</span><span class="s2">,</span>
            <span class="s1">self.univariate_results.smoothed_state_cov</span><span class="s2">, </span><span class="s5">6</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_smoothed_measurement_disturbance(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.conventional_results.smoothed_measurement_disturbance</span><span class="s2">,</span>
            <span class="s1">self.univariate_results.smoothed_measurement_disturbance</span><span class="s2">, </span><span class="s5">9</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_smoothed_measurement_disturbance_cov(self):</span>
        <span class="s1">conv = self.conventional_results</span>
        <span class="s1">univ = self.univariate_results</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">conv.smoothed_measurement_disturbance_cov.diagonal()</span><span class="s2">,</span>
            <span class="s1">univ.smoothed_measurement_disturbance_cov.diagonal()</span><span class="s2">, </span><span class="s5">9</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_smoothed_state_disturbance(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.conventional_results.smoothed_state_disturbance</span><span class="s2">,</span>
            <span class="s1">self.univariate_results.smoothed_state_disturbance</span><span class="s2">,</span>
            <span class="s1">atol=</span><span class="s5">1e-7</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_smoothed_state_disturbance_cov(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.conventional_results.smoothed_state_disturbance_cov</span><span class="s2">,</span>
            <span class="s1">self.univariate_results.smoothed_state_disturbance_cov</span><span class="s2">, </span><span class="s5">9</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_simulation_smoothed_state(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.conventional_sim.simulated_state</span><span class="s2">,</span>
            <span class="s1">self.univariate_sim.simulated_state</span><span class="s2">, </span><span class="s5">9</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_simulation_smoothed_measurement_disturbance(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.conventional_sim.simulated_measurement_disturbance</span><span class="s2">,</span>
            <span class="s1">self.univariate_sim.simulated_measurement_disturbance</span><span class="s2">, </span><span class="s5">9</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_simulation_smoothed_state_disturbance(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.conventional_sim.simulated_state_disturbance</span><span class="s2">,</span>
            <span class="s1">self.univariate_sim.simulated_state_disturbance</span><span class="s2">, </span><span class="s5">9</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestClark1989Alternate(TestClark1989):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super(TestClark1989Alternate</span><span class="s2">, </span><span class="s1">cls).setup_class(alternate_timing=</span><span class="s2">True,</span>
                                                       <span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">test_using_alterate(self):</span>
        <span class="s2">assert </span><span class="s1">self.model._kalman_filter.filter_timing == </span><span class="s5">1</span>


<span class="s2">class </span><span class="s1">MultivariateMissingGeneralObsCov:</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">which</span><span class="s2">, </span><span class="s1">dtype=float</span><span class="s2">, </span><span class="s1">alternate_timing=</span><span class="s2">False, </span><span class="s1">**kwargs):</span>
        <span class="s4"># Results</span>
        <span class="s1">path = os.path.join(current_path</span><span class="s2">, </span><span class="s3">'results'</span><span class="s2">,</span>
                            <span class="s3">'results_smoothing_generalobscov_R.csv'</span><span class="s1">)</span>
        <span class="s1">cls.desired = pd.read_csv(path)</span>

        <span class="s4"># Data</span>
        <span class="s1">dta = datasets.macrodata.load_pandas().data</span>
        <span class="s1">dta.index = pd.date_range(start=</span><span class="s3">'1959-01-01'</span><span class="s2">,</span>
                                  <span class="s1">end=</span><span class="s3">'2009-7-01'</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">'QS'</span><span class="s1">)</span>
        <span class="s1">obs = dta[[</span><span class="s3">'realgdp'</span><span class="s2">, </span><span class="s3">'realcons'</span><span class="s2">, </span><span class="s3">'realinv'</span><span class="s1">]].diff().iloc[</span><span class="s5">1</span><span class="s1">:]</span>

        <span class="s2">if </span><span class="s1">which == </span><span class="s3">'all'</span><span class="s1">:</span>
            <span class="s1">obs.iloc[:</span><span class="s5">50</span><span class="s2">, </span><span class="s1">:] = np.nan</span>
            <span class="s1">obs.iloc[</span><span class="s5">119</span><span class="s1">:</span><span class="s5">130</span><span class="s2">, </span><span class="s1">:] = np.nan</span>
        <span class="s2">elif </span><span class="s1">which == </span><span class="s3">'partial'</span><span class="s1">:</span>
            <span class="s1">obs.iloc[</span><span class="s5">0</span><span class="s1">:</span><span class="s5">50</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] = np.nan</span>
            <span class="s1">obs.iloc[</span><span class="s5">119</span><span class="s1">:</span><span class="s5">130</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] = np.nan</span>
        <span class="s2">elif </span><span class="s1">which == </span><span class="s3">'mixed'</span><span class="s1">:</span>
            <span class="s1">obs.iloc[</span><span class="s5">0</span><span class="s1">:</span><span class="s5">50</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] = np.nan</span>
            <span class="s1">obs.iloc[</span><span class="s5">19</span><span class="s1">:</span><span class="s5">70</span><span class="s2">, </span><span class="s5">1</span><span class="s1">] = np.nan</span>
            <span class="s1">obs.iloc[</span><span class="s5">39</span><span class="s1">:</span><span class="s5">90</span><span class="s2">, </span><span class="s5">2</span><span class="s1">] = np.nan</span>
            <span class="s1">obs.iloc[</span><span class="s5">119</span><span class="s1">:</span><span class="s5">130</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] = np.nan</span>
            <span class="s1">obs.iloc[</span><span class="s5">119</span><span class="s1">:</span><span class="s5">130</span><span class="s2">, </span><span class="s5">2</span><span class="s1">] = np.nan</span>

        <span class="s4"># Create the model</span>
        <span class="s1">mod = MLEModel(obs</span><span class="s2">, </span><span class="s1">k_states=</span><span class="s5">3</span><span class="s2">, </span><span class="s1">k_posdef=</span><span class="s5">3</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">mod[</span><span class="s3">'design'</span><span class="s1">] = np.eye(</span><span class="s5">3</span><span class="s1">)</span>
        <span class="s1">X = (np.arange(</span><span class="s5">9</span><span class="s1">) + </span><span class="s5">1</span><span class="s1">).reshape((</span><span class="s5">3</span><span class="s2">, </span><span class="s5">3</span><span class="s1">)) / </span><span class="s5">10.</span>
        <span class="s1">mod[</span><span class="s3">'obs_cov'</span><span class="s1">] = np.dot(X</span><span class="s2">, </span><span class="s1">X.T)</span>
        <span class="s1">mod[</span><span class="s3">'transition'</span><span class="s1">] = np.eye(</span><span class="s5">3</span><span class="s1">)</span>
        <span class="s1">mod[</span><span class="s3">'selection'</span><span class="s1">] = np.eye(</span><span class="s5">3</span><span class="s1">)</span>
        <span class="s1">mod[</span><span class="s3">'state_cov'</span><span class="s1">] = np.eye(</span><span class="s5">3</span><span class="s1">)</span>
        <span class="s1">mod.initialize_approximate_diffuse(</span><span class="s5">1e6</span><span class="s1">)</span>
        <span class="s1">cls.model = mod.ssm</span>

        <span class="s4"># Conventional filtering, smoothing, and simulation smoothing</span>
        <span class="s1">cls.model.filter_conventional = </span><span class="s2">True</span>
        <span class="s1">cls.conventional_results = cls.model.smooth()</span>
        <span class="s1">n_disturbance_variates = (</span>
            <span class="s1">(cls.model.k_endog + cls.model.k_posdef) * cls.model.nobs</span>
        <span class="s1">)</span>
        <span class="s1">cls.conventional_sim = cls.model.simulation_smoother(</span>
            <span class="s1">disturbance_variates=np.zeros(n_disturbance_variates)</span><span class="s2">,</span>
            <span class="s1">initial_state_variates=np.zeros(cls.model.k_states)</span>
        <span class="s1">)</span>

        <span class="s4"># Univariate filtering, smoothing, and simulation smoothing</span>
        <span class="s1">cls.model.filter_univariate = </span><span class="s2">True</span>
        <span class="s1">cls.univariate_results = cls.model.smooth()</span>
        <span class="s1">cls.univariate_sim = cls.model.simulation_smoother(</span>
            <span class="s1">disturbance_variates=np.zeros(n_disturbance_variates)</span><span class="s2">,</span>
            <span class="s1">initial_state_variates=np.zeros(cls.model.k_states)</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_using_univariate(self):</span>
        <span class="s4"># Regression test to make sure the univariate_results actually</span>
        <span class="s4"># used the univariate Kalman filtering approach (i.e. that the flag</span>
        <span class="s4"># being set actually caused the filter to not use the conventional</span>
        <span class="s4"># filter)</span>
        <span class="s2">assert not </span><span class="s1">self.conventional_results.filter_univariate</span>
        <span class="s2">assert </span><span class="s1">self.univariate_results.filter_univariate</span>

        <span class="s1">assert_allclose(</span>
            <span class="s1">self.conventional_results.forecasts_error_cov[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s5">1000000.77</span>
        <span class="s1">)</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.univariate_results.forecasts_error_cov[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s5">1000000.77</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_forecasts(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.conventional_results.forecasts[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">,</span>
            <span class="s1">self.univariate_results.forecasts[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">, </span><span class="s5">9</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_forecasts_error(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.conventional_results.forecasts_error[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">,</span>
            <span class="s1">self.univariate_results.forecasts_error[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">, </span><span class="s5">9</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_forecasts_error_cov(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.conventional_results.forecasts_error_cov[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">,</span>
            <span class="s1">self.univariate_results.forecasts_error_cov[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">, </span><span class="s5">9</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_filtered_state(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.conventional_results.filtered_state</span><span class="s2">,</span>
            <span class="s1">self.univariate_results.filtered_state</span><span class="s2">, </span><span class="s5">8</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_filtered_state_cov(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.conventional_results.filtered_state_cov</span><span class="s2">,</span>
            <span class="s1">self.univariate_results.filtered_state_cov</span><span class="s2">, </span><span class="s5">9</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_predicted_state(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.conventional_results.predicted_state</span><span class="s2">,</span>
            <span class="s1">self.univariate_results.predicted_state</span><span class="s2">, </span><span class="s5">8</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_predicted_state_cov(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.conventional_results.predicted_state_cov</span><span class="s2">,</span>
            <span class="s1">self.univariate_results.predicted_state_cov</span><span class="s2">, </span><span class="s5">9</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_loglike(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.conventional_results.llf_obs</span><span class="s2">,</span>
            <span class="s1">self.univariate_results.llf_obs</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_smoothed_states(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.conventional_results.smoothed_state</span><span class="s2">,</span>
            <span class="s1">self.univariate_results.smoothed_state</span><span class="s2">, </span><span class="s5">7</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_smoothed_states_cov(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.conventional_results.smoothed_state_cov</span><span class="s2">,</span>
            <span class="s1">self.univariate_results.smoothed_state_cov</span><span class="s2">, </span><span class="s5">6</span>
        <span class="s1">)</span>

    <span class="s1">@pytest.mark.skip</span>
    <span class="s2">def </span><span class="s1">test_smoothed_measurement_disturbance(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.conventional_results.smoothed_measurement_disturbance</span><span class="s2">,</span>
            <span class="s1">self.univariate_results.smoothed_measurement_disturbance</span><span class="s2">, </span><span class="s5">9</span>
        <span class="s1">)</span>

    <span class="s1">@pytest.mark.skip</span>
    <span class="s2">def </span><span class="s1">test_smoothed_measurement_disturbance_cov(self):</span>
        <span class="s1">conv = self.conventional_results</span>
        <span class="s1">univ = self.univariate_results</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">conv.smoothed_measurement_disturbance_cov.diagonal()</span><span class="s2">,</span>
            <span class="s1">univ.smoothed_measurement_disturbance_cov.diagonal()</span><span class="s2">, </span><span class="s5">9</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_smoothed_state_disturbance(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.conventional_results.smoothed_state_disturbance</span><span class="s2">,</span>
            <span class="s1">self.univariate_results.smoothed_state_disturbance</span><span class="s2">,</span>
            <span class="s1">atol=</span><span class="s5">1e-7</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_smoothed_state_disturbance_cov(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.conventional_results.smoothed_state_disturbance_cov</span><span class="s2">,</span>
            <span class="s1">self.univariate_results.smoothed_state_disturbance_cov</span><span class="s2">, </span><span class="s5">9</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_simulation_smoothed_state(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.conventional_sim.simulated_state</span><span class="s2">,</span>
            <span class="s1">self.univariate_sim.simulated_state</span><span class="s2">, </span><span class="s5">9</span>
        <span class="s1">)</span>

    <span class="s1">@pytest.mark.skip</span>
    <span class="s2">def </span><span class="s1">test_simulation_smoothed_measurement_disturbance(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.conventional_sim.simulated_measurement_disturbance</span><span class="s2">,</span>
            <span class="s1">self.univariate_sim.simulated_measurement_disturbance</span><span class="s2">, </span><span class="s5">9</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_simulation_smoothed_state_disturbance(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.conventional_sim.simulated_state_disturbance</span><span class="s2">,</span>
            <span class="s1">self.univariate_sim.simulated_state_disturbance</span><span class="s2">, </span><span class="s5">9</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestMultivariateGeneralObsCov(MultivariateMissingGeneralObsCov):</span>
    <span class="s0">&quot;&quot;&quot; 
    This class tests the univariate method when the observation covariance 
    matrix is not diagonal and all data is available. 
 
    Tests are against the conventional smoother. 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super(TestMultivariateGeneralObsCov</span><span class="s2">, </span><span class="s1">cls).setup_class(</span><span class="s3">'none'</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestMultivariateAllMissingGeneralObsCov(</span>
        <span class="s1">MultivariateMissingGeneralObsCov):</span>
    <span class="s0">&quot;&quot;&quot; 
    This class tests the univariate method when the observation covariance 
    matrix is not diagonal and there are cases of fully missing data only. 
 
    Tests are against the conventional smoother. 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super(TestMultivariateAllMissingGeneralObsCov</span><span class="s2">, </span><span class="s1">cls).setup_class(</span><span class="s3">'all'</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestMultivariatePartialMissingGeneralObsCov(</span>
        <span class="s1">MultivariateMissingGeneralObsCov):</span>
    <span class="s0">&quot;&quot;&quot; 
    This class tests the univariate method when the observation covariance 
    matrix is not diagonal and there are cases of partially missing data only. 
 
    Tests are against the conventional smoother. 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super(TestMultivariatePartialMissingGeneralObsCov</span><span class="s2">,</span>
              <span class="s1">cls).setup_class(</span><span class="s3">'partial'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_forecasts(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.conventional_results.forecasts[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">,</span>
            <span class="s1">self.univariate_results.forecasts[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">, </span><span class="s5">8</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_forecasts_error(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.conventional_results.forecasts_error[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">,</span>
            <span class="s1">self.univariate_results.forecasts_error[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">, </span><span class="s5">8</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestMultivariateMixedMissingGeneralObsCov(</span>
        <span class="s1">MultivariateMissingGeneralObsCov):</span>
    <span class="s0">&quot;&quot;&quot; 
    This class tests the univariate method when the observation covariance 
    matrix is not diagonal and there are cases of both partially missing and 
    fully missing data. 
 
    Tests are against the conventional smoother. 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super(TestMultivariateMixedMissingGeneralObsCov</span><span class="s2">,</span>
              <span class="s1">cls).setup_class(</span><span class="s3">'mixed'</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_forecasts(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.conventional_results.forecasts[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">,</span>
            <span class="s1">self.univariate_results.forecasts[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">, </span><span class="s5">8</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_forecasts_error(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.conventional_results.forecasts_error[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">,</span>
            <span class="s1">self.univariate_results.forecasts_error[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">, </span><span class="s5">8</span>
        <span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestMultivariateVAR:</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">which=</span><span class="s3">'none'</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s4"># Results</span>
        <span class="s1">path = os.path.join(current_path</span><span class="s2">, </span><span class="s3">'results'</span><span class="s2">,</span>
                            <span class="s3">'results_smoothing_generalobscov_R.csv'</span><span class="s1">)</span>
        <span class="s1">cls.desired = pd.read_csv(path)</span>

        <span class="s4"># Data</span>
        <span class="s1">dta = datasets.macrodata.load_pandas().data</span>
        <span class="s1">dta.index = pd.date_range(start=</span><span class="s3">'1959-01-01'</span><span class="s2">,</span>
                                  <span class="s1">end=</span><span class="s3">'2009-7-01'</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">'QS'</span><span class="s1">)</span>
        <span class="s1">obs = dta[[</span><span class="s3">'realgdp'</span><span class="s2">, </span><span class="s3">'realcons'</span><span class="s2">, </span><span class="s3">'realinv'</span><span class="s1">]].diff().iloc[</span><span class="s5">1</span><span class="s1">:]</span>

        <span class="s2">if </span><span class="s1">which == </span><span class="s3">'all'</span><span class="s1">:</span>
            <span class="s1">obs.iloc[:</span><span class="s5">50</span><span class="s2">, </span><span class="s1">:] = np.nan</span>
            <span class="s1">obs.iloc[</span><span class="s5">119</span><span class="s1">:</span><span class="s5">130</span><span class="s2">, </span><span class="s1">:] = np.nan</span>
        <span class="s2">elif </span><span class="s1">which == </span><span class="s3">'partial'</span><span class="s1">:</span>
            <span class="s1">obs.iloc[</span><span class="s5">0</span><span class="s1">:</span><span class="s5">50</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] = np.nan</span>
            <span class="s1">obs.iloc[</span><span class="s5">119</span><span class="s1">:</span><span class="s5">130</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] = np.nan</span>
        <span class="s2">elif </span><span class="s1">which == </span><span class="s3">'mixed'</span><span class="s1">:</span>
            <span class="s1">obs.iloc[</span><span class="s5">0</span><span class="s1">:</span><span class="s5">50</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] = np.nan</span>
            <span class="s1">obs.iloc[</span><span class="s5">19</span><span class="s1">:</span><span class="s5">70</span><span class="s2">, </span><span class="s5">1</span><span class="s1">] = np.nan</span>
            <span class="s1">obs.iloc[</span><span class="s5">39</span><span class="s1">:</span><span class="s5">90</span><span class="s2">, </span><span class="s5">2</span><span class="s1">] = np.nan</span>
            <span class="s1">obs.iloc[</span><span class="s5">119</span><span class="s1">:</span><span class="s5">130</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] = np.nan</span>
            <span class="s1">obs.iloc[</span><span class="s5">119</span><span class="s1">:</span><span class="s5">130</span><span class="s2">, </span><span class="s5">2</span><span class="s1">] = np.nan</span>

        <span class="s4"># Create the model</span>
        <span class="s1">mod = MLEModel(obs</span><span class="s2">, </span><span class="s1">k_states=</span><span class="s5">3</span><span class="s2">, </span><span class="s1">k_posdef=</span><span class="s5">3</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">mod[</span><span class="s3">'design'</span><span class="s1">] = np.eye(</span><span class="s5">3</span><span class="s1">)</span>
        <span class="s1">mod[</span><span class="s3">'obs_cov'</span><span class="s1">] = np.array([</span>
            <span class="s1">[</span><span class="s5">609.0746647855</span><span class="s2">,    </span><span class="s5">0.</span><span class="s2">,              </span><span class="s5">0.</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s5">0.</span><span class="s2">,                </span><span class="s5">1.8774916622</span><span class="s2">,    </span><span class="s5">0.</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s5">0.</span><span class="s2">,                </span><span class="s5">0.</span><span class="s2">,            </span><span class="s5">124.6768281675</span><span class="s1">]])</span>
        <span class="s1">mod[</span><span class="s3">'transition'</span><span class="s1">] = np.array([</span>
            <span class="s1">[-</span><span class="s5">0.8110473405</span><span class="s2">,  </span><span class="s5">1.8005304445</span><span class="s2">,  </span><span class="s5">1.0215975772</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[-</span><span class="s5">1.9846632699</span><span class="s2">,  </span><span class="s5">2.4091302213</span><span class="s2">,  </span><span class="s5">1.9264449765</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s5">0.9181658823</span><span class="s2">,  </span><span class="s1">-</span><span class="s5">0.2442384581</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.6393462272</span><span class="s1">]])</span>
        <span class="s1">mod[</span><span class="s3">'selection'</span><span class="s1">] = np.eye(</span><span class="s5">3</span><span class="s1">)</span>
        <span class="s1">mod[</span><span class="s3">'state_cov'</span><span class="s1">] = np.array([</span>
            <span class="s1">[</span><span class="s5">1552.9758843938</span><span class="s2">,   </span><span class="s5">612.7185121905</span><span class="s2">,   </span><span class="s5">877.6157204992</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s5">612.7185121905</span><span class="s2">,    </span><span class="s5">467.8739411204</span><span class="s2">,    </span><span class="s5">70.608037339</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s5">877.6157204992</span><span class="s2">,     </span><span class="s5">70.608037339</span><span class="s2">,    </span><span class="s5">900.5440385836</span><span class="s1">]])</span>
        <span class="s1">mod.initialize_approximate_diffuse(</span><span class="s5">1e6</span><span class="s1">)</span>
        <span class="s1">cls.model = mod.ssm</span>

        <span class="s4"># Conventional filtering, smoothing, and simulation smoothing</span>
        <span class="s1">cls.model.filter_conventional = </span><span class="s2">True</span>
        <span class="s1">cls.conventional_results = cls.model.smooth()</span>
        <span class="s1">n_disturbance_variates = (</span>
            <span class="s1">(cls.model.k_endog + cls.model.k_posdef) * cls.model.nobs</span>
        <span class="s1">)</span>
        <span class="s1">cls.conventional_sim = cls.model.simulation_smoother(</span>
            <span class="s1">disturbance_variates=np.zeros(n_disturbance_variates)</span><span class="s2">,</span>
            <span class="s1">initial_state_variates=np.zeros(cls.model.k_states)</span>
        <span class="s1">)</span>

        <span class="s4"># Univariate filtering, smoothing, and simulation smoothing</span>
        <span class="s1">cls.model.filter_univariate = </span><span class="s2">True</span>
        <span class="s1">cls.univariate_results = cls.model.smooth()</span>
        <span class="s1">cls.univariate_sim = cls.model.simulation_smoother(</span>
            <span class="s1">disturbance_variates=np.zeros(n_disturbance_variates)</span><span class="s2">,</span>
            <span class="s1">initial_state_variates=np.zeros(cls.model.k_states)</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_forecasts(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.conventional_results.forecasts[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">,</span>
            <span class="s1">self.univariate_results.forecasts[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">, </span><span class="s5">9</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_forecasts_error(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.conventional_results.forecasts_error[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">,</span>
            <span class="s1">self.univariate_results.forecasts_error[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">, </span><span class="s5">9</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_forecasts_error_cov(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.conventional_results.forecasts_error_cov[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">,</span>
            <span class="s1">self.univariate_results.forecasts_error_cov[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">, </span><span class="s5">9</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_filtered_state(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.conventional_results.filtered_state</span><span class="s2">,</span>
            <span class="s1">self.univariate_results.filtered_state</span><span class="s2">, </span><span class="s5">8</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_filtered_state_cov(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.conventional_results.filtered_state_cov</span><span class="s2">,</span>
            <span class="s1">self.univariate_results.filtered_state_cov</span><span class="s2">, </span><span class="s5">9</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_predicted_state(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.conventional_results.predicted_state</span><span class="s2">,</span>
            <span class="s1">self.univariate_results.predicted_state</span><span class="s2">, </span><span class="s5">8</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_predicted_state_cov(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.conventional_results.predicted_state_cov</span><span class="s2">,</span>
            <span class="s1">self.univariate_results.predicted_state_cov</span><span class="s2">, </span><span class="s5">9</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_loglike(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.conventional_results.llf_obs</span><span class="s2">,</span>
            <span class="s1">self.univariate_results.llf_obs</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_smoothed_states(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.conventional_results.smoothed_state</span><span class="s2">,</span>
            <span class="s1">self.univariate_results.smoothed_state</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_smoothed_states_cov(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.conventional_results.smoothed_state_cov</span><span class="s2">,</span>
            <span class="s1">self.univariate_results.smoothed_state_cov</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-9</span>
        <span class="s1">)</span>

    <span class="s1">@pytest.mark.skip</span>
    <span class="s2">def </span><span class="s1">test_smoothed_measurement_disturbance(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.conventional_results.smoothed_measurement_disturbance</span><span class="s2">,</span>
            <span class="s1">self.univariate_results.smoothed_measurement_disturbance</span><span class="s2">, </span><span class="s5">9</span>
        <span class="s1">)</span>

    <span class="s1">@pytest.mark.skip</span>
    <span class="s2">def </span><span class="s1">test_smoothed_measurement_disturbance_cov(self):</span>
        <span class="s1">conv = self.self.conventional_results</span>
        <span class="s1">univ = self.univariate_results</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">conv.smoothed_measurement_disturbance_cov.diagonal()</span><span class="s2">,</span>
            <span class="s1">univ.smoothed_measurement_disturbance_cov.diagonal()</span><span class="s2">,</span>
            <span class="s5">9</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_smoothed_state_disturbance(self):</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">self.conventional_results.smoothed_state_disturbance</span><span class="s2">,</span>
            <span class="s1">self.univariate_results.smoothed_state_disturbance</span><span class="s2">,</span>
            <span class="s1">atol=</span><span class="s5">1e-7</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_smoothed_state_disturbance_cov(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.conventional_results.smoothed_state_disturbance_cov</span><span class="s2">,</span>
            <span class="s1">self.univariate_results.smoothed_state_disturbance_cov</span><span class="s2">, </span><span class="s5">9</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_simulation_smoothed_state(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.conventional_sim.simulated_state</span><span class="s2">,</span>
            <span class="s1">self.univariate_sim.simulated_state</span><span class="s2">, </span><span class="s5">9</span>
        <span class="s1">)</span>

    <span class="s1">@pytest.mark.skip</span>
    <span class="s2">def </span><span class="s1">test_simulation_smoothed_measurement_disturbance(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.conventional_sim.simulated_measurement_disturbance</span><span class="s2">,</span>
            <span class="s1">self.univariate_sim.simulated_measurement_disturbance</span><span class="s2">, </span><span class="s5">9</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_simulation_smoothed_state_disturbance(self):</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">self.conventional_sim.simulated_state_disturbance</span><span class="s2">,</span>
            <span class="s1">self.univariate_sim.simulated_state_disturbance</span><span class="s2">, </span><span class="s5">9</span>
        <span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_time_varying_transition():</span>
    <span class="s4"># Test for correct univariate filtering/smoothing when we have a</span>
    <span class="s4"># time-varying transition matrix</span>
    <span class="s1">endog = np.array([</span><span class="s5">10</span><span class="s2">, </span><span class="s5">5</span><span class="s2">, </span><span class="s5">2.5</span><span class="s2">, </span><span class="s5">1.25</span><span class="s2">, </span><span class="s5">2.5</span><span class="s2">, </span><span class="s5">5</span><span class="s2">, </span><span class="s5">10</span><span class="s1">])</span>
    <span class="s1">transition = np.ones((</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">7</span><span class="s1">))</span>
    <span class="s1">transition[...</span><span class="s2">, </span><span class="s1">:</span><span class="s5">5</span><span class="s1">] = </span><span class="s5">0.5</span>
    <span class="s1">transition[...</span><span class="s2">, </span><span class="s5">5</span><span class="s1">:] = </span><span class="s5">2</span>

    <span class="s4"># Conventional filter / smoother</span>
    <span class="s1">mod1 = SARIMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">measurement_error=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">mod1.update([</span><span class="s5">2.</span><span class="s2">, </span><span class="s5">1.</span><span class="s2">, </span><span class="s5">1.</span><span class="s1">])</span>
    <span class="s1">mod1.ssm[</span><span class="s3">'transition'</span><span class="s1">] = transition</span>
    <span class="s1">res1 = mod1.ssm.smooth()</span>

    <span class="s4"># Univariate filter / smoother</span>
    <span class="s1">mod2 = SARIMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">measurement_error=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">mod2.ssm.filter_univariate = </span><span class="s2">True</span>
    <span class="s1">mod2.update([</span><span class="s5">2.</span><span class="s2">, </span><span class="s5">1.</span><span class="s2">, </span><span class="s5">1.</span><span class="s1">])</span>
    <span class="s1">mod2.ssm[</span><span class="s3">'transition'</span><span class="s1">] = transition</span>
    <span class="s1">res2 = mod2.ssm.smooth()</span>

    <span class="s4"># Simulation smoothers</span>
    <span class="s1">n_disturbance_variates = (mod1.k_endog + mod1.k_posdef) * mod1.nobs</span>
    <span class="s1">sim1 = mod1.simulation_smoother(</span>
        <span class="s1">disturbance_variates=np.zeros(n_disturbance_variates)</span><span class="s2">,</span>
        <span class="s1">initial_state_variates=np.zeros(mod1.k_states))</span>
    <span class="s1">sim2 = mod2.simulation_smoother(</span>
        <span class="s1">disturbance_variates=np.zeros(n_disturbance_variates)</span><span class="s2">,</span>
        <span class="s1">initial_state_variates=np.zeros(mod2.k_states))</span>

    <span class="s4"># Test for correctness</span>
    <span class="s1">assert_allclose(res1.forecasts[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">, </span><span class="s1">res2.forecasts[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">:])</span>
    <span class="s1">assert_allclose(res1.forecasts_error[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">, </span><span class="s1">res2.forecasts_error[</span><span class="s5">0</span><span class="s2">, </span><span class="s1">:])</span>
    <span class="s1">assert_allclose(res1.forecasts_error_cov[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">,</span>
                    <span class="s1">res2.forecasts_error_cov[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">:])</span>
    <span class="s1">assert_allclose(res1.filtered_state</span><span class="s2">, </span><span class="s1">res2.filtered_state)</span>
    <span class="s1">assert_allclose(res1.filtered_state_cov</span><span class="s2">, </span><span class="s1">res2.filtered_state_cov)</span>
    <span class="s1">assert_allclose(res1.predicted_state</span><span class="s2">, </span><span class="s1">res2.predicted_state)</span>
    <span class="s1">assert_allclose(res1.predicted_state_cov</span><span class="s2">, </span><span class="s1">res2.predicted_state_cov)</span>
    <span class="s1">assert_allclose(res1.llf_obs</span><span class="s2">, </span><span class="s1">res2.llf_obs)</span>
    <span class="s1">assert_allclose(res1.smoothed_state</span><span class="s2">, </span><span class="s1">res2.smoothed_state)</span>
    <span class="s1">assert_allclose(res1.smoothed_state_cov</span><span class="s2">, </span><span class="s1">res2.smoothed_state_cov)</span>
    <span class="s1">assert_allclose(res1.smoothed_measurement_disturbance</span><span class="s2">,</span>
                    <span class="s1">res2.smoothed_measurement_disturbance)</span>
    <span class="s1">assert_allclose(res1.smoothed_measurement_disturbance_cov.diagonal()</span><span class="s2">,</span>
                    <span class="s1">res2.smoothed_measurement_disturbance_cov.diagonal())</span>
    <span class="s1">assert_allclose(res1.smoothed_state_disturbance</span><span class="s2">,</span>
                    <span class="s1">res2.smoothed_state_disturbance)</span>
    <span class="s1">assert_allclose(res1.smoothed_state_disturbance_cov</span><span class="s2">,</span>
                    <span class="s1">res2.smoothed_state_disturbance_cov)</span>

    <span class="s1">assert_allclose(sim1.simulated_state</span><span class="s2">, </span><span class="s1">sim2.simulated_state)</span>
    <span class="s1">assert_allclose(sim1.simulated_measurement_disturbance</span><span class="s2">,</span>
                    <span class="s1">sim2.simulated_measurement_disturbance)</span>
    <span class="s1">assert_allclose(sim1.simulated_state_disturbance</span><span class="s2">,</span>
                    <span class="s1">sim2.simulated_state_disturbance)</span>
</pre>
</body>
</html>