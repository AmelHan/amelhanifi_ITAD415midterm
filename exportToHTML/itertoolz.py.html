<html>
<head>
<title>itertoolz.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
itertoolz.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">itertools</span>
<span class="s0">import </span><span class="s1">heapq</span>
<span class="s0">import </span><span class="s1">collections</span>
<span class="s0">import </span><span class="s1">operator</span>
<span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">partial</span>
<span class="s0">from </span><span class="s1">itertools </span><span class="s0">import </span><span class="s1">filterfalse</span><span class="s0">, </span><span class="s1">zip_longest</span>
<span class="s0">from </span><span class="s1">collections.abc </span><span class="s0">import </span><span class="s1">Sequence</span>
<span class="s0">from </span><span class="s1">toolz.utils </span><span class="s0">import </span><span class="s1">no_default</span>


<span class="s1">__all__ = (</span><span class="s2">'remove'</span><span class="s0">, </span><span class="s2">'accumulate'</span><span class="s0">, </span><span class="s2">'groupby'</span><span class="s0">, </span><span class="s2">'merge_sorted'</span><span class="s0">, </span><span class="s2">'interleave'</span><span class="s0">,</span>
           <span class="s2">'unique'</span><span class="s0">, </span><span class="s2">'isiterable'</span><span class="s0">, </span><span class="s2">'isdistinct'</span><span class="s0">, </span><span class="s2">'take'</span><span class="s0">, </span><span class="s2">'drop'</span><span class="s0">, </span><span class="s2">'take_nth'</span><span class="s0">,</span>
           <span class="s2">'first'</span><span class="s0">, </span><span class="s2">'second'</span><span class="s0">, </span><span class="s2">'nth'</span><span class="s0">, </span><span class="s2">'last'</span><span class="s0">, </span><span class="s2">'get'</span><span class="s0">, </span><span class="s2">'concat'</span><span class="s0">, </span><span class="s2">'concatv'</span><span class="s0">,</span>
           <span class="s2">'mapcat'</span><span class="s0">, </span><span class="s2">'cons'</span><span class="s0">, </span><span class="s2">'interpose'</span><span class="s0">, </span><span class="s2">'frequencies'</span><span class="s0">, </span><span class="s2">'reduceby'</span><span class="s0">, </span><span class="s2">'iterate'</span><span class="s0">,</span>
           <span class="s2">'sliding_window'</span><span class="s0">, </span><span class="s2">'partition'</span><span class="s0">, </span><span class="s2">'partition_all'</span><span class="s0">, </span><span class="s2">'count'</span><span class="s0">, </span><span class="s2">'pluck'</span><span class="s0">,</span>
           <span class="s2">'join'</span><span class="s0">, </span><span class="s2">'tail'</span><span class="s0">, </span><span class="s2">'diff'</span><span class="s0">, </span><span class="s2">'topk'</span><span class="s0">, </span><span class="s2">'peek'</span><span class="s0">, </span><span class="s2">'peekn'</span><span class="s0">, </span><span class="s2">'random_sample'</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">remove(predicate</span><span class="s0">, </span><span class="s1">seq):</span>
    <span class="s3">&quot;&quot;&quot; Return those items of sequence for which predicate(item) is False 
 
    &gt;&gt;&gt; def iseven(x): 
    ...     return x % 2 == 0 
    &gt;&gt;&gt; list(remove(iseven, [1, 2, 3, 4])) 
    [1, 3] 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">filterfalse(predicate</span><span class="s0">, </span><span class="s1">seq)</span>


<span class="s0">def </span><span class="s1">accumulate(binop</span><span class="s0">, </span><span class="s1">seq</span><span class="s0">, </span><span class="s1">initial=no_default):</span>
    <span class="s3">&quot;&quot;&quot; Repeatedly apply binary function to a sequence, accumulating results 
 
    &gt;&gt;&gt; from operator import add, mul 
    &gt;&gt;&gt; list(accumulate(add, [1, 2, 3, 4, 5])) 
    [1, 3, 6, 10, 15] 
    &gt;&gt;&gt; list(accumulate(mul, [1, 2, 3, 4, 5])) 
    [1, 2, 6, 24, 120] 
 
    Accumulate is similar to ``reduce`` and is good for making functions like 
    cumulative sum: 
 
    &gt;&gt;&gt; from functools import partial, reduce 
    &gt;&gt;&gt; sum    = partial(reduce, add) 
    &gt;&gt;&gt; cumsum = partial(accumulate, add) 
 
    Accumulate also takes an optional argument that will be used as the first 
    value. This is similar to reduce. 
 
    &gt;&gt;&gt; list(accumulate(add, [1, 2, 3], -1)) 
    [-1, 0, 2, 5] 
    &gt;&gt;&gt; list(accumulate(add, [], 1)) 
    [1] 
 
    See Also: 
        itertools.accumulate :  In standard itertools for Python 3.2+ 
    &quot;&quot;&quot;</span>
    <span class="s1">seq = iter(seq)</span>
    <span class="s0">if </span><span class="s1">initial == no_default:</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">result = next(seq)</span>
        <span class="s0">except </span><span class="s1">StopIteration:</span>
            <span class="s0">return</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">result = initial</span>
    <span class="s0">yield </span><span class="s1">result</span>
    <span class="s0">for </span><span class="s1">elem </span><span class="s0">in </span><span class="s1">seq:</span>
        <span class="s1">result = binop(result</span><span class="s0">, </span><span class="s1">elem)</span>
        <span class="s0">yield </span><span class="s1">result</span>


<span class="s0">def </span><span class="s1">groupby(key</span><span class="s0">, </span><span class="s1">seq):</span>
    <span class="s3">&quot;&quot;&quot; Group a collection by a key function 
 
    &gt;&gt;&gt; names = ['Alice', 'Bob', 'Charlie', 'Dan', 'Edith', 'Frank'] 
    &gt;&gt;&gt; groupby(len, names)  # doctest: +SKIP 
    {3: ['Bob', 'Dan'], 5: ['Alice', 'Edith', 'Frank'], 7: ['Charlie']} 
 
    &gt;&gt;&gt; iseven = lambda x: x % 2 == 0 
    &gt;&gt;&gt; groupby(iseven, [1, 2, 3, 4, 5, 6, 7, 8])  # doctest: +SKIP 
    {False: [1, 3, 5, 7], True: [2, 4, 6, 8]} 
 
    Non-callable keys imply grouping on a member. 
 
    &gt;&gt;&gt; groupby('gender', [{'name': 'Alice', 'gender': 'F'}, 
    ...                    {'name': 'Bob', 'gender': 'M'}, 
    ...                    {'name': 'Charlie', 'gender': 'M'}]) # doctest:+SKIP 
    {'F': [{'gender': 'F', 'name': 'Alice'}], 
     'M': [{'gender': 'M', 'name': 'Bob'}, 
           {'gender': 'M', 'name': 'Charlie'}]} 
 
    Not to be confused with ``itertools.groupby`` 
 
    See Also: 
        countby 
    &quot;&quot;&quot;</span>
    <span class="s0">if not </span><span class="s1">callable(key):</span>
        <span class="s1">key = getter(key)</span>
    <span class="s1">d = collections.defaultdict(</span><span class="s0">lambda</span><span class="s1">: [].append)</span>
    <span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">seq:</span>
        <span class="s1">d[key(item)](item)</span>
    <span class="s1">rv = {}</span>
    <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">d.items():</span>
        <span class="s1">rv[k] = v.__self__</span>
    <span class="s0">return </span><span class="s1">rv</span>


<span class="s0">def </span><span class="s1">merge_sorted(*seqs</span><span class="s0">, </span><span class="s1">**kwargs):</span>
    <span class="s3">&quot;&quot;&quot; Merge and sort a collection of sorted collections 
 
    This works lazily and only keeps one value from each iterable in memory. 
 
    &gt;&gt;&gt; list(merge_sorted([1, 3, 5], [2, 4, 6])) 
    [1, 2, 3, 4, 5, 6] 
 
    &gt;&gt;&gt; ''.join(merge_sorted('abc', 'abc', 'abc')) 
    'aaabbbccc' 
 
    The &quot;key&quot; function used to sort the input may be passed as a keyword. 
 
    &gt;&gt;&gt; list(merge_sorted([2, 3], [1, 3], key=lambda x: x // 3)) 
    [2, 1, 3, 3] 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">len(seqs) == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">iter([])</span>
    <span class="s0">elif </span><span class="s1">len(seqs) == </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">iter(seqs[</span><span class="s4">0</span><span class="s1">])</span>

    <span class="s1">key = kwargs.get(</span><span class="s2">'key'</span><span class="s0">, None</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">key </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">_merge_sorted_binary(seqs)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">_merge_sorted_binary_key(seqs</span><span class="s0">, </span><span class="s1">key)</span>


<span class="s0">def </span><span class="s1">_merge_sorted_binary(seqs):</span>
    <span class="s1">mid = len(seqs) // </span><span class="s4">2</span>
    <span class="s1">L1 = seqs[:mid]</span>
    <span class="s0">if </span><span class="s1">len(L1) == </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">seq1 = iter(L1[</span><span class="s4">0</span><span class="s1">])</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">seq1 = _merge_sorted_binary(L1)</span>
    <span class="s1">L2 = seqs[mid:]</span>
    <span class="s0">if </span><span class="s1">len(L2) == </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">seq2 = iter(L2[</span><span class="s4">0</span><span class="s1">])</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">seq2 = _merge_sorted_binary(L2)</span>

    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">val2 = next(seq2)</span>
    <span class="s0">except </span><span class="s1">StopIteration:</span>
        <span class="s0">for </span><span class="s1">val1 </span><span class="s0">in </span><span class="s1">seq1:</span>
            <span class="s0">yield </span><span class="s1">val1</span>
        <span class="s0">return</span>

    <span class="s0">for </span><span class="s1">val1 </span><span class="s0">in </span><span class="s1">seq1:</span>
        <span class="s0">if </span><span class="s1">val2 &lt; val1:</span>
            <span class="s0">yield </span><span class="s1">val2</span>
            <span class="s0">for </span><span class="s1">val2 </span><span class="s0">in </span><span class="s1">seq2:</span>
                <span class="s0">if </span><span class="s1">val2 &lt; val1:</span>
                    <span class="s0">yield </span><span class="s1">val2</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s0">yield </span><span class="s1">val1</span>
                    <span class="s0">break</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">break</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">yield </span><span class="s1">val1</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">yield </span><span class="s1">val2</span>
        <span class="s0">for </span><span class="s1">val2 </span><span class="s0">in </span><span class="s1">seq2:</span>
            <span class="s0">yield </span><span class="s1">val2</span>
        <span class="s0">return</span>
    <span class="s0">yield </span><span class="s1">val1</span>
    <span class="s0">for </span><span class="s1">val1 </span><span class="s0">in </span><span class="s1">seq1:</span>
        <span class="s0">yield </span><span class="s1">val1</span>


<span class="s0">def </span><span class="s1">_merge_sorted_binary_key(seqs</span><span class="s0">, </span><span class="s1">key):</span>
    <span class="s1">mid = len(seqs) // </span><span class="s4">2</span>
    <span class="s1">L1 = seqs[:mid]</span>
    <span class="s0">if </span><span class="s1">len(L1) == </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">seq1 = iter(L1[</span><span class="s4">0</span><span class="s1">])</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">seq1 = _merge_sorted_binary_key(L1</span><span class="s0">, </span><span class="s1">key)</span>
    <span class="s1">L2 = seqs[mid:]</span>
    <span class="s0">if </span><span class="s1">len(L2) == </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">seq2 = iter(L2[</span><span class="s4">0</span><span class="s1">])</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">seq2 = _merge_sorted_binary_key(L2</span><span class="s0">, </span><span class="s1">key)</span>

    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">val2 = next(seq2)</span>
    <span class="s0">except </span><span class="s1">StopIteration:</span>
        <span class="s0">for </span><span class="s1">val1 </span><span class="s0">in </span><span class="s1">seq1:</span>
            <span class="s0">yield </span><span class="s1">val1</span>
        <span class="s0">return</span>
    <span class="s1">key2 = key(val2)</span>

    <span class="s0">for </span><span class="s1">val1 </span><span class="s0">in </span><span class="s1">seq1:</span>
        <span class="s1">key1 = key(val1)</span>
        <span class="s0">if </span><span class="s1">key2 &lt; key1:</span>
            <span class="s0">yield </span><span class="s1">val2</span>
            <span class="s0">for </span><span class="s1">val2 </span><span class="s0">in </span><span class="s1">seq2:</span>
                <span class="s1">key2 = key(val2)</span>
                <span class="s0">if </span><span class="s1">key2 &lt; key1:</span>
                    <span class="s0">yield </span><span class="s1">val2</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s0">yield </span><span class="s1">val1</span>
                    <span class="s0">break</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">break</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">yield </span><span class="s1">val1</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">yield </span><span class="s1">val2</span>
        <span class="s0">for </span><span class="s1">val2 </span><span class="s0">in </span><span class="s1">seq2:</span>
            <span class="s0">yield </span><span class="s1">val2</span>
        <span class="s0">return</span>
    <span class="s0">yield </span><span class="s1">val1</span>
    <span class="s0">for </span><span class="s1">val1 </span><span class="s0">in </span><span class="s1">seq1:</span>
        <span class="s0">yield </span><span class="s1">val1</span>


<span class="s0">def </span><span class="s1">interleave(seqs):</span>
    <span class="s3">&quot;&quot;&quot; Interleave a sequence of sequences 
 
    &gt;&gt;&gt; list(interleave([[1, 2], [3, 4]])) 
    [1, 3, 2, 4] 
 
    &gt;&gt;&gt; ''.join(interleave(('ABC', 'XY'))) 
    'AXBYC' 
 
    Both the individual sequences and the sequence of sequences may be infinite 
 
    Returns a lazy iterator 
    &quot;&quot;&quot;</span>
    <span class="s1">iters = itertools.cycle(map(iter</span><span class="s0">, </span><span class="s1">seqs))</span>
    <span class="s0">while True</span><span class="s1">:</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">for </span><span class="s1">itr </span><span class="s0">in </span><span class="s1">iters:</span>
                <span class="s0">yield </span><span class="s1">next(itr)</span>
            <span class="s0">return</span>
        <span class="s0">except </span><span class="s1">StopIteration:</span>
            <span class="s1">predicate = partial(operator.is_not</span><span class="s0">, </span><span class="s1">itr)</span>
            <span class="s1">iters = itertools.cycle(itertools.takewhile(predicate</span><span class="s0">, </span><span class="s1">iters))</span>


<span class="s0">def </span><span class="s1">unique(seq</span><span class="s0">, </span><span class="s1">key=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot; Return only unique elements of a sequence 
 
    &gt;&gt;&gt; tuple(unique((1, 2, 3))) 
    (1, 2, 3) 
    &gt;&gt;&gt; tuple(unique((1, 2, 1, 3))) 
    (1, 2, 3) 
 
    Uniqueness can be defined by key keyword 
 
    &gt;&gt;&gt; tuple(unique(['cat', 'mouse', 'dog', 'hen'], key=len)) 
    ('cat', 'mouse') 
    &quot;&quot;&quot;</span>
    <span class="s1">seen = set()</span>
    <span class="s1">seen_add = seen.add</span>
    <span class="s0">if </span><span class="s1">key </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">seq:</span>
            <span class="s0">if </span><span class="s1">item </span><span class="s0">not in </span><span class="s1">seen:</span>
                <span class="s1">seen_add(item)</span>
                <span class="s0">yield </span><span class="s1">item</span>
    <span class="s0">else</span><span class="s1">:  </span><span class="s5"># calculate key</span>
        <span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">seq:</span>
            <span class="s1">val = key(item)</span>
            <span class="s0">if </span><span class="s1">val </span><span class="s0">not in </span><span class="s1">seen:</span>
                <span class="s1">seen_add(val)</span>
                <span class="s0">yield </span><span class="s1">item</span>


<span class="s0">def </span><span class="s1">isiterable(x):</span>
    <span class="s3">&quot;&quot;&quot; Is x iterable? 
 
    &gt;&gt;&gt; isiterable([1, 2, 3]) 
    True 
    &gt;&gt;&gt; isiterable('abc') 
    True 
    &gt;&gt;&gt; isiterable(5) 
    False 
    &quot;&quot;&quot;</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">iter(x)</span>
        <span class="s0">return True</span>
    <span class="s0">except </span><span class="s1">TypeError:</span>
        <span class="s0">return False</span>


<span class="s0">def </span><span class="s1">isdistinct(seq):</span>
    <span class="s3">&quot;&quot;&quot; All values in sequence are distinct 
 
    &gt;&gt;&gt; isdistinct([1, 2, 3]) 
    True 
    &gt;&gt;&gt; isdistinct([1, 2, 1]) 
    False 
 
    &gt;&gt;&gt; isdistinct(&quot;Hello&quot;) 
    False 
    &gt;&gt;&gt; isdistinct(&quot;World&quot;) 
    True 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">iter(seq) </span><span class="s0">is </span><span class="s1">seq:</span>
        <span class="s1">seen = set()</span>
        <span class="s1">seen_add = seen.add</span>
        <span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">seq:</span>
            <span class="s0">if </span><span class="s1">item </span><span class="s0">in </span><span class="s1">seen:</span>
                <span class="s0">return False</span>
            <span class="s1">seen_add(item)</span>
        <span class="s0">return True</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">len(seq) == len(set(seq))</span>


<span class="s0">def </span><span class="s1">take(n</span><span class="s0">, </span><span class="s1">seq):</span>
    <span class="s3">&quot;&quot;&quot; The first n elements of a sequence 
 
    &gt;&gt;&gt; list(take(2, [10, 20, 30, 40, 50])) 
    [10, 20] 
 
    See Also: 
        drop 
        tail 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">itertools.islice(seq</span><span class="s0">, </span><span class="s1">n)</span>


<span class="s0">def </span><span class="s1">tail(n</span><span class="s0">, </span><span class="s1">seq):</span>
    <span class="s3">&quot;&quot;&quot; The last n elements of a sequence 
 
    &gt;&gt;&gt; tail(2, [10, 20, 30, 40, 50]) 
    [40, 50] 
 
    See Also: 
        drop 
        take 
    &quot;&quot;&quot;</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">seq[-n:]</span>
    <span class="s0">except </span><span class="s1">(TypeError</span><span class="s0">, </span><span class="s1">KeyError):</span>
        <span class="s0">return </span><span class="s1">tuple(collections.deque(seq</span><span class="s0">, </span><span class="s1">n))</span>


<span class="s0">def </span><span class="s1">drop(n</span><span class="s0">, </span><span class="s1">seq):</span>
    <span class="s3">&quot;&quot;&quot; The sequence following the first n elements 
 
    &gt;&gt;&gt; list(drop(2, [10, 20, 30, 40, 50])) 
    [30, 40, 50] 
 
    See Also: 
        take 
        tail 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">itertools.islice(seq</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, None</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">take_nth(n</span><span class="s0">, </span><span class="s1">seq):</span>
    <span class="s3">&quot;&quot;&quot; Every nth item in seq 
 
    &gt;&gt;&gt; list(take_nth(2, [10, 20, 30, 40, 50])) 
    [10, 30, 50] 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">itertools.islice(seq</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, None, </span><span class="s1">n)</span>


<span class="s0">def </span><span class="s1">first(seq):</span>
    <span class="s3">&quot;&quot;&quot; The first element in a sequence 
 
    &gt;&gt;&gt; first('ABC') 
    'A' 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">next(iter(seq))</span>


<span class="s0">def </span><span class="s1">second(seq):</span>
    <span class="s3">&quot;&quot;&quot; The second element in a sequence 
 
    &gt;&gt;&gt; second('ABC') 
    'B' 
    &quot;&quot;&quot;</span>
    <span class="s1">seq = iter(seq)</span>
    <span class="s1">next(seq)</span>
    <span class="s0">return </span><span class="s1">next(seq)</span>


<span class="s0">def </span><span class="s1">nth(n</span><span class="s0">, </span><span class="s1">seq):</span>
    <span class="s3">&quot;&quot;&quot; The nth element in a sequence 
 
    &gt;&gt;&gt; nth(1, 'ABC') 
    'B' 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">isinstance(seq</span><span class="s0">, </span><span class="s1">(tuple</span><span class="s0">, </span><span class="s1">list</span><span class="s0">, </span><span class="s1">Sequence)):</span>
        <span class="s0">return </span><span class="s1">seq[n]</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">next(itertools.islice(seq</span><span class="s0">, </span><span class="s1">n</span><span class="s0">, None</span><span class="s1">))</span>


<span class="s0">def </span><span class="s1">last(seq):</span>
    <span class="s3">&quot;&quot;&quot; The last element in a sequence 
 
    &gt;&gt;&gt; last('ABC') 
    'C' 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">tail(</span><span class="s4">1</span><span class="s0">, </span><span class="s1">seq)[</span><span class="s4">0</span><span class="s1">]</span>


<span class="s1">rest = partial(drop</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">_get(ind</span><span class="s0">, </span><span class="s1">seq</span><span class="s0">, </span><span class="s1">default):</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">seq[ind]</span>
    <span class="s0">except </span><span class="s1">(KeyError</span><span class="s0">, </span><span class="s1">IndexError):</span>
        <span class="s0">return </span><span class="s1">default</span>


<span class="s0">def </span><span class="s1">get(ind</span><span class="s0">, </span><span class="s1">seq</span><span class="s0">, </span><span class="s1">default=no_default):</span>
    <span class="s3">&quot;&quot;&quot; Get element in a sequence or dict 
 
    Provides standard indexing 
 
    &gt;&gt;&gt; get(1, 'ABC')       # Same as 'ABC'[1] 
    'B' 
 
    Pass a list to get multiple values 
 
    &gt;&gt;&gt; get([1, 2], 'ABC')  # ('ABC'[1], 'ABC'[2]) 
    ('B', 'C') 
 
    Works on any value that supports indexing/getitem 
    For example here we see that it works with dictionaries 
 
    &gt;&gt;&gt; phonebook = {'Alice':  '555-1234', 
    ...              'Bob':    '555-5678', 
    ...              'Charlie':'555-9999'} 
    &gt;&gt;&gt; get('Alice', phonebook) 
    '555-1234' 
 
    &gt;&gt;&gt; get(['Alice', 'Bob'], phonebook) 
    ('555-1234', '555-5678') 
 
    Provide a default for missing values 
 
    &gt;&gt;&gt; get(['Alice', 'Dennis'], phonebook, None) 
    ('555-1234', None) 
 
    See Also: 
        pluck 
    &quot;&quot;&quot;</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">seq[ind]</span>
    <span class="s0">except </span><span class="s1">TypeError:  </span><span class="s5"># `ind` may be a list</span>
        <span class="s0">if </span><span class="s1">isinstance(ind</span><span class="s0">, </span><span class="s1">list):</span>
            <span class="s0">if </span><span class="s1">default == no_default:</span>
                <span class="s0">if </span><span class="s1">len(ind) &gt; </span><span class="s4">1</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s1">operator.itemgetter(*ind)(seq)</span>
                <span class="s0">elif </span><span class="s1">ind:</span>
                    <span class="s0">return </span><span class="s1">seq[ind[</span><span class="s4">0</span><span class="s1">]]</span><span class="s0">,</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s0">return </span><span class="s1">()</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">tuple(_get(i</span><span class="s0">, </span><span class="s1">seq</span><span class="s0">, </span><span class="s1">default) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">ind)</span>
        <span class="s0">elif </span><span class="s1">default != no_default:</span>
            <span class="s0">return </span><span class="s1">default</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise</span>
    <span class="s0">except </span><span class="s1">(KeyError</span><span class="s0">, </span><span class="s1">IndexError):  </span><span class="s5"># we know `ind` is not a list</span>
        <span class="s0">if </span><span class="s1">default == no_default:</span>
            <span class="s0">raise</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">default</span>


<span class="s0">def </span><span class="s1">concat(seqs):</span>
    <span class="s3">&quot;&quot;&quot; Concatenate zero or more iterables, any of which may be infinite. 
 
    An infinite sequence will prevent the rest of the arguments from 
    being included. 
 
    We use chain.from_iterable rather than ``chain(*seqs)`` so that seqs 
    can be a generator. 
 
    &gt;&gt;&gt; list(concat([[], [1], [2, 3]])) 
    [1, 2, 3] 
 
    See also: 
        itertools.chain.from_iterable  equivalent 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">itertools.chain.from_iterable(seqs)</span>


<span class="s0">def </span><span class="s1">concatv(*seqs):</span>
    <span class="s3">&quot;&quot;&quot; Variadic version of concat 
 
    &gt;&gt;&gt; list(concatv([], [&quot;a&quot;], [&quot;b&quot;, &quot;c&quot;])) 
    ['a', 'b', 'c'] 
 
    See also: 
        itertools.chain 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">concat(seqs)</span>


<span class="s0">def </span><span class="s1">mapcat(func</span><span class="s0">, </span><span class="s1">seqs):</span>
    <span class="s3">&quot;&quot;&quot; Apply func to each sequence in seqs, concatenating results. 
 
    &gt;&gt;&gt; list(mapcat(lambda s: [c.upper() for c in s], 
    ...             [[&quot;a&quot;, &quot;b&quot;], [&quot;c&quot;, &quot;d&quot;, &quot;e&quot;]])) 
    ['A', 'B', 'C', 'D', 'E'] 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">concat(map(func</span><span class="s0">, </span><span class="s1">seqs))</span>


<span class="s0">def </span><span class="s1">cons(el</span><span class="s0">, </span><span class="s1">seq):</span>
    <span class="s3">&quot;&quot;&quot; Add el to beginning of (possibly infinite) sequence seq. 
 
    &gt;&gt;&gt; list(cons(1, [2, 3])) 
    [1, 2, 3] 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">itertools.chain([el]</span><span class="s0">, </span><span class="s1">seq)</span>


<span class="s0">def </span><span class="s1">interpose(el</span><span class="s0">, </span><span class="s1">seq):</span>
    <span class="s3">&quot;&quot;&quot; Introduce element between each pair of elements in seq 
 
    &gt;&gt;&gt; list(interpose(&quot;a&quot;, [1, 2, 3])) 
    [1, 'a', 2, 'a', 3] 
    &quot;&quot;&quot;</span>
    <span class="s1">inposed = concat(zip(itertools.repeat(el)</span><span class="s0">, </span><span class="s1">seq))</span>
    <span class="s1">next(inposed)</span>
    <span class="s0">return </span><span class="s1">inposed</span>


<span class="s0">def </span><span class="s1">frequencies(seq):</span>
    <span class="s3">&quot;&quot;&quot; Find number of occurrences of each value in seq 
 
    &gt;&gt;&gt; frequencies(['cat', 'cat', 'ox', 'pig', 'pig', 'cat'])  #doctest: +SKIP 
    {'cat': 3, 'ox': 1, 'pig': 2} 
 
    See Also: 
        countby 
        groupby 
    &quot;&quot;&quot;</span>
    <span class="s1">d = collections.defaultdict(int)</span>
    <span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">seq:</span>
        <span class="s1">d[item] += </span><span class="s4">1</span>
    <span class="s0">return </span><span class="s1">dict(d)</span>


<span class="s0">def </span><span class="s1">reduceby(key</span><span class="s0">, </span><span class="s1">binop</span><span class="s0">, </span><span class="s1">seq</span><span class="s0">, </span><span class="s1">init=no_default):</span>
    <span class="s3">&quot;&quot;&quot; Perform a simultaneous groupby and reduction 
 
    The computation: 
 
    &gt;&gt;&gt; result = reduceby(key, binop, seq, init)      # doctest: +SKIP 
 
    is equivalent to the following: 
 
    &gt;&gt;&gt; def reduction(group):                           # doctest: +SKIP 
    ...     return reduce(binop, group, init)           # doctest: +SKIP 
 
    &gt;&gt;&gt; groups = groupby(key, seq)                    # doctest: +SKIP 
    &gt;&gt;&gt; result = valmap(reduction, groups)              # doctest: +SKIP 
 
    But the former does not build the intermediate groups, allowing it to 
    operate in much less space.  This makes it suitable for larger datasets 
    that do not fit comfortably in memory 
 
    The ``init`` keyword argument is the default initialization of the 
    reduction.  This can be either a constant value like ``0`` or a callable 
    like ``lambda : 0`` as might be used in ``defaultdict``. 
 
    Simple Examples 
    --------------- 
 
    &gt;&gt;&gt; from operator import add, mul 
    &gt;&gt;&gt; iseven = lambda x: x % 2 == 0 
 
    &gt;&gt;&gt; data = [1, 2, 3, 4, 5] 
 
    &gt;&gt;&gt; reduceby(iseven, add, data)  # doctest: +SKIP 
    {False: 9, True: 6} 
 
    &gt;&gt;&gt; reduceby(iseven, mul, data)  # doctest: +SKIP 
    {False: 15, True: 8} 
 
    Complex Example 
    --------------- 
 
    &gt;&gt;&gt; projects = [{'name': 'build roads', 'state': 'CA', 'cost': 1000000}, 
    ...             {'name': 'fight crime', 'state': 'IL', 'cost': 100000}, 
    ...             {'name': 'help farmers', 'state': 'IL', 'cost': 2000000}, 
    ...             {'name': 'help farmers', 'state': 'CA', 'cost': 200000}] 
 
    &gt;&gt;&gt; reduceby('state',                        # doctest: +SKIP 
    ...          lambda acc, x: acc + x['cost'], 
    ...          projects, 0) 
    {'CA': 1200000, 'IL': 2100000} 
 
    Example Using ``init`` 
    ---------------------- 
 
    &gt;&gt;&gt; def set_add(s, i): 
    ...     s.add(i) 
    ...     return s 
 
    &gt;&gt;&gt; reduceby(iseven, set_add, [1, 2, 3, 4, 1, 2, 3], set)  # doctest: +SKIP 
    {True:  set([2, 4]), 
     False: set([1, 3])} 
    &quot;&quot;&quot;</span>
    <span class="s1">is_no_default = init == no_default</span>
    <span class="s0">if not </span><span class="s1">is_no_default </span><span class="s0">and not </span><span class="s1">callable(init):</span>
        <span class="s1">_init = init</span>
        <span class="s1">init = </span><span class="s0">lambda</span><span class="s1">: _init</span>
    <span class="s0">if not </span><span class="s1">callable(key):</span>
        <span class="s1">key = getter(key)</span>
    <span class="s1">d = {}</span>
    <span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">seq:</span>
        <span class="s1">k = key(item)</span>
        <span class="s0">if </span><span class="s1">k </span><span class="s0">not in </span><span class="s1">d:</span>
            <span class="s0">if </span><span class="s1">is_no_default:</span>
                <span class="s1">d[k] = item</span>
                <span class="s0">continue</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">d[k] = init()</span>
        <span class="s1">d[k] = binop(d[k]</span><span class="s0">, </span><span class="s1">item)</span>
    <span class="s0">return </span><span class="s1">d</span>


<span class="s0">def </span><span class="s1">iterate(func</span><span class="s0">, </span><span class="s1">x):</span>
    <span class="s3">&quot;&quot;&quot; Repeatedly apply a function func onto an original input 
 
    Yields x, then func(x), then func(func(x)), then func(func(func(x))), etc.. 
 
    &gt;&gt;&gt; def inc(x):  return x + 1 
    &gt;&gt;&gt; counter = iterate(inc, 0) 
    &gt;&gt;&gt; next(counter) 
    0 
    &gt;&gt;&gt; next(counter) 
    1 
    &gt;&gt;&gt; next(counter) 
    2 
 
    &gt;&gt;&gt; double = lambda x: x * 2 
    &gt;&gt;&gt; powers_of_two = iterate(double, 1) 
    &gt;&gt;&gt; next(powers_of_two) 
    1 
    &gt;&gt;&gt; next(powers_of_two) 
    2 
    &gt;&gt;&gt; next(powers_of_two) 
    4 
    &gt;&gt;&gt; next(powers_of_two) 
    8 
    &quot;&quot;&quot;</span>
    <span class="s0">while True</span><span class="s1">:</span>
        <span class="s0">yield </span><span class="s1">x</span>
        <span class="s1">x = func(x)</span>


<span class="s0">def </span><span class="s1">sliding_window(n</span><span class="s0">, </span><span class="s1">seq):</span>
    <span class="s3">&quot;&quot;&quot; A sequence of overlapping subsequences 
 
    &gt;&gt;&gt; list(sliding_window(2, [1, 2, 3, 4])) 
    [(1, 2), (2, 3), (3, 4)] 
 
    This function creates a sliding window suitable for transformations like 
    sliding means / smoothing 
 
    &gt;&gt;&gt; mean = lambda seq: float(sum(seq)) / len(seq) 
    &gt;&gt;&gt; list(map(mean, sliding_window(2, [1, 2, 3, 4]))) 
    [1.5, 2.5, 3.5] 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">zip(*(collections.deque(itertools.islice(it</span><span class="s0">, </span><span class="s1">i)</span><span class="s0">, </span><span class="s4">0</span><span class="s1">) </span><span class="s0">or </span><span class="s1">it</span>
               <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">it </span><span class="s0">in </span><span class="s1">enumerate(itertools.tee(seq</span><span class="s0">, </span><span class="s1">n))))</span>


<span class="s1">no_pad = </span><span class="s2">'__no__pad__'</span>


<span class="s0">def </span><span class="s1">partition(n</span><span class="s0">, </span><span class="s1">seq</span><span class="s0">, </span><span class="s1">pad=no_pad):</span>
    <span class="s3">&quot;&quot;&quot; Partition sequence into tuples of length n 
 
    &gt;&gt;&gt; list(partition(2, [1, 2, 3, 4])) 
    [(1, 2), (3, 4)] 
 
    If the length of ``seq`` is not evenly divisible by ``n``, the final tuple 
    is dropped if ``pad`` is not specified, or filled to length ``n`` by pad: 
 
    &gt;&gt;&gt; list(partition(2, [1, 2, 3, 4, 5])) 
    [(1, 2), (3, 4)] 
 
    &gt;&gt;&gt; list(partition(2, [1, 2, 3, 4, 5], pad=None)) 
    [(1, 2), (3, 4), (5, None)] 
 
    See Also: 
        partition_all 
    &quot;&quot;&quot;</span>
    <span class="s1">args = [iter(seq)] * n</span>
    <span class="s0">if </span><span class="s1">pad </span><span class="s0">is </span><span class="s1">no_pad:</span>
        <span class="s0">return </span><span class="s1">zip(*args)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">zip_longest(*args</span><span class="s0">, </span><span class="s1">fillvalue=pad)</span>


<span class="s0">def </span><span class="s1">partition_all(n</span><span class="s0">, </span><span class="s1">seq):</span>
    <span class="s3">&quot;&quot;&quot; Partition all elements of sequence into tuples of length at most n 
 
    The final tuple may be shorter to accommodate extra elements. 
 
    &gt;&gt;&gt; list(partition_all(2, [1, 2, 3, 4])) 
    [(1, 2), (3, 4)] 
 
    &gt;&gt;&gt; list(partition_all(2, [1, 2, 3, 4, 5])) 
    [(1, 2), (3, 4), (5,)] 
 
    See Also: 
        partition 
    &quot;&quot;&quot;</span>
    <span class="s1">args = [iter(seq)] * n</span>
    <span class="s1">it = zip_longest(*args</span><span class="s0">, </span><span class="s1">fillvalue=no_pad)</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">prev = next(it)</span>
    <span class="s0">except </span><span class="s1">StopIteration:</span>
        <span class="s0">return</span>
    <span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">it:</span>
        <span class="s0">yield </span><span class="s1">prev</span>
        <span class="s1">prev = item</span>
    <span class="s0">if </span><span class="s1">prev[-</span><span class="s4">1</span><span class="s1">] </span><span class="s0">is </span><span class="s1">no_pad:</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s5"># If seq defines __len__, then</span>
            <span class="s5"># we can quickly calculate where no_pad starts</span>
            <span class="s0">yield </span><span class="s1">prev[:len(seq) % n]</span>
        <span class="s0">except </span><span class="s1">TypeError:</span>
            <span class="s5"># Get first index of no_pad without using .index()</span>
            <span class="s5"># https://github.com/pytoolz/toolz/issues/387</span>
            <span class="s5"># Binary search from CPython's bisect module,</span>
            <span class="s5"># modified for identity testing.</span>
            <span class="s1">lo</span><span class="s0">, </span><span class="s1">hi = </span><span class="s4">0</span><span class="s0">, </span><span class="s1">n</span>
            <span class="s0">while </span><span class="s1">lo &lt; hi:</span>
                <span class="s1">mid = (lo + hi) // </span><span class="s4">2</span>
                <span class="s0">if </span><span class="s1">prev[mid] </span><span class="s0">is </span><span class="s1">no_pad:</span>
                    <span class="s1">hi = mid</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">lo = mid + </span><span class="s4">1</span>
            <span class="s0">yield </span><span class="s1">prev[:lo]</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">yield </span><span class="s1">prev</span>


<span class="s0">def </span><span class="s1">count(seq):</span>
    <span class="s3">&quot;&quot;&quot; Count the number of items in seq 
 
    Like the builtin ``len`` but works on lazy sequences. 
 
    Not to be confused with ``itertools.count`` 
 
    See also: 
        len 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">hasattr(seq</span><span class="s0">, </span><span class="s2">'__len__'</span><span class="s1">):</span>
        <span class="s0">return </span><span class="s1">len(seq)</span>
    <span class="s0">return </span><span class="s1">sum(</span><span class="s4">1 </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">seq)</span>


<span class="s0">def </span><span class="s1">pluck(ind</span><span class="s0">, </span><span class="s1">seqs</span><span class="s0">, </span><span class="s1">default=no_default):</span>
    <span class="s3">&quot;&quot;&quot; plucks an element or several elements from each item in a sequence. 
 
    ``pluck`` maps ``itertoolz.get`` over a sequence and returns one or more 
    elements of each item in the sequence. 
 
    This is equivalent to running `map(curried.get(ind), seqs)` 
 
    ``ind`` can be either a single string/index or a list of strings/indices. 
    ``seqs`` should be sequence containing sequences or dicts. 
 
    e.g. 
 
    &gt;&gt;&gt; data = [{'id': 1, 'name': 'Cheese'}, {'id': 2, 'name': 'Pies'}] 
    &gt;&gt;&gt; list(pluck('name', data)) 
    ['Cheese', 'Pies'] 
    &gt;&gt;&gt; list(pluck([0, 1], [[1, 2, 3], [4, 5, 7]])) 
    [(1, 2), (4, 5)] 
 
    See Also: 
        get 
        map 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">default == no_default:</span>
        <span class="s1">get = getter(ind)</span>
        <span class="s0">return </span><span class="s1">map(get</span><span class="s0">, </span><span class="s1">seqs)</span>
    <span class="s0">elif </span><span class="s1">isinstance(ind</span><span class="s0">, </span><span class="s1">list):</span>
        <span class="s0">return </span><span class="s1">(tuple(_get(item</span><span class="s0">, </span><span class="s1">seq</span><span class="s0">, </span><span class="s1">default) </span><span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">ind)</span>
                <span class="s0">for </span><span class="s1">seq </span><span class="s0">in </span><span class="s1">seqs)</span>
    <span class="s0">return </span><span class="s1">(_get(ind</span><span class="s0">, </span><span class="s1">seq</span><span class="s0">, </span><span class="s1">default) </span><span class="s0">for </span><span class="s1">seq </span><span class="s0">in </span><span class="s1">seqs)</span>


<span class="s0">def </span><span class="s1">getter(index):</span>
    <span class="s0">if </span><span class="s1">isinstance(index</span><span class="s0">, </span><span class="s1">list):</span>
        <span class="s0">if </span><span class="s1">len(index) == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">index = index[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s0">return lambda </span><span class="s1">x: (x[index]</span><span class="s0">,</span><span class="s1">)</span>
        <span class="s0">elif </span><span class="s1">index:</span>
            <span class="s0">return </span><span class="s1">operator.itemgetter(*index)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return lambda </span><span class="s1">x: ()</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">operator.itemgetter(index)</span>


<span class="s0">def </span><span class="s1">join(leftkey</span><span class="s0">, </span><span class="s1">leftseq</span><span class="s0">, </span><span class="s1">rightkey</span><span class="s0">, </span><span class="s1">rightseq</span><span class="s0">,</span>
         <span class="s1">left_default=no_default</span><span class="s0">, </span><span class="s1">right_default=no_default):</span>
    <span class="s3">&quot;&quot;&quot; Join two sequences on common attributes 
 
    This is a semi-streaming operation.  The LEFT sequence is fully evaluated 
    and placed into memory.  The RIGHT sequence is evaluated lazily and so can 
    be arbitrarily large. 
    (Note: If right_default is defined, then unique keys of rightseq 
        will also be stored in memory.) 
 
    &gt;&gt;&gt; friends = [('Alice', 'Edith'), 
    ...            ('Alice', 'Zhao'), 
    ...            ('Edith', 'Alice'), 
    ...            ('Zhao', 'Alice'), 
    ...            ('Zhao', 'Edith')] 
 
    &gt;&gt;&gt; cities = [('Alice', 'NYC'), 
    ...           ('Alice', 'Chicago'), 
    ...           ('Dan', 'Syndey'), 
    ...           ('Edith', 'Paris'), 
    ...           ('Edith', 'Berlin'), 
    ...           ('Zhao', 'Shanghai')] 
 
    &gt;&gt;&gt; # Vacation opportunities 
    &gt;&gt;&gt; # In what cities do people have friends? 
    &gt;&gt;&gt; result = join(second, friends, 
    ...               first, cities) 
    &gt;&gt;&gt; for ((a, b), (c, d)) in sorted(unique(result)): 
    ...     print((a, d)) 
    ('Alice', 'Berlin') 
    ('Alice', 'Paris') 
    ('Alice', 'Shanghai') 
    ('Edith', 'Chicago') 
    ('Edith', 'NYC') 
    ('Zhao', 'Chicago') 
    ('Zhao', 'NYC') 
    ('Zhao', 'Berlin') 
    ('Zhao', 'Paris') 
 
    Specify outer joins with keyword arguments ``left_default`` and/or 
    ``right_default``.  Here is a full outer join in which unmatched elements 
    are paired with None. 
 
    &gt;&gt;&gt; identity = lambda x: x 
    &gt;&gt;&gt; list(join(identity, [1, 2, 3], 
    ...           identity, [2, 3, 4], 
    ...           left_default=None, right_default=None)) 
    [(2, 2), (3, 3), (None, 4), (1, None)] 
 
    Usually the key arguments are callables to be applied to the sequences.  If 
    the keys are not obviously callable then it is assumed that indexing was 
    intended, e.g. the following is a legal change. 
    The join is implemented as a hash join and the keys of leftseq must be 
    hashable. Additionally, if right_default is defined, then keys of rightseq 
    must also be hashable. 
 
    &gt;&gt;&gt; # result = join(second, friends, first, cities) 
    &gt;&gt;&gt; result = join(1, friends, 0, cities)  # doctest: +SKIP 
    &quot;&quot;&quot;</span>
    <span class="s0">if not </span><span class="s1">callable(leftkey):</span>
        <span class="s1">leftkey = getter(leftkey)</span>
    <span class="s0">if not </span><span class="s1">callable(rightkey):</span>
        <span class="s1">rightkey = getter(rightkey)</span>

    <span class="s1">d = groupby(leftkey</span><span class="s0">, </span><span class="s1">leftseq)</span>

    <span class="s0">if </span><span class="s1">left_default == no_default </span><span class="s0">and </span><span class="s1">right_default == no_default:</span>
        <span class="s5"># Inner Join</span>
        <span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">rightseq:</span>
            <span class="s1">key = rightkey(item)</span>
            <span class="s0">if </span><span class="s1">key </span><span class="s0">in </span><span class="s1">d:</span>
                <span class="s0">for </span><span class="s1">left_match </span><span class="s0">in </span><span class="s1">d[key]:</span>
                    <span class="s0">yield </span><span class="s1">(left_match</span><span class="s0">, </span><span class="s1">item)</span>
    <span class="s0">elif </span><span class="s1">left_default != no_default </span><span class="s0">and </span><span class="s1">right_default == no_default:</span>
        <span class="s5"># Right Join</span>
        <span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">rightseq:</span>
            <span class="s1">key = rightkey(item)</span>
            <span class="s0">if </span><span class="s1">key </span><span class="s0">in </span><span class="s1">d:</span>
                <span class="s0">for </span><span class="s1">left_match </span><span class="s0">in </span><span class="s1">d[key]:</span>
                    <span class="s0">yield </span><span class="s1">(left_match</span><span class="s0">, </span><span class="s1">item)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">yield </span><span class="s1">(left_default</span><span class="s0">, </span><span class="s1">item)</span>
    <span class="s0">elif </span><span class="s1">right_default != no_default:</span>
        <span class="s1">seen_keys = set()</span>
        <span class="s1">seen = seen_keys.add</span>

        <span class="s0">if </span><span class="s1">left_default == no_default:</span>
            <span class="s5"># Left Join</span>
            <span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">rightseq:</span>
                <span class="s1">key = rightkey(item)</span>
                <span class="s1">seen(key)</span>
                <span class="s0">if </span><span class="s1">key </span><span class="s0">in </span><span class="s1">d:</span>
                    <span class="s0">for </span><span class="s1">left_match </span><span class="s0">in </span><span class="s1">d[key]:</span>
                        <span class="s0">yield </span><span class="s1">(left_match</span><span class="s0">, </span><span class="s1">item)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s5"># Full Join</span>
            <span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">rightseq:</span>
                <span class="s1">key = rightkey(item)</span>
                <span class="s1">seen(key)</span>
                <span class="s0">if </span><span class="s1">key </span><span class="s0">in </span><span class="s1">d:</span>
                    <span class="s0">for </span><span class="s1">left_match </span><span class="s0">in </span><span class="s1">d[key]:</span>
                        <span class="s0">yield </span><span class="s1">(left_match</span><span class="s0">, </span><span class="s1">item)</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s0">yield </span><span class="s1">(left_default</span><span class="s0">, </span><span class="s1">item)</span>

        <span class="s0">for </span><span class="s1">key</span><span class="s0">, </span><span class="s1">matches </span><span class="s0">in </span><span class="s1">d.items():</span>
            <span class="s0">if </span><span class="s1">key </span><span class="s0">not in </span><span class="s1">seen_keys:</span>
                <span class="s0">for </span><span class="s1">match </span><span class="s0">in </span><span class="s1">matches:</span>
                    <span class="s0">yield </span><span class="s1">(match</span><span class="s0">, </span><span class="s1">right_default)</span>


<span class="s0">def </span><span class="s1">diff(*seqs</span><span class="s0">, </span><span class="s1">**kwargs):</span>
    <span class="s3">&quot;&quot;&quot; Return those items that differ between sequences 
 
    &gt;&gt;&gt; list(diff([1, 2, 3], [1, 2, 10, 100])) 
    [(3, 10)] 
 
    Shorter sequences may be padded with a ``default`` value: 
 
    &gt;&gt;&gt; list(diff([1, 2, 3], [1, 2, 10, 100], default=None)) 
    [(3, 10), (None, 100)] 
 
    A ``key`` function may also be applied to each item to use during 
    comparisons: 
 
    &gt;&gt;&gt; list(diff(['apples', 'bananas'], ['Apples', 'Oranges'], key=str.lower)) 
    [('bananas', 'Oranges')] 
    &quot;&quot;&quot;</span>
    <span class="s1">N = len(seqs)</span>
    <span class="s0">if </span><span class="s1">N == </span><span class="s4">1 </span><span class="s0">and </span><span class="s1">isinstance(seqs[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">list):</span>
        <span class="s1">seqs = seqs[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">N = len(seqs)</span>
    <span class="s0">if </span><span class="s1">N &lt; </span><span class="s4">2</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">'Too few sequences given (min 2 required)'</span><span class="s1">)</span>
    <span class="s1">default = kwargs.get(</span><span class="s2">'default'</span><span class="s0">, </span><span class="s1">no_default)</span>
    <span class="s0">if </span><span class="s1">default == no_default:</span>
        <span class="s1">iters = zip(*seqs)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">iters = zip_longest(*seqs</span><span class="s0">, </span><span class="s1">fillvalue=default)</span>
    <span class="s1">key = kwargs.get(</span><span class="s2">'key'</span><span class="s0">, None</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">key </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">for </span><span class="s1">items </span><span class="s0">in </span><span class="s1">iters:</span>
            <span class="s0">if </span><span class="s1">items.count(items[</span><span class="s4">0</span><span class="s1">]) != N:</span>
                <span class="s0">yield </span><span class="s1">items</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">for </span><span class="s1">items </span><span class="s0">in </span><span class="s1">iters:</span>
            <span class="s1">vals = tuple(map(key</span><span class="s0">, </span><span class="s1">items))</span>
            <span class="s0">if </span><span class="s1">vals.count(vals[</span><span class="s4">0</span><span class="s1">]) != N:</span>
                <span class="s0">yield </span><span class="s1">items</span>


<span class="s0">def </span><span class="s1">topk(k</span><span class="s0">, </span><span class="s1">seq</span><span class="s0">, </span><span class="s1">key=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot; Find the k largest elements of a sequence 
 
    Operates lazily in ``n*log(k)`` time 
 
    &gt;&gt;&gt; topk(2, [1, 100, 10, 1000]) 
    (1000, 100) 
 
    Use a key function to change sorted order 
 
    &gt;&gt;&gt; topk(2, ['Alice', 'Bob', 'Charlie', 'Dan'], key=len) 
    ('Charlie', 'Alice') 
 
    See also: 
        heapq.nlargest 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">key </span><span class="s0">is not None and not </span><span class="s1">callable(key):</span>
        <span class="s1">key = getter(key)</span>
    <span class="s0">return </span><span class="s1">tuple(heapq.nlargest(k</span><span class="s0">, </span><span class="s1">seq</span><span class="s0">, </span><span class="s1">key=key))</span>


<span class="s0">def </span><span class="s1">peek(seq):</span>
    <span class="s3">&quot;&quot;&quot; Retrieve the next element of a sequence 
 
    Returns the first element and an iterable equivalent to the original 
    sequence, still having the element retrieved. 
 
    &gt;&gt;&gt; seq = [0, 1, 2, 3, 4] 
    &gt;&gt;&gt; first, seq = peek(seq) 
    &gt;&gt;&gt; first 
    0 
    &gt;&gt;&gt; list(seq) 
    [0, 1, 2, 3, 4] 
    &quot;&quot;&quot;</span>
    <span class="s1">iterator = iter(seq)</span>
    <span class="s1">item = next(iterator)</span>
    <span class="s0">return </span><span class="s1">item</span><span class="s0">, </span><span class="s1">itertools.chain((item</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">iterator)</span>


<span class="s0">def </span><span class="s1">peekn(n</span><span class="s0">, </span><span class="s1">seq):</span>
    <span class="s3">&quot;&quot;&quot; Retrieve the next n elements of a sequence 
 
    Returns a tuple of the first n elements and an iterable equivalent 
    to the original, still having the elements retrieved. 
 
    &gt;&gt;&gt; seq = [0, 1, 2, 3, 4] 
    &gt;&gt;&gt; first_two, seq = peekn(2, seq) 
    &gt;&gt;&gt; first_two 
    (0, 1) 
    &gt;&gt;&gt; list(seq) 
    [0, 1, 2, 3, 4] 
    &quot;&quot;&quot;</span>
    <span class="s1">iterator = iter(seq)</span>
    <span class="s1">peeked = tuple(take(n</span><span class="s0">, </span><span class="s1">iterator))</span>
    <span class="s0">return </span><span class="s1">peeked</span><span class="s0">, </span><span class="s1">itertools.chain(iter(peeked)</span><span class="s0">, </span><span class="s1">iterator)</span>


<span class="s0">def </span><span class="s1">random_sample(prob</span><span class="s0">, </span><span class="s1">seq</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s3">&quot;&quot;&quot; Return elements from a sequence with probability of prob 
 
    Returns a lazy iterator of random items from seq. 
 
    ``random_sample`` considers each item independently and without 
    replacement. See below how the first time it returned 13 items and the 
    next time it returned 6 items. 
 
    &gt;&gt;&gt; seq = list(range(100)) 
    &gt;&gt;&gt; list(random_sample(0.1, seq)) # doctest: +SKIP 
    [6, 9, 19, 35, 45, 50, 58, 62, 68, 72, 78, 86, 95] 
    &gt;&gt;&gt; list(random_sample(0.1, seq)) # doctest: +SKIP 
    [6, 44, 54, 61, 69, 94] 
 
    Providing an integer seed for ``random_state`` will result in 
    deterministic sampling. Given the same seed it will return the same sample 
    every time. 
 
    &gt;&gt;&gt; list(random_sample(0.1, seq, random_state=2016)) 
    [7, 9, 19, 25, 30, 32, 34, 48, 59, 60, 81, 98] 
    &gt;&gt;&gt; list(random_sample(0.1, seq, random_state=2016)) 
    [7, 9, 19, 25, 30, 32, 34, 48, 59, 60, 81, 98] 
 
    ``random_state`` can also be any object with a method ``random`` that 
    returns floats between 0.0 and 1.0 (exclusive). 
 
    &gt;&gt;&gt; from random import Random 
    &gt;&gt;&gt; randobj = Random(2016) 
    &gt;&gt;&gt; list(random_sample(0.1, seq, random_state=randobj)) 
    [7, 9, 19, 25, 30, 32, 34, 48, 59, 60, 81, 98] 
    &quot;&quot;&quot;</span>
    <span class="s0">if not </span><span class="s1">hasattr(random_state</span><span class="s0">, </span><span class="s2">'random'</span><span class="s1">):</span>
        <span class="s0">from </span><span class="s1">random </span><span class="s0">import </span><span class="s1">Random</span>

        <span class="s1">random_state = Random(random_state)</span>
    <span class="s0">return </span><span class="s1">filter(</span><span class="s0">lambda </span><span class="s1">_: random_state.random() &lt; prob</span><span class="s0">, </span><span class="s1">seq)</span>
</pre>
</body>
</html>