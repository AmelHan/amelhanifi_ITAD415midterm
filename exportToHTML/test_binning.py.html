<html>
<head>
<title>test_binning.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6897bb;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_binning.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">pytest</span>
<span class="s0">from </span><span class="s1">numpy.testing </span><span class="s0">import </span><span class="s1">assert_allclose</span><span class="s0">, </span><span class="s1">assert_array_equal</span>

<span class="s0">from </span><span class="s1">sklearn.ensemble._hist_gradient_boosting.binning </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">_BinMapper</span><span class="s0">,</span>
    <span class="s1">_find_binning_thresholds</span><span class="s0">,</span>
    <span class="s1">_map_to_bins</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">sklearn.ensemble._hist_gradient_boosting.common </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">ALMOST_INF</span><span class="s0">,</span>
    <span class="s1">X_BINNED_DTYPE</span><span class="s0">,</span>
    <span class="s1">X_DTYPE</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">sklearn.utils._openmp_helpers </span><span class="s0">import </span><span class="s1">_openmp_effective_n_threads</span>

<span class="s1">n_threads = _openmp_effective_n_threads()</span>


<span class="s1">DATA = (</span>
    <span class="s1">np.random.RandomState(</span><span class="s2">42</span><span class="s1">)</span>
    <span class="s1">.normal(loc=[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">10</span><span class="s1">]</span><span class="s0">, </span><span class="s1">scale=[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0.01</span><span class="s1">]</span><span class="s0">, </span><span class="s1">size=(int(</span><span class="s2">1e6</span><span class="s1">)</span><span class="s0">, </span><span class="s2">2</span><span class="s1">))</span>
    <span class="s1">.astype(X_DTYPE)</span>
<span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_find_binning_thresholds_regular_data():</span>
    <span class="s1">data = np.linspace(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">1001</span><span class="s1">)</span>
    <span class="s1">bin_thresholds = _find_binning_thresholds(data</span><span class="s0">, </span><span class="s1">max_bins=</span><span class="s2">10</span><span class="s1">)</span>
    <span class="s1">assert_allclose(bin_thresholds</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">9</span><span class="s1">])</span>

    <span class="s1">bin_thresholds = _find_binning_thresholds(data</span><span class="s0">, </span><span class="s1">max_bins=</span><span class="s2">5</span><span class="s1">)</span>
    <span class="s1">assert_allclose(bin_thresholds</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">8</span><span class="s1">])</span>


<span class="s0">def </span><span class="s1">test_find_binning_thresholds_small_regular_data():</span>
    <span class="s1">data = np.linspace(</span><span class="s2">0</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">11</span><span class="s1">)</span>

    <span class="s1">bin_thresholds = _find_binning_thresholds(data</span><span class="s0">, </span><span class="s1">max_bins=</span><span class="s2">5</span><span class="s1">)</span>
    <span class="s1">assert_allclose(bin_thresholds</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">8</span><span class="s1">])</span>

    <span class="s1">bin_thresholds = _find_binning_thresholds(data</span><span class="s0">, </span><span class="s1">max_bins=</span><span class="s2">10</span><span class="s1">)</span>
    <span class="s1">assert_allclose(bin_thresholds</span><span class="s0">, </span><span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">6</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s2">8</span><span class="s0">, </span><span class="s2">9</span><span class="s1">])</span>

    <span class="s1">bin_thresholds = _find_binning_thresholds(data</span><span class="s0">, </span><span class="s1">max_bins=</span><span class="s2">11</span><span class="s1">)</span>
    <span class="s1">assert_allclose(bin_thresholds</span><span class="s0">, </span><span class="s1">np.arange(</span><span class="s2">10</span><span class="s1">) + </span><span class="s2">0.5</span><span class="s1">)</span>

    <span class="s1">bin_thresholds = _find_binning_thresholds(data</span><span class="s0">, </span><span class="s1">max_bins=</span><span class="s2">255</span><span class="s1">)</span>
    <span class="s1">assert_allclose(bin_thresholds</span><span class="s0">, </span><span class="s1">np.arange(</span><span class="s2">10</span><span class="s1">) + </span><span class="s2">0.5</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_find_binning_thresholds_random_data():</span>
    <span class="s1">bin_thresholds = [</span>
        <span class="s1">_find_binning_thresholds(DATA[:</span><span class="s0">, </span><span class="s1">i]</span><span class="s0">, </span><span class="s1">max_bins=</span><span class="s2">255</span><span class="s1">) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">2</span><span class="s1">)</span>
    <span class="s1">]</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(bin_thresholds)):</span>
        <span class="s0">assert </span><span class="s1">bin_thresholds[i].shape == (</span><span class="s2">254</span><span class="s0">,</span><span class="s1">)  </span><span class="s3"># 255 - 1</span>
        <span class="s0">assert </span><span class="s1">bin_thresholds[i].dtype == DATA.dtype</span>

    <span class="s1">assert_allclose(</span>
        <span class="s1">bin_thresholds[</span><span class="s2">0</span><span class="s1">][[</span><span class="s2">64</span><span class="s0">, </span><span class="s2">128</span><span class="s0">, </span><span class="s2">192</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">np.array([-</span><span class="s2">0.7</span><span class="s0">, </span><span class="s2">0.0</span><span class="s0">, </span><span class="s2">0.7</span><span class="s1">])</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-1</span>
    <span class="s1">)</span>

    <span class="s1">assert_allclose(</span>
        <span class="s1">bin_thresholds[</span><span class="s2">1</span><span class="s1">][[</span><span class="s2">64</span><span class="s0">, </span><span class="s2">128</span><span class="s0">, </span><span class="s2">192</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s2">9.99</span><span class="s0">, </span><span class="s2">10.00</span><span class="s0">, </span><span class="s2">10.01</span><span class="s1">])</span><span class="s0">, </span><span class="s1">atol=</span><span class="s2">1e-2</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_find_binning_thresholds_low_n_bins():</span>
    <span class="s1">bin_thresholds = [</span>
        <span class="s1">_find_binning_thresholds(DATA[:</span><span class="s0">, </span><span class="s1">i]</span><span class="s0">, </span><span class="s1">max_bins=</span><span class="s2">128</span><span class="s1">) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">2</span><span class="s1">)</span>
    <span class="s1">]</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(bin_thresholds)):</span>
        <span class="s0">assert </span><span class="s1">bin_thresholds[i].shape == (</span><span class="s2">127</span><span class="s0">,</span><span class="s1">)  </span><span class="s3"># 128 - 1</span>
        <span class="s0">assert </span><span class="s1">bin_thresholds[i].dtype == DATA.dtype</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;n_bins&quot;</span><span class="s0">, </span><span class="s1">(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">257</span><span class="s1">))</span>
<span class="s0">def </span><span class="s1">test_invalid_n_bins(n_bins):</span>
    <span class="s1">err_msg = </span><span class="s4">&quot;n_bins={} should be no smaller than 3 and no larger than 256&quot;</span><span class="s1">.format(</span>
        <span class="s1">n_bins</span>
    <span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=err_msg):</span>
        <span class="s1">_BinMapper(n_bins=n_bins).fit(DATA)</span>


<span class="s0">def </span><span class="s1">test_bin_mapper_n_features_transform():</span>
    <span class="s1">mapper = _BinMapper(n_bins=</span><span class="s2">42</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s2">42</span><span class="s1">).fit(DATA)</span>
    <span class="s1">err_msg = </span><span class="s4">&quot;This estimator was fitted with 2 features but 4 got passed&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=err_msg):</span>
        <span class="s1">mapper.transform(np.repeat(DATA</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s1">axis=</span><span class="s2">1</span><span class="s1">))</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;max_bins&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">16</span><span class="s0">, </span><span class="s2">128</span><span class="s0">, </span><span class="s2">255</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_map_to_bins(max_bins):</span>
    <span class="s1">bin_thresholds = [</span>
        <span class="s1">_find_binning_thresholds(DATA[:</span><span class="s0">, </span><span class="s1">i]</span><span class="s0">, </span><span class="s1">max_bins=max_bins) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s2">2</span><span class="s1">)</span>
    <span class="s1">]</span>
    <span class="s1">binned = np.zeros_like(DATA</span><span class="s0">, </span><span class="s1">dtype=X_BINNED_DTYPE</span><span class="s0">, </span><span class="s1">order=</span><span class="s4">&quot;F&quot;</span><span class="s1">)</span>
    <span class="s1">is_categorical = np.zeros(</span><span class="s2">2</span><span class="s0">, </span><span class="s1">dtype=np.uint8)</span>
    <span class="s1">last_bin_idx = max_bins</span>
    <span class="s1">_map_to_bins(DATA</span><span class="s0">, </span><span class="s1">bin_thresholds</span><span class="s0">, </span><span class="s1">is_categorical</span><span class="s0">, </span><span class="s1">last_bin_idx</span><span class="s0">, </span><span class="s1">n_threads</span><span class="s0">, </span><span class="s1">binned)</span>
    <span class="s0">assert </span><span class="s1">binned.shape == DATA.shape</span>
    <span class="s0">assert </span><span class="s1">binned.dtype == np.uint8</span>
    <span class="s0">assert </span><span class="s1">binned.flags.f_contiguous</span>

    <span class="s1">min_indices = DATA.argmin(axis=</span><span class="s2">0</span><span class="s1">)</span>
    <span class="s1">max_indices = DATA.argmax(axis=</span><span class="s2">0</span><span class="s1">)</span>

    <span class="s0">for </span><span class="s1">feature_idx</span><span class="s0">, </span><span class="s1">min_idx </span><span class="s0">in </span><span class="s1">enumerate(min_indices):</span>
        <span class="s0">assert </span><span class="s1">binned[min_idx</span><span class="s0">, </span><span class="s1">feature_idx] == </span><span class="s2">0</span>
    <span class="s0">for </span><span class="s1">feature_idx</span><span class="s0">, </span><span class="s1">max_idx </span><span class="s0">in </span><span class="s1">enumerate(max_indices):</span>
        <span class="s0">assert </span><span class="s1">binned[max_idx</span><span class="s0">, </span><span class="s1">feature_idx] == max_bins - </span><span class="s2">1</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;max_bins&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">5</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">42</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_bin_mapper_random_data(max_bins):</span>
    <span class="s1">n_samples</span><span class="s0">, </span><span class="s1">n_features = DATA.shape</span>

    <span class="s1">expected_count_per_bin = n_samples // max_bins</span>
    <span class="s1">tol = int(</span><span class="s2">0.05 </span><span class="s1">* expected_count_per_bin)</span>

    <span class="s3"># max_bins is the number of bins for non-missing values</span>
    <span class="s1">n_bins = max_bins + </span><span class="s2">1</span>
    <span class="s1">mapper = _BinMapper(n_bins=n_bins</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s2">42</span><span class="s1">).fit(DATA)</span>
    <span class="s1">binned = mapper.transform(DATA)</span>

    <span class="s0">assert </span><span class="s1">binned.shape == (n_samples</span><span class="s0">, </span><span class="s1">n_features)</span>
    <span class="s0">assert </span><span class="s1">binned.dtype == np.uint8</span>
    <span class="s1">assert_array_equal(binned.min(axis=</span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.array([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]))</span>
    <span class="s1">assert_array_equal(binned.max(axis=</span><span class="s2">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.array([max_bins - </span><span class="s2">1</span><span class="s0">, </span><span class="s1">max_bins - </span><span class="s2">1</span><span class="s1">]))</span>
    <span class="s0">assert </span><span class="s1">len(mapper.bin_thresholds_) == n_features</span>
    <span class="s0">for </span><span class="s1">bin_thresholds_feature </span><span class="s0">in </span><span class="s1">mapper.bin_thresholds_:</span>
        <span class="s0">assert </span><span class="s1">bin_thresholds_feature.shape == (max_bins - </span><span class="s2">1</span><span class="s0">,</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">bin_thresholds_feature.dtype == DATA.dtype</span>
    <span class="s0">assert </span><span class="s1">np.all(mapper.n_bins_non_missing_ == max_bins)</span>

    <span class="s3"># Check that the binned data is approximately balanced across bins.</span>
    <span class="s0">for </span><span class="s1">feature_idx </span><span class="s0">in </span><span class="s1">range(n_features):</span>
        <span class="s0">for </span><span class="s1">bin_idx </span><span class="s0">in </span><span class="s1">range(max_bins):</span>
            <span class="s1">count = (binned[:</span><span class="s0">, </span><span class="s1">feature_idx] == bin_idx).sum()</span>
            <span class="s0">assert </span><span class="s1">abs(count - expected_count_per_bin) &lt; tol</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;n_samples, max_bins&quot;</span><span class="s0">, </span><span class="s1">[(</span><span class="s2">5</span><span class="s0">, </span><span class="s2">5</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">5</span><span class="s0">, </span><span class="s2">10</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">5</span><span class="s0">, </span><span class="s2">11</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(</span><span class="s2">42</span><span class="s0">, </span><span class="s2">255</span><span class="s1">)])</span>
<span class="s0">def </span><span class="s1">test_bin_mapper_small_random_data(n_samples</span><span class="s0">, </span><span class="s1">max_bins):</span>
    <span class="s1">data = np.random.RandomState(</span><span class="s2">42</span><span class="s1">).normal(size=n_samples).reshape(-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">len(np.unique(data)) == n_samples</span>

    <span class="s3"># max_bins is the number of bins for non-missing values</span>
    <span class="s1">n_bins = max_bins + </span><span class="s2">1</span>
    <span class="s1">mapper = _BinMapper(n_bins=n_bins</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s2">42</span><span class="s1">)</span>
    <span class="s1">binned = mapper.fit_transform(data)</span>

    <span class="s0">assert </span><span class="s1">binned.shape == data.shape</span>
    <span class="s0">assert </span><span class="s1">binned.dtype == np.uint8</span>
    <span class="s1">assert_array_equal(binned.ravel()[np.argsort(data.ravel())]</span><span class="s0">, </span><span class="s1">np.arange(n_samples))</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s4">&quot;max_bins, n_distinct, multiplier&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span><span class="s2">5</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">5</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">255</span><span class="s0">, </span><span class="s2">12</span><span class="s0">, </span><span class="s2">42</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_bin_mapper_identity_repeated_values(max_bins</span><span class="s0">, </span><span class="s1">n_distinct</span><span class="s0">, </span><span class="s1">multiplier):</span>
    <span class="s1">data = np.array(list(range(n_distinct)) * multiplier).reshape(-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
    <span class="s3"># max_bins is the number of bins for non-missing values</span>
    <span class="s1">n_bins = max_bins + </span><span class="s2">1</span>
    <span class="s1">binned = _BinMapper(n_bins=n_bins).fit_transform(data)</span>
    <span class="s1">assert_array_equal(data</span><span class="s0">, </span><span class="s1">binned)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;n_distinct&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s2">42</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_bin_mapper_repeated_values_invariance(n_distinct):</span>
    <span class="s1">rng = np.random.RandomState(</span><span class="s2">42</span><span class="s1">)</span>
    <span class="s1">distinct_values = rng.normal(size=n_distinct)</span>
    <span class="s0">assert </span><span class="s1">len(np.unique(distinct_values)) == n_distinct</span>

    <span class="s1">repeated_indices = rng.randint(low=</span><span class="s2">0</span><span class="s0">, </span><span class="s1">high=n_distinct</span><span class="s0">, </span><span class="s1">size=</span><span class="s2">1000</span><span class="s1">)</span>
    <span class="s1">data = distinct_values[repeated_indices]</span>
    <span class="s1">rng.shuffle(data)</span>
    <span class="s1">assert_array_equal(np.unique(data)</span><span class="s0">, </span><span class="s1">np.sort(distinct_values))</span>

    <span class="s1">data = data.reshape(-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>

    <span class="s1">mapper_1 = _BinMapper(n_bins=n_distinct + </span><span class="s2">1</span><span class="s1">)</span>
    <span class="s1">binned_1 = mapper_1.fit_transform(data)</span>
    <span class="s1">assert_array_equal(np.unique(binned_1[:</span><span class="s0">, </span><span class="s2">0</span><span class="s1">])</span><span class="s0">, </span><span class="s1">np.arange(n_distinct))</span>

    <span class="s3"># Adding more bins to the mapper yields the same results (same thresholds)</span>
    <span class="s1">mapper_2 = _BinMapper(n_bins=min(</span><span class="s2">256</span><span class="s0">, </span><span class="s1">n_distinct * </span><span class="s2">3</span><span class="s1">) + </span><span class="s2">1</span><span class="s1">)</span>
    <span class="s1">binned_2 = mapper_2.fit_transform(data)</span>

    <span class="s1">assert_allclose(mapper_1.bin_thresholds_[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">mapper_2.bin_thresholds_[</span><span class="s2">0</span><span class="s1">])</span>
    <span class="s1">assert_array_equal(binned_1</span><span class="s0">, </span><span class="s1">binned_2)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s4">&quot;max_bins, scale, offset&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">42</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">255</span><span class="s0">, </span><span class="s2">0.3</span><span class="s0">, </span><span class="s2">42</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_bin_mapper_identity_small(max_bins</span><span class="s0">, </span><span class="s1">scale</span><span class="s0">, </span><span class="s1">offset):</span>
    <span class="s1">data = np.arange(max_bins).reshape(-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">) * scale + offset</span>
    <span class="s3"># max_bins is the number of bins for non-missing values</span>
    <span class="s1">n_bins = max_bins + </span><span class="s2">1</span>
    <span class="s1">binned = _BinMapper(n_bins=n_bins).fit_transform(data)</span>
    <span class="s1">assert_array_equal(binned</span><span class="s0">, </span><span class="s1">np.arange(max_bins).reshape(-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">))</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s4">&quot;max_bins_small, max_bins_large&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">4</span><span class="s0">, </span><span class="s2">4</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">42</span><span class="s0">, </span><span class="s2">42</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">255</span><span class="s0">, </span><span class="s2">255</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">5</span><span class="s0">, </span><span class="s2">17</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span><span class="s2">42</span><span class="s0">, </span><span class="s2">255</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_bin_mapper_idempotence(max_bins_small</span><span class="s0">, </span><span class="s1">max_bins_large):</span>
    <span class="s0">assert </span><span class="s1">max_bins_large &gt;= max_bins_small</span>
    <span class="s1">data = np.random.RandomState(</span><span class="s2">42</span><span class="s1">).normal(size=</span><span class="s2">30000</span><span class="s1">).reshape(-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
    <span class="s1">mapper_small = _BinMapper(n_bins=max_bins_small + </span><span class="s2">1</span><span class="s1">)</span>
    <span class="s1">mapper_large = _BinMapper(n_bins=max_bins_small + </span><span class="s2">1</span><span class="s1">)</span>
    <span class="s1">binned_small = mapper_small.fit_transform(data)</span>
    <span class="s1">binned_large = mapper_large.fit_transform(binned_small)</span>
    <span class="s1">assert_array_equal(binned_small</span><span class="s0">, </span><span class="s1">binned_large)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;n_bins&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">10</span><span class="s0">, </span><span class="s2">100</span><span class="s0">, </span><span class="s2">256</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;diff&quot;</span><span class="s0">, </span><span class="s1">[-</span><span class="s2">5</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">5</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_n_bins_non_missing(n_bins</span><span class="s0">, </span><span class="s1">diff):</span>
    <span class="s3"># Check that n_bins_non_missing is n_unique_values when</span>
    <span class="s3"># there are not a lot of unique values, else n_bins - 1.</span>

    <span class="s1">n_unique_values = n_bins + diff</span>
    <span class="s1">X = list(range(n_unique_values)) * </span><span class="s2">2</span>
    <span class="s1">X = np.array(X).reshape(-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
    <span class="s1">mapper = _BinMapper(n_bins=n_bins).fit(X)</span>
    <span class="s0">assert </span><span class="s1">np.all(mapper.n_bins_non_missing_ == min(n_bins - </span><span class="s2">1</span><span class="s0">, </span><span class="s1">n_unique_values))</span>


<span class="s0">def </span><span class="s1">test_subsample():</span>
    <span class="s3"># Make sure bin thresholds are different when applying subsampling</span>
    <span class="s1">mapper_no_subsample = _BinMapper(subsample=</span><span class="s0">None, </span><span class="s1">random_state=</span><span class="s2">0</span><span class="s1">).fit(DATA)</span>
    <span class="s1">mapper_subsample = _BinMapper(subsample=</span><span class="s2">256</span><span class="s0">, </span><span class="s1">random_state=</span><span class="s2">0</span><span class="s1">).fit(DATA)</span>

    <span class="s0">for </span><span class="s1">feature </span><span class="s0">in </span><span class="s1">range(DATA.shape[</span><span class="s2">1</span><span class="s1">]):</span>
        <span class="s0">assert not </span><span class="s1">np.allclose(</span>
            <span class="s1">mapper_no_subsample.bin_thresholds_[feature]</span><span class="s0">,</span>
            <span class="s1">mapper_subsample.bin_thresholds_[feature]</span><span class="s0">,</span>
            <span class="s1">rtol=</span><span class="s2">1e-4</span><span class="s0">,</span>
        <span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s4">&quot;n_bins, n_bins_non_missing, X_trans_expected&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span>
            <span class="s2">256</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s2">4</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span>
                <span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,  </span><span class="s3"># 255 &lt;=&gt; missing value</span>
                <span class="s1">[</span><span class="s2">255</span><span class="s0">, </span><span class="s2">255</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">255</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span>
            <span class="s2">3</span><span class="s0">,</span>
            <span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">[</span>
                <span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,  </span><span class="s3"># 2 &lt;=&gt; missing value</span>
                <span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
                <span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">]</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_missing_values_support(n_bins</span><span class="s0">, </span><span class="s1">n_bins_non_missing</span><span class="s0">, </span><span class="s1">X_trans_expected):</span>
    <span class="s3"># check for missing values: make sure nans are mapped to the last bin</span>
    <span class="s3"># and that the _BinMapper attributes are correct</span>

    <span class="s1">X = [</span>
        <span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[np.nan</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[np.nan</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">4</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">]</span>

    <span class="s1">X = np.array(X)</span>

    <span class="s1">mapper = _BinMapper(n_bins=n_bins)</span>
    <span class="s1">mapper.fit(X)</span>

    <span class="s1">assert_array_equal(mapper.n_bins_non_missing_</span><span class="s0">, </span><span class="s1">n_bins_non_missing)</span>

    <span class="s0">for </span><span class="s1">feature_idx </span><span class="s0">in </span><span class="s1">range(X.shape[</span><span class="s2">1</span><span class="s1">]):</span>
        <span class="s0">assert </span><span class="s1">(</span>
            <span class="s1">len(mapper.bin_thresholds_[feature_idx])</span>
            <span class="s1">== n_bins_non_missing[feature_idx] - </span><span class="s2">1</span>
        <span class="s1">)</span>

    <span class="s0">assert </span><span class="s1">mapper.missing_values_bin_idx_ == n_bins - </span><span class="s2">1</span>

    <span class="s1">X_trans = mapper.transform(X)</span>
    <span class="s1">assert_array_equal(X_trans</span><span class="s0">, </span><span class="s1">X_trans_expected)</span>


<span class="s0">def </span><span class="s1">test_infinite_values():</span>
    <span class="s3"># Make sure infinite values are properly handled.</span>
    <span class="s1">bin_mapper = _BinMapper()</span>

    <span class="s1">X = np.array([-np.inf</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s1">np.inf]).reshape(-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>

    <span class="s1">bin_mapper.fit(X)</span>
    <span class="s1">assert_allclose(bin_mapper.bin_thresholds_[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[-np.inf</span><span class="s0">, </span><span class="s2">0.5</span><span class="s0">, </span><span class="s1">ALMOST_INF])</span>
    <span class="s0">assert </span><span class="s1">bin_mapper.n_bins_non_missing_ == [</span><span class="s2">4</span><span class="s1">]</span>

    <span class="s1">expected_binned_X = np.array([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]).reshape(-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)</span>
    <span class="s1">assert_array_equal(bin_mapper.transform(X)</span><span class="s0">, </span><span class="s1">expected_binned_X)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;n_bins&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">15</span><span class="s0">, </span><span class="s2">256</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_categorical_feature(n_bins):</span>
    <span class="s3"># Basic test for categorical features</span>
    <span class="s3"># we make sure that categories are mapped into [0, n_categories - 1] and</span>
    <span class="s3"># that nans are mapped to the last bin</span>
    <span class="s1">X = np.array(</span>
        <span class="s1">[[</span><span class="s2">4</span><span class="s1">] * </span><span class="s2">500 </span><span class="s1">+ [</span><span class="s2">1</span><span class="s1">] * </span><span class="s2">3 </span><span class="s1">+ [</span><span class="s2">10</span><span class="s1">] * </span><span class="s2">4 </span><span class="s1">+ [</span><span class="s2">0</span><span class="s1">] * </span><span class="s2">4 </span><span class="s1">+ [</span><span class="s2">13</span><span class="s1">] + [</span><span class="s2">7</span><span class="s1">] * </span><span class="s2">5 </span><span class="s1">+ [np.nan] * </span><span class="s2">2</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">dtype=X_DTYPE</span><span class="s0">,</span>
    <span class="s1">).T</span>
    <span class="s1">known_categories = [np.unique(X[~np.isnan(X)])]</span>

    <span class="s1">bin_mapper = _BinMapper(</span>
        <span class="s1">n_bins=n_bins</span><span class="s0">,</span>
        <span class="s1">is_categorical=np.array([</span><span class="s0">True</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">known_categories=known_categories</span><span class="s0">,</span>
    <span class="s1">).fit(X)</span>
    <span class="s0">assert </span><span class="s1">bin_mapper.n_bins_non_missing_ == [</span><span class="s2">6</span><span class="s1">]</span>
    <span class="s1">assert_array_equal(bin_mapper.bin_thresholds_[</span><span class="s2">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">13</span><span class="s1">])</span>

    <span class="s1">X = np.array([[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s2">7</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">13</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">dtype=X_DTYPE).T</span>
    <span class="s1">expected_trans = np.array([[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s1">n_bins - </span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]]).T</span>
    <span class="s1">assert_array_equal(bin_mapper.transform(X)</span><span class="s0">, </span><span class="s1">expected_trans)</span>

    <span class="s3"># Negative categories are mapped to the missing values' bin</span>
    <span class="s3"># (i.e. the bin of index `missing_values_bin_idx_ == n_bins - 1).</span>
    <span class="s3"># Unknown positive categories does not happen in practice and tested</span>
    <span class="s3"># for illustration purpose.</span>
    <span class="s1">X = np.array([[-</span><span class="s2">4</span><span class="s0">, </span><span class="s1">-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">100</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">dtype=X_DTYPE).T</span>
    <span class="s1">expected_trans = np.array([[n_bins - </span><span class="s2">1</span><span class="s0">, </span><span class="s1">n_bins - </span><span class="s2">1</span><span class="s0">, </span><span class="s2">6</span><span class="s1">]]).T</span>
    <span class="s1">assert_array_equal(bin_mapper.transform(X)</span><span class="s0">, </span><span class="s1">expected_trans)</span>


<span class="s0">def </span><span class="s1">test_categorical_feature_negative_missing():</span>
    <span class="s5">&quot;&quot;&quot;Make sure bin mapper treats negative categories as missing values.&quot;&quot;&quot;</span>
    <span class="s1">X = np.array(</span>
        <span class="s1">[[</span><span class="s2">4</span><span class="s1">] * </span><span class="s2">500 </span><span class="s1">+ [</span><span class="s2">1</span><span class="s1">] * </span><span class="s2">3 </span><span class="s1">+ [</span><span class="s2">5</span><span class="s1">] * </span><span class="s2">10 </span><span class="s1">+ [-</span><span class="s2">1</span><span class="s1">] * </span><span class="s2">3 </span><span class="s1">+ [np.nan] * </span><span class="s2">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=X_DTYPE</span>
    <span class="s1">).T</span>
    <span class="s1">bin_mapper = _BinMapper(</span>
        <span class="s1">n_bins=</span><span class="s2">4</span><span class="s0">,</span>
        <span class="s1">is_categorical=np.array([</span><span class="s0">True</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">known_categories=[np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=X_DTYPE)]</span><span class="s0">,</span>
    <span class="s1">).fit(X)</span>

    <span class="s0">assert </span><span class="s1">bin_mapper.n_bins_non_missing_ == [</span><span class="s2">3</span><span class="s1">]</span>

    <span class="s1">X = np.array([[-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">3</span><span class="s0">, </span><span class="s2">5</span><span class="s0">, </span><span class="s1">np.nan]]</span><span class="s0">, </span><span class="s1">dtype=X_DTYPE).T</span>

    <span class="s3"># Negative values for categorical features are considered as missing values.</span>
    <span class="s3"># They are mapped to the bin of index `bin_mapper.missing_values_bin_idx_`,</span>
    <span class="s3"># which is 3 here.</span>
    <span class="s0">assert </span><span class="s1">bin_mapper.missing_values_bin_idx_ == </span><span class="s2">3</span>
    <span class="s1">expected_trans = np.array([[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]]).T</span>
    <span class="s1">assert_array_equal(bin_mapper.transform(X)</span><span class="s0">, </span><span class="s1">expected_trans)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;n_bins&quot;</span><span class="s0">, </span><span class="s1">(</span><span class="s2">128</span><span class="s0">, </span><span class="s2">256</span><span class="s1">))</span>
<span class="s0">def </span><span class="s1">test_categorical_with_numerical_features(n_bins):</span>
    <span class="s3"># basic check for binmapper with mixed data</span>
    <span class="s1">X1 = np.arange(</span><span class="s2">10</span><span class="s0">, </span><span class="s2">20</span><span class="s1">).reshape(-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)  </span><span class="s3"># numerical</span>
    <span class="s1">X2 = np.arange(</span><span class="s2">10</span><span class="s0">, </span><span class="s2">15</span><span class="s1">).reshape(-</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">)  </span><span class="s3"># categorical</span>
    <span class="s1">X2 = np.r_[X2</span><span class="s0">, </span><span class="s1">X2]</span>
    <span class="s1">X = np.c_[X1</span><span class="s0">, </span><span class="s1">X2]</span>
    <span class="s1">known_categories = [</span><span class="s0">None, </span><span class="s1">np.unique(X2).astype(X_DTYPE)]</span>

    <span class="s1">bin_mapper = _BinMapper(</span>
        <span class="s1">n_bins=n_bins</span><span class="s0">,</span>
        <span class="s1">is_categorical=np.array([</span><span class="s0">False, True</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">known_categories=known_categories</span><span class="s0">,</span>
    <span class="s1">).fit(X)</span>

    <span class="s1">assert_array_equal(bin_mapper.n_bins_non_missing_</span><span class="s0">, </span><span class="s1">[</span><span class="s2">10</span><span class="s0">, </span><span class="s2">5</span><span class="s1">])</span>

    <span class="s1">bin_thresholds = bin_mapper.bin_thresholds_</span>
    <span class="s0">assert </span><span class="s1">len(bin_thresholds) == </span><span class="s2">2</span>
    <span class="s1">assert_array_equal(bin_thresholds[</span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.arange(</span><span class="s2">10</span><span class="s0">, </span><span class="s2">15</span><span class="s1">))</span>

    <span class="s1">expected_X_trans = [</span>
        <span class="s1">[</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">2</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">3</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">4</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">5</span><span class="s0">, </span><span class="s2">0</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">6</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">7</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">8</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">9</span><span class="s0">, </span><span class="s2">4</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">]</span>
    <span class="s1">assert_array_equal(bin_mapper.transform(X)</span><span class="s0">, </span><span class="s1">expected_X_trans)</span>


<span class="s0">def </span><span class="s1">test_make_known_categories_bitsets():</span>
    <span class="s3"># Check the output of make_known_categories_bitsets</span>
    <span class="s1">X = np.array(</span>
        <span class="s1">[[</span><span class="s2">14</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">30</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">30</span><span class="s0">, </span><span class="s2">4</span><span class="s0">, </span><span class="s2">70</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">40</span><span class="s0">, </span><span class="s2">10</span><span class="s0">, </span><span class="s2">180</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">40</span><span class="s0">, </span><span class="s2">240</span><span class="s0">, </span><span class="s2">180</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">dtype=X_DTYPE</span>
    <span class="s1">)</span>

    <span class="s1">bin_mapper = _BinMapper(</span>
        <span class="s1">n_bins=</span><span class="s2">256</span><span class="s0">,</span>
        <span class="s1">is_categorical=np.array([</span><span class="s0">False, True, True</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">known_categories=[</span><span class="s0">None, </span><span class="s1">X[:</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">X[:</span><span class="s0">, </span><span class="s2">2</span><span class="s1">]]</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">bin_mapper.fit(X)</span>

    <span class="s1">known_cat_bitsets</span><span class="s0">, </span><span class="s1">f_idx_map = bin_mapper.make_known_categories_bitsets()</span>

    <span class="s3"># Note that for non-categorical features, values are left to 0</span>
    <span class="s1">expected_f_idx_map = np.array([</span><span class="s2">0</span><span class="s0">, </span><span class="s2">0</span><span class="s0">, </span><span class="s2">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.uint8)</span>
    <span class="s1">assert_allclose(expected_f_idx_map</span><span class="s0">, </span><span class="s1">f_idx_map)</span>

    <span class="s1">expected_cat_bitset = np.zeros((</span><span class="s2">2</span><span class="s0">, </span><span class="s2">8</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=np.uint32)</span>

    <span class="s3"># first categorical feature: [2, 4, 10, 240]</span>
    <span class="s1">f_idx = </span><span class="s2">1</span>
    <span class="s1">mapped_f_idx = f_idx_map[f_idx]</span>
    <span class="s1">expected_cat_bitset[mapped_f_idx</span><span class="s0">, </span><span class="s2">0</span><span class="s1">] = </span><span class="s2">2</span><span class="s1">**</span><span class="s2">2 </span><span class="s1">+ </span><span class="s2">2</span><span class="s1">**</span><span class="s2">4 </span><span class="s1">+ </span><span class="s2">2</span><span class="s1">**</span><span class="s2">10</span>
    <span class="s3"># 240 = 32**7 + 16, therefore the 16th bit of the 7th array is 1.</span>
    <span class="s1">expected_cat_bitset[mapped_f_idx</span><span class="s0">, </span><span class="s2">7</span><span class="s1">] = </span><span class="s2">2</span><span class="s1">**</span><span class="s2">16</span>

    <span class="s3"># second categorical feature [30, 70, 180]</span>
    <span class="s1">f_idx = </span><span class="s2">2</span>
    <span class="s1">mapped_f_idx = f_idx_map[f_idx]</span>
    <span class="s1">expected_cat_bitset[mapped_f_idx</span><span class="s0">, </span><span class="s2">0</span><span class="s1">] = </span><span class="s2">2</span><span class="s1">**</span><span class="s2">30</span>
    <span class="s1">expected_cat_bitset[mapped_f_idx</span><span class="s0">, </span><span class="s2">2</span><span class="s1">] = </span><span class="s2">2</span><span class="s1">**</span><span class="s2">6</span>
    <span class="s1">expected_cat_bitset[mapped_f_idx</span><span class="s0">, </span><span class="s2">5</span><span class="s1">] = </span><span class="s2">2</span><span class="s1">**</span><span class="s2">20</span>

    <span class="s1">assert_allclose(expected_cat_bitset</span><span class="s0">, </span><span class="s1">known_cat_bitsets)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s4">&quot;is_categorical, known_categories, match&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(np.array([</span><span class="s0">True</span><span class="s1">])</span><span class="s0">, </span><span class="s1">[</span><span class="s0">None</span><span class="s1">]</span><span class="s0">, </span><span class="s4">&quot;Known categories for feature 0 must be provided&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span>
            <span class="s1">np.array([</span><span class="s0">False</span><span class="s1">])</span><span class="s0">,</span>
            <span class="s1">np.array([</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">])</span><span class="s0">,</span>
            <span class="s4">&quot;isn't marked as a categorical feature, but categories were passed&quot;</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_categorical_parameters(is_categorical</span><span class="s0">, </span><span class="s1">known_categories</span><span class="s0">, </span><span class="s1">match):</span>
    <span class="s3"># test the validation of the is_categorical and known_categories parameters</span>

    <span class="s1">X = np.array([[</span><span class="s2">1</span><span class="s0">, </span><span class="s2">2</span><span class="s0">, </span><span class="s2">3</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">dtype=X_DTYPE)</span>

    <span class="s1">bin_mapper = _BinMapper(</span>
        <span class="s1">is_categorical=is_categorical</span><span class="s0">, </span><span class="s1">known_categories=known_categories</span>
    <span class="s1">)</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=match):</span>
        <span class="s1">bin_mapper.fit(X)</span>
</pre>
</body>
</html>