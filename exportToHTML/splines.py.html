<html>
<head>
<title>splines.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
splines.py</font>
</center></td></tr></table>
<pre><span class="s0"># This file is part of Patsy</span>
<span class="s0"># Copyright (C) 2012-2013 Nathaniel Smith &lt;njs@pobox.com&gt;</span>
<span class="s0"># See file LICENSE.txt for license information.</span>

<span class="s0"># R-compatible spline basis functions</span>

<span class="s0"># These are made available in the patsy.* namespace</span>
<span class="s1">__all__ = [</span><span class="s2">&quot;bs&quot;</span><span class="s1">]</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>

<span class="s3">from </span><span class="s1">patsy.util </span><span class="s3">import </span><span class="s1">have_pandas</span><span class="s3">, </span><span class="s1">no_pickling</span><span class="s3">, </span><span class="s1">assert_no_pickling</span>
<span class="s3">from </span><span class="s1">patsy.state </span><span class="s3">import </span><span class="s1">stateful_transform</span>

<span class="s3">if </span><span class="s1">have_pandas:</span>
    <span class="s3">import </span><span class="s1">pandas</span>

<span class="s3">def </span><span class="s1">_eval_bspline_basis(x</span><span class="s3">, </span><span class="s1">knots</span><span class="s3">, </span><span class="s1">degree):</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s3">from </span><span class="s1">scipy.interpolate </span><span class="s3">import </span><span class="s1">splev</span>
    <span class="s3">except </span><span class="s1">ImportError: </span><span class="s0"># pragma: no cover</span>
        <span class="s3">raise </span><span class="s1">ImportError(</span><span class="s2">&quot;spline functionality requires scipy&quot;</span><span class="s1">)</span>
    <span class="s0"># 'knots' are assumed to be already pre-processed. E.g. usually you</span>
    <span class="s0"># want to include duplicate copies of boundary knots; you should do</span>
    <span class="s0"># that *before* calling this constructor.</span>
    <span class="s1">knots = np.atleast_1d(np.asarray(knots</span><span class="s3">, </span><span class="s1">dtype=float))</span>
    <span class="s3">assert </span><span class="s1">knots.ndim == </span><span class="s4">1</span>
    <span class="s1">knots.sort()</span>
    <span class="s1">degree = int(degree)</span>
    <span class="s1">x = np.atleast_1d(x)</span>
    <span class="s3">if </span><span class="s1">x.ndim == </span><span class="s4">2 </span><span class="s3">and </span><span class="s1">x.shape[</span><span class="s4">1</span><span class="s1">] == </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">x = x[:</span><span class="s3">, </span><span class="s4">0</span><span class="s1">]</span>
    <span class="s3">assert </span><span class="s1">x.ndim == </span><span class="s4">1</span>
    <span class="s0"># XX FIXME: when points fall outside of the boundaries, splev and R seem</span>
    <span class="s0"># to handle them differently. I don't know why yet. So until we understand</span>
    <span class="s0"># this and decide what to do with it, I'm going to play it safe and</span>
    <span class="s0"># disallow such points.</span>
    <span class="s3">if </span><span class="s1">np.min(x) &lt; np.min(knots) </span><span class="s3">or </span><span class="s1">np.max(x) &gt; np.max(knots):</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s2">&quot;some data points fall outside the &quot;</span>
                                  <span class="s2">&quot;outermost knots, and I'm not sure how &quot;</span>
                                  <span class="s2">&quot;to handle them. (Patches accepted!)&quot;</span><span class="s1">)</span>
    <span class="s0"># Thanks to Charles Harris for explaining splev. It's not well</span>
    <span class="s0"># documented, but basically it computes an arbitrary b-spline basis</span>
    <span class="s0"># given knots and degree on some specified points (or derivatives</span>
    <span class="s0"># thereof, but we don't use that functionality), and then returns some</span>
    <span class="s0"># linear combination of these basis functions. To get out the basis</span>
    <span class="s0"># functions themselves, we use linear combinations like [1, 0, 0], [0,</span>
    <span class="s0"># 1, 0], [0, 0, 1].</span>
    <span class="s0"># NB: This probably makes it rather inefficient (though I haven't checked</span>
    <span class="s0"># to be sure -- maybe the fortran code actually skips computing the basis</span>
    <span class="s0"># function for coefficients that are zero).</span>
    <span class="s0"># Note: the order of a spline is the same as its degree + 1.</span>
    <span class="s0"># Note: there are (len(knots) - order) basis functions.</span>
    <span class="s1">n_bases = len(knots) - (degree + </span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">basis = np.empty((x.shape[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">n_bases)</span><span class="s3">, </span><span class="s1">dtype=float)</span>
    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(n_bases):</span>
        <span class="s1">coefs = np.zeros((n_bases</span><span class="s3">,</span><span class="s1">))</span>
        <span class="s1">coefs[i] = </span><span class="s4">1</span>
        <span class="s1">basis[:</span><span class="s3">, </span><span class="s1">i] = splev(x</span><span class="s3">, </span><span class="s1">(knots</span><span class="s3">, </span><span class="s1">coefs</span><span class="s3">, </span><span class="s1">degree))</span>
    <span class="s3">return </span><span class="s1">basis</span>

<span class="s3">def </span><span class="s1">_R_compat_quantile(x</span><span class="s3">, </span><span class="s1">probs):</span>
    <span class="s0">#return np.percentile(x, 100 * np.asarray(probs))</span>
    <span class="s1">probs = np.asarray(probs)</span>
    <span class="s1">quantiles = np.asarray([np.percentile(x</span><span class="s3">, </span><span class="s4">100 </span><span class="s1">* prob)</span>
                            <span class="s3">for </span><span class="s1">prob </span><span class="s3">in </span><span class="s1">probs.ravel(order=</span><span class="s2">&quot;C&quot;</span><span class="s1">)])</span>
    <span class="s3">return </span><span class="s1">quantiles.reshape(probs.shape</span><span class="s3">, </span><span class="s1">order=</span><span class="s2">&quot;C&quot;</span><span class="s1">)</span>

<span class="s3">def </span><span class="s1">test__R_compat_quantile():</span>
    <span class="s3">def </span><span class="s1">t(x</span><span class="s3">, </span><span class="s1">prob</span><span class="s3">, </span><span class="s1">expected):</span>
        <span class="s3">assert </span><span class="s1">np.allclose(_R_compat_quantile(x</span><span class="s3">, </span><span class="s1">prob)</span><span class="s3">, </span><span class="s1">expected)</span>
    <span class="s1">t([</span><span class="s4">10</span><span class="s3">, </span><span class="s4">20</span><span class="s1">]</span><span class="s3">, </span><span class="s4">0.5</span><span class="s3">, </span><span class="s4">15</span><span class="s1">)</span>
    <span class="s1">t([</span><span class="s4">10</span><span class="s3">, </span><span class="s4">20</span><span class="s1">]</span><span class="s3">, </span><span class="s4">0.3</span><span class="s3">, </span><span class="s4">13</span><span class="s1">)</span>
    <span class="s1">t([</span><span class="s4">10</span><span class="s3">, </span><span class="s4">20</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s4">0.3</span><span class="s3">, </span><span class="s4">0.7</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s4">13</span><span class="s3">, </span><span class="s4">17</span><span class="s1">])</span>
    <span class="s1">t(list(range(</span><span class="s4">10</span><span class="s1">))</span><span class="s3">, </span><span class="s1">[</span><span class="s4">0.3</span><span class="s3">, </span><span class="s4">0.7</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s4">2.7</span><span class="s3">, </span><span class="s4">6.3</span><span class="s1">])</span>

<span class="s3">class </span><span class="s1">BS(object):</span>
    <span class="s5">&quot;&quot;&quot;bs(x, df=None, knots=None, degree=3, include_intercept=False, lower_bound=None, upper_bound=None) 
 
    Generates a B-spline basis for ``x``, allowing non-linear fits. The usual 
    usage is something like:: 
 
      y ~ 1 + bs(x, 4) 
 
    to fit ``y`` as a smooth function of ``x``, with 4 degrees of freedom 
    given to the smooth. 
 
    :arg df: The number of degrees of freedom to use for this spline. The 
      return value will have this many columns. You must specify at least one 
      of ``df`` and ``knots``. 
    :arg knots: The interior knots to use for the spline. If unspecified, then 
      equally spaced quantiles of the input data are used. You must specify at 
      least one of ``df`` and ``knots``. 
    :arg degree: The degree of the spline to use. 
    :arg include_intercept: If ``True``, then the resulting 
      spline basis will span the intercept term (i.e., the constant 
      function). If ``False`` (the default) then this will not be the case, 
      which is useful for avoiding overspecification in models that include 
      multiple spline terms and/or an intercept term. 
    :arg lower_bound: The lower exterior knot location. 
    :arg upper_bound: The upper exterior knot location. 
 
    A spline with ``degree=0`` is piecewise constant with breakpoints at each 
    knot, and the default knot positions are quantiles of the input. So if you 
    find yourself in the situation of wanting to quantize a continuous 
    variable into ``num_bins`` equal-sized bins with a constant effect across 
    each bin, you can use ``bs(x, num_bins - 1, degree=0)``. (The ``- 1`` is 
    because one degree of freedom will be taken by the intercept; 
    alternatively, you could leave the intercept term out of your model and 
    use ``bs(x, num_bins, degree=0, include_intercept=True)``. 
 
    A spline with ``degree=1`` is piecewise linear with breakpoints at each 
    knot. 
 
    The default is ``degree=3``, which gives a cubic b-spline. 
 
    This is a stateful transform (for details see 
    :ref:`stateful-transforms`). If ``knots``, ``lower_bound``, or 
    ``upper_bound`` are not specified, they will be calculated from the data 
    and then the chosen values will be remembered and re-used for prediction 
    from the fitted model. 
 
    Using this function requires scipy be installed. 
 
    .. note:: This function is very similar to the R function of the same 
      name. In cases where both return output at all (e.g., R's ``bs`` will 
      raise an error if ``degree=0``, while patsy's will not), they should 
      produce identical output given identical input and parameter settings. 
 
    .. warning:: I'm not sure on what the proper handling of points outside 
      the lower/upper bounds is, so for now attempting to evaluate a spline 
      basis at such points produces an error. Patches gratefully accepted. 
 
    .. versionadded:: 0.2.0 
    &quot;&quot;&quot;</span>
    <span class="s3">def </span><span class="s1">__init__(self):</span>
        <span class="s1">self._tmp = {}</span>
        <span class="s1">self._degree = </span><span class="s3">None</span>
        <span class="s1">self._all_knots = </span><span class="s3">None</span>

    <span class="s3">def </span><span class="s1">memorize_chunk(self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">df=</span><span class="s3">None, </span><span class="s1">knots=</span><span class="s3">None, </span><span class="s1">degree=</span><span class="s4">3</span><span class="s3">,</span>
                       <span class="s1">include_intercept=</span><span class="s3">False,</span>
                       <span class="s1">lower_bound=</span><span class="s3">None, </span><span class="s1">upper_bound=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">args = {</span><span class="s2">&quot;df&quot;</span><span class="s1">: df</span><span class="s3">,</span>
                <span class="s2">&quot;knots&quot;</span><span class="s1">: knots</span><span class="s3">,</span>
                <span class="s2">&quot;degree&quot;</span><span class="s1">: degree</span><span class="s3">,</span>
                <span class="s2">&quot;include_intercept&quot;</span><span class="s1">: include_intercept</span><span class="s3">,</span>
                <span class="s2">&quot;lower_bound&quot;</span><span class="s1">: lower_bound</span><span class="s3">,</span>
                <span class="s2">&quot;upper_bound&quot;</span><span class="s1">: upper_bound</span><span class="s3">,</span>
                <span class="s1">}</span>
        <span class="s1">self._tmp[</span><span class="s2">&quot;args&quot;</span><span class="s1">] = args</span>
        <span class="s0"># XX: check whether we need x values before saving them</span>
        <span class="s1">x = np.atleast_1d(x)</span>
        <span class="s3">if </span><span class="s1">x.ndim == </span><span class="s4">2 </span><span class="s3">and </span><span class="s1">x.shape[</span><span class="s4">1</span><span class="s1">] == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">x = x[:</span><span class="s3">, </span><span class="s4">0</span><span class="s1">]</span>
        <span class="s3">if </span><span class="s1">x.ndim &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;input to 'bs' must be 1-d, &quot;</span>
                             <span class="s2">&quot;or a 2-d column vector&quot;</span><span class="s1">)</span>
        <span class="s0"># There's no better way to compute exact quantiles than memorizing</span>
        <span class="s0"># all data.</span>
        <span class="s1">self._tmp.setdefault(</span><span class="s2">&quot;xs&quot;</span><span class="s3">, </span><span class="s1">[]).append(x)</span>

    <span class="s3">def </span><span class="s1">memorize_finish(self):</span>
        <span class="s1">tmp = self._tmp</span>
        <span class="s1">args = tmp[</span><span class="s2">&quot;args&quot;</span><span class="s1">]</span>
        <span class="s3">del </span><span class="s1">self._tmp</span>

        <span class="s3">if </span><span class="s1">args[</span><span class="s2">&quot;degree&quot;</span><span class="s1">] &lt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;degree must be greater than 0 (not %r)&quot;</span>
                             <span class="s1">% (args[</span><span class="s2">&quot;degree&quot;</span><span class="s1">]</span><span class="s3">,</span><span class="s1">))</span>
        <span class="s3">if </span><span class="s1">int(args[</span><span class="s2">&quot;degree&quot;</span><span class="s1">]) != args[</span><span class="s2">&quot;degree&quot;</span><span class="s1">]:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;degree must be an integer (not %r)&quot;</span>
                             <span class="s1">% (self._degree</span><span class="s3">,</span><span class="s1">))</span>

        <span class="s0"># These are guaranteed to all be 1d vectors by the code above</span>
        <span class="s1">x = np.concatenate(tmp[</span><span class="s2">&quot;xs&quot;</span><span class="s1">])</span>
        <span class="s3">if </span><span class="s1">args[</span><span class="s2">&quot;df&quot;</span><span class="s1">] </span><span class="s3">is None and </span><span class="s1">args[</span><span class="s2">&quot;knots&quot;</span><span class="s1">] </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;must specify either df or knots&quot;</span><span class="s1">)</span>
        <span class="s1">order = args[</span><span class="s2">&quot;degree&quot;</span><span class="s1">] + </span><span class="s4">1</span>
        <span class="s3">if </span><span class="s1">args[</span><span class="s2">&quot;df&quot;</span><span class="s1">] </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">n_inner_knots = args[</span><span class="s2">&quot;df&quot;</span><span class="s1">] - order</span>
            <span class="s3">if not </span><span class="s1">args[</span><span class="s2">&quot;include_intercept&quot;</span><span class="s1">]:</span>
                <span class="s1">n_inner_knots += </span><span class="s4">1</span>
            <span class="s3">if </span><span class="s1">n_inner_knots &lt; </span><span class="s4">0</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;df=%r is too small for degree=%r and &quot;</span>
                                 <span class="s2">&quot;include_intercept=%r; must be &gt;= %s&quot;</span>
                                 <span class="s1">% (args[</span><span class="s2">&quot;df&quot;</span><span class="s1">]</span><span class="s3">, </span><span class="s1">args[</span><span class="s2">&quot;degree&quot;</span><span class="s1">]</span><span class="s3">,</span>
                                    <span class="s1">args[</span><span class="s2">&quot;include_intercept&quot;</span><span class="s1">]</span><span class="s3">,</span>
                                    <span class="s0"># We know that n_inner_knots is negative;</span>
                                    <span class="s0"># if df were that much larger, it would</span>
                                    <span class="s0"># have been zero, and things would work.</span>
                                    <span class="s1">args[</span><span class="s2">&quot;df&quot;</span><span class="s1">] - n_inner_knots))</span>
            <span class="s3">if </span><span class="s1">args[</span><span class="s2">&quot;knots&quot;</span><span class="s1">] </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s3">if </span><span class="s1">len(args[</span><span class="s2">&quot;knots&quot;</span><span class="s1">]) != n_inner_knots:</span>
                    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;df=%s with degree=%r implies %s knots, &quot;</span>
                                     <span class="s2">&quot;but %s knots were provided&quot;</span>
                                     <span class="s1">% (args[</span><span class="s2">&quot;df&quot;</span><span class="s1">]</span><span class="s3">, </span><span class="s1">args[</span><span class="s2">&quot;degree&quot;</span><span class="s1">]</span><span class="s3">,</span>
                                        <span class="s1">n_inner_knots</span><span class="s3">, </span><span class="s1">len(args[</span><span class="s2">&quot;knots&quot;</span><span class="s1">])))</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s0"># Need to compute inner knots</span>
                <span class="s1">knot_quantiles = np.linspace(</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s1">n_inner_knots + </span><span class="s4">2</span><span class="s1">)[</span><span class="s4">1</span><span class="s1">:-</span><span class="s4">1</span><span class="s1">]</span>
                <span class="s1">inner_knots = _R_compat_quantile(x</span><span class="s3">, </span><span class="s1">knot_quantiles)</span>
        <span class="s3">if </span><span class="s1">args[</span><span class="s2">&quot;knots&quot;</span><span class="s1">] </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">inner_knots = args[</span><span class="s2">&quot;knots&quot;</span><span class="s1">]</span>
        <span class="s3">if </span><span class="s1">args[</span><span class="s2">&quot;lower_bound&quot;</span><span class="s1">] </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">lower_bound = args[</span><span class="s2">&quot;lower_bound&quot;</span><span class="s1">]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">lower_bound = np.min(x)</span>
        <span class="s3">if </span><span class="s1">args[</span><span class="s2">&quot;upper_bound&quot;</span><span class="s1">] </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">upper_bound = args[</span><span class="s2">&quot;upper_bound&quot;</span><span class="s1">]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">upper_bound = np.max(x)</span>
        <span class="s3">if </span><span class="s1">lower_bound &gt; upper_bound:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;lower_bound &gt; upper_bound (%r &gt; %r)&quot;</span>
                             <span class="s1">% (lower_bound</span><span class="s3">, </span><span class="s1">upper_bound))</span>
        <span class="s1">inner_knots = np.asarray(inner_knots)</span>
        <span class="s3">if </span><span class="s1">inner_knots.ndim &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;knots must be 1 dimensional&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">np.any(inner_knots &lt; lower_bound):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;some knot values (%s) fall below lower bound &quot;</span>
                             <span class="s2">&quot;(%r)&quot;</span>
                             <span class="s1">% (inner_knots[inner_knots &lt; lower_bound]</span><span class="s3">,</span>
                                <span class="s1">lower_bound))</span>
        <span class="s3">if </span><span class="s1">np.any(inner_knots &gt; upper_bound):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;some knot values (%s) fall above upper bound &quot;</span>
                             <span class="s2">&quot;(%r)&quot;</span>
                             <span class="s1">% (inner_knots[inner_knots &gt; upper_bound]</span><span class="s3">,</span>
                                <span class="s1">upper_bound))</span>
        <span class="s1">all_knots = np.concatenate(([lower_bound</span><span class="s3">, </span><span class="s1">upper_bound] * order</span><span class="s3">,</span>
                                    <span class="s1">inner_knots))</span>
        <span class="s1">all_knots.sort()</span>

        <span class="s1">self._degree = args[</span><span class="s2">&quot;degree&quot;</span><span class="s1">]</span>
        <span class="s1">self._all_knots = all_knots</span>

    <span class="s3">def </span><span class="s1">transform(self</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">df=</span><span class="s3">None, </span><span class="s1">knots=</span><span class="s3">None, </span><span class="s1">degree=</span><span class="s4">3</span><span class="s3">,</span>
                  <span class="s1">include_intercept=</span><span class="s3">False,</span>
                  <span class="s1">lower_bound=</span><span class="s3">None, </span><span class="s1">upper_bound=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">basis = _eval_bspline_basis(x</span><span class="s3">, </span><span class="s1">self._all_knots</span><span class="s3">, </span><span class="s1">self._degree)</span>
        <span class="s3">if not </span><span class="s1">include_intercept:</span>
            <span class="s1">basis = basis[:</span><span class="s3">, </span><span class="s4">1</span><span class="s1">:]</span>
        <span class="s3">if </span><span class="s1">have_pandas:</span>
            <span class="s3">if </span><span class="s1">isinstance(x</span><span class="s3">, </span><span class="s1">(pandas.Series</span><span class="s3">, </span><span class="s1">pandas.DataFrame)):</span>
                <span class="s1">basis = pandas.DataFrame(basis)</span>
                <span class="s1">basis.index = x.index</span>
        <span class="s3">return </span><span class="s1">basis</span>

    <span class="s1">__getstate__ = no_pickling</span>

<span class="s1">bs = stateful_transform(BS)</span>

<span class="s3">def </span><span class="s1">test_bs_compat():</span>
    <span class="s3">from </span><span class="s1">patsy.test_state </span><span class="s3">import </span><span class="s1">check_stateful</span>
    <span class="s3">from </span><span class="s1">patsy.test_splines_bs_data </span><span class="s3">import </span><span class="s1">(R_bs_test_x</span><span class="s3">,</span>
                                            <span class="s1">R_bs_test_data</span><span class="s3">,</span>
                                            <span class="s1">R_bs_num_tests)</span>
    <span class="s1">lines = R_bs_test_data.split(</span><span class="s2">&quot;</span><span class="s3">\n</span><span class="s2">&quot;</span><span class="s1">)</span>
    <span class="s1">tests_ran = </span><span class="s4">0</span>
    <span class="s1">start_idx = lines.index(</span><span class="s2">&quot;--BEGIN TEST CASE--&quot;</span><span class="s1">)</span>
    <span class="s3">while True</span><span class="s1">:</span>
        <span class="s3">if not </span><span class="s1">lines[start_idx] == </span><span class="s2">&quot;--BEGIN TEST CASE--&quot;</span><span class="s1">:</span>
            <span class="s3">break</span>
        <span class="s1">start_idx += </span><span class="s4">1</span>
        <span class="s1">stop_idx = lines.index(</span><span class="s2">&quot;--END TEST CASE--&quot;</span><span class="s3">, </span><span class="s1">start_idx)</span>
        <span class="s1">block = lines[start_idx:stop_idx]</span>
        <span class="s1">test_data = {}</span>
        <span class="s3">for </span><span class="s1">line </span><span class="s3">in </span><span class="s1">block:</span>
            <span class="s1">key</span><span class="s3">, </span><span class="s1">value = line.split(</span><span class="s2">&quot;=&quot;</span><span class="s3">, </span><span class="s4">1</span><span class="s1">)</span>
            <span class="s1">test_data[key] = value</span>
        <span class="s0"># Translate the R output into Python calling conventions</span>
        <span class="s1">kwargs = {</span>
            <span class="s2">&quot;degree&quot;</span><span class="s1">: int(test_data[</span><span class="s2">&quot;degree&quot;</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s0"># integer, or None</span>
            <span class="s2">&quot;df&quot;</span><span class="s1">: eval(test_data[</span><span class="s2">&quot;df&quot;</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s0"># np.array() call, or None</span>
            <span class="s2">&quot;knots&quot;</span><span class="s1">: eval(test_data[</span><span class="s2">&quot;knots&quot;</span><span class="s1">])</span><span class="s3">,</span>
            <span class="s1">}</span>
        <span class="s3">if </span><span class="s1">test_data[</span><span class="s2">&quot;Boundary.knots&quot;</span><span class="s1">] != </span><span class="s2">&quot;None&quot;</span><span class="s1">:</span>
            <span class="s1">lower</span><span class="s3">, </span><span class="s1">upper = eval(test_data[</span><span class="s2">&quot;Boundary.knots&quot;</span><span class="s1">])</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;lower_bound&quot;</span><span class="s1">] = lower</span>
            <span class="s1">kwargs[</span><span class="s2">&quot;upper_bound&quot;</span><span class="s1">] = upper</span>
        <span class="s1">kwargs[</span><span class="s2">&quot;include_intercept&quot;</span><span class="s1">] = (test_data[</span><span class="s2">&quot;intercept&quot;</span><span class="s1">] == </span><span class="s2">&quot;TRUE&quot;</span><span class="s1">)</span>
        <span class="s0"># Special case: in R, setting intercept=TRUE increases the effective</span>
        <span class="s0"># dof by 1. Adjust our arguments to match.</span>
        <span class="s0"># if kwargs[&quot;df&quot;] is not None and kwargs[&quot;include_intercept&quot;]:</span>
        <span class="s0">#     kwargs[&quot;df&quot;] += 1</span>
        <span class="s1">output = np.asarray(eval(test_data[</span><span class="s2">&quot;output&quot;</span><span class="s1">]))</span>
        <span class="s3">if </span><span class="s1">kwargs[</span><span class="s2">&quot;df&quot;</span><span class="s1">] </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">assert </span><span class="s1">output.shape[</span><span class="s4">1</span><span class="s1">] == kwargs[</span><span class="s2">&quot;df&quot;</span><span class="s1">]</span>
        <span class="s0"># Do the actual test</span>
        <span class="s1">check_stateful(BS</span><span class="s3">, False, </span><span class="s1">R_bs_test_x</span><span class="s3">, </span><span class="s1">output</span><span class="s3">, </span><span class="s1">**kwargs)</span>
        <span class="s1">tests_ran += </span><span class="s4">1</span>
        <span class="s0"># Set up for the next one</span>
        <span class="s1">start_idx = stop_idx + </span><span class="s4">1</span>
    <span class="s3">assert </span><span class="s1">tests_ran == R_bs_num_tests</span>

<span class="s1">test_bs_compat.slow = </span><span class="s4">1</span>

<span class="s0"># This isn't checked by the above, because R doesn't have zero degree</span>
<span class="s0"># b-splines.</span>
<span class="s3">def </span><span class="s1">test_bs_0degree():</span>
    <span class="s1">x = np.logspace(-</span><span class="s4">1</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">10</span><span class="s1">)</span>
    <span class="s1">result = bs(x</span><span class="s3">, </span><span class="s1">knots=[</span><span class="s4">1</span><span class="s3">, </span><span class="s4">4</span><span class="s1">]</span><span class="s3">, </span><span class="s1">degree=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">include_intercept=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s3">assert </span><span class="s1">result.shape[</span><span class="s4">1</span><span class="s1">] == </span><span class="s4">3</span>
    <span class="s1">expected_0 = np.zeros(</span><span class="s4">10</span><span class="s1">)</span>
    <span class="s1">expected_0[x &lt; </span><span class="s4">1</span><span class="s1">] = </span><span class="s4">1</span>
    <span class="s3">assert </span><span class="s1">np.array_equal(result[:</span><span class="s3">, </span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">expected_0)</span>
    <span class="s1">expected_1 = np.zeros(</span><span class="s4">10</span><span class="s1">)</span>
    <span class="s1">expected_1[(x &gt;= </span><span class="s4">1</span><span class="s1">) &amp; (x &lt; </span><span class="s4">4</span><span class="s1">)] = </span><span class="s4">1</span>
    <span class="s3">assert </span><span class="s1">np.array_equal(result[:</span><span class="s3">, </span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">expected_1)</span>
    <span class="s1">expected_2 = np.zeros(</span><span class="s4">10</span><span class="s1">)</span>
    <span class="s1">expected_2[x &gt;= </span><span class="s4">4</span><span class="s1">] = </span><span class="s4">1</span>
    <span class="s3">assert </span><span class="s1">np.array_equal(result[:</span><span class="s3">, </span><span class="s4">2</span><span class="s1">]</span><span class="s3">, </span><span class="s1">expected_2)</span>
    <span class="s0"># Check handling of points that exactly fall on knots. They arbitrarily</span>
    <span class="s0"># get included into the larger region, not the smaller. This is consistent</span>
    <span class="s0"># with Python's half-open interval convention -- each basis function is</span>
    <span class="s0"># constant on [knot[i], knot[i + 1]).</span>
    <span class="s3">assert </span><span class="s1">np.array_equal(bs([</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s3">, </span><span class="s4">2</span><span class="s1">]</span><span class="s3">, </span><span class="s1">degree=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">knots=[</span><span class="s4">1</span><span class="s1">]</span><span class="s3">,</span>
                             <span class="s1">include_intercept=</span><span class="s3">True</span><span class="s1">)</span><span class="s3">,</span>
                          <span class="s1">[[</span><span class="s4">1</span><span class="s3">, </span><span class="s4">0</span><span class="s1">]</span><span class="s3">,</span>
                           <span class="s1">[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s1">]</span><span class="s3">,</span>
                           <span class="s1">[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">1</span><span class="s1">]])</span>

    <span class="s1">result_int = bs(x</span><span class="s3">, </span><span class="s1">knots=[</span><span class="s4">1</span><span class="s3">, </span><span class="s4">4</span><span class="s1">]</span><span class="s3">, </span><span class="s1">degree=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">include_intercept=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s1">result_no_int = bs(x</span><span class="s3">, </span><span class="s1">knots=[</span><span class="s4">1</span><span class="s3">, </span><span class="s4">4</span><span class="s1">]</span><span class="s3">, </span><span class="s1">degree=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">include_intercept=</span><span class="s3">False</span><span class="s1">)</span>
    <span class="s3">assert </span><span class="s1">np.array_equal(result_int[:</span><span class="s3">, </span><span class="s4">1</span><span class="s1">:]</span><span class="s3">, </span><span class="s1">result_no_int)</span>

<span class="s3">def </span><span class="s1">test_bs_errors():</span>
    <span class="s3">import </span><span class="s1">pytest</span>
    <span class="s1">x = np.linspace(-</span><span class="s4">10</span><span class="s3">, </span><span class="s4">10</span><span class="s3">, </span><span class="s4">20</span><span class="s1">)</span>
    <span class="s0"># error checks:</span>
    <span class="s0"># out of bounds</span>
    <span class="s1">pytest.raises(NotImplementedError</span><span class="s3">, </span><span class="s1">bs</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s1">lower_bound=</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">pytest.raises(NotImplementedError</span><span class="s3">, </span><span class="s1">bs</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s1">upper_bound=</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s0"># must specify df or knots</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s3">, </span><span class="s1">bs</span><span class="s3">, </span><span class="s1">x)</span>
    <span class="s0"># df/knots match/mismatch (with and without intercept)</span>
    <span class="s0">#   match:</span>
    <span class="s1">bs(x</span><span class="s3">, </span><span class="s1">df=</span><span class="s4">10</span><span class="s3">, </span><span class="s1">include_intercept=</span><span class="s3">False, </span><span class="s1">knots=[</span><span class="s4">0</span><span class="s1">] * </span><span class="s4">7</span><span class="s1">)</span>
    <span class="s1">bs(x</span><span class="s3">, </span><span class="s1">df=</span><span class="s4">10</span><span class="s3">, </span><span class="s1">include_intercept=</span><span class="s3">True, </span><span class="s1">knots=[</span><span class="s4">0</span><span class="s1">] * </span><span class="s4">6</span><span class="s1">)</span>
    <span class="s1">bs(x</span><span class="s3">, </span><span class="s1">df=</span><span class="s4">10</span><span class="s3">, </span><span class="s1">include_intercept=</span><span class="s3">False, </span><span class="s1">knots=[</span><span class="s4">0</span><span class="s1">] * </span><span class="s4">9</span><span class="s3">, </span><span class="s1">degree=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">bs(x</span><span class="s3">, </span><span class="s1">df=</span><span class="s4">10</span><span class="s3">, </span><span class="s1">include_intercept=</span><span class="s3">True, </span><span class="s1">knots=[</span><span class="s4">0</span><span class="s1">] * </span><span class="s4">8</span><span class="s3">, </span><span class="s1">degree=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s0">#   too many knots:</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s3">,</span>
                  <span class="s1">bs</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">df=</span><span class="s4">10</span><span class="s3">, </span><span class="s1">include_intercept=</span><span class="s3">False, </span><span class="s1">knots=[</span><span class="s4">0</span><span class="s1">] * </span><span class="s4">8</span><span class="s1">)</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s3">,</span>
                  <span class="s1">bs</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">df=</span><span class="s4">10</span><span class="s3">, </span><span class="s1">include_intercept=</span><span class="s3">True, </span><span class="s1">knots=[</span><span class="s4">0</span><span class="s1">] * </span><span class="s4">7</span><span class="s1">)</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s3">,</span>
                  <span class="s1">bs</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">df=</span><span class="s4">10</span><span class="s3">, </span><span class="s1">include_intercept=</span><span class="s3">False, </span><span class="s1">knots=[</span><span class="s4">0</span><span class="s1">] * </span><span class="s4">10</span><span class="s3">,</span>
                  <span class="s1">degree=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s3">,</span>
                  <span class="s1">bs</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">df=</span><span class="s4">10</span><span class="s3">, </span><span class="s1">include_intercept=</span><span class="s3">True, </span><span class="s1">knots=[</span><span class="s4">0</span><span class="s1">] * </span><span class="s4">9</span><span class="s3">,</span>
                  <span class="s1">degree=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s0">#   too few knots:</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s3">,</span>
                  <span class="s1">bs</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">df=</span><span class="s4">10</span><span class="s3">, </span><span class="s1">include_intercept=</span><span class="s3">False, </span><span class="s1">knots=[</span><span class="s4">0</span><span class="s1">] * </span><span class="s4">6</span><span class="s1">)</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s3">,</span>
                  <span class="s1">bs</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">df=</span><span class="s4">10</span><span class="s3">, </span><span class="s1">include_intercept=</span><span class="s3">True, </span><span class="s1">knots=[</span><span class="s4">0</span><span class="s1">] * </span><span class="s4">5</span><span class="s1">)</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s3">,</span>
                  <span class="s1">bs</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">df=</span><span class="s4">10</span><span class="s3">, </span><span class="s1">include_intercept=</span><span class="s3">False, </span><span class="s1">knots=[</span><span class="s4">0</span><span class="s1">] * </span><span class="s4">8</span><span class="s3">,</span>
                  <span class="s1">degree=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s3">,</span>
                  <span class="s1">bs</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">df=</span><span class="s4">10</span><span class="s3">, </span><span class="s1">include_intercept=</span><span class="s3">True, </span><span class="s1">knots=[</span><span class="s4">0</span><span class="s1">] * </span><span class="s4">7</span><span class="s3">,</span>
                  <span class="s1">degree=</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s0"># df too small</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s3">,</span>
                  <span class="s1">bs</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">df=</span><span class="s4">1</span><span class="s3">, </span><span class="s1">degree=</span><span class="s4">3</span><span class="s1">)</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s3">,</span>
                  <span class="s1">bs</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">df=</span><span class="s4">3</span><span class="s3">, </span><span class="s1">degree=</span><span class="s4">5</span><span class="s1">)</span>
    <span class="s0"># bad degree</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s3">,</span>
                  <span class="s1">bs</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">df=</span><span class="s4">10</span><span class="s3">, </span><span class="s1">degree=-</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s3">,</span>
                  <span class="s1">bs</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">df=</span><span class="s4">10</span><span class="s3">, </span><span class="s1">degree=</span><span class="s4">1.5</span><span class="s1">)</span>
    <span class="s0"># upper_bound &lt; lower_bound</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s3">,</span>
                  <span class="s1">bs</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s4">3</span><span class="s3">, </span><span class="s1">lower_bound=</span><span class="s4">1</span><span class="s3">, </span><span class="s1">upper_bound=-</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s0"># multidimensional input</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s3">,</span>
                  <span class="s1">bs</span><span class="s3">, </span><span class="s1">np.column_stack((x</span><span class="s3">, </span><span class="s1">x))</span><span class="s3">, </span><span class="s4">3</span><span class="s1">)</span>
    <span class="s0"># unsorted knots are okay, and get sorted</span>
    <span class="s3">assert </span><span class="s1">np.array_equal(bs(x</span><span class="s3">, </span><span class="s1">knots=[</span><span class="s4">1</span><span class="s3">, </span><span class="s4">4</span><span class="s1">])</span><span class="s3">, </span><span class="s1">bs(x</span><span class="s3">, </span><span class="s1">knots=[</span><span class="s4">4</span><span class="s3">, </span><span class="s4">1</span><span class="s1">]))</span>
    <span class="s0"># 2d knots</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s3">,</span>
                  <span class="s1">bs</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">knots=[[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">[</span><span class="s4">20</span><span class="s1">]])</span>
    <span class="s0"># knots &gt; upper_bound</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s3">,</span>
                  <span class="s1">bs</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">knots=[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">20</span><span class="s1">])</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s3">,</span>
                  <span class="s1">bs</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">knots=[</span><span class="s4">0</span><span class="s3">, </span><span class="s4">4</span><span class="s1">]</span><span class="s3">, </span><span class="s1">upper_bound=</span><span class="s4">3</span><span class="s1">)</span>
    <span class="s0"># knots &lt; lower_bound</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s3">,</span>
                  <span class="s1">bs</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">knots=[-</span><span class="s4">20</span><span class="s3">, </span><span class="s4">0</span><span class="s1">])</span>
    <span class="s1">pytest.raises(ValueError</span><span class="s3">,</span>
                  <span class="s1">bs</span><span class="s3">, </span><span class="s1">x</span><span class="s3">, </span><span class="s1">knots=[-</span><span class="s4">4</span><span class="s3">, </span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">lower_bound=-</span><span class="s4">3</span><span class="s1">)</span>



<span class="s0"># differences between bs and ns (since the R code is a pile of copy-paste):</span>
<span class="s0"># - degree is always 3</span>
<span class="s0"># - different number of interior knots given df (b/c fewer dof used at edges I</span>
<span class="s0">#   guess)</span>
<span class="s0"># - boundary knots always repeated exactly 4 times (same as bs with degree=3)</span>
<span class="s0"># - complications at the end to handle boundary conditions</span>
<span class="s0"># the 'rcs' function uses slightly different conventions -- in particular it</span>
<span class="s0"># picks boundary knots that are not quite at the edges of the data, which</span>
<span class="s0"># makes sense for a natural spline.</span>
</pre>
</body>
</html>