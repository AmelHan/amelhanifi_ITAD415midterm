<html>
<head>
<title>dask-schema.yaml</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #a9b7c6;}
.s3 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
dask-schema.yaml</font>
</center></td></tr></table>
<pre><span class="s0">properties</span><span class="s1">:</span>

  <span class="s0">temporary-directory</span><span class="s1">:</span>
    <span class="s0">type</span><span class="s1">:</span>
    <span class="s1">- </span><span class="s2">string</span>
    <span class="s1">- </span><span class="s3">&quot;null&quot;</span>
    <span class="s0">description</span><span class="s1">: </span><span class="s2">|</span>
      <span class="s2">Temporary directory for local disk storage /tmp, /scratch,</span>
      <span class="s2">or /local.  This directory is used during dask spill-to-disk operations.</span>

      <span class="s2">When the value is &quot;null&quot; (default), dask will create a directory from</span>
      <span class="s2">where dask was launched: `cwd/dask-worker-space`</span>

  <span class="s0">visualization</span><span class="s1">:</span>
    <span class="s0">type</span><span class="s1">: </span><span class="s2">object</span>
    <span class="s0">properties</span><span class="s1">:</span>
      <span class="s0">engine</span><span class="s1">:</span>
        <span class="s0">type</span><span class="s1">:</span>
          <span class="s1">- </span><span class="s2">string</span>
          <span class="s1">- </span><span class="s3">'null'</span>
        <span class="s0">description</span><span class="s1">: </span><span class="s2">|</span>
          <span class="s2">Visualization engine to use when calling ``.visualize()`` on a Dask collection.</span>
          <span class="s2">Currently supports ``'graphviz'``, ``'ipycytoscape'``, and ``'cytoscape'``</span>
          <span class="s2">(alias for ``'ipycytoscape'``)</span>

  <span class="s0">tokenize</span><span class="s1">:</span>
    <span class="s0">type</span><span class="s1">: </span><span class="s2">object</span>
    <span class="s0">properties</span><span class="s1">:</span>
      <span class="s0">ensure-deterministic</span><span class="s1">:</span>
        <span class="s0">type</span><span class="s1">:</span>
        <span class="s1">- </span><span class="s2">boolean</span>
        <span class="s0">description</span><span class="s1">: </span><span class="s2">|</span>
          <span class="s2">If ``true``, tokenize will error instead of falling back to uuids</span>
          <span class="s2">when a deterministic token cannot be generated. Defaults to</span>
          <span class="s2">``false``.</span>

  <span class="s0">dataframe</span><span class="s1">:</span>
    <span class="s0">type</span><span class="s1">: </span><span class="s2">object</span>
    <span class="s0">properties</span><span class="s1">:</span>

      <span class="s0">backend</span><span class="s1">:</span>
        <span class="s0">type</span><span class="s1">:</span>
        <span class="s1">- </span><span class="s2">string</span>
        <span class="s1">- </span><span class="s3">&quot;null&quot;</span>
        <span class="s0">description</span><span class="s1">: </span><span class="s2">|</span>
          <span class="s2">Backend to use for supported dataframe-creation functions.</span>
          <span class="s2">Default is &quot;pandas&quot;.</span>

      <span class="s0">shuffle</span><span class="s1">:</span>
        <span class="s0">type</span><span class="s1">: </span><span class="s2">object</span>
        <span class="s0">properties</span><span class="s1">:</span>

          <span class="s0">method</span><span class="s1">:</span>
            <span class="s0">type</span><span class="s1">:</span>
            <span class="s1">- </span><span class="s2">string</span>
            <span class="s1">- </span><span class="s3">&quot;null&quot;</span>
            <span class="s0">description</span><span class="s1">: </span><span class="s2">|</span>
              <span class="s2">The default shuffle method to choose. Possible values are disk,</span>
              <span class="s2">tasks, p2p. If null, pick best method depending on application.</span>

          <span class="s0">compression</span><span class="s1">:</span>
            <span class="s0">type</span><span class="s1">:</span>
            <span class="s1">- </span><span class="s2">string</span>
            <span class="s1">- </span><span class="s3">&quot;null&quot;</span>
            <span class="s0">description</span><span class="s1">: </span><span class="s2">|</span>
              <span class="s2">Compression algorithm used for on disk-shuffling. Partd, the library used</span>
              <span class="s2">for compression supports ZLib, BZ2, and SNAPPY</span>


      <span class="s0">parquet</span><span class="s1">:</span>
        <span class="s0">type</span><span class="s1">: </span><span class="s2">object</span>
        <span class="s0">properties</span><span class="s1">:</span>

          <span class="s0">metadata-task-size-local</span><span class="s1">:</span>
            <span class="s0">type</span><span class="s1">: </span><span class="s2">integer</span>
            <span class="s0">description</span><span class="s1">: </span><span class="s2">|</span>
              <span class="s2">The number of files to handle within each metadata-processing</span>
              <span class="s2">task when reading a parquet dataset from a LOCAL file system.</span>
              <span class="s2">Specifying 0 will result in serial execution on the client.</span>

          <span class="s0">metadata-task-size-remote</span><span class="s1">:</span>
            <span class="s0">type</span><span class="s1">: </span><span class="s2">integer</span>
            <span class="s0">description</span><span class="s1">: </span><span class="s2">|</span>
              <span class="s2">The number of files to handle within each metadata-processing</span>
              <span class="s2">task when reading a parquet dataset from a REMOTE file system.</span>
              <span class="s2">Specifying 0 will result in serial execution on the client.</span>

      <span class="s0">convert-string</span><span class="s1">:</span>
        <span class="s0">type</span><span class="s1">: [</span><span class="s2">boolean</span><span class="s1">, </span><span class="s3">'null'</span><span class="s1">]</span>
        <span class="s0">description</span><span class="s1">: </span><span class="s2">|</span>
          <span class="s2">Whether to convert string-like data to pyarrow strings.</span>

  <span class="s0">array</span><span class="s1">:</span>
    <span class="s0">type</span><span class="s1">: </span><span class="s2">object</span>
    <span class="s0">properties</span><span class="s1">:</span>

      <span class="s0">backend</span><span class="s1">:</span>
        <span class="s0">type</span><span class="s1">:</span>
        <span class="s1">- </span><span class="s2">string</span>
        <span class="s1">- </span><span class="s3">&quot;null&quot;</span>
        <span class="s0">description</span><span class="s1">: </span><span class="s2">|</span>
          <span class="s2">Backend to use for supported array-creation functions.</span>
          <span class="s2">Default is &quot;numpy&quot;.</span>

      <span class="s0">chunk-size</span><span class="s1">:</span>
        <span class="s0">type</span><span class="s1">:</span>
        <span class="s1">- </span><span class="s2">integer</span>
        <span class="s1">- </span><span class="s2">string</span>
        <span class="s0">description</span><span class="s1">: </span><span class="s2">|</span>
          <span class="s2">The default chunk size to target. Default is &quot;128MiB&quot;.</span>

      <span class="s0">rechunk</span><span class="s1">:</span>
        <span class="s0">type</span><span class="s1">: </span><span class="s2">object</span>
        <span class="s0">properties</span><span class="s1">:</span>
          
          <span class="s0">method</span><span class="s1">:</span>
            <span class="s0">type</span><span class="s1">: </span><span class="s2">string</span>
            <span class="s0">description</span><span class="s1">: </span><span class="s2">|</span>
              <span class="s2">The method to use for rechunking. Must be either &quot;tasks&quot; or &quot;p2p&quot;;</span>
              <span class="s2">default is &quot;tasks&quot;. Using &quot;p2p&quot; requires a distributed cluster.</span>
          
          <span class="s0">threshold</span><span class="s1">:</span>
            <span class="s0">type</span><span class="s1">: </span><span class="s2">integer</span>
            <span class="s0">description</span><span class="s1">: </span><span class="s2">|</span>
              <span class="s2">The graph growth factor above which task-based shuffling introduces</span>
              <span class="s2">an intermediate step.</span>

      <span class="s0">svg</span><span class="s1">:</span>
        <span class="s0">type</span><span class="s1">: </span><span class="s2">object</span>
        <span class="s0">properties</span><span class="s1">:</span>

          <span class="s0">size</span><span class="s1">:</span>
            <span class="s0">type</span><span class="s1">: </span><span class="s2">integer</span>
            <span class="s0">description</span><span class="s1">: </span><span class="s2">|</span>
              <span class="s2">The size of pixels used when displaying a dask array as an SVG image.</span>
              <span class="s2">This is used, for example, for nice rendering in a Jupyter notebook</span>

      <span class="s0">slicing</span><span class="s1">:</span>
        <span class="s0">type</span><span class="s1">: </span><span class="s2">object</span>
        <span class="s0">properties</span><span class="s1">:</span>
          <span class="s0">split-large-chunks</span><span class="s1">:</span>
            <span class="s0">type</span><span class="s1">: [</span><span class="s2">boolean</span><span class="s1">, </span><span class="s3">'null'</span><span class="s1">]</span>
            <span class="s0">description</span><span class="s1">: </span><span class="s2">|</span>
              <span class="s2">How to handle large chunks created when slicing Arrays. By default a</span>
              <span class="s2">warning is produced. Set to ``False`` to silence the warning</span>
              <span class="s2">and allow large output chunks. Set to ``True`` to silence the</span>
              <span class="s2">warning and avoid large output chunks.</span>

  <span class="s0">optimization</span><span class="s1">:</span>
    <span class="s0">type</span><span class="s1">: </span><span class="s2">object</span>
    <span class="s0">properties</span><span class="s1">:</span>

      <span class="s0">annotations</span><span class="s1">:</span>
        <span class="s0">type</span><span class="s1">: </span><span class="s2">object</span>
        <span class="s0">properties</span><span class="s1">:</span>
          <span class="s0">fuse</span><span class="s1">:</span>
            <span class="s0">type</span><span class="s1">: </span><span class="s2">boolean</span>
            <span class="s0">description</span><span class="s1">: </span><span class="s2">|</span>
              <span class="s2">If adjacent blockwise layers have different annotations (e.g., one has</span>
              <span class="s2">retries=3 and another has retries=4), Dask can make an attempt to merge</span>
              <span class="s2">those annotations according to some simple rules. ``retries`` is set to</span>
              <span class="s2">the max of the layers, ``priority`` is set to the max of the layers,</span>
              <span class="s2">``resources`` are set to the max of all the resources, ``workers`` is</span>
              <span class="s2">set to the intersection of the requested workers. If this setting is</span>
              <span class="s2">disabled, then adjacent blockwise layers with different annotations</span>
              <span class="s2">will *not* be fused.</span>

      <span class="s0">fuse</span><span class="s1">:</span>
        <span class="s0">type</span><span class="s1">: </span><span class="s2">object</span>
        <span class="s0">description</span><span class="s1">: </span><span class="s2">Options for Dask's task fusion optimizations</span>
        <span class="s0">properties</span><span class="s1">:</span>

          <span class="s0">active</span><span class="s1">:</span>
            <span class="s0">type</span><span class="s1">: [</span><span class="s2">boolean</span><span class="s1">, </span><span class="s3">'null'</span><span class="s1">]</span>
            <span class="s0">description</span><span class="s1">: </span><span class="s2">|</span>
              <span class="s2">Turn task fusion on/off. This option refers to the fusion of a</span>
              <span class="s2">fully-materialized task graph (not a high-Level graph). By default</span>
              <span class="s2">(None), the active task-fusion option will be treated as ``False``</span>
              <span class="s2">for Dask-Dataframe collections, and as ``True`` for all other graphs</span>
              <span class="s2">(including Dask-Array collections).</span>

          <span class="s0">ave-width</span><span class="s1">:</span>
            <span class="s0">type</span><span class="s1">: </span><span class="s2">number</span>
            <span class="s0">minimum</span><span class="s1">: </span><span class="s2">0</span>
            <span class="s0">description</span><span class="s1">:</span>
              <span class="s2">Upper limit for width, where width = num_nodes / height, a good measure</span>
              <span class="s2">of parallelizability</span>

          <span class="s0">max-width</span><span class="s1">:</span>
            <span class="s0">type</span><span class="s1">: [</span><span class="s2">number</span><span class="s1">, </span><span class="s3">'null'</span><span class="s1">]</span>
            <span class="s0">minimum</span><span class="s1">: </span><span class="s2">0</span>
            <span class="s0">description</span><span class="s1">:</span>
              <span class="s2">Don't fuse if total width is greater than this. Set to null to dynamically</span>
              <span class="s2">adjust to 1.5 + ave_width * log(ave_width + 1)</span>

          <span class="s0">max-height</span><span class="s1">:</span>
            <span class="s0">type</span><span class="s1">: </span><span class="s2">number</span>
            <span class="s0">minimum</span><span class="s1">: </span><span class="s2">0</span>
            <span class="s0">description</span><span class="s1">: </span><span class="s2">Don't fuse more than this many levels</span>

          <span class="s0">max-depth-new-edges</span><span class="s1">:</span>
            <span class="s0">type</span><span class="s1">: [</span><span class="s2">number</span><span class="s1">, </span><span class="s3">'null'</span><span class="s1">]</span>
            <span class="s0">minimum</span><span class="s1">: </span><span class="s2">0</span>
            <span class="s0">description</span><span class="s1">:</span>
              <span class="s2">Don't fuse if new dependencies are added after this many levels.</span>
              <span class="s2">Set to null to dynamically adjust to ave_width * 1.5.</span>

          <span class="s0">subgraphs</span><span class="s1">:</span>
            <span class="s0">type</span><span class="s1">: [</span><span class="s2">boolean</span><span class="s1">, </span><span class="s3">'null'</span><span class="s1">]</span>
            <span class="s0">description</span><span class="s1">: </span><span class="s2">|</span>
              <span class="s2">Set to True to fuse multiple tasks into SubgraphCallable objects. Set to</span>
              <span class="s2">None to let the default optimizer of individual dask collections decide.</span>
              <span class="s2">If no collection-specific default exists, None defaults to False.</span>

          <span class="s0">rename-keys</span><span class="s1">:</span>
            <span class="s0">type</span><span class="s1">: </span><span class="s2">boolean</span>
            <span class="s0">description</span><span class="s1">:</span>
              <span class="s2">Set to true to rename the fused keys with `default_fused_keys_renamer`.</span>
              <span class="s2">Renaming fused keys can keep the graph more understandable and</span>
              <span class="s2">comprehensible, but it comes at the cost of additional processing. If</span>
              <span class="s2">False, then the top-most key will be used. For advanced usage, a function</span>
              <span class="s2">to create the new name is also accepted.</span>

  <span class="s0">admin</span><span class="s1">:</span>
    <span class="s0">type</span><span class="s1">: </span><span class="s2">object</span>
    <span class="s0">properties</span><span class="s1">:</span>

      <span class="s0">traceback</span><span class="s1">:</span>
        <span class="s0">type</span><span class="s1">: </span><span class="s2">object</span>
        <span class="s0">properties</span><span class="s1">:</span>

          <span class="s0">shorten</span><span class="s1">:</span>
            <span class="s0">description</span><span class="s1">:</span>
              <span class="s2">Clean up Dask tracebacks for readability.</span>
              <span class="s2">Remove all modules that match one of the listed regular expressions.</span>
              <span class="s2">Always preserve the first and last frame.</span>
            <span class="s0">type</span><span class="s1">: </span><span class="s2">array</span>
            <span class="s0">items</span><span class="s1">:</span>
              <span class="s0">type</span><span class="s1">: </span><span class="s2">string</span>
</pre>
</body>
</html>