<html>
<head>
<title>test_weights.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_weights.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Tests for computation of weight functions in state space models 
 
Author: Chad Fulton 
License: Simplified-BSD 
&quot;&quot;&quot;</span>

<span class="s2">import </span><span class="s1">pytest</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pandas </span><span class="s2">as </span><span class="s1">pd</span>

<span class="s2">from </span><span class="s1">numpy.testing </span><span class="s2">import </span><span class="s1">assert_equal</span><span class="s2">, </span><span class="s1">assert_allclose</span>

<span class="s2">from </span><span class="s1">statsmodels </span><span class="s2">import </span><span class="s1">datasets</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.statespace </span><span class="s2">import </span><span class="s1">sarimax</span><span class="s2">, </span><span class="s1">varmax</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.statespace </span><span class="s2">import </span><span class="s1">tools</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.statespace.tests.test_impulse_responses </span><span class="s2">import </span><span class="s1">TVSS</span>


<span class="s1">dta = datasets.macrodata.load_pandas().data</span>
<span class="s1">dta.index = pd.period_range(start=</span><span class="s3">'1959Q1'</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">'2009Q3'</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">'Q'</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'use_exog'</span><span class="s2">, </span><span class="s1">[</span><span class="s2">False, True</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'trend'</span><span class="s2">, </span><span class="s1">[</span><span class="s3">'n'</span><span class="s2">, </span><span class="s3">'c'</span><span class="s2">, </span><span class="s3">'t'</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'concentrate_scale'</span><span class="s2">, </span><span class="s1">[</span><span class="s2">False, True</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'measurement_error'</span><span class="s2">, </span><span class="s1">[</span><span class="s2">False, True</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_smoothed_state_obs_weights_sarimax(use_exog</span><span class="s2">, </span><span class="s1">trend</span><span class="s2">,</span>
                                            <span class="s1">concentrate_scale</span><span class="s2">,</span>
                                            <span class="s1">measurement_error):</span>
    <span class="s1">endog = np.array([[</span><span class="s4">0.2</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s4">1.2</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.3</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1.5</span><span class="s1">]]).T</span>
    <span class="s1">exog = np.array([</span><span class="s4">2</span><span class="s2">, </span><span class="s4">5.3</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">3.4</span><span class="s2">, </span><span class="s4">0.</span><span class="s1">]) </span><span class="s2">if </span><span class="s1">use_exog </span><span class="s2">else None</span>

    <span class="s1">trend_params = [</span><span class="s4">0.1</span><span class="s1">]</span>
    <span class="s1">ar_params = [</span><span class="s4">0.5</span><span class="s1">]</span>
    <span class="s1">exog_params = [</span><span class="s4">1.4</span><span class="s1">]</span>
    <span class="s1">meas_err_params = [</span><span class="s4">1.2</span><span class="s1">]</span>
    <span class="s1">cov_params = [</span><span class="s4">0.8</span><span class="s1">]</span>

    <span class="s1">params = []</span>
    <span class="s2">if </span><span class="s1">trend </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'c'</span><span class="s2">, </span><span class="s3">'t'</span><span class="s1">]:</span>
        <span class="s1">params += trend_params</span>
    <span class="s2">if </span><span class="s1">use_exog:</span>
        <span class="s1">params += exog_params</span>
    <span class="s1">params += ar_params</span>
    <span class="s2">if </span><span class="s1">measurement_error:</span>
        <span class="s1">params += meas_err_params</span>
    <span class="s2">if not </span><span class="s1">concentrate_scale:</span>
        <span class="s1">params += cov_params</span>

    <span class="s5"># Fit the models</span>
    <span class="s1">mod = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=trend</span><span class="s2">,</span>
                          <span class="s1">exog=exog </span><span class="s2">if </span><span class="s1">use_exog </span><span class="s2">else None,</span>
                          <span class="s1">concentrate_scale=concentrate_scale</span><span class="s2">,</span>
                          <span class="s1">measurement_error=measurement_error)</span>
    <span class="s1">prior_mean = np.array([-</span><span class="s4">0.4</span><span class="s1">])</span>
    <span class="s1">prior_cov = np.eye(</span><span class="s4">1</span><span class="s1">) * </span><span class="s4">1.2</span>
    <span class="s1">mod.ssm.initialize_known(prior_mean</span><span class="s2">, </span><span class="s1">prior_cov)</span>
    <span class="s1">res = mod.smooth(params)</span>

    <span class="s5"># Compute the desiried weights</span>
    <span class="s1">n = mod.nobs</span>
    <span class="s1">m = mod.k_states</span>
    <span class="s1">p = mod.k_endog</span>

    <span class="s1">desired = np.zeros((n</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">p)) * np.nan</span>
    <span class="s5"># Here we manually compute the weights by adjusting one observation at a</span>
    <span class="s5"># time</span>
    <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(n):</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(p):</span>
            <span class="s2">if </span><span class="s1">np.isnan(endog[j</span><span class="s2">, </span><span class="s1">i]):</span>
                <span class="s1">desired[:</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">i] = np.nan</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">y = endog.copy()</span>
                <span class="s1">y[j</span><span class="s2">, </span><span class="s1">i] += </span><span class="s4">1.0</span>
                <span class="s1">tmp_mod = sarimax.SARIMAX(y</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=trend</span><span class="s2">,</span>
                                          <span class="s1">exog=exog </span><span class="s2">if </span><span class="s1">use_exog </span><span class="s2">else None,</span>
                                          <span class="s1">concentrate_scale=concentrate_scale</span><span class="s2">,</span>
                                          <span class="s1">measurement_error=measurement_error)</span>
                <span class="s1">tmp_mod.ssm.initialize_known(prior_mean</span><span class="s2">, </span><span class="s1">prior_cov)</span>
                <span class="s1">tmp_res = tmp_mod.smooth(params)</span>

                <span class="s1">desired[:</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">i] = (tmp_res.smoothed_state.T</span>
                                       <span class="s1">- res.smoothed_state.T)</span>

    <span class="s1">desired_state_intercept_weights = np.zeros((n</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">m)) * np.nan</span>
    <span class="s5"># Here we manually compute the weights by adjusting one state intercept</span>
    <span class="s5"># at a time</span>
    <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(n):</span>
        <span class="s2">for </span><span class="s1">ell </span><span class="s2">in </span><span class="s1">range(m):</span>
            <span class="s1">tmp_mod = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=trend</span><span class="s2">,</span>
                                      <span class="s1">exog=exog </span><span class="s2">if </span><span class="s1">use_exog </span><span class="s2">else None,</span>
                                      <span class="s1">concentrate_scale=concentrate_scale</span><span class="s2">,</span>
                                      <span class="s1">measurement_error=measurement_error)</span>
            <span class="s1">tmp_mod.ssm.initialize_known(prior_mean</span><span class="s2">, </span><span class="s1">prior_cov)</span>
            <span class="s1">tmp_mod.update(params)</span>
            <span class="s2">if </span><span class="s1">tmp_mod[</span><span class="s3">'state_intercept'</span><span class="s1">].ndim == </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">si = tmp_mod[</span><span class="s3">'state_intercept'</span><span class="s1">]</span>
                <span class="s1">tmp_mod[</span><span class="s3">'state_intercept'</span><span class="s1">] = np.zeros((mod.k_states</span><span class="s2">, </span><span class="s1">mod.nobs))</span>
                <span class="s1">tmp_mod[</span><span class="s3">'state_intercept'</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">:] = si</span>
            <span class="s1">tmp_mod[</span><span class="s3">'state_intercept'</span><span class="s2">, </span><span class="s1">ell</span><span class="s2">, </span><span class="s1">j] += </span><span class="s4">1.0</span>
            <span class="s1">tmp_res = tmp_mod.ssm.smooth()</span>

            <span class="s1">desired_state_intercept_weights[:</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">ell] = (</span>
                <span class="s1">tmp_res.smoothed_state.T - res.smoothed_state.T)</span>

    <span class="s1">desired_prior_weights = np.zeros((n</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">m)) * np.nan</span>
    <span class="s5"># Here we manually compute the weights by adjusting one prior element at</span>
    <span class="s5"># a time</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(m):</span>
        <span class="s1">a = prior_mean.copy()</span>
        <span class="s1">a[i] += </span><span class="s4">1</span>
        <span class="s1">tmp_mod = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=trend</span><span class="s2">,</span>
                                  <span class="s1">exog=exog </span><span class="s2">if </span><span class="s1">use_exog </span><span class="s2">else None,</span>
                                  <span class="s1">concentrate_scale=concentrate_scale</span><span class="s2">,</span>
                                  <span class="s1">measurement_error=measurement_error)</span>
        <span class="s1">tmp_mod.ssm.initialize_known(a</span><span class="s2">, </span><span class="s1">prior_cov)</span>
        <span class="s1">tmp_res = tmp_mod.smooth(params)</span>

        <span class="s1">desired_prior_weights[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">i] = (tmp_res.smoothed_state.T</span>
                                          <span class="s1">- res.smoothed_state.T)</span>

    <span class="s1">mod.ssm.initialize_known(prior_mean</span><span class="s2">, </span><span class="s1">prior_cov)</span>
    <span class="s1">actual</span><span class="s2">, </span><span class="s1">actual_state_intercept_weights</span><span class="s2">, </span><span class="s1">actual_prior_weights = (</span>
        <span class="s1">tools.compute_smoothed_state_weights(res))</span>

    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-12</span><span class="s1">)</span>
    <span class="s1">assert_allclose(actual_state_intercept_weights</span><span class="s2">,</span>
                    <span class="s1">desired_state_intercept_weights</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-12</span><span class="s1">)</span>
    <span class="s1">assert_allclose(actual_prior_weights</span><span class="s2">, </span><span class="s1">desired_prior_weights</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-12</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'use_exog'</span><span class="s2">, </span><span class="s1">[</span><span class="s2">False, True</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'trend'</span><span class="s2">, </span><span class="s1">[</span><span class="s3">'n'</span><span class="s2">, </span><span class="s3">'c'</span><span class="s2">, </span><span class="s3">'t'</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_smoothed_state_obs_weights_varmax(use_exog</span><span class="s2">, </span><span class="s1">trend):</span>
    <span class="s1">endog = np.zeros((</span><span class="s4">5</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>
    <span class="s1">endog[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">] = np.nan</span>
    <span class="s1">endog[</span><span class="s4">1</span><span class="s2">, </span><span class="s1">:] = np.nan</span>
    <span class="s1">endog[</span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s1">] = np.nan</span>
    <span class="s1">exog = np.array([</span><span class="s4">2</span><span class="s2">, </span><span class="s4">5.3</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">3.4</span><span class="s2">, </span><span class="s4">0.</span><span class="s1">]) </span><span class="s2">if </span><span class="s1">use_exog </span><span class="s2">else None</span>

    <span class="s1">trend_params = [</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.2</span><span class="s1">]</span>
    <span class="s1">var_params = [</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.0</span><span class="s2">, </span><span class="s4">0.2</span><span class="s1">]</span>
    <span class="s1">exog_params = [</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">2.</span><span class="s1">]</span>
    <span class="s1">cov_params = [</span><span class="s4">1.</span><span class="s2">, </span><span class="s4">0.</span><span class="s2">, </span><span class="s4">1.</span><span class="s1">]</span>

    <span class="s1">params = []</span>
    <span class="s2">if </span><span class="s1">trend </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'c'</span><span class="s2">, </span><span class="s3">'t'</span><span class="s1">]:</span>
        <span class="s1">params += trend_params</span>
    <span class="s1">params += var_params</span>
    <span class="s2">if </span><span class="s1">use_exog:</span>
        <span class="s1">params += exog_params</span>
    <span class="s1">params += cov_params</span>

    <span class="s5"># Fit the model</span>
    <span class="s1">mod = varmax.VARMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=trend</span><span class="s2">,</span>
                        <span class="s1">exog=exog </span><span class="s2">if </span><span class="s1">use_exog </span><span class="s2">else None</span><span class="s1">)</span>
    <span class="s1">prior_mean = np.array([-</span><span class="s4">0.4</span><span class="s2">, </span><span class="s4">0.9</span><span class="s1">])</span>
    <span class="s1">prior_cov = np.array([[</span><span class="s4">1.4</span><span class="s2">, </span><span class="s4">0.3</span><span class="s1">]</span><span class="s2">,</span>
                          <span class="s1">[</span><span class="s4">0.3</span><span class="s2">, </span><span class="s4">2.6</span><span class="s1">]])</span>
    <span class="s1">mod.ssm.initialize_known(prior_mean</span><span class="s2">, </span><span class="s1">prior_cov)</span>
    <span class="s1">res = mod.smooth(params)</span>

    <span class="s5"># Compute the desiried weights</span>
    <span class="s1">n = mod.nobs</span>
    <span class="s1">m = mod.k_states</span>
    <span class="s1">p = mod.k_endog</span>

    <span class="s1">desired = np.zeros((n</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">p)) * np.nan</span>
    <span class="s5"># Here we manually compute the weights by adjusting one observation at a</span>
    <span class="s5"># time</span>
    <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(n):</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(p):</span>
            <span class="s2">if </span><span class="s1">np.isnan(endog[j</span><span class="s2">, </span><span class="s1">i]):</span>
                <span class="s1">desired[:</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">i] = np.nan</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">y = endog.copy()</span>
                <span class="s1">y[j</span><span class="s2">, </span><span class="s1">i] = </span><span class="s4">1.0</span>
                <span class="s1">tmp_mod = varmax.VARMAX(y</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=trend</span><span class="s2">,</span>
                                        <span class="s1">exog=exog </span><span class="s2">if </span><span class="s1">use_exog </span><span class="s2">else None</span><span class="s1">)</span>
                <span class="s1">tmp_mod.ssm.initialize_known(prior_mean</span><span class="s2">, </span><span class="s1">prior_cov)</span>
                <span class="s1">tmp_res = tmp_mod.smooth(params)</span>

                <span class="s1">desired[:</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">i] = (tmp_res.smoothed_state.T</span>
                                       <span class="s1">- res.smoothed_state.T)</span>

    <span class="s1">desired_state_intercept_weights = np.zeros((n</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">m)) * np.nan</span>
    <span class="s5"># Here we manually compute the weights by adjusting one state intercept</span>
    <span class="s5"># at a time</span>
    <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(n):</span>
        <span class="s2">for </span><span class="s1">ell </span><span class="s2">in </span><span class="s1">range(m):</span>
            <span class="s1">tmp_mod = varmax.VARMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=trend</span><span class="s2">,</span>
                                    <span class="s1">exog=exog </span><span class="s2">if </span><span class="s1">use_exog </span><span class="s2">else None</span><span class="s1">)</span>
            <span class="s1">tmp_mod.ssm.initialize_known(prior_mean</span><span class="s2">, </span><span class="s1">prior_cov)</span>
            <span class="s1">tmp_mod.update(params)</span>
            <span class="s2">if </span><span class="s1">tmp_mod[</span><span class="s3">'state_intercept'</span><span class="s1">].ndim == </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">si = tmp_mod[</span><span class="s3">'state_intercept'</span><span class="s1">]</span>
                <span class="s1">tmp_mod[</span><span class="s3">'state_intercept'</span><span class="s1">] = np.zeros((mod.k_states</span><span class="s2">, </span><span class="s1">mod.nobs))</span>
                <span class="s1">tmp_mod[</span><span class="s3">'state_intercept'</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">:] = si[:</span><span class="s2">, None</span><span class="s1">]</span>
            <span class="s1">tmp_mod[</span><span class="s3">'state_intercept'</span><span class="s2">, </span><span class="s1">ell</span><span class="s2">, </span><span class="s1">j] += </span><span class="s4">1.0</span>
            <span class="s1">tmp_res = tmp_mod.ssm.smooth()</span>

            <span class="s1">desired_state_intercept_weights[:</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">ell] = (</span>
                <span class="s1">tmp_res.smoothed_state.T - res.smoothed_state.T)</span>

    <span class="s1">desired_prior_weights = np.zeros((n</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">m)) * np.nan</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(m):</span>
        <span class="s1">a = prior_mean.copy()</span>
        <span class="s1">a[i] += </span><span class="s4">1</span>
        <span class="s1">tmp_mod = varmax.VARMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=trend</span><span class="s2">,</span>
                                <span class="s1">exog=exog </span><span class="s2">if </span><span class="s1">use_exog </span><span class="s2">else None</span><span class="s1">)</span>
        <span class="s1">tmp_mod.ssm.initialize_known(a</span><span class="s2">, </span><span class="s1">prior_cov)</span>
        <span class="s1">tmp_res = tmp_mod.smooth(params)</span>

        <span class="s1">desired_prior_weights[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">i] = (tmp_res.smoothed_state.T</span>
                                          <span class="s1">- res.smoothed_state.T)</span>

    <span class="s1">mod.ssm.initialize_known(prior_mean</span><span class="s2">, </span><span class="s1">prior_cov)</span>
    <span class="s1">actual</span><span class="s2">, </span><span class="s1">actual_state_intercept_weights</span><span class="s2">, </span><span class="s1">actual_prior_weights = (</span>
        <span class="s1">tools.compute_smoothed_state_weights(res))</span>

    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-12</span><span class="s1">)</span>
    <span class="s1">assert_allclose(actual_state_intercept_weights</span><span class="s2">,</span>
                    <span class="s1">desired_state_intercept_weights</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-12</span><span class="s1">)</span>
    <span class="s1">assert_allclose(actual_prior_weights</span><span class="s2">, </span><span class="s1">desired_prior_weights</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-12</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'diffuse'</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">4</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'univariate'</span><span class="s2">, </span><span class="s1">[</span><span class="s2">False, True</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_smoothed_state_obs_weights_TVSS(univariate</span><span class="s2">, </span><span class="s1">diffuse</span><span class="s2">,</span>
                                         <span class="s1">reset_randomstate):</span>
    <span class="s1">endog = np.zeros((</span><span class="s4">10</span><span class="s2">, </span><span class="s4">3</span><span class="s1">))</span>
    <span class="s5"># One simple way to introduce more diffuse periods is to have fully missing</span>
    <span class="s5"># observations at the beginning</span>
    <span class="s2">if </span><span class="s1">diffuse == </span><span class="s4">4</span><span class="s1">:</span>
        <span class="s1">endog[:</span><span class="s4">3</span><span class="s1">] = np.nan</span>
    <span class="s1">endog[</span><span class="s4">6</span><span class="s2">, </span><span class="s4">0</span><span class="s1">] = np.nan</span>
    <span class="s1">endog[</span><span class="s4">7</span><span class="s2">, </span><span class="s1">:] = np.nan</span>
    <span class="s1">endog[</span><span class="s4">8</span><span class="s2">, </span><span class="s4">1</span><span class="s1">] = np.nan</span>
    <span class="s1">mod = TVSS(endog)</span>

    <span class="s1">prior_mean = np.array([</span><span class="s4">1.2</span><span class="s2">, </span><span class="s4">0.8</span><span class="s1">])</span>
    <span class="s1">prior_cov = np.eye(</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s2">if not </span><span class="s1">diffuse:</span>
        <span class="s1">mod.ssm.initialize_known(prior_mean</span><span class="s2">, </span><span class="s1">prior_cov)</span>
    <span class="s2">if </span><span class="s1">univariate:</span>
        <span class="s1">mod.ssm.filter_univariate = </span><span class="s2">True</span>
    <span class="s1">res = mod.smooth([])</span>

    <span class="s5"># Compute the desiried weights</span>
    <span class="s1">n = mod.nobs</span>
    <span class="s1">m = mod.k_states</span>
    <span class="s1">p = mod.k_endog</span>

    <span class="s1">desired = np.zeros((n</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">p)) * np.nan</span>
    <span class="s5"># Here we manually compute the weights by adjusting one observation at a</span>
    <span class="s5"># time</span>
    <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(n):</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(p):</span>
            <span class="s2">if </span><span class="s1">np.isnan(endog[j</span><span class="s2">, </span><span class="s1">i]):</span>
                <span class="s1">desired[:</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">i] = np.nan</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">y = endog.copy()</span>
                <span class="s1">y[j</span><span class="s2">, </span><span class="s1">i] = </span><span class="s4">1.0</span>
                <span class="s1">tmp_mod = mod.clone(y)</span>
                <span class="s2">if not </span><span class="s1">diffuse:</span>
                    <span class="s1">tmp_mod.ssm.initialize_known(prior_mean</span><span class="s2">, </span><span class="s1">prior_cov)</span>
                <span class="s2">if </span><span class="s1">univariate:</span>
                    <span class="s1">tmp_mod.ssm.filter_univariate = </span><span class="s2">True</span>
                <span class="s1">tmp_res = tmp_mod.smooth([])</span>

                <span class="s1">desired[:</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">i] = (tmp_res.smoothed_state.T</span>
                                       <span class="s1">- res.smoothed_state.T)</span>

    <span class="s1">desired_state_intercept_weights = np.zeros((n</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">m)) * np.nan</span>
    <span class="s5"># Here we manually compute the weights by adjusting one state intercept</span>
    <span class="s5"># at a time</span>
    <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(n):</span>
        <span class="s2">for </span><span class="s1">ell </span><span class="s2">in </span><span class="s1">range(m):</span>
            <span class="s1">tmp_mod = mod.clone(endog)</span>
            <span class="s2">if not </span><span class="s1">diffuse:</span>
                <span class="s1">tmp_mod.ssm.initialize_known(prior_mean</span><span class="s2">, </span><span class="s1">prior_cov)</span>
            <span class="s2">if </span><span class="s1">univariate:</span>
                <span class="s1">tmp_mod.ssm.filter_univariate = </span><span class="s2">True</span>
            <span class="s2">if </span><span class="s1">tmp_mod[</span><span class="s3">'state_intercept'</span><span class="s1">].ndim == </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">si = tmp_mod[</span><span class="s3">'state_intercept'</span><span class="s1">]</span>
                <span class="s1">tmp_mod[</span><span class="s3">'state_intercept'</span><span class="s1">] = np.zeros((mod.k_states</span><span class="s2">, </span><span class="s1">mod.nobs))</span>
                <span class="s1">tmp_mod[</span><span class="s3">'state_intercept'</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">:] = si[:</span><span class="s2">, None</span><span class="s1">]</span>
            <span class="s1">tmp_mod[</span><span class="s3">'state_intercept'</span><span class="s2">, </span><span class="s1">ell</span><span class="s2">, </span><span class="s1">j] += </span><span class="s4">1.0</span>
            <span class="s1">tmp_res = tmp_mod.ssm.smooth()</span>

            <span class="s1">desired_state_intercept_weights[:</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">ell] = (</span>
                <span class="s1">tmp_res.smoothed_state.T - res.smoothed_state.T)</span>

    <span class="s1">desired_prior_weights = np.zeros((n</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">m)) * np.nan</span>
    <span class="s2">if not </span><span class="s1">diffuse:</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(m):</span>
            <span class="s1">a = prior_mean.copy()</span>
            <span class="s1">a[i] += </span><span class="s4">1</span>
            <span class="s1">tmp_mod = mod.clone(endog)</span>
            <span class="s1">tmp_mod.ssm.initialize_known(a</span><span class="s2">, </span><span class="s1">prior_cov)</span>
            <span class="s1">tmp_res = tmp_mod.smooth([])</span>

            <span class="s1">desired_prior_weights[:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">i] = (tmp_res.smoothed_state.T</span>
                                              <span class="s1">- res.smoothed_state.T)</span>

    <span class="s2">if not </span><span class="s1">diffuse:</span>
        <span class="s1">mod.ssm.initialize_known(prior_mean</span><span class="s2">, </span><span class="s1">prior_cov)</span>
    <span class="s1">actual</span><span class="s2">, </span><span class="s1">actual_state_intercept_weights</span><span class="s2">, </span><span class="s1">actual_prior_weights = (</span>
        <span class="s1">tools.compute_smoothed_state_weights(res))</span>

    <span class="s1">d = res.nobs_diffuse</span>
    <span class="s1">assert_equal(d</span><span class="s2">, </span><span class="s1">diffuse)</span>
    <span class="s2">if </span><span class="s1">diffuse:</span>
        <span class="s1">assert_allclose(actual[:d]</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-12</span><span class="s1">)</span>
        <span class="s1">assert_allclose(actual[:</span><span class="s2">, </span><span class="s1">:d]</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-12</span><span class="s1">)</span>
        <span class="s1">assert_allclose(actual_state_intercept_weights[:d]</span><span class="s2">, </span><span class="s1">np.nan)</span>
        <span class="s1">assert_allclose(actual_state_intercept_weights[:</span><span class="s2">, </span><span class="s1">:d]</span><span class="s2">, </span><span class="s1">np.nan)</span>
        <span class="s1">assert_allclose(actual_prior_weights</span><span class="s2">, </span><span class="s1">np.nan)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s5"># Test that the weights are the same</span>
        <span class="s1">assert_allclose(actual_prior_weights</span><span class="s2">, </span><span class="s1">desired_prior_weights</span><span class="s2">,</span>
                        <span class="s1">atol=</span><span class="s4">1e-12</span><span class="s1">)</span>

        <span class="s5"># In the non-diffuse case, we can actually use the weights along with</span>
        <span class="s5"># the prior and observations to compute the smoothed state directly,</span>
        <span class="s5"># and then compare that to what was returned by the usual Kalman</span>
        <span class="s5"># smoothing routines</span>
        <span class="s5"># Note that TVSS sets the state intercept to zeros, so this does not</span>
        <span class="s5"># test that, although those weights are tested separately, see above</span>
        <span class="s5"># and below.</span>
        <span class="s1">contribution_prior = np.nansum(</span>
            <span class="s1">actual_prior_weights * prior_mean[</span><span class="s2">None, None, </span><span class="s1">:]</span><span class="s2">, </span><span class="s1">axis=</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">contribution_endog = np.nansum(</span>
            <span class="s1">actual * (endog - mod[</span><span class="s3">'obs_intercept'</span><span class="s1">].T)[</span><span class="s2">None, </span><span class="s1">:</span><span class="s2">, None, </span><span class="s1">:]</span><span class="s2">,</span>
            <span class="s1">axis=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s1">))</span>
        <span class="s1">computed_smoothed_state = contribution_prior + contribution_endog</span>
        <span class="s1">assert_allclose(computed_smoothed_state</span><span class="s2">, </span><span class="s1">res.smoothed_state.T)</span>
    <span class="s1">assert_allclose(actual[d:</span><span class="s2">, </span><span class="s1">d:]</span><span class="s2">, </span><span class="s1">desired[d:</span><span class="s2">, </span><span class="s1">d:]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-12</span><span class="s1">)</span>
    <span class="s1">assert_allclose(actual_state_intercept_weights[d:</span><span class="s2">, </span><span class="s1">d:]</span><span class="s2">,</span>
                    <span class="s1">desired_state_intercept_weights[d:</span><span class="s2">, </span><span class="s1">d:]</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-12</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'singular'</span><span class="s2">, </span><span class="s1">[</span><span class="s3">'both'</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'periods'</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_smoothed_state_obs_weights_univariate_singular(singular</span><span class="s2">, </span><span class="s1">periods</span><span class="s2">,</span>
                                                        <span class="s1">reset_randomstate):</span>
    <span class="s5"># Tests for the univariate case when the forecast error covariance matrix</span>
    <span class="s5"># is singular (so the multivariate approach cannot be used, and the use of</span>
    <span class="s5"># pinv in computing the weights becomes actually operative)</span>
    <span class="s1">endog = np.zeros((</span><span class="s4">10</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>
    <span class="s1">endog[</span><span class="s4">6</span><span class="s2">, </span><span class="s4">0</span><span class="s1">] = np.nan</span>
    <span class="s1">endog[</span><span class="s4">7</span><span class="s2">, </span><span class="s1">:] = np.nan</span>
    <span class="s1">endog[</span><span class="s4">8</span><span class="s2">, </span><span class="s4">1</span><span class="s1">] = np.nan</span>
    <span class="s1">mod = TVSS(endog)</span>
    <span class="s1">mod.ssm.initialize_known([</span><span class="s4">1.2</span><span class="s2">, </span><span class="s4">0.8</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.eye(</span><span class="s4">2</span><span class="s1">) * </span><span class="s4">0</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">singular == </span><span class="s3">'both'</span><span class="s1">:</span>
        <span class="s1">mod[</span><span class="s3">'obs_cov'</span><span class="s2">, </span><span class="s1">...</span><span class="s2">, </span><span class="s1">:periods] = </span><span class="s4">0</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">mod[</span><span class="s3">'obs_cov'</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">:periods] = </span><span class="s4">0</span>
        <span class="s1">mod[</span><span class="s3">'obs_cov'</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">:periods] = </span><span class="s4">0</span>
        <span class="s1">mod[</span><span class="s3">'obs_cov'</span><span class="s2">, </span><span class="s1">singular</span><span class="s2">, </span><span class="s1">singular</span><span class="s2">, </span><span class="s1">:periods] = </span><span class="s4">0</span>
    <span class="s1">mod[</span><span class="s3">'state_cov'</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">:periods] = </span><span class="s4">0</span>
    <span class="s1">mod.ssm.filter_univariate = </span><span class="s2">True</span>
    <span class="s1">res = mod.smooth([])</span>

    <span class="s5"># Make sure we actually have singular covariance matrices in the periods</span>
    <span class="s5"># specified</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(periods):</span>
        <span class="s1">eigvals = np.linalg.eigvalsh(res.forecasts_error_cov[...</span><span class="s2">, </span><span class="s1">i])</span>
        <span class="s1">assert_equal(np.min(eigvals)</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

    <span class="s5"># Compute the desiried weights</span>
    <span class="s1">n = mod.nobs</span>
    <span class="s1">m = mod.k_states</span>
    <span class="s1">p = mod.k_endog</span>

    <span class="s1">desired = np.zeros((n</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">p)) * np.nan</span>
    <span class="s5"># Here we manually compute the weights by adjusting one observation at a</span>
    <span class="s5"># time</span>
    <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(n):</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(p):</span>
            <span class="s2">if </span><span class="s1">np.isnan(endog[j</span><span class="s2">, </span><span class="s1">i]):</span>
                <span class="s1">desired[:</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">i] = np.nan</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">y = endog.copy()</span>
                <span class="s1">y[j</span><span class="s2">, </span><span class="s1">i] = </span><span class="s4">1.0</span>
                <span class="s1">tmp_mod = mod.clone(y)</span>
                <span class="s1">tmp_mod.ssm.initialize_known([</span><span class="s4">1.2</span><span class="s2">, </span><span class="s4">0.8</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.eye(</span><span class="s4">2</span><span class="s1">) * </span><span class="s4">0</span><span class="s1">)</span>
                <span class="s1">tmp_mod.ssm.filter_univariate = </span><span class="s2">True</span>
                <span class="s1">tmp_res = tmp_mod.smooth([])</span>

                <span class="s1">desired[:</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">i] = (tmp_res.smoothed_state.T</span>
                                       <span class="s1">- res.smoothed_state.T)</span>

    <span class="s1">actual</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">_ = tools.compute_smoothed_state_weights(res)</span>

    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-12</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_smoothed_state_obs_weights_collapsed(reset_randomstate):</span>
    <span class="s5"># Tests for the collapsed case</span>
    <span class="s1">endog = np.zeros((</span><span class="s4">20</span><span class="s2">, </span><span class="s4">6</span><span class="s1">))</span>
    <span class="s1">endog[</span><span class="s4">2</span><span class="s2">, </span><span class="s1">:] = np.nan</span>
    <span class="s1">endog[</span><span class="s4">6</span><span class="s2">, </span><span class="s4">0</span><span class="s1">] = np.nan</span>
    <span class="s1">endog[</span><span class="s4">7</span><span class="s2">, </span><span class="s1">:] = np.nan</span>
    <span class="s1">endog[</span><span class="s4">8</span><span class="s2">, </span><span class="s4">1</span><span class="s1">] = np.nan</span>
    <span class="s1">mod = TVSS(endog)</span>
    <span class="s1">mod[</span><span class="s3">'obs_intercept'</span><span class="s1">] = np.zeros((</span><span class="s4">6</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span>
    <span class="s1">mod.ssm.initialize_known([</span><span class="s4">1.2</span><span class="s2">, </span><span class="s4">0.8</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.eye(</span><span class="s4">2</span><span class="s1">))</span>
    <span class="s1">mod.ssm.filter_collapsed = </span><span class="s2">True</span>
    <span class="s1">res = mod.smooth([])</span>

    <span class="s5"># Compute the desiried weights</span>
    <span class="s1">n = mod.nobs</span>
    <span class="s1">m = mod.k_states</span>
    <span class="s1">p = mod.k_endog</span>

    <span class="s1">desired = np.zeros((n</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">p)) * np.nan</span>
    <span class="s5"># Here we manually compute the weights by adjusting one observation at a</span>
    <span class="s5"># time</span>
    <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(n):</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(p):</span>
            <span class="s2">if </span><span class="s1">np.isnan(endog[j</span><span class="s2">, </span><span class="s1">i]):</span>
                <span class="s1">desired[:</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">i] = np.nan</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">y = endog.copy()</span>
                <span class="s1">y[j</span><span class="s2">, </span><span class="s1">i] = </span><span class="s4">1.0</span>
                <span class="s1">tmp_mod = mod.clone(y)</span>
                <span class="s1">tmp_mod[</span><span class="s3">'obs_intercept'</span><span class="s1">] = np.zeros((</span><span class="s4">6</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span>
                <span class="s1">tmp_mod.ssm.initialize_known([</span><span class="s4">1.2</span><span class="s2">, </span><span class="s4">0.8</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.eye(</span><span class="s4">2</span><span class="s1">))</span>
                <span class="s1">mod.ssm.filter_collapsed = </span><span class="s2">True</span>
                <span class="s1">tmp_res = tmp_mod.smooth([])</span>

                <span class="s1">desired[:</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">i] = (tmp_res.smoothed_state.T</span>
                                       <span class="s1">- res.smoothed_state.T)</span>

    <span class="s1">desired_state_intercept_weights = np.zeros((n</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">m)) * np.nan</span>
    <span class="s5"># Here we manually compute the weights by adjusting one state intercept</span>
    <span class="s5"># at a time</span>
    <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(n):</span>
        <span class="s2">for </span><span class="s1">ell </span><span class="s2">in </span><span class="s1">range(m):</span>
            <span class="s1">tmp_mod = mod.clone(endog)</span>
            <span class="s1">tmp_mod[</span><span class="s3">'obs_intercept'</span><span class="s1">] = np.zeros((</span><span class="s4">6</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span>
            <span class="s1">tmp_mod.ssm.initialize_known([</span><span class="s4">1.2</span><span class="s2">, </span><span class="s4">0.8</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.eye(</span><span class="s4">2</span><span class="s1">))</span>
            <span class="s1">mod.ssm.filter_collapsed = </span><span class="s2">True</span>

            <span class="s2">if </span><span class="s1">tmp_mod[</span><span class="s3">'state_intercept'</span><span class="s1">].ndim == </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">si = tmp_mod[</span><span class="s3">'state_intercept'</span><span class="s1">]</span>
                <span class="s1">tmp_mod[</span><span class="s3">'state_intercept'</span><span class="s1">] = np.zeros((mod.k_states</span><span class="s2">, </span><span class="s1">mod.nobs))</span>
                <span class="s1">tmp_mod[</span><span class="s3">'state_intercept'</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">:] = si[:</span><span class="s2">, None</span><span class="s1">]</span>
            <span class="s1">tmp_mod[</span><span class="s3">'state_intercept'</span><span class="s2">, </span><span class="s1">ell</span><span class="s2">, </span><span class="s1">j] += </span><span class="s4">1.0</span>
            <span class="s1">tmp_res = tmp_mod.ssm.smooth()</span>

            <span class="s1">desired_state_intercept_weights[:</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">ell] = (</span>
                <span class="s1">tmp_res.smoothed_state.T - res.smoothed_state.T)</span>

    <span class="s1">actual</span><span class="s2">, </span><span class="s1">actual_state_intercept_weights</span><span class="s2">, </span><span class="s1">_ = (</span>
        <span class="s1">tools.compute_smoothed_state_weights(res))</span>

    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-12</span><span class="s1">)</span>
    <span class="s1">assert_allclose(actual_state_intercept_weights</span><span class="s2">,</span>
                    <span class="s1">desired_state_intercept_weights</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-12</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'compute_j'</span><span class="s2">, </span><span class="s1">[np.arange(</span><span class="s4">10</span><span class="s1">)</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">5</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">9</span><span class="s1">]</span><span class="s2">, </span><span class="s4">8</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'compute_t'</span><span class="s2">, </span><span class="s1">[np.arange(</span><span class="s4">10</span><span class="s1">)</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">5</span><span class="s1">]</span><span class="s2">, </span><span class="s4">5</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_compute_t_compute_j(compute_j</span><span class="s2">, </span><span class="s1">compute_t</span><span class="s2">, </span><span class="s1">reset_randomstate):</span>
    <span class="s5"># Tests for the collapsed case</span>
    <span class="s1">endog = np.zeros((</span><span class="s4">10</span><span class="s2">, </span><span class="s4">6</span><span class="s1">))</span>
    <span class="s1">endog[</span><span class="s4">2</span><span class="s2">, </span><span class="s1">:] = np.nan</span>
    <span class="s1">endog[</span><span class="s4">6</span><span class="s2">, </span><span class="s4">0</span><span class="s1">] = np.nan</span>
    <span class="s1">endog[</span><span class="s4">7</span><span class="s2">, </span><span class="s1">:] = np.nan</span>
    <span class="s1">endog[</span><span class="s4">8</span><span class="s2">, </span><span class="s4">1</span><span class="s1">] = np.nan</span>
    <span class="s1">mod = TVSS(endog)</span>
    <span class="s1">mod[</span><span class="s3">'obs_intercept'</span><span class="s1">] = np.zeros((</span><span class="s4">6</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span>
    <span class="s1">mod.ssm.initialize_known([</span><span class="s4">1.2</span><span class="s2">, </span><span class="s4">0.8</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.eye(</span><span class="s4">2</span><span class="s1">))</span>
    <span class="s1">mod.ssm.filter_collapsed = </span><span class="s2">True</span>
    <span class="s1">res = mod.smooth([])</span>

    <span class="s5"># Compute the desiried weights</span>
    <span class="s1">n = mod.nobs</span>
    <span class="s1">m = mod.k_states</span>
    <span class="s1">p = mod.k_endog</span>

    <span class="s1">desired = np.zeros((n</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">p)) * np.nan</span>
    <span class="s5"># Here we manually compute the weights by adjusting one observation at a</span>
    <span class="s5"># time</span>
    <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(n):</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(p):</span>
            <span class="s2">if </span><span class="s1">np.isnan(endog[j</span><span class="s2">, </span><span class="s1">i]):</span>
                <span class="s1">desired[:</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">i] = np.nan</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">y = endog.copy()</span>
                <span class="s1">y[j</span><span class="s2">, </span><span class="s1">i] = </span><span class="s4">1.0</span>
                <span class="s1">tmp_mod = mod.clone(y)</span>
                <span class="s1">tmp_mod[</span><span class="s3">'obs_intercept'</span><span class="s1">] = np.zeros((</span><span class="s4">6</span><span class="s2">, </span><span class="s4">1</span><span class="s1">))</span>
                <span class="s1">tmp_mod.ssm.initialize_known([</span><span class="s4">1.2</span><span class="s2">, </span><span class="s4">0.8</span><span class="s1">]</span><span class="s2">, </span><span class="s1">np.eye(</span><span class="s4">2</span><span class="s1">))</span>
                <span class="s1">mod.ssm.filter_collapsed = </span><span class="s2">True</span>
                <span class="s1">tmp_res = tmp_mod.smooth([])</span>

                <span class="s1">desired[:</span><span class="s2">, </span><span class="s1">j</span><span class="s2">, </span><span class="s1">:</span><span class="s2">, </span><span class="s1">i] = (tmp_res.smoothed_state.T</span>
                                       <span class="s1">- res.smoothed_state.T)</span>

    <span class="s1">actual</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">_ = tools.compute_smoothed_state_weights(</span>
        <span class="s1">res</span><span class="s2">, </span><span class="s1">compute_t=compute_t</span><span class="s2">, </span><span class="s1">compute_j=compute_j)</span>

    <span class="s1">compute_t = np.atleast_1d(compute_t)</span>
    <span class="s1">compute_j = np.atleast_1d(compute_j)</span>
    <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">np.arange(</span><span class="s4">10</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">t </span><span class="s2">not in </span><span class="s1">compute_t:</span>
            <span class="s1">desired[t</span><span class="s2">, </span><span class="s1">:] = np.nan</span>
    <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">np.arange(</span><span class="s4">10</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">j </span><span class="s2">not in </span><span class="s1">compute_j:</span>
            <span class="s1">desired[:</span><span class="s2">, </span><span class="s1">j] = np.nan</span>

    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired</span><span class="s2">, </span><span class="s1">atol=</span><span class="s4">1e-7</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_resmooth():</span>
    <span class="s5"># Tests that resmooth works as it ought to, to reset the filter</span>
    <span class="s1">endog = [</span><span class="s4">0.1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.3</span><span class="s2">, </span><span class="s1">-</span><span class="s4">0.1</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">0.02</span><span class="s1">]</span>
    <span class="s1">mod = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">measurement_error=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s1">res1 = mod.smooth([</span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">2.0</span><span class="s2">, </span><span class="s4">1.0</span><span class="s1">])</span>
    <span class="s1">weights1_original</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">_ = tools.compute_smoothed_state_weights(</span>
        <span class="s1">res1</span><span class="s2">, </span><span class="s1">resmooth=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">res2 = mod.smooth([</span><span class="s4">0.2</span><span class="s2">, </span><span class="s4">1.0</span><span class="s2">, </span><span class="s4">1.2</span><span class="s1">])</span>
    <span class="s1">weights2_original</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">_ = tools.compute_smoothed_state_weights(</span>
        <span class="s1">res2</span><span class="s2">, </span><span class="s1">resmooth=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s1">weights1_no_resmooth</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">_ = tools.compute_smoothed_state_weights(</span>
        <span class="s1">res1</span><span class="s2">, </span><span class="s1">resmooth=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">weights1_resmooth</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">_ = tools.compute_smoothed_state_weights(</span>
        <span class="s1">res1</span><span class="s2">, </span><span class="s1">resmooth=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s1">weights2_no_resmooth</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">_ = tools.compute_smoothed_state_weights(</span>
        <span class="s1">res2</span><span class="s2">, </span><span class="s1">resmooth=</span><span class="s2">False</span><span class="s1">)</span>
    <span class="s1">weights2_resmooth</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">_ = tools.compute_smoothed_state_weights(</span>
        <span class="s1">res2</span><span class="s2">, </span><span class="s1">resmooth=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s1">weights1_default</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">_ = tools.compute_smoothed_state_weights(res1)</span>
    <span class="s1">weights2_default</span><span class="s2">, </span><span class="s1">_</span><span class="s2">, </span><span class="s1">_ = tools.compute_smoothed_state_weights(res2)</span>

    <span class="s1">assert_allclose(weights1_no_resmooth</span><span class="s2">, </span><span class="s1">weights2_original)</span>
    <span class="s1">assert_allclose(weights1_resmooth</span><span class="s2">, </span><span class="s1">weights1_original)</span>
    <span class="s1">assert_allclose(weights1_default</span><span class="s2">, </span><span class="s1">weights1_original)</span>

    <span class="s1">assert_allclose(weights2_no_resmooth</span><span class="s2">, </span><span class="s1">weights1_original)</span>
    <span class="s1">assert_allclose(weights2_resmooth</span><span class="s2">, </span><span class="s1">weights2_original)</span>
    <span class="s1">assert_allclose(weights2_default</span><span class="s2">, </span><span class="s1">weights2_original)</span>
</pre>
</body>
</html>