<html>
<head>
<title>test_qmc.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6897bb;}
.s4 { color: #6a8759;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_qmc.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">os</span>
<span class="s0">from </span><span class="s1">collections </span><span class="s0">import </span><span class="s1">Counter</span>
<span class="s0">from </span><span class="s1">itertools </span><span class="s0">import </span><span class="s1">combinations</span><span class="s0">, </span><span class="s1">product</span>

<span class="s0">import </span><span class="s1">pytest</span>
<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">numpy.testing </span><span class="s0">import </span><span class="s1">assert_allclose</span><span class="s0">, </span><span class="s1">assert_equal</span><span class="s0">, </span><span class="s1">assert_array_equal</span>

<span class="s0">from </span><span class="s1">scipy.spatial </span><span class="s0">import </span><span class="s1">distance</span>
<span class="s0">from </span><span class="s1">scipy.stats </span><span class="s0">import </span><span class="s1">shapiro</span>
<span class="s0">from </span><span class="s1">scipy.stats._sobol </span><span class="s0">import </span><span class="s1">_test_find_index</span>
<span class="s0">from </span><span class="s1">scipy.stats </span><span class="s0">import </span><span class="s1">qmc</span>
<span class="s0">from </span><span class="s1">scipy.stats._qmc </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">van_der_corput</span><span class="s0">, </span><span class="s1">n_primes</span><span class="s0">, </span><span class="s1">primes_from_2_to</span><span class="s0">,</span>
    <span class="s1">update_discrepancy</span><span class="s0">, </span><span class="s1">QMCEngine</span><span class="s0">, </span><span class="s1">_l1_norm</span><span class="s0">,</span>
    <span class="s1">_perturb_discrepancy</span><span class="s0">, </span><span class="s1">_lloyd_centroidal_voronoi_tessellation</span>
<span class="s1">)  </span><span class="s2"># noqa</span>


<span class="s0">class </span><span class="s1">TestUtils:</span>
    <span class="s0">def </span><span class="s1">test_scale(self):</span>
        <span class="s2"># 1d scalar</span>
        <span class="s1">space = [[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0.5</span><span class="s1">]]</span>
        <span class="s1">out = [[-</span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">6</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">2</span><span class="s1">]]</span>
        <span class="s1">scaled_space = qmc.scale(space</span><span class="s0">, </span><span class="s1">l_bounds=-</span><span class="s3">2</span><span class="s0">, </span><span class="s1">u_bounds=</span><span class="s3">6</span><span class="s1">)</span>

        <span class="s1">assert_allclose(scaled_space</span><span class="s0">, </span><span class="s1">out)</span>

        <span class="s2"># 2d space</span>
        <span class="s1">space = [[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">0.5</span><span class="s1">]]</span>
        <span class="s1">bounds = np.array([[-</span><span class="s3">2</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">6</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]])</span>
        <span class="s1">out = [[-</span><span class="s3">2</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">6</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2.5</span><span class="s1">]]</span>

        <span class="s1">scaled_space = qmc.scale(space</span><span class="s0">, </span><span class="s1">l_bounds=bounds[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">u_bounds=bounds[</span><span class="s3">1</span><span class="s1">])</span>

        <span class="s1">assert_allclose(scaled_space</span><span class="s0">, </span><span class="s1">out)</span>

        <span class="s1">scaled_back_space = qmc.scale(scaled_space</span><span class="s0">, </span><span class="s1">l_bounds=bounds[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">,</span>
                                      <span class="s1">u_bounds=bounds[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">reverse=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">assert_allclose(scaled_back_space</span><span class="s0">, </span><span class="s1">space)</span>

        <span class="s2"># broadcast</span>
        <span class="s1">space = [[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">0.5</span><span class="s1">]]</span>
        <span class="s1">l_bounds</span><span class="s0">, </span><span class="s1">u_bounds = </span><span class="s3">0</span><span class="s0">, </span><span class="s1">[</span><span class="s3">6</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span>
        <span class="s1">out = [[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">6</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">3</span><span class="s0">, </span><span class="s3">2.5</span><span class="s0">, </span><span class="s3">1.5</span><span class="s1">]]</span>

        <span class="s1">scaled_space = qmc.scale(space</span><span class="s0">, </span><span class="s1">l_bounds=l_bounds</span><span class="s0">, </span><span class="s1">u_bounds=u_bounds)</span>

        <span class="s1">assert_allclose(scaled_space</span><span class="s0">, </span><span class="s1">out)</span>

    <span class="s0">def </span><span class="s1">test_scale_random(self):</span>
        <span class="s1">rng = np.random.default_rng(</span><span class="s3">317589836511269190194010915937762468165</span><span class="s1">)</span>
        <span class="s1">sample = rng.random((</span><span class="s3">30</span><span class="s0">, </span><span class="s3">10</span><span class="s1">))</span>
        <span class="s1">a = -rng.random(</span><span class="s3">10</span><span class="s1">) * </span><span class="s3">10</span>
        <span class="s1">b = rng.random(</span><span class="s3">10</span><span class="s1">) * </span><span class="s3">10</span>
        <span class="s1">scaled = qmc.scale(sample</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">reverse=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">unscaled = qmc.scale(scaled</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">reverse=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">assert_allclose(unscaled</span><span class="s0">, </span><span class="s1">sample)</span>

    <span class="s0">def </span><span class="s1">test_scale_errors(self):</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">r&quot;Sample is not a 2D array&quot;</span><span class="s1">):</span>
            <span class="s1">space = [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">0.5</span><span class="s1">]</span>
            <span class="s1">qmc.scale(space</span><span class="s0">, </span><span class="s1">l_bounds=-</span><span class="s3">2</span><span class="s0">, </span><span class="s1">u_bounds=</span><span class="s3">6</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">r&quot;Bounds are not consistent&quot;</span><span class="s1">):</span>
            <span class="s1">space = [[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">0.5</span><span class="s1">]]</span>
            <span class="s1">bounds = np.array([[-</span><span class="s3">2</span><span class="s0">, </span><span class="s3">6</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">6</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]])</span>
            <span class="s1">qmc.scale(space</span><span class="s0">, </span><span class="s1">l_bounds=bounds[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">u_bounds=bounds[</span><span class="s3">1</span><span class="s1">])</span>

        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">r&quot;'l_bounds' and 'u_bounds'&quot;</span>
                                             <span class="s4">r&quot; must be broadcastable&quot;</span><span class="s1">):</span>
            <span class="s1">space = [[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">0.5</span><span class="s1">]]</span>
            <span class="s1">l_bounds</span><span class="s0">, </span><span class="s1">u_bounds = [-</span><span class="s3">2</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">6</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]</span>
            <span class="s1">qmc.scale(space</span><span class="s0">, </span><span class="s1">l_bounds=l_bounds</span><span class="s0">, </span><span class="s1">u_bounds=u_bounds)</span>

        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">r&quot;'l_bounds' and 'u_bounds'&quot;</span>
                                             <span class="s4">r&quot; must be broadcastable&quot;</span><span class="s1">):</span>
            <span class="s1">space = [[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">0.5</span><span class="s1">]]</span>
            <span class="s1">bounds = np.array([[-</span><span class="s3">2</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">6</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]])</span>
            <span class="s1">qmc.scale(space</span><span class="s0">, </span><span class="s1">l_bounds=bounds[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">u_bounds=bounds[</span><span class="s3">1</span><span class="s1">])</span>

        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">r&quot;Sample is not in unit &quot;</span>
                                             <span class="s4">r&quot;hypercube&quot;</span><span class="s1">):</span>
            <span class="s1">space = [[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1.5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">0.5</span><span class="s1">]]</span>
            <span class="s1">bounds = np.array([[-</span><span class="s3">2</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">6</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]])</span>
            <span class="s1">qmc.scale(space</span><span class="s0">, </span><span class="s1">l_bounds=bounds[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">u_bounds=bounds[</span><span class="s3">1</span><span class="s1">])</span>

        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">r&quot;Sample is out of bounds&quot;</span><span class="s1">):</span>
            <span class="s1">out = [[-</span><span class="s3">2</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">6</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">8</span><span class="s0">, </span><span class="s3">2.5</span><span class="s1">]]</span>
            <span class="s1">bounds = np.array([[-</span><span class="s3">2</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">6</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]])</span>
            <span class="s1">qmc.scale(out</span><span class="s0">, </span><span class="s1">l_bounds=bounds[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">u_bounds=bounds[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">,</span>
                      <span class="s1">reverse=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_discrepancy(self):</span>
        <span class="s1">space_1 = np.array([[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">2</span><span class="s0">, </span><span class="s3">6</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">5</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">6</span><span class="s0">, </span><span class="s3">4</span><span class="s1">]])</span>
        <span class="s1">space_1 = (</span><span class="s3">2.0 </span><span class="s1">* space_1 - </span><span class="s3">1.0</span><span class="s1">) / (</span><span class="s3">2.0 </span><span class="s1">* </span><span class="s3">6.0</span><span class="s1">)</span>
        <span class="s1">space_2 = np.array([[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">2</span><span class="s0">, </span><span class="s3">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">5</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">6</span><span class="s0">, </span><span class="s3">6</span><span class="s1">]])</span>
        <span class="s1">space_2 = (</span><span class="s3">2.0 </span><span class="s1">* space_2 - </span><span class="s3">1.0</span><span class="s1">) / (</span><span class="s3">2.0 </span><span class="s1">* </span><span class="s3">6.0</span><span class="s1">)</span>

        <span class="s2"># From Fang et al. Design and modeling for computer experiments, 2006</span>
        <span class="s1">assert_allclose(qmc.discrepancy(space_1)</span><span class="s0">, </span><span class="s3">0.0081</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-4</span><span class="s1">)</span>
        <span class="s1">assert_allclose(qmc.discrepancy(space_2)</span><span class="s0">, </span><span class="s3">0.0105</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-4</span><span class="s1">)</span>

        <span class="s2"># From Zhou Y.-D. et al. Mixture discrepancy for quasi-random point</span>
        <span class="s2"># sets. Journal of Complexity, 29 (3-4), pp. 283-301, 2013.</span>
        <span class="s2"># Example 4 on Page 298</span>
        <span class="s1">sample = np.array([[</span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">,</span>
                           <span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">,</span>
                           <span class="s1">[</span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">,</span>
                           <span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">,</span>
                           <span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">,</span>
                           <span class="s1">[</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">,</span>
                           <span class="s1">[</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]])</span>
        <span class="s1">sample = (</span><span class="s3">2.0 </span><span class="s1">* sample - </span><span class="s3">1.0</span><span class="s1">) / (</span><span class="s3">2.0 </span><span class="s1">* </span><span class="s3">2.0</span><span class="s1">)</span>

        <span class="s1">assert_allclose(qmc.discrepancy(sample</span><span class="s0">, </span><span class="s1">method=</span><span class="s4">'MD'</span><span class="s1">)</span><span class="s0">, </span><span class="s3">2.5000</span><span class="s0">,</span>
                        <span class="s1">atol=</span><span class="s3">1e-4</span><span class="s1">)</span>
        <span class="s1">assert_allclose(qmc.discrepancy(sample</span><span class="s0">, </span><span class="s1">method=</span><span class="s4">'WD'</span><span class="s1">)</span><span class="s0">, </span><span class="s3">1.3680</span><span class="s0">,</span>
                        <span class="s1">atol=</span><span class="s3">1e-4</span><span class="s1">)</span>
        <span class="s1">assert_allclose(qmc.discrepancy(sample</span><span class="s0">, </span><span class="s1">method=</span><span class="s4">'CD'</span><span class="s1">)</span><span class="s0">, </span><span class="s3">0.3172</span><span class="s0">,</span>
                        <span class="s1">atol=</span><span class="s3">1e-4</span><span class="s1">)</span>

        <span class="s2"># From Tim P. et al. Minimizing the L2 and Linf star discrepancies</span>
        <span class="s2"># of a single point in the unit hypercube. JCAM, 2005</span>
        <span class="s2"># Table 1 on Page 283</span>
        <span class="s0">for </span><span class="s1">dim </span><span class="s0">in </span><span class="s1">[</span><span class="s3">2</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">8</span><span class="s0">, </span><span class="s3">16</span><span class="s0">, </span><span class="s3">32</span><span class="s0">, </span><span class="s3">64</span><span class="s1">]:</span>
            <span class="s1">ref = np.sqrt(</span><span class="s3">3</span><span class="s1">**(-dim))</span>
            <span class="s1">assert_allclose(qmc.discrepancy(np.array([[</span><span class="s3">1</span><span class="s1">]*dim])</span><span class="s0">,</span>
                                            <span class="s1">method=</span><span class="s4">'L2-star'</span><span class="s1">)</span><span class="s0">, </span><span class="s1">ref)</span>

    <span class="s0">def </span><span class="s1">test_discrepancy_errors(self):</span>
        <span class="s1">sample = np.array([[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">2</span><span class="s0">, </span><span class="s3">6</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">5</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">6</span><span class="s0">, </span><span class="s3">4</span><span class="s1">]])</span>

        <span class="s0">with </span><span class="s1">pytest.raises(</span>
            <span class="s1">ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">r&quot;Sample is not in unit hypercube&quot;</span>
        <span class="s1">):</span>
            <span class="s1">qmc.discrepancy(sample)</span>

        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">r&quot;Sample is not a 2D array&quot;</span><span class="s1">):</span>
            <span class="s1">qmc.discrepancy([</span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s1">])</span>

        <span class="s1">sample = [[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">0.5</span><span class="s1">]]</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">r&quot;'toto' is not a valid ...&quot;</span><span class="s1">):</span>
            <span class="s1">qmc.discrepancy(sample</span><span class="s0">, </span><span class="s1">method=</span><span class="s4">&quot;toto&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_discrepancy_parallel(self</span><span class="s0">, </span><span class="s1">monkeypatch):</span>
        <span class="s1">sample = np.array([[</span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">,</span>
                           <span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">,</span>
                           <span class="s1">[</span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">,</span>
                           <span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">,</span>
                           <span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">,</span>
                           <span class="s1">[</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">,</span>
                           <span class="s1">[</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]])</span>
        <span class="s1">sample = (</span><span class="s3">2.0 </span><span class="s1">* sample - </span><span class="s3">1.0</span><span class="s1">) / (</span><span class="s3">2.0 </span><span class="s1">* </span><span class="s3">2.0</span><span class="s1">)</span>

        <span class="s1">assert_allclose(qmc.discrepancy(sample</span><span class="s0">, </span><span class="s1">method=</span><span class="s4">'MD'</span><span class="s0">, </span><span class="s1">workers=</span><span class="s3">8</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s3">2.5000</span><span class="s0">,</span>
                        <span class="s1">atol=</span><span class="s3">1e-4</span><span class="s1">)</span>
        <span class="s1">assert_allclose(qmc.discrepancy(sample</span><span class="s0">, </span><span class="s1">method=</span><span class="s4">'WD'</span><span class="s0">, </span><span class="s1">workers=</span><span class="s3">8</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s3">1.3680</span><span class="s0">,</span>
                        <span class="s1">atol=</span><span class="s3">1e-4</span><span class="s1">)</span>
        <span class="s1">assert_allclose(qmc.discrepancy(sample</span><span class="s0">, </span><span class="s1">method=</span><span class="s4">'CD'</span><span class="s0">, </span><span class="s1">workers=</span><span class="s3">8</span><span class="s1">)</span><span class="s0">,</span>
                        <span class="s3">0.3172</span><span class="s0">,</span>
                        <span class="s1">atol=</span><span class="s3">1e-4</span><span class="s1">)</span>

        <span class="s2"># From Tim P. et al. Minimizing the L2 and Linf star discrepancies</span>
        <span class="s2"># of a single point in the unit hypercube. JCAM, 2005</span>
        <span class="s2"># Table 1 on Page 283</span>
        <span class="s0">for </span><span class="s1">dim </span><span class="s0">in </span><span class="s1">[</span><span class="s3">2</span><span class="s0">, </span><span class="s3">4</span><span class="s0">, </span><span class="s3">8</span><span class="s0">, </span><span class="s3">16</span><span class="s0">, </span><span class="s3">32</span><span class="s0">, </span><span class="s3">64</span><span class="s1">]:</span>
            <span class="s1">ref = np.sqrt(</span><span class="s3">3 </span><span class="s1">** (-dim))</span>
            <span class="s1">assert_allclose(qmc.discrepancy(np.array([[</span><span class="s3">1</span><span class="s1">] * dim])</span><span class="s0">,</span>
                                            <span class="s1">method=</span><span class="s4">'L2-star'</span><span class="s0">, </span><span class="s1">workers=-</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">ref)</span>

        <span class="s1">monkeypatch.setattr(os</span><span class="s0">, </span><span class="s4">'cpu_count'</span><span class="s0">, lambda</span><span class="s1">: </span><span class="s0">None</span><span class="s1">)</span>
        <span class="s0">with </span><span class="s1">pytest.raises(NotImplementedError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;Cannot determine the&quot;</span><span class="s1">):</span>
            <span class="s1">qmc.discrepancy(sample</span><span class="s0">, </span><span class="s1">workers=-</span><span class="s3">1</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;Invalid number of workers...&quot;</span><span class="s1">):</span>
            <span class="s1">qmc.discrepancy(sample</span><span class="s0">, </span><span class="s1">workers=-</span><span class="s3">2</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_update_discrepancy(self):</span>
        <span class="s2"># From Fang et al. Design and modeling for computer experiments, 2006</span>
        <span class="s1">space_1 = np.array([[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">2</span><span class="s0">, </span><span class="s3">6</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">3</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">4</span><span class="s0">, </span><span class="s3">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">5</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">6</span><span class="s0">, </span><span class="s3">4</span><span class="s1">]])</span>
        <span class="s1">space_1 = (</span><span class="s3">2.0 </span><span class="s1">* space_1 - </span><span class="s3">1.0</span><span class="s1">) / (</span><span class="s3">2.0 </span><span class="s1">* </span><span class="s3">6.0</span><span class="s1">)</span>

        <span class="s1">disc_init = qmc.discrepancy(space_1[:-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">iterative=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">disc_iter = update_discrepancy(space_1[-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">space_1[:-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">disc_init)</span>

        <span class="s1">assert_allclose(disc_iter</span><span class="s0">, </span><span class="s3">0.0081</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-4</span><span class="s1">)</span>

        <span class="s2"># n&lt;d</span>
        <span class="s1">rng = np.random.default_rng(</span><span class="s3">241557431858162136881731220526394276199</span><span class="s1">)</span>
        <span class="s1">space_1 = rng.random((</span><span class="s3">4</span><span class="s0">, </span><span class="s3">10</span><span class="s1">))</span>

        <span class="s1">disc_ref = qmc.discrepancy(space_1)</span>
        <span class="s1">disc_init = qmc.discrepancy(space_1[:-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">iterative=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">disc_iter = update_discrepancy(space_1[-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">space_1[:-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">disc_init)</span>

        <span class="s1">assert_allclose(disc_iter</span><span class="s0">, </span><span class="s1">disc_ref</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-4</span><span class="s1">)</span>

        <span class="s2"># errors</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">r&quot;Sample is not in unit &quot;</span>
                                             <span class="s4">r&quot;hypercube&quot;</span><span class="s1">):</span>
            <span class="s1">update_discrepancy(space_1[-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">space_1[:-</span><span class="s3">1</span><span class="s1">] + </span><span class="s3">1</span><span class="s0">, </span><span class="s1">disc_init)</span>

        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">r&quot;Sample is not a 2D array&quot;</span><span class="s1">):</span>
            <span class="s1">update_discrepancy(space_1[-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">space_1[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">disc_init)</span>

        <span class="s1">x_new = [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s1">]</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">r&quot;x_new is not in unit &quot;</span>
                                             <span class="s4">r&quot;hypercube&quot;</span><span class="s1">):</span>
            <span class="s1">update_discrepancy(x_new</span><span class="s0">, </span><span class="s1">space_1[:-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">disc_init)</span>

        <span class="s1">x_new = [[</span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">0.5</span><span class="s1">]]</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">r&quot;x_new is not a 1D array&quot;</span><span class="s1">):</span>
            <span class="s1">update_discrepancy(x_new</span><span class="s0">, </span><span class="s1">space_1[:-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">disc_init)</span>

        <span class="s1">x_new = [</span><span class="s3">0.3</span><span class="s0">, </span><span class="s3">0.1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">r&quot;x_new and sample must be &quot;</span>
                                             <span class="s4">r&quot;broadcastable&quot;</span><span class="s1">):</span>
            <span class="s1">update_discrepancy(x_new</span><span class="s0">, </span><span class="s1">space_1[:-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">disc_init)</span>

    <span class="s0">def </span><span class="s1">test_perm_discrepancy(self):</span>
        <span class="s1">rng = np.random.default_rng(</span><span class="s3">46449423132557934943847369749645759997</span><span class="s1">)</span>
        <span class="s1">qmc_gen = qmc.LatinHypercube(</span><span class="s3">5</span><span class="s0">, </span><span class="s1">seed=rng)</span>
        <span class="s1">sample = qmc_gen.random(</span><span class="s3">10</span><span class="s1">)</span>
        <span class="s1">disc = qmc.discrepancy(sample)</span>

        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">100</span><span class="s1">):</span>
            <span class="s1">row_1 = rng.integers(</span><span class="s3">10</span><span class="s1">)</span>
            <span class="s1">row_2 = rng.integers(</span><span class="s3">10</span><span class="s1">)</span>
            <span class="s1">col = rng.integers(</span><span class="s3">5</span><span class="s1">)</span>

            <span class="s1">disc = _perturb_discrepancy(sample</span><span class="s0">, </span><span class="s1">row_1</span><span class="s0">, </span><span class="s1">row_2</span><span class="s0">, </span><span class="s1">col</span><span class="s0">, </span><span class="s1">disc)</span>
            <span class="s1">sample[row_1</span><span class="s0">, </span><span class="s1">col]</span><span class="s0">, </span><span class="s1">sample[row_2</span><span class="s0">, </span><span class="s1">col] = (</span>
                <span class="s1">sample[row_2</span><span class="s0">, </span><span class="s1">col]</span><span class="s0">, </span><span class="s1">sample[row_1</span><span class="s0">, </span><span class="s1">col])</span>
            <span class="s1">disc_reference = qmc.discrepancy(sample)</span>
            <span class="s1">assert_allclose(disc</span><span class="s0">, </span><span class="s1">disc_reference)</span>

    <span class="s0">def </span><span class="s1">test_discrepancy_alternative_implementation(self):</span>
        <span class="s5">&quot;&quot;&quot;Alternative definitions from Matt Haberland.&quot;&quot;&quot;</span>

        <span class="s0">def </span><span class="s1">disc_c2(x):</span>
            <span class="s1">n</span><span class="s0">, </span><span class="s1">s = x.shape</span>
            <span class="s1">xij = x</span>
            <span class="s1">disc1 = np.sum(np.prod((</span><span class="s3">1</span>
                                    <span class="s1">+ </span><span class="s3">1</span><span class="s1">/</span><span class="s3">2</span><span class="s1">*np.abs(xij-</span><span class="s3">0.5</span><span class="s1">)</span>
                                    <span class="s1">- </span><span class="s3">1</span><span class="s1">/</span><span class="s3">2</span><span class="s1">*np.abs(xij-</span><span class="s3">0.5</span><span class="s1">)**</span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">))</span>
            <span class="s1">xij = x[</span><span class="s0">None, </span><span class="s1">:</span><span class="s0">, </span><span class="s1">:]</span>
            <span class="s1">xkj = x[:</span><span class="s0">, None, </span><span class="s1">:]</span>
            <span class="s1">disc2 = np.sum(np.sum(np.prod(</span><span class="s3">1</span>
                                          <span class="s1">+ </span><span class="s3">1</span><span class="s1">/</span><span class="s3">2</span><span class="s1">*np.abs(xij - </span><span class="s3">0.5</span><span class="s1">)</span>
                                          <span class="s1">+ </span><span class="s3">1</span><span class="s1">/</span><span class="s3">2</span><span class="s1">*np.abs(xkj - </span><span class="s3">0.5</span><span class="s1">)</span>
                                          <span class="s1">- </span><span class="s3">1</span><span class="s1">/</span><span class="s3">2</span><span class="s1">*np.abs(xij - xkj)</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">2</span><span class="s1">)</span><span class="s0">,</span>
                                  <span class="s1">axis=</span><span class="s3">0</span><span class="s1">))</span>
            <span class="s0">return </span><span class="s1">(</span><span class="s3">13</span><span class="s1">/</span><span class="s3">12</span><span class="s1">)**s - </span><span class="s3">2</span><span class="s1">/n * disc1 + </span><span class="s3">1</span><span class="s1">/n**</span><span class="s3">2</span><span class="s1">*disc2</span>

        <span class="s0">def </span><span class="s1">disc_wd(x):</span>
            <span class="s1">n</span><span class="s0">, </span><span class="s1">s = x.shape</span>
            <span class="s1">xij = x[</span><span class="s0">None, </span><span class="s1">:</span><span class="s0">, </span><span class="s1">:]</span>
            <span class="s1">xkj = x[:</span><span class="s0">, None, </span><span class="s1">:]</span>
            <span class="s1">disc = np.sum(np.sum(np.prod(</span><span class="s3">3</span><span class="s1">/</span><span class="s3">2</span>
                                         <span class="s1">- np.abs(xij - xkj)</span>
                                         <span class="s1">+ np.abs(xij - xkj)**</span><span class="s3">2</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">2</span><span class="s1">)</span><span class="s0">,</span>
                                 <span class="s1">axis=</span><span class="s3">0</span><span class="s1">))</span>
            <span class="s0">return </span><span class="s1">-(</span><span class="s3">4</span><span class="s1">/</span><span class="s3">3</span><span class="s1">)**s + </span><span class="s3">1</span><span class="s1">/n**</span><span class="s3">2 </span><span class="s1">* disc</span>

        <span class="s0">def </span><span class="s1">disc_md(x):</span>
            <span class="s1">n</span><span class="s0">, </span><span class="s1">s = x.shape</span>
            <span class="s1">xij = x</span>
            <span class="s1">disc1 = np.sum(np.prod((</span><span class="s3">5</span><span class="s1">/</span><span class="s3">3</span>
                                    <span class="s1">- </span><span class="s3">1</span><span class="s1">/</span><span class="s3">4</span><span class="s1">*np.abs(xij-</span><span class="s3">0.5</span><span class="s1">)</span>
                                    <span class="s1">- </span><span class="s3">1</span><span class="s1">/</span><span class="s3">4</span><span class="s1">*np.abs(xij-</span><span class="s3">0.5</span><span class="s1">)**</span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">))</span>
            <span class="s1">xij = x[</span><span class="s0">None, </span><span class="s1">:</span><span class="s0">, </span><span class="s1">:]</span>
            <span class="s1">xkj = x[:</span><span class="s0">, None, </span><span class="s1">:]</span>
            <span class="s1">disc2 = np.sum(np.sum(np.prod(</span><span class="s3">15</span><span class="s1">/</span><span class="s3">8</span>
                                          <span class="s1">- </span><span class="s3">1</span><span class="s1">/</span><span class="s3">4</span><span class="s1">*np.abs(xij - </span><span class="s3">0.5</span><span class="s1">)</span>
                                          <span class="s1">- </span><span class="s3">1</span><span class="s1">/</span><span class="s3">4</span><span class="s1">*np.abs(xkj - </span><span class="s3">0.5</span><span class="s1">)</span>
                                          <span class="s1">- </span><span class="s3">3</span><span class="s1">/</span><span class="s3">4</span><span class="s1">*np.abs(xij - xkj)</span>
                                          <span class="s1">+ </span><span class="s3">1</span><span class="s1">/</span><span class="s3">2</span><span class="s1">*np.abs(xij - xkj)**</span><span class="s3">2</span><span class="s0">,</span>
                                          <span class="s1">axis=</span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">))</span>
            <span class="s0">return </span><span class="s1">(</span><span class="s3">19</span><span class="s1">/</span><span class="s3">12</span><span class="s1">)**s - </span><span class="s3">2</span><span class="s1">/n * disc1 + </span><span class="s3">1</span><span class="s1">/n**</span><span class="s3">2</span><span class="s1">*disc2</span>

        <span class="s0">def </span><span class="s1">disc_star_l2(x):</span>
            <span class="s1">n</span><span class="s0">, </span><span class="s1">s = x.shape</span>
            <span class="s0">return </span><span class="s1">np.sqrt(</span>
                <span class="s3">3 </span><span class="s1">** (-s) - </span><span class="s3">2 </span><span class="s1">** (</span><span class="s3">1 </span><span class="s1">- s) / n</span>
                <span class="s1">* np.sum(np.prod(</span><span class="s3">1 </span><span class="s1">- x ** </span><span class="s3">2</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">))</span>
                <span class="s1">+ np.sum([</span>
                    <span class="s1">np.prod(</span><span class="s3">1 </span><span class="s1">- np.maximum(x[k</span><span class="s0">, </span><span class="s1">:]</span><span class="s0">, </span><span class="s1">x[j</span><span class="s0">, </span><span class="s1">:]))</span>
                    <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range(n) </span><span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(n)</span>
                <span class="s1">]) / n ** </span><span class="s3">2</span>
            <span class="s1">)</span>

        <span class="s1">rng = np.random.default_rng(</span><span class="s3">117065081482921065782761407107747179201</span><span class="s1">)</span>
        <span class="s1">sample = rng.random((</span><span class="s3">30</span><span class="s0">, </span><span class="s3">10</span><span class="s1">))</span>

        <span class="s1">disc_curr = qmc.discrepancy(sample</span><span class="s0">, </span><span class="s1">method=</span><span class="s4">'CD'</span><span class="s1">)</span>
        <span class="s1">disc_alt = disc_c2(sample)</span>
        <span class="s1">assert_allclose(disc_curr</span><span class="s0">, </span><span class="s1">disc_alt)</span>

        <span class="s1">disc_curr = qmc.discrepancy(sample</span><span class="s0">, </span><span class="s1">method=</span><span class="s4">'WD'</span><span class="s1">)</span>
        <span class="s1">disc_alt = disc_wd(sample)</span>
        <span class="s1">assert_allclose(disc_curr</span><span class="s0">, </span><span class="s1">disc_alt)</span>

        <span class="s1">disc_curr = qmc.discrepancy(sample</span><span class="s0">, </span><span class="s1">method=</span><span class="s4">'MD'</span><span class="s1">)</span>
        <span class="s1">disc_alt = disc_md(sample)</span>
        <span class="s1">assert_allclose(disc_curr</span><span class="s0">, </span><span class="s1">disc_alt)</span>

        <span class="s1">disc_curr = qmc.discrepancy(sample</span><span class="s0">, </span><span class="s1">method=</span><span class="s4">'L2-star'</span><span class="s1">)</span>
        <span class="s1">disc_alt = disc_star_l2(sample)</span>
        <span class="s1">assert_allclose(disc_curr</span><span class="s0">, </span><span class="s1">disc_alt)</span>

    <span class="s0">def </span><span class="s1">test_n_primes(self):</span>
        <span class="s1">primes = n_primes(</span><span class="s3">10</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">primes[-</span><span class="s3">1</span><span class="s1">] == </span><span class="s3">29</span>

        <span class="s1">primes = n_primes(</span><span class="s3">168</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">primes[-</span><span class="s3">1</span><span class="s1">] == </span><span class="s3">997</span>

        <span class="s1">primes = n_primes(</span><span class="s3">350</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">primes[-</span><span class="s3">1</span><span class="s1">] == </span><span class="s3">2357</span>

    <span class="s0">def </span><span class="s1">test_primes(self):</span>
        <span class="s1">primes = primes_from_2_to(</span><span class="s3">50</span><span class="s1">)</span>
        <span class="s1">out = [</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">5</span><span class="s0">, </span><span class="s3">7</span><span class="s0">, </span><span class="s3">11</span><span class="s0">, </span><span class="s3">13</span><span class="s0">, </span><span class="s3">17</span><span class="s0">, </span><span class="s3">19</span><span class="s0">, </span><span class="s3">23</span><span class="s0">, </span><span class="s3">29</span><span class="s0">, </span><span class="s3">31</span><span class="s0">, </span><span class="s3">37</span><span class="s0">, </span><span class="s3">41</span><span class="s0">, </span><span class="s3">43</span><span class="s0">, </span><span class="s3">47</span><span class="s1">]</span>
        <span class="s1">assert_allclose(primes</span><span class="s0">, </span><span class="s1">out)</span>


<span class="s0">class </span><span class="s1">TestVDC:</span>
    <span class="s0">def </span><span class="s1">test_van_der_corput(self):</span>
        <span class="s1">sample = van_der_corput(</span><span class="s3">10</span><span class="s1">)</span>
        <span class="s1">out = [</span><span class="s3">0.0</span><span class="s0">, </span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">0.25</span><span class="s0">, </span><span class="s3">0.75</span><span class="s0">, </span><span class="s3">0.125</span><span class="s0">, </span><span class="s3">0.625</span><span class="s0">,</span>
               <span class="s3">0.375</span><span class="s0">, </span><span class="s3">0.875</span><span class="s0">, </span><span class="s3">0.0625</span><span class="s0">, </span><span class="s3">0.5625</span><span class="s1">]</span>
        <span class="s1">assert_allclose(sample</span><span class="s0">, </span><span class="s1">out)</span>

        <span class="s1">sample = van_der_corput(</span><span class="s3">10</span><span class="s0">, </span><span class="s1">workers=</span><span class="s3">4</span><span class="s1">)</span>
        <span class="s1">assert_allclose(sample</span><span class="s0">, </span><span class="s1">out)</span>

        <span class="s1">sample = van_der_corput(</span><span class="s3">10</span><span class="s0">, </span><span class="s1">workers=</span><span class="s3">8</span><span class="s1">)</span>
        <span class="s1">assert_allclose(sample</span><span class="s0">, </span><span class="s1">out)</span>

        <span class="s1">sample = van_der_corput(</span><span class="s3">7</span><span class="s0">, </span><span class="s1">start_index=</span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">assert_allclose(sample</span><span class="s0">, </span><span class="s1">out[</span><span class="s3">3</span><span class="s1">:])</span>

    <span class="s0">def </span><span class="s1">test_van_der_corput_scramble(self):</span>
        <span class="s1">seed = </span><span class="s3">338213789010180879520345496831675783177</span>
        <span class="s1">out = van_der_corput(</span><span class="s3">10</span><span class="s0">, </span><span class="s1">scramble=</span><span class="s0">True, </span><span class="s1">seed=seed)</span>

        <span class="s1">sample = van_der_corput(</span><span class="s3">7</span><span class="s0">, </span><span class="s1">start_index=</span><span class="s3">3</span><span class="s0">, </span><span class="s1">scramble=</span><span class="s0">True, </span><span class="s1">seed=seed)</span>
        <span class="s1">assert_allclose(sample</span><span class="s0">, </span><span class="s1">out[</span><span class="s3">3</span><span class="s1">:])</span>

        <span class="s1">sample = van_der_corput(</span>
            <span class="s3">7</span><span class="s0">, </span><span class="s1">start_index=</span><span class="s3">3</span><span class="s0">, </span><span class="s1">scramble=</span><span class="s0">True, </span><span class="s1">seed=seed</span><span class="s0">, </span><span class="s1">workers=</span><span class="s3">4</span>
        <span class="s1">)</span>
        <span class="s1">assert_allclose(sample</span><span class="s0">, </span><span class="s1">out[</span><span class="s3">3</span><span class="s1">:])</span>

        <span class="s1">sample = van_der_corput(</span>
            <span class="s3">7</span><span class="s0">, </span><span class="s1">start_index=</span><span class="s3">3</span><span class="s0">, </span><span class="s1">scramble=</span><span class="s0">True, </span><span class="s1">seed=seed</span><span class="s0">, </span><span class="s1">workers=</span><span class="s3">8</span>
        <span class="s1">)</span>
        <span class="s1">assert_allclose(sample</span><span class="s0">, </span><span class="s1">out[</span><span class="s3">3</span><span class="s1">:])</span>

    <span class="s0">def </span><span class="s1">test_invalid_base_error(self):</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">r&quot;'base' must be at least 2&quot;</span><span class="s1">):</span>
            <span class="s1">van_der_corput(</span><span class="s3">10</span><span class="s0">, </span><span class="s1">base=</span><span class="s3">1</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">RandomEngine(qmc.QMCEngine):</span>
    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">d</span><span class="s0">, </span><span class="s1">optimization=</span><span class="s0">None, </span><span class="s1">seed=</span><span class="s0">None</span><span class="s1">):</span>
        <span class="s1">super().__init__(d=d</span><span class="s0">, </span><span class="s1">optimization=optimization</span><span class="s0">, </span><span class="s1">seed=seed)</span>

    <span class="s0">def </span><span class="s1">_random(self</span><span class="s0">, </span><span class="s1">n=</span><span class="s3">1</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">workers=</span><span class="s3">1</span><span class="s1">):</span>
        <span class="s1">sample = self.rng.random((n</span><span class="s0">, </span><span class="s1">self.d))</span>
        <span class="s0">return </span><span class="s1">sample</span>


<span class="s0">def </span><span class="s1">test_subclassing_QMCEngine():</span>
    <span class="s1">engine = RandomEngine(</span><span class="s3">2</span><span class="s0">, </span><span class="s1">seed=</span><span class="s3">175180605424926556207367152557812293274</span><span class="s1">)</span>

    <span class="s1">sample_1 = engine.random(n=</span><span class="s3">5</span><span class="s1">)</span>
    <span class="s1">sample_2 = engine.random(n=</span><span class="s3">7</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">engine.num_generated == </span><span class="s3">12</span>

    <span class="s2"># reset and re-sample</span>
    <span class="s1">engine.reset()</span>
    <span class="s0">assert </span><span class="s1">engine.num_generated == </span><span class="s3">0</span>

    <span class="s1">sample_1_test = engine.random(n=</span><span class="s3">5</span><span class="s1">)</span>
    <span class="s1">assert_equal(sample_1</span><span class="s0">, </span><span class="s1">sample_1_test)</span>

    <span class="s2"># repeat reset and fast forward</span>
    <span class="s1">engine.reset()</span>
    <span class="s1">engine.fast_forward(n=</span><span class="s3">5</span><span class="s1">)</span>
    <span class="s1">sample_2_test = engine.random(n=</span><span class="s3">7</span><span class="s1">)</span>

    <span class="s1">assert_equal(sample_2</span><span class="s0">, </span><span class="s1">sample_2_test)</span>
    <span class="s0">assert </span><span class="s1">engine.num_generated == </span><span class="s3">12</span>


<span class="s0">def </span><span class="s1">test_raises():</span>
    <span class="s2"># input validation</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">r&quot;d must be a non-negative integer&quot;</span><span class="s1">):</span>
        <span class="s1">RandomEngine((</span><span class="s3">2</span><span class="s0">,</span><span class="s1">))  </span><span class="s2"># noqa</span>

    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">r&quot;d must be a non-negative integer&quot;</span><span class="s1">):</span>
        <span class="s1">RandomEngine(-</span><span class="s3">1</span><span class="s1">)  </span><span class="s2"># noqa</span>

    <span class="s1">msg = </span><span class="s4">r&quot;'u_bounds' and 'l_bounds' must be integers&quot;</span>
    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">engine = RandomEngine(</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">engine.integers(l_bounds=</span><span class="s3">1</span><span class="s0">, </span><span class="s1">u_bounds=</span><span class="s3">1.1</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_integers():</span>
    <span class="s1">engine = RandomEngine(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">seed=</span><span class="s3">231195739755290648063853336582377368684</span><span class="s1">)</span>

    <span class="s2"># basic tests</span>
    <span class="s1">sample = engine.integers(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">n=</span><span class="s3">10</span><span class="s1">)</span>
    <span class="s1">assert_equal(np.unique(sample)</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s1">])</span>

    <span class="s0">assert </span><span class="s1">sample.dtype == np.dtype(</span><span class="s4">'int64'</span><span class="s1">)</span>

    <span class="s1">sample = engine.integers(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">n=</span><span class="s3">10</span><span class="s0">, </span><span class="s1">endpoint=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">assert_equal(np.unique(sample)</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">])</span>

    <span class="s1">low = -</span><span class="s3">5</span>
    <span class="s1">high = </span><span class="s3">7</span>

    <span class="s2"># scaling logic</span>
    <span class="s1">engine.reset()</span>
    <span class="s1">ref_sample = engine.random(</span><span class="s3">20</span><span class="s1">)</span>
    <span class="s1">ref_sample = ref_sample * (high - low) + low</span>
    <span class="s1">ref_sample = np.floor(ref_sample).astype(np.int64)</span>

    <span class="s1">engine.reset()</span>
    <span class="s1">sample = engine.integers(low</span><span class="s0">, </span><span class="s1">u_bounds=high</span><span class="s0">, </span><span class="s1">n=</span><span class="s3">20</span><span class="s0">, </span><span class="s1">endpoint=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s1">assert_equal(sample</span><span class="s0">, </span><span class="s1">ref_sample)</span>

    <span class="s2"># up to bounds, no less, no more</span>
    <span class="s1">sample = engine.integers(low</span><span class="s0">, </span><span class="s1">u_bounds=high</span><span class="s0">, </span><span class="s1">n=</span><span class="s3">100</span><span class="s0">, </span><span class="s1">endpoint=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">assert_equal((sample.min()</span><span class="s0">, </span><span class="s1">sample.max())</span><span class="s0">, </span><span class="s1">(low</span><span class="s0">, </span><span class="s1">high-</span><span class="s3">1</span><span class="s1">))</span>

    <span class="s1">sample = engine.integers(low</span><span class="s0">, </span><span class="s1">u_bounds=high</span><span class="s0">, </span><span class="s1">n=</span><span class="s3">100</span><span class="s0">, </span><span class="s1">endpoint=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">assert_equal((sample.min()</span><span class="s0">, </span><span class="s1">sample.max())</span><span class="s0">, </span><span class="s1">(low</span><span class="s0">, </span><span class="s1">high))</span>


<span class="s0">def </span><span class="s1">test_integers_nd():</span>
    <span class="s1">d = </span><span class="s3">10</span>
    <span class="s1">rng = np.random.default_rng(</span><span class="s3">3716505122102428560615700415287450951</span><span class="s1">)</span>
    <span class="s1">low = rng.integers(low=-</span><span class="s3">5</span><span class="s0">, </span><span class="s1">high=-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">size=d)</span>
    <span class="s1">high = rng.integers(low=</span><span class="s3">1</span><span class="s0">, </span><span class="s1">high=</span><span class="s3">5</span><span class="s0">, </span><span class="s1">size=d</span><span class="s0">, </span><span class="s1">endpoint=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">engine = RandomEngine(d</span><span class="s0">, </span><span class="s1">seed=rng)</span>

    <span class="s1">sample = engine.integers(low</span><span class="s0">, </span><span class="s1">u_bounds=high</span><span class="s0">, </span><span class="s1">n=</span><span class="s3">100</span><span class="s0">, </span><span class="s1">endpoint=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">assert_equal(sample.min(axis=</span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">low)</span>
    <span class="s1">assert_equal(sample.max(axis=</span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">high-</span><span class="s3">1</span><span class="s1">)</span>

    <span class="s1">sample = engine.integers(low</span><span class="s0">, </span><span class="s1">u_bounds=high</span><span class="s0">, </span><span class="s1">n=</span><span class="s3">100</span><span class="s0">, </span><span class="s1">endpoint=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">assert_equal(sample.min(axis=</span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">low)</span>
    <span class="s1">assert_equal(sample.max(axis=</span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">high)</span>


<span class="s0">class </span><span class="s1">QMCEngineTests:</span>
    <span class="s5">&quot;&quot;&quot;Generic tests for QMC engines.&quot;&quot;&quot;</span>
    <span class="s1">qmce = NotImplemented</span>
    <span class="s1">can_scramble = NotImplemented</span>
    <span class="s1">unscramble_nd = NotImplemented</span>
    <span class="s1">scramble_nd = NotImplemented</span>

    <span class="s1">scramble = [</span><span class="s0">True, False</span><span class="s1">]</span>
    <span class="s1">ids = [</span><span class="s4">&quot;Scrambled&quot;</span><span class="s0">, </span><span class="s4">&quot;Unscrambled&quot;</span><span class="s1">]</span>

    <span class="s0">def </span><span class="s1">engine(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">scramble: bool</span><span class="s0">,</span>
        <span class="s1">seed=</span><span class="s3">170382760648021597650530316304495310428</span><span class="s0">,</span>
        <span class="s1">**kwargs</span>
    <span class="s1">) -&gt; QMCEngine:</span>
        <span class="s0">if </span><span class="s1">self.can_scramble:</span>
            <span class="s0">return </span><span class="s1">self.qmce(scramble=scramble</span><span class="s0">, </span><span class="s1">seed=seed</span><span class="s0">, </span><span class="s1">**kwargs)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">scramble:</span>
                <span class="s1">pytest.skip()</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s1">self.qmce(seed=seed</span><span class="s0">, </span><span class="s1">**kwargs)</span>

    <span class="s0">def </span><span class="s1">reference(self</span><span class="s0">, </span><span class="s1">scramble: bool) -&gt; np.ndarray:</span>
        <span class="s0">return </span><span class="s1">self.scramble_nd </span><span class="s0">if </span><span class="s1">scramble </span><span class="s0">else </span><span class="s1">self.unscramble_nd</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;scramble&quot;</span><span class="s0">, </span><span class="s1">scramble</span><span class="s0">, </span><span class="s1">ids=ids)</span>
    <span class="s0">def </span><span class="s1">test_0dim(self</span><span class="s0">, </span><span class="s1">scramble):</span>
        <span class="s1">engine = self.engine(d=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">scramble=scramble)</span>
        <span class="s1">sample = engine.random(</span><span class="s3">4</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(np.empty((</span><span class="s3">4</span><span class="s0">, </span><span class="s3">0</span><span class="s1">))</span><span class="s0">, </span><span class="s1">sample)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;scramble&quot;</span><span class="s0">, </span><span class="s1">scramble</span><span class="s0">, </span><span class="s1">ids=ids)</span>
    <span class="s0">def </span><span class="s1">test_0sample(self</span><span class="s0">, </span><span class="s1">scramble):</span>
        <span class="s1">engine = self.engine(d=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">scramble=scramble)</span>
        <span class="s1">sample = engine.random(</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(np.empty((</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span><span class="s0">, </span><span class="s1">sample)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;scramble&quot;</span><span class="s0">, </span><span class="s1">scramble</span><span class="s0">, </span><span class="s1">ids=ids)</span>
    <span class="s0">def </span><span class="s1">test_1sample(self</span><span class="s0">, </span><span class="s1">scramble):</span>
        <span class="s1">engine = self.engine(d=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">scramble=scramble)</span>
        <span class="s1">sample = engine.random(</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">) == sample.shape</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;scramble&quot;</span><span class="s0">, </span><span class="s1">scramble</span><span class="s0">, </span><span class="s1">ids=ids)</span>
    <span class="s0">def </span><span class="s1">test_bounds(self</span><span class="s0">, </span><span class="s1">scramble):</span>
        <span class="s1">engine = self.engine(d=</span><span class="s3">100</span><span class="s0">, </span><span class="s1">scramble=scramble)</span>
        <span class="s1">sample = engine.random(</span><span class="s3">512</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">np.all(sample &gt;= </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">np.all(sample &lt;= </span><span class="s3">1</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;scramble&quot;</span><span class="s0">, </span><span class="s1">scramble</span><span class="s0">, </span><span class="s1">ids=ids)</span>
    <span class="s0">def </span><span class="s1">test_sample(self</span><span class="s0">, </span><span class="s1">scramble):</span>
        <span class="s1">ref_sample = self.reference(scramble=scramble)</span>
        <span class="s1">engine = self.engine(d=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">scramble=scramble)</span>
        <span class="s1">sample = engine.random(n=len(ref_sample))</span>

        <span class="s1">assert_allclose(sample</span><span class="s0">, </span><span class="s1">ref_sample</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-1</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">engine.num_generated == len(ref_sample)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;scramble&quot;</span><span class="s0">, </span><span class="s1">scramble</span><span class="s0">, </span><span class="s1">ids=ids)</span>
    <span class="s0">def </span><span class="s1">test_continuing(self</span><span class="s0">, </span><span class="s1">scramble):</span>
        <span class="s1">engine = self.engine(d=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">scramble=scramble)</span>
        <span class="s1">ref_sample = engine.random(n=</span><span class="s3">8</span><span class="s1">)</span>

        <span class="s1">engine = self.engine(d=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">scramble=scramble)</span>

        <span class="s1">n_half = len(ref_sample) // </span><span class="s3">2</span>

        <span class="s1">_ = engine.random(n=n_half)</span>
        <span class="s1">sample = engine.random(n=n_half)</span>
        <span class="s1">assert_allclose(sample</span><span class="s0">, </span><span class="s1">ref_sample[n_half:]</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-1</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;scramble&quot;</span><span class="s0">, </span><span class="s1">scramble</span><span class="s0">, </span><span class="s1">ids=ids)</span>
    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s4">&quot;seed&quot;</span><span class="s0">,</span>
        <span class="s1">(</span>
            <span class="s3">170382760648021597650530316304495310428</span><span class="s0">,</span>
            <span class="s1">np.random.default_rng(</span><span class="s3">170382760648021597650530316304495310428</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s0">None,</span>
        <span class="s1">)</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_reset(self</span><span class="s0">, </span><span class="s1">scramble</span><span class="s0">, </span><span class="s1">seed):</span>
        <span class="s1">engine = self.engine(d=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">scramble=scramble</span><span class="s0">, </span><span class="s1">seed=seed)</span>
        <span class="s1">ref_sample = engine.random(n=</span><span class="s3">8</span><span class="s1">)</span>

        <span class="s1">engine.reset()</span>
        <span class="s0">assert </span><span class="s1">engine.num_generated == </span><span class="s3">0</span>

        <span class="s1">sample = engine.random(n=</span><span class="s3">8</span><span class="s1">)</span>
        <span class="s1">assert_allclose(sample</span><span class="s0">, </span><span class="s1">ref_sample)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;scramble&quot;</span><span class="s0">, </span><span class="s1">scramble</span><span class="s0">, </span><span class="s1">ids=ids)</span>
    <span class="s0">def </span><span class="s1">test_fast_forward(self</span><span class="s0">, </span><span class="s1">scramble):</span>
        <span class="s1">engine = self.engine(d=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">scramble=scramble)</span>
        <span class="s1">ref_sample = engine.random(n=</span><span class="s3">8</span><span class="s1">)</span>

        <span class="s1">engine = self.engine(d=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">scramble=scramble)</span>

        <span class="s1">engine.fast_forward(</span><span class="s3">4</span><span class="s1">)</span>
        <span class="s1">sample = engine.random(n=</span><span class="s3">4</span><span class="s1">)</span>

        <span class="s1">assert_allclose(sample</span><span class="s0">, </span><span class="s1">ref_sample[</span><span class="s3">4</span><span class="s1">:]</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-1</span><span class="s1">)</span>

        <span class="s2"># alternate fast forwarding with sampling</span>
        <span class="s1">engine.reset()</span>
        <span class="s1">even_draws = []</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">8</span><span class="s1">):</span>
            <span class="s0">if </span><span class="s1">i % </span><span class="s3">2 </span><span class="s1">== </span><span class="s3">0</span><span class="s1">:</span>
                <span class="s1">even_draws.append(engine.random())</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">engine.fast_forward(</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">ref_sample[[i </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">8</span><span class="s1">) </span><span class="s0">if </span><span class="s1">i % </span><span class="s3">2 </span><span class="s1">== </span><span class="s3">0</span><span class="s1">]]</span><span class="s0">,</span>
            <span class="s1">np.concatenate(even_draws)</span><span class="s0">,</span>
            <span class="s1">atol=</span><span class="s3">1e-5</span>
        <span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;scramble&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_distribution(self</span><span class="s0">, </span><span class="s1">scramble):</span>
        <span class="s1">d = </span><span class="s3">50</span>
        <span class="s1">engine = self.engine(d=d</span><span class="s0">, </span><span class="s1">scramble=scramble)</span>
        <span class="s1">sample = engine.random(</span><span class="s3">1024</span><span class="s1">)</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">np.mean(sample</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.repeat(</span><span class="s3">0.5</span><span class="s0">, </span><span class="s1">d)</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-2</span>
        <span class="s1">)</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">np.percentile(sample</span><span class="s0">, </span><span class="s3">25</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.repeat(</span><span class="s3">0.25</span><span class="s0">, </span><span class="s1">d)</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-2</span>
        <span class="s1">)</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">np.percentile(sample</span><span class="s0">, </span><span class="s3">75</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.repeat(</span><span class="s3">0.75</span><span class="s0">, </span><span class="s1">d)</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-2</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_raises_optimizer(self):</span>
        <span class="s1">message = </span><span class="s4">r&quot;'toto' is not a valid optimization method&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=message):</span>
            <span class="s1">self.engine(d=</span><span class="s3">1</span><span class="s0">, </span><span class="s1">scramble=</span><span class="s0">False, </span><span class="s1">optimization=</span><span class="s4">&quot;toto&quot;</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s4">&quot;optimization,metric&quot;</span><span class="s0">,</span>
        <span class="s1">[</span>
            <span class="s1">(</span><span class="s4">&quot;random-CD&quot;</span><span class="s0">, </span><span class="s1">qmc.discrepancy)</span><span class="s0">,</span>
            <span class="s1">(</span><span class="s4">&quot;lloyd&quot;</span><span class="s0">, lambda </span><span class="s1">sample: -_l1_norm(sample))]</span>
    <span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_optimizers(self</span><span class="s0">, </span><span class="s1">optimization</span><span class="s0">, </span><span class="s1">metric):</span>
        <span class="s1">engine = self.engine(d=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">scramble=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">sample_ref = engine.random(n=</span><span class="s3">64</span><span class="s1">)</span>
        <span class="s1">metric_ref = metric(sample_ref)</span>

        <span class="s1">optimal_ = self.engine(d=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">scramble=</span><span class="s0">False, </span><span class="s1">optimization=optimization)</span>
        <span class="s1">sample_ = optimal_.random(n=</span><span class="s3">64</span><span class="s1">)</span>
        <span class="s1">metric_ = metric(sample_)</span>

        <span class="s0">assert </span><span class="s1">metric_ &lt; metric_ref</span>

    <span class="s0">def </span><span class="s1">test_consume_prng_state(self):</span>
        <span class="s1">rng = np.random.default_rng(</span><span class="s3">0xa29cabb11cfdf44ff6cac8bec254c2a0</span><span class="s1">)</span>
        <span class="s1">sample = []</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">3</span><span class="s1">):</span>
            <span class="s1">engine = self.engine(d=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">scramble=</span><span class="s0">True, </span><span class="s1">seed=rng)</span>
            <span class="s1">sample.append(engine.random(</span><span class="s3">4</span><span class="s1">))</span>

        <span class="s0">with </span><span class="s1">pytest.raises(AssertionError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;Arrays are not equal&quot;</span><span class="s1">):</span>
            <span class="s1">assert_equal(sample[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">sample[</span><span class="s3">1</span><span class="s1">])</span>
        <span class="s0">with </span><span class="s1">pytest.raises(AssertionError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;Arrays are not equal&quot;</span><span class="s1">):</span>
            <span class="s1">assert_equal(sample[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">sample[</span><span class="s3">2</span><span class="s1">])</span>


<span class="s0">class </span><span class="s1">TestHalton(QMCEngineTests):</span>
    <span class="s1">qmce = qmc.Halton</span>
    <span class="s1">can_scramble = </span><span class="s0">True</span>
    <span class="s2"># theoretical values known from Van der Corput</span>
    <span class="s1">unscramble_nd = np.array([[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1 </span><span class="s1">/ </span><span class="s3">2</span><span class="s0">, </span><span class="s3">1 </span><span class="s1">/ </span><span class="s3">3</span><span class="s1">]</span><span class="s0">,</span>
                              <span class="s1">[</span><span class="s3">1 </span><span class="s1">/ </span><span class="s3">4</span><span class="s0">, </span><span class="s3">2 </span><span class="s1">/ </span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">3 </span><span class="s1">/ </span><span class="s3">4</span><span class="s0">, </span><span class="s3">1 </span><span class="s1">/ </span><span class="s3">9</span><span class="s1">]</span><span class="s0">,</span>
                              <span class="s1">[</span><span class="s3">1 </span><span class="s1">/ </span><span class="s3">8</span><span class="s0">, </span><span class="s3">4 </span><span class="s1">/ </span><span class="s3">9</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">5 </span><span class="s1">/ </span><span class="s3">8</span><span class="s0">, </span><span class="s3">7 </span><span class="s1">/ </span><span class="s3">9</span><span class="s1">]</span><span class="s0">,</span>
                              <span class="s1">[</span><span class="s3">3 </span><span class="s1">/ </span><span class="s3">8</span><span class="s0">, </span><span class="s3">2 </span><span class="s1">/ </span><span class="s3">9</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">7 </span><span class="s1">/ </span><span class="s3">8</span><span class="s0">, </span><span class="s3">5 </span><span class="s1">/ </span><span class="s3">9</span><span class="s1">]])</span>
    <span class="s2"># theoretical values unknown: convergence properties checked</span>
    <span class="s1">scramble_nd = np.array([[</span><span class="s3">0.50246036</span><span class="s0">, </span><span class="s3">0.93382481</span><span class="s1">]</span><span class="s0">,</span>
                            <span class="s1">[</span><span class="s3">0.00246036</span><span class="s0">, </span><span class="s3">0.26715815</span><span class="s1">]</span><span class="s0">,</span>
                            <span class="s1">[</span><span class="s3">0.75246036</span><span class="s0">, </span><span class="s3">0.60049148</span><span class="s1">]</span><span class="s0">,</span>
                            <span class="s1">[</span><span class="s3">0.25246036</span><span class="s0">, </span><span class="s3">0.8227137 </span><span class="s1">]</span><span class="s0">,</span>
                            <span class="s1">[</span><span class="s3">0.62746036</span><span class="s0">, </span><span class="s3">0.15604704</span><span class="s1">]</span><span class="s0">,</span>
                            <span class="s1">[</span><span class="s3">0.12746036</span><span class="s0">, </span><span class="s3">0.48938037</span><span class="s1">]</span><span class="s0">,</span>
                            <span class="s1">[</span><span class="s3">0.87746036</span><span class="s0">, </span><span class="s3">0.71160259</span><span class="s1">]</span><span class="s0">,</span>
                            <span class="s1">[</span><span class="s3">0.37746036</span><span class="s0">, </span><span class="s3">0.04493592</span><span class="s1">]])</span>

    <span class="s0">def </span><span class="s1">test_workers(self):</span>
        <span class="s1">ref_sample = self.reference(scramble=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">engine = self.engine(d=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">scramble=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">sample = engine.random(n=len(ref_sample)</span><span class="s0">, </span><span class="s1">workers=</span><span class="s3">8</span><span class="s1">)</span>

        <span class="s1">assert_allclose(sample</span><span class="s0">, </span><span class="s1">ref_sample</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-3</span><span class="s1">)</span>

        <span class="s2"># worker + integers</span>
        <span class="s1">engine.reset()</span>
        <span class="s1">ref_sample = engine.integers(</span><span class="s3">10</span><span class="s1">)</span>
        <span class="s1">engine.reset()</span>
        <span class="s1">sample = engine.integers(</span><span class="s3">10</span><span class="s0">, </span><span class="s1">workers=</span><span class="s3">8</span><span class="s1">)</span>
        <span class="s1">assert_equal(sample</span><span class="s0">, </span><span class="s1">ref_sample)</span>


<span class="s0">class </span><span class="s1">TestLHS(QMCEngineTests):</span>
    <span class="s1">qmce = qmc.LatinHypercube</span>
    <span class="s1">can_scramble = </span><span class="s0">True</span>

    <span class="s0">def </span><span class="s1">test_continuing(self</span><span class="s0">, </span><span class="s1">*args):</span>
        <span class="s1">pytest.skip(</span><span class="s4">&quot;Not applicable: not a sequence.&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_fast_forward(self</span><span class="s0">, </span><span class="s1">*args):</span>
        <span class="s1">pytest.skip(</span><span class="s4">&quot;Not applicable: not a sequence.&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_sample(self</span><span class="s0">, </span><span class="s1">*args):</span>
        <span class="s1">pytest.skip(</span><span class="s4">&quot;Not applicable: the value of reference sample is&quot;</span>
                    <span class="s4">&quot; implementation dependent.&quot;</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;strength&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;scramble&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">False, True</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;optimization&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">None, </span><span class="s4">&quot;random-CD&quot;</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_sample_stratified(self</span><span class="s0">, </span><span class="s1">optimization</span><span class="s0">, </span><span class="s1">scramble</span><span class="s0">, </span><span class="s1">strength):</span>
        <span class="s1">seed = np.random.default_rng(</span><span class="s3">37511836202578819870665127532742111260</span><span class="s1">)</span>
        <span class="s1">p = </span><span class="s3">5</span>
        <span class="s1">n = p**</span><span class="s3">2</span>
        <span class="s1">d = </span><span class="s3">6</span>

        <span class="s1">engine = qmc.LatinHypercube(d=d</span><span class="s0">, </span><span class="s1">scramble=scramble</span><span class="s0">,</span>
                                    <span class="s1">strength=strength</span><span class="s0">,</span>
                                    <span class="s1">optimization=optimization</span><span class="s0">,</span>
                                    <span class="s1">seed=seed)</span>
        <span class="s1">sample = engine.random(n=n)</span>
        <span class="s0">assert </span><span class="s1">sample.shape == (n</span><span class="s0">, </span><span class="s1">d)</span>
        <span class="s0">assert </span><span class="s1">engine.num_generated == n</span>

        <span class="s2"># centering stratifies samples in the middle of equal segments:</span>
        <span class="s2"># * inter-sample distance is constant in 1D sub-projections</span>
        <span class="s2"># * after ordering, columns are equal</span>
        <span class="s1">expected1d = (np.arange(n) + </span><span class="s3">0.5</span><span class="s1">) / n</span>
        <span class="s1">expected = np.broadcast_to(expected1d</span><span class="s0">, </span><span class="s1">(d</span><span class="s0">, </span><span class="s1">n)).T</span>
        <span class="s0">assert </span><span class="s1">np.any(sample != expected)</span>

        <span class="s1">sorted_sample = np.sort(sample</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">tol = </span><span class="s3">0.5 </span><span class="s1">/ n </span><span class="s0">if </span><span class="s1">scramble </span><span class="s0">else </span><span class="s3">0</span>

        <span class="s1">assert_allclose(sorted_sample</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">atol=tol)</span>
        <span class="s0">assert </span><span class="s1">np.any(sample - expected &gt; tol)</span>

        <span class="s0">if </span><span class="s1">strength == </span><span class="s3">2 </span><span class="s0">and </span><span class="s1">optimization </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">unique_elements = np.arange(p)</span>
            <span class="s1">desired = set(product(unique_elements</span><span class="s0">, </span><span class="s1">unique_elements))</span>

            <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">j </span><span class="s0">in </span><span class="s1">combinations(range(engine.d)</span><span class="s0">, </span><span class="s3">2</span><span class="s1">):</span>
                <span class="s1">samples_2d = sample[:</span><span class="s0">, </span><span class="s1">[i</span><span class="s0">, </span><span class="s1">j]]</span>
                <span class="s1">res = (samples_2d * p).astype(int)</span>
                <span class="s1">res_set = {tuple(row) </span><span class="s0">for </span><span class="s1">row </span><span class="s0">in </span><span class="s1">res}</span>
                <span class="s1">assert_equal(res_set</span><span class="s0">, </span><span class="s1">desired)</span>

    <span class="s0">def </span><span class="s1">test_optimizer_1d(self):</span>
        <span class="s2"># discrepancy measures are invariant under permuting factors and runs</span>
        <span class="s1">engine = self.engine(d=</span><span class="s3">1</span><span class="s0">, </span><span class="s1">scramble=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">sample_ref = engine.random(n=</span><span class="s3">64</span><span class="s1">)</span>

        <span class="s1">optimal_ = self.engine(d=</span><span class="s3">1</span><span class="s0">, </span><span class="s1">scramble=</span><span class="s0">False, </span><span class="s1">optimization=</span><span class="s4">&quot;random-CD&quot;</span><span class="s1">)</span>
        <span class="s1">sample_ = optimal_.random(n=</span><span class="s3">64</span><span class="s1">)</span>

        <span class="s1">assert_array_equal(sample_ref</span><span class="s0">, </span><span class="s1">sample_)</span>

    <span class="s0">def </span><span class="s1">test_raises(self):</span>
        <span class="s1">message = </span><span class="s4">r&quot;not a valid strength&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=message):</span>
            <span class="s1">qmc.LatinHypercube(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">strength=</span><span class="s3">3</span><span class="s1">)</span>

        <span class="s1">message = </span><span class="s4">r&quot;n is not the square of a prime number&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=message):</span>
            <span class="s1">engine = qmc.LatinHypercube(d=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">strength=</span><span class="s3">2</span><span class="s1">)</span>
            <span class="s1">engine.random(</span><span class="s3">16</span><span class="s1">)</span>

        <span class="s1">message = </span><span class="s4">r&quot;n is not the square of a prime number&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=message):</span>
            <span class="s1">engine = qmc.LatinHypercube(d=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">strength=</span><span class="s3">2</span><span class="s1">)</span>
            <span class="s1">engine.random(</span><span class="s3">5</span><span class="s1">)  </span><span class="s2"># because int(sqrt(5)) would result in 2</span>

        <span class="s1">message = </span><span class="s4">r&quot;n is too small for d&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=message):</span>
            <span class="s1">engine = qmc.LatinHypercube(d=</span><span class="s3">5</span><span class="s0">, </span><span class="s1">strength=</span><span class="s3">2</span><span class="s1">)</span>
            <span class="s1">engine.random(</span><span class="s3">9</span><span class="s1">)</span>

        <span class="s1">message = </span><span class="s4">r&quot;'centered' is deprecated&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.warns(UserWarning</span><span class="s0">, </span><span class="s1">match=message):</span>
            <span class="s1">qmc.LatinHypercube(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">centered=</span><span class="s0">True</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestSobol(QMCEngineTests):</span>
    <span class="s1">qmce = qmc.Sobol</span>
    <span class="s1">can_scramble = </span><span class="s0">True</span>
    <span class="s2"># theoretical values from Joe Kuo2010</span>
    <span class="s1">unscramble_nd = np.array([[</span><span class="s3">0.</span><span class="s0">, </span><span class="s3">0.</span><span class="s1">]</span><span class="s0">,</span>
                              <span class="s1">[</span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">0.5</span><span class="s1">]</span><span class="s0">,</span>
                              <span class="s1">[</span><span class="s3">0.75</span><span class="s0">, </span><span class="s3">0.25</span><span class="s1">]</span><span class="s0">,</span>
                              <span class="s1">[</span><span class="s3">0.25</span><span class="s0">, </span><span class="s3">0.75</span><span class="s1">]</span><span class="s0">,</span>
                              <span class="s1">[</span><span class="s3">0.375</span><span class="s0">, </span><span class="s3">0.375</span><span class="s1">]</span><span class="s0">,</span>
                              <span class="s1">[</span><span class="s3">0.875</span><span class="s0">, </span><span class="s3">0.875</span><span class="s1">]</span><span class="s0">,</span>
                              <span class="s1">[</span><span class="s3">0.625</span><span class="s0">, </span><span class="s3">0.125</span><span class="s1">]</span><span class="s0">,</span>
                              <span class="s1">[</span><span class="s3">0.125</span><span class="s0">, </span><span class="s3">0.625</span><span class="s1">]])</span>

    <span class="s2"># theoretical values unknown: convergence properties checked</span>
    <span class="s1">scramble_nd = np.array([[</span><span class="s3">0.25331921</span><span class="s0">, </span><span class="s3">0.41371179</span><span class="s1">]</span><span class="s0">,</span>
                            <span class="s1">[</span><span class="s3">0.8654213</span><span class="s0">, </span><span class="s3">0.9821167</span><span class="s1">]</span><span class="s0">,</span>
                            <span class="s1">[</span><span class="s3">0.70097554</span><span class="s0">, </span><span class="s3">0.03664616</span><span class="s1">]</span><span class="s0">,</span>
                            <span class="s1">[</span><span class="s3">0.18027647</span><span class="s0">, </span><span class="s3">0.60895735</span><span class="s1">]</span><span class="s0">,</span>
                            <span class="s1">[</span><span class="s3">0.10521339</span><span class="s0">, </span><span class="s3">0.21897069</span><span class="s1">]</span><span class="s0">,</span>
                            <span class="s1">[</span><span class="s3">0.53019685</span><span class="s0">, </span><span class="s3">0.66619033</span><span class="s1">]</span><span class="s0">,</span>
                            <span class="s1">[</span><span class="s3">0.91122276</span><span class="s0">, </span><span class="s3">0.34580743</span><span class="s1">]</span><span class="s0">,</span>
                            <span class="s1">[</span><span class="s3">0.45337471</span><span class="s0">, </span><span class="s3">0.78912079</span><span class="s1">]])</span>

    <span class="s0">def </span><span class="s1">test_warning(self):</span>
        <span class="s0">with </span><span class="s1">pytest.warns(UserWarning</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">r&quot;The balance properties of &quot;</span>
                                             <span class="s4">r&quot;Sobol' points&quot;</span><span class="s1">):</span>
            <span class="s1">engine = qmc.Sobol(</span><span class="s3">1</span><span class="s1">)</span>
            <span class="s1">engine.random(</span><span class="s3">10</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_random_base2(self):</span>
        <span class="s1">engine = qmc.Sobol(</span><span class="s3">2</span><span class="s0">, </span><span class="s1">scramble=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">sample = engine.random_base2(</span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(self.unscramble_nd[:</span><span class="s3">4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">sample)</span>

        <span class="s2"># resampling still having N=2**n</span>
        <span class="s1">sample = engine.random_base2(</span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(self.unscramble_nd[</span><span class="s3">4</span><span class="s1">:</span><span class="s3">8</span><span class="s1">]</span><span class="s0">, </span><span class="s1">sample)</span>

        <span class="s2"># resampling again but leading to N!=2**n</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">r&quot;The balance properties of &quot;</span>
                                             <span class="s4">r&quot;Sobol' points&quot;</span><span class="s1">):</span>
            <span class="s1">engine.random_base2(</span><span class="s3">2</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_raise(self):</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">r&quot;Maximum supported &quot;</span>
                                             <span class="s4">r&quot;dimensionality&quot;</span><span class="s1">):</span>
            <span class="s1">qmc.Sobol(qmc.Sobol.MAXDIM + </span><span class="s3">1</span><span class="s1">)</span>

        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">r&quot;Maximum supported &quot;</span>
                                             <span class="s4">r&quot;'bits' is 64&quot;</span><span class="s1">):</span>
            <span class="s1">qmc.Sobol(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">bits=</span><span class="s3">65</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_high_dim(self):</span>
        <span class="s1">engine = qmc.Sobol(</span><span class="s3">1111</span><span class="s0">, </span><span class="s1">scramble=</span><span class="s0">False</span><span class="s1">)</span>
        <span class="s1">count1 = Counter(engine.random().flatten().tolist())</span>
        <span class="s1">count2 = Counter(engine.random().flatten().tolist())</span>
        <span class="s1">assert_equal(count1</span><span class="s0">, </span><span class="s1">Counter({</span><span class="s3">0.0</span><span class="s1">: </span><span class="s3">1111</span><span class="s1">}))</span>
        <span class="s1">assert_equal(count2</span><span class="s0">, </span><span class="s1">Counter({</span><span class="s3">0.5</span><span class="s1">: </span><span class="s3">1111</span><span class="s1">}))</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;bits&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s3">2</span><span class="s0">, </span><span class="s3">3</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_bits(self</span><span class="s0">, </span><span class="s1">bits):</span>
        <span class="s1">engine = qmc.Sobol(</span><span class="s3">2</span><span class="s0">, </span><span class="s1">scramble=</span><span class="s0">False, </span><span class="s1">bits=bits)</span>
        <span class="s1">ns = </span><span class="s3">2</span><span class="s1">**bits</span>
        <span class="s1">sample = engine.random(ns)</span>
        <span class="s1">assert_array_equal(self.unscramble_nd[:ns]</span><span class="s0">, </span><span class="s1">sample)</span>

        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;increasing `bits`&quot;</span><span class="s1">):</span>
            <span class="s1">engine.random()</span>

    <span class="s0">def </span><span class="s1">test_64bits(self):</span>
        <span class="s1">engine = qmc.Sobol(</span><span class="s3">2</span><span class="s0">, </span><span class="s1">scramble=</span><span class="s0">False, </span><span class="s1">bits=</span><span class="s3">64</span><span class="s1">)</span>
        <span class="s1">sample = engine.random(</span><span class="s3">8</span><span class="s1">)</span>
        <span class="s1">assert_array_equal(self.unscramble_nd</span><span class="s0">, </span><span class="s1">sample)</span>


<span class="s0">class </span><span class="s1">TestPoisson(QMCEngineTests):</span>
    <span class="s1">qmce = qmc.PoissonDisk</span>
    <span class="s1">can_scramble = </span><span class="s0">False</span>

    <span class="s0">def </span><span class="s1">test_bounds(self</span><span class="s0">, </span><span class="s1">*args):</span>
        <span class="s1">pytest.skip(</span><span class="s4">&quot;Too costly in memory.&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_fast_forward(self</span><span class="s0">, </span><span class="s1">*args):</span>
        <span class="s1">pytest.skip(</span><span class="s4">&quot;Not applicable: recursive process.&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_sample(self</span><span class="s0">, </span><span class="s1">*args):</span>
        <span class="s1">pytest.skip(</span><span class="s4">&quot;Not applicable: the value of reference sample is&quot;</span>
                    <span class="s4">&quot; implementation dependent.&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_continuing(self</span><span class="s0">, </span><span class="s1">*args):</span>
        <span class="s2"># can continue a sampling, but will not preserve the same order</span>
        <span class="s2"># because candidates are lost, so we will not select the same center</span>
        <span class="s1">radius = </span><span class="s3">0.05</span>
        <span class="s1">ns = </span><span class="s3">6</span>
        <span class="s1">engine = self.engine(d=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">radius=radius</span><span class="s0">, </span><span class="s1">scramble=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s1">sample_init = engine.random(n=ns)</span>
        <span class="s0">assert </span><span class="s1">len(sample_init) &lt;= ns</span>
        <span class="s0">assert </span><span class="s1">l2_norm(sample_init) &gt;= radius</span>

        <span class="s1">sample_continued = engine.random(n=ns)</span>
        <span class="s0">assert </span><span class="s1">len(sample_continued) &lt;= ns</span>
        <span class="s0">assert </span><span class="s1">l2_norm(sample_continued) &gt;= radius</span>

        <span class="s1">sample = np.concatenate([sample_init</span><span class="s0">, </span><span class="s1">sample_continued]</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">len(sample) &lt;= ns * </span><span class="s3">2</span>
        <span class="s0">assert </span><span class="s1">l2_norm(sample) &gt;= radius</span>

    <span class="s0">def </span><span class="s1">test_mindist(self):</span>
        <span class="s1">rng = np.random.default_rng(</span><span class="s3">132074951149370773672162394161442690287</span><span class="s1">)</span>
        <span class="s1">ns = </span><span class="s3">50</span>

        <span class="s1">low</span><span class="s0">, </span><span class="s1">high = </span><span class="s3">0.08</span><span class="s0">, </span><span class="s3">0.2</span>
        <span class="s1">radii = (high - low) * rng.random(</span><span class="s3">5</span><span class="s1">) + low</span>

        <span class="s1">dimensions = [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s0">, </span><span class="s3">4</span><span class="s1">]</span>
        <span class="s1">hypersphere_methods = [</span><span class="s4">&quot;volume&quot;</span><span class="s0">, </span><span class="s4">&quot;surface&quot;</span><span class="s1">]</span>

        <span class="s1">gen = product(dimensions</span><span class="s0">, </span><span class="s1">radii</span><span class="s0">, </span><span class="s1">hypersphere_methods)</span>

        <span class="s0">for </span><span class="s1">d</span><span class="s0">, </span><span class="s1">radius</span><span class="s0">, </span><span class="s1">hypersphere </span><span class="s0">in </span><span class="s1">gen:</span>
            <span class="s1">engine = self.qmce(</span>
                <span class="s1">d=d</span><span class="s0">, </span><span class="s1">radius=radius</span><span class="s0">, </span><span class="s1">hypersphere=hypersphere</span><span class="s0">, </span><span class="s1">seed=rng</span>
            <span class="s1">)</span>
            <span class="s1">sample = engine.random(ns)</span>

            <span class="s0">assert </span><span class="s1">len(sample) &lt;= ns</span>
            <span class="s0">assert </span><span class="s1">l2_norm(sample) &gt;= radius</span>

    <span class="s0">def </span><span class="s1">test_fill_space(self):</span>
        <span class="s1">radius = </span><span class="s3">0.2</span>
        <span class="s1">engine = self.qmce(d=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">radius=radius)</span>

        <span class="s1">sample = engine.fill_space()</span>
        <span class="s2"># circle packing problem is np complex</span>
        <span class="s0">assert </span><span class="s1">l2_norm(sample) &gt;= radius</span>

    <span class="s0">def </span><span class="s1">test_raises(self):</span>
        <span class="s1">message = </span><span class="s4">r&quot;'toto' is not a valid hypersphere sampling&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=message):</span>
            <span class="s1">qmc.PoissonDisk(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">hypersphere=</span><span class="s4">&quot;toto&quot;</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestMultinomialQMC:</span>
    <span class="s0">def </span><span class="s1">test_validations(self):</span>
        <span class="s2"># negative Ps</span>
        <span class="s1">p = np.array([</span><span class="s3">0.12</span><span class="s0">, </span><span class="s3">0.26</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.05</span><span class="s0">, </span><span class="s3">0.35</span><span class="s0">, </span><span class="s3">0.22</span><span class="s1">])</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">r&quot;Elements of pvals must &quot;</span>
                                             <span class="s4">r&quot;be non-negative.&quot;</span><span class="s1">):</span>
            <span class="s1">qmc.MultinomialQMC(p</span><span class="s0">, </span><span class="s1">n_trials=</span><span class="s3">10</span><span class="s1">)</span>

        <span class="s2"># sum of P too large</span>
        <span class="s1">p = np.array([</span><span class="s3">0.12</span><span class="s0">, </span><span class="s3">0.26</span><span class="s0">, </span><span class="s3">0.1</span><span class="s0">, </span><span class="s3">0.35</span><span class="s0">, </span><span class="s3">0.22</span><span class="s1">])</span>
        <span class="s1">message = </span><span class="s4">r&quot;Elements of pvals must sum to 1.&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=message):</span>
            <span class="s1">qmc.MultinomialQMC(p</span><span class="s0">, </span><span class="s1">n_trials=</span><span class="s3">10</span><span class="s1">)</span>

        <span class="s1">p = np.array([</span><span class="s3">0.12</span><span class="s0">, </span><span class="s3">0.26</span><span class="s0">, </span><span class="s3">0.05</span><span class="s0">, </span><span class="s3">0.35</span><span class="s0">, </span><span class="s3">0.22</span><span class="s1">])</span>

        <span class="s1">message = </span><span class="s4">r&quot;Dimension of `engine` must be 1.&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=message):</span>
            <span class="s1">qmc.MultinomialQMC(p</span><span class="s0">, </span><span class="s1">n_trials=</span><span class="s3">10</span><span class="s0">, </span><span class="s1">engine=qmc.Sobol(d=</span><span class="s3">2</span><span class="s1">))</span>

        <span class="s1">message = </span><span class="s4">r&quot;`engine` must be an instance of...&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=message):</span>
            <span class="s1">qmc.MultinomialQMC(p</span><span class="s0">, </span><span class="s1">n_trials=</span><span class="s3">10</span><span class="s0">, </span><span class="s1">engine=np.random.default_rng())</span>

    <span class="s1">@pytest.mark.filterwarnings(</span><span class="s4">'ignore::UserWarning'</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_MultinomialBasicDraw(self):</span>
        <span class="s1">seed = np.random.default_rng(</span><span class="s3">6955663962957011631562466584467607969</span><span class="s1">)</span>
        <span class="s1">p = np.array([</span><span class="s3">0.12</span><span class="s0">, </span><span class="s3">0.26</span><span class="s0">, </span><span class="s3">0.05</span><span class="s0">, </span><span class="s3">0.35</span><span class="s0">, </span><span class="s3">0.22</span><span class="s1">])</span>
        <span class="s1">n_trials = </span><span class="s3">100</span>
        <span class="s1">expected = np.atleast_2d(n_trials * p).astype(int)</span>
        <span class="s1">engine = qmc.MultinomialQMC(p</span><span class="s0">, </span><span class="s1">n_trials=n_trials</span><span class="s0">, </span><span class="s1">seed=seed)</span>
        <span class="s1">assert_allclose(engine.random(</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_MultinomialDistribution(self):</span>
        <span class="s1">seed = np.random.default_rng(</span><span class="s3">77797854505813727292048130876699859000</span><span class="s1">)</span>
        <span class="s1">p = np.array([</span><span class="s3">0.12</span><span class="s0">, </span><span class="s3">0.26</span><span class="s0">, </span><span class="s3">0.05</span><span class="s0">, </span><span class="s3">0.35</span><span class="s0">, </span><span class="s3">0.22</span><span class="s1">])</span>
        <span class="s1">engine = qmc.MultinomialQMC(p</span><span class="s0">, </span><span class="s1">n_trials=</span><span class="s3">8192</span><span class="s0">, </span><span class="s1">seed=seed)</span>
        <span class="s1">draws = engine.random(</span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">assert_allclose(draws / np.sum(draws)</span><span class="s0">, </span><span class="s1">np.atleast_2d(p)</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-4</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_FindIndex(self):</span>
        <span class="s1">p_cumulative = np.array([</span><span class="s3">0.1</span><span class="s0">, </span><span class="s3">0.4</span><span class="s0">, </span><span class="s3">0.45</span><span class="s0">, </span><span class="s3">0.6</span><span class="s0">, </span><span class="s3">0.75</span><span class="s0">, </span><span class="s3">0.9</span><span class="s0">, </span><span class="s3">0.99</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">])</span>
        <span class="s1">size = len(p_cumulative)</span>
        <span class="s1">assert_equal(_test_find_index(p_cumulative</span><span class="s0">, </span><span class="s1">size</span><span class="s0">, </span><span class="s3">0.0</span><span class="s1">)</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s1">assert_equal(_test_find_index(p_cumulative</span><span class="s0">, </span><span class="s1">size</span><span class="s0">, </span><span class="s3">0.4</span><span class="s1">)</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">assert_equal(_test_find_index(p_cumulative</span><span class="s0">, </span><span class="s1">size</span><span class="s0">, </span><span class="s3">0.44999</span><span class="s1">)</span><span class="s0">, </span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">assert_equal(_test_find_index(p_cumulative</span><span class="s0">, </span><span class="s1">size</span><span class="s0">, </span><span class="s3">0.45001</span><span class="s1">)</span><span class="s0">, </span><span class="s3">3</span><span class="s1">)</span>
        <span class="s1">assert_equal(_test_find_index(p_cumulative</span><span class="s0">, </span><span class="s1">size</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">size - </span><span class="s3">1</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.filterwarnings(</span><span class="s4">'ignore::UserWarning'</span><span class="s1">)</span>
    <span class="s0">def </span><span class="s1">test_other_engine(self):</span>
        <span class="s2"># same as test_MultinomialBasicDraw with different engine</span>
        <span class="s1">seed = np.random.default_rng(</span><span class="s3">283753519042773243071753037669078065412</span><span class="s1">)</span>
        <span class="s1">p = np.array([</span><span class="s3">0.12</span><span class="s0">, </span><span class="s3">0.26</span><span class="s0">, </span><span class="s3">0.05</span><span class="s0">, </span><span class="s3">0.35</span><span class="s0">, </span><span class="s3">0.22</span><span class="s1">])</span>
        <span class="s1">n_trials = </span><span class="s3">100</span>
        <span class="s1">expected = np.atleast_2d(n_trials * p).astype(int)</span>
        <span class="s1">base_engine = qmc.Sobol(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">scramble=</span><span class="s0">True, </span><span class="s1">seed=seed)</span>
        <span class="s1">engine = qmc.MultinomialQMC(p</span><span class="s0">, </span><span class="s1">n_trials=n_trials</span><span class="s0">, </span><span class="s1">engine=base_engine</span><span class="s0">,</span>
                                    <span class="s1">seed=seed)</span>
        <span class="s1">assert_allclose(engine.random(</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestNormalQMC:</span>
    <span class="s0">def </span><span class="s1">test_NormalQMC(self):</span>
        <span class="s2"># d = 1</span>
        <span class="s1">engine = qmc.MultivariateNormalQMC(mean=np.zeros(</span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">samples = engine.random()</span>
        <span class="s1">assert_equal(samples.shape</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">samples = engine.random(n=</span><span class="s3">5</span><span class="s1">)</span>
        <span class="s1">assert_equal(samples.shape</span><span class="s0">, </span><span class="s1">(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span>
        <span class="s2"># d = 2</span>
        <span class="s1">engine = qmc.MultivariateNormalQMC(mean=np.zeros(</span><span class="s3">2</span><span class="s1">))</span>
        <span class="s1">samples = engine.random()</span>
        <span class="s1">assert_equal(samples.shape</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
        <span class="s1">samples = engine.random(n=</span><span class="s3">5</span><span class="s1">)</span>
        <span class="s1">assert_equal(samples.shape</span><span class="s0">, </span><span class="s1">(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_NormalQMCInvTransform(self):</span>
        <span class="s2"># d = 1</span>
        <span class="s1">engine = qmc.MultivariateNormalQMC(</span>
            <span class="s1">mean=np.zeros(</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">inv_transform=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">samples = engine.random()</span>
        <span class="s1">assert_equal(samples.shape</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">samples = engine.random(n=</span><span class="s3">5</span><span class="s1">)</span>
        <span class="s1">assert_equal(samples.shape</span><span class="s0">, </span><span class="s1">(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span>
        <span class="s2"># d = 2</span>
        <span class="s1">engine = qmc.MultivariateNormalQMC(</span>
            <span class="s1">mean=np.zeros(</span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">inv_transform=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">samples = engine.random()</span>
        <span class="s1">assert_equal(samples.shape</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
        <span class="s1">samples = engine.random(n=</span><span class="s3">5</span><span class="s1">)</span>
        <span class="s1">assert_equal(samples.shape</span><span class="s0">, </span><span class="s1">(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_NormalQMCSeeded(self):</span>
        <span class="s2"># test even dimension</span>
        <span class="s1">seed = np.random.default_rng(</span><span class="s3">274600237797326520096085022671371676017</span><span class="s1">)</span>
        <span class="s1">engine = qmc.MultivariateNormalQMC(</span>
            <span class="s1">mean=np.zeros(</span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">inv_transform=</span><span class="s0">False, </span><span class="s1">seed=seed)</span>
        <span class="s1">samples = engine.random(n=</span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">samples_expected = np.array([[-</span><span class="s3">0.932001</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.522923</span><span class="s1">]</span><span class="s0">,</span>
                                     <span class="s1">[-</span><span class="s3">1.477655</span><span class="s0">, </span><span class="s3">0.846851</span><span class="s1">]])</span>
        <span class="s1">assert_allclose(samples</span><span class="s0">, </span><span class="s1">samples_expected</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-4</span><span class="s1">)</span>

        <span class="s2"># test odd dimension</span>
        <span class="s1">seed = np.random.default_rng(</span><span class="s3">274600237797326520096085022671371676017</span><span class="s1">)</span>
        <span class="s1">engine = qmc.MultivariateNormalQMC(</span>
            <span class="s1">mean=np.zeros(</span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">inv_transform=</span><span class="s0">False, </span><span class="s1">seed=seed)</span>
        <span class="s1">samples = engine.random(n=</span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">samples_expected = np.array([[-</span><span class="s3">0.932001</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.522923</span><span class="s0">, </span><span class="s3">0.036578</span><span class="s1">]</span><span class="s0">,</span>
                                     <span class="s1">[-</span><span class="s3">1.778011</span><span class="s0">, </span><span class="s3">0.912428</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.065421</span><span class="s1">]])</span>
        <span class="s1">assert_allclose(samples</span><span class="s0">, </span><span class="s1">samples_expected</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-4</span><span class="s1">)</span>

        <span class="s2"># same test with another engine</span>
        <span class="s1">seed = np.random.default_rng(</span><span class="s3">274600237797326520096085022671371676017</span><span class="s1">)</span>
        <span class="s1">base_engine = qmc.Sobol(</span><span class="s3">4</span><span class="s0">, </span><span class="s1">scramble=</span><span class="s0">True, </span><span class="s1">seed=seed)</span>
        <span class="s1">engine = qmc.MultivariateNormalQMC(</span>
            <span class="s1">mean=np.zeros(</span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">inv_transform=</span><span class="s0">False,</span>
            <span class="s1">engine=base_engine</span><span class="s0">, </span><span class="s1">seed=seed</span>
        <span class="s1">)</span>
        <span class="s1">samples = engine.random(n=</span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">samples_expected = np.array([[-</span><span class="s3">0.932001</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.522923</span><span class="s0">, </span><span class="s3">0.036578</span><span class="s1">]</span><span class="s0">,</span>
                                     <span class="s1">[-</span><span class="s3">1.778011</span><span class="s0">, </span><span class="s3">0.912428</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.065421</span><span class="s1">]])</span>
        <span class="s1">assert_allclose(samples</span><span class="s0">, </span><span class="s1">samples_expected</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-4</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_NormalQMCSeededInvTransform(self):</span>
        <span class="s2"># test even dimension</span>
        <span class="s1">seed = np.random.default_rng(</span><span class="s3">288527772707286126646493545351112463929</span><span class="s1">)</span>
        <span class="s1">engine = qmc.MultivariateNormalQMC(</span>
            <span class="s1">mean=np.zeros(</span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">seed=seed</span><span class="s0">, </span><span class="s1">inv_transform=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">samples = engine.random(n=</span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">samples_expected = np.array([[-</span><span class="s3">0.913237</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.964026</span><span class="s1">]</span><span class="s0">,</span>
                                     <span class="s1">[</span><span class="s3">0.255904</span><span class="s0">, </span><span class="s3">0.003068</span><span class="s1">]])</span>
        <span class="s1">assert_allclose(samples</span><span class="s0">, </span><span class="s1">samples_expected</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-4</span><span class="s1">)</span>

        <span class="s2"># test odd dimension</span>
        <span class="s1">seed = np.random.default_rng(</span><span class="s3">288527772707286126646493545351112463929</span><span class="s1">)</span>
        <span class="s1">engine = qmc.MultivariateNormalQMC(</span>
            <span class="s1">mean=np.zeros(</span><span class="s3">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">seed=seed</span><span class="s0">, </span><span class="s1">inv_transform=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">samples = engine.random(n=</span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">samples_expected = np.array([[-</span><span class="s3">0.913237</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.964026</span><span class="s0">, </span><span class="s3">0.355501</span><span class="s1">]</span><span class="s0">,</span>
                                     <span class="s1">[</span><span class="s3">0.699261</span><span class="s0">, </span><span class="s3">2.90213 </span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.6418</span><span class="s1">]])</span>
        <span class="s1">assert_allclose(samples</span><span class="s0">, </span><span class="s1">samples_expected</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-4</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_other_engine(self):</span>
        <span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">):</span>
            <span class="s1">base_engine = qmc.Sobol(d=d</span><span class="s0">, </span><span class="s1">scramble=</span><span class="s0">False</span><span class="s1">)</span>
            <span class="s1">engine = qmc.MultivariateNormalQMC(mean=np.zeros(d)</span><span class="s0">,</span>
                                               <span class="s1">engine=base_engine</span><span class="s0">,</span>
                                               <span class="s1">inv_transform=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s1">samples = engine.random()</span>
            <span class="s1">assert_equal(samples.shape</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">d))</span>

    <span class="s0">def </span><span class="s1">test_NormalQMCShapiro(self):</span>
        <span class="s1">rng = np.random.default_rng(</span><span class="s3">13242</span><span class="s1">)</span>
        <span class="s1">engine = qmc.MultivariateNormalQMC(mean=np.zeros(</span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">seed=rng)</span>
        <span class="s1">samples = engine.random(n=</span><span class="s3">256</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">all(np.abs(samples.mean(axis=</span><span class="s3">0</span><span class="s1">)) &lt; </span><span class="s3">1e-2</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">all(np.abs(samples.std(axis=</span><span class="s3">0</span><span class="s1">) - </span><span class="s3">1</span><span class="s1">) &lt; </span><span class="s3">1e-2</span><span class="s1">)</span>
        <span class="s2"># perform Shapiro-Wilk test for normality</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">):</span>
            <span class="s1">_</span><span class="s0">, </span><span class="s1">pval = shapiro(samples[:</span><span class="s0">, </span><span class="s1">i])</span>
            <span class="s0">assert </span><span class="s1">pval &gt; </span><span class="s3">0.9</span>
        <span class="s2"># make sure samples are uncorrelated</span>
        <span class="s1">cov = np.cov(samples.transpose())</span>
        <span class="s0">assert </span><span class="s1">np.abs(cov[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]) &lt; </span><span class="s3">1e-2</span>

    <span class="s0">def </span><span class="s1">test_NormalQMCShapiroInvTransform(self):</span>
        <span class="s1">rng = np.random.default_rng(</span><span class="s3">32344554</span><span class="s1">)</span>
        <span class="s1">engine = qmc.MultivariateNormalQMC(</span>
            <span class="s1">mean=np.zeros(</span><span class="s3">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">inv_transform=</span><span class="s0">True, </span><span class="s1">seed=rng)</span>
        <span class="s1">samples = engine.random(n=</span><span class="s3">256</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">all(np.abs(samples.mean(axis=</span><span class="s3">0</span><span class="s1">)) &lt; </span><span class="s3">1e-2</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">all(np.abs(samples.std(axis=</span><span class="s3">0</span><span class="s1">) - </span><span class="s3">1</span><span class="s1">) &lt; </span><span class="s3">1e-2</span><span class="s1">)</span>
        <span class="s2"># perform Shapiro-Wilk test for normality</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">):</span>
            <span class="s1">_</span><span class="s0">, </span><span class="s1">pval = shapiro(samples[:</span><span class="s0">, </span><span class="s1">i])</span>
            <span class="s0">assert </span><span class="s1">pval &gt; </span><span class="s3">0.9</span>
        <span class="s2"># make sure samples are uncorrelated</span>
        <span class="s1">cov = np.cov(samples.transpose())</span>
        <span class="s0">assert </span><span class="s1">np.abs(cov[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]) &lt; </span><span class="s3">1e-2</span>


<span class="s0">class </span><span class="s1">TestMultivariateNormalQMC:</span>

    <span class="s0">def </span><span class="s1">test_validations(self):</span>

        <span class="s1">message = </span><span class="s4">r&quot;Dimension of `engine` must be consistent&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=message):</span>
            <span class="s1">qmc.MultivariateNormalQMC([</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">engine=qmc.Sobol(d=</span><span class="s3">2</span><span class="s1">))</span>

        <span class="s1">message = </span><span class="s4">r&quot;Dimension of `engine` must be consistent&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=message):</span>
            <span class="s1">qmc.MultivariateNormalQMC([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">engine=qmc.Sobol(d=</span><span class="s3">4</span><span class="s1">))</span>

        <span class="s1">message = </span><span class="s4">r&quot;`engine` must be an instance of...&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=message):</span>
            <span class="s1">qmc.MultivariateNormalQMC([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">engine=np.random.default_rng())</span>

        <span class="s1">message = </span><span class="s4">r&quot;Covariance matrix not PSD.&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=message):</span>
            <span class="s1">qmc.MultivariateNormalQMC([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]])</span>

        <span class="s1">message = </span><span class="s4">r&quot;Covariance matrix is not symmetric.&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=message):</span>
            <span class="s1">qmc.MultivariateNormalQMC([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">2</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]])</span>

        <span class="s1">message = </span><span class="s4">r&quot;Dimension mismatch between mean and covariance.&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=message):</span>
            <span class="s1">qmc.MultivariateNormalQMC([</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]])</span>

    <span class="s0">def </span><span class="s1">test_MultivariateNormalQMCNonPD(self):</span>
        <span class="s2"># try with non-pd but psd cov; should work</span>
        <span class="s1">engine = qmc.MultivariateNormalQMC(</span>
            <span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]]</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">engine._corr_matrix </span><span class="s0">is not None</span>

    <span class="s0">def </span><span class="s1">test_MultivariateNormalQMC(self):</span>
        <span class="s2"># d = 1 scalar</span>
        <span class="s1">engine = qmc.MultivariateNormalQMC(mean=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">cov=</span><span class="s3">5</span><span class="s1">)</span>
        <span class="s1">samples = engine.random()</span>
        <span class="s1">assert_equal(samples.shape</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">samples = engine.random(n=</span><span class="s3">5</span><span class="s1">)</span>
        <span class="s1">assert_equal(samples.shape</span><span class="s0">, </span><span class="s1">(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span>

        <span class="s2"># d = 2 list</span>
        <span class="s1">engine = qmc.MultivariateNormalQMC(mean=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">cov=[[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]])</span>
        <span class="s1">samples = engine.random()</span>
        <span class="s1">assert_equal(samples.shape</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
        <span class="s1">samples = engine.random(n=</span><span class="s3">5</span><span class="s1">)</span>
        <span class="s1">assert_equal(samples.shape</span><span class="s0">, </span><span class="s1">(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>

        <span class="s2"># d = 3 np.array</span>
        <span class="s1">mean = np.array([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">])</span>
        <span class="s1">cov = np.array([[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]])</span>
        <span class="s1">engine = qmc.MultivariateNormalQMC(mean</span><span class="s0">, </span><span class="s1">cov)</span>
        <span class="s1">samples = engine.random()</span>
        <span class="s1">assert_equal(samples.shape</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>
        <span class="s1">samples = engine.random(n=</span><span class="s3">5</span><span class="s1">)</span>
        <span class="s1">assert_equal(samples.shape</span><span class="s0">, </span><span class="s1">(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_MultivariateNormalQMCInvTransform(self):</span>
        <span class="s2"># d = 1 scalar</span>
        <span class="s1">engine = qmc.MultivariateNormalQMC(mean=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">cov=</span><span class="s3">5</span><span class="s0">, </span><span class="s1">inv_transform=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">samples = engine.random()</span>
        <span class="s1">assert_equal(samples.shape</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span>
        <span class="s1">samples = engine.random(n=</span><span class="s3">5</span><span class="s1">)</span>
        <span class="s1">assert_equal(samples.shape</span><span class="s0">, </span><span class="s1">(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span>

        <span class="s2"># d = 2 list</span>
        <span class="s1">engine = qmc.MultivariateNormalQMC(</span>
            <span class="s1">mean=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">cov=[[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">inv_transform=</span><span class="s0">True,</span>
        <span class="s1">)</span>
        <span class="s1">samples = engine.random()</span>
        <span class="s1">assert_equal(samples.shape</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
        <span class="s1">samples = engine.random(n=</span><span class="s3">5</span><span class="s1">)</span>
        <span class="s1">assert_equal(samples.shape</span><span class="s0">, </span><span class="s1">(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>

        <span class="s2"># d = 3 np.array</span>
        <span class="s1">mean = np.array([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">])</span>
        <span class="s1">cov = np.array([[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]])</span>
        <span class="s1">engine = qmc.MultivariateNormalQMC(mean</span><span class="s0">, </span><span class="s1">cov</span><span class="s0">, </span><span class="s1">inv_transform=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">samples = engine.random()</span>
        <span class="s1">assert_equal(samples.shape</span><span class="s0">, </span><span class="s1">(</span><span class="s3">1</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>
        <span class="s1">samples = engine.random(n=</span><span class="s3">5</span><span class="s1">)</span>
        <span class="s1">assert_equal(samples.shape</span><span class="s0">, </span><span class="s1">(</span><span class="s3">5</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">test_MultivariateNormalQMCSeeded(self):</span>
        <span class="s2"># test even dimension</span>
        <span class="s1">rng = np.random.default_rng(</span><span class="s3">180182791534511062935571481899241825000</span><span class="s1">)</span>
        <span class="s1">a = rng.standard_normal((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
        <span class="s1">A = a @ a.transpose() + np.diag(rng.random(</span><span class="s3">2</span><span class="s1">))</span>
        <span class="s1">engine = qmc.MultivariateNormalQMC(np.array([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">])</span><span class="s0">, </span><span class="s1">A</span><span class="s0">,</span>
                                           <span class="s1">inv_transform=</span><span class="s0">False, </span><span class="s1">seed=rng)</span>
        <span class="s1">samples = engine.random(n=</span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">samples_expected = np.array([[-</span><span class="s3">0.64419</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.882413</span><span class="s1">]</span><span class="s0">,</span>
                                     <span class="s1">[</span><span class="s3">0.837199</span><span class="s0">, </span><span class="s3">2.045301</span><span class="s1">]])</span>
        <span class="s1">assert_allclose(samples</span><span class="s0">, </span><span class="s1">samples_expected</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-4</span><span class="s1">)</span>

        <span class="s2"># test odd dimension</span>
        <span class="s1">rng = np.random.default_rng(</span><span class="s3">180182791534511062935571481899241825000</span><span class="s1">)</span>
        <span class="s1">a = rng.standard_normal((</span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>
        <span class="s1">A = a @ a.transpose() + np.diag(rng.random(</span><span class="s3">3</span><span class="s1">))</span>
        <span class="s1">engine = qmc.MultivariateNormalQMC(np.array([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">])</span><span class="s0">, </span><span class="s1">A</span><span class="s0">,</span>
                                           <span class="s1">inv_transform=</span><span class="s0">False, </span><span class="s1">seed=rng)</span>
        <span class="s1">samples = engine.random(n=</span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">samples_expected = np.array([[-</span><span class="s3">0.693853</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1.265338</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.088024</span><span class="s1">]</span><span class="s0">,</span>
                                     <span class="s1">[</span><span class="s3">1.620193</span><span class="s0">, </span><span class="s3">2.679222</span><span class="s0">, </span><span class="s3">0.457343</span><span class="s1">]])</span>
        <span class="s1">assert_allclose(samples</span><span class="s0">, </span><span class="s1">samples_expected</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-4</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_MultivariateNormalQMCSeededInvTransform(self):</span>
        <span class="s2"># test even dimension</span>
        <span class="s1">rng = np.random.default_rng(</span><span class="s3">224125808928297329711992996940871155974</span><span class="s1">)</span>
        <span class="s1">a = rng.standard_normal((</span><span class="s3">2</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
        <span class="s1">A = a @ a.transpose() + np.diag(rng.random(</span><span class="s3">2</span><span class="s1">))</span>
        <span class="s1">engine = qmc.MultivariateNormalQMC(</span>
            <span class="s1">np.array([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">])</span><span class="s0">, </span><span class="s1">A</span><span class="s0">, </span><span class="s1">seed=rng</span><span class="s0">, </span><span class="s1">inv_transform=</span><span class="s0">True</span>
        <span class="s1">)</span>
        <span class="s1">samples = engine.random(n=</span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">samples_expected = np.array([[</span><span class="s3">0.682171</span><span class="s0">, </span><span class="s1">-</span><span class="s3">3.114233</span><span class="s1">]</span><span class="s0">,</span>
                                     <span class="s1">[-</span><span class="s3">0.098463</span><span class="s0">, </span><span class="s3">0.668069</span><span class="s1">]])</span>
        <span class="s1">assert_allclose(samples</span><span class="s0">, </span><span class="s1">samples_expected</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-4</span><span class="s1">)</span>

        <span class="s2"># test odd dimension</span>
        <span class="s1">rng = np.random.default_rng(</span><span class="s3">224125808928297329711992996940871155974</span><span class="s1">)</span>
        <span class="s1">a = rng.standard_normal((</span><span class="s3">3</span><span class="s0">, </span><span class="s3">3</span><span class="s1">))</span>
        <span class="s1">A = a @ a.transpose() + np.diag(rng.random(</span><span class="s3">3</span><span class="s1">))</span>
        <span class="s1">engine = qmc.MultivariateNormalQMC(</span>
            <span class="s1">np.array([</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">])</span><span class="s0">, </span><span class="s1">A</span><span class="s0">, </span><span class="s1">seed=rng</span><span class="s0">, </span><span class="s1">inv_transform=</span><span class="s0">True</span>
        <span class="s1">)</span>
        <span class="s1">samples = engine.random(n=</span><span class="s3">2</span><span class="s1">)</span>
        <span class="s1">samples_expected = np.array([[</span><span class="s3">0.988061</span><span class="s0">, </span><span class="s1">-</span><span class="s3">1.644089</span><span class="s0">, </span><span class="s1">-</span><span class="s3">0.877035</span><span class="s1">]</span><span class="s0">,</span>
                                     <span class="s1">[-</span><span class="s3">1.771731</span><span class="s0">, </span><span class="s3">1.096988</span><span class="s0">, </span><span class="s3">2.024744</span><span class="s1">]])</span>
        <span class="s1">assert_allclose(samples</span><span class="s0">, </span><span class="s1">samples_expected</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-4</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_MultivariateNormalQMCShapiro(self):</span>
        <span class="s2"># test the standard case</span>
        <span class="s1">seed = np.random.default_rng(</span><span class="s3">188960007281846377164494575845971640</span><span class="s1">)</span>
        <span class="s1">engine = qmc.MultivariateNormalQMC(</span>
            <span class="s1">mean=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">cov=[[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">seed=seed</span>
        <span class="s1">)</span>
        <span class="s1">samples = engine.random(n=</span><span class="s3">256</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">all(np.abs(samples.mean(axis=</span><span class="s3">0</span><span class="s1">)) &lt; </span><span class="s3">1e-2</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">all(np.abs(samples.std(axis=</span><span class="s3">0</span><span class="s1">) - </span><span class="s3">1</span><span class="s1">) &lt; </span><span class="s3">1e-2</span><span class="s1">)</span>
        <span class="s2"># perform Shapiro-Wilk test for normality</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">):</span>
            <span class="s1">_</span><span class="s0">, </span><span class="s1">pval = shapiro(samples[:</span><span class="s0">, </span><span class="s1">i])</span>
            <span class="s0">assert </span><span class="s1">pval &gt; </span><span class="s3">0.9</span>
        <span class="s2"># make sure samples are uncorrelated</span>
        <span class="s1">cov = np.cov(samples.transpose())</span>
        <span class="s0">assert </span><span class="s1">np.abs(cov[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]) &lt; </span><span class="s3">1e-2</span>

        <span class="s2"># test the correlated, non-zero mean case</span>
        <span class="s1">engine = qmc.MultivariateNormalQMC(</span>
            <span class="s1">mean=[</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">2.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">cov=[[</span><span class="s3">1.5</span><span class="s0">, </span><span class="s3">0.5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">1.5</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">seed=seed</span>
        <span class="s1">)</span>
        <span class="s1">samples = engine.random(n=</span><span class="s3">256</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">all(np.abs(samples.mean(axis=</span><span class="s3">0</span><span class="s1">) - [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]) &lt; </span><span class="s3">1e-2</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">all(np.abs(samples.std(axis=</span><span class="s3">0</span><span class="s1">) - np.sqrt(</span><span class="s3">1.5</span><span class="s1">)) &lt; </span><span class="s3">1e-2</span><span class="s1">)</span>
        <span class="s2"># perform Shapiro-Wilk test for normality</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">):</span>
            <span class="s1">_</span><span class="s0">, </span><span class="s1">pval = shapiro(samples[:</span><span class="s0">, </span><span class="s1">i])</span>
            <span class="s0">assert </span><span class="s1">pval &gt; </span><span class="s3">0.9</span>
        <span class="s2"># check covariance</span>
        <span class="s1">cov = np.cov(samples.transpose())</span>
        <span class="s0">assert </span><span class="s1">np.abs(cov[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">] - </span><span class="s3">0.5</span><span class="s1">) &lt; </span><span class="s3">1e-2</span>

    <span class="s0">def </span><span class="s1">test_MultivariateNormalQMCShapiroInvTransform(self):</span>
        <span class="s2"># test the standard case</span>
        <span class="s1">seed = np.random.default_rng(</span><span class="s3">200089821034563288698994840831440331329</span><span class="s1">)</span>
        <span class="s1">engine = qmc.MultivariateNormalQMC(</span>
            <span class="s1">mean=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">cov=[[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">seed=seed</span><span class="s0">, </span><span class="s1">inv_transform=</span><span class="s0">True</span>
        <span class="s1">)</span>
        <span class="s1">samples = engine.random(n=</span><span class="s3">256</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">all(np.abs(samples.mean(axis=</span><span class="s3">0</span><span class="s1">)) &lt; </span><span class="s3">1e-2</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">all(np.abs(samples.std(axis=</span><span class="s3">0</span><span class="s1">) - </span><span class="s3">1</span><span class="s1">) &lt; </span><span class="s3">1e-2</span><span class="s1">)</span>
        <span class="s2"># perform Shapiro-Wilk test for normality</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">):</span>
            <span class="s1">_</span><span class="s0">, </span><span class="s1">pval = shapiro(samples[:</span><span class="s0">, </span><span class="s1">i])</span>
            <span class="s0">assert </span><span class="s1">pval &gt; </span><span class="s3">0.9</span>
        <span class="s2"># make sure samples are uncorrelated</span>
        <span class="s1">cov = np.cov(samples.transpose())</span>
        <span class="s0">assert </span><span class="s1">np.abs(cov[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]) &lt; </span><span class="s3">1e-2</span>

        <span class="s2"># test the correlated, non-zero mean case</span>
        <span class="s1">engine = qmc.MultivariateNormalQMC(</span>
            <span class="s1">mean=[</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">2.0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">cov=[[</span><span class="s3">1.5</span><span class="s0">, </span><span class="s3">0.5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0.5</span><span class="s0">, </span><span class="s3">1.5</span><span class="s1">]]</span><span class="s0">,</span>
            <span class="s1">seed=seed</span><span class="s0">,</span>
            <span class="s1">inv_transform=</span><span class="s0">True,</span>
        <span class="s1">)</span>
        <span class="s1">samples = engine.random(n=</span><span class="s3">256</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">all(np.abs(samples.mean(axis=</span><span class="s3">0</span><span class="s1">) - [</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]) &lt; </span><span class="s3">1e-2</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">all(np.abs(samples.std(axis=</span><span class="s3">0</span><span class="s1">) - np.sqrt(</span><span class="s3">1.5</span><span class="s1">)) &lt; </span><span class="s3">1e-2</span><span class="s1">)</span>
        <span class="s2"># perform Shapiro-Wilk test for normality</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">):</span>
            <span class="s1">_</span><span class="s0">, </span><span class="s1">pval = shapiro(samples[:</span><span class="s0">, </span><span class="s1">i])</span>
            <span class="s0">assert </span><span class="s1">pval &gt; </span><span class="s3">0.9</span>
        <span class="s2"># check covariance</span>
        <span class="s1">cov = np.cov(samples.transpose())</span>
        <span class="s0">assert </span><span class="s1">np.abs(cov[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">] - </span><span class="s3">0.5</span><span class="s1">) &lt; </span><span class="s3">1e-2</span>

    <span class="s0">def </span><span class="s1">test_MultivariateNormalQMCDegenerate(self):</span>
        <span class="s2"># X, Y iid standard Normal and Z = X + Y, random vector (X, Y, Z)</span>
        <span class="s1">seed = np.random.default_rng(</span><span class="s3">16320637417581448357869821654290448620</span><span class="s1">)</span>
        <span class="s1">engine = qmc.MultivariateNormalQMC(</span>
            <span class="s1">mean=[</span><span class="s3">0.0</span><span class="s0">, </span><span class="s3">0.0</span><span class="s0">, </span><span class="s3">0.0</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">cov=[[</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">0.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">1.0</span><span class="s0">, </span><span class="s3">2.0</span><span class="s1">]]</span><span class="s0">,</span>
            <span class="s1">seed=seed</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">samples = engine.random(n=</span><span class="s3">512</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">all(np.abs(samples.mean(axis=</span><span class="s3">0</span><span class="s1">)) &lt; </span><span class="s3">1e-2</span><span class="s1">)</span>
        <span class="s0">assert </span><span class="s1">np.abs(np.std(samples[:</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]) - </span><span class="s3">1</span><span class="s1">) &lt; </span><span class="s3">1e-2</span>
        <span class="s0">assert </span><span class="s1">np.abs(np.std(samples[:</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]) - </span><span class="s3">1</span><span class="s1">) &lt; </span><span class="s3">1e-2</span>
        <span class="s0">assert </span><span class="s1">np.abs(np.std(samples[:</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]) - np.sqrt(</span><span class="s3">2</span><span class="s1">)) &lt; </span><span class="s3">1e-2</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">):</span>
            <span class="s1">_</span><span class="s0">, </span><span class="s1">pval = shapiro(samples[:</span><span class="s0">, </span><span class="s1">i])</span>
            <span class="s0">assert </span><span class="s1">pval &gt; </span><span class="s3">0.8</span>
        <span class="s1">cov = np.cov(samples.transpose())</span>
        <span class="s0">assert </span><span class="s1">np.abs(cov[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">]) &lt; </span><span class="s3">1e-2</span>
        <span class="s0">assert </span><span class="s1">np.abs(cov[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">2</span><span class="s1">] - </span><span class="s3">1</span><span class="s1">) &lt; </span><span class="s3">1e-2</span>
        <span class="s2"># check to see if X + Y = Z almost exactly</span>
        <span class="s0">assert </span><span class="s1">all(np.abs(samples[:</span><span class="s0">, </span><span class="s3">0</span><span class="s1">] + samples[:</span><span class="s0">, </span><span class="s3">1</span><span class="s1">] - samples[:</span><span class="s0">, </span><span class="s3">2</span><span class="s1">])</span>
                   <span class="s1">&lt; </span><span class="s3">1e-5</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">TestLloyd:</span>
    <span class="s0">def </span><span class="s1">test_lloyd(self):</span>
        <span class="s2"># quite sensible seed as it can go up before going further down</span>
        <span class="s1">rng = np.random.RandomState(</span><span class="s3">1809831</span><span class="s1">)</span>
        <span class="s1">sample = rng.uniform(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s1">size=(</span><span class="s3">128</span><span class="s0">, </span><span class="s3">2</span><span class="s1">))</span>
        <span class="s1">base_l1 = _l1_norm(sample)</span>
        <span class="s1">base_l2 = l2_norm(sample)</span>

        <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">4</span><span class="s1">):</span>
            <span class="s1">sample_lloyd = _lloyd_centroidal_voronoi_tessellation(</span>
                    <span class="s1">sample</span><span class="s0">, </span><span class="s1">maxiter=</span><span class="s3">1</span><span class="s0">,</span>
            <span class="s1">)</span>
            <span class="s1">curr_l1 = _l1_norm(sample_lloyd)</span>
            <span class="s1">curr_l2 = l2_norm(sample_lloyd)</span>

            <span class="s2"># higher is better for the distance measures</span>
            <span class="s0">assert </span><span class="s1">base_l1 &lt; curr_l1</span>
            <span class="s0">assert </span><span class="s1">base_l2 &lt; curr_l2</span>

            <span class="s1">base_l1 = curr_l1</span>
            <span class="s1">base_l2 = curr_l2</span>

            <span class="s1">sample = sample_lloyd</span>

    <span class="s0">def </span><span class="s1">test_lloyd_non_mutating(self):</span>
        <span class="s5">&quot;&quot;&quot; 
        Verify that the input samples are not mutated in place and that they do 
        not share memory with the output. 
        &quot;&quot;&quot;</span>
        <span class="s1">sample_orig = np.array([[</span><span class="s3">0.1</span><span class="s0">, </span><span class="s3">0.1</span><span class="s1">]</span><span class="s0">,</span>
                                <span class="s1">[</span><span class="s3">0.1</span><span class="s0">, </span><span class="s3">0.2</span><span class="s1">]</span><span class="s0">,</span>
                                <span class="s1">[</span><span class="s3">0.2</span><span class="s0">, </span><span class="s3">0.1</span><span class="s1">]</span><span class="s0">,</span>
                                <span class="s1">[</span><span class="s3">0.2</span><span class="s0">, </span><span class="s3">0.2</span><span class="s1">]])</span>
        <span class="s1">sample_copy = sample_orig.copy()</span>
        <span class="s1">new_sample = _lloyd_centroidal_voronoi_tessellation(</span>
            <span class="s1">sample=sample_orig</span>
        <span class="s1">)</span>
        <span class="s1">assert_allclose(sample_orig</span><span class="s0">, </span><span class="s1">sample_copy)</span>
        <span class="s0">assert not </span><span class="s1">np.may_share_memory(sample_orig</span><span class="s0">, </span><span class="s1">new_sample)</span>

    <span class="s0">def </span><span class="s1">test_lloyd_errors(self):</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">r&quot;`sample` is not a 2D array&quot;</span><span class="s1">):</span>
            <span class="s1">sample = [</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s0">, </span><span class="s3">0.5</span><span class="s1">]</span>
            <span class="s1">_lloyd_centroidal_voronoi_tessellation(sample)</span>

        <span class="s1">msg = </span><span class="s4">r&quot;`sample` dimension is not &gt;= 2&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">sample = [[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0.4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s1">]]</span>
            <span class="s1">_lloyd_centroidal_voronoi_tessellation(sample)</span>

        <span class="s1">msg = </span><span class="s4">r&quot;`sample` is not in unit hypercube&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">sample = [[-</span><span class="s3">1.1</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">0.1</span><span class="s0">, </span><span class="s3">0.4</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s3">1</span><span class="s0">, </span><span class="s3">2</span><span class="s1">]]</span>
            <span class="s1">_lloyd_centroidal_voronoi_tessellation(sample)</span>


<span class="s2"># mindist</span>
<span class="s0">def </span><span class="s1">l2_norm(sample):</span>
    <span class="s0">return </span><span class="s1">distance.pdist(sample).min()</span>
</pre>
</body>
</html>