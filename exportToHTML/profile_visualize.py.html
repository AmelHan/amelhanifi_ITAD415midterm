<html>
<head>
<title>profile_visualize.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #6897bb;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
profile_visualize.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">import </span><span class="s1">random</span>
<span class="s0">import </span><span class="s1">warnings</span>
<span class="s0">from </span><span class="s1">bisect </span><span class="s0">import </span><span class="s1">bisect_left</span>
<span class="s0">from </span><span class="s1">itertools </span><span class="s0">import </span><span class="s1">cycle</span>
<span class="s0">from </span><span class="s1">operator </span><span class="s0">import </span><span class="s1">add</span><span class="s0">, </span><span class="s1">itemgetter</span>

<span class="s0">from </span><span class="s1">tlz </span><span class="s0">import </span><span class="s1">accumulate</span><span class="s0">, </span><span class="s1">groupby</span><span class="s0">, </span><span class="s1">pluck</span><span class="s0">, </span><span class="s1">unique</span>

<span class="s0">from </span><span class="s1">dask.core </span><span class="s0">import </span><span class="s1">istask</span>
<span class="s0">from </span><span class="s1">dask.utils </span><span class="s0">import </span><span class="s1">apply</span><span class="s0">, </span><span class="s1">funcname</span><span class="s0">, </span><span class="s1">import_required</span>


<span class="s0">def </span><span class="s1">BOKEH_VERSION():</span>
    <span class="s0">import </span><span class="s1">bokeh</span>
    <span class="s0">from </span><span class="s1">packaging.version </span><span class="s0">import </span><span class="s1">parse </span><span class="s0">as </span><span class="s1">parse_version</span>

    <span class="s0">return </span><span class="s1">parse_version(bokeh.__version__)</span>


<span class="s1">_BOKEH_MISSING_MSG = </span><span class="s2">&quot;Diagnostics plots require `bokeh` to be installed&quot;</span>


<span class="s0">def </span><span class="s1">unquote(expr):</span>
    <span class="s0">if </span><span class="s1">istask(expr):</span>
        <span class="s0">if </span><span class="s1">expr[</span><span class="s3">0</span><span class="s1">] </span><span class="s0">in </span><span class="s1">(tuple</span><span class="s0">, </span><span class="s1">list</span><span class="s0">, </span><span class="s1">set):</span>
            <span class="s0">return </span><span class="s1">expr[</span><span class="s3">0</span><span class="s1">](map(unquote</span><span class="s0">, </span><span class="s1">expr[</span><span class="s3">1</span><span class="s1">]))</span>
        <span class="s0">elif </span><span class="s1">(</span>
            <span class="s1">expr[</span><span class="s3">0</span><span class="s1">] == dict</span>
            <span class="s0">and </span><span class="s1">isinstance(expr[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">list)</span>
            <span class="s0">and </span><span class="s1">isinstance(expr[</span><span class="s3">1</span><span class="s1">][</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">list)</span>
        <span class="s1">):</span>
            <span class="s0">return </span><span class="s1">dict(map(unquote</span><span class="s0">, </span><span class="s1">expr[</span><span class="s3">1</span><span class="s1">]))</span>
    <span class="s0">return </span><span class="s1">expr</span>


<span class="s0">def </span><span class="s1">pprint_task(task</span><span class="s0">, </span><span class="s1">keys</span><span class="s0">, </span><span class="s1">label_size=</span><span class="s3">60</span><span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot;Return a nicely formatted string for a task. 
 
    Parameters 
    ---------- 
    task: 
        Value within dask graph to render as text 
    keys: iterable 
        List of keys within dask graph 
    label_size: int (optional) 
        Maximum size of output label, defaults to 60 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from operator import add, mul 
    &gt;&gt;&gt; dsk = {'a': 1, 
    ...        'b': 2, 
    ...        'c': (add, 'a', 'b'), 
    ...        'd': (add, (mul, 'a', 'b'), 'c'), 
    ...        'e': (sum, ['a', 'b', 5]), 
    ...        'f': (add,), 
    ...        'g': []} 
 
    &gt;&gt;&gt; pprint_task(dsk['c'], dsk) 
    'add(_, _)' 
    &gt;&gt;&gt; pprint_task(dsk['d'], dsk) 
    'add(mul(_, _), _)' 
    &gt;&gt;&gt; pprint_task(dsk['e'], dsk) 
    'sum([_, _, *])' 
    &gt;&gt;&gt; pprint_task(dsk['f'], dsk) 
    'add()' 
    &gt;&gt;&gt; pprint_task(dsk['g'], dsk) 
    '[]' 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">istask(task):</span>
        <span class="s1">func = task[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s0">if </span><span class="s1">func </span><span class="s0">is </span><span class="s1">apply:</span>
            <span class="s1">head = funcname(task[</span><span class="s3">1</span><span class="s1">])</span>
            <span class="s1">tail = </span><span class="s2">&quot;)&quot;</span>
            <span class="s1">args = unquote(task[</span><span class="s3">2</span><span class="s1">]) </span><span class="s0">if </span><span class="s1">len(task) &gt; </span><span class="s3">2 </span><span class="s0">else </span><span class="s1">()</span>
            <span class="s1">kwargs = unquote(task[</span><span class="s3">3</span><span class="s1">]) </span><span class="s0">if </span><span class="s1">len(task) &gt; </span><span class="s3">3 </span><span class="s0">else </span><span class="s1">{}</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">hasattr(func</span><span class="s0">, </span><span class="s2">&quot;funcs&quot;</span><span class="s1">):</span>
                <span class="s1">head = </span><span class="s2">&quot;(&quot;</span><span class="s1">.join(funcname(f) </span><span class="s0">for </span><span class="s1">f </span><span class="s0">in </span><span class="s1">func.funcs)</span>
                <span class="s1">tail = </span><span class="s2">&quot;)&quot; </span><span class="s1">* len(func.funcs)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">head = funcname(task[</span><span class="s3">0</span><span class="s1">])</span>
                <span class="s1">tail = </span><span class="s2">&quot;)&quot;</span>
            <span class="s1">args = task[</span><span class="s3">1</span><span class="s1">:]</span>
            <span class="s1">kwargs = {}</span>
        <span class="s0">if </span><span class="s1">args </span><span class="s0">or </span><span class="s1">kwargs:</span>
            <span class="s1">label_size2 = int(</span>
                <span class="s1">(label_size - len(head) - len(tail)) // (len(args) + len(kwargs))</span>
            <span class="s1">)</span>
            <span class="s1">pprint = </span><span class="s0">lambda </span><span class="s1">t: pprint_task(t</span><span class="s0">, </span><span class="s1">keys</span><span class="s0">, </span><span class="s1">label_size2)</span>
        <span class="s0">if </span><span class="s1">args:</span>
            <span class="s0">if </span><span class="s1">label_size2 &gt; </span><span class="s3">5</span><span class="s1">:</span>
                <span class="s1">args = </span><span class="s2">&quot;, &quot;</span><span class="s1">.join(pprint(t) </span><span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">args)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">args = </span><span class="s2">&quot;...&quot;</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">args = </span><span class="s2">&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">kwargs:</span>
            <span class="s0">if </span><span class="s1">label_size2 &gt; </span><span class="s3">5</span><span class="s1">:</span>
                <span class="s1">kwargs = </span><span class="s2">&quot;, &quot; </span><span class="s1">+ </span><span class="s2">&quot;, &quot;</span><span class="s1">.join(</span>
                    <span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">k</span><span class="s0">}</span><span class="s2">=</span><span class="s0">{</span><span class="s1">pprint(v)</span><span class="s0">}</span><span class="s2">&quot; </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">sorted(kwargs.items())</span>
                <span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">kwargs = </span><span class="s2">&quot;, ...&quot;</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">kwargs = </span><span class="s2">&quot;&quot;</span>
        <span class="s0">return </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">head</span><span class="s0">}</span><span class="s2">(</span><span class="s0">{</span><span class="s1">args</span><span class="s0">}{</span><span class="s1">kwargs</span><span class="s0">}{</span><span class="s1">tail</span><span class="s0">}</span><span class="s2">&quot;</span>
    <span class="s0">elif </span><span class="s1">isinstance(task</span><span class="s0">, </span><span class="s1">list):</span>
        <span class="s0">if not </span><span class="s1">task:</span>
            <span class="s0">return </span><span class="s2">&quot;[]&quot;</span>
        <span class="s0">elif </span><span class="s1">len(task) &gt; </span><span class="s3">3</span><span class="s1">:</span>
            <span class="s1">result = pprint_task(task[:</span><span class="s3">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">keys</span><span class="s0">, </span><span class="s1">label_size)</span>
            <span class="s0">return </span><span class="s1">result[:-</span><span class="s3">1</span><span class="s1">] + </span><span class="s2">&quot;, ...]&quot;</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">label_size2 = int((label_size - </span><span class="s3">2 </span><span class="s1">- </span><span class="s3">2 </span><span class="s1">* len(task)) // len(task))</span>
            <span class="s1">args = </span><span class="s2">&quot;, &quot;</span><span class="s1">.join(pprint_task(t</span><span class="s0">, </span><span class="s1">keys</span><span class="s0">, </span><span class="s1">label_size2) </span><span class="s0">for </span><span class="s1">t </span><span class="s0">in </span><span class="s1">task)</span>
            <span class="s0">return </span><span class="s2">f&quot;[</span><span class="s0">{</span><span class="s1">args</span><span class="s0">}</span><span class="s2">]&quot;</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">task </span><span class="s0">in </span><span class="s1">keys:</span>
                <span class="s0">return </span><span class="s2">&quot;_&quot;</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">return </span><span class="s2">&quot;*&quot;</span>
        <span class="s0">except </span><span class="s1">TypeError:</span>
            <span class="s0">return </span><span class="s2">&quot;*&quot;</span>


<span class="s0">def </span><span class="s1">get_colors(palette</span><span class="s0">, </span><span class="s1">funcs):</span>
    <span class="s4">&quot;&quot;&quot;Get a dict mapping funcs to colors from palette. 
 
    Parameters 
    ---------- 
    palette : string 
        Name of the bokeh palette to use, must be a member of 
        bokeh.palettes.all_palettes. 
    funcs : iterable 
        Iterable of function names 
    &quot;&quot;&quot;</span>
    <span class="s1">palettes = import_required(</span><span class="s2">&quot;bokeh.palettes&quot;</span><span class="s0">, </span><span class="s1">_BOKEH_MISSING_MSG)</span>

    <span class="s1">unique_funcs = sorted(unique(funcs))</span>
    <span class="s1">n_funcs = len(unique_funcs)</span>
    <span class="s1">palette_lookup = palettes.all_palettes[palette]</span>
    <span class="s1">keys = list(sorted(palette_lookup.keys()))</span>
    <span class="s1">index = keys[min(bisect_left(keys</span><span class="s0">, </span><span class="s1">n_funcs)</span><span class="s0">, </span><span class="s1">len(keys) - </span><span class="s3">1</span><span class="s1">)]</span>
    <span class="s1">palette = palette_lookup[index]</span>
    <span class="s5"># Some bokeh palettes repeat colors, we want just the unique set</span>
    <span class="s1">palette = list(unique(palette))</span>
    <span class="s0">if </span><span class="s1">len(palette) &gt; n_funcs:</span>
        <span class="s5"># Consistently shuffle palette - prevents just using low-range</span>
        <span class="s1">random.Random(</span><span class="s3">42</span><span class="s1">).shuffle(palette)</span>
    <span class="s1">color_lookup = dict(zip(unique_funcs</span><span class="s0">, </span><span class="s1">cycle(palette)))</span>
    <span class="s0">return </span><span class="s1">[color_lookup[n] </span><span class="s0">for </span><span class="s1">n </span><span class="s0">in </span><span class="s1">funcs]</span>


<span class="s0">def </span><span class="s1">visualize(</span>
    <span class="s1">profilers</span><span class="s0">, </span><span class="s1">filename=</span><span class="s2">&quot;profile.html&quot;</span><span class="s0">, </span><span class="s1">show=</span><span class="s0">True, </span><span class="s1">save=</span><span class="s0">None, </span><span class="s1">mode=</span><span class="s0">None, </span><span class="s1">**kwargs</span>
<span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot;Visualize the results of profiling in a bokeh plot. 
 
    If multiple profilers are passed in, the plots are stacked vertically. 
 
    Parameters 
    ---------- 
    profilers : profiler or list 
        Profiler or list of profilers. 
    filename : string, optional 
        Name of the plot output file. 
    show : boolean, optional 
        If True (default), the plot is opened in a browser. 
    save : boolean, optional 
        If True (default when not in notebook), the plot is saved to disk. 
    mode : str, optional 
        Mode passed to bokeh.output_file() 
    **kwargs 
        Other keyword arguments, passed to bokeh.figure. These will override 
        all defaults set by visualize. 
 
    Returns 
    ------- 
    The completed bokeh plot object. 
    &quot;&quot;&quot;</span>
    <span class="s1">bp = import_required(</span><span class="s2">&quot;bokeh.plotting&quot;</span><span class="s0">, </span><span class="s1">_BOKEH_MISSING_MSG)</span>
    <span class="s0">from </span><span class="s1">bokeh.io </span><span class="s0">import </span><span class="s1">state</span>

    <span class="s0">if </span><span class="s2">&quot;file_path&quot; </span><span class="s0">in </span><span class="s1">kwargs:</span>
        <span class="s1">warnings.warn(</span>
            <span class="s2">&quot;The file_path keyword argument is deprecated &quot;</span>
            <span class="s2">&quot;and will be removed in a future release. &quot;</span>
            <span class="s2">&quot;Please use filename instead.&quot;</span><span class="s0">,</span>
            <span class="s1">category=FutureWarning</span><span class="s0">,</span>
            <span class="s1">stacklevel=</span><span class="s3">2</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">filename = kwargs.pop(</span><span class="s2">&quot;file_path&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">save </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">save = </span><span class="s0">not </span><span class="s1">state.curstate().notebook</span>

    <span class="s0">if not </span><span class="s1">isinstance(profilers</span><span class="s0">, </span><span class="s1">list):</span>
        <span class="s1">profilers = [profilers]</span>
    <span class="s1">figs = [prof._plot(**kwargs) </span><span class="s0">for </span><span class="s1">prof </span><span class="s0">in </span><span class="s1">profilers]</span>
    <span class="s5"># Stack the plots</span>
    <span class="s0">if </span><span class="s1">len(figs) == </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s1">p = figs[</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">top = figs[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s0">for </span><span class="s1">f </span><span class="s0">in </span><span class="s1">figs[</span><span class="s3">1</span><span class="s1">:]:</span>
            <span class="s1">f.x_range = top.x_range</span>
            <span class="s1">f.title = </span><span class="s0">None</span>
            <span class="s1">f.min_border_top = </span><span class="s3">20</span>
            <span class="s0">if </span><span class="s1">BOKEH_VERSION().major &lt; </span><span class="s3">3</span><span class="s1">:</span>
                <span class="s1">f.plot_height -= </span><span class="s3">30</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">f.height -= </span><span class="s3">30</span>
        <span class="s0">for </span><span class="s1">f </span><span class="s0">in </span><span class="s1">figs[:-</span><span class="s3">1</span><span class="s1">]:</span>
            <span class="s1">f.xaxis.axis_label = </span><span class="s0">None</span>
            <span class="s1">f.min_border_bottom = </span><span class="s3">20</span>
            <span class="s0">if </span><span class="s1">BOKEH_VERSION().major &lt; </span><span class="s3">3</span><span class="s1">:</span>
                <span class="s1">f.plot_height -= </span><span class="s3">30</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">f.height -= </span><span class="s3">30</span>
        <span class="s0">for </span><span class="s1">f </span><span class="s0">in </span><span class="s1">figs:</span>
            <span class="s1">f.min_border_left = </span><span class="s3">75</span>
            <span class="s1">f.min_border_right = </span><span class="s3">75</span>
        <span class="s1">p = bp.gridplot([[f] </span><span class="s0">for </span><span class="s1">f </span><span class="s0">in </span><span class="s1">figs])</span>
    <span class="s0">if </span><span class="s1">show:</span>
        <span class="s1">bp.show(p)</span>
    <span class="s0">if </span><span class="s1">save:</span>
        <span class="s1">bp.output_file(filename</span><span class="s0">, </span><span class="s1">mode=mode)</span>
        <span class="s1">bp.save(p)</span>
    <span class="s0">return </span><span class="s1">p</span>


<span class="s0">def </span><span class="s1">plot_tasks(</span>
    <span class="s1">results</span><span class="s0">, </span><span class="s1">dsk</span><span class="s0">, </span><span class="s1">start_time</span><span class="s0">, </span><span class="s1">end_time</span><span class="s0">, </span><span class="s1">palette=</span><span class="s2">&quot;Viridis&quot;</span><span class="s0">, </span><span class="s1">label_size=</span><span class="s3">60</span><span class="s0">, </span><span class="s1">**kwargs</span>
<span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot;Visualize the results of profiling in a bokeh plot. 
 
    Parameters 
    ---------- 
    results : sequence 
        Output of Profiler.results 
    dsk : dict 
        The dask graph being profiled. 
    start_time : float 
        Start time of the profile in seconds 
    end_time : float 
        End time of the profile in seconds 
    palette : string, optional 
        Name of the bokeh palette to use, must be a member of 
        bokeh.palettes.all_palettes. 
    label_size: int (optional) 
        Maximum size of output labels in plot, defaults to 60 
    **kwargs 
        Other keyword arguments, passed to bokeh.figure. These will override 
        all defaults set by visualize. 
 
    Returns 
    ------- 
    The completed bokeh plot object. 
    &quot;&quot;&quot;</span>
    <span class="s1">bp = import_required(</span><span class="s2">&quot;bokeh.plotting&quot;</span><span class="s0">, </span><span class="s1">_BOKEH_MISSING_MSG)</span>
    <span class="s0">from </span><span class="s1">bokeh.models </span><span class="s0">import </span><span class="s1">HoverTool</span>

    <span class="s1">defaults = dict(</span>
        <span class="s1">title=</span><span class="s2">&quot;Profile Results&quot;</span><span class="s0">,</span>
        <span class="s1">tools=</span><span class="s2">&quot;hover,save,reset,xwheel_zoom,xpan&quot;</span><span class="s0">,</span>
        <span class="s1">toolbar_location=</span><span class="s2">&quot;above&quot;</span><span class="s0">,</span>
        <span class="s1">width=</span><span class="s3">800</span><span class="s0">,</span>
        <span class="s1">height=</span><span class="s3">300</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s5"># Support plot_width and plot_height for backwards compatibility</span>
    <span class="s0">if </span><span class="s2">&quot;plot_width&quot; </span><span class="s0">in </span><span class="s1">kwargs:</span>
        <span class="s1">kwargs[</span><span class="s2">&quot;width&quot;</span><span class="s1">] = kwargs.pop(</span><span class="s2">&quot;plot_width&quot;</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s2">&quot;plot_height&quot; </span><span class="s0">in </span><span class="s1">kwargs:</span>
        <span class="s1">kwargs[</span><span class="s2">&quot;height&quot;</span><span class="s1">] = kwargs.pop(</span><span class="s2">&quot;plot_height&quot;</span><span class="s1">)</span>
    <span class="s1">defaults.update(**kwargs)</span>

    <span class="s0">if </span><span class="s1">results:</span>
        <span class="s1">keys</span><span class="s0">, </span><span class="s1">tasks</span><span class="s0">, </span><span class="s1">starts</span><span class="s0">, </span><span class="s1">ends</span><span class="s0">, </span><span class="s1">ids = zip(*results)</span>

        <span class="s1">id_group = groupby(itemgetter(</span><span class="s3">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">results)</span>
        <span class="s1">timings = {</span>
            <span class="s1">k: [i.end_time - i.start_time </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">v] </span><span class="s0">for </span><span class="s1">(k</span><span class="s0">, </span><span class="s1">v) </span><span class="s0">in </span><span class="s1">id_group.items()</span>
        <span class="s1">}</span>
        <span class="s1">id_lk = {</span>
            <span class="s1">t[</span><span class="s3">0</span><span class="s1">]: n</span>
            <span class="s0">for </span><span class="s1">(n</span><span class="s0">, </span><span class="s1">t) </span><span class="s0">in </span><span class="s1">enumerate(</span>
                <span class="s1">sorted(timings.items()</span><span class="s0">, </span><span class="s1">key=itemgetter(</span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">reverse=</span><span class="s0">True</span><span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s1">}</span>

        <span class="s1">p = bp.figure(</span>
            <span class="s1">y_range=[str(i) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(id_lk))]</span><span class="s0">,</span>
            <span class="s1">x_range=[</span><span class="s3">0</span><span class="s0">, </span><span class="s1">end_time - start_time]</span><span class="s0">,</span>
            <span class="s1">**defaults</span><span class="s0">,</span>
        <span class="s1">)</span>

        <span class="s1">data = {}</span>
        <span class="s1">data[</span><span class="s2">&quot;width&quot;</span><span class="s1">] = width = [e - s </span><span class="s0">for </span><span class="s1">(s</span><span class="s0">, </span><span class="s1">e) </span><span class="s0">in </span><span class="s1">zip(starts</span><span class="s0">, </span><span class="s1">ends)]</span>
        <span class="s1">data[</span><span class="s2">&quot;x&quot;</span><span class="s1">] = [w / </span><span class="s3">2 </span><span class="s1">+ s - start_time </span><span class="s0">for </span><span class="s1">(w</span><span class="s0">, </span><span class="s1">s) </span><span class="s0">in </span><span class="s1">zip(width</span><span class="s0">, </span><span class="s1">starts)]</span>
        <span class="s1">data[</span><span class="s2">&quot;y&quot;</span><span class="s1">] = [id_lk[i] + </span><span class="s3">1 </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">ids]</span>
        <span class="s1">data[</span><span class="s2">&quot;function&quot;</span><span class="s1">] = funcs = [pprint_task(i</span><span class="s0">, </span><span class="s1">dsk</span><span class="s0">, </span><span class="s1">label_size) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">tasks]</span>
        <span class="s1">data[</span><span class="s2">&quot;color&quot;</span><span class="s1">] = get_colors(palette</span><span class="s0">, </span><span class="s1">funcs)</span>
        <span class="s1">data[</span><span class="s2">&quot;key&quot;</span><span class="s1">] = [str(i) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">keys]</span>

        <span class="s1">source = bp.ColumnDataSource(data=data)</span>

        <span class="s1">p.rect(</span>
            <span class="s1">source=source</span><span class="s0">,</span>
            <span class="s1">x=</span><span class="s2">&quot;x&quot;</span><span class="s0">,</span>
            <span class="s1">y=</span><span class="s2">&quot;y&quot;</span><span class="s0">,</span>
            <span class="s1">height=</span><span class="s3">1</span><span class="s0">,</span>
            <span class="s1">width=</span><span class="s2">&quot;width&quot;</span><span class="s0">,</span>
            <span class="s1">color=</span><span class="s2">&quot;color&quot;</span><span class="s0">,</span>
            <span class="s1">line_color=</span><span class="s2">&quot;gray&quot;</span><span class="s0">,</span>
        <span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">p = bp.figure(y_range=[str(i) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(</span><span class="s3">8</span><span class="s1">)]</span><span class="s0">, </span><span class="s1">x_range=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">10</span><span class="s1">]</span><span class="s0">, </span><span class="s1">**defaults)</span>
    <span class="s1">p.grid.grid_line_color = </span><span class="s0">None</span>
    <span class="s1">p.axis.axis_line_color = </span><span class="s0">None</span>
    <span class="s1">p.axis.major_tick_line_color = </span><span class="s0">None</span>
    <span class="s1">p.yaxis.axis_label = </span><span class="s2">&quot;Worker ID&quot;</span>
    <span class="s1">p.xaxis.axis_label = </span><span class="s2">&quot;Time (s)&quot;</span>

    <span class="s1">hover = p.select(HoverTool)</span>
    <span class="s1">hover.tooltips = </span><span class="s2">&quot;&quot;&quot; 
    &lt;div&gt; 
        &lt;span style=&quot;font-size: 14px; font-weight: bold;&quot;&gt;Key:&lt;/span&gt;&amp;nbsp; 
        &lt;span style=&quot;font-size: 10px; font-family: Monaco, monospace;&quot;&gt;@key&lt;/span&gt; 
    &lt;/div&gt; 
    &lt;div&gt; 
        &lt;span style=&quot;font-size: 14px; font-weight: bold;&quot;&gt;Task:&lt;/span&gt;&amp;nbsp; 
        &lt;span style=&quot;font-size: 10px; font-family: Monaco, monospace;&quot;&gt;@function&lt;/span&gt; 
    &lt;/div&gt; 
    &quot;&quot;&quot;</span>
    <span class="s1">hover.point_policy = </span><span class="s2">&quot;follow_mouse&quot;</span>

    <span class="s0">return </span><span class="s1">p</span>


<span class="s0">def </span><span class="s1">plot_resources(results</span><span class="s0">, </span><span class="s1">start_time</span><span class="s0">, </span><span class="s1">end_time</span><span class="s0">, </span><span class="s1">palette=</span><span class="s2">&quot;Viridis&quot;</span><span class="s0">, </span><span class="s1">**kwargs):</span>
    <span class="s4">&quot;&quot;&quot;Plot resource usage in a bokeh plot. 
 
    Parameters 
    ---------- 
    results : sequence 
        Output of ResourceProfiler.results 
    start_time : float 
        Start time of the profile in seconds 
    end_time : float 
        End time of the profile in seconds 
    palette : string, optional 
        Name of the bokeh palette to use, must be a member of 
        bokeh.palettes.all_palettes. 
    **kwargs 
        Other keyword arguments, passed to bokeh.figure. These will override 
        all defaults set by plot_resources. 
 
    Returns 
    ------- 
    The completed bokeh plot object. 
    &quot;&quot;&quot;</span>
    <span class="s1">bp = import_required(</span><span class="s2">&quot;bokeh.plotting&quot;</span><span class="s0">, </span><span class="s1">_BOKEH_MISSING_MSG)</span>
    <span class="s0">from </span><span class="s1">bokeh </span><span class="s0">import </span><span class="s1">palettes</span>
    <span class="s0">from </span><span class="s1">bokeh.models </span><span class="s0">import </span><span class="s1">LinearAxis</span><span class="s0">, </span><span class="s1">Range1d</span>

    <span class="s1">defaults = dict(</span>
        <span class="s1">title=</span><span class="s2">&quot;Profile Results&quot;</span><span class="s0">,</span>
        <span class="s1">tools=</span><span class="s2">&quot;save,reset,xwheel_zoom,xpan&quot;</span><span class="s0">,</span>
        <span class="s1">toolbar_location=</span><span class="s2">&quot;above&quot;</span><span class="s0">,</span>
        <span class="s1">width=</span><span class="s3">800</span><span class="s0">,</span>
        <span class="s1">height=</span><span class="s3">300</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s5"># Support plot_width and plot_height for backwards compatibility</span>
    <span class="s0">if </span><span class="s2">&quot;plot_width&quot; </span><span class="s0">in </span><span class="s1">kwargs:</span>
        <span class="s1">kwargs[</span><span class="s2">&quot;width&quot;</span><span class="s1">] = kwargs.pop(</span><span class="s2">&quot;plot_width&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">BOKEH_VERSION().major &gt;= </span><span class="s3">3</span><span class="s1">:</span>
            <span class="s1">warnings.warn(</span><span class="s2">&quot;Use width instead of plot_width with Bokeh &gt;= 3&quot;</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s2">&quot;plot_height&quot; </span><span class="s0">in </span><span class="s1">kwargs:</span>
        <span class="s1">kwargs[</span><span class="s2">&quot;height&quot;</span><span class="s1">] = kwargs.pop(</span><span class="s2">&quot;plot_height&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">BOKEH_VERSION().major &gt;= </span><span class="s3">3</span><span class="s1">:</span>
            <span class="s1">warnings.warn(</span><span class="s2">&quot;Use height instead of plot_height with Bokeh &gt;= 3&quot;</span><span class="s1">)</span>

    <span class="s5"># Drop `label_size` to match `plot_cache` and `plot_tasks` kwargs</span>
    <span class="s0">if </span><span class="s2">&quot;label_size&quot; </span><span class="s0">in </span><span class="s1">kwargs:</span>
        <span class="s1">kwargs.pop(</span><span class="s2">&quot;label_size&quot;</span><span class="s1">)</span>

    <span class="s1">defaults.update(**kwargs)</span>

    <span class="s0">if </span><span class="s1">results:</span>
        <span class="s1">t</span><span class="s0">, </span><span class="s1">mem</span><span class="s0">, </span><span class="s1">cpu = zip(*results)</span>
        <span class="s1">left = start_time</span>
        <span class="s1">right = end_time</span>
        <span class="s1">t = [i - left </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">t]</span>
        <span class="s1">p = bp.figure(</span>
            <span class="s1">y_range=fix_bounds(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">max(cpu)</span><span class="s0">, </span><span class="s3">100</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">x_range=fix_bounds(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">right - left</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">**defaults</span><span class="s0">,</span>
        <span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">t = mem = cpu = []</span>
        <span class="s1">p = bp.figure(y_range=(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">x_range=(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">**defaults)</span>
    <span class="s1">colors = palettes.all_palettes[palette][</span><span class="s3">6</span><span class="s1">]</span>
    <span class="s1">p.line(</span>
        <span class="s1">t</span><span class="s0">,</span>
        <span class="s1">cpu</span><span class="s0">,</span>
        <span class="s1">color=colors[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">line_width=</span><span class="s3">4</span><span class="s0">,</span>
        <span class="s1">legend_label=</span><span class="s2">&quot;% CPU&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">p.yaxis.axis_label = </span><span class="s2">&quot;% CPU&quot;</span>
    <span class="s1">p.extra_y_ranges = {</span>
        <span class="s2">&quot;memory&quot;</span><span class="s1">: Range1d(</span>
            <span class="s1">*fix_bounds(min(mem) </span><span class="s0">if </span><span class="s1">mem </span><span class="s0">else </span><span class="s3">0</span><span class="s0">, </span><span class="s1">max(mem) </span><span class="s0">if </span><span class="s1">mem </span><span class="s0">else </span><span class="s3">100</span><span class="s0">, </span><span class="s3">100</span><span class="s1">)</span>
        <span class="s1">)</span>
    <span class="s1">}</span>
    <span class="s1">p.line(</span>
        <span class="s1">t</span><span class="s0">,</span>
        <span class="s1">mem</span><span class="s0">,</span>
        <span class="s1">color=colors[</span><span class="s3">2</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">y_range_name=</span><span class="s2">&quot;memory&quot;</span><span class="s0">,</span>
        <span class="s1">line_width=</span><span class="s3">4</span><span class="s0">,</span>
        <span class="s1">legend_label=</span><span class="s2">&quot;Memory&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">p.add_layout(LinearAxis(y_range_name=</span><span class="s2">&quot;memory&quot;</span><span class="s0">, </span><span class="s1">axis_label=</span><span class="s2">&quot;Memory (MB)&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s2">&quot;right&quot;</span><span class="s1">)</span>
    <span class="s1">p.xaxis.axis_label = </span><span class="s2">&quot;Time (s)&quot;</span>
    <span class="s0">return </span><span class="s1">p</span>


<span class="s0">def </span><span class="s1">fix_bounds(start</span><span class="s0">, </span><span class="s1">end</span><span class="s0">, </span><span class="s1">min_span):</span>
    <span class="s4">&quot;&quot;&quot;Adjust end point to ensure span of at least `min_span`&quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">start</span><span class="s0">, </span><span class="s1">max(end</span><span class="s0">, </span><span class="s1">start + min_span)</span>


<span class="s0">def </span><span class="s1">plot_cache(</span>
    <span class="s1">results</span><span class="s0">,</span>
    <span class="s1">dsk</span><span class="s0">,</span>
    <span class="s1">start_time</span><span class="s0">,</span>
    <span class="s1">end_time</span><span class="s0">,</span>
    <span class="s1">metric_name</span><span class="s0">,</span>
    <span class="s1">palette=</span><span class="s2">&quot;Viridis&quot;</span><span class="s0">,</span>
    <span class="s1">label_size=</span><span class="s3">60</span><span class="s0">,</span>
    <span class="s1">**kwargs</span><span class="s0">,</span>
<span class="s1">):</span>
    <span class="s4">&quot;&quot;&quot;Visualize the results of profiling in a bokeh plot. 
 
    Parameters 
    ---------- 
    results : sequence 
        Output of CacheProfiler.results 
    dsk : dict 
        The dask graph being profiled. 
    start_time : float 
        Start time of the profile in seconds 
    end_time : float 
        End time of the profile in seconds 
    metric_name : string 
        Metric used to measure cache size 
    palette : string, optional 
        Name of the bokeh palette to use, must be a member of 
        bokeh.palettes.all_palettes. 
    label_size: int (optional) 
        Maximum size of output labels in plot, defaults to 60 
    **kwargs 
        Other keyword arguments, passed to bokeh.figure. These will override 
        all defaults set by visualize. 
 
    Returns 
    ------- 
    The completed bokeh plot object. 
    &quot;&quot;&quot;</span>
    <span class="s1">bp = import_required(</span><span class="s2">&quot;bokeh.plotting&quot;</span><span class="s0">, </span><span class="s1">_BOKEH_MISSING_MSG)</span>
    <span class="s0">from </span><span class="s1">bokeh.models </span><span class="s0">import </span><span class="s1">HoverTool</span>

    <span class="s1">defaults = dict(</span>
        <span class="s1">title=</span><span class="s2">&quot;Profile Results&quot;</span><span class="s0">,</span>
        <span class="s1">tools=</span><span class="s2">&quot;hover,save,reset,wheel_zoom,xpan&quot;</span><span class="s0">,</span>
        <span class="s1">toolbar_location=</span><span class="s2">&quot;above&quot;</span><span class="s0">,</span>
        <span class="s1">width=</span><span class="s3">800</span><span class="s0">,</span>
        <span class="s1">height=</span><span class="s3">300</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s5"># Support plot_width and plot_height for backwards compatibility</span>
    <span class="s0">if </span><span class="s2">&quot;plot_width&quot; </span><span class="s0">in </span><span class="s1">kwargs:</span>
        <span class="s1">kwargs[</span><span class="s2">&quot;width&quot;</span><span class="s1">] = kwargs.pop(</span><span class="s2">&quot;plot_width&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">BOKEH_VERSION().major &gt;= </span><span class="s3">3</span><span class="s1">:</span>
            <span class="s1">warnings.warn(</span><span class="s2">&quot;Use width instead of plot_width with Bokeh &gt;= 3&quot;</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s2">&quot;plot_height&quot; </span><span class="s0">in </span><span class="s1">kwargs:</span>
        <span class="s1">kwargs[</span><span class="s2">&quot;height&quot;</span><span class="s1">] = kwargs.pop(</span><span class="s2">&quot;plot_height&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">BOKEH_VERSION().major &gt;= </span><span class="s3">3</span><span class="s1">:</span>
            <span class="s1">warnings.warn(</span><span class="s2">&quot;Use height instead of plot_height with Bokeh &gt;= 3&quot;</span><span class="s1">)</span>
    <span class="s1">defaults.update(**kwargs)</span>

    <span class="s0">if </span><span class="s1">results:</span>
        <span class="s1">starts</span><span class="s0">, </span><span class="s1">ends = list(zip(*results))[</span><span class="s3">3</span><span class="s1">:]</span>
        <span class="s1">tics = sorted(unique(starts + ends))</span>
        <span class="s1">groups = groupby(</span><span class="s0">lambda </span><span class="s1">d: pprint_task(d[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dsk</span><span class="s0">, </span><span class="s1">label_size)</span><span class="s0">, </span><span class="s1">results)</span>
        <span class="s1">data = {}</span>
        <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">vals </span><span class="s0">in </span><span class="s1">groups.items():</span>
            <span class="s1">cnts = dict.fromkeys(tics</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>
            <span class="s0">for </span><span class="s1">v </span><span class="s0">in </span><span class="s1">vals:</span>
                <span class="s1">cnts[v.cache_time] += v.metric</span>
                <span class="s1">cnts[v.free_time] -= v.metric</span>
            <span class="s1">data[k] = [</span><span class="s3">0</span><span class="s1">] + list(accumulate(add</span><span class="s0">, </span><span class="s1">pluck(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">sorted(cnts.items()))))</span>

        <span class="s1">tics = [</span><span class="s3">0</span><span class="s1">] + [i - start_time </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">tics]</span>
        <span class="s1">p = bp.figure(x_range=[</span><span class="s3">0</span><span class="s0">, </span><span class="s1">end_time - start_time]</span><span class="s0">, </span><span class="s1">**defaults)</span>

        <span class="s0">for </span><span class="s1">(key</span><span class="s0">, </span><span class="s1">val)</span><span class="s0">, </span><span class="s1">color </span><span class="s0">in </span><span class="s1">zip(data.items()</span><span class="s0">, </span><span class="s1">get_colors(palette</span><span class="s0">, </span><span class="s1">data.keys())):</span>
            <span class="s1">p.line(</span>
                <span class="s2">&quot;x&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;y&quot;</span><span class="s0">,</span>
                <span class="s1">line_color=color</span><span class="s0">,</span>
                <span class="s1">line_width=</span><span class="s3">3</span><span class="s0">,</span>
                <span class="s1">source=bp.ColumnDataSource(</span>
                    <span class="s1">{</span><span class="s2">&quot;x&quot;</span><span class="s1">: tics</span><span class="s0">, </span><span class="s2">&quot;y&quot;</span><span class="s1">: val</span><span class="s0">, </span><span class="s2">&quot;label&quot;</span><span class="s1">: [key </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">val]}</span>
                <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">)</span>

    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">p = bp.figure(y_range=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">10</span><span class="s1">]</span><span class="s0">, </span><span class="s1">x_range=[</span><span class="s3">0</span><span class="s0">, </span><span class="s3">10</span><span class="s1">]</span><span class="s0">, </span><span class="s1">**defaults)</span>
    <span class="s1">p.yaxis.axis_label = </span><span class="s2">f&quot;Cache Size (</span><span class="s0">{</span><span class="s1">metric_name</span><span class="s0">}</span><span class="s2">)&quot;</span>
    <span class="s1">p.xaxis.axis_label = </span><span class="s2">&quot;Time (s)&quot;</span>

    <span class="s1">hover = p.select(HoverTool)</span>
    <span class="s1">hover.tooltips = </span><span class="s2">&quot;&quot;&quot; 
    &lt;div&gt; 
        &lt;span style=&quot;font-size: 14px; font-weight: bold;&quot;&gt;Task:&lt;/span&gt;&amp;nbsp; 
        &lt;span style=&quot;font-size: 10px; font-family: Monaco, monospace;&quot;&gt;@label&lt;/span&gt; 
    &lt;/div&gt; 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">p</span>
</pre>
</body>
</html>