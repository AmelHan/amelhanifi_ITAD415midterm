<html>
<head>
<title>discrete_margins.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
discrete_margins.py</font>
</center></td></tr></table>
<pre><span class="s0">#Splitting out maringal effects to see if they can be generalized</span>

<span class="s2">from </span><span class="s1">statsmodels.compat.python </span><span class="s2">import </span><span class="s1">lzip</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">scipy.stats </span><span class="s2">import </span><span class="s1">norm</span>
<span class="s2">from </span><span class="s1">statsmodels.tools.decorators </span><span class="s2">import </span><span class="s1">cache_readonly</span>

<span class="s0">#### margeff helper functions ####</span>
<span class="s0">#NOTE: todo marginal effects for group 2</span>
<span class="s0"># group 2 oprobit, ologit, gologit, mlogit, biprobit</span>

<span class="s2">def </span><span class="s1">_check_margeff_args(at</span><span class="s2">, </span><span class="s1">method):</span>
    <span class="s3">&quot;&quot;&quot; 
    Checks valid options for margeff 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">at </span><span class="s2">not in </span><span class="s1">[</span><span class="s4">'overall'</span><span class="s2">,</span><span class="s4">'mean'</span><span class="s2">,</span><span class="s4">'median'</span><span class="s2">,</span><span class="s4">'zero'</span><span class="s2">,</span><span class="s4">'all'</span><span class="s1">]:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;%s not a valid option for `at`.&quot; </span><span class="s1">% at)</span>
    <span class="s2">if </span><span class="s1">method </span><span class="s2">not in </span><span class="s1">[</span><span class="s4">'dydx'</span><span class="s2">,</span><span class="s4">'eyex'</span><span class="s2">,</span><span class="s4">'dyex'</span><span class="s2">,</span><span class="s4">'eydx'</span><span class="s1">]:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;method is not understood.  Got %s&quot; </span><span class="s1">% method)</span>

<span class="s2">def </span><span class="s1">_check_discrete_args(at</span><span class="s2">, </span><span class="s1">method):</span>
    <span class="s3">&quot;&quot;&quot; 
    Checks the arguments for margeff if the exogenous variables are discrete. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">method </span><span class="s2">in </span><span class="s1">[</span><span class="s4">'dyex'</span><span class="s2">,</span><span class="s4">'eyex'</span><span class="s1">]:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;%s not allowed for discrete variables&quot; </span><span class="s1">% method)</span>
    <span class="s2">if </span><span class="s1">at </span><span class="s2">in </span><span class="s1">[</span><span class="s4">'median'</span><span class="s2">, </span><span class="s4">'zero'</span><span class="s1">]:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;%s not allowed for discrete variables&quot; </span><span class="s1">% at)</span>

<span class="s2">def </span><span class="s1">_get_const_index(exog):</span>
    <span class="s3">&quot;&quot;&quot; 
    Returns a boolean array of non-constant column indices in exog and 
    an scalar array of where the constant is or None 
    &quot;&quot;&quot;</span>
    <span class="s1">effects_idx = exog.var(</span><span class="s5">0</span><span class="s1">) != </span><span class="s5">0</span>
    <span class="s2">if </span><span class="s1">np.any(~effects_idx):</span>
        <span class="s1">const_idx = np.where(~effects_idx)[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">const_idx = </span><span class="s2">None</span>
    <span class="s2">return </span><span class="s1">effects_idx</span><span class="s2">, </span><span class="s1">const_idx</span>

<span class="s2">def </span><span class="s1">_isdummy(X):</span>
    <span class="s3">&quot;&quot;&quot; 
    Given an array X, returns the column indices for the dummy variables. 
 
    Parameters 
    ---------- 
    X : array_like 
        A 1d or 2d array of numbers 
 
    Examples 
    -------- 
    &gt;&gt;&gt; X = np.random.randint(0, 2, size=(15,5)).astype(float) 
    &gt;&gt;&gt; X[:,1:3] = np.random.randn(15,2) 
    &gt;&gt;&gt; ind = _isdummy(X) 
    &gt;&gt;&gt; ind 
    array([0, 3, 4]) 
    &quot;&quot;&quot;</span>
    <span class="s1">X = np.asarray(X)</span>
    <span class="s2">if </span><span class="s1">X.ndim &gt; </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">ind = np.zeros(X.shape[</span><span class="s5">1</span><span class="s1">]).astype(bool)</span>
    <span class="s1">max = (np.max(X</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">) == </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">min = (np.min(X</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">) == </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">remainder = np.all(X % </span><span class="s5">1. </span><span class="s1">== </span><span class="s5">0</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">ind = min &amp; max &amp; remainder</span>
    <span class="s2">if </span><span class="s1">X.ndim == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">ind = np.asarray([ind])</span>
    <span class="s2">return </span><span class="s1">np.where(ind)[</span><span class="s5">0</span><span class="s1">]</span>

<span class="s2">def </span><span class="s1">_get_dummy_index(X</span><span class="s2">, </span><span class="s1">const_idx):</span>
    <span class="s1">dummy_ind = _isdummy(X)</span>
    <span class="s1">dummy = </span><span class="s2">True</span>

    <span class="s2">if </span><span class="s1">dummy_ind.size == </span><span class="s5">0</span><span class="s1">: </span><span class="s0"># do not waste your time</span>
        <span class="s1">dummy = </span><span class="s2">False</span>
        <span class="s1">dummy_ind = </span><span class="s2">None </span><span class="s0"># this gets passed to stand err func</span>
    <span class="s2">return </span><span class="s1">dummy_ind</span><span class="s2">, </span><span class="s1">dummy</span>

<span class="s2">def </span><span class="s1">_iscount(X):</span>
    <span class="s3">&quot;&quot;&quot; 
    Given an array X, returns the column indices for count variables. 
 
    Parameters 
    ---------- 
    X : array_like 
        A 1d or 2d array of numbers 
 
    Examples 
    -------- 
    &gt;&gt;&gt; X = np.random.randint(0, 10, size=(15,5)).astype(float) 
    &gt;&gt;&gt; X[:,1:3] = np.random.randn(15,2) 
    &gt;&gt;&gt; ind = _iscount(X) 
    &gt;&gt;&gt; ind 
    array([0, 3, 4]) 
    &quot;&quot;&quot;</span>
    <span class="s1">X = np.asarray(X)</span>
    <span class="s1">remainder = np.logical_and(np.logical_and(np.all(X % </span><span class="s5">1. </span><span class="s1">== </span><span class="s5">0</span><span class="s2">, </span><span class="s1">axis = </span><span class="s5">0</span><span class="s1">)</span><span class="s2">,</span>
                               <span class="s1">X.var(</span><span class="s5">0</span><span class="s1">) != </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.all(X &gt;= </span><span class="s5">0</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">))</span>
    <span class="s1">dummy = _isdummy(X)</span>
    <span class="s1">remainder = np.where(remainder)[</span><span class="s5">0</span><span class="s1">].tolist()</span>
    <span class="s2">for </span><span class="s1">idx </span><span class="s2">in </span><span class="s1">dummy:</span>
        <span class="s1">remainder.remove(idx)</span>
    <span class="s2">return </span><span class="s1">np.array(remainder)</span>

<span class="s2">def </span><span class="s1">_get_count_index(X</span><span class="s2">, </span><span class="s1">const_idx):</span>
    <span class="s1">count_ind = _iscount(X)</span>
    <span class="s1">count = </span><span class="s2">True</span>

    <span class="s2">if </span><span class="s1">count_ind.size == </span><span class="s5">0</span><span class="s1">: </span><span class="s0"># do not waste your time</span>
        <span class="s1">count = </span><span class="s2">False</span>
        <span class="s1">count_ind = </span><span class="s2">None </span><span class="s0"># for stand err func</span>
    <span class="s2">return </span><span class="s1">count_ind</span><span class="s2">, </span><span class="s1">count</span>

<span class="s2">def </span><span class="s1">_get_margeff_exog(exog</span><span class="s2">, </span><span class="s1">at</span><span class="s2">, </span><span class="s1">atexog</span><span class="s2">, </span><span class="s1">ind):</span>
    <span class="s2">if </span><span class="s1">atexog </span><span class="s2">is not None</span><span class="s1">: </span><span class="s0"># user supplied</span>
        <span class="s2">if </span><span class="s1">isinstance(atexog</span><span class="s2">, </span><span class="s1">dict):</span>
            <span class="s0"># assumes values are singular or of len(exog)</span>
            <span class="s2">for </span><span class="s1">key </span><span class="s2">in </span><span class="s1">atexog:</span>
                <span class="s1">exog[:</span><span class="s2">,</span><span class="s1">key] = atexog[key]</span>
        <span class="s2">elif </span><span class="s1">isinstance(atexog</span><span class="s2">, </span><span class="s1">np.ndarray): </span><span class="s0">#TODO: handle DataFrames</span>
            <span class="s2">if </span><span class="s1">atexog.ndim == </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">k_vars = len(atexog)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">k_vars = atexog.shape[</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s2">assert </span><span class="s1">k_vars == exog.shape[</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s2">except</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;atexog does not have the same number &quot;</span>
                        <span class="s4">&quot;of variables as exog&quot;</span><span class="s1">)</span>
            <span class="s1">exog = atexog</span>

    <span class="s0">#NOTE: we should fill in atexog after we process at</span>
    <span class="s2">if </span><span class="s1">at == </span><span class="s4">'mean'</span><span class="s1">:</span>
        <span class="s1">exog = np.atleast_2d(exog.mean(</span><span class="s5">0</span><span class="s1">))</span>
    <span class="s2">elif </span><span class="s1">at == </span><span class="s4">'median'</span><span class="s1">:</span>
        <span class="s1">exog = np.atleast_2d(np.median(exog</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">))</span>
    <span class="s2">elif </span><span class="s1">at == </span><span class="s4">'zero'</span><span class="s1">:</span>
        <span class="s1">exog = np.zeros((</span><span class="s5">1</span><span class="s2">,</span><span class="s1">exog.shape[</span><span class="s5">1</span><span class="s1">]))</span>
        <span class="s1">exog[</span><span class="s5">0</span><span class="s2">,</span><span class="s1">~ind] = </span><span class="s5">1</span>
    <span class="s2">return </span><span class="s1">exog</span>

<span class="s2">def </span><span class="s1">_get_count_effects(effects</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">count_ind</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">model</span><span class="s2">, </span><span class="s1">params):</span>
    <span class="s3">&quot;&quot;&quot; 
    If there's a count variable, the predicted difference is taken by 
    subtracting one and adding one to exog then averaging the difference 
    &quot;&quot;&quot;</span>
    <span class="s0"># this is the index for the effect and the index for count col in exog</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">count_ind:</span>
        <span class="s1">exog0 = exog.copy()</span>
        <span class="s1">exog0[:</span><span class="s2">, </span><span class="s1">i] -= </span><span class="s5">1</span>
        <span class="s1">effect0 = model.predict(params</span><span class="s2">, </span><span class="s1">exog0)</span>
        <span class="s1">exog0[:</span><span class="s2">, </span><span class="s1">i] += </span><span class="s5">2</span>
        <span class="s1">effect1 = model.predict(params</span><span class="s2">, </span><span class="s1">exog0)</span>
        <span class="s0">#NOTE: done by analogy with dummy effects but untested bc</span>
        <span class="s0"># stata does not handle both count and eydx anywhere</span>
        <span class="s2">if </span><span class="s4">'ey' </span><span class="s2">in </span><span class="s1">method:</span>
            <span class="s1">effect0 = np.log(effect0)</span>
            <span class="s1">effect1 = np.log(effect1)</span>
        <span class="s1">effects[:</span><span class="s2">, </span><span class="s1">i] = ((effect1 - effect0)/</span><span class="s5">2</span><span class="s1">)</span>
    <span class="s2">return </span><span class="s1">effects</span>

<span class="s2">def </span><span class="s1">_get_dummy_effects(effects</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">dummy_ind</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">model</span><span class="s2">, </span><span class="s1">params):</span>
    <span class="s3">&quot;&quot;&quot; 
    If there's a dummy variable, the predicted difference is taken at 
    0 and 1 
    &quot;&quot;&quot;</span>
    <span class="s0"># this is the index for the effect and the index for dummy col in exog</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">dummy_ind:</span>
        <span class="s1">exog0 = exog.copy() </span><span class="s0"># only copy once, can we avoid a copy?</span>
        <span class="s1">exog0[:</span><span class="s2">,</span><span class="s1">i] = </span><span class="s5">0</span>
        <span class="s1">effect0 = model.predict(params</span><span class="s2">, </span><span class="s1">exog0)</span>
        <span class="s0">#fittedvalues0 = np.dot(exog0,params)</span>
        <span class="s1">exog0[:</span><span class="s2">,</span><span class="s1">i] = </span><span class="s5">1</span>
        <span class="s1">effect1 = model.predict(params</span><span class="s2">, </span><span class="s1">exog0)</span>
        <span class="s2">if </span><span class="s4">'ey' </span><span class="s2">in </span><span class="s1">method:</span>
            <span class="s1">effect0 = np.log(effect0)</span>
            <span class="s1">effect1 = np.log(effect1)</span>
        <span class="s1">effects[:</span><span class="s2">, </span><span class="s1">i] = (effect1 - effect0)</span>
    <span class="s2">return </span><span class="s1">effects</span>

<span class="s2">def </span><span class="s1">_effects_at(effects</span><span class="s2">, </span><span class="s1">at):</span>
    <span class="s2">if </span><span class="s1">at == </span><span class="s4">'all'</span><span class="s1">:</span>
        <span class="s1">effects = effects</span>
    <span class="s2">elif </span><span class="s1">at == </span><span class="s4">'overall'</span><span class="s1">:</span>
        <span class="s1">effects = effects.mean(</span><span class="s5">0</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">effects = effects[</span><span class="s5">0</span><span class="s2">,</span><span class="s1">:]</span>
    <span class="s2">return </span><span class="s1">effects</span>

<span class="s2">def </span><span class="s1">_margeff_cov_params_dummy(model</span><span class="s2">, </span><span class="s1">cov_margins</span><span class="s2">, </span><span class="s1">params</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">dummy_ind</span><span class="s2">,</span>
        <span class="s1">method</span><span class="s2">, </span><span class="s1">J):</span>
    <span class="s3">r&quot;&quot;&quot; 
    Returns the Jacobian for discrete regressors for use in margeff_cov_params. 
 
    For discrete regressors the marginal effect is 
 
    \Delta F = F(XB) | d = 1 - F(XB) | d = 0 
 
    The row of the Jacobian for this variable is given by 
 
    f(XB)*X | d = 1 - f(XB)*X | d = 0 
 
    Where F is the default prediction of the model. 
    &quot;&quot;&quot;</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">dummy_ind:</span>
        <span class="s1">exog0 = exog.copy()</span>
        <span class="s1">exog1 = exog.copy()</span>
        <span class="s1">exog0[:</span><span class="s2">,</span><span class="s1">i] = </span><span class="s5">0</span>
        <span class="s1">exog1[:</span><span class="s2">,</span><span class="s1">i] = </span><span class="s5">1</span>
        <span class="s1">dfdb0 = model._derivative_predict(params</span><span class="s2">, </span><span class="s1">exog0</span><span class="s2">, </span><span class="s1">method)</span>
        <span class="s1">dfdb1 = model._derivative_predict(params</span><span class="s2">, </span><span class="s1">exog1</span><span class="s2">, </span><span class="s1">method)</span>
        <span class="s1">dfdb = (dfdb1 - dfdb0)</span>
        <span class="s2">if </span><span class="s1">dfdb.ndim &gt;= </span><span class="s5">2</span><span class="s1">: </span><span class="s0"># for overall</span>
            <span class="s1">dfdb = dfdb.mean(</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">J &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">K = dfdb.shape[</span><span class="s5">1</span><span class="s1">] // (J-</span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">cov_margins[i::K</span><span class="s2">, </span><span class="s1">:] = dfdb</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># dfdb could be too short if there are extra params, k_extra &gt; 0</span>
            <span class="s1">cov_margins[i</span><span class="s2">, </span><span class="s1">:len(dfdb)] = dfdb </span><span class="s0"># how each F changes with change in B</span>
    <span class="s2">return </span><span class="s1">cov_margins</span>

<span class="s2">def </span><span class="s1">_margeff_cov_params_count(model</span><span class="s2">, </span><span class="s1">cov_margins</span><span class="s2">, </span><span class="s1">params</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">count_ind</span><span class="s2">,</span>
                             <span class="s1">method</span><span class="s2">, </span><span class="s1">J):</span>
    <span class="s3">r&quot;&quot;&quot; 
    Returns the Jacobian for discrete regressors for use in margeff_cov_params. 
 
    For discrete regressors the marginal effect is 
 
    \Delta F = F(XB) | d += 1 - F(XB) | d -= 1 
 
    The row of the Jacobian for this variable is given by 
 
    (f(XB)*X | d += 1 - f(XB)*X | d -= 1) / 2 
 
    where F is the default prediction for the model. 
    &quot;&quot;&quot;</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">count_ind:</span>
        <span class="s1">exog0 = exog.copy()</span>
        <span class="s1">exog0[:</span><span class="s2">,</span><span class="s1">i] -= </span><span class="s5">1</span>
        <span class="s1">dfdb0 = model._derivative_predict(params</span><span class="s2">, </span><span class="s1">exog0</span><span class="s2">, </span><span class="s1">method)</span>
        <span class="s1">exog0[:</span><span class="s2">,</span><span class="s1">i] += </span><span class="s5">2</span>
        <span class="s1">dfdb1 = model._derivative_predict(params</span><span class="s2">, </span><span class="s1">exog0</span><span class="s2">, </span><span class="s1">method)</span>
        <span class="s1">dfdb = (dfdb1 - dfdb0)</span>
        <span class="s2">if </span><span class="s1">dfdb.ndim &gt;= </span><span class="s5">2</span><span class="s1">: </span><span class="s0"># for overall</span>
            <span class="s1">dfdb = dfdb.mean(</span><span class="s5">0</span><span class="s1">) / </span><span class="s5">2</span>
        <span class="s2">if </span><span class="s1">J &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">K = dfdb.shape[</span><span class="s5">1</span><span class="s1">] / (J-</span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">cov_margins[i::K</span><span class="s2">, </span><span class="s1">:] = dfdb</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># dfdb could be too short if there are extra params, k_extra &gt; 0</span>
            <span class="s1">cov_margins[i</span><span class="s2">, </span><span class="s1">:len(dfdb)] = dfdb </span><span class="s0"># how each F changes with change in B</span>
    <span class="s2">return </span><span class="s1">cov_margins</span>

<span class="s2">def </span><span class="s1">margeff_cov_params(model</span><span class="s2">, </span><span class="s1">params</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">cov_params</span><span class="s2">, </span><span class="s1">at</span><span class="s2">, </span><span class="s1">derivative</span><span class="s2">,</span>
                       <span class="s1">dummy_ind</span><span class="s2">, </span><span class="s1">count_ind</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">J):</span>
    <span class="s3">&quot;&quot;&quot; 
    Computes the variance-covariance of marginal effects by the delta method. 
 
    Parameters 
    ---------- 
    model : model instance 
        The model that returned the fitted results. Its pdf method is used 
        for computing the Jacobian of discrete variables in dummy_ind and 
        count_ind 
    params : array_like 
        estimated model parameters 
    exog : array_like 
        exogenous variables at which to calculate the derivative 
    cov_params : array_like 
        The variance-covariance of the parameters 
    at : str 
       Options are: 
 
        - 'overall', The average of the marginal effects at each 
          observation. 
        - 'mean', The marginal effects at the mean of each regressor. 
        - 'median', The marginal effects at the median of each regressor. 
        - 'zero', The marginal effects at zero for each regressor. 
        - 'all', The marginal effects at each observation. 
 
        Only overall has any effect here.you 
 
    derivative : function or array_like 
        If a function, it returns the marginal effects of the model with 
        respect to the exogenous variables evaluated at exog. Expected to be 
        called derivative(params, exog). This will be numerically 
        differentiated. Otherwise, it can be the Jacobian of the marginal 
        effects with respect to the parameters. 
    dummy_ind : array_like 
        Indices of the columns of exog that contain dummy variables 
    count_ind : array_like 
        Indices of the columns of exog that contain count variables 
 
    Notes 
    ----- 
    For continuous regressors, the variance-covariance is given by 
 
    Asy. Var[MargEff] = [d margeff / d params] V [d margeff / d params]' 
 
    where V is the parameter variance-covariance. 
 
    The outer Jacobians are computed via numerical differentiation if 
    derivative is a function. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">callable(derivative):</span>
        <span class="s2">from </span><span class="s1">statsmodels.tools.numdiff </span><span class="s2">import </span><span class="s1">approx_fprime_cs</span>
        <span class="s1">params = params.ravel(</span><span class="s4">'F'</span><span class="s1">)  </span><span class="s0"># for Multinomial</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">jacobian_mat = approx_fprime_cs(params</span><span class="s2">, </span><span class="s1">derivative</span><span class="s2">,</span>
                                            <span class="s1">args=(exog</span><span class="s2">,</span><span class="s1">method))</span>
        <span class="s2">except </span><span class="s1">TypeError:  </span><span class="s0"># norm.cdf does not take complex values</span>
            <span class="s2">from </span><span class="s1">statsmodels.tools.numdiff </span><span class="s2">import </span><span class="s1">approx_fprime</span>
            <span class="s1">jacobian_mat = approx_fprime(params</span><span class="s2">, </span><span class="s1">derivative</span><span class="s2">,</span>
                                            <span class="s1">args=(exog</span><span class="s2">,</span><span class="s1">method))</span>
        <span class="s2">if </span><span class="s1">at == </span><span class="s4">'overall'</span><span class="s1">:</span>
            <span class="s1">jacobian_mat = np.mean(jacobian_mat</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">jacobian_mat = jacobian_mat.squeeze()  </span><span class="s0"># exog was 2d row vector</span>
        <span class="s2">if </span><span class="s1">dummy_ind </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">jacobian_mat = _margeff_cov_params_dummy(model</span><span class="s2">, </span><span class="s1">jacobian_mat</span><span class="s2">,</span>
                                <span class="s1">params</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">dummy_ind</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">J)</span>
        <span class="s2">if </span><span class="s1">count_ind </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">jacobian_mat = _margeff_cov_params_count(model</span><span class="s2">, </span><span class="s1">jacobian_mat</span><span class="s2">,</span>
                                <span class="s1">params</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">count_ind</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">J)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">jacobian_mat = derivative</span>

    <span class="s0">#NOTE: this will not go through for at == 'all'</span>
    <span class="s2">return </span><span class="s1">np.dot(np.dot(jacobian_mat</span><span class="s2">, </span><span class="s1">cov_params)</span><span class="s2">, </span><span class="s1">jacobian_mat.T)</span>

<span class="s2">def </span><span class="s1">margeff_cov_with_se(model</span><span class="s2">, </span><span class="s1">params</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">cov_params</span><span class="s2">, </span><span class="s1">at</span><span class="s2">, </span><span class="s1">derivative</span><span class="s2">,</span>
                        <span class="s1">dummy_ind</span><span class="s2">, </span><span class="s1">count_ind</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">J):</span>
    <span class="s3">&quot;&quot;&quot; 
    See margeff_cov_params. 
 
    Same function but returns both the covariance of the marginal effects 
    and their standard errors. 
    &quot;&quot;&quot;</span>
    <span class="s1">cov_me = margeff_cov_params(model</span><span class="s2">, </span><span class="s1">params</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">cov_params</span><span class="s2">, </span><span class="s1">at</span><span class="s2">,</span>
                                              <span class="s1">derivative</span><span class="s2">, </span><span class="s1">dummy_ind</span><span class="s2">,</span>
                                              <span class="s1">count_ind</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">J)</span>
    <span class="s2">return </span><span class="s1">cov_me</span><span class="s2">, </span><span class="s1">np.sqrt(np.diag(cov_me))</span>


<span class="s2">def </span><span class="s1">margeff():</span>
    <span class="s2">raise </span><span class="s1">NotImplementedError</span>



<span class="s2">def </span><span class="s1">_check_at_is_all(method):</span>
    <span class="s2">if </span><span class="s1">method[</span><span class="s4">'at'</span><span class="s1">] == </span><span class="s4">'all'</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Only margeff are available when `at` is &quot;</span>
                         <span class="s4">&quot;'all'. Please input specific points if you would &quot;</span>
                         <span class="s4">&quot;like to do inference.&quot;</span><span class="s1">)</span>


<span class="s1">_transform_names = dict(dydx=</span><span class="s4">'dy/dx'</span><span class="s2">,</span>
                        <span class="s1">eyex=</span><span class="s4">'d(lny)/d(lnx)'</span><span class="s2">,</span>
                        <span class="s1">dyex=</span><span class="s4">'dy/d(lnx)'</span><span class="s2">,</span>
                        <span class="s1">eydx=</span><span class="s4">'d(lny)/dx'</span><span class="s1">)</span>

<span class="s2">class </span><span class="s1">Margins:</span>
    <span class="s3">&quot;&quot;&quot; 
    Mostly a do nothing class. Lays out the methods expected of a sub-class. 
 
    This is just a sketch of what we may want out of a general margins class. 
    I (SS) need to look at details of other models. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">results</span><span class="s2">, </span><span class="s1">get_margeff</span><span class="s2">, </span><span class="s1">derivative</span><span class="s2">, </span><span class="s1">dist=</span><span class="s2">None,</span>
                       <span class="s1">margeff_args=()):</span>
        <span class="s1">self._cache = {}</span>
        <span class="s1">self.results = results</span>
        <span class="s1">self.dist = dist</span>
        <span class="s1">self.get_margeff(margeff_args)</span>

    <span class="s2">def </span><span class="s1">_reset(self):</span>
        <span class="s1">self._cache = {}</span>

    <span class="s2">def </span><span class="s1">get_margeff(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">self._reset()</span>
        <span class="s1">self.margeff = self.get_margeff(*args)</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">tvalues(self):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">cov_margins(self):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">margins_se(self):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s2">def </span><span class="s1">summary_frame(self):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">pvalues(self):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s2">def </span><span class="s1">conf_int(self</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s5">.05</span><span class="s1">):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

    <span class="s2">def </span><span class="s1">summary(self</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s5">.05</span><span class="s1">):</span>
        <span class="s2">raise </span><span class="s1">NotImplementedError</span>

<span class="s0">#class DiscreteMargins(Margins):</span>
<span class="s2">class </span><span class="s1">DiscreteMargins:</span>
    <span class="s3">&quot;&quot;&quot;Get marginal effects of a Discrete Choice model. 
 
    Parameters 
    ---------- 
    results : DiscreteResults instance 
        The results instance of a fitted discrete choice model 
    args : tuple 
        Args are passed to `get_margeff`. This is the same as 
        results.get_margeff. See there for more information. 
    kwargs : dict 
        Keyword args are passed to `get_margeff`. This is the same as 
        results.get_margeff. See there for more information. 
    &quot;&quot;&quot;</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">results</span><span class="s2">, </span><span class="s1">args</span><span class="s2">, </span><span class="s1">kwargs={}):</span>
        <span class="s1">self._cache = {}</span>
        <span class="s1">self.results = results</span>
        <span class="s1">self.get_margeff(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

    <span class="s2">def </span><span class="s1">_reset(self):</span>
        <span class="s1">self._cache = {}</span>

    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">tvalues(self):</span>
        <span class="s1">_check_at_is_all(self.margeff_options)</span>
        <span class="s2">return </span><span class="s1">self.margeff / self.margeff_se</span>

    <span class="s2">def </span><span class="s1">summary_frame(self</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s5">.05</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Returns a DataFrame summarizing the marginal effects. 
 
        Parameters 
        ---------- 
        alpha : float 
            Number between 0 and 1. The confidence intervals have the 
            probability 1-alpha. 
 
        Returns 
        ------- 
        frame : DataFrames 
            A DataFrame summarizing the marginal effects. 
 
        Notes 
        ----- 
        The dataframe is created on each call and not cached, as are the 
        tables build in `summary()` 
        &quot;&quot;&quot;</span>
        <span class="s1">_check_at_is_all(self.margeff_options)</span>
        <span class="s1">results = self.results</span>
        <span class="s1">model = self.results.model</span>
        <span class="s2">from </span><span class="s1">pandas </span><span class="s2">import </span><span class="s1">DataFrame</span><span class="s2">, </span><span class="s1">MultiIndex</span>
        <span class="s1">names = [_transform_names[self.margeff_options[</span><span class="s4">'method'</span><span class="s1">]]</span><span class="s2">,</span>
                                  <span class="s4">'Std. Err.'</span><span class="s2">, </span><span class="s4">'z'</span><span class="s2">, </span><span class="s4">'Pr(&gt;|z|)'</span><span class="s2">,</span>
                                  <span class="s4">'Conf. Int. Low'</span><span class="s2">, </span><span class="s4">'Cont. Int. Hi.'</span><span class="s1">]</span>
        <span class="s1">ind = self.results.model.exog.var(</span><span class="s5">0</span><span class="s1">) != </span><span class="s5">0 </span><span class="s0"># True if not a constant</span>
        <span class="s1">exog_names = self.results.model.exog_names</span>
        <span class="s1">k_extra = getattr(model</span><span class="s2">, </span><span class="s4">'k_extra'</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">k_extra &gt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">exog_names = exog_names[:-k_extra]</span>
        <span class="s1">var_names = [name </span><span class="s2">for </span><span class="s1">i</span><span class="s2">,</span><span class="s1">name </span><span class="s2">in </span><span class="s1">enumerate(exog_names) </span><span class="s2">if </span><span class="s1">ind[i]]</span>

        <span class="s2">if </span><span class="s1">self.margeff.ndim == </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s0"># MNLogit case</span>
            <span class="s1">ci = self.conf_int(alpha)</span>
            <span class="s1">table = np.column_stack([i.ravel(</span><span class="s4">&quot;F&quot;</span><span class="s1">) </span><span class="s2">for </span><span class="s1">i </span><span class="s2">in</span>
                        <span class="s1">[self.margeff</span><span class="s2">, </span><span class="s1">self.margeff_se</span><span class="s2">, </span><span class="s1">self.tvalues</span><span class="s2">,</span>
                         <span class="s1">self.pvalues</span><span class="s2">, </span><span class="s1">ci[:</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s1">:]</span><span class="s2">, </span><span class="s1">ci[:</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">:]]])</span>

            <span class="s1">_</span><span class="s2">, </span><span class="s1">yname_list = results._get_endog_name(model.endog_names</span><span class="s2">,</span>
                                                        <span class="s2">None, </span><span class="s1">all=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s1">ynames = np.repeat(yname_list</span><span class="s2">, </span><span class="s1">len(var_names))</span>
            <span class="s1">xnames = np.tile(var_names</span><span class="s2">, </span><span class="s1">len(yname_list))</span>
            <span class="s1">index = MultiIndex.from_tuples(list(zip(ynames</span><span class="s2">, </span><span class="s1">xnames))</span><span class="s2">,</span>
                                           <span class="s1">names=[</span><span class="s4">'endog'</span><span class="s2">, </span><span class="s4">'exog'</span><span class="s1">])</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">table = np.column_stack((self.margeff</span><span class="s2">, </span><span class="s1">self.margeff_se</span><span class="s2">, </span><span class="s1">self.tvalues</span><span class="s2">,</span>
                                     <span class="s1">self.pvalues</span><span class="s2">, </span><span class="s1">self.conf_int(alpha)))</span>
            <span class="s1">index=var_names</span>

        <span class="s2">return </span><span class="s1">DataFrame(table</span><span class="s2">, </span><span class="s1">columns=names</span><span class="s2">, </span><span class="s1">index=index)</span>


    <span class="s1">@cache_readonly</span>
    <span class="s2">def </span><span class="s1">pvalues(self):</span>
        <span class="s1">_check_at_is_all(self.margeff_options)</span>
        <span class="s2">return </span><span class="s1">norm.sf(np.abs(self.tvalues)) * </span><span class="s5">2</span>

    <span class="s2">def </span><span class="s1">conf_int(self</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s5">.05</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Returns the confidence intervals of the marginal effects 
 
        Parameters 
        ---------- 
        alpha : float 
            Number between 0 and 1. The confidence intervals have the 
            probability 1-alpha. 
 
        Returns 
        ------- 
        conf_int : ndarray 
            An array with lower, upper confidence intervals for the marginal 
            effects. 
        &quot;&quot;&quot;</span>
        <span class="s1">_check_at_is_all(self.margeff_options)</span>
        <span class="s1">me_se = self.margeff_se</span>
        <span class="s1">q = norm.ppf(</span><span class="s5">1 </span><span class="s1">- alpha / </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">lower = self.margeff - q * me_se</span>
        <span class="s1">upper = self.margeff + q * me_se</span>
        <span class="s2">return </span><span class="s1">np.asarray(lzip(lower</span><span class="s2">, </span><span class="s1">upper))</span>

    <span class="s2">def </span><span class="s1">summary(self</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s5">.05</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot; 
        Returns a summary table for marginal effects 
 
        Parameters 
        ---------- 
        alpha : float 
            Number between 0 and 1. The confidence intervals have the 
            probability 1-alpha. 
 
        Returns 
        ------- 
        Summary : SummaryTable 
            A SummaryTable instance 
        &quot;&quot;&quot;</span>
        <span class="s1">_check_at_is_all(self.margeff_options)</span>
        <span class="s1">results = self.results</span>
        <span class="s1">model = results.model</span>
        <span class="s1">title = model.__class__.__name__ + </span><span class="s4">&quot; Marginal Effects&quot;</span>
        <span class="s1">method = self.margeff_options[</span><span class="s4">'method'</span><span class="s1">]</span>
        <span class="s1">top_left = [(</span><span class="s4">'Dep. Variable:'</span><span class="s2">, </span><span class="s1">[model.endog_names])</span><span class="s2">,</span>
                <span class="s1">(</span><span class="s4">'Method:'</span><span class="s2">, </span><span class="s1">[method])</span><span class="s2">,</span>
                <span class="s1">(</span><span class="s4">'At:'</span><span class="s2">, </span><span class="s1">[self.margeff_options[</span><span class="s4">'at'</span><span class="s1">]])</span><span class="s2">,</span><span class="s1">]</span>

        <span class="s2">from </span><span class="s1">statsmodels.iolib.summary </span><span class="s2">import </span><span class="s1">(Summary</span><span class="s2">, </span><span class="s1">summary_params</span><span class="s2">,</span>
                                                <span class="s1">table_extend)</span>
        <span class="s1">exog_names = model.exog_names[:] </span><span class="s0"># copy</span>
        <span class="s1">smry = Summary()</span>

        <span class="s0"># TODO: sigh, we really need to hold on to this in _data...</span>
        <span class="s1">_</span><span class="s2">, </span><span class="s1">const_idx = _get_const_index(model.exog)</span>
        <span class="s2">if </span><span class="s1">const_idx </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">exog_names.pop(const_idx[</span><span class="s5">0</span><span class="s1">])</span>
        <span class="s2">if </span><span class="s1">getattr(model</span><span class="s2">, </span><span class="s4">'k_extra'</span><span class="s2">, </span><span class="s5">0</span><span class="s1">) &gt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">exog_names = exog_names[:-model.k_extra]</span>

        <span class="s1">J = int(getattr(model</span><span class="s2">, </span><span class="s4">&quot;J&quot;</span><span class="s2">, </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s2">if </span><span class="s1">J &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">yname</span><span class="s2">, </span><span class="s1">yname_list = results._get_endog_name(model.endog_names</span><span class="s2">,</span>
                                                <span class="s2">None, </span><span class="s1">all=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">yname = model.endog_names</span>
            <span class="s1">yname_list = [yname]</span>

        <span class="s1">smry.add_table_2cols(self</span><span class="s2">, </span><span class="s1">gleft=top_left</span><span class="s2">, </span><span class="s1">gright=[]</span><span class="s2">,</span>
                <span class="s1">yname=yname</span><span class="s2">, </span><span class="s1">xname=exog_names</span><span class="s2">, </span><span class="s1">title=title)</span>

        <span class="s0"># NOTE: add_table_params is not general enough yet for margeff</span>
        <span class="s0"># could use a refactor with getattr instead of hard-coded params</span>
        <span class="s0"># tvalues etc.</span>
        <span class="s1">table = []</span>
        <span class="s1">conf_int = self.conf_int(alpha)</span>
        <span class="s1">margeff = self.margeff</span>
        <span class="s1">margeff_se = self.margeff_se</span>
        <span class="s1">tvalues = self.tvalues</span>
        <span class="s1">pvalues = self.pvalues</span>
        <span class="s2">if </span><span class="s1">J &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">eq </span><span class="s2">in </span><span class="s1">range(J):</span>
                <span class="s1">restup = (results</span><span class="s2">, </span><span class="s1">margeff[:</span><span class="s2">,</span><span class="s1">eq]</span><span class="s2">, </span><span class="s1">margeff_se[:</span><span class="s2">,</span><span class="s1">eq]</span><span class="s2">,</span>
                          <span class="s1">tvalues[:</span><span class="s2">,</span><span class="s1">eq]</span><span class="s2">, </span><span class="s1">pvalues[:</span><span class="s2">,</span><span class="s1">eq]</span><span class="s2">, </span><span class="s1">conf_int[:</span><span class="s2">,</span><span class="s1">:</span><span class="s2">,</span><span class="s1">eq])</span>
                <span class="s1">tble = summary_params(restup</span><span class="s2">, </span><span class="s1">yname=yname_list[eq]</span><span class="s2">,</span>
                              <span class="s1">xname=exog_names</span><span class="s2">, </span><span class="s1">alpha=alpha</span><span class="s2">, </span><span class="s1">use_t=</span><span class="s2">False,</span>
                              <span class="s1">skip_header=</span><span class="s2">True</span><span class="s1">)</span>
                <span class="s1">tble.title = yname_list[eq]</span>
                <span class="s0"># overwrite coef with method name</span>
                <span class="s1">header = [</span><span class="s4">''</span><span class="s2">, </span><span class="s1">_transform_names[method]</span><span class="s2">, </span><span class="s4">'std err'</span><span class="s2">, </span><span class="s4">'z'</span><span class="s2">,</span>
                        <span class="s4">'P&gt;|z|'</span><span class="s2">, </span><span class="s4">'[' </span><span class="s1">+ str(alpha/</span><span class="s5">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">str(</span><span class="s5">1</span><span class="s1">-alpha/</span><span class="s5">2</span><span class="s1">) + </span><span class="s4">']'</span><span class="s1">]</span>
                <span class="s1">tble.insert_header_row(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">header)</span>
                <span class="s1">table.append(tble)</span>

            <span class="s1">table = table_extend(table</span><span class="s2">, </span><span class="s1">keep_headers=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">restup = (results</span><span class="s2">, </span><span class="s1">margeff</span><span class="s2">, </span><span class="s1">margeff_se</span><span class="s2">, </span><span class="s1">tvalues</span><span class="s2">, </span><span class="s1">pvalues</span><span class="s2">, </span><span class="s1">conf_int)</span>
            <span class="s1">table = summary_params(restup</span><span class="s2">, </span><span class="s1">yname=yname</span><span class="s2">, </span><span class="s1">xname=exog_names</span><span class="s2">,</span>
                    <span class="s1">alpha=alpha</span><span class="s2">, </span><span class="s1">use_t=</span><span class="s2">False, </span><span class="s1">skip_header=</span><span class="s2">True</span><span class="s1">)</span>
            <span class="s1">header = [</span><span class="s4">''</span><span class="s2">, </span><span class="s1">_transform_names[method]</span><span class="s2">, </span><span class="s4">'std err'</span><span class="s2">, </span><span class="s4">'z'</span><span class="s2">,</span>
                        <span class="s4">'P&gt;|z|'</span><span class="s2">, </span><span class="s4">'[' </span><span class="s1">+ str(alpha/</span><span class="s5">2</span><span class="s1">)</span><span class="s2">, </span><span class="s1">str(</span><span class="s5">1</span><span class="s1">-alpha/</span><span class="s5">2</span><span class="s1">) + </span><span class="s4">']'</span><span class="s1">]</span>
            <span class="s1">table.insert_header_row(</span><span class="s5">0</span><span class="s2">, </span><span class="s1">header)</span>

        <span class="s1">smry.tables.append(table)</span>
        <span class="s2">return </span><span class="s1">smry</span>

    <span class="s2">def </span><span class="s1">get_margeff(self</span><span class="s2">, </span><span class="s1">at=</span><span class="s4">'overall'</span><span class="s2">, </span><span class="s1">method=</span><span class="s4">'dydx'</span><span class="s2">, </span><span class="s1">atexog=</span><span class="s2">None,</span>
                          <span class="s1">dummy=</span><span class="s2">False, </span><span class="s1">count=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s3">&quot;&quot;&quot;Get marginal effects of the fitted model. 
 
        Parameters 
        ---------- 
        at : str, optional 
            Options are: 
 
            - 'overall', The average of the marginal effects at each 
              observation. 
            - 'mean', The marginal effects at the mean of each regressor. 
            - 'median', The marginal effects at the median of each regressor. 
            - 'zero', The marginal effects at zero for each regressor. 
            - 'all', The marginal effects at each observation. If `at` is all 
              only margeff will be available. 
 
            Note that if `exog` is specified, then marginal effects for all 
            variables not specified by `exog` are calculated using the `at` 
            option. 
        method : str, optional 
            Options are: 
 
            - 'dydx' - dy/dx - No transformation is made and marginal effects 
              are returned.  This is the default. 
            - 'eyex' - estimate elasticities of variables in `exog` -- 
              d(lny)/d(lnx) 
            - 'dyex' - estimate semi-elasticity -- dy/d(lnx) 
            - 'eydx' - estimate semi-elasticity -- d(lny)/dx 
 
            Note that tranformations are done after each observation is 
            calculated.  Semi-elasticities for binary variables are computed 
            using the midpoint method. 'dyex' and 'eyex' do not make sense 
            for discrete variables. 
        atexog : array_like, optional 
            Optionally, you can provide the exogenous variables over which to 
            get the marginal effects.  This should be a dictionary with the key 
            as the zero-indexed column number and the value of the dictionary. 
            Default is None for all independent variables less the constant. 
        dummy : bool, optional 
            If False, treats binary variables (if present) as continuous.  This 
            is the default.  Else if True, treats binary variables as 
            changing from 0 to 1.  Note that any variable that is either 0 or 1 
            is treated as binary.  Each binary variable is treated separately 
            for now. 
        count : bool, optional 
            If False, treats count variables (if present) as continuous.  This 
            is the default.  Else if True, the marginal effect is the 
            change in probabilities when each observation is increased by one. 
 
        Returns 
        ------- 
        effects : ndarray 
            the marginal effect corresponding to the input options 
 
        Notes 
        ----- 
        When using after Poisson, returns the expected number of events 
        per period, assuming that the model is loglinear. 
        &quot;&quot;&quot;</span>
        <span class="s1">self._reset() </span><span class="s0"># always reset the cache when this is called</span>
        <span class="s0">#TODO: if at is not all or overall, we can also put atexog values</span>
        <span class="s0"># in summary table head</span>
        <span class="s1">method = method.lower()</span>
        <span class="s1">at = at.lower()</span>
        <span class="s1">_check_margeff_args(at</span><span class="s2">, </span><span class="s1">method)</span>
        <span class="s1">self.margeff_options = dict(method=method</span><span class="s2">, </span><span class="s1">at=at)</span>
        <span class="s1">results = self.results</span>
        <span class="s1">model = results.model</span>
        <span class="s1">params = results.params</span>
        <span class="s1">exog = model.exog.copy() </span><span class="s0"># copy because values are changed</span>
        <span class="s1">effects_idx</span><span class="s2">, </span><span class="s1">const_idx =  _get_const_index(exog)</span>

        <span class="s2">if </span><span class="s1">dummy:</span>
            <span class="s1">_check_discrete_args(at</span><span class="s2">, </span><span class="s1">method)</span>
            <span class="s1">dummy_idx</span><span class="s2">, </span><span class="s1">dummy = _get_dummy_index(exog</span><span class="s2">, </span><span class="s1">const_idx)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">dummy_idx = </span><span class="s2">None</span>

        <span class="s2">if </span><span class="s1">count:</span>
            <span class="s1">_check_discrete_args(at</span><span class="s2">, </span><span class="s1">method)</span>
            <span class="s1">count_idx</span><span class="s2">, </span><span class="s1">count = _get_count_index(exog</span><span class="s2">, </span><span class="s1">const_idx)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">count_idx = </span><span class="s2">None</span>

        <span class="s0"># attach dummy_idx and cout_idx</span>
        <span class="s1">self.dummy_idx = dummy_idx</span>
        <span class="s1">self.count_idx = count_idx</span>

        <span class="s0"># get the exogenous variables</span>
        <span class="s1">exog = _get_margeff_exog(exog</span><span class="s2">, </span><span class="s1">at</span><span class="s2">, </span><span class="s1">atexog</span><span class="s2">, </span><span class="s1">effects_idx)</span>

        <span class="s0"># get base marginal effects, handled by sub-classes</span>
        <span class="s1">effects = model._derivative_exog(params</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">, </span><span class="s1">method</span><span class="s2">,</span>
                                                    <span class="s1">dummy_idx</span><span class="s2">, </span><span class="s1">count_idx)</span>

        <span class="s1">J = getattr(model</span><span class="s2">, </span><span class="s4">'J'</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">effects_idx = np.tile(effects_idx</span><span class="s2">, </span><span class="s1">J) </span><span class="s0"># adjust for multi-equation.</span>

        <span class="s1">effects = _effects_at(effects</span><span class="s2">, </span><span class="s1">at)</span>

        <span class="s2">if </span><span class="s1">at == </span><span class="s4">'all'</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">J &gt; </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">K = model.K - np.any(~effects_idx) </span><span class="s0"># subtract constant</span>
                <span class="s1">self.margeff = effects[:</span><span class="s2">, </span><span class="s1">effects_idx].reshape(-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">K</span><span class="s2">, </span><span class="s1">J</span><span class="s2">,</span>
                                                                <span class="s1">order=</span><span class="s4">'F'</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">self.margeff = effects[:</span><span class="s2">, </span><span class="s1">effects_idx]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s0"># Set standard error of the marginal effects by Delta method.</span>
            <span class="s1">margeff_cov</span><span class="s2">, </span><span class="s1">margeff_se = margeff_cov_with_se(model</span><span class="s2">, </span><span class="s1">params</span><span class="s2">, </span><span class="s1">exog</span><span class="s2">,</span>
                                                <span class="s1">results.cov_params()</span><span class="s2">, </span><span class="s1">at</span><span class="s2">,</span>
                                                <span class="s1">model._derivative_exog</span><span class="s2">,</span>
                                                <span class="s1">dummy_idx</span><span class="s2">, </span><span class="s1">count_idx</span><span class="s2">,</span>
                                                <span class="s1">method</span><span class="s2">, </span><span class="s1">J)</span>

            <span class="s0"># reshape for multi-equation</span>
            <span class="s2">if </span><span class="s1">J &gt; </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">K = model.K - np.any(~effects_idx) </span><span class="s0"># subtract constant</span>
                <span class="s1">self.margeff = effects[effects_idx].reshape(K</span><span class="s2">, </span><span class="s1">J</span><span class="s2">, </span><span class="s1">order=</span><span class="s4">'F'</span><span class="s1">)</span>
                <span class="s1">self.margeff_se = margeff_se[effects_idx].reshape(K</span><span class="s2">, </span><span class="s1">J</span><span class="s2">,</span>
                                                                  <span class="s1">order=</span><span class="s4">'F'</span><span class="s1">)</span>
                <span class="s1">self.margeff_cov = margeff_cov[effects_idx][:</span><span class="s2">, </span><span class="s1">effects_idx]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s0"># do not care about at constant</span>
                <span class="s0"># hack truncate effects_idx again if necessary</span>
                <span class="s0"># if eyex, then effects is truncated to be without extra params</span>
                <span class="s1">effects_idx = effects_idx[:len(effects)]</span>
                <span class="s1">self.margeff_cov = margeff_cov[effects_idx][:</span><span class="s2">, </span><span class="s1">effects_idx]</span>
                <span class="s1">self.margeff_se = margeff_se[effects_idx]</span>
                <span class="s1">self.margeff = effects[effects_idx]</span>
</pre>
</body>
</html>