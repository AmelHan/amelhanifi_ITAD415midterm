<html>
<head>
<title>test_offsets.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_offsets.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Tests of pandas.tseries.offsets 
&quot;&quot;&quot;</span>
<span class="s2">from </span><span class="s1">__future__ </span><span class="s2">import </span><span class="s1">annotations</span>

<span class="s2">from </span><span class="s1">datetime </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">datetime</span><span class="s2">,</span>
    <span class="s1">timedelta</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pytest</span>

<span class="s2">from </span><span class="s1">pandas._libs.tslibs </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">NaT</span><span class="s2">,</span>
    <span class="s1">Timedelta</span><span class="s2">,</span>
    <span class="s1">Timestamp</span><span class="s2">,</span>
    <span class="s1">conversion</span><span class="s2">,</span>
    <span class="s1">timezones</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">import </span><span class="s1">pandas._libs.tslibs.offsets </span><span class="s2">as </span><span class="s1">liboffsets</span>
<span class="s2">from </span><span class="s1">pandas._libs.tslibs.offsets </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">_get_offset</span><span class="s2">,</span>
    <span class="s1">_offset_map</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">pandas._libs.tslibs.period </span><span class="s2">import </span><span class="s1">INVALID_FREQ_ERR_MSG</span>
<span class="s2">from </span><span class="s1">pandas.errors </span><span class="s2">import </span><span class="s1">PerformanceWarning</span>

<span class="s2">from </span><span class="s1">pandas </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">DataFrame</span><span class="s2">,</span>
    <span class="s1">DatetimeIndex</span><span class="s2">,</span>
    <span class="s1">Series</span><span class="s2">,</span>
    <span class="s1">date_range</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">import </span><span class="s1">pandas._testing </span><span class="s2">as </span><span class="s1">tm</span>
<span class="s2">from </span><span class="s1">pandas.tests.tseries.offsets.common </span><span class="s2">import </span><span class="s1">WeekDay</span>

<span class="s2">from </span><span class="s1">pandas.tseries </span><span class="s2">import </span><span class="s1">offsets</span>
<span class="s2">from </span><span class="s1">pandas.tseries.offsets </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">FY5253</span><span class="s2">,</span>
    <span class="s1">BDay</span><span class="s2">,</span>
    <span class="s1">BMonthEnd</span><span class="s2">,</span>
    <span class="s1">BusinessHour</span><span class="s2">,</span>
    <span class="s1">CustomBusinessDay</span><span class="s2">,</span>
    <span class="s1">CustomBusinessHour</span><span class="s2">,</span>
    <span class="s1">CustomBusinessMonthBegin</span><span class="s2">,</span>
    <span class="s1">CustomBusinessMonthEnd</span><span class="s2">,</span>
    <span class="s1">DateOffset</span><span class="s2">,</span>
    <span class="s1">Easter</span><span class="s2">,</span>
    <span class="s1">FY5253Quarter</span><span class="s2">,</span>
    <span class="s1">LastWeekOfMonth</span><span class="s2">,</span>
    <span class="s1">MonthBegin</span><span class="s2">,</span>
    <span class="s1">Nano</span><span class="s2">,</span>
    <span class="s1">Tick</span><span class="s2">,</span>
    <span class="s1">Week</span><span class="s2">,</span>
    <span class="s1">WeekOfMonth</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s1">_ARITHMETIC_DATE_OFFSET = [</span>
    <span class="s3">&quot;years&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;months&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;weeks&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;days&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;hours&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;minutes&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;seconds&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;milliseconds&quot;</span><span class="s2">,</span>
    <span class="s3">&quot;microseconds&quot;</span><span class="s2">,</span>
<span class="s1">]</span>


<span class="s2">def </span><span class="s1">_create_offset(klass</span><span class="s2">, </span><span class="s1">value=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">normalize=</span><span class="s2">False</span><span class="s1">):</span>
    <span class="s5"># create instance from offset class</span>
    <span class="s2">if </span><span class="s1">klass </span><span class="s2">is </span><span class="s1">FY5253:</span>
        <span class="s1">klass = klass(</span>
            <span class="s1">n=value</span><span class="s2">,</span>
            <span class="s1">startingMonth=</span><span class="s4">1</span><span class="s2">,</span>
            <span class="s1">weekday=</span><span class="s4">1</span><span class="s2">,</span>
            <span class="s1">variation=</span><span class="s3">&quot;last&quot;</span><span class="s2">,</span>
            <span class="s1">normalize=normalize</span><span class="s2">,</span>
        <span class="s1">)</span>
    <span class="s2">elif </span><span class="s1">klass </span><span class="s2">is </span><span class="s1">FY5253Quarter:</span>
        <span class="s1">klass = klass(</span>
            <span class="s1">n=value</span><span class="s2">,</span>
            <span class="s1">startingMonth=</span><span class="s4">1</span><span class="s2">,</span>
            <span class="s1">weekday=</span><span class="s4">1</span><span class="s2">,</span>
            <span class="s1">qtr_with_extra_week=</span><span class="s4">1</span><span class="s2">,</span>
            <span class="s1">variation=</span><span class="s3">&quot;last&quot;</span><span class="s2">,</span>
            <span class="s1">normalize=normalize</span><span class="s2">,</span>
        <span class="s1">)</span>
    <span class="s2">elif </span><span class="s1">klass </span><span class="s2">is </span><span class="s1">LastWeekOfMonth:</span>
        <span class="s1">klass = klass(n=value</span><span class="s2">, </span><span class="s1">weekday=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">normalize=normalize)</span>
    <span class="s2">elif </span><span class="s1">klass </span><span class="s2">is </span><span class="s1">WeekOfMonth:</span>
        <span class="s1">klass = klass(n=value</span><span class="s2">, </span><span class="s1">week=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">weekday=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">normalize=normalize)</span>
    <span class="s2">elif </span><span class="s1">klass </span><span class="s2">is </span><span class="s1">Week:</span>
        <span class="s1">klass = klass(n=value</span><span class="s2">, </span><span class="s1">weekday=</span><span class="s4">5</span><span class="s2">, </span><span class="s1">normalize=normalize)</span>
    <span class="s2">elif </span><span class="s1">klass </span><span class="s2">is </span><span class="s1">DateOffset:</span>
        <span class="s1">klass = klass(days=value</span><span class="s2">, </span><span class="s1">normalize=normalize)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">klass = klass(value</span><span class="s2">, </span><span class="s1">normalize=normalize)</span>
    <span class="s2">return </span><span class="s1">klass</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">dt():</span>
    <span class="s2">return </span><span class="s1">Timestamp(datetime(</span><span class="s4">2008</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">))</span>


<span class="s1">@pytest.fixture</span>
<span class="s2">def </span><span class="s1">expecteds():</span>
    <span class="s5"># executed value created by _create_offset</span>
    <span class="s5"># are applied to 2011/01/01 09:00 (Saturday)</span>
    <span class="s5"># used for .apply and .rollforward</span>
    <span class="s2">return </span><span class="s1">{</span>
        <span class="s3">&quot;Day&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2011-01-02 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s3">&quot;DateOffset&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2011-01-02 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s3">&quot;BusinessDay&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2011-01-03 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s3">&quot;CustomBusinessDay&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2011-01-03 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s3">&quot;CustomBusinessMonthEnd&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2011-01-31 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s3">&quot;CustomBusinessMonthBegin&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2011-01-03 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s3">&quot;MonthBegin&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2011-02-01 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s3">&quot;BusinessMonthBegin&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2011-01-03 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s3">&quot;MonthEnd&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2011-01-31 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s3">&quot;SemiMonthEnd&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2011-01-15 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s3">&quot;SemiMonthBegin&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2011-01-15 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s3">&quot;BusinessMonthEnd&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2011-01-31 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s3">&quot;YearBegin&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2012-01-01 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s3">&quot;BYearBegin&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2011-01-03 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s3">&quot;YearEnd&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2011-12-31 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s3">&quot;BYearEnd&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2011-12-30 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s3">&quot;QuarterBegin&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2011-03-01 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s3">&quot;BQuarterBegin&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2011-03-01 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s3">&quot;QuarterEnd&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2011-03-31 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s3">&quot;BQuarterEnd&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2011-03-31 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s3">&quot;BusinessHour&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2011-01-03 10:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s3">&quot;CustomBusinessHour&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2011-01-03 10:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s3">&quot;WeekOfMonth&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2011-01-08 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s3">&quot;LastWeekOfMonth&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2011-01-29 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s3">&quot;FY5253Quarter&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2011-01-25 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s3">&quot;FY5253&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2011-01-25 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s3">&quot;Week&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2011-01-08 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s3">&quot;Easter&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2011-04-24 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s3">&quot;Hour&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2011-01-01 10:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s3">&quot;Minute&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2011-01-01 09:01:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s3">&quot;Second&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2011-01-01 09:00:01&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s3">&quot;Milli&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2011-01-01 09:00:00.001000&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s3">&quot;Micro&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2011-01-01 09:00:00.000001&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s3">&quot;Nano&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2011-01-01T09:00:00.000000001&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">}</span>


<span class="s2">class </span><span class="s1">TestCommon:</span>
    <span class="s2">def </span><span class="s1">test_immutable(self</span><span class="s2">, </span><span class="s1">offset_types):</span>
        <span class="s5"># GH#21341 check that __setattr__ raises</span>
        <span class="s1">offset = _create_offset(offset_types)</span>
        <span class="s1">msg = </span><span class="s3">&quot;objects is not writable|DateOffset objects are immutable&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(AttributeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">offset.normalize = </span><span class="s2">True</span>
        <span class="s2">with </span><span class="s1">pytest.raises(AttributeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">offset.n = </span><span class="s4">91</span>

    <span class="s2">def </span><span class="s1">test_return_type(self</span><span class="s2">, </span><span class="s1">offset_types):</span>
        <span class="s1">offset = _create_offset(offset_types)</span>

        <span class="s5"># make sure that we are returning a Timestamp</span>
        <span class="s1">result = Timestamp(</span><span class="s3">&quot;20080101&quot;</span><span class="s1">) + offset</span>
        <span class="s2">assert </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">Timestamp)</span>

        <span class="s5"># make sure that we are returning NaT</span>
        <span class="s2">assert </span><span class="s1">NaT + offset </span><span class="s2">is </span><span class="s1">NaT</span>
        <span class="s2">assert </span><span class="s1">offset + NaT </span><span class="s2">is </span><span class="s1">NaT</span>

        <span class="s2">assert </span><span class="s1">NaT - offset </span><span class="s2">is </span><span class="s1">NaT</span>
        <span class="s2">assert </span><span class="s1">(-offset)._apply(NaT) </span><span class="s2">is </span><span class="s1">NaT</span>

    <span class="s2">def </span><span class="s1">test_offset_n(self</span><span class="s2">, </span><span class="s1">offset_types):</span>
        <span class="s1">offset = _create_offset(offset_types)</span>
        <span class="s2">assert </span><span class="s1">offset.n == </span><span class="s4">1</span>

        <span class="s1">neg_offset = offset * -</span><span class="s4">1</span>
        <span class="s2">assert </span><span class="s1">neg_offset.n == -</span><span class="s4">1</span>

        <span class="s1">mul_offset = offset * </span><span class="s4">3</span>
        <span class="s2">assert </span><span class="s1">mul_offset.n == </span><span class="s4">3</span>

    <span class="s2">def </span><span class="s1">test_offset_timedelta64_arg(self</span><span class="s2">, </span><span class="s1">offset_types):</span>
        <span class="s5"># check that offset._validate_n raises TypeError on a timedelt64</span>
        <span class="s5">#  object</span>
        <span class="s1">off = _create_offset(offset_types)</span>

        <span class="s1">td64 = np.timedelta64(</span><span class="s4">4567</span><span class="s2">, </span><span class="s3">&quot;s&quot;</span><span class="s1">)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;argument must be an integer&quot;</span><span class="s1">):</span>
            <span class="s1">type(off)(n=td64</span><span class="s2">, </span><span class="s1">**off.kwds)</span>

    <span class="s2">def </span><span class="s1">test_offset_mul_ndarray(self</span><span class="s2">, </span><span class="s1">offset_types):</span>
        <span class="s1">off = _create_offset(offset_types)</span>

        <span class="s1">expected = np.array([[off</span><span class="s2">, </span><span class="s1">off * </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[off * </span><span class="s4">3</span><span class="s2">, </span><span class="s1">off * </span><span class="s4">4</span><span class="s1">]])</span>

        <span class="s1">result = np.array([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]]) * off</span>
        <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

        <span class="s1">result = off * np.array([[</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">3</span><span class="s2">, </span><span class="s4">4</span><span class="s1">]])</span>
        <span class="s1">tm.assert_numpy_array_equal(result</span><span class="s2">, </span><span class="s1">expected)</span>

    <span class="s2">def </span><span class="s1">test_offset_freqstr(self</span><span class="s2">, </span><span class="s1">offset_types):</span>
        <span class="s1">offset = _create_offset(offset_types)</span>

        <span class="s1">freqstr = offset.freqstr</span>
        <span class="s2">if </span><span class="s1">freqstr </span><span class="s2">not in </span><span class="s1">(</span><span class="s3">&quot;&lt;Easter&gt;&quot;</span><span class="s2">, </span><span class="s3">&quot;&lt;DateOffset: days=1&gt;&quot;</span><span class="s2">, </span><span class="s3">&quot;LWOM-SAT&quot;</span><span class="s1">):</span>
            <span class="s1">code = _get_offset(freqstr)</span>
            <span class="s2">assert </span><span class="s1">offset.rule_code == code</span>

    <span class="s2">def </span><span class="s1">_check_offsetfunc_works(self</span><span class="s2">, </span><span class="s1">offset</span><span class="s2">, </span><span class="s1">funcname</span><span class="s2">, </span><span class="s1">dt</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">normalize=</span><span class="s2">False</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">normalize </span><span class="s2">and </span><span class="s1">issubclass(offset</span><span class="s2">, </span><span class="s1">Tick):</span>
            <span class="s5"># normalize=True disallowed for Tick subclasses GH#21427</span>
            <span class="s2">return</span>

        <span class="s1">offset_s = _create_offset(offset</span><span class="s2">, </span><span class="s1">normalize=normalize)</span>
        <span class="s1">func = getattr(offset_s</span><span class="s2">, </span><span class="s1">funcname)</span>

        <span class="s1">result = func(dt)</span>
        <span class="s2">assert </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">Timestamp)</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

        <span class="s1">result = func(Timestamp(dt))</span>
        <span class="s2">assert </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">Timestamp)</span>
        <span class="s2">assert </span><span class="s1">result == expected</span>

        <span class="s5"># see gh-14101</span>
        <span class="s1">exp_warning = </span><span class="s2">None</span>
        <span class="s1">ts = Timestamp(dt) + Nano(</span><span class="s4">5</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">(</span>
            <span class="s1">type(offset_s).__name__ == </span><span class="s3">&quot;DateOffset&quot;</span>
            <span class="s2">and </span><span class="s1">(funcname </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;apply&quot;</span><span class="s2">, </span><span class="s3">&quot;_apply&quot;</span><span class="s1">] </span><span class="s2">or </span><span class="s1">normalize)</span>
            <span class="s2">and </span><span class="s1">ts.nanosecond &gt; </span><span class="s4">0</span>
        <span class="s1">):</span>
            <span class="s1">exp_warning = UserWarning</span>

        <span class="s5"># test nanosecond is preserved</span>
        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(exp_warning):</span>
            <span class="s1">result = func(ts)</span>

        <span class="s2">assert </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">Timestamp)</span>
        <span class="s2">if </span><span class="s1">normalize </span><span class="s2">is False</span><span class="s1">:</span>
            <span class="s2">assert </span><span class="s1">result == expected + Nano(</span><span class="s4">5</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">assert </span><span class="s1">result == expected</span>

        <span class="s2">if </span><span class="s1">isinstance(dt</span><span class="s2">, </span><span class="s1">np.datetime64):</span>
            <span class="s5"># test tz when input is datetime or Timestamp</span>
            <span class="s2">return</span>

        <span class="s2">for </span><span class="s1">tz </span><span class="s2">in </span><span class="s1">[</span>
            <span class="s2">None,</span>
            <span class="s3">&quot;UTC&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;Asia/Tokyo&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;US/Eastern&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;dateutil/Asia/Tokyo&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;dateutil/US/Pacific&quot;</span><span class="s2">,</span>
        <span class="s1">]:</span>
            <span class="s1">expected_localize = expected.tz_localize(tz)</span>
            <span class="s1">tz_obj = timezones.maybe_get_tz(tz)</span>
            <span class="s1">dt_tz = conversion.localize_pydatetime(dt</span><span class="s2">, </span><span class="s1">tz_obj)</span>

            <span class="s1">result = func(dt_tz)</span>
            <span class="s2">assert </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">Timestamp)</span>
            <span class="s2">assert </span><span class="s1">result == expected_localize</span>

            <span class="s1">result = func(Timestamp(dt</span><span class="s2">, </span><span class="s1">tz=tz))</span>
            <span class="s2">assert </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">Timestamp)</span>
            <span class="s2">assert </span><span class="s1">result == expected_localize</span>

            <span class="s5"># see gh-14101</span>
            <span class="s1">exp_warning = </span><span class="s2">None</span>
            <span class="s1">ts = Timestamp(dt</span><span class="s2">, </span><span class="s1">tz=tz) + Nano(</span><span class="s4">5</span><span class="s1">)</span>

            <span class="s2">if </span><span class="s1">(</span>
                <span class="s1">type(offset_s).__name__ == </span><span class="s3">&quot;DateOffset&quot;</span>
                <span class="s2">and </span><span class="s1">(funcname </span><span class="s2">in </span><span class="s1">[</span><span class="s3">&quot;apply&quot;</span><span class="s2">, </span><span class="s3">&quot;_apply&quot;</span><span class="s1">] </span><span class="s2">or </span><span class="s1">normalize)</span>
                <span class="s2">and </span><span class="s1">ts.nanosecond &gt; </span><span class="s4">0</span>
            <span class="s1">):</span>
                <span class="s1">exp_warning = UserWarning</span>

            <span class="s5"># test nanosecond is preserved</span>
            <span class="s2">with </span><span class="s1">tm.assert_produces_warning(exp_warning):</span>
                <span class="s1">result = func(ts)</span>
            <span class="s2">assert </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">Timestamp)</span>
            <span class="s2">if </span><span class="s1">normalize </span><span class="s2">is False</span><span class="s1">:</span>
                <span class="s2">assert </span><span class="s1">result == expected_localize + Nano(</span><span class="s4">5</span><span class="s1">)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">assert </span><span class="s1">result == expected_localize</span>

    <span class="s2">def </span><span class="s1">test_apply(self</span><span class="s2">, </span><span class="s1">offset_types</span><span class="s2">, </span><span class="s1">expecteds):</span>
        <span class="s1">sdt = datetime(</span><span class="s4">2011</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">ndt = np.datetime64(</span><span class="s3">&quot;2011-01-01 09:00&quot;</span><span class="s1">)</span>

        <span class="s1">expected = expecteds[offset_types.__name__]</span>
        <span class="s1">expected_norm = Timestamp(expected.date())</span>

        <span class="s2">for </span><span class="s1">dt </span><span class="s2">in </span><span class="s1">[sdt</span><span class="s2">, </span><span class="s1">ndt]:</span>
            <span class="s1">self._check_offsetfunc_works(offset_types</span><span class="s2">, </span><span class="s3">&quot;_apply&quot;</span><span class="s2">, </span><span class="s1">dt</span><span class="s2">, </span><span class="s1">expected)</span>

            <span class="s1">self._check_offsetfunc_works(</span>
                <span class="s1">offset_types</span><span class="s2">, </span><span class="s3">&quot;_apply&quot;</span><span class="s2">, </span><span class="s1">dt</span><span class="s2">, </span><span class="s1">expected_norm</span><span class="s2">, </span><span class="s1">normalize=</span><span class="s2">True</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_rollforward(self</span><span class="s2">, </span><span class="s1">offset_types</span><span class="s2">, </span><span class="s1">expecteds):</span>
        <span class="s1">expecteds = expecteds.copy()</span>

        <span class="s5"># result will not be changed if the target is on the offset</span>
        <span class="s1">no_changes = [</span>
            <span class="s3">&quot;Day&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;MonthBegin&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;SemiMonthBegin&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;YearBegin&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;Week&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;Hour&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;Minute&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;Second&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;Milli&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;Micro&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;Nano&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;DateOffset&quot;</span><span class="s2">,</span>
        <span class="s1">]</span>
        <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">no_changes:</span>
            <span class="s1">expecteds[n] = Timestamp(</span><span class="s3">&quot;2011/01/01 09:00&quot;</span><span class="s1">)</span>

        <span class="s1">expecteds[</span><span class="s3">&quot;BusinessHour&quot;</span><span class="s1">] = Timestamp(</span><span class="s3">&quot;2011-01-03 09:00:00&quot;</span><span class="s1">)</span>
        <span class="s1">expecteds[</span><span class="s3">&quot;CustomBusinessHour&quot;</span><span class="s1">] = Timestamp(</span><span class="s3">&quot;2011-01-03 09:00:00&quot;</span><span class="s1">)</span>

        <span class="s5"># but be changed when normalize=True</span>
        <span class="s1">norm_expected = expecteds.copy()</span>
        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">norm_expected:</span>
            <span class="s1">norm_expected[k] = Timestamp(norm_expected[k].date())</span>

        <span class="s1">normalized = {</span>
            <span class="s3">&quot;Day&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2011-01-02 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;DateOffset&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2011-01-02 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;MonthBegin&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2011-02-01 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;SemiMonthBegin&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2011-01-15 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;YearBegin&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2012-01-01 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;Week&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2011-01-08 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;Hour&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2011-01-01 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;Minute&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2011-01-01 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;Second&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2011-01-01 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;Milli&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2011-01-01 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;Micro&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2011-01-01 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">}</span>
        <span class="s1">norm_expected.update(normalized)</span>

        <span class="s1">sdt = datetime(</span><span class="s4">2011</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">ndt = np.datetime64(</span><span class="s3">&quot;2011-01-01 09:00&quot;</span><span class="s1">)</span>

        <span class="s2">for </span><span class="s1">dt </span><span class="s2">in </span><span class="s1">[sdt</span><span class="s2">, </span><span class="s1">ndt]:</span>
            <span class="s1">expected = expecteds[offset_types.__name__]</span>
            <span class="s1">self._check_offsetfunc_works(offset_types</span><span class="s2">, </span><span class="s3">&quot;rollforward&quot;</span><span class="s2">, </span><span class="s1">dt</span><span class="s2">, </span><span class="s1">expected)</span>
            <span class="s1">expected = norm_expected[offset_types.__name__]</span>
            <span class="s1">self._check_offsetfunc_works(</span>
                <span class="s1">offset_types</span><span class="s2">, </span><span class="s3">&quot;rollforward&quot;</span><span class="s2">, </span><span class="s1">dt</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">normalize=</span><span class="s2">True</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_rollback(self</span><span class="s2">, </span><span class="s1">offset_types):</span>
        <span class="s1">expecteds = {</span>
            <span class="s3">&quot;BusinessDay&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2010-12-31 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;CustomBusinessDay&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2010-12-31 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;CustomBusinessMonthEnd&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2010-12-31 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;CustomBusinessMonthBegin&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2010-12-01 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;BusinessMonthBegin&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2010-12-01 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;MonthEnd&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2010-12-31 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;SemiMonthEnd&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2010-12-31 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;BusinessMonthEnd&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2010-12-31 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;BYearBegin&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2010-01-01 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;YearEnd&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2010-12-31 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;BYearEnd&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2010-12-31 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;QuarterBegin&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2010-12-01 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;BQuarterBegin&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2010-12-01 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;QuarterEnd&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2010-12-31 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;BQuarterEnd&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2010-12-31 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;BusinessHour&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2010-12-31 17:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;CustomBusinessHour&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2010-12-31 17:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;WeekOfMonth&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2010-12-11 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;LastWeekOfMonth&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2010-12-25 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;FY5253Quarter&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2010-10-26 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;FY5253&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2010-01-26 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;Easter&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2010-04-04 09:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">}</span>

        <span class="s5"># result will not be changed if the target is on the offset</span>
        <span class="s2">for </span><span class="s1">n </span><span class="s2">in </span><span class="s1">[</span>
            <span class="s3">&quot;Day&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;MonthBegin&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;SemiMonthBegin&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;YearBegin&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;Week&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;Hour&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;Minute&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;Second&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;Milli&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;Micro&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;Nano&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;DateOffset&quot;</span><span class="s2">,</span>
        <span class="s1">]:</span>
            <span class="s1">expecteds[n] = Timestamp(</span><span class="s3">&quot;2011/01/01 09:00&quot;</span><span class="s1">)</span>

        <span class="s5"># but be changed when normalize=True</span>
        <span class="s1">norm_expected = expecteds.copy()</span>
        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">norm_expected:</span>
            <span class="s1">norm_expected[k] = Timestamp(norm_expected[k].date())</span>

        <span class="s1">normalized = {</span>
            <span class="s3">&quot;Day&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2010-12-31 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;DateOffset&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2010-12-31 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;MonthBegin&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2010-12-01 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;SemiMonthBegin&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2010-12-15 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;YearBegin&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2010-01-01 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;Week&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2010-12-25 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;Hour&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2011-01-01 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;Minute&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2011-01-01 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;Second&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2011-01-01 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;Milli&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2011-01-01 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s3">&quot;Micro&quot;</span><span class="s1">: Timestamp(</span><span class="s3">&quot;2011-01-01 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">}</span>
        <span class="s1">norm_expected.update(normalized)</span>

        <span class="s1">sdt = datetime(</span><span class="s4">2011</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">ndt = np.datetime64(</span><span class="s3">&quot;2011-01-01 09:00&quot;</span><span class="s1">)</span>

        <span class="s2">for </span><span class="s1">dt </span><span class="s2">in </span><span class="s1">[sdt</span><span class="s2">, </span><span class="s1">ndt]:</span>
            <span class="s1">expected = expecteds[offset_types.__name__]</span>
            <span class="s1">self._check_offsetfunc_works(offset_types</span><span class="s2">, </span><span class="s3">&quot;rollback&quot;</span><span class="s2">, </span><span class="s1">dt</span><span class="s2">, </span><span class="s1">expected)</span>

            <span class="s1">expected = norm_expected[offset_types.__name__]</span>
            <span class="s1">self._check_offsetfunc_works(</span>
                <span class="s1">offset_types</span><span class="s2">, </span><span class="s3">&quot;rollback&quot;</span><span class="s2">, </span><span class="s1">dt</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">normalize=</span><span class="s2">True</span>
            <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_is_on_offset(self</span><span class="s2">, </span><span class="s1">offset_types</span><span class="s2">, </span><span class="s1">expecteds):</span>
        <span class="s1">dt = expecteds[offset_types.__name__]</span>
        <span class="s1">offset_s = _create_offset(offset_types)</span>
        <span class="s2">assert </span><span class="s1">offset_s.is_on_offset(dt)</span>

        <span class="s5"># when normalize=True, is_on_offset checks time is 00:00:00</span>
        <span class="s2">if </span><span class="s1">issubclass(offset_types</span><span class="s2">, </span><span class="s1">Tick):</span>
            <span class="s5"># normalize=True disallowed for Tick subclasses GH#21427</span>
            <span class="s2">return</span>
        <span class="s1">offset_n = _create_offset(offset_types</span><span class="s2">, </span><span class="s1">normalize=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">assert not </span><span class="s1">offset_n.is_on_offset(dt)</span>

        <span class="s2">if </span><span class="s1">offset_types </span><span class="s2">in </span><span class="s1">(BusinessHour</span><span class="s2">, </span><span class="s1">CustomBusinessHour):</span>
            <span class="s5"># In default BusinessHour (9:00-17:00), normalized time</span>
            <span class="s5"># cannot be in business hour range</span>
            <span class="s2">return</span>
        <span class="s1">date = datetime(dt.year</span><span class="s2">, </span><span class="s1">dt.month</span><span class="s2">, </span><span class="s1">dt.day)</span>
        <span class="s2">assert </span><span class="s1">offset_n.is_on_offset(date)</span>

    <span class="s2">def </span><span class="s1">test_add(self</span><span class="s2">, </span><span class="s1">offset_types</span><span class="s2">, </span><span class="s1">tz_naive_fixture</span><span class="s2">, </span><span class="s1">expecteds):</span>
        <span class="s1">tz = tz_naive_fixture</span>
        <span class="s1">dt = datetime(</span><span class="s4">2011</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">9</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">offset_s = _create_offset(offset_types)</span>
        <span class="s1">expected = expecteds[offset_types.__name__]</span>

        <span class="s1">result_dt = dt + offset_s</span>
        <span class="s1">result_ts = Timestamp(dt) + offset_s</span>
        <span class="s2">for </span><span class="s1">result </span><span class="s2">in </span><span class="s1">[result_dt</span><span class="s2">, </span><span class="s1">result_ts]:</span>
            <span class="s2">assert </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">Timestamp)</span>
            <span class="s2">assert </span><span class="s1">result == expected</span>

        <span class="s1">expected_localize = expected.tz_localize(tz)</span>
        <span class="s1">result = Timestamp(dt</span><span class="s2">, </span><span class="s1">tz=tz) + offset_s</span>
        <span class="s2">assert </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">Timestamp)</span>
        <span class="s2">assert </span><span class="s1">result == expected_localize</span>

        <span class="s5"># normalize=True, disallowed for Tick subclasses GH#21427</span>
        <span class="s2">if </span><span class="s1">issubclass(offset_types</span><span class="s2">, </span><span class="s1">Tick):</span>
            <span class="s2">return</span>
        <span class="s1">offset_s = _create_offset(offset_types</span><span class="s2">, </span><span class="s1">normalize=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">expected = Timestamp(expected.date())</span>

        <span class="s1">result_dt = dt + offset_s</span>
        <span class="s1">result_ts = Timestamp(dt) + offset_s</span>
        <span class="s2">for </span><span class="s1">result </span><span class="s2">in </span><span class="s1">[result_dt</span><span class="s2">, </span><span class="s1">result_ts]:</span>
            <span class="s2">assert </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">Timestamp)</span>
            <span class="s2">assert </span><span class="s1">result == expected</span>

        <span class="s1">expected_localize = expected.tz_localize(tz)</span>
        <span class="s1">result = Timestamp(dt</span><span class="s2">, </span><span class="s1">tz=tz) + offset_s</span>
        <span class="s2">assert </span><span class="s1">isinstance(result</span><span class="s2">, </span><span class="s1">Timestamp)</span>
        <span class="s2">assert </span><span class="s1">result == expected_localize</span>

    <span class="s2">def </span><span class="s1">test_add_empty_datetimeindex(self</span><span class="s2">, </span><span class="s1">offset_types</span><span class="s2">, </span><span class="s1">tz_naive_fixture):</span>
        <span class="s5"># GH#12724, GH#30336</span>
        <span class="s1">offset_s = _create_offset(offset_types)</span>

        <span class="s1">dti = DatetimeIndex([]</span><span class="s2">, </span><span class="s1">tz=tz_naive_fixture)</span>

        <span class="s1">warn = </span><span class="s2">None</span>
        <span class="s2">if </span><span class="s1">isinstance(</span>
            <span class="s1">offset_s</span><span class="s2">,</span>
            <span class="s1">(</span>
                <span class="s1">Easter</span><span class="s2">,</span>
                <span class="s1">WeekOfMonth</span><span class="s2">,</span>
                <span class="s1">LastWeekOfMonth</span><span class="s2">,</span>
                <span class="s1">CustomBusinessDay</span><span class="s2">,</span>
                <span class="s1">BusinessHour</span><span class="s2">,</span>
                <span class="s1">CustomBusinessHour</span><span class="s2">,</span>
                <span class="s1">CustomBusinessMonthBegin</span><span class="s2">,</span>
                <span class="s1">CustomBusinessMonthEnd</span><span class="s2">,</span>
                <span class="s1">FY5253</span><span class="s2">,</span>
                <span class="s1">FY5253Quarter</span><span class="s2">,</span>
            <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">):</span>
            <span class="s5"># We don't have an optimized apply_index</span>
            <span class="s1">warn = PerformanceWarning</span>

        <span class="s5"># stacklevel checking is slow, and we have ~800 of variants of this</span>
        <span class="s5">#  test, so let's only check the stacklevel in a subset of them</span>
        <span class="s1">check_stacklevel = tz_naive_fixture </span><span class="s2">is None</span>
        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(warn</span><span class="s2">, </span><span class="s1">check_stacklevel=check_stacklevel):</span>
            <span class="s1">result = dti + offset_s</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">dti)</span>
        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(warn</span><span class="s2">, </span><span class="s1">check_stacklevel=check_stacklevel):</span>
            <span class="s1">result = offset_s + dti</span>
        <span class="s1">tm.assert_index_equal(result</span><span class="s2">, </span><span class="s1">dti)</span>

        <span class="s1">dta = dti._data</span>
        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(warn</span><span class="s2">, </span><span class="s1">check_stacklevel=check_stacklevel):</span>
            <span class="s1">result = dta + offset_s</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">dta)</span>
        <span class="s2">with </span><span class="s1">tm.assert_produces_warning(warn</span><span class="s2">, </span><span class="s1">check_stacklevel=check_stacklevel):</span>
            <span class="s1">result = offset_s + dta</span>
        <span class="s1">tm.assert_equal(result</span><span class="s2">, </span><span class="s1">dta)</span>

    <span class="s2">def </span><span class="s1">test_pickle_roundtrip(self</span><span class="s2">, </span><span class="s1">offset_types):</span>
        <span class="s1">off = _create_offset(offset_types)</span>
        <span class="s1">res = tm.round_trip_pickle(off)</span>
        <span class="s2">assert </span><span class="s1">off == res</span>
        <span class="s2">if </span><span class="s1">type(off) </span><span class="s2">is not </span><span class="s1">DateOffset:</span>
            <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">off._attributes:</span>
                <span class="s2">if </span><span class="s1">attr == </span><span class="s3">&quot;calendar&quot;</span><span class="s1">:</span>
                    <span class="s5"># np.busdaycalendar __eq__ will return False;</span>
                    <span class="s5">#  we check holidays and weekmask attrs so are OK</span>
                    <span class="s2">continue</span>
                <span class="s5"># Make sure nothings got lost from _params (which __eq__) is based on</span>
                <span class="s2">assert </span><span class="s1">getattr(off</span><span class="s2">, </span><span class="s1">attr) == getattr(res</span><span class="s2">, </span><span class="s1">attr)</span>

    <span class="s2">def </span><span class="s1">test_pickle_dateoffset_odd_inputs(self):</span>
        <span class="s5"># GH#34511</span>
        <span class="s1">off = DateOffset(months=</span><span class="s4">12</span><span class="s1">)</span>
        <span class="s1">res = tm.round_trip_pickle(off)</span>
        <span class="s2">assert </span><span class="s1">off == res</span>

        <span class="s1">base_dt = datetime(</span><span class="s4">2020</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">base_dt + off == base_dt + res</span>

    <span class="s2">def </span><span class="s1">test_offsets_hashable(self</span><span class="s2">, </span><span class="s1">offset_types):</span>
        <span class="s5"># GH: 37267</span>
        <span class="s1">off = _create_offset(offset_types)</span>
        <span class="s2">assert </span><span class="s1">hash(off) </span><span class="s2">is not None</span>

    <span class="s1">@pytest.mark.filterwarnings(</span>
        <span class="s3">&quot;ignore:Non-vectorized DateOffset being applied to Series or DatetimeIndex&quot;</span>
    <span class="s1">)</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;unit&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;s&quot;</span><span class="s2">, </span><span class="s3">&quot;ms&quot;</span><span class="s2">, </span><span class="s3">&quot;us&quot;</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_add_dt64_ndarray_non_nano(self</span><span class="s2">, </span><span class="s1">offset_types</span><span class="s2">, </span><span class="s1">unit</span><span class="s2">, </span><span class="s1">request):</span>
        <span class="s5"># check that the result with non-nano matches nano</span>
        <span class="s1">off = _create_offset(offset_types)</span>

        <span class="s1">dti = date_range(</span><span class="s3">&quot;2016-01-01&quot;</span><span class="s2">, </span><span class="s1">periods=</span><span class="s4">35</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">&quot;D&quot;</span><span class="s1">)</span>

        <span class="s1">arr = dti._data._ndarray.astype(</span><span class="s3">f&quot;M8[</span><span class="s2">{</span><span class="s1">unit</span><span class="s2">}</span><span class="s3">]&quot;</span><span class="s1">)</span>
        <span class="s1">dta = type(dti._data)._simple_new(arr</span><span class="s2">, </span><span class="s1">dtype=arr.dtype)</span>

        <span class="s1">expected = dti._data + off</span>
        <span class="s1">result = dta + off</span>

        <span class="s1">exp_unit = unit</span>
        <span class="s2">if </span><span class="s1">isinstance(off</span><span class="s2">, </span><span class="s1">Tick) </span><span class="s2">and </span><span class="s1">off._creso &gt; dta._creso:</span>
            <span class="s5"># cast to higher reso like we would with Timedelta scalar</span>
            <span class="s1">exp_unit = Timedelta(off).unit</span>
        <span class="s1">expected = expected.as_unit(exp_unit)</span>

        <span class="s1">tm.assert_numpy_array_equal(result._ndarray</span><span class="s2">, </span><span class="s1">expected._ndarray)</span>


<span class="s2">class </span><span class="s1">TestDateOffset:</span>
    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">_offset_map.clear()</span>

    <span class="s2">def </span><span class="s1">test_repr(self):</span>
        <span class="s1">repr(DateOffset())</span>
        <span class="s1">repr(DateOffset(</span><span class="s4">2</span><span class="s1">))</span>
        <span class="s1">repr(</span><span class="s4">2 </span><span class="s1">* DateOffset())</span>
        <span class="s1">repr(</span><span class="s4">2 </span><span class="s1">* DateOffset(months=</span><span class="s4">2</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_mul(self):</span>
        <span class="s2">assert </span><span class="s1">DateOffset(</span><span class="s4">2</span><span class="s1">) == </span><span class="s4">2 </span><span class="s1">* DateOffset(</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">DateOffset(</span><span class="s4">2</span><span class="s1">) == DateOffset(</span><span class="s4">1</span><span class="s1">) * </span><span class="s4">2</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;kwd&quot;</span><span class="s2">, </span><span class="s1">sorted(liboffsets._relativedelta_kwds))</span>
    <span class="s2">def </span><span class="s1">test_constructor(self</span><span class="s2">, </span><span class="s1">kwd</span><span class="s2">, </span><span class="s1">request):</span>
        <span class="s2">if </span><span class="s1">kwd == </span><span class="s3">&quot;millisecond&quot;</span><span class="s1">:</span>
            <span class="s1">request.node.add_marker(</span>
                <span class="s1">pytest.mark.xfail(</span>
                    <span class="s1">raises=NotImplementedError</span><span class="s2">,</span>
                    <span class="s1">reason=</span><span class="s3">&quot;Constructing DateOffset object with `millisecond` is not &quot;</span>
                    <span class="s3">&quot;yet supported.&quot;</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s1">offset = DateOffset(**{kwd: </span><span class="s4">2</span><span class="s1">})</span>
        <span class="s2">assert </span><span class="s1">offset.kwds == {kwd: </span><span class="s4">2</span><span class="s1">}</span>
        <span class="s2">assert </span><span class="s1">getattr(offset</span><span class="s2">, </span><span class="s1">kwd) == </span><span class="s4">2</span>

    <span class="s2">def </span><span class="s1">test_default_constructor(self</span><span class="s2">, </span><span class="s1">dt):</span>
        <span class="s2">assert </span><span class="s1">(dt + DateOffset(</span><span class="s4">2</span><span class="s1">)) == datetime(</span><span class="s4">2008</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_is_anchored(self):</span>
        <span class="s2">assert not </span><span class="s1">DateOffset(</span><span class="s4">2</span><span class="s1">).is_anchored()</span>
        <span class="s2">assert </span><span class="s1">DateOffset(</span><span class="s4">1</span><span class="s1">).is_anchored()</span>

    <span class="s2">def </span><span class="s1">test_copy(self):</span>
        <span class="s2">assert </span><span class="s1">DateOffset(months=</span><span class="s4">2</span><span class="s1">).copy() == DateOffset(months=</span><span class="s4">2</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">DateOffset(milliseconds=</span><span class="s4">1</span><span class="s1">).copy() == DateOffset(milliseconds=</span><span class="s4">1</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;arithmatic_offset_type, expected&quot;</span><span class="s2">,</span>
        <span class="s1">zip(</span>
            <span class="s1">_ARITHMETIC_DATE_OFFSET</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s3">&quot;2009-01-02&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;2008-02-02&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;2008-01-09&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;2008-01-03&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;2008-01-02 01:00:00&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;2008-01-02 00:01:00&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;2008-01-02 00:00:01&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;2008-01-02 00:00:00.001000000&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;2008-01-02 00:00:00.000001000&quot;</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">)</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_add(self</span><span class="s2">, </span><span class="s1">arithmatic_offset_type</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">dt):</span>
        <span class="s2">assert </span><span class="s1">DateOffset(**{arithmatic_offset_type: </span><span class="s4">1</span><span class="s1">}) + dt == Timestamp(expected)</span>
        <span class="s2">assert </span><span class="s1">dt + DateOffset(**{arithmatic_offset_type: </span><span class="s4">1</span><span class="s1">}) == Timestamp(expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;arithmatic_offset_type, expected&quot;</span><span class="s2">,</span>
        <span class="s1">zip(</span>
            <span class="s1">_ARITHMETIC_DATE_OFFSET</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s3">&quot;2007-01-02&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;2007-12-02&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;2007-12-26&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;2008-01-01&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;2008-01-01 23:00:00&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;2008-01-01 23:59:00&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;2008-01-01 23:59:59&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;2008-01-01 23:59:59.999000000&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;2008-01-01 23:59:59.999999000&quot;</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">)</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_sub(self</span><span class="s2">, </span><span class="s1">arithmatic_offset_type</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">dt):</span>
        <span class="s2">assert </span><span class="s1">dt - DateOffset(**{arithmatic_offset_type: </span><span class="s4">1</span><span class="s1">}) == Timestamp(expected)</span>
        <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;Cannot subtract datetime from offset&quot;</span><span class="s1">):</span>
            <span class="s1">DateOffset(**{arithmatic_offset_type: </span><span class="s4">1</span><span class="s1">}) - dt</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;arithmatic_offset_type, n, expected&quot;</span><span class="s2">,</span>
        <span class="s1">zip(</span>
            <span class="s1">_ARITHMETIC_DATE_OFFSET</span><span class="s2">,</span>
            <span class="s1">range(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s3">&quot;2009-01-02&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;2008-03-02&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;2008-01-23&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;2008-01-06&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;2008-01-02 05:00:00&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;2008-01-02 00:06:00&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;2008-01-02 00:00:07&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;2008-01-02 00:00:00.008000000&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;2008-01-02 00:00:00.000009000&quot;</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">)</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_mul_add(self</span><span class="s2">, </span><span class="s1">arithmatic_offset_type</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">dt):</span>
        <span class="s2">assert </span><span class="s1">DateOffset(**{arithmatic_offset_type: </span><span class="s4">1</span><span class="s1">}) * n + dt == Timestamp(expected)</span>
        <span class="s2">assert </span><span class="s1">n * DateOffset(**{arithmatic_offset_type: </span><span class="s4">1</span><span class="s1">}) + dt == Timestamp(expected)</span>
        <span class="s2">assert </span><span class="s1">dt + DateOffset(**{arithmatic_offset_type: </span><span class="s4">1</span><span class="s1">}) * n == Timestamp(expected)</span>
        <span class="s2">assert </span><span class="s1">dt + n * DateOffset(**{arithmatic_offset_type: </span><span class="s4">1</span><span class="s1">}) == Timestamp(expected)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;arithmatic_offset_type, n, expected&quot;</span><span class="s2">,</span>
        <span class="s1">zip(</span>
            <span class="s1">_ARITHMETIC_DATE_OFFSET</span><span class="s2">,</span>
            <span class="s1">range(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">10</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">[</span>
                <span class="s3">&quot;2007-01-02&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;2007-11-02&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;2007-12-12&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;2007-12-29&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;2008-01-01 19:00:00&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;2008-01-01 23:54:00&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;2008-01-01 23:59:53&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;2008-01-01 23:59:59.992000000&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;2008-01-01 23:59:59.999991000&quot;</span><span class="s2">,</span>
            <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">)</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_mul_sub(self</span><span class="s2">, </span><span class="s1">arithmatic_offset_type</span><span class="s2">, </span><span class="s1">n</span><span class="s2">, </span><span class="s1">expected</span><span class="s2">, </span><span class="s1">dt):</span>
        <span class="s2">assert </span><span class="s1">dt - DateOffset(**{arithmatic_offset_type: </span><span class="s4">1</span><span class="s1">}) * n == Timestamp(expected)</span>
        <span class="s2">assert </span><span class="s1">dt - n * DateOffset(**{arithmatic_offset_type: </span><span class="s4">1</span><span class="s1">}) == Timestamp(expected)</span>

    <span class="s2">def </span><span class="s1">test_leap_year(self):</span>
        <span class="s1">d = datetime(</span><span class="s4">2008</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">31</span><span class="s1">)</span>
        <span class="s2">assert </span><span class="s1">(d + DateOffset(months=</span><span class="s4">1</span><span class="s1">)) == datetime(</span><span class="s4">2008</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s4">29</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_eq(self):</span>
        <span class="s1">offset1 = DateOffset(days=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">offset2 = DateOffset(days=</span><span class="s4">365</span><span class="s1">)</span>

        <span class="s2">assert </span><span class="s1">offset1 != offset2</span>

        <span class="s2">assert </span><span class="s1">DateOffset(milliseconds=</span><span class="s4">3</span><span class="s1">) != DateOffset(milliseconds=</span><span class="s4">7</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span>
        <span class="s3">&quot;offset_kwargs, expected_arg&quot;</span><span class="s2">,</span>
        <span class="s1">[</span>
            <span class="s1">({</span><span class="s3">&quot;microseconds&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s2">, </span><span class="s3">&quot;milliseconds&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s1">}</span><span class="s2">, </span><span class="s3">&quot;2022-01-01 00:00:00.001001&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">({</span><span class="s3">&quot;seconds&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s2">, </span><span class="s3">&quot;milliseconds&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s1">}</span><span class="s2">, </span><span class="s3">&quot;2022-01-01 00:00:01.001&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">({</span><span class="s3">&quot;minutes&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s2">, </span><span class="s3">&quot;milliseconds&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s1">}</span><span class="s2">, </span><span class="s3">&quot;2022-01-01 00:01:00.001&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">({</span><span class="s3">&quot;hours&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s2">, </span><span class="s3">&quot;milliseconds&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s1">}</span><span class="s2">, </span><span class="s3">&quot;2022-01-01 01:00:00.001&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">({</span><span class="s3">&quot;days&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s2">, </span><span class="s3">&quot;milliseconds&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s1">}</span><span class="s2">, </span><span class="s3">&quot;2022-01-02 00:00:00.001&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">({</span><span class="s3">&quot;weeks&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s2">, </span><span class="s3">&quot;milliseconds&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s1">}</span><span class="s2">, </span><span class="s3">&quot;2022-01-08 00:00:00.001&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">({</span><span class="s3">&quot;months&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s2">, </span><span class="s3">&quot;milliseconds&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s1">}</span><span class="s2">, </span><span class="s3">&quot;2022-02-01 00:00:00.001&quot;</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">({</span><span class="s3">&quot;years&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s2">, </span><span class="s3">&quot;milliseconds&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s1">}</span><span class="s2">, </span><span class="s3">&quot;2023-01-01 00:00:00.001&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">]</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s2">def </span><span class="s1">test_milliseconds_combination(self</span><span class="s2">, </span><span class="s1">offset_kwargs</span><span class="s2">, </span><span class="s1">expected_arg):</span>
        <span class="s5"># GH 49897</span>
        <span class="s1">offset = DateOffset(**offset_kwargs)</span>
        <span class="s1">ts = Timestamp(</span><span class="s3">&quot;2022-01-01&quot;</span><span class="s1">)</span>
        <span class="s1">result = ts + offset</span>
        <span class="s1">expected = Timestamp(expected_arg)</span>

        <span class="s2">assert </span><span class="s1">result == expected</span>

    <span class="s2">def </span><span class="s1">test_offset_invalid_arguments(self):</span>
        <span class="s1">msg = </span><span class="s3">&quot;^Invalid argument/s or bad combination of arguments&quot;</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
            <span class="s1">DateOffset(picoseconds=</span><span class="s4">1</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestOffsetNames:</span>
    <span class="s2">def </span><span class="s1">test_get_offset_name(self):</span>
        <span class="s2">assert </span><span class="s1">BDay().freqstr == </span><span class="s3">&quot;B&quot;</span>
        <span class="s2">assert </span><span class="s1">BDay(</span><span class="s4">2</span><span class="s1">).freqstr == </span><span class="s3">&quot;2B&quot;</span>
        <span class="s2">assert </span><span class="s1">BMonthEnd().freqstr == </span><span class="s3">&quot;BM&quot;</span>
        <span class="s2">assert </span><span class="s1">Week(weekday=</span><span class="s4">0</span><span class="s1">).freqstr == </span><span class="s3">&quot;W-MON&quot;</span>
        <span class="s2">assert </span><span class="s1">Week(weekday=</span><span class="s4">1</span><span class="s1">).freqstr == </span><span class="s3">&quot;W-TUE&quot;</span>
        <span class="s2">assert </span><span class="s1">Week(weekday=</span><span class="s4">2</span><span class="s1">).freqstr == </span><span class="s3">&quot;W-WED&quot;</span>
        <span class="s2">assert </span><span class="s1">Week(weekday=</span><span class="s4">3</span><span class="s1">).freqstr == </span><span class="s3">&quot;W-THU&quot;</span>
        <span class="s2">assert </span><span class="s1">Week(weekday=</span><span class="s4">4</span><span class="s1">).freqstr == </span><span class="s3">&quot;W-FRI&quot;</span>

        <span class="s2">assert </span><span class="s1">LastWeekOfMonth(weekday=WeekDay.SUN).freqstr == </span><span class="s3">&quot;LWOM-SUN&quot;</span>


<span class="s2">def </span><span class="s1">test_get_offset():</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=INVALID_FREQ_ERR_MSG):</span>
        <span class="s1">_get_offset(</span><span class="s3">&quot;gibberish&quot;</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=INVALID_FREQ_ERR_MSG):</span>
        <span class="s1">_get_offset(</span><span class="s3">&quot;QS-JAN-B&quot;</span><span class="s1">)</span>

    <span class="s1">pairs = [</span>
        <span class="s1">(</span><span class="s3">&quot;B&quot;</span><span class="s2">, </span><span class="s1">BDay())</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;b&quot;</span><span class="s2">, </span><span class="s1">BDay())</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;bm&quot;</span><span class="s2">, </span><span class="s1">BMonthEnd())</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;Bm&quot;</span><span class="s2">, </span><span class="s1">BMonthEnd())</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;W-MON&quot;</span><span class="s2">, </span><span class="s1">Week(weekday=</span><span class="s4">0</span><span class="s1">))</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;W-TUE&quot;</span><span class="s2">, </span><span class="s1">Week(weekday=</span><span class="s4">1</span><span class="s1">))</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;W-WED&quot;</span><span class="s2">, </span><span class="s1">Week(weekday=</span><span class="s4">2</span><span class="s1">))</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;W-THU&quot;</span><span class="s2">, </span><span class="s1">Week(weekday=</span><span class="s4">3</span><span class="s1">))</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s3">&quot;W-FRI&quot;</span><span class="s2">, </span><span class="s1">Week(weekday=</span><span class="s4">4</span><span class="s1">))</span><span class="s2">,</span>
    <span class="s1">]</span>

    <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">expected </span><span class="s2">in </span><span class="s1">pairs:</span>
        <span class="s1">offset = _get_offset(name)</span>
        <span class="s2">assert </span><span class="s1">offset == expected</span><span class="s2">, </span><span class="s1">(</span>
            <span class="s3">f&quot;Expected </span><span class="s2">{</span><span class="s1">repr(name)</span><span class="s2">} </span><span class="s3">to yield </span><span class="s2">{</span><span class="s1">repr(expected)</span><span class="s2">} </span><span class="s3">&quot;</span>
            <span class="s3">f&quot;(actual: </span><span class="s2">{</span><span class="s1">repr(offset)</span><span class="s2">}</span><span class="s3">)&quot;</span>
        <span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_get_offset_legacy():</span>
    <span class="s1">pairs = [(</span><span class="s3">&quot;w@Sat&quot;</span><span class="s2">, </span><span class="s1">Week(weekday=</span><span class="s4">5</span><span class="s1">))]</span>
    <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">expected </span><span class="s2">in </span><span class="s1">pairs:</span>
        <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=INVALID_FREQ_ERR_MSG):</span>
            <span class="s1">_get_offset(name)</span>


<span class="s2">class </span><span class="s1">TestOffsetAliases:</span>
    <span class="s2">def </span><span class="s1">setup_method(self):</span>
        <span class="s1">_offset_map.clear()</span>

    <span class="s2">def </span><span class="s1">test_alias_equality(self):</span>
        <span class="s2">for </span><span class="s1">k</span><span class="s2">, </span><span class="s1">v </span><span class="s2">in </span><span class="s1">_offset_map.items():</span>
            <span class="s2">if </span><span class="s1">v </span><span class="s2">is None</span><span class="s1">:</span>
                <span class="s2">continue</span>
            <span class="s2">assert </span><span class="s1">k == v.copy()</span>

    <span class="s2">def </span><span class="s1">test_rule_code(self):</span>
        <span class="s1">lst = [</span><span class="s3">&quot;M&quot;</span><span class="s2">, </span><span class="s3">&quot;MS&quot;</span><span class="s2">, </span><span class="s3">&quot;BM&quot;</span><span class="s2">, </span><span class="s3">&quot;BMS&quot;</span><span class="s2">, </span><span class="s3">&quot;D&quot;</span><span class="s2">, </span><span class="s3">&quot;B&quot;</span><span class="s2">, </span><span class="s3">&quot;H&quot;</span><span class="s2">, </span><span class="s3">&quot;T&quot;</span><span class="s2">, </span><span class="s3">&quot;S&quot;</span><span class="s2">, </span><span class="s3">&quot;L&quot;</span><span class="s2">, </span><span class="s3">&quot;U&quot;</span><span class="s1">]</span>
        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">lst:</span>
            <span class="s2">assert </span><span class="s1">k == _get_offset(k).rule_code</span>
            <span class="s5"># should be cached - this is kind of an internals test...</span>
            <span class="s2">assert </span><span class="s1">k </span><span class="s2">in </span><span class="s1">_offset_map</span>
            <span class="s2">assert </span><span class="s1">k == (_get_offset(k) * </span><span class="s4">3</span><span class="s1">).rule_code</span>

        <span class="s1">suffix_lst = [</span><span class="s3">&quot;MON&quot;</span><span class="s2">, </span><span class="s3">&quot;TUE&quot;</span><span class="s2">, </span><span class="s3">&quot;WED&quot;</span><span class="s2">, </span><span class="s3">&quot;THU&quot;</span><span class="s2">, </span><span class="s3">&quot;FRI&quot;</span><span class="s2">, </span><span class="s3">&quot;SAT&quot;</span><span class="s2">, </span><span class="s3">&quot;SUN&quot;</span><span class="s1">]</span>
        <span class="s1">base = </span><span class="s3">&quot;W&quot;</span>
        <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">suffix_lst:</span>
            <span class="s1">alias = </span><span class="s3">&quot;-&quot;</span><span class="s1">.join([base</span><span class="s2">, </span><span class="s1">v])</span>
            <span class="s2">assert </span><span class="s1">alias == _get_offset(alias).rule_code</span>
            <span class="s2">assert </span><span class="s1">alias == (_get_offset(alias) * </span><span class="s4">5</span><span class="s1">).rule_code</span>

        <span class="s1">suffix_lst = [</span>
            <span class="s3">&quot;JAN&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;FEB&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;MAR&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;APR&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;MAY&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;JUN&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;JUL&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;AUG&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;SEP&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;OCT&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;NOV&quot;</span><span class="s2">,</span>
            <span class="s3">&quot;DEC&quot;</span><span class="s2">,</span>
        <span class="s1">]</span>
        <span class="s1">base_lst = [</span><span class="s3">&quot;A&quot;</span><span class="s2">, </span><span class="s3">&quot;AS&quot;</span><span class="s2">, </span><span class="s3">&quot;BA&quot;</span><span class="s2">, </span><span class="s3">&quot;BAS&quot;</span><span class="s2">, </span><span class="s3">&quot;Q&quot;</span><span class="s2">, </span><span class="s3">&quot;QS&quot;</span><span class="s2">, </span><span class="s3">&quot;BQ&quot;</span><span class="s2">, </span><span class="s3">&quot;BQS&quot;</span><span class="s1">]</span>
        <span class="s2">for </span><span class="s1">base </span><span class="s2">in </span><span class="s1">base_lst:</span>
            <span class="s2">for </span><span class="s1">v </span><span class="s2">in </span><span class="s1">suffix_lst:</span>
                <span class="s1">alias = </span><span class="s3">&quot;-&quot;</span><span class="s1">.join([base</span><span class="s2">, </span><span class="s1">v])</span>
                <span class="s2">assert </span><span class="s1">alias == _get_offset(alias).rule_code</span>
                <span class="s2">assert </span><span class="s1">alias == (_get_offset(alias) * </span><span class="s4">5</span><span class="s1">).rule_code</span>


<span class="s2">def </span><span class="s1">test_freq_offsets():</span>
    <span class="s1">off = BDay(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">offset=timedelta(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1800</span><span class="s1">))</span>
    <span class="s2">assert </span><span class="s1">off.freqstr == </span><span class="s3">&quot;B+30Min&quot;</span>

    <span class="s1">off = BDay(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">offset=timedelta(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1800</span><span class="s1">))</span>
    <span class="s2">assert </span><span class="s1">off.freqstr == </span><span class="s3">&quot;B-30Min&quot;</span>


<span class="s2">class </span><span class="s1">TestReprNames:</span>
    <span class="s2">def </span><span class="s1">test_str_for_named_is_name(self):</span>
        <span class="s5"># look at all the amazing combinations!</span>
        <span class="s1">month_prefixes = [</span><span class="s3">&quot;A&quot;</span><span class="s2">, </span><span class="s3">&quot;AS&quot;</span><span class="s2">, </span><span class="s3">&quot;BA&quot;</span><span class="s2">, </span><span class="s3">&quot;BAS&quot;</span><span class="s2">, </span><span class="s3">&quot;Q&quot;</span><span class="s2">, </span><span class="s3">&quot;BQ&quot;</span><span class="s2">, </span><span class="s3">&quot;BQS&quot;</span><span class="s2">, </span><span class="s3">&quot;QS&quot;</span><span class="s1">]</span>
        <span class="s1">names = [</span>
            <span class="s1">prefix + </span><span class="s3">&quot;-&quot; </span><span class="s1">+ month</span>
            <span class="s2">for </span><span class="s1">prefix </span><span class="s2">in </span><span class="s1">month_prefixes</span>
            <span class="s2">for </span><span class="s1">month </span><span class="s2">in </span><span class="s1">[</span>
                <span class="s3">&quot;JAN&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;FEB&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;MAR&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;APR&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;MAY&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;JUN&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;JUL&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;AUG&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;SEP&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;OCT&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;NOV&quot;</span><span class="s2">,</span>
                <span class="s3">&quot;DEC&quot;</span><span class="s2">,</span>
            <span class="s1">]</span>
        <span class="s1">]</span>
        <span class="s1">days = [</span><span class="s3">&quot;MON&quot;</span><span class="s2">, </span><span class="s3">&quot;TUE&quot;</span><span class="s2">, </span><span class="s3">&quot;WED&quot;</span><span class="s2">, </span><span class="s3">&quot;THU&quot;</span><span class="s2">, </span><span class="s3">&quot;FRI&quot;</span><span class="s2">, </span><span class="s3">&quot;SAT&quot;</span><span class="s2">, </span><span class="s3">&quot;SUN&quot;</span><span class="s1">]</span>
        <span class="s1">names += [</span><span class="s3">&quot;W-&quot; </span><span class="s1">+ day </span><span class="s2">for </span><span class="s1">day </span><span class="s2">in </span><span class="s1">days]</span>
        <span class="s1">names += [</span><span class="s3">&quot;WOM-&quot; </span><span class="s1">+ week + day </span><span class="s2">for </span><span class="s1">week </span><span class="s2">in </span><span class="s1">(</span><span class="s3">&quot;1&quot;</span><span class="s2">, </span><span class="s3">&quot;2&quot;</span><span class="s2">, </span><span class="s3">&quot;3&quot;</span><span class="s2">, </span><span class="s3">&quot;4&quot;</span><span class="s1">) </span><span class="s2">for </span><span class="s1">day </span><span class="s2">in </span><span class="s1">days]</span>
        <span class="s1">_offset_map.clear()</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">names:</span>
            <span class="s1">offset = _get_offset(name)</span>
            <span class="s2">assert </span><span class="s1">offset.freqstr == name</span>


<span class="s5"># ---------------------------------------------------------------------</span>


<span class="s2">def </span><span class="s1">test_valid_default_arguments(offset_types):</span>
    <span class="s5"># GH#19142 check that the calling the constructors without passing</span>
    <span class="s5"># any keyword arguments produce valid offsets</span>
    <span class="s1">cls = offset_types</span>
    <span class="s1">cls()</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;kwd&quot;</span><span class="s2">, </span><span class="s1">sorted(liboffsets._relativedelta_kwds))</span>
<span class="s2">def </span><span class="s1">test_valid_month_attributes(kwd</span><span class="s2">, </span><span class="s1">month_classes):</span>
    <span class="s5"># GH#18226</span>
    <span class="s1">cls = month_classes</span>
    <span class="s5"># check that we cannot create e.g. MonthEnd(weeks=3)</span>
    <span class="s1">msg = </span><span class="s3">rf&quot;__init__\(\) got an unexpected keyword argument '</span><span class="s2">{</span><span class="s1">kwd</span><span class="s2">}</span><span class="s3">'&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">cls(**{kwd: </span><span class="s4">3</span><span class="s1">})</span>


<span class="s2">def </span><span class="s1">test_month_offset_name(month_classes):</span>
    <span class="s5"># GH#33757 off.name with n != 1 should not raise AttributeError</span>
    <span class="s1">obj = month_classes(</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">obj2 = month_classes(</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">obj2.name == obj.name</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;kwd&quot;</span><span class="s2">, </span><span class="s1">sorted(liboffsets._relativedelta_kwds))</span>
<span class="s2">def </span><span class="s1">test_valid_relativedelta_kwargs(kwd</span><span class="s2">, </span><span class="s1">request):</span>
    <span class="s2">if </span><span class="s1">kwd == </span><span class="s3">&quot;millisecond&quot;</span><span class="s1">:</span>
        <span class="s1">request.node.add_marker(</span>
            <span class="s1">pytest.mark.xfail(</span>
                <span class="s1">raises=NotImplementedError</span><span class="s2">,</span>
                <span class="s1">reason=</span><span class="s3">&quot;Constructing DateOffset object with `millisecond` is not &quot;</span>
                <span class="s3">&quot;yet supported.&quot;</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s1">)</span>
    <span class="s5"># Check that all the arguments specified in liboffsets._relativedelta_kwds</span>
    <span class="s5"># are in fact valid relativedelta keyword args</span>
    <span class="s1">DateOffset(**{kwd: </span><span class="s4">1</span><span class="s1">})</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;kwd&quot;</span><span class="s2">, </span><span class="s1">sorted(liboffsets._relativedelta_kwds))</span>
<span class="s2">def </span><span class="s1">test_valid_tick_attributes(kwd</span><span class="s2">, </span><span class="s1">tick_classes):</span>
    <span class="s5"># GH#18226</span>
    <span class="s1">cls = tick_classes</span>
    <span class="s5"># check that we cannot create e.g. Hour(weeks=3)</span>
    <span class="s1">msg = </span><span class="s3">rf&quot;__init__\(\) got an unexpected keyword argument '</span><span class="s2">{</span><span class="s1">kwd</span><span class="s2">}</span><span class="s3">'&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">cls(**{kwd: </span><span class="s4">3</span><span class="s1">})</span>


<span class="s2">def </span><span class="s1">test_validate_n_error():</span>
    <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;argument must be an integer&quot;</span><span class="s1">):</span>
        <span class="s1">DateOffset(n=</span><span class="s3">&quot;Doh!&quot;</span><span class="s1">)</span>

    <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;argument must be an integer&quot;</span><span class="s1">):</span>
        <span class="s1">MonthBegin(n=timedelta(</span><span class="s4">1</span><span class="s1">))</span>

    <span class="s2">with </span><span class="s1">pytest.raises(TypeError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;argument must be an integer&quot;</span><span class="s1">):</span>
        <span class="s1">BDay(n=np.array([</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">dtype=np.int64))</span>


<span class="s2">def </span><span class="s1">test_require_integers(offset_types):</span>
    <span class="s1">cls = offset_types</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=</span><span class="s3">&quot;argument must be an integer&quot;</span><span class="s1">):</span>
        <span class="s1">cls(n=</span><span class="s4">1.5</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_tick_normalize_raises(tick_classes):</span>
    <span class="s5"># check that trying to create a Tick object with normalize=True raises</span>
    <span class="s5"># GH#21427</span>
    <span class="s1">cls = tick_classes</span>
    <span class="s1">msg = </span><span class="s3">&quot;Tick offset with `normalize=True` are not allowed.&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">cls(n=</span><span class="s4">3</span><span class="s2">, </span><span class="s1">normalize=</span><span class="s2">True</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;offset_kwargs, expected_arg&quot;</span><span class="s2">,</span>
    <span class="s1">[</span>
        <span class="s1">({</span><span class="s3">&quot;nanoseconds&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s1">}</span><span class="s2">, </span><span class="s3">&quot;1970-01-01 00:00:00.000000001&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">({</span><span class="s3">&quot;nanoseconds&quot;</span><span class="s1">: </span><span class="s4">5</span><span class="s1">}</span><span class="s2">, </span><span class="s3">&quot;1970-01-01 00:00:00.000000005&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">({</span><span class="s3">&quot;nanoseconds&quot;</span><span class="s1">: -</span><span class="s4">1</span><span class="s1">}</span><span class="s2">, </span><span class="s3">&quot;1969-12-31 23:59:59.999999999&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">({</span><span class="s3">&quot;microseconds&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s1">}</span><span class="s2">, </span><span class="s3">&quot;1970-01-01 00:00:00.000001&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">({</span><span class="s3">&quot;microseconds&quot;</span><span class="s1">: -</span><span class="s4">1</span><span class="s1">}</span><span class="s2">, </span><span class="s3">&quot;1969-12-31 23:59:59.999999&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">({</span><span class="s3">&quot;seconds&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s1">}</span><span class="s2">, </span><span class="s3">&quot;1970-01-01 00:00:01&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">({</span><span class="s3">&quot;seconds&quot;</span><span class="s1">: -</span><span class="s4">1</span><span class="s1">}</span><span class="s2">, </span><span class="s3">&quot;1969-12-31 23:59:59&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">({</span><span class="s3">&quot;minutes&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s1">}</span><span class="s2">, </span><span class="s3">&quot;1970-01-01 00:01:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">({</span><span class="s3">&quot;minutes&quot;</span><span class="s1">: -</span><span class="s4">1</span><span class="s1">}</span><span class="s2">, </span><span class="s3">&quot;1969-12-31 23:59:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">({</span><span class="s3">&quot;hours&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s1">}</span><span class="s2">, </span><span class="s3">&quot;1970-01-01 01:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">({</span><span class="s3">&quot;hours&quot;</span><span class="s1">: -</span><span class="s4">1</span><span class="s1">}</span><span class="s2">, </span><span class="s3">&quot;1969-12-31 23:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">({</span><span class="s3">&quot;days&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s1">}</span><span class="s2">, </span><span class="s3">&quot;1970-01-02 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">({</span><span class="s3">&quot;days&quot;</span><span class="s1">: -</span><span class="s4">1</span><span class="s1">}</span><span class="s2">, </span><span class="s3">&quot;1969-12-31 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">({</span><span class="s3">&quot;weeks&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s1">}</span><span class="s2">, </span><span class="s3">&quot;1970-01-08 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">({</span><span class="s3">&quot;weeks&quot;</span><span class="s1">: -</span><span class="s4">1</span><span class="s1">}</span><span class="s2">, </span><span class="s3">&quot;1969-12-25 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">({</span><span class="s3">&quot;months&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s1">}</span><span class="s2">, </span><span class="s3">&quot;1970-02-01 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">({</span><span class="s3">&quot;months&quot;</span><span class="s1">: -</span><span class="s4">1</span><span class="s1">}</span><span class="s2">, </span><span class="s3">&quot;1969-12-01 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">({</span><span class="s3">&quot;years&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s1">}</span><span class="s2">, </span><span class="s3">&quot;1971-01-01 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">({</span><span class="s3">&quot;years&quot;</span><span class="s1">: -</span><span class="s4">1</span><span class="s1">}</span><span class="s2">, </span><span class="s3">&quot;1969-01-01 00:00:00&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_dateoffset_add_sub(offset_kwargs</span><span class="s2">, </span><span class="s1">expected_arg):</span>
    <span class="s1">offset = DateOffset(**offset_kwargs)</span>
    <span class="s1">ts = Timestamp(</span><span class="s4">0</span><span class="s1">)</span>
    <span class="s1">result = ts + offset</span>
    <span class="s1">expected = Timestamp(expected_arg)</span>
    <span class="s2">assert </span><span class="s1">result == expected</span>
    <span class="s1">result -= offset</span>
    <span class="s2">assert </span><span class="s1">result == ts</span>
    <span class="s1">result = offset + ts</span>
    <span class="s2">assert </span><span class="s1">result == expected</span>


<span class="s2">def </span><span class="s1">test_dateoffset_add_sub_timestamp_with_nano():</span>
    <span class="s1">offset = DateOffset(minutes=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">nanoseconds=</span><span class="s4">9</span><span class="s1">)</span>
    <span class="s1">ts = Timestamp(</span><span class="s4">4</span><span class="s1">)</span>
    <span class="s1">result = ts + offset</span>
    <span class="s1">expected = Timestamp(</span><span class="s3">&quot;1970-01-01 00:02:00.000000013&quot;</span><span class="s1">)</span>
    <span class="s2">assert </span><span class="s1">result == expected</span>
    <span class="s1">result -= offset</span>
    <span class="s2">assert </span><span class="s1">result == ts</span>
    <span class="s1">result = offset + ts</span>
    <span class="s2">assert </span><span class="s1">result == expected</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;attribute&quot;</span><span class="s2">,</span>
    <span class="s1">[</span>
        <span class="s3">&quot;hours&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;days&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;weeks&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;months&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;years&quot;</span><span class="s2">,</span>
    <span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_dateoffset_immutable(attribute):</span>
    <span class="s1">offset = DateOffset(**{attribute: </span><span class="s4">0</span><span class="s1">})</span>
    <span class="s1">msg = </span><span class="s3">&quot;DateOffset objects are immutable&quot;</span>
    <span class="s2">with </span><span class="s1">pytest.raises(AttributeError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">setattr(offset</span><span class="s2">, </span><span class="s1">attribute</span><span class="s2">, </span><span class="s4">5</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_dateoffset_misc():</span>
    <span class="s1">oset = offsets.DateOffset(months=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">days=</span><span class="s4">4</span><span class="s1">)</span>
    <span class="s5"># it works</span>
    <span class="s1">oset.freqstr</span>

    <span class="s2">assert not </span><span class="s1">offsets.DateOffset(months=</span><span class="s4">2</span><span class="s1">) == </span><span class="s4">2</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;n&quot;</span><span class="s2">, </span><span class="s1">[-</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">3</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_construct_int_arg_no_kwargs_assumed_days(n):</span>
    <span class="s5"># GH 45890, 45643</span>
    <span class="s1">offset = DateOffset(n)</span>
    <span class="s2">assert </span><span class="s1">offset._offset == timedelta(</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">result = Timestamp(</span><span class="s4">2022</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s1">) + offset</span>
    <span class="s1">expected = Timestamp(</span><span class="s4">2022</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">2 </span><span class="s1">+ n)</span>
    <span class="s2">assert </span><span class="s1">result == expected</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;offset, expected&quot;</span><span class="s2">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span>
            <span class="s1">DateOffset(minutes=</span><span class="s4">7</span><span class="s2">, </span><span class="s1">nanoseconds=</span><span class="s4">18</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">Timestamp(</span><span class="s3">&quot;2022-01-01 00:07:00.000000018&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(DateOffset(nanoseconds=</span><span class="s4">3</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;2022-01-01 00:00:00.000000003&quot;</span><span class="s1">))</span><span class="s2">,</span>
    <span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_dateoffset_add_sub_timestamp_series_with_nano(offset</span><span class="s2">, </span><span class="s1">expected):</span>
    <span class="s5"># GH 47856</span>
    <span class="s1">start_time = Timestamp(</span><span class="s3">&quot;2022-01-01&quot;</span><span class="s1">)</span>
    <span class="s1">teststamp = start_time</span>
    <span class="s1">testseries = Series([start_time])</span>
    <span class="s1">testseries = testseries + offset</span>
    <span class="s2">assert </span><span class="s1">testseries[</span><span class="s4">0</span><span class="s1">] == expected</span>
    <span class="s1">testseries -= offset</span>
    <span class="s2">assert </span><span class="s1">testseries[</span><span class="s4">0</span><span class="s1">] == teststamp</span>
    <span class="s1">testseries = offset + testseries</span>
    <span class="s2">assert </span><span class="s1">testseries[</span><span class="s4">0</span><span class="s1">] == expected</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s3">&quot;n_months, scaling_factor, start_timestamp, expected_timestamp&quot;</span><span class="s2">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">2</span><span class="s2">, </span><span class="s3">&quot;2020-01-30&quot;</span><span class="s2">, </span><span class="s3">&quot;2020-03-30&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s3">&quot;2020-01-30&quot;</span><span class="s2">, </span><span class="s3">&quot;2020-03-30&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s3">&quot;2020-01-30&quot;</span><span class="s2">, </span><span class="s3">&quot;2020-01-30&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">2</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s3">&quot;2020-01-30&quot;</span><span class="s2">, </span><span class="s3">&quot;2020-01-30&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s3">&quot;2020-01-30&quot;</span><span class="s2">, </span><span class="s3">&quot;2019-12-30&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">-</span><span class="s4">1</span><span class="s2">, </span><span class="s3">&quot;2020-01-30&quot;</span><span class="s2">, </span><span class="s3">&quot;2019-11-30&quot;</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">]</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">def </span><span class="s1">test_offset_multiplication(</span>
    <span class="s1">n_months</span><span class="s2">, </span><span class="s1">scaling_factor</span><span class="s2">, </span><span class="s1">start_timestamp</span><span class="s2">, </span><span class="s1">expected_timestamp</span>
<span class="s1">):</span>
    <span class="s5"># GH 47953</span>
    <span class="s1">mo1 = DateOffset(months=n_months)</span>

    <span class="s1">startscalar = Timestamp(start_timestamp)</span>
    <span class="s1">startarray = Series([startscalar])</span>

    <span class="s1">resultscalar = startscalar + (mo1 * scaling_factor)</span>
    <span class="s1">resultarray = startarray + (mo1 * scaling_factor)</span>

    <span class="s1">expectedscalar = Timestamp(expected_timestamp)</span>
    <span class="s1">expectedarray = Series([expectedscalar])</span>
    <span class="s2">assert </span><span class="s1">resultscalar == expectedscalar</span>

    <span class="s1">tm.assert_series_equal(resultarray</span><span class="s2">, </span><span class="s1">expectedarray)</span>


<span class="s2">def </span><span class="s1">test_dateoffset_operations_on_dataframes():</span>
    <span class="s5"># GH 47953</span>
    <span class="s1">df = DataFrame({</span><span class="s3">&quot;T&quot;</span><span class="s1">: [Timestamp(</span><span class="s3">&quot;2019-04-30&quot;</span><span class="s1">)]</span><span class="s2">, </span><span class="s3">&quot;D&quot;</span><span class="s1">: [DateOffset(months=</span><span class="s4">1</span><span class="s1">)]})</span>
    <span class="s1">frameresult1 = df[</span><span class="s3">&quot;T&quot;</span><span class="s1">] + </span><span class="s4">26 </span><span class="s1">* df[</span><span class="s3">&quot;D&quot;</span><span class="s1">]</span>
    <span class="s1">df2 = DataFrame(</span>
        <span class="s1">{</span>
            <span class="s3">&quot;T&quot;</span><span class="s1">: [Timestamp(</span><span class="s3">&quot;2019-04-30&quot;</span><span class="s1">)</span><span class="s2">, </span><span class="s1">Timestamp(</span><span class="s3">&quot;2019-04-30&quot;</span><span class="s1">)]</span><span class="s2">,</span>
            <span class="s3">&quot;D&quot;</span><span class="s1">: [DateOffset(months=</span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">DateOffset(months=</span><span class="s4">1</span><span class="s1">)]</span><span class="s2">,</span>
        <span class="s1">}</span>
    <span class="s1">)</span>
    <span class="s1">expecteddate = Timestamp(</span><span class="s3">&quot;2021-06-30&quot;</span><span class="s1">)</span>
    <span class="s2">with </span><span class="s1">tm.assert_produces_warning(PerformanceWarning):</span>
        <span class="s1">frameresult2 = df2[</span><span class="s3">&quot;T&quot;</span><span class="s1">] + </span><span class="s4">26 </span><span class="s1">* df2[</span><span class="s3">&quot;D&quot;</span><span class="s1">]</span>

    <span class="s2">assert </span><span class="s1">frameresult1[</span><span class="s4">0</span><span class="s1">] == expecteddate</span>
    <span class="s2">assert </span><span class="s1">frameresult2[</span><span class="s4">0</span><span class="s1">] == expecteddate</span>
</pre>
</body>
</html>