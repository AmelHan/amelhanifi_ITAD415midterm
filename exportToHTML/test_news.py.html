<html>
<head>
<title>test_news.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_news.py</font>
</center></td></tr></table>
<pre><span class="s0">r&quot;&quot;&quot; 
Tests for news results 
 
Author: Chad Fulton 
License: BSD-3 
&quot;&quot;&quot;</span>
<span class="s2">from </span><span class="s1">statsmodels.compat.pandas </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">assert_frame_equal</span><span class="s2">,</span>
    <span class="s1">assert_series_equal</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">numpy.testing </span><span class="s2">import </span><span class="s1">assert_</span><span class="s2">, </span><span class="s1">assert_allclose</span><span class="s2">, </span><span class="s1">assert_equal</span>
<span class="s2">import </span><span class="s1">pandas </span><span class="s2">as </span><span class="s1">pd</span>
<span class="s2">import </span><span class="s1">pytest</span>

<span class="s2">from </span><span class="s1">statsmodels </span><span class="s2">import </span><span class="s1">datasets</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.statespace </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">dynamic_factor</span><span class="s2">,</span>
    <span class="s1">sarimax</span><span class="s2">,</span>
    <span class="s1">structural</span><span class="s2">,</span>
    <span class="s1">varmax</span><span class="s2">,</span>
<span class="s1">)</span>

<span class="s1">dta = datasets.macrodata.load_pandas().data</span>
<span class="s1">dta.index = pd.period_range(start=</span><span class="s3">'1959Q1'</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">'2009Q3'</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">'Q'</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">check_impact_indices(news</span><span class="s2">, </span><span class="s1">impact_dates</span><span class="s2">, </span><span class="s1">impacted_variables):</span>
    <span class="s4"># Note: the index for impacts is only a time index, because we compute</span>
    <span class="s4"># impacts for all variables during these time periods.</span>
    <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'total_impacts'</span><span class="s2">, </span><span class="s3">'update_impacts'</span><span class="s2">, </span><span class="s3">'revision_impacts'</span><span class="s2">,</span>
                 <span class="s3">'post_impacted_forecasts'</span><span class="s2">, </span><span class="s3">'prev_impacted_forecasts'</span><span class="s1">]:</span>
        <span class="s1">val = getattr(news</span><span class="s2">, </span><span class="s1">attr)</span>
        <span class="s1">assert_(val.index.equals(impact_dates))</span>
        <span class="s1">assert_equal(val.columns.tolist()</span><span class="s2">, </span><span class="s1">impacted_variables)</span>


<span class="s2">def </span><span class="s1">check_revision_indices(news</span><span class="s2">, </span><span class="s1">revisions_index):</span>
    <span class="s4"># Note: revision indices must be a MultiIndex, because for each time</span>
    <span class="s4"># period, not all variables necessarily revised.</span>

    <span class="s4"># If there are no revisions, we just check the length is zero</span>
    <span class="s2">if </span><span class="s1">news.news_results.revision_impacts </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">assert_equal(len(news.revisions_iloc[</span><span class="s3">'revision date'</span><span class="s1">])</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">assert_equal(len(news.revisions_iloc[</span><span class="s3">'revised variable'</span><span class="s1">])</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">assert_equal(len(news.revisions_ix[</span><span class="s3">'revision date'</span><span class="s1">])</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">assert_equal(len(news.revisions_ix[</span><span class="s3">'revised variable'</span><span class="s1">])</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s4"># Otherwise, check that the revision indexes are correct</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s4"># Get the integer locations of the given indexes</span>
        <span class="s1">dates = news.previous.model._index</span>
        <span class="s1">endog_names = news.previous.model.endog_names</span>
        <span class="s2">if </span><span class="s1">isinstance(endog_names</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">endog_names = [endog_names]</span>
        <span class="s1">desired_ix = revisions_index.to_frame().reset_index(drop=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">desired_iloc = desired_ix.copy()</span>
        <span class="s1">desired_iloc[</span><span class="s3">'revision date'</span><span class="s1">] = [</span>
            <span class="s1">dates.get_loc(date) </span><span class="s2">for </span><span class="s1">date </span><span class="s2">in </span><span class="s1">desired_ix[</span><span class="s3">'revision date'</span><span class="s1">]]</span>
        <span class="s1">desired_iloc[</span><span class="s3">'revised variable'</span><span class="s1">] = [</span>
            <span class="s1">endog_names.index(name)</span>
            <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">desired_ix[</span><span class="s3">'revised variable'</span><span class="s1">]]</span>

        <span class="s1">assert_(news.revisions_iloc.equals(</span>
            <span class="s1">desired_iloc.astype(news.revisions_iloc.dtypes)))</span>
        <span class="s1">assert_(news.revisions_ix.equals(desired_ix))</span>


<span class="s2">def </span><span class="s1">check_update_indices(news</span><span class="s2">, </span><span class="s1">updates_index):</span>
    <span class="s4"># Note: update indices are also a MultiIndex, for the same reason as the</span>
    <span class="s4"># revision indices.</span>
    <span class="s4"># If there are no updates, we just check the length is zero</span>
    <span class="s2">if </span><span class="s1">news.news_results.update_impacts </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">assert_equal(len(news.updates_iloc[</span><span class="s3">'update date'</span><span class="s1">])</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">assert_equal(len(news.updates_iloc[</span><span class="s3">'updated variable'</span><span class="s1">])</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">assert_equal(len(news.updates_ix[</span><span class="s3">'update date'</span><span class="s1">])</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">assert_equal(len(news.updates_ix[</span><span class="s3">'updated variable'</span><span class="s1">])</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s4"># Otherwise, check that the revision indexes are correct</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s4"># Get the integer locations of the given indexes</span>
        <span class="s1">dates = news.updated.model._index</span>
        <span class="s1">endog_names = news.updated.model.endog_names</span>
        <span class="s2">if </span><span class="s1">isinstance(endog_names</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">endog_names = [endog_names]</span>
        <span class="s1">desired_ix = updates_index.to_frame().reset_index(drop=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">desired_iloc = desired_ix.copy()</span>
        <span class="s1">desired_iloc[</span><span class="s3">'update date'</span><span class="s1">] = [</span>
            <span class="s1">dates.get_loc(date) </span><span class="s2">for </span><span class="s1">date </span><span class="s2">in </span><span class="s1">desired_ix[</span><span class="s3">'update date'</span><span class="s1">]]</span>
        <span class="s1">desired_iloc[</span><span class="s3">'updated variable'</span><span class="s1">] = [</span>
            <span class="s1">endog_names.index(name)</span>
            <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">desired_ix[</span><span class="s3">'updated variable'</span><span class="s1">]]</span>

        <span class="s1">assert_(news.updates_iloc.equals(</span>
            <span class="s1">desired_iloc.astype(news.updates_iloc.dtypes)))</span>
        <span class="s1">assert_(news.updates_ix.equals(desired_ix))</span>


<span class="s2">def </span><span class="s1">check_news_indices(news</span><span class="s2">, </span><span class="s1">updates_index</span><span class="s2">, </span><span class="s1">impact_dates):</span>
    <span class="s4"># News are computed only from updates, so the news indices are the same as</span>
    <span class="s4"># the update indices</span>
    <span class="s2">if </span><span class="s1">len(updates_index):</span>
        <span class="s1">news_index = updates_index</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">news_index = pd.MultiIndex.from_product(</span>
            <span class="s1">[[]</span><span class="s2">, </span><span class="s1">[]]</span><span class="s2">, </span><span class="s1">names=[</span><span class="s3">'update date'</span><span class="s2">, </span><span class="s3">'updated variable'</span><span class="s1">])</span>
    <span class="s1">endog_names = news.previous.model.endog_names</span>
    <span class="s2">if </span><span class="s1">isinstance(endog_names</span><span class="s2">, </span><span class="s1">str):</span>
        <span class="s1">endog_names = [endog_names]</span>

    <span class="s1">assert_(news.news.index.equals(news_index))</span>
    <span class="s1">assert_(news.update_forecasts.index.equals(news_index))</span>
    <span class="s1">assert_(news.update_realized.index.equals(news_index))</span>
    <span class="s1">assert_(news.weights.index.equals(news_index))</span>

    <span class="s1">weights_columns = pd.MultiIndex.from_product([impact_dates</span><span class="s2">, </span><span class="s1">endog_names])</span>
    <span class="s1">assert_(news.weights.columns.equals(weights_columns))</span>


<span class="s2">def </span><span class="s1">check_news(news</span><span class="s2">, </span><span class="s1">revisions</span><span class="s2">, </span><span class="s1">updates</span><span class="s2">, </span><span class="s1">impact_dates</span><span class="s2">, </span><span class="s1">impacted_variables</span><span class="s2">,</span>
               <span class="s1">revisions_index</span><span class="s2">, </span><span class="s1">updates_index</span><span class="s2">,</span>
               <span class="s1">revision_impacts</span><span class="s2">, </span><span class="s1">update_impacts</span><span class="s2">,</span>
               <span class="s1">prev_impacted_forecasts</span><span class="s2">, </span><span class="s1">post_impacted_forecasts</span><span class="s2">,</span>
               <span class="s1">update_forecasts</span><span class="s2">, </span><span class="s1">update_realized</span><span class="s2">, </span><span class="s1">news_desired</span><span class="s2">, </span><span class="s1">weights):</span>
    <span class="s4"># Note: we use atol=1e-12 to handle cases where impacts, etc. are equal to</span>
    <span class="s4"># zero, but numerical precision of the Kalman filter procedures gives an</span>
    <span class="s4"># answer of e.g. 1e-16.</span>

    <span class="s4"># Note: Here we set the tolerance to be slightly negative, since some of</span>
    <span class="s4"># the tests have weights or impacts exactly equal to zero, while we still</span>
    <span class="s4"># want to include those in tests.</span>
    <span class="s1">news.tolerance = -</span><span class="s5">1e-10</span>

    <span class="s4"># - Indexes --------------------------------------------------------------</span>
    <span class="s4"># Index of impacts</span>
    <span class="s1">check_impact_indices(news</span><span class="s2">, </span><span class="s1">impact_dates</span><span class="s2">, </span><span class="s1">impacted_variables)</span>

    <span class="s4"># Reivision indices</span>
    <span class="s1">check_revision_indices(news</span><span class="s2">, </span><span class="s1">revisions_index)</span>

    <span class="s4"># Update indices</span>
    <span class="s1">check_update_indices(news</span><span class="s2">, </span><span class="s1">updates_index)</span>

    <span class="s4"># News indices</span>
    <span class="s1">check_news_indices(news</span><span class="s2">, </span><span class="s1">updates_index</span><span class="s2">, </span><span class="s1">impact_dates)</span>

    <span class="s4"># - Impacts --------------------------------------------------------------</span>
    <span class="s2">if </span><span class="s1">updates:</span>
        <span class="s1">assert_allclose(news.update_impacts</span><span class="s2">, </span><span class="s1">update_impacts</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-12</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">assert_(np.all(news.update_impacts.isnull()))</span>

    <span class="s4"># Impacts from revisions</span>
    <span class="s2">if </span><span class="s1">revisions:</span>
        <span class="s1">assert_allclose(news.revision_impacts</span><span class="s2">, </span><span class="s1">revision_impacts</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-12</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">assert_(news.news_results.revision_impacts </span><span class="s2">is None</span><span class="s1">)</span>
        <span class="s1">assert_(np.all(news.revision_impacts.isnull()))</span>

    <span class="s4"># Total impacts</span>
    <span class="s1">total_impacts = (news.revision_impacts.fillna(</span><span class="s5">0</span><span class="s1">) +</span>
                     <span class="s1">news.update_impacts.fillna(</span><span class="s5">0</span><span class="s1">))</span>
    <span class="s1">assert_allclose(news.total_impacts</span><span class="s2">, </span><span class="s1">total_impacts</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-12</span><span class="s1">)</span>

    <span class="s4"># - Impacted variable forecasts ------------------------------------------</span>
    <span class="s1">assert_allclose(news.prev_impacted_forecasts</span><span class="s2">, </span><span class="s1">prev_impacted_forecasts</span><span class="s2">,</span>
                    <span class="s1">atol=</span><span class="s5">1e-12</span><span class="s1">)</span>
    <span class="s1">assert_allclose(news.post_impacted_forecasts</span><span class="s2">, </span><span class="s1">post_impacted_forecasts</span><span class="s2">,</span>
                    <span class="s1">atol=</span><span class="s5">1e-12</span><span class="s1">)</span>

    <span class="s4"># - News -----------------------------------------------------------------</span>
    <span class="s1">assert_allclose(news.update_forecasts</span><span class="s2">, </span><span class="s1">update_forecasts</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-12</span><span class="s1">)</span>
    <span class="s1">assert_allclose(news.update_realized</span><span class="s2">, </span><span class="s1">update_realized</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-12</span><span class="s1">)</span>
    <span class="s4"># The &quot;news&quot; is simply the forecast error</span>
    <span class="s1">assert_allclose(news.news</span><span class="s2">, </span><span class="s1">news_desired</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-12</span><span class="s1">)</span>
    <span class="s4"># The weight is zero on previously known data, and is geometrically</span>
    <span class="s4"># declining (according to the AR parameter) in the forecast period</span>
    <span class="s1">assert_allclose(news.weights</span><span class="s2">, </span><span class="s1">weights</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-12</span><span class="s1">)</span>

    <span class="s4"># - Table: data revisions ------------------------------------------------</span>
    <span class="s1">assert_equal(news.data_revisions.columns.tolist()</span><span class="s2">,</span>
                 <span class="s1">[</span><span class="s3">'revised'</span><span class="s2">, </span><span class="s3">'observed (prev)'</span><span class="s1">])</span>
    <span class="s1">assert_equal(news.data_revisions.index.names</span><span class="s2">,</span>
                 <span class="s1">[</span><span class="s3">'revision date'</span><span class="s2">, </span><span class="s3">'revised variable'</span><span class="s1">])</span>
    <span class="s1">assert_(news.data_revisions.index.equals(revisions_index))</span>

    <span class="s4"># - Table: data updates --------------------------------------------------</span>
    <span class="s1">assert_equal(news.data_updates.columns.tolist()</span><span class="s2">,</span>
                 <span class="s1">[</span><span class="s3">'observed'</span><span class="s2">, </span><span class="s3">'forecast (prev)'</span><span class="s1">])</span>
    <span class="s1">assert_equal(news.data_updates.index.names</span><span class="s2">,</span>
                 <span class="s1">[</span><span class="s3">'update date'</span><span class="s2">, </span><span class="s3">'updated variable'</span><span class="s1">])</span>
    <span class="s1">assert_(news.data_updates.index.equals(news.news.index))</span>
    <span class="s1">assert_allclose(news.data_updates[</span><span class="s3">'forecast (prev)'</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s1">news.update_forecasts</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-12</span><span class="s1">)</span>
    <span class="s1">assert_allclose(news.data_updates[</span><span class="s3">'observed'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">news.update_realized</span><span class="s2">,</span>
                    <span class="s1">atol=</span><span class="s5">1e-12</span><span class="s1">)</span>

    <span class="s4"># - Table: details_by_impact ---------------------------------------------</span>
    <span class="s1">details_by_impact = news.details_by_impact</span>
    <span class="s1">desired = [</span><span class="s3">'observed'</span><span class="s2">, </span><span class="s3">'forecast (prev)'</span><span class="s2">, </span><span class="s3">'news'</span><span class="s2">, </span><span class="s3">'weight'</span><span class="s2">, </span><span class="s3">'impact'</span><span class="s1">]</span>
    <span class="s1">assert_equal(details_by_impact.columns.tolist()</span><span class="s2">, </span><span class="s1">desired)</span>
    <span class="s1">desired = [</span><span class="s3">'impact date'</span><span class="s2">, </span><span class="s3">'impacted variable'</span><span class="s2">,</span>
               <span class="s3">'update date'</span><span class="s2">, </span><span class="s3">'updated variable'</span><span class="s1">]</span>
    <span class="s1">assert_equal(details_by_impact.index.names</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s2">if </span><span class="s1">updates:</span>
        <span class="s1">actual = (news.details_by_impact[</span><span class="s3">'forecast (prev)'</span><span class="s1">]</span>
                      <span class="s1">.drop_duplicates()</span>
                      <span class="s1">.reset_index([</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">])[</span><span class="s3">'forecast (prev)'</span><span class="s1">])</span>
        <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">news.update_forecasts</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-12</span><span class="s1">)</span>
        <span class="s1">actual = (news.details_by_impact[</span><span class="s3">'observed'</span><span class="s1">]</span>
                      <span class="s1">.drop_duplicates().reset_index([</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">])[</span><span class="s3">'observed'</span><span class="s1">])</span>
        <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">news.update_realized</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-12</span><span class="s1">)</span>
        <span class="s1">actual = (news.details_by_impact[</span><span class="s3">'news'</span><span class="s1">]</span>
                      <span class="s1">.drop_duplicates().reset_index([</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">])[</span><span class="s3">'news'</span><span class="s1">])</span>
        <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">news.news</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-12</span><span class="s1">)</span>

        <span class="s4"># Weights</span>
        <span class="s1">assert_allclose(details_by_impact[</span><span class="s3">'weight'</span><span class="s1">].unstack([</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">])</span><span class="s2">,</span>
                        <span class="s1">news.weights</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-12</span><span class="s1">)</span>

        <span class="s4"># Impact of news</span>
        <span class="s1">actual = (news.details_by_impact[</span><span class="s3">'impact'</span><span class="s1">]</span>
                      <span class="s1">.unstack([</span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s1">]).sum(axis=</span><span class="s5">1</span><span class="s1">).unstack(</span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">news.update_impacts</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-12</span><span class="s1">)</span>

    <span class="s4"># - Table: details_by_update ---------------------------------------------</span>
    <span class="s1">details_by_update = news.details_by_update</span>
    <span class="s1">desired = [</span><span class="s3">'news'</span><span class="s2">, </span><span class="s3">'weight'</span><span class="s2">, </span><span class="s3">'impact'</span><span class="s1">]</span>
    <span class="s1">assert_equal(details_by_update.columns.tolist()</span><span class="s2">, </span><span class="s1">desired)</span>
    <span class="s1">desired = [</span><span class="s3">'update date'</span><span class="s2">, </span><span class="s3">'updated variable'</span><span class="s2">, </span><span class="s3">'observed'</span><span class="s2">,</span>
               <span class="s3">'forecast (prev)'</span><span class="s2">, </span><span class="s3">'impact date'</span><span class="s2">, </span><span class="s3">'impacted variable'</span><span class="s1">]</span>
    <span class="s1">assert_equal(details_by_update.index.names</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s2">if </span><span class="s1">updates:</span>
        <span class="s4"># News</span>
        <span class="s4"># Special case for Pandas = 0.23, see above</span>
        <span class="s1">actual = (news.details_by_update[</span><span class="s3">'news'</span><span class="s1">]</span>
                      <span class="s1">.drop_duplicates().reset_index([</span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s5">5</span><span class="s1">])[</span><span class="s3">'news'</span><span class="s1">])</span>
        <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">news.news</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-12</span><span class="s1">)</span>

        <span class="s4"># Weights</span>
        <span class="s1">assert_allclose(news.details_by_update[</span><span class="s3">'weight'</span><span class="s1">].unstack([</span><span class="s5">4</span><span class="s2">, </span><span class="s5">5</span><span class="s1">])</span><span class="s2">,</span>
                        <span class="s1">news.weights</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-12</span><span class="s1">)</span>

        <span class="s4"># Impact of news</span>
        <span class="s1">actual = (news.details_by_update[</span><span class="s3">'impact'</span><span class="s1">]</span>
                      <span class="s1">.unstack([</span><span class="s5">4</span><span class="s2">, </span><span class="s5">5</span><span class="s1">]).sum(axis=</span><span class="s5">0</span><span class="s1">).unstack(</span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">news.update_impacts</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-12</span><span class="s1">)</span>

    <span class="s4"># - Table: impacts -------------------------------------------------------</span>
    <span class="s1">impacts = news.impacts</span>
    <span class="s1">desired = [</span><span class="s3">'estimate (prev)'</span><span class="s2">, </span><span class="s3">'impact of revisions'</span><span class="s2">, </span><span class="s3">'impact of news'</span><span class="s2">,</span>
               <span class="s3">'total impact'</span><span class="s2">, </span><span class="s3">'estimate (new)'</span><span class="s1">]</span>
    <span class="s1">assert_equal(impacts.columns.tolist()</span><span class="s2">, </span><span class="s1">desired)</span>
    <span class="s1">desired = [</span><span class="s3">'impact date'</span><span class="s2">, </span><span class="s3">'impacted variable'</span><span class="s1">]</span>
    <span class="s1">assert_equal(impacts.index.names</span><span class="s2">, </span><span class="s1">desired)</span>

    <span class="s1">assert_allclose(impacts.loc[:</span><span class="s2">, </span><span class="s3">'estimate (prev)'</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s1">news.prev_impacted_forecasts.stack()</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-12</span><span class="s1">)</span>
    <span class="s1">assert_allclose(impacts.loc[:</span><span class="s2">, </span><span class="s3">'impact of revisions'</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s1">news.revision_impacts.fillna(</span><span class="s5">0</span><span class="s1">).stack()</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-12</span><span class="s1">)</span>
    <span class="s1">assert_allclose(impacts.loc[:</span><span class="s2">, </span><span class="s3">'impact of news'</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s1">news.update_impacts.fillna(</span><span class="s5">0</span><span class="s1">).stack()</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-12</span><span class="s1">)</span>
    <span class="s1">assert_allclose(impacts.loc[:</span><span class="s2">, </span><span class="s3">'total impact'</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s1">news.total_impacts.stack()</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-12</span><span class="s1">)</span>
    <span class="s1">assert_allclose(impacts.loc[:</span><span class="s2">, </span><span class="s3">'estimate (new)'</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s1">news.post_impacted_forecasts.stack()</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-12</span><span class="s1">)</span>


<span class="s4"># @pytest.mark.parametrize('revisions', [True, False])</span>
<span class="s4"># @pytest.mark.parametrize('updates', [True, False])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'revisions'</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'updates'</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_sarimax_time_invariant(revisions</span><span class="s2">, </span><span class="s1">updates):</span>
    <span class="s4"># Construct previous and updated datasets</span>
    <span class="s1">endog = dta[</span><span class="s3">'infl'</span><span class="s1">].copy()</span>
    <span class="s1">comparison_type = </span><span class="s2">None</span>
    <span class="s2">if </span><span class="s1">updates:</span>
        <span class="s1">endog1 = endog.loc[:</span><span class="s3">'2009Q2'</span><span class="s1">].copy()</span>
        <span class="s1">endog2 = endog.loc[:</span><span class="s3">'2009Q3'</span><span class="s1">].copy()</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">endog1 = endog.loc[:</span><span class="s3">'2009Q3'</span><span class="s1">].copy()</span>
        <span class="s1">endog2 = endog.loc[:</span><span class="s3">'2009Q3'</span><span class="s1">].copy()</span>
        <span class="s4"># Without updates and without NaN values, we need to specify that</span>
        <span class="s4"># the type of the comparison object that we're passing is &quot;updated&quot;</span>
        <span class="s1">comparison_type = </span><span class="s3">'updated'</span>
    <span class="s2">if </span><span class="s1">revisions:</span>
        <span class="s1">endog1.iloc[-</span><span class="s5">1</span><span class="s1">] = </span><span class="s5">0.</span>

    <span class="s4"># Get the previous results object and compute the news</span>
    <span class="s1">mod = sarimax.SARIMAX(endog1)</span>
    <span class="s1">res = mod.smooth([</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">1.0</span><span class="s1">])</span>
    <span class="s1">news = res.news(endog2</span><span class="s2">, </span><span class="s1">start=</span><span class="s3">'2009Q2'</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">'2010Q1'</span><span class="s2">,</span>
                    <span class="s1">comparison_type=comparison_type)</span>

    <span class="s4"># Compute the true values for each combination of (revsions, updates)</span>
    <span class="s1">impact_dates = pd.period_range(start=</span><span class="s3">'2009Q2'</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">'2010Q1'</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">'Q'</span><span class="s1">)</span>
    <span class="s1">impacted_variables = [</span><span class="s3">'infl'</span><span class="s1">]</span>

    <span class="s4"># Revisions</span>
    <span class="s2">if </span><span class="s1">revisions </span><span class="s2">and </span><span class="s1">updates:</span>
        <span class="s1">revisions_index = pd.MultiIndex.from_arrays(</span>
            <span class="s1">[endog1.index[-</span><span class="s5">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">'infl'</span><span class="s1">]]</span><span class="s2">,</span>
            <span class="s1">names=[</span><span class="s3">'revision date'</span><span class="s2">, </span><span class="s3">'revised variable'</span><span class="s1">])</span>
        <span class="s4"># If we have updates, the revision is to 2009Q2</span>
        <span class="s1">revision_impacts = endog2.iloc[-</span><span class="s5">2</span><span class="s1">] * </span><span class="s5">0.5</span><span class="s1">**np.arange(</span><span class="s5">4</span><span class="s1">).reshape(</span><span class="s5">4</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s2">elif </span><span class="s1">revisions:</span>
        <span class="s1">revisions_index = pd.MultiIndex.from_arrays(</span>
            <span class="s1">[endog1.index[-</span><span class="s5">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">'infl'</span><span class="s1">]]</span><span class="s2">,</span>
            <span class="s1">names=[</span><span class="s3">'revision date'</span><span class="s2">, </span><span class="s3">'revised variable'</span><span class="s1">])</span>
        <span class="s4"># With no updates, the revision is to 2009Q3</span>
        <span class="s1">revision_impacts = np.r_[</span>
            <span class="s5">0</span><span class="s2">, </span><span class="s1">endog2.iloc[-</span><span class="s5">1</span><span class="s1">] * </span><span class="s5">0.5</span><span class="s1">**np.arange(</span><span class="s5">3</span><span class="s1">)].reshape(</span><span class="s5">4</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">revisions_index = pd.MultiIndex.from_arrays(</span>
            <span class="s1">[[]</span><span class="s2">, </span><span class="s1">[]]</span><span class="s2">, </span><span class="s1">names=[</span><span class="s3">'revision date'</span><span class="s2">, </span><span class="s3">'revised variable'</span><span class="s1">])</span>
        <span class="s1">revision_impacts = </span><span class="s2">None</span>

    <span class="s4"># Updates</span>
    <span class="s2">if </span><span class="s1">updates:</span>
        <span class="s1">updates_index = pd.MultiIndex.from_arrays(</span>
            <span class="s1">[pd.period_range(start=</span><span class="s3">'2009Q3'</span><span class="s2">, </span><span class="s1">periods=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">'Q'</span><span class="s1">)</span><span class="s2">, </span><span class="s1">[</span><span class="s3">'infl'</span><span class="s1">]]</span><span class="s2">,</span>
            <span class="s1">names=[</span><span class="s3">'update date'</span><span class="s2">, </span><span class="s3">'updated variable'</span><span class="s1">])</span>
        <span class="s1">update_impacts = np.array([[</span>
            <span class="s5">0</span><span class="s2">, </span><span class="s1">endog.loc[</span><span class="s3">'2009Q3'</span><span class="s1">] - </span><span class="s5">0.5 </span><span class="s1">* endog.loc[</span><span class="s3">'2009Q2'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s5">0.5 </span><span class="s1">* endog.loc[</span><span class="s3">'2009Q3'</span><span class="s1">] - </span><span class="s5">0.5</span><span class="s1">**</span><span class="s5">2 </span><span class="s1">* endog.loc[</span><span class="s3">'2009Q2'</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s5">0.5</span><span class="s1">**</span><span class="s5">2 </span><span class="s1">* endog.loc[</span><span class="s3">'2009Q3'</span><span class="s1">] - </span><span class="s5">0.5</span><span class="s1">**</span><span class="s5">3 </span><span class="s1">* endog.loc[</span><span class="s3">'2009Q2'</span><span class="s1">]]]).T</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">updates_index = pd.MultiIndex.from_arrays(</span>
            <span class="s1">[[]</span><span class="s2">, </span><span class="s1">[]]</span><span class="s2">, </span><span class="s1">names=[</span><span class="s3">'update date'</span><span class="s2">, </span><span class="s3">'updated variable'</span><span class="s1">])</span>
        <span class="s1">update_impacts = </span><span class="s2">None</span>
    <span class="s1">print(update_impacts)</span>

    <span class="s4"># Impact forecasts</span>
    <span class="s2">if </span><span class="s1">updates:</span>
        <span class="s1">prev_impacted_forecasts = np.r_[</span>
            <span class="s1">endog1.iloc[-</span><span class="s5">1</span><span class="s1">] * </span><span class="s5">0.5</span><span class="s1">**np.arange(</span><span class="s5">4</span><span class="s1">)].reshape(</span><span class="s5">4</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">prev_impacted_forecasts = np.r_[</span>
            <span class="s1">endog1.iloc[-</span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">endog1.iloc[-</span><span class="s5">1</span><span class="s1">] * </span><span class="s5">0.5</span><span class="s1">**np.arange(</span><span class="s5">3</span><span class="s1">)].reshape(</span><span class="s5">4</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">post_impacted_forecasts = np.r_[</span>
        <span class="s1">endog2.iloc[-</span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s5">0.5 </span><span class="s1">** np.arange(</span><span class="s5">3</span><span class="s1">) * endog2.iloc[-</span><span class="s5">1</span><span class="s1">]].reshape(</span><span class="s5">4</span><span class="s2">, </span><span class="s5">1</span><span class="s1">)</span>

    <span class="s4"># News</span>
    <span class="s2">if </span><span class="s1">updates:</span>
        <span class="s4"># Note: update_forecasts is created using the endog2 dataset even if</span>
        <span class="s4"># there were revisions, because it should be computed after revisions</span>
        <span class="s4"># have already been taken into account</span>
        <span class="s1">update_forecasts = [</span><span class="s5">0.5 </span><span class="s1">* endog2.loc[</span><span class="s3">'2009Q2'</span><span class="s1">]]</span>
        <span class="s1">update_realized = [endog2.loc[</span><span class="s3">'2009Q3'</span><span class="s1">]]</span>
        <span class="s1">news_desired = [update_realized[i] - update_forecasts[i]</span>
                        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(update_forecasts))]</span>
        <span class="s1">weights = pd.DataFrame(np.r_[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0.5</span><span class="s1">**np.arange(</span><span class="s5">3</span><span class="s1">)]).T</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">update_forecasts = pd.Series([]</span><span class="s2">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s1">update_realized = pd.Series([]</span><span class="s2">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s1">news_desired = pd.Series([]</span><span class="s2">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s1">weights = pd.DataFrame(np.zeros((</span><span class="s5">0</span><span class="s2">, </span><span class="s5">4</span><span class="s1">)))</span>

    <span class="s4"># Run unit tests</span>
    <span class="s1">check_news(news</span><span class="s2">, </span><span class="s1">revisions</span><span class="s2">, </span><span class="s1">updates</span><span class="s2">, </span><span class="s1">impact_dates</span><span class="s2">, </span><span class="s1">impacted_variables</span><span class="s2">,</span>
               <span class="s1">revisions_index</span><span class="s2">, </span><span class="s1">updates_index</span><span class="s2">,</span>
               <span class="s1">revision_impacts</span><span class="s2">, </span><span class="s1">update_impacts</span><span class="s2">,</span>
               <span class="s1">prev_impacted_forecasts</span><span class="s2">, </span><span class="s1">post_impacted_forecasts</span><span class="s2">,</span>
               <span class="s1">update_forecasts</span><span class="s2">, </span><span class="s1">update_realized</span><span class="s2">, </span><span class="s1">news_desired</span><span class="s2">, </span><span class="s1">weights)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'revisions'</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'updates'</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'which'</span><span class="s2">, </span><span class="s1">[</span><span class="s3">'exog'</span><span class="s2">, </span><span class="s3">'trend'</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_sarimax_time_varying(revisions</span><span class="s2">, </span><span class="s1">updates</span><span class="s2">, </span><span class="s1">which):</span>
    <span class="s4"># This is primarily a test that the `news` method works with a time-varying</span>
    <span class="s4"># setup (i.e. time-varying state space matrices). It tests a time-varying</span>
    <span class="s4"># SARIMAX model where the time-varying component has been set to zeros</span>
    <span class="s4"># against a time-invariant version of the model.</span>

    <span class="s4"># Construct previous and updated datasets</span>
    <span class="s1">endog = dta[</span><span class="s3">'infl'</span><span class="s1">].copy()</span>
    <span class="s1">comparison_type = </span><span class="s2">None</span>
    <span class="s2">if </span><span class="s1">updates:</span>
        <span class="s1">endog1 = endog.loc[:</span><span class="s3">'2009Q2'</span><span class="s1">].copy()</span>
        <span class="s1">endog2 = endog.loc[:</span><span class="s3">'2009Q3'</span><span class="s1">].copy()</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">endog1 = endog.loc[:</span><span class="s3">'2009Q3'</span><span class="s1">].copy()</span>
        <span class="s1">endog2 = endog.loc[:</span><span class="s3">'2009Q3'</span><span class="s1">].copy()</span>
        <span class="s4"># Without updates and without NaN values, we need to specify that</span>
        <span class="s4"># the type of the comparison object that we're passing is &quot;updated&quot;</span>
        <span class="s1">comparison_type = </span><span class="s3">'updated'</span>
    <span class="s2">if </span><span class="s1">revisions:</span>
        <span class="s1">endog1.iloc[-</span><span class="s5">1</span><span class="s1">] = </span><span class="s5">0.</span>

    <span class="s1">exog1 = </span><span class="s2">None</span>
    <span class="s1">exog2 = </span><span class="s2">None</span>
    <span class="s1">trend = </span><span class="s3">'n'</span>
    <span class="s2">if </span><span class="s1">which == </span><span class="s3">'exog'</span><span class="s1">:</span>
        <span class="s1">exog1 = np.ones_like(endog1)</span>
        <span class="s1">exog2 = np.ones_like(endog2)</span>
    <span class="s2">elif </span><span class="s1">which == </span><span class="s3">'trend'</span><span class="s1">:</span>
        <span class="s1">trend = </span><span class="s3">'t'</span>

    <span class="s4"># Compute the news from a model with a trend/exog term (so the model is</span>
    <span class="s4"># time-varying), but with the coefficient set to zero (so that it will be</span>
    <span class="s4"># equivalent to the time-invariant model)</span>
    <span class="s1">mod1 = sarimax.SARIMAX(endog1</span><span class="s2">, </span><span class="s1">exog=exog1</span><span class="s2">, </span><span class="s1">trend=trend)</span>
    <span class="s1">res1 = mod1.smooth([</span><span class="s5">0.</span><span class="s2">, </span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">1.0</span><span class="s1">])</span>
    <span class="s1">news1 = res1.news(endog2</span><span class="s2">, </span><span class="s1">exog=exog2</span><span class="s2">, </span><span class="s1">start=</span><span class="s3">'2008Q1'</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">'2009Q3'</span><span class="s2">,</span>
                      <span class="s1">comparison_type=comparison_type)</span>

    <span class="s4"># Compute the news from a model without a trend term</span>
    <span class="s1">mod2 = sarimax.SARIMAX(endog1)</span>
    <span class="s1">res2 = mod2.smooth([</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">1.0</span><span class="s1">])</span>
    <span class="s1">news2 = res2.news(endog2</span><span class="s2">, </span><span class="s1">start=</span><span class="s3">'2008Q1'</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">'2009Q3'</span><span class="s2">,</span>
                      <span class="s1">comparison_type=comparison_type)</span>

    <span class="s1">attrs = [</span><span class="s3">'total_impacts'</span><span class="s2">, </span><span class="s3">'update_impacts'</span><span class="s2">, </span><span class="s3">'revision_impacts'</span><span class="s2">, </span><span class="s3">'news'</span><span class="s2">,</span>
             <span class="s3">'weights'</span><span class="s2">, </span><span class="s3">'update_forecasts'</span><span class="s2">, </span><span class="s3">'update_realized'</span><span class="s2">,</span>
             <span class="s3">'prev_impacted_forecasts'</span><span class="s2">, </span><span class="s3">'post_impacted_forecasts'</span><span class="s2">,</span>
             <span class="s3">'revisions_iloc'</span><span class="s2">, </span><span class="s3">'revisions_ix'</span><span class="s2">, </span><span class="s3">'updates_iloc'</span><span class="s2">, </span><span class="s3">'updates_ix'</span><span class="s1">]</span>

    <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">attrs:</span>
        <span class="s1">w = getattr(news1</span><span class="s2">, </span><span class="s1">attr)</span>
        <span class="s1">x = getattr(news2</span><span class="s2">, </span><span class="s1">attr)</span>
        <span class="s2">if </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">pd.Series):</span>
            <span class="s1">assert_series_equal(w</span><span class="s2">, </span><span class="s1">x)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">assert_frame_equal(w</span><span class="s2">, </span><span class="s1">x)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'revisions'</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'updates'</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_unobserved_components_time_varying(revisions</span><span class="s2">, </span><span class="s1">updates):</span>
    <span class="s4"># This is primarily a test that the `news` method works with a time-varying</span>
    <span class="s4"># setup (i.e. time-varying state space matrices). It tests a time-varying</span>
    <span class="s4"># UnobservedComponents model where the time-varying component has been set</span>
    <span class="s4"># to zeros against a time-invariant version of the model.</span>

    <span class="s4"># Construct previous and updated datasets</span>
    <span class="s1">endog = dta[</span><span class="s3">'infl'</span><span class="s1">].copy()</span>
    <span class="s1">comparison_type = </span><span class="s2">None</span>
    <span class="s2">if </span><span class="s1">updates:</span>
        <span class="s1">endog1 = endog.loc[:</span><span class="s3">'2009Q2'</span><span class="s1">].copy()</span>
        <span class="s1">endog2 = endog.loc[:</span><span class="s3">'2009Q3'</span><span class="s1">].copy()</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">endog1 = endog.loc[:</span><span class="s3">'2009Q3'</span><span class="s1">].copy()</span>
        <span class="s1">endog2 = endog.loc[:</span><span class="s3">'2009Q3'</span><span class="s1">].copy()</span>
        <span class="s4"># Without updates and without NaN values, we need to specify that</span>
        <span class="s4"># the type of the comparison object that we're passing is &quot;updated&quot;</span>
        <span class="s1">comparison_type = </span><span class="s3">'updated'</span>
    <span class="s2">if </span><span class="s1">revisions:</span>
        <span class="s1">endog1.iloc[-</span><span class="s5">1</span><span class="s1">] = </span><span class="s5">0.</span>

    <span class="s1">exog1 = np.ones_like(endog1)</span>
    <span class="s1">exog2 = np.ones_like(endog2)</span>

    <span class="s4"># Compute the news from a model with a trend/exog term (so the model is</span>
    <span class="s4"># time-varying), but with the coefficient set to zero (so that it will be</span>
    <span class="s4"># equivalent to the time-invariant model)</span>
    <span class="s1">mod1 = structural.UnobservedComponents(endog1</span><span class="s2">, </span><span class="s3">'llevel'</span><span class="s2">, </span><span class="s1">exog=exog1)</span>
    <span class="s1">res1 = mod1.smooth([</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">0.2</span><span class="s2">, </span><span class="s5">0.0</span><span class="s1">])</span>
    <span class="s1">news1 = res1.news(endog2</span><span class="s2">, </span><span class="s1">exog=exog2</span><span class="s2">, </span><span class="s1">start=</span><span class="s3">'2008Q1'</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">'2009Q3'</span><span class="s2">,</span>
                      <span class="s1">comparison_type=comparison_type)</span>

    <span class="s4"># Compute the news from a model without a trend term</span>
    <span class="s1">mod2 = structural.UnobservedComponents(endog1</span><span class="s2">, </span><span class="s3">'llevel'</span><span class="s1">)</span>
    <span class="s1">res2 = mod2.smooth([</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">0.2</span><span class="s1">])</span>
    <span class="s1">news2 = res2.news(endog2</span><span class="s2">, </span><span class="s1">start=</span><span class="s3">'2008Q1'</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">'2009Q3'</span><span class="s2">,</span>
                      <span class="s1">comparison_type=comparison_type)</span>

    <span class="s1">attrs = [</span><span class="s3">'total_impacts'</span><span class="s2">, </span><span class="s3">'update_impacts'</span><span class="s2">, </span><span class="s3">'revision_impacts'</span><span class="s2">, </span><span class="s3">'news'</span><span class="s2">,</span>
             <span class="s3">'weights'</span><span class="s2">, </span><span class="s3">'update_forecasts'</span><span class="s2">, </span><span class="s3">'update_realized'</span><span class="s2">,</span>
             <span class="s3">'prev_impacted_forecasts'</span><span class="s2">, </span><span class="s3">'post_impacted_forecasts'</span><span class="s2">,</span>
             <span class="s3">'revisions_iloc'</span><span class="s2">, </span><span class="s3">'revisions_ix'</span><span class="s2">, </span><span class="s3">'updates_iloc'</span><span class="s2">, </span><span class="s3">'updates_ix'</span><span class="s1">]</span>

    <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">attrs:</span>
        <span class="s1">w = getattr(news1</span><span class="s2">, </span><span class="s1">attr)</span>
        <span class="s1">x = getattr(news2</span><span class="s2">, </span><span class="s1">attr)</span>
        <span class="s2">if </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">pd.Series):</span>
            <span class="s1">assert_series_equal(w</span><span class="s2">, </span><span class="s1">x)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">assert_frame_equal(w</span><span class="s2">, </span><span class="s1">x)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'revisions'</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'updates'</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_varmax_time_invariant(revisions</span><span class="s2">, </span><span class="s1">updates):</span>
    <span class="s4"># Construct previous and updated datasets</span>
    <span class="s1">endog = dta[[</span><span class="s3">'realgdp'</span><span class="s2">, </span><span class="s3">'unemp'</span><span class="s1">]].copy()</span>
    <span class="s1">endog[</span><span class="s3">'realgdp'</span><span class="s1">] = np.log(endog[</span><span class="s3">'realgdp'</span><span class="s1">]).diff() * </span><span class="s5">400</span>
    <span class="s1">endog = endog.iloc[</span><span class="s5">1</span><span class="s1">:]</span>
    <span class="s1">comparison_type = </span><span class="s2">None</span>
    <span class="s2">if </span><span class="s1">updates:</span>
        <span class="s1">endog1 = endog.loc[:</span><span class="s3">'2009Q2'</span><span class="s1">].copy()</span>
        <span class="s1">endog2 = endog.loc[:</span><span class="s3">'2009Q3'</span><span class="s1">].copy()</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">endog1 = endog.loc[:</span><span class="s3">'2009Q3'</span><span class="s1">].copy()</span>
        <span class="s1">endog2 = endog.loc[:</span><span class="s3">'2009Q3'</span><span class="s1">].copy()</span>
        <span class="s4"># Without updates and without NaN values, we need to specify that</span>
        <span class="s4"># the type of the comparison object that we're passing is &quot;updated&quot;</span>
        <span class="s1">comparison_type = </span><span class="s3">'updated'</span>
    <span class="s2">if </span><span class="s1">revisions:</span>
        <span class="s4"># TODO: add test for only one of the variables revising?</span>
        <span class="s1">endog1.iloc[-</span><span class="s5">1</span><span class="s1">] = </span><span class="s5">0.</span>

    <span class="s4"># Get the previous results object and compute the news</span>
    <span class="s1">mod = varmax.VARMAX(endog1</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'n'</span><span class="s1">)</span>
    <span class="s1">params = np.r_[</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">0.1</span><span class="s2">, </span><span class="s5">0.2</span><span class="s2">, </span><span class="s5">0.9</span><span class="s2">, </span><span class="s5">1.</span><span class="s2">, </span><span class="s5">0.1</span><span class="s2">, </span><span class="s5">1.1</span><span class="s1">]</span>
    <span class="s1">res = mod.smooth(params)</span>
    <span class="s1">news = res.news(endog2</span><span class="s2">, </span><span class="s1">start=</span><span class="s3">'2009Q2'</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">'2010Q1'</span><span class="s2">,</span>
                    <span class="s1">comparison_type=comparison_type)</span>

    <span class="s4"># Compute the true values for each combination of (revsions, updates)</span>
    <span class="s1">impact_dates = pd.period_range(start=</span><span class="s3">'2009Q2'</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">'2010Q1'</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">'Q'</span><span class="s1">)</span>
    <span class="s1">impacted_variables = [</span><span class="s3">'realgdp'</span><span class="s2">, </span><span class="s3">'unemp'</span><span class="s1">]</span>

    <span class="s4"># Matrix powers of transition matrix</span>
    <span class="s1">Z = np.zeros((</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s1">))</span>
    <span class="s1">T0 = np.eye(</span><span class="s5">2</span><span class="s1">)</span>
    <span class="s1">T1 = mod[</span><span class="s3">'transition'</span><span class="s1">]</span>
    <span class="s1">T2 = T1 @ T1</span>
    <span class="s1">T3 = T1 @ T2</span>

    <span class="s4"># Revisions</span>
    <span class="s2">if </span><span class="s1">revisions </span><span class="s2">and </span><span class="s1">updates:</span>
        <span class="s1">revisions_index = pd.MultiIndex.from_product(</span>
            <span class="s1">[endog1.index[-</span><span class="s5">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">'realgdp'</span><span class="s2">, </span><span class="s3">'unemp'</span><span class="s1">]]</span><span class="s2">,</span>
            <span class="s1">names=[</span><span class="s3">'revision date'</span><span class="s2">, </span><span class="s3">'revised variable'</span><span class="s1">])</span>
        <span class="s4"># If we have updates, the revision is to 2009Q2</span>
        <span class="s4"># Note: this &quot;.values&quot; and all of those below are only required for</span>
        <span class="s4"># Pandas = 0.23, and can be removed once that is no longer a supported</span>
        <span class="s4"># dependency</span>
        <span class="s1">tmp = endog2.iloc[-</span><span class="s5">2</span><span class="s1">].values</span>
        <span class="s1">revision_impacts = np.c_[T0 @ tmp</span><span class="s2">, </span><span class="s1">T1 @ tmp</span><span class="s2">, </span><span class="s1">T2 @ tmp</span><span class="s2">, </span><span class="s1">T3 @ tmp].T</span>
    <span class="s2">elif </span><span class="s1">revisions:</span>
        <span class="s1">revisions_index = pd.MultiIndex.from_product(</span>
            <span class="s1">[endog1.index[-</span><span class="s5">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">[</span><span class="s3">'realgdp'</span><span class="s2">, </span><span class="s3">'unemp'</span><span class="s1">]]</span><span class="s2">,</span>
            <span class="s1">names=[</span><span class="s3">'revision date'</span><span class="s2">, </span><span class="s3">'revised variable'</span><span class="s1">])</span>
        <span class="s4"># With no updates, the revision is to 2009Q3</span>
        <span class="s1">tmp = endog2.iloc[-</span><span class="s5">1</span><span class="s1">].values</span>
        <span class="s1">revision_impacts = np.c_[Z @ tmp</span><span class="s2">, </span><span class="s1">T0 @ tmp</span><span class="s2">, </span><span class="s1">T1 @ tmp</span><span class="s2">, </span><span class="s1">T2 @ tmp].T</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">revisions_index = pd.MultiIndex.from_product(</span>
            <span class="s1">[[]</span><span class="s2">, </span><span class="s1">[]]</span><span class="s2">,</span>
            <span class="s1">names=[</span><span class="s3">'revision date'</span><span class="s2">, </span><span class="s3">'revised variable'</span><span class="s1">])</span>
        <span class="s1">revision_impacts = </span><span class="s2">None</span>

    <span class="s4"># Impact forecasts</span>
    <span class="s2">if </span><span class="s1">updates:</span>
        <span class="s1">tmp = endog1.iloc[-</span><span class="s5">1</span><span class="s1">].values</span>
        <span class="s1">prev_impacted_forecasts = np.c_[T0 @ tmp</span><span class="s2">, </span><span class="s1">T1 @ tmp</span><span class="s2">,</span>
                                        <span class="s1">T2 @ tmp</span><span class="s2">, </span><span class="s1">T3 @ tmp].T</span>
        <span class="s1">tmp = endog2.iloc[-</span><span class="s5">2</span><span class="s1">].values</span>
        <span class="s1">rev_impacted_forecasts = np.c_[T0 @ tmp</span><span class="s2">, </span><span class="s1">T1 @ tmp</span><span class="s2">,</span>
                                       <span class="s1">T2 @ tmp</span><span class="s2">, </span><span class="s1">T3 @ tmp].T</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">tmp = endog1.iloc[-</span><span class="s5">1</span><span class="s1">].values</span>
        <span class="s1">prev_impacted_forecasts = np.c_[</span>
            <span class="s1">T0 @ endog1.iloc[-</span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">T0 @ tmp</span><span class="s2">, </span><span class="s1">T1 @ tmp</span><span class="s2">, </span><span class="s1">T2 @ tmp].T</span>
        <span class="s1">tmp = endog2.iloc[-</span><span class="s5">1</span><span class="s1">].values</span>
        <span class="s1">rev_impacted_forecasts = np.c_[</span>
            <span class="s1">T0 @ endog2.iloc[-</span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">T0 @ tmp</span><span class="s2">, </span><span class="s1">T1 @ tmp</span><span class="s2">, </span><span class="s1">T2 @ tmp].T</span>
    <span class="s1">tmp = endog2.iloc[-</span><span class="s5">1</span><span class="s1">].values</span>
    <span class="s1">post_impacted_forecasts = np.c_[</span>
        <span class="s1">T0 @ endog2.iloc[-</span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">T0 @ tmp</span><span class="s2">, </span><span class="s1">T1 @ tmp</span><span class="s2">, </span><span class="s1">T2 @ tmp].T</span>

    <span class="s4"># Updates</span>
    <span class="s2">if </span><span class="s1">updates:</span>
        <span class="s1">updates_index = pd.MultiIndex.from_product(</span>
            <span class="s1">[pd.period_range(start=</span><span class="s3">'2009Q3'</span><span class="s2">, </span><span class="s1">periods=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">'Q'</span><span class="s1">)</span><span class="s2">,</span>
             <span class="s1">[</span><span class="s3">'realgdp'</span><span class="s2">, </span><span class="s3">'unemp'</span><span class="s1">]]</span><span class="s2">, </span><span class="s1">names=[</span><span class="s3">'update date'</span><span class="s2">, </span><span class="s3">'updated variable'</span><span class="s1">])</span>
        <span class="s1">update_impacts = post_impacted_forecasts - rev_impacted_forecasts</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">updates_index = pd.MultiIndex.from_product(</span>
            <span class="s1">[[]</span><span class="s2">, </span><span class="s1">[]]</span><span class="s2">, </span><span class="s1">names=[</span><span class="s3">'update date'</span><span class="s2">, </span><span class="s3">'updated variable'</span><span class="s1">])</span>
        <span class="s1">update_impacts = </span><span class="s2">None</span>

    <span class="s4"># News</span>
    <span class="s2">if </span><span class="s1">updates:</span>
        <span class="s4"># Note: update_forecasts is created using the endog2 dataset even if</span>
        <span class="s4"># there were revisions, because it should be computed after revisions</span>
        <span class="s4"># have already been taken into account</span>
        <span class="s1">update_forecasts = T1 @ endog2.loc[</span><span class="s3">'2009Q2'</span><span class="s1">].values</span>
        <span class="s1">update_realized = endog2.loc[</span><span class="s3">'2009Q3'</span><span class="s1">].values</span>
        <span class="s1">news_desired = [update_realized[i] - update_forecasts[i]</span>
                        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(len(update_forecasts))]</span>
        <span class="s1">columns = pd.MultiIndex.from_product(</span>
            <span class="s1">[impact_dates</span><span class="s2">, </span><span class="s1">impacted_variables]</span><span class="s2">,</span>
            <span class="s1">names=[</span><span class="s3">'impact dates'</span><span class="s2">, </span><span class="s3">'impacted variables'</span><span class="s1">])</span>
        <span class="s1">weights = pd.DataFrame(np.zeros((</span><span class="s5">2</span><span class="s2">, </span><span class="s5">8</span><span class="s1">))</span><span class="s2">, </span><span class="s1">index=updates_index</span><span class="s2">,</span>
                               <span class="s1">columns=columns)</span>
        <span class="s1">weights.loc[:</span><span class="s2">, </span><span class="s3">'2009Q2'</span><span class="s1">] = Z</span>
        <span class="s1">weights.loc[:</span><span class="s2">, </span><span class="s3">'2009Q3'</span><span class="s1">] = T0</span>
        <span class="s1">weights.loc[:</span><span class="s2">, </span><span class="s3">'2009Q4'</span><span class="s1">] = T1.T</span>
        <span class="s1">weights.loc[:</span><span class="s2">, </span><span class="s3">'2010Q1'</span><span class="s1">] = T2.T</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">update_forecasts = pd.Series([]</span><span class="s2">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s1">update_realized = pd.Series([]</span><span class="s2">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s1">news_desired = pd.Series([]</span><span class="s2">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s1">weights = pd.DataFrame(np.zeros((</span><span class="s5">0</span><span class="s2">, </span><span class="s5">8</span><span class="s1">)))</span>

    <span class="s4"># Run unit tests</span>
    <span class="s1">check_news(news</span><span class="s2">, </span><span class="s1">revisions</span><span class="s2">, </span><span class="s1">updates</span><span class="s2">, </span><span class="s1">impact_dates</span><span class="s2">, </span><span class="s1">impacted_variables</span><span class="s2">,</span>
               <span class="s1">revisions_index</span><span class="s2">, </span><span class="s1">updates_index</span><span class="s2">,</span>
               <span class="s1">revision_impacts</span><span class="s2">, </span><span class="s1">update_impacts</span><span class="s2">,</span>
               <span class="s1">prev_impacted_forecasts</span><span class="s2">, </span><span class="s1">post_impacted_forecasts</span><span class="s2">,</span>
               <span class="s1">update_forecasts</span><span class="s2">, </span><span class="s1">update_realized</span><span class="s2">, </span><span class="s1">news_desired</span><span class="s2">, </span><span class="s1">weights)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'revisions'</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'updates'</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'which'</span><span class="s2">, </span><span class="s1">[</span><span class="s3">'exog'</span><span class="s2">, </span><span class="s3">'trend'</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_varmax_time_varying(revisions</span><span class="s2">, </span><span class="s1">updates</span><span class="s2">, </span><span class="s1">which):</span>
    <span class="s4"># This is primarily a test that the `news` method works with a time-varying</span>
    <span class="s4"># setup (i.e. time-varying state space matrices). It tests a time-varying</span>
    <span class="s4"># VARMAX model where the time-varying component has been set to zeros</span>
    <span class="s4"># against a time-invariant version of the model.</span>

    <span class="s4"># Construct previous and updated datasets</span>
    <span class="s1">endog = dta[[</span><span class="s3">'realgdp'</span><span class="s2">, </span><span class="s3">'unemp'</span><span class="s1">]].copy()</span>
    <span class="s1">endog[</span><span class="s3">'realgdp'</span><span class="s1">] = np.log(endog[</span><span class="s3">'realgdp'</span><span class="s1">]).diff() * </span><span class="s5">400</span>
    <span class="s1">endog = endog.iloc[</span><span class="s5">1</span><span class="s1">:]</span>
    <span class="s1">comparison_type = </span><span class="s2">None</span>
    <span class="s2">if </span><span class="s1">updates:</span>
        <span class="s1">endog1 = endog.loc[:</span><span class="s3">'2009Q2'</span><span class="s1">].copy()</span>
        <span class="s1">endog2 = endog.loc[:</span><span class="s3">'2009Q3'</span><span class="s1">].copy()</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">endog1 = endog.loc[:</span><span class="s3">'2009Q3'</span><span class="s1">].copy()</span>
        <span class="s1">endog2 = endog.loc[:</span><span class="s3">'2009Q3'</span><span class="s1">].copy()</span>
        <span class="s4"># Without updates and without NaN values, we need to specify that</span>
        <span class="s4"># the type of the comparison object that we're passing is &quot;updated&quot;</span>
        <span class="s1">comparison_type = </span><span class="s3">'updated'</span>
    <span class="s2">if </span><span class="s1">revisions:</span>
        <span class="s4"># TODO: add test for only one of the variables revising?</span>
        <span class="s1">endog1.iloc[-</span><span class="s5">1</span><span class="s1">] = </span><span class="s5">0.</span>

    <span class="s1">exog1 = </span><span class="s2">None</span>
    <span class="s1">exog2 = </span><span class="s2">None</span>
    <span class="s1">trend = </span><span class="s3">'n'</span>
    <span class="s2">if </span><span class="s1">which == </span><span class="s3">'exog'</span><span class="s1">:</span>
        <span class="s1">exog1 = np.ones_like(endog1[</span><span class="s3">'realgdp'</span><span class="s1">])</span>
        <span class="s1">exog2 = np.ones_like(endog2[</span><span class="s3">'realgdp'</span><span class="s1">])</span>
        <span class="s1">params1 = np.r_[</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">0.1</span><span class="s2">, </span><span class="s5">0.2</span><span class="s2">, </span><span class="s5">0.9</span><span class="s2">, </span><span class="s5">0.</span><span class="s2">, </span><span class="s5">0.</span><span class="s2">, </span><span class="s5">1.</span><span class="s2">, </span><span class="s5">0.1</span><span class="s2">, </span><span class="s5">1.1</span><span class="s1">]</span>
        <span class="s1">params2 = np.r_[</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">0.1</span><span class="s2">, </span><span class="s5">0.2</span><span class="s2">, </span><span class="s5">0.9</span><span class="s2">, </span><span class="s5">1.</span><span class="s2">, </span><span class="s5">0.1</span><span class="s2">, </span><span class="s5">1.1</span><span class="s1">]</span>
    <span class="s2">elif </span><span class="s1">which == </span><span class="s3">'trend'</span><span class="s1">:</span>
        <span class="s1">trend = </span><span class="s3">'t'</span>
        <span class="s1">params1 = np.r_[</span><span class="s5">0.</span><span class="s2">, </span><span class="s5">0.</span><span class="s2">, </span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">0.1</span><span class="s2">, </span><span class="s5">0.2</span><span class="s2">, </span><span class="s5">0.9</span><span class="s2">, </span><span class="s5">1.</span><span class="s2">, </span><span class="s5">0.1</span><span class="s2">, </span><span class="s5">1.1</span><span class="s1">]</span>
        <span class="s1">params2 = np.r_[</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">0.1</span><span class="s2">, </span><span class="s5">0.2</span><span class="s2">, </span><span class="s5">0.9</span><span class="s2">, </span><span class="s5">1.</span><span class="s2">, </span><span class="s5">0.1</span><span class="s2">, </span><span class="s5">1.1</span><span class="s1">]</span>

    <span class="s4"># Compute the news from a model with a trend/exog term (so the model is</span>
    <span class="s4"># time-varying), but with the coefficient set to zero (so that it will be</span>
    <span class="s4"># equivalent to the time-invariant model)</span>
    <span class="s1">mod1 = varmax.VARMAX(endog1</span><span class="s2">, </span><span class="s1">exog=exog1</span><span class="s2">, </span><span class="s1">trend=trend)</span>
    <span class="s1">res1 = mod1.smooth(params1)</span>
    <span class="s1">news1 = res1.news(endog2</span><span class="s2">, </span><span class="s1">exog=exog2</span><span class="s2">, </span><span class="s1">start=</span><span class="s3">'2008Q1'</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">'2009Q3'</span><span class="s2">,</span>
                      <span class="s1">comparison_type=comparison_type)</span>

    <span class="s4"># Compute the news from a model without a trend term</span>
    <span class="s1">mod2 = varmax.VARMAX(endog1</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">'n'</span><span class="s1">)</span>
    <span class="s1">res2 = mod2.smooth(params2)</span>
    <span class="s1">news2 = res2.news(endog2</span><span class="s2">, </span><span class="s1">start=</span><span class="s3">'2008Q1'</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">'2009Q3'</span><span class="s2">,</span>
                      <span class="s1">comparison_type=comparison_type)</span>

    <span class="s1">attrs = [</span><span class="s3">'total_impacts'</span><span class="s2">, </span><span class="s3">'update_impacts'</span><span class="s2">, </span><span class="s3">'revision_impacts'</span><span class="s2">, </span><span class="s3">'news'</span><span class="s2">,</span>
             <span class="s3">'weights'</span><span class="s2">, </span><span class="s3">'update_forecasts'</span><span class="s2">, </span><span class="s3">'update_realized'</span><span class="s2">,</span>
             <span class="s3">'prev_impacted_forecasts'</span><span class="s2">, </span><span class="s3">'post_impacted_forecasts'</span><span class="s2">,</span>
             <span class="s3">'revisions_iloc'</span><span class="s2">, </span><span class="s3">'revisions_ix'</span><span class="s2">, </span><span class="s3">'updates_iloc'</span><span class="s2">, </span><span class="s3">'updates_ix'</span><span class="s1">]</span>

    <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">attrs:</span>
        <span class="s1">w = getattr(news1</span><span class="s2">, </span><span class="s1">attr)</span>
        <span class="s1">x = getattr(news2</span><span class="s2">, </span><span class="s1">attr)</span>
        <span class="s2">if </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">pd.Series):</span>
            <span class="s1">assert_series_equal(w</span><span class="s2">, </span><span class="s1">x)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">assert_frame_equal(w</span><span class="s2">, </span><span class="s1">x)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'revisions'</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'updates'</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_dynamic_factor_time_varying(revisions</span><span class="s2">, </span><span class="s1">updates):</span>
    <span class="s4"># This is primarily a test that the `news` method works with a time-varying</span>
    <span class="s4"># setup (i.e. time-varying state space matrices). It tests a time-varying</span>
    <span class="s4"># DynamicFactor model where the time-varying component has been set to</span>
    <span class="s4"># zeros against a time-invariant version of the model.</span>

    <span class="s4"># Construct previous and updated datasets</span>
    <span class="s1">endog = dta[[</span><span class="s3">'realgdp'</span><span class="s2">, </span><span class="s3">'unemp'</span><span class="s1">]].copy()</span>
    <span class="s1">endog[</span><span class="s3">'realgdp'</span><span class="s1">] = np.log(endog[</span><span class="s3">'realgdp'</span><span class="s1">]).diff() * </span><span class="s5">400</span>
    <span class="s1">endog = endog.iloc[</span><span class="s5">1</span><span class="s1">:]</span>
    <span class="s1">comparison_type = </span><span class="s2">None</span>
    <span class="s2">if </span><span class="s1">updates:</span>
        <span class="s1">endog1 = endog.loc[:</span><span class="s3">'2009Q2'</span><span class="s1">].copy()</span>
        <span class="s1">endog2 = endog.loc[:</span><span class="s3">'2009Q3'</span><span class="s1">].copy()</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">endog1 = endog.loc[:</span><span class="s3">'2009Q3'</span><span class="s1">].copy()</span>
        <span class="s1">endog2 = endog.loc[:</span><span class="s3">'2009Q3'</span><span class="s1">].copy()</span>
        <span class="s4"># Without updates and without NaN values, we need to specify that</span>
        <span class="s4"># the type of the comparison object that we're passing is &quot;updated&quot;</span>
        <span class="s1">comparison_type = </span><span class="s3">'updated'</span>
    <span class="s2">if </span><span class="s1">revisions:</span>
        <span class="s4"># TODO: add test for only one of the variables revising?</span>
        <span class="s1">endog1.iloc[-</span><span class="s5">1</span><span class="s1">] = </span><span class="s5">0.</span>

    <span class="s1">exog1 = np.ones_like(endog1[</span><span class="s3">'realgdp'</span><span class="s1">])</span>
    <span class="s1">exog2 = np.ones_like(endog2[</span><span class="s3">'realgdp'</span><span class="s1">])</span>
    <span class="s1">params1 = np.r_[</span><span class="s5">0.9</span><span class="s2">, </span><span class="s5">0.2</span><span class="s2">, </span><span class="s5">0.0</span><span class="s2">, </span><span class="s5">0.0</span><span class="s2">, </span><span class="s5">1.2</span><span class="s2">, </span><span class="s5">1.1</span><span class="s2">, </span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">0.2</span><span class="s1">]</span>
    <span class="s1">params2 = np.r_[</span><span class="s5">0.9</span><span class="s2">, </span><span class="s5">0.2</span><span class="s2">, </span><span class="s5">1.2</span><span class="s2">, </span><span class="s5">1.1</span><span class="s2">, </span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">0.2</span><span class="s1">]</span>

    <span class="s4"># Compute the news from a model with an exog term (so the model is</span>
    <span class="s4"># time-varying), but with the coefficient set to zero (so that it will be</span>
    <span class="s4"># equivalent to the time-invariant model)</span>
    <span class="s1">mod1 = dynamic_factor.DynamicFactor(endog1</span><span class="s2">, </span><span class="s1">exog=exog1</span><span class="s2">,</span>
                                        <span class="s1">k_factors=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">factor_order=</span><span class="s5">2</span><span class="s1">)</span>
    <span class="s1">res1 = mod1.smooth(params1)</span>
    <span class="s1">news1 = res1.news(endog2</span><span class="s2">, </span><span class="s1">exog=exog2</span><span class="s2">, </span><span class="s1">start=</span><span class="s3">'2008Q1'</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">'2009Q3'</span><span class="s2">,</span>
                      <span class="s1">comparison_type=comparison_type)</span>

    <span class="s4"># Compute the news from a model without a trend term</span>
    <span class="s1">mod2 = dynamic_factor.DynamicFactor(endog1</span><span class="s2">, </span><span class="s1">k_factors=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">factor_order=</span><span class="s5">2</span><span class="s1">)</span>
    <span class="s1">res2 = mod2.smooth(params2)</span>
    <span class="s1">news2 = res2.news(endog2</span><span class="s2">, </span><span class="s1">start=</span><span class="s3">'2008Q1'</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">'2009Q3'</span><span class="s2">,</span>
                      <span class="s1">comparison_type=comparison_type)</span>

    <span class="s1">attrs = [</span><span class="s3">'total_impacts'</span><span class="s2">, </span><span class="s3">'update_impacts'</span><span class="s2">, </span><span class="s3">'revision_impacts'</span><span class="s2">, </span><span class="s3">'news'</span><span class="s2">,</span>
             <span class="s3">'weights'</span><span class="s2">, </span><span class="s3">'update_forecasts'</span><span class="s2">, </span><span class="s3">'update_realized'</span><span class="s2">,</span>
             <span class="s3">'prev_impacted_forecasts'</span><span class="s2">, </span><span class="s3">'post_impacted_forecasts'</span><span class="s2">,</span>
             <span class="s3">'revisions_iloc'</span><span class="s2">, </span><span class="s3">'revisions_ix'</span><span class="s2">, </span><span class="s3">'updates_iloc'</span><span class="s2">, </span><span class="s3">'updates_ix'</span><span class="s1">]</span>

    <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">attrs:</span>
        <span class="s1">w = getattr(news1</span><span class="s2">, </span><span class="s1">attr)</span>
        <span class="s1">x = getattr(news2</span><span class="s2">, </span><span class="s1">attr)</span>
        <span class="s2">if </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">pd.Series):</span>
            <span class="s1">assert_series_equal(w</span><span class="s2">, </span><span class="s1">x)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">assert_frame_equal(w</span><span class="s2">, </span><span class="s1">x)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'revisions'</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'updates'</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_defaults(revisions</span><span class="s2">, </span><span class="s1">updates):</span>
    <span class="s4"># Construct previous and updated datasets</span>
    <span class="s1">endog = dta[</span><span class="s3">'infl'</span><span class="s1">].copy()</span>
    <span class="s2">if </span><span class="s1">updates:</span>
        <span class="s1">endog1 = endog.loc[:</span><span class="s3">'2009Q2'</span><span class="s1">].copy()</span>
        <span class="s1">endog2 = endog.loc[:</span><span class="s3">'2009Q3'</span><span class="s1">].copy()</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">endog1 = endog.loc[:</span><span class="s3">'2009Q3'</span><span class="s1">].copy()</span>
        <span class="s1">endog2 = endog.loc[:</span><span class="s3">'2009Q3'</span><span class="s1">].copy()</span>
    <span class="s2">if </span><span class="s1">revisions:</span>
        <span class="s4"># TODO: add test for only one of the variables revising?</span>
        <span class="s1">endog1.iloc[-</span><span class="s5">1</span><span class="s1">] = </span><span class="s5">0.</span>

    <span class="s4"># Get the previous results object and compute the news</span>
    <span class="s1">mod1 = sarimax.SARIMAX(endog1)</span>
    <span class="s1">res1 = mod1.smooth([</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">1.0</span><span class="s1">])</span>

    <span class="s1">mod2 = sarimax.SARIMAX(endog2)</span>
    <span class="s1">res2 = mod2.smooth([</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">1.0</span><span class="s1">])</span>

    <span class="s1">news_updated_data = res1.news(endog2</span><span class="s2">, </span><span class="s1">comparison_type=</span><span class="s3">'updated'</span><span class="s1">)</span>
    <span class="s1">news_previous_data = res2.news(endog1</span><span class="s2">, </span><span class="s1">comparison_type=</span><span class="s3">'previous'</span><span class="s1">)</span>
    <span class="s1">news_updated_results = res1.news(res2</span><span class="s2">, </span><span class="s1">comparison_type=</span><span class="s3">'updated'</span><span class="s1">)</span>
    <span class="s1">news_previous_results = res2.news(res1</span><span class="s2">, </span><span class="s1">comparison_type=</span><span class="s3">'previous'</span><span class="s1">)</span>

    <span class="s1">attrs = [</span><span class="s3">'total_impacts'</span><span class="s2">, </span><span class="s3">'update_impacts'</span><span class="s2">, </span><span class="s3">'revision_impacts'</span><span class="s2">, </span><span class="s3">'news'</span><span class="s2">,</span>
             <span class="s3">'weights'</span><span class="s2">, </span><span class="s3">'update_forecasts'</span><span class="s2">, </span><span class="s3">'update_realized'</span><span class="s2">,</span>
             <span class="s3">'prev_impacted_forecasts'</span><span class="s2">, </span><span class="s3">'post_impacted_forecasts'</span><span class="s2">,</span>
             <span class="s3">'revisions_iloc'</span><span class="s2">, </span><span class="s3">'revisions_ix'</span><span class="s2">, </span><span class="s3">'updates_iloc'</span><span class="s2">, </span><span class="s3">'updates_ix'</span><span class="s1">]</span>

    <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">attrs:</span>
        <span class="s1">w = getattr(news_updated_data</span><span class="s2">, </span><span class="s1">attr)</span>
        <span class="s1">x = getattr(news_previous_data</span><span class="s2">, </span><span class="s1">attr)</span>
        <span class="s1">y = getattr(news_updated_results</span><span class="s2">, </span><span class="s1">attr)</span>
        <span class="s1">z = getattr(news_previous_results</span><span class="s2">, </span><span class="s1">attr)</span>
        <span class="s2">if </span><span class="s1">isinstance(x</span><span class="s2">, </span><span class="s1">pd.Series):</span>
            <span class="s1">assert_series_equal(w</span><span class="s2">, </span><span class="s1">x)</span>
            <span class="s1">assert_series_equal(w</span><span class="s2">, </span><span class="s1">y)</span>
            <span class="s1">assert_series_equal(w</span><span class="s2">, </span><span class="s1">z)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">assert_frame_equal(w</span><span class="s2">, </span><span class="s1">x)</span>
            <span class="s1">assert_frame_equal(w</span><span class="s2">, </span><span class="s1">y)</span>
            <span class="s1">assert_frame_equal(w</span><span class="s2">, </span><span class="s1">z)</span>


<span class="s2">def </span><span class="s1">test_comparison_types():</span>
    <span class="s1">endog = dta[</span><span class="s3">'infl'</span><span class="s1">].copy()</span>
    <span class="s1">endog.iloc[-</span><span class="s5">1</span><span class="s1">] = np.nan</span>
    <span class="s1">msg = </span><span class="s3">'Could not automatically determine the type of comparison'</span>

    <span class="s1">mod = sarimax.SARIMAX(endog)</span>
    <span class="s1">res = mod.smooth([</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">1.0</span><span class="s1">])</span>

    <span class="s4"># Test that the comparison type cannot be determined if the given dataset</span>
    <span class="s4"># or results dataset is identical to the previous dataset</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">res.news(endog)</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">res.news(res)</span>

    <span class="s4"># Test that if the the comparison type is specified, the news can be</span>
    <span class="s4"># computed from data that has the same shape and number of NaNs (this can</span>
    <span class="s4"># happen if there are only revisions but no updates)</span>
    <span class="s1">news = res.news(endog</span><span class="s2">, </span><span class="s1">comparison_type=</span><span class="s3">'previous'</span><span class="s1">)</span>
    <span class="s1">assert_allclose(news.total_impacts</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">news = res.news(endog</span><span class="s2">, </span><span class="s1">comparison_type=</span><span class="s3">'updated'</span><span class="s1">)</span>
    <span class="s1">assert_allclose(news.total_impacts</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">news = res.news(res</span><span class="s2">, </span><span class="s1">comparison_type=</span><span class="s3">'updated'</span><span class="s1">)</span>
    <span class="s1">assert_allclose(news.total_impacts</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s1">news = res.news(res</span><span class="s2">, </span><span class="s1">comparison_type=</span><span class="s3">'updated'</span><span class="s1">)</span>
    <span class="s1">assert_allclose(news.total_impacts</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'use_periods'</span><span class="s2">, </span><span class="s1">[</span><span class="s2">True, False</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_start_end_dates(use_periods):</span>
    <span class="s1">endog = dta[</span><span class="s3">'infl'</span><span class="s1">].copy()</span>
    <span class="s2">if </span><span class="s1">use_periods:</span>
        <span class="s1">index_range = pd.period_range</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">def </span><span class="s1">index_range(*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
            <span class="s2">return </span><span class="s1">pd.period_range(*args</span><span class="s2">, </span><span class="s1">**kwargs).to_timestamp(freq=</span><span class="s3">'Q'</span><span class="s1">)</span>
        <span class="s1">endog = endog.to_timestamp(freq=</span><span class="s3">'Q'</span><span class="s1">)</span>
    <span class="s1">mod = sarimax.SARIMAX(endog.iloc[:-</span><span class="s5">1</span><span class="s1">])</span>
    <span class="s1">res = mod.smooth([</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">1.0</span><span class="s1">])</span>

    <span class="s4"># Default is the first out-of-sample period</span>
    <span class="s1">news = res.news(endog)</span>
    <span class="s1">desired = index_range(start=</span><span class="s3">'2009Q2'</span><span class="s2">, </span><span class="s1">periods=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">'Q'</span><span class="s1">)</span>
    <span class="s1">assert_(news.total_impacts.index.equals(desired))</span>

    <span class="s4"># Start (dates), periods</span>
    <span class="s1">news = res.news(endog</span><span class="s2">, </span><span class="s1">start=</span><span class="s3">'2009Q1'</span><span class="s2">, </span><span class="s1">periods=</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">desired = index_range(start=</span><span class="s3">'2009Q1'</span><span class="s2">, </span><span class="s1">periods=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">'Q'</span><span class="s1">)</span>
    <span class="s1">assert_(news.total_impacts.index.equals(desired))</span>
    <span class="s1">news = res.news(endog</span><span class="s2">, </span><span class="s1">start=</span><span class="s3">'2009Q1'</span><span class="s2">, </span><span class="s1">periods=</span><span class="s5">2</span><span class="s1">)</span>
    <span class="s1">desired = index_range(start=</span><span class="s3">'2009Q1'</span><span class="s2">, </span><span class="s1">periods=</span><span class="s5">2</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">'Q'</span><span class="s1">)</span>
    <span class="s1">assert_(news.total_impacts.index.equals(desired))</span>

    <span class="s4"># Start (int), periods</span>
    <span class="s1">news = res.news(endog</span><span class="s2">, </span><span class="s1">start=mod.nobs - </span><span class="s5">1</span><span class="s2">, </span><span class="s1">periods=</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">desired = index_range(start=</span><span class="s3">'2009Q2'</span><span class="s2">, </span><span class="s1">periods=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">'Q'</span><span class="s1">)</span>
    <span class="s1">assert_(news.total_impacts.index.equals(desired))</span>
    <span class="s1">news = res.news(endog</span><span class="s2">, </span><span class="s1">start=mod.nobs - </span><span class="s5">2</span><span class="s2">, </span><span class="s1">periods=</span><span class="s5">2</span><span class="s1">)</span>
    <span class="s1">desired = index_range(start=</span><span class="s3">'2009Q1'</span><span class="s2">, </span><span class="s1">periods=</span><span class="s5">2</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">'Q'</span><span class="s1">)</span>
    <span class="s1">assert_(news.total_impacts.index.equals(desired))</span>

    <span class="s4"># End (dates), periods</span>
    <span class="s1">news = res.news(endog</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">'2009Q1'</span><span class="s2">, </span><span class="s1">periods=</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">desired = index_range(end=</span><span class="s3">'2009Q1'</span><span class="s2">, </span><span class="s1">periods=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">'Q'</span><span class="s1">)</span>
    <span class="s1">assert_(news.total_impacts.index.equals(desired))</span>
    <span class="s1">news = res.news(endog</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">'2009Q1'</span><span class="s2">, </span><span class="s1">periods=</span><span class="s5">2</span><span class="s1">)</span>
    <span class="s1">desired = index_range(end=</span><span class="s3">'2009Q1'</span><span class="s2">, </span><span class="s1">periods=</span><span class="s5">2</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">'Q'</span><span class="s1">)</span>
    <span class="s1">assert_(news.total_impacts.index.equals(desired))</span>

    <span class="s4"># End (int), periods</span>
    <span class="s1">news = res.news(endog</span><span class="s2">, </span><span class="s1">end=mod.nobs - </span><span class="s5">1</span><span class="s2">, </span><span class="s1">periods=</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">desired = index_range(end=</span><span class="s3">'2009Q2'</span><span class="s2">, </span><span class="s1">periods=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">'Q'</span><span class="s1">)</span>
    <span class="s1">assert_(news.total_impacts.index.equals(desired))</span>
    <span class="s1">news = res.news(endog</span><span class="s2">, </span><span class="s1">end=mod.nobs - </span><span class="s5">2</span><span class="s2">, </span><span class="s1">periods=</span><span class="s5">2</span><span class="s1">)</span>
    <span class="s1">desired = index_range(end=</span><span class="s3">'2009Q1'</span><span class="s2">, </span><span class="s1">periods=</span><span class="s5">2</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">'Q'</span><span class="s1">)</span>
    <span class="s1">assert_(news.total_impacts.index.equals(desired))</span>

    <span class="s4"># Start (dates), end (dates)</span>
    <span class="s1">news = res.news(endog</span><span class="s2">, </span><span class="s1">start=</span><span class="s3">'2009Q1'</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">'2009Q1'</span><span class="s1">)</span>
    <span class="s1">desired = index_range(start=</span><span class="s3">'2009Q1'</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">'2009Q1'</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">'Q'</span><span class="s1">)</span>
    <span class="s1">assert_(news.total_impacts.index.equals(desired))</span>
    <span class="s1">news = res.news(endog</span><span class="s2">, </span><span class="s1">start=</span><span class="s3">'2009Q1'</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">'2009Q2'</span><span class="s1">)</span>
    <span class="s1">desired = index_range(start=</span><span class="s3">'2009Q1'</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">'2009Q2'</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">'Q'</span><span class="s1">)</span>
    <span class="s1">assert_(news.total_impacts.index.equals(desired))</span>

    <span class="s4"># Start (dates), end (int)</span>
    <span class="s1">news = res.news(endog</span><span class="s2">, </span><span class="s1">start=</span><span class="s3">'2009Q1'</span><span class="s2">, </span><span class="s1">end=mod.nobs - </span><span class="s5">2</span><span class="s1">)</span>
    <span class="s1">desired = index_range(start=</span><span class="s3">'2009Q1'</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">'2009Q1'</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">'Q'</span><span class="s1">)</span>
    <span class="s1">assert_(news.total_impacts.index.equals(desired))</span>
    <span class="s1">predicted = res.predict(start=</span><span class="s3">'2009Q1'</span><span class="s2">, </span><span class="s1">end=mod.nobs - </span><span class="s5">2</span><span class="s1">)</span>
    <span class="s1">assert_(news.total_impacts.index.equals(predicted.index))</span>
    <span class="s1">news = res.news(endog</span><span class="s2">, </span><span class="s1">start=</span><span class="s3">'2009Q1'</span><span class="s2">, </span><span class="s1">end=mod.nobs - </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">desired = index_range(start=</span><span class="s3">'2009Q1'</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">'2009Q2'</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">'Q'</span><span class="s1">)</span>
    <span class="s1">assert_(news.total_impacts.index.equals(desired))</span>
    <span class="s1">predicted = res.predict(start=</span><span class="s3">'2009Q1'</span><span class="s2">, </span><span class="s1">end=mod.nobs - </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">assert_(news.total_impacts.index.equals(predicted.index))</span>

    <span class="s4"># Start (int), end (dates)</span>
    <span class="s1">news = res.news(endog</span><span class="s2">, </span><span class="s1">start=mod.nobs - </span><span class="s5">2</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">'2009Q1'</span><span class="s1">)</span>
    <span class="s1">desired = index_range(start=</span><span class="s3">'2009Q1'</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">'2009Q1'</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">'Q'</span><span class="s1">)</span>
    <span class="s1">assert_(news.total_impacts.index.equals(desired))</span>
    <span class="s1">predicted = res.predict(start=mod.nobs - </span><span class="s5">2</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">'2009Q1'</span><span class="s1">)</span>
    <span class="s1">assert_(news.total_impacts.index.equals(predicted.index))</span>
    <span class="s1">news = res.news(endog</span><span class="s2">, </span><span class="s1">start=mod.nobs - </span><span class="s5">2</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">'2009Q2'</span><span class="s1">)</span>
    <span class="s1">desired = index_range(start=</span><span class="s3">'2009Q1'</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">'2009Q2'</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">'Q'</span><span class="s1">)</span>
    <span class="s1">assert_(news.total_impacts.index.equals(desired))</span>
    <span class="s1">predicted = res.predict(start=mod.nobs - </span><span class="s5">2</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">'2009Q2'</span><span class="s1">)</span>
    <span class="s1">assert_(news.total_impacts.index.equals(predicted.index))</span>

    <span class="s4"># Negative indexes</span>
    <span class="s4"># Note that negative indexes are always computed relative to the updated</span>
    <span class="s4"># sample, which in this case is 1 observation more than is in `mod.nobs`</span>
    <span class="s1">total_nobs = len(endog)</span>
    <span class="s1">assert_equal(total_nobs</span><span class="s2">, </span><span class="s1">mod.nobs + </span><span class="s5">1</span><span class="s1">)</span>

    <span class="s4"># Start (dates), end (int)</span>
    <span class="s1">desired = index_range(start=</span><span class="s3">'2009Q1'</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">'2009Q1'</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">'Q'</span><span class="s1">)</span>
    <span class="s2">for </span><span class="s1">end </span><span class="s2">in </span><span class="s1">[mod.nobs - </span><span class="s5">2</span><span class="s2">, </span><span class="s1">total_nobs - </span><span class="s5">3</span><span class="s2">, </span><span class="s1">-</span><span class="s5">3</span><span class="s1">]:</span>
        <span class="s1">news = res.news(endog</span><span class="s2">, </span><span class="s1">start=</span><span class="s3">'2009Q1'</span><span class="s2">, </span><span class="s1">end=end)</span>
        <span class="s1">assert_(news.total_impacts.index.equals(desired))</span>
        <span class="s4"># Note: predict does not allow negative indexing</span>
        <span class="s2">if </span><span class="s1">end &gt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">predicted = res.predict(start=</span><span class="s3">'2009Q1'</span><span class="s2">, </span><span class="s1">end=end)</span>
            <span class="s1">assert_(news.total_impacts.index.equals(predicted.index))</span>

    <span class="s4"># Start (int), end (dates)</span>
    <span class="s1">desired = index_range(start=</span><span class="s3">'2009Q1'</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">'2009Q1'</span><span class="s2">, </span><span class="s1">freq=</span><span class="s3">'Q'</span><span class="s1">)</span>
    <span class="s2">for </span><span class="s1">start </span><span class="s2">in </span><span class="s1">[mod.nobs - </span><span class="s5">2</span><span class="s2">, </span><span class="s1">total_nobs - </span><span class="s5">3</span><span class="s2">, </span><span class="s1">-</span><span class="s5">3</span><span class="s1">]:</span>
        <span class="s1">news = res.news(endog</span><span class="s2">, </span><span class="s1">start=start</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">'2009Q1'</span><span class="s1">)</span>
        <span class="s1">assert_(news.total_impacts.index.equals(desired))</span>
        <span class="s4"># Note: predict does not allow negative indexing</span>
        <span class="s2">if </span><span class="s1">end &gt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">predicted = res.predict(start=start</span><span class="s2">, </span><span class="s1">end=</span><span class="s3">'2009Q1'</span><span class="s1">)</span>
            <span class="s1">assert_(news.total_impacts.index.equals(predicted.index))</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s3">'which'</span><span class="s2">, </span><span class="s1">[</span><span class="s3">'range'</span><span class="s2">, </span><span class="s3">'range2'</span><span class="s2">, </span><span class="s3">'int64'</span><span class="s2">,</span>
                                   <span class="s3">'numpy'</span><span class="s2">, </span><span class="s3">'list'</span><span class="s1">])</span>
<span class="s2">def </span><span class="s1">test_start_end_int(which):</span>
    <span class="s1">endog = dta[</span><span class="s3">'infl'</span><span class="s1">].copy()</span>
    <span class="s1">nobs = len(endog)</span>
    <span class="s2">if </span><span class="s1">which == </span><span class="s3">'range'</span><span class="s1">:</span>
        <span class="s1">endog.index = pd.RangeIndex(nobs)</span>
        <span class="s1">endog_init = endog.iloc[:-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">index_plus2 = pd.RangeIndex(nobs + </span><span class="s5">2</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">which == </span><span class="s3">'range2'</span><span class="s1">:</span>
        <span class="s1">endog.index = pd.RangeIndex(stop=nobs * </span><span class="s5">2</span><span class="s2">, </span><span class="s1">step=</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">endog_init = endog.iloc[:-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">index_plus2 = pd.RangeIndex((nobs + </span><span class="s5">2</span><span class="s1">) * </span><span class="s5">2</span><span class="s2">, </span><span class="s1">step=</span><span class="s5">2</span><span class="s1">)</span>
    <span class="s2">elif </span><span class="s1">which == </span><span class="s3">'int64'</span><span class="s1">:</span>
        <span class="s1">endog.index = pd.Index(np.arange(nobs))</span>
        <span class="s1">endog_init = endog.iloc[:-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">index_plus2 = pd.Index(np.arange(nobs + </span><span class="s5">2</span><span class="s1">))</span>
    <span class="s2">elif </span><span class="s1">which == </span><span class="s3">'numpy'</span><span class="s1">:</span>
        <span class="s1">endog = endog.values</span>
        <span class="s1">endog_init = endog[:-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">index_plus2 = pd.RangeIndex(nobs + </span><span class="s5">2</span><span class="s1">)</span>
    <span class="s2">elif </span><span class="s1">which == </span><span class="s3">'list'</span><span class="s1">:</span>
        <span class="s1">endog = endog.tolist()</span>
        <span class="s1">endog_init = endog[:-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">index_plus2 = pd.RangeIndex(nobs + </span><span class="s5">2</span><span class="s1">)</span>

    <span class="s1">mod = sarimax.SARIMAX(endog_init)</span>
    <span class="s1">res = mod.smooth([</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">1.0</span><span class="s1">])</span>

    <span class="s4"># Default is the last in-sample period</span>
    <span class="s1">news = res.news(endog)</span>
    <span class="s1">desired = index_plus2[-</span><span class="s5">4</span><span class="s1">:-</span><span class="s5">3</span><span class="s1">]</span>
    <span class="s1">assert_(news.total_impacts.index.equals(desired))</span>

    <span class="s4"># Start, periods</span>
    <span class="s1">news = res.news(endog</span><span class="s2">, </span><span class="s1">start=mod.nobs - </span><span class="s5">1</span><span class="s2">, </span><span class="s1">periods=</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">desired = index_plus2[-</span><span class="s5">4</span><span class="s1">:-</span><span class="s5">3</span><span class="s1">]</span>
    <span class="s1">assert_(news.total_impacts.index.equals(desired))</span>
    <span class="s1">news = res.news(endog</span><span class="s2">, </span><span class="s1">start=mod.nobs - </span><span class="s5">2</span><span class="s2">, </span><span class="s1">periods=</span><span class="s5">2</span><span class="s1">)</span>
    <span class="s1">desired = index_plus2[-</span><span class="s5">5</span><span class="s1">:-</span><span class="s5">3</span><span class="s1">]</span>
    <span class="s1">assert_(news.total_impacts.index.equals(desired))</span>

    <span class="s4"># End, periods</span>
    <span class="s1">news = res.news(endog</span><span class="s2">, </span><span class="s1">end=mod.nobs - </span><span class="s5">1</span><span class="s2">, </span><span class="s1">periods=</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">desired = index_plus2[-</span><span class="s5">4</span><span class="s1">:-</span><span class="s5">3</span><span class="s1">]</span>
    <span class="s1">assert_(news.total_impacts.index.equals(desired))</span>
    <span class="s1">news = res.news(endog</span><span class="s2">, </span><span class="s1">end=mod.nobs - </span><span class="s5">2</span><span class="s2">, </span><span class="s1">periods=</span><span class="s5">2</span><span class="s1">)</span>
    <span class="s1">desired = index_plus2[-</span><span class="s5">6</span><span class="s1">:-</span><span class="s5">4</span><span class="s1">]</span>
    <span class="s1">assert_(news.total_impacts.index.equals(desired))</span>

    <span class="s4"># Start, end</span>
    <span class="s4"># Note: end is inclusive, like `get_prediction`.</span>
    <span class="s1">news = res.news(endog</span><span class="s2">, </span><span class="s1">start=mod.nobs - </span><span class="s5">2</span><span class="s2">, </span><span class="s1">end=mod.nobs - </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">desired = index_plus2[-</span><span class="s5">5</span><span class="s1">:-</span><span class="s5">3</span><span class="s1">]</span>
    <span class="s1">assert_(news.total_impacts.index.equals(desired))</span>
    <span class="s2">if </span><span class="s1">which </span><span class="s2">not in </span><span class="s1">[</span><span class="s3">'numpy'</span><span class="s2">, </span><span class="s3">'list'</span><span class="s1">]:</span>
        <span class="s1">predicted = res.predict(start=mod.nobs - </span><span class="s5">2</span><span class="s2">, </span><span class="s1">end=mod.nobs - </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">assert_(news.total_impacts.index.equals(predicted.index))</span>

    <span class="s1">news = res.news(endog</span><span class="s2">, </span><span class="s1">start=mod.nobs</span><span class="s2">, </span><span class="s1">end=mod.nobs)</span>
    <span class="s1">desired = index_plus2[-</span><span class="s5">3</span><span class="s1">:-</span><span class="s5">2</span><span class="s1">]</span>
    <span class="s1">assert_(news.total_impacts.index.equals(desired))</span>
    <span class="s2">if </span><span class="s1">which </span><span class="s2">not in </span><span class="s1">[</span><span class="s3">'numpy'</span><span class="s2">, </span><span class="s3">'list'</span><span class="s1">]:</span>
        <span class="s1">predicted = res.predict(start=mod.nobs</span><span class="s2">, </span><span class="s1">end=mod.nobs)</span>
        <span class="s1">assert_(news.total_impacts.index.equals(predicted.index))</span>

    <span class="s1">news = res.news(endog</span><span class="s2">, </span><span class="s1">start=mod.nobs</span><span class="s2">, </span><span class="s1">end=mod.nobs + </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">desired = index_plus2[-</span><span class="s5">3</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">assert_(news.total_impacts.index.equals(desired))</span>
    <span class="s2">if </span><span class="s1">which </span><span class="s2">not in </span><span class="s1">[</span><span class="s3">'numpy'</span><span class="s2">, </span><span class="s3">'list'</span><span class="s1">]:</span>
        <span class="s1">predicted = res.predict(start=mod.nobs</span><span class="s2">, </span><span class="s1">end=mod.nobs + </span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">assert_(news.total_impacts.index.equals(predicted.index))</span>


<span class="s2">def </span><span class="s1">test_invalid():</span>
    <span class="s1">endog = dta[</span><span class="s3">'infl'</span><span class="s1">].copy()</span>
    <span class="s1">mod = sarimax.SARIMAX(endog.iloc[:-</span><span class="s5">1</span><span class="s1">])</span>
    <span class="s1">res = mod.smooth([</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">1.0</span><span class="s1">])</span>

    <span class="s1">msg = </span><span class="s3">'The index associated with the updated results is not a superset'</span>
    <span class="s2">with </span><span class="s1">pytest.raises(ValueError</span><span class="s2">, </span><span class="s1">match=msg):</span>
        <span class="s1">res.news(endog.values)</span>
</pre>
</body>
</html>