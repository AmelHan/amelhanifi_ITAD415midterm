<html>
<head>
<title>routines.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6897bb;}
.s4 { color: #6a8759;}
.s5 { color: #629755; font-style: italic;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
routines.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">__future__ </span><span class="s0">import </span><span class="s1">annotations</span>

<span class="s0">import </span><span class="s1">math</span>
<span class="s0">import </span><span class="s1">warnings</span>
<span class="s0">from </span><span class="s1">collections.abc </span><span class="s0">import </span><span class="s1">Iterable</span>
<span class="s0">from </span><span class="s1">functools </span><span class="s0">import </span><span class="s1">partial</span><span class="s0">, </span><span class="s1">reduce</span><span class="s0">, </span><span class="s1">wraps</span>
<span class="s0">from </span><span class="s1">numbers </span><span class="s0">import </span><span class="s1">Integral</span><span class="s0">, </span><span class="s1">Real</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">from </span><span class="s1">tlz </span><span class="s0">import </span><span class="s1">concat</span><span class="s0">, </span><span class="s1">interleave</span><span class="s0">, </span><span class="s1">sliding_window</span>

<span class="s0">from </span><span class="s1">dask.array </span><span class="s0">import </span><span class="s1">chunk</span>
<span class="s0">from </span><span class="s1">dask.array.core </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">Array</span><span class="s0">,</span>
    <span class="s1">asanyarray</span><span class="s0">,</span>
    <span class="s1">asarray</span><span class="s0">,</span>
    <span class="s1">blockwise</span><span class="s0">,</span>
    <span class="s1">broadcast_arrays</span><span class="s0">,</span>
    <span class="s1">broadcast_shapes</span><span class="s0">,</span>
    <span class="s1">broadcast_to</span><span class="s0">,</span>
    <span class="s1">concatenate</span><span class="s0">,</span>
    <span class="s1">elemwise</span><span class="s0">,</span>
    <span class="s1">from_array</span><span class="s0">,</span>
    <span class="s1">implements</span><span class="s0">,</span>
    <span class="s1">is_scalar_for_elemwise</span><span class="s0">,</span>
    <span class="s1">map_blocks</span><span class="s0">,</span>
    <span class="s1">stack</span><span class="s0">,</span>
    <span class="s1">tensordot_lookup</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">dask.array.creation </span><span class="s0">import </span><span class="s1">arange</span><span class="s0">, </span><span class="s1">diag</span><span class="s0">, </span><span class="s1">empty</span><span class="s0">, </span><span class="s1">indices</span><span class="s0">, </span><span class="s1">tri</span>
<span class="s0">from </span><span class="s1">dask.array.einsumfuncs </span><span class="s0">import </span><span class="s1">einsum  </span><span class="s2"># noqa</span>
<span class="s0">from </span><span class="s1">dask.array.reductions </span><span class="s0">import </span><span class="s1">reduction</span>
<span class="s0">from </span><span class="s1">dask.array.ufunc </span><span class="s0">import </span><span class="s1">multiply</span><span class="s0">, </span><span class="s1">sqrt</span>
<span class="s0">from </span><span class="s1">dask.array.utils </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">array_safe</span><span class="s0">,</span>
    <span class="s1">asarray_safe</span><span class="s0">,</span>
    <span class="s1">meta_from_array</span><span class="s0">,</span>
    <span class="s1">safe_wraps</span><span class="s0">,</span>
    <span class="s1">validate_axis</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">from </span><span class="s1">dask.array.wrap </span><span class="s0">import </span><span class="s1">ones</span>
<span class="s0">from </span><span class="s1">dask.base </span><span class="s0">import </span><span class="s1">is_dask_collection</span><span class="s0">, </span><span class="s1">tokenize</span>
<span class="s0">from </span><span class="s1">dask.core </span><span class="s0">import </span><span class="s1">flatten</span>
<span class="s0">from </span><span class="s1">dask.delayed </span><span class="s0">import </span><span class="s1">Delayed</span><span class="s0">, </span><span class="s1">unpack_collections</span>
<span class="s0">from </span><span class="s1">dask.highlevelgraph </span><span class="s0">import </span><span class="s1">HighLevelGraph</span>
<span class="s0">from </span><span class="s1">dask.utils </span><span class="s0">import </span><span class="s1">apply</span><span class="s0">, </span><span class="s1">derived_from</span><span class="s0">, </span><span class="s1">funcname</span><span class="s0">, </span><span class="s1">is_arraylike</span><span class="s0">, </span><span class="s1">is_cupy_type</span>

<span class="s2"># save built-in for histogram functions which use range as a kwarg.</span>
<span class="s1">_range = range</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">array(x</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s0">None, </span><span class="s1">ndmin=</span><span class="s0">None, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">like=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s1">x = asarray(x</span><span class="s0">, </span><span class="s1">like=like)</span>
    <span class="s0">while </span><span class="s1">ndmin </span><span class="s0">is not None and </span><span class="s1">x.ndim &lt; ndmin:</span>
        <span class="s1">x = x[</span><span class="s0">None, </span><span class="s1">:]</span>
    <span class="s0">if </span><span class="s1">dtype </span><span class="s0">is not None and </span><span class="s1">x.dtype != dtype:</span>
        <span class="s1">x = x.astype(dtype)</span>
    <span class="s0">return </span><span class="s1">x</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">result_type(*args):</span>
    <span class="s1">args = [a </span><span class="s0">if </span><span class="s1">is_scalar_for_elemwise(a) </span><span class="s0">else </span><span class="s1">a.dtype </span><span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">args]</span>
    <span class="s0">return </span><span class="s1">np.result_type(*args)</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">atleast_3d(*arys):</span>
    <span class="s1">new_arys = []</span>
    <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">arys:</span>
        <span class="s1">x = asanyarray(x)</span>
        <span class="s0">if </span><span class="s1">x.ndim == </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">x = x[</span><span class="s0">None, None, None</span><span class="s1">]</span>
        <span class="s0">elif </span><span class="s1">x.ndim == </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s1">x = x[</span><span class="s0">None, </span><span class="s1">:</span><span class="s0">, None</span><span class="s1">]</span>
        <span class="s0">elif </span><span class="s1">x.ndim == </span><span class="s3">2</span><span class="s1">:</span>
            <span class="s1">x = x[:</span><span class="s0">, </span><span class="s1">:</span><span class="s0">, None</span><span class="s1">]</span>

        <span class="s1">new_arys.append(x)</span>

    <span class="s0">if </span><span class="s1">len(new_arys) == </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">new_arys[</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">new_arys</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">atleast_2d(*arys):</span>
    <span class="s1">new_arys = []</span>
    <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">arys:</span>
        <span class="s1">x = asanyarray(x)</span>
        <span class="s0">if </span><span class="s1">x.ndim == </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">x = x[</span><span class="s0">None, None</span><span class="s1">]</span>
        <span class="s0">elif </span><span class="s1">x.ndim == </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s1">x = x[</span><span class="s0">None, </span><span class="s1">:]</span>

        <span class="s1">new_arys.append(x)</span>

    <span class="s0">if </span><span class="s1">len(new_arys) == </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">new_arys[</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">new_arys</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">atleast_1d(*arys):</span>
    <span class="s1">new_arys = []</span>
    <span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">arys:</span>
        <span class="s1">x = asanyarray(x)</span>
        <span class="s0">if </span><span class="s1">x.ndim == </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">x = x[</span><span class="s0">None</span><span class="s1">]</span>

        <span class="s1">new_arys.append(x)</span>

    <span class="s0">if </span><span class="s1">len(new_arys) == </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">new_arys[</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">new_arys</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">vstack(tup</span><span class="s0">, </span><span class="s1">allow_unknown_chunksizes=</span><span class="s0">False</span><span class="s1">):</span>
    <span class="s0">if </span><span class="s1">isinstance(tup</span><span class="s0">, </span><span class="s1">Array):</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError(</span>
            <span class="s4">&quot;``vstack`` expects a sequence of arrays as the first argument&quot;</span>
        <span class="s1">)</span>

    <span class="s1">tup = tuple(atleast_2d(x) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">tup)</span>
    <span class="s0">return </span><span class="s1">concatenate(tup</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">allow_unknown_chunksizes=allow_unknown_chunksizes)</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">hstack(tup</span><span class="s0">, </span><span class="s1">allow_unknown_chunksizes=</span><span class="s0">False</span><span class="s1">):</span>
    <span class="s0">if </span><span class="s1">isinstance(tup</span><span class="s0">, </span><span class="s1">Array):</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError(</span>
            <span class="s4">&quot;``hstack`` expects a sequence of arrays as the first argument&quot;</span>
        <span class="s1">)</span>

    <span class="s0">if </span><span class="s1">all(x.ndim == </span><span class="s3">1 </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">tup):</span>
        <span class="s0">return </span><span class="s1">concatenate(</span>
            <span class="s1">tup</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">allow_unknown_chunksizes=allow_unknown_chunksizes</span>
        <span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">concatenate(</span>
            <span class="s1">tup</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s0">, </span><span class="s1">allow_unknown_chunksizes=allow_unknown_chunksizes</span>
        <span class="s1">)</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">dstack(tup</span><span class="s0">, </span><span class="s1">allow_unknown_chunksizes=</span><span class="s0">False</span><span class="s1">):</span>
    <span class="s0">if </span><span class="s1">isinstance(tup</span><span class="s0">, </span><span class="s1">Array):</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError(</span>
            <span class="s4">&quot;``dstack`` expects a sequence of arrays as the first argument&quot;</span>
        <span class="s1">)</span>

    <span class="s1">tup = tuple(atleast_3d(x) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">tup)</span>
    <span class="s0">return </span><span class="s1">concatenate(tup</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">allow_unknown_chunksizes=allow_unknown_chunksizes)</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">swapaxes(a</span><span class="s0">, </span><span class="s1">axis1</span><span class="s0">, </span><span class="s1">axis2):</span>
    <span class="s0">if </span><span class="s1">axis1 == axis2:</span>
        <span class="s0">return </span><span class="s1">a</span>
    <span class="s0">if </span><span class="s1">axis1 &lt; </span><span class="s3">0</span><span class="s1">:</span>
        <span class="s1">axis1 = axis1 + a.ndim</span>
    <span class="s0">if </span><span class="s1">axis2 &lt; </span><span class="s3">0</span><span class="s1">:</span>
        <span class="s1">axis2 = axis2 + a.ndim</span>
    <span class="s1">ind = list(range(a.ndim))</span>
    <span class="s1">out = list(ind)</span>
    <span class="s1">out[axis1]</span><span class="s0">, </span><span class="s1">out[axis2] = axis2</span><span class="s0">, </span><span class="s1">axis1</span>

    <span class="s0">return </span><span class="s1">blockwise(np.swapaxes</span><span class="s0">, </span><span class="s1">out</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">ind</span><span class="s0">, </span><span class="s1">axis1=axis1</span><span class="s0">, </span><span class="s1">axis2=axis2</span><span class="s0">, </span><span class="s1">dtype=a.dtype)</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">transpose(a</span><span class="s0">, </span><span class="s1">axes=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s0">if </span><span class="s1">axes:</span>
        <span class="s0">if </span><span class="s1">len(axes) != a.ndim:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;axes don't match array&quot;</span><span class="s1">)</span>
        <span class="s1">axes = tuple(d + a.ndim </span><span class="s0">if </span><span class="s1">d &lt; </span><span class="s3">0 </span><span class="s0">else </span><span class="s1">d </span><span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">axes)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">axes = tuple(range(a.ndim))[::-</span><span class="s3">1</span><span class="s1">]</span>
    <span class="s0">return </span><span class="s1">blockwise(</span>
        <span class="s1">np.transpose</span><span class="s0">, </span><span class="s1">axes</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">tuple(range(a.ndim))</span><span class="s0">, </span><span class="s1">dtype=a.dtype</span><span class="s0">, </span><span class="s1">axes=axes</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">flip(m</span><span class="s0">, </span><span class="s1">axis=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Reverse element order along axis. 
 
    Parameters 
    ---------- 
    m : array_like 
        Input array. 
    axis : None or int or tuple of ints, optional 
        Axis or axes to reverse element order of. None will reverse all axes. 
 
    Returns 
    ------- 
    dask.array.Array 
        The flipped array. 
    &quot;&quot;&quot;</span>

    <span class="s1">m = asanyarray(m)</span>

    <span class="s1">sl = m.ndim * [slice(</span><span class="s0">None</span><span class="s1">)]</span>
    <span class="s0">if </span><span class="s1">axis </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">axis = range(m.ndim)</span>
    <span class="s0">if not </span><span class="s1">isinstance(axis</span><span class="s0">, </span><span class="s1">Iterable):</span>
        <span class="s1">axis = (axis</span><span class="s0">,</span><span class="s1">)</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">axis:</span>
            <span class="s1">sl[ax] = slice(</span><span class="s0">None, None, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s0">except </span><span class="s1">IndexError </span><span class="s0">as </span><span class="s1">e:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span>
            <span class="s4">f&quot;`axis` of </span><span class="s0">{</span><span class="s1">str(axis)</span><span class="s0">} </span><span class="s4">invalid for </span><span class="s0">{</span><span class="s1">str(m.ndim)</span><span class="s0">}</span><span class="s4">-D array&quot;</span>
        <span class="s1">) </span><span class="s0">from </span><span class="s1">e</span>
    <span class="s1">sl = tuple(sl)</span>

    <span class="s0">return </span><span class="s1">m[sl]</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">flipud(m):</span>
    <span class="s0">return </span><span class="s1">flip(m</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">fliplr(m):</span>
    <span class="s0">return </span><span class="s1">flip(m</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">rot90(m</span><span class="s0">, </span><span class="s1">k=</span><span class="s3">1</span><span class="s0">, </span><span class="s1">axes=(</span><span class="s3">0</span><span class="s0">, </span><span class="s3">1</span><span class="s1">)):</span>
    <span class="s1">axes = tuple(axes)</span>
    <span class="s0">if </span><span class="s1">len(axes) != </span><span class="s3">2</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;len(axes) must be 2.&quot;</span><span class="s1">)</span>

    <span class="s1">m = asanyarray(m)</span>

    <span class="s0">if </span><span class="s1">axes[</span><span class="s3">0</span><span class="s1">] == axes[</span><span class="s3">1</span><span class="s1">] </span><span class="s0">or </span><span class="s1">np.absolute(axes[</span><span class="s3">0</span><span class="s1">] - axes[</span><span class="s3">1</span><span class="s1">]) == m.ndim:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Axes must be different.&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">axes[</span><span class="s3">0</span><span class="s1">] &gt;= m.ndim </span><span class="s0">or </span><span class="s1">axes[</span><span class="s3">0</span><span class="s1">] &lt; -m.ndim </span><span class="s0">or </span><span class="s1">axes[</span><span class="s3">1</span><span class="s1">] &gt;= m.ndim </span><span class="s0">or </span><span class="s1">axes[</span><span class="s3">1</span><span class="s1">] &lt; -m.ndim:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">f&quot;Axes=</span><span class="s0">{</span><span class="s1">axes</span><span class="s0">} </span><span class="s4">out of range for array of ndim=</span><span class="s0">{</span><span class="s1">m.ndim</span><span class="s0">}</span><span class="s4">.&quot;</span><span class="s1">)</span>

    <span class="s1">k %= </span><span class="s3">4</span>

    <span class="s0">if </span><span class="s1">k == </span><span class="s3">0</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">m[:]</span>
    <span class="s0">if </span><span class="s1">k == </span><span class="s3">2</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">flip(flip(m</span><span class="s0">, </span><span class="s1">axes[</span><span class="s3">0</span><span class="s1">])</span><span class="s0">, </span><span class="s1">axes[</span><span class="s3">1</span><span class="s1">])</span>

    <span class="s1">axes_list = list(range(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">m.ndim))</span>
    <span class="s1">(axes_list[axes[</span><span class="s3">0</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">axes_list[axes[</span><span class="s3">1</span><span class="s1">]]) = (axes_list[axes[</span><span class="s3">1</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">axes_list[axes[</span><span class="s3">0</span><span class="s1">]])</span>

    <span class="s0">if </span><span class="s1">k == </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">transpose(flip(m</span><span class="s0">, </span><span class="s1">axes[</span><span class="s3">1</span><span class="s1">])</span><span class="s0">, </span><span class="s1">axes_list)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s2"># k == 3</span>
        <span class="s0">return </span><span class="s1">flip(transpose(m</span><span class="s0">, </span><span class="s1">axes_list)</span><span class="s0">, </span><span class="s1">axes[</span><span class="s3">1</span><span class="s1">])</span>


<span class="s0">def </span><span class="s1">_tensordot(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axes</span><span class="s0">, </span><span class="s1">is_sparse):</span>
    <span class="s1">x = max([a</span><span class="s0">, </span><span class="s1">b]</span><span class="s0">, </span><span class="s1">key=</span><span class="s0">lambda </span><span class="s1">x: x.__array_priority__)</span>
    <span class="s1">tensordot = tensordot_lookup.dispatch(type(x))</span>
    <span class="s1">x = tensordot(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axes=axes)</span>
    <span class="s0">if </span><span class="s1">is_sparse </span><span class="s0">and </span><span class="s1">len(axes[</span><span class="s3">0</span><span class="s1">]) == </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">x</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">ind = [slice(</span><span class="s0">None, None</span><span class="s1">)] * x.ndim</span>
        <span class="s0">for </span><span class="s1">a </span><span class="s0">in </span><span class="s1">sorted(axes[</span><span class="s3">0</span><span class="s1">]):</span>
            <span class="s1">ind.insert(a</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s1">x = x[tuple(ind)]</span>
        <span class="s0">return </span><span class="s1">x</span>


<span class="s0">def </span><span class="s1">_tensordot_is_sparse(x):</span>
    <span class="s1">is_sparse = </span><span class="s4">&quot;sparse&quot; </span><span class="s0">in </span><span class="s1">str(type(x._meta))</span>
    <span class="s0">if </span><span class="s1">is_sparse:</span>
        <span class="s2"># exclude pydata sparse arrays, no workaround required for these in tensordot</span>
        <span class="s1">is_sparse = </span><span class="s4">&quot;sparse._coo.core.COO&quot; </span><span class="s0">not in </span><span class="s1">str(type(x._meta))</span>
    <span class="s0">return </span><span class="s1">is_sparse</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">tensordot(lhs</span><span class="s0">, </span><span class="s1">rhs</span><span class="s0">, </span><span class="s1">axes=</span><span class="s3">2</span><span class="s1">):</span>
    <span class="s0">if not </span><span class="s1">isinstance(lhs</span><span class="s0">, </span><span class="s1">Array):</span>
        <span class="s1">lhs = from_array(lhs)</span>
    <span class="s0">if not </span><span class="s1">isinstance(rhs</span><span class="s0">, </span><span class="s1">Array):</span>
        <span class="s1">rhs = from_array(rhs)</span>

    <span class="s0">if </span><span class="s1">isinstance(axes</span><span class="s0">, </span><span class="s1">Iterable):</span>
        <span class="s1">left_axes</span><span class="s0">, </span><span class="s1">right_axes = axes</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">left_axes = tuple(range(lhs.ndim - axes</span><span class="s0">, </span><span class="s1">lhs.ndim))</span>
        <span class="s1">right_axes = tuple(range(</span><span class="s3">0</span><span class="s0">, </span><span class="s1">axes))</span>
    <span class="s0">if </span><span class="s1">isinstance(left_axes</span><span class="s0">, </span><span class="s1">Integral):</span>
        <span class="s1">left_axes = (left_axes</span><span class="s0">,</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">isinstance(right_axes</span><span class="s0">, </span><span class="s1">Integral):</span>
        <span class="s1">right_axes = (right_axes</span><span class="s0">,</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">isinstance(left_axes</span><span class="s0">, </span><span class="s1">list):</span>
        <span class="s1">left_axes = tuple(left_axes)</span>
    <span class="s0">if </span><span class="s1">isinstance(right_axes</span><span class="s0">, </span><span class="s1">list):</span>
        <span class="s1">right_axes = tuple(right_axes)</span>
    <span class="s1">is_sparse = _tensordot_is_sparse(lhs) </span><span class="s0">or </span><span class="s1">_tensordot_is_sparse(rhs)</span>
    <span class="s0">if </span><span class="s1">is_sparse </span><span class="s0">and </span><span class="s1">len(left_axes) == </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s1">concatenate = </span><span class="s0">True</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">concatenate = </span><span class="s0">False</span>
    <span class="s1">dt = np.promote_types(lhs.dtype</span><span class="s0">, </span><span class="s1">rhs.dtype)</span>
    <span class="s1">left_index = list(range(lhs.ndim))</span>
    <span class="s1">right_index = list(range(lhs.ndim</span><span class="s0">, </span><span class="s1">lhs.ndim + rhs.ndim))</span>
    <span class="s1">out_index = left_index + right_index</span>
    <span class="s1">adjust_chunks = {}</span>
    <span class="s0">for </span><span class="s1">l</span><span class="s0">, </span><span class="s1">r </span><span class="s0">in </span><span class="s1">zip(left_axes</span><span class="s0">, </span><span class="s1">right_axes):</span>
        <span class="s1">out_index.remove(right_index[r])</span>
        <span class="s1">right_index[r] = left_index[l]</span>
        <span class="s0">if </span><span class="s1">concatenate:</span>
            <span class="s1">out_index.remove(left_index[l])</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">adjust_chunks[left_index[l]] = </span><span class="s0">lambda </span><span class="s1">c: </span><span class="s3">1</span>
    <span class="s1">intermediate = blockwise(</span>
        <span class="s1">_tensordot</span><span class="s0">,</span>
        <span class="s1">out_index</span><span class="s0">,</span>
        <span class="s1">lhs</span><span class="s0">,</span>
        <span class="s1">left_index</span><span class="s0">,</span>
        <span class="s1">rhs</span><span class="s0">,</span>
        <span class="s1">right_index</span><span class="s0">,</span>
        <span class="s1">dtype=dt</span><span class="s0">,</span>
        <span class="s1">concatenate=concatenate</span><span class="s0">,</span>
        <span class="s1">adjust_chunks=adjust_chunks</span><span class="s0">,</span>
        <span class="s1">axes=(left_axes</span><span class="s0">, </span><span class="s1">right_axes)</span><span class="s0">,</span>
        <span class="s1">is_sparse=is_sparse</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">if </span><span class="s1">concatenate:</span>
        <span class="s0">return </span><span class="s1">intermediate</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">intermediate.sum(axis=left_axes)</span>


<span class="s1">@derived_from(np</span><span class="s0">, </span><span class="s1">ua_args=[</span><span class="s4">&quot;out&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">dot(a</span><span class="s0">, </span><span class="s1">b):</span>
    <span class="s0">return </span><span class="s1">tensordot(a</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">axes=((a.ndim - </span><span class="s3">1</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(b.ndim - </span><span class="s3">2</span><span class="s0">,</span><span class="s1">)))</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">vdot(a</span><span class="s0">, </span><span class="s1">b):</span>
    <span class="s0">return </span><span class="s1">dot(a.conj().ravel()</span><span class="s0">, </span><span class="s1">b.ravel())</span>


<span class="s0">def </span><span class="s1">_chunk_sum(a</span><span class="s0">, </span><span class="s1">axis=</span><span class="s0">None, </span><span class="s1">dtype=</span><span class="s0">None, </span><span class="s1">keepdims=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s2"># Caution: this is not your conventional array-sum: due</span>
    <span class="s2"># to the special nature of the preceding blockwise con-</span>
    <span class="s2"># traction,  each chunk is expected to have exactly the</span>
    <span class="s2"># same shape,  with a size of 1 for the dimension given</span>
    <span class="s2"># by `axis` (the reduction axis).  This makes mere ele-</span>
    <span class="s2"># ment-wise addition of the arrays possible.   Besides,</span>
    <span class="s2"># the output can be merely squeezed to lose the `axis`-</span>
    <span class="s2"># dimension when keepdims = False</span>
    <span class="s0">if </span><span class="s1">type(a) </span><span class="s0">is </span><span class="s1">list:</span>
        <span class="s1">out = reduce(partial(np.add</span><span class="s0">, </span><span class="s1">dtype=dtype)</span><span class="s0">, </span><span class="s1">a)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">out = a</span>

    <span class="s0">if </span><span class="s1">keepdims:</span>
        <span class="s0">return </span><span class="s1">out</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">out.squeeze(axis[</span><span class="s3">0</span><span class="s1">])</span>


<span class="s0">def </span><span class="s1">_sum_wo_cat(a</span><span class="s0">, </span><span class="s1">axis=</span><span class="s0">None, </span><span class="s1">dtype=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s0">if </span><span class="s1">dtype </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">dtype = getattr(np.zeros(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">dtype=a.dtype).sum()</span><span class="s0">, </span><span class="s4">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">object)</span>

    <span class="s0">if </span><span class="s1">a.shape[axis] == </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">a.squeeze(axis)</span>

    <span class="s0">return </span><span class="s1">reduction(</span>
        <span class="s1">a</span><span class="s0">, </span><span class="s1">_chunk_sum</span><span class="s0">, </span><span class="s1">_chunk_sum</span><span class="s0">, </span><span class="s1">axis=axis</span><span class="s0">, </span><span class="s1">dtype=dtype</span><span class="s0">, </span><span class="s1">concatenate=</span><span class="s0">False</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">_matmul(a</span><span class="s0">, </span><span class="s1">b):</span>
    <span class="s1">xp = np</span>

    <span class="s0">if </span><span class="s1">is_cupy_type(a):</span>
        <span class="s2"># This branch appears to  be unnecessary since cupy</span>
        <span class="s2"># version 9.0. See the following link:</span>
        <span class="s2"># https://github.com/dask/dask/pull/8423#discussion_r768291271</span>
        <span class="s2"># But it remains here  for  backward-compatibility.</span>
        <span class="s2"># Consider removing it in a future version of dask.</span>
        <span class="s0">import </span><span class="s1">cupy</span>

        <span class="s1">xp = cupy</span>

    <span class="s1">chunk = xp.matmul(a</span><span class="s0">, </span><span class="s1">b)</span>
    <span class="s2"># Since we have performed the contraction via xp.matmul</span>
    <span class="s2"># but blockwise expects all dimensions back  (including</span>
    <span class="s2"># the contraction-axis in  the 2nd-to-last position  of</span>
    <span class="s2"># the output), we must then put it back in the expected</span>
    <span class="s2"># the position ourselves:</span>
    <span class="s0">return </span><span class="s1">chunk[...</span><span class="s0">, </span><span class="s1">xp.newaxis</span><span class="s0">, </span><span class="s1">:]</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">matmul(a</span><span class="s0">, </span><span class="s1">b):</span>
    <span class="s1">a = asanyarray(a)</span>
    <span class="s1">b = asanyarray(b)</span>

    <span class="s0">if </span><span class="s1">a.ndim == </span><span class="s3">0 </span><span class="s0">or </span><span class="s1">b.ndim == </span><span class="s3">0</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;`matmul` does not support scalars.&quot;</span><span class="s1">)</span>

    <span class="s1">a_is_1d = </span><span class="s0">False</span>
    <span class="s0">if </span><span class="s1">a.ndim == </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s1">a_is_1d = </span><span class="s0">True</span>
        <span class="s1">a = a[np.newaxis</span><span class="s0">, </span><span class="s1">:]</span>

    <span class="s1">b_is_1d = </span><span class="s0">False</span>
    <span class="s0">if </span><span class="s1">b.ndim == </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s1">b_is_1d = </span><span class="s0">True</span>
        <span class="s1">b = b[:</span><span class="s0">, </span><span class="s1">np.newaxis]</span>

    <span class="s0">if </span><span class="s1">a.ndim &lt; b.ndim:</span>
        <span class="s1">a = a[(b.ndim - a.ndim) * (np.newaxis</span><span class="s0">,</span><span class="s1">)]</span>
    <span class="s0">elif </span><span class="s1">a.ndim &gt; b.ndim:</span>
        <span class="s1">b = b[(a.ndim - b.ndim) * (np.newaxis</span><span class="s0">,</span><span class="s1">)]</span>

    <span class="s2"># out_ind includes all dimensions to prevent contraction</span>
    <span class="s2"># in the blockwise below.  We set the last two dimensions</span>
    <span class="s2"># of the output to the contraction axis and the 2nd</span>
    <span class="s2"># (last) dimension of b in that order</span>
    <span class="s1">out_ind = tuple(range(a.ndim + </span><span class="s3">1</span><span class="s1">))</span>
    <span class="s2"># lhs_ind includes `a`/LHS dimensions</span>
    <span class="s1">lhs_ind = tuple(range(a.ndim))</span>
    <span class="s2"># on `b`/RHS everything above 2nd dimension, is the same</span>
    <span class="s2"># as `a`, -2 dimension is &quot;contracted&quot; with the last dimension</span>
    <span class="s2"># of `a`, last dimension of `b` is `b` specific</span>
    <span class="s1">rhs_ind = tuple(range(a.ndim - </span><span class="s3">2</span><span class="s1">)) + (lhs_ind[-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">a.ndim)</span>

    <span class="s1">out = blockwise(</span>
        <span class="s1">_matmul</span><span class="s0">,</span>
        <span class="s1">out_ind</span><span class="s0">,</span>
        <span class="s1">a</span><span class="s0">,</span>
        <span class="s1">lhs_ind</span><span class="s0">,</span>
        <span class="s1">b</span><span class="s0">,</span>
        <span class="s1">rhs_ind</span><span class="s0">,</span>
        <span class="s1">adjust_chunks={lhs_ind[-</span><span class="s3">1</span><span class="s1">]: </span><span class="s3">1</span><span class="s1">}</span><span class="s0">,</span>
        <span class="s1">dtype=result_type(a</span><span class="s0">, </span><span class="s1">b)</span><span class="s0">,</span>
        <span class="s1">concatenate=</span><span class="s0">False,</span>
    <span class="s1">)</span>

    <span class="s2"># Because contraction + concatenate in blockwise leads to high</span>
    <span class="s2"># memory footprints, we want to avoid them. Instead we will perform</span>
    <span class="s2"># blockwise (without contraction) followed by reduction. More about</span>
    <span class="s2"># this issue: https://github.com/dask/dask/issues/6874</span>

    <span class="s2"># We will also perform the reduction without concatenation</span>
    <span class="s1">out = _sum_wo_cat(out</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">2</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">a_is_1d:</span>
        <span class="s1">out = out.squeeze(-</span><span class="s3">2</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">b_is_1d:</span>
        <span class="s1">out = out.squeeze(-</span><span class="s3">1</span><span class="s1">)</span>

    <span class="s0">return </span><span class="s1">out</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">outer(a</span><span class="s0">, </span><span class="s1">b):</span>
    <span class="s1">a = a.flatten()</span>
    <span class="s1">b = b.flatten()</span>

    <span class="s1">dtype = np.outer(a.dtype.type()</span><span class="s0">, </span><span class="s1">b.dtype.type()).dtype</span>

    <span class="s0">return </span><span class="s1">blockwise(np.outer</span><span class="s0">, </span><span class="s4">&quot;ij&quot;</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s4">&quot;i&quot;</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s4">&quot;j&quot;</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>


<span class="s0">def </span><span class="s1">_inner_apply_along_axis(arr</span><span class="s0">, </span><span class="s1">func1d</span><span class="s0">, </span><span class="s1">func1d_axis</span><span class="s0">, </span><span class="s1">func1d_args</span><span class="s0">, </span><span class="s1">func1d_kwargs):</span>
    <span class="s0">return </span><span class="s1">np.apply_along_axis(func1d</span><span class="s0">, </span><span class="s1">func1d_axis</span><span class="s0">, </span><span class="s1">arr</span><span class="s0">, </span><span class="s1">*func1d_args</span><span class="s0">, </span><span class="s1">**func1d_kwargs)</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">apply_along_axis(func1d</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">arr</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s0">None, </span><span class="s1">shape=</span><span class="s0">None, </span><span class="s1">**kwargs):</span>
    <span class="s5">&quot;&quot;&quot; 
    This is a blocked variant of :func:`numpy.apply_along_axis` implemented via 
    :func:`dask.array.map_blocks` 
 
    Notes 
    ----- 
    If either of `dtype` or `shape` are not provided, Dask attempts to 
    determine them by calling `func1d` on a dummy array. This may produce 
    incorrect values for `dtype` or `shape`, so we recommend providing them. 
    &quot;&quot;&quot;</span>
    <span class="s1">arr = asarray(arr)</span>

    <span class="s2"># Verify that axis is valid and throw an error otherwise</span>
    <span class="s1">axis = len(arr.shape[:axis])</span>

    <span class="s2"># If necessary, infer dtype and shape of the output of func1d by calling it on test data.</span>
    <span class="s0">if </span><span class="s1">shape </span><span class="s0">is None or </span><span class="s1">dtype </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">test_data = np.ones((</span><span class="s3">1</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=arr.dtype)</span>
        <span class="s1">test_result = np.array(func1d(test_data</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs))</span>
        <span class="s0">if </span><span class="s1">shape </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">shape = test_result.shape</span>
        <span class="s0">if </span><span class="s1">dtype </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">dtype = test_result.dtype</span>

    <span class="s2"># Rechunk so that func1d is applied over the full axis.</span>
    <span class="s1">arr = arr.rechunk(</span>
        <span class="s1">arr.chunks[:axis] + (arr.shape[axis : axis + </span><span class="s3">1</span><span class="s1">]</span><span class="s0">,</span><span class="s1">) + arr.chunks[axis + </span><span class="s3">1 </span><span class="s1">:]</span>
    <span class="s1">)</span>

    <span class="s2"># Map func1d over the data to get the result</span>
    <span class="s2"># Adds other axes as needed.</span>
    <span class="s1">result = arr.map_blocks(</span>
        <span class="s1">_inner_apply_along_axis</span><span class="s0">,</span>
        <span class="s1">name=funcname(func1d) + </span><span class="s4">&quot;-along-axis&quot;</span><span class="s0">,</span>
        <span class="s1">dtype=dtype</span><span class="s0">,</span>
        <span class="s1">chunks=(arr.chunks[:axis] + shape + arr.chunks[axis + </span><span class="s3">1 </span><span class="s1">:])</span><span class="s0">,</span>
        <span class="s1">drop_axis=axis</span><span class="s0">,</span>
        <span class="s1">new_axis=list(range(axis</span><span class="s0">, </span><span class="s1">axis + len(shape)</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">func1d=func1d</span><span class="s0">,</span>
        <span class="s1">func1d_axis=axis</span><span class="s0">,</span>
        <span class="s1">func1d_args=args</span><span class="s0">,</span>
        <span class="s1">func1d_kwargs=kwargs</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s0">return </span><span class="s1">result</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">apply_over_axes(func</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">axes):</span>
    <span class="s2"># Validate arguments</span>
    <span class="s1">a = asarray(a)</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">axes = tuple(axes)</span>
    <span class="s0">except </span><span class="s1">TypeError:</span>
        <span class="s1">axes = (axes</span><span class="s0">,</span><span class="s1">)</span>

    <span class="s1">sl = a.ndim * (slice(</span><span class="s0">None</span><span class="s1">)</span><span class="s0">,</span><span class="s1">)</span>

    <span class="s2"># Compute using `apply_along_axis`.</span>
    <span class="s1">result = a</span>
    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">axes:</span>
        <span class="s1">result = apply_along_axis(func</span><span class="s0">, </span><span class="s1">i</span><span class="s0">, </span><span class="s1">result</span><span class="s0">, </span><span class="s3">0</span><span class="s1">)</span>

        <span class="s2"># Restore original dimensionality or error.</span>
        <span class="s0">if </span><span class="s1">result.ndim == (a.ndim - </span><span class="s3">1</span><span class="s1">):</span>
            <span class="s1">result = result[sl[:i] + (</span><span class="s0">None,</span><span class="s1">)]</span>
        <span class="s0">elif </span><span class="s1">result.ndim != a.ndim:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;func must either preserve dimensionality of the input&quot;</span>
                <span class="s4">&quot; or reduce it by one.&quot;</span>
            <span class="s1">)</span>

    <span class="s0">return </span><span class="s1">result</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">ptp(a</span><span class="s0">, </span><span class="s1">axis=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s0">return </span><span class="s1">a.max(axis=axis) - a.min(axis=axis)</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">diff(a</span><span class="s0">, </span><span class="s1">n=</span><span class="s3">1</span><span class="s0">, </span><span class="s1">axis=-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">prepend=</span><span class="s0">None, </span><span class="s1">append=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s1">a = asarray(a)</span>
    <span class="s1">n = int(n)</span>
    <span class="s1">axis = int(axis)</span>

    <span class="s0">if </span><span class="s1">n == </span><span class="s3">0</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">a</span>
    <span class="s0">if </span><span class="s1">n &lt; </span><span class="s3">0</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;order must be non-negative but got %d&quot; </span><span class="s1">% n)</span>

    <span class="s1">combined = []</span>
    <span class="s0">if </span><span class="s1">prepend </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">prepend = asarray_safe(prepend</span><span class="s0">, </span><span class="s1">like=meta_from_array(a))</span>
        <span class="s0">if </span><span class="s1">prepend.ndim == </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">shape = list(a.shape)</span>
            <span class="s1">shape[axis] = </span><span class="s3">1</span>
            <span class="s1">prepend = broadcast_to(prepend</span><span class="s0">, </span><span class="s1">tuple(shape))</span>
        <span class="s1">combined.append(prepend)</span>

    <span class="s1">combined.append(a)</span>

    <span class="s0">if </span><span class="s1">append </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">append = asarray_safe(append</span><span class="s0">, </span><span class="s1">like=meta_from_array(a))</span>
        <span class="s0">if </span><span class="s1">append.ndim == </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">shape = list(a.shape)</span>
            <span class="s1">shape[axis] = </span><span class="s3">1</span>
            <span class="s1">append = np.broadcast_to(append</span><span class="s0">, </span><span class="s1">tuple(shape))</span>
        <span class="s1">combined.append(append)</span>

    <span class="s0">if </span><span class="s1">len(combined) &gt; </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s1">a = concatenate(combined</span><span class="s0">, </span><span class="s1">axis)</span>

    <span class="s1">sl_1 = a.ndim * [slice(</span><span class="s0">None</span><span class="s1">)]</span>
    <span class="s1">sl_2 = a.ndim * [slice(</span><span class="s0">None</span><span class="s1">)]</span>

    <span class="s1">sl_1[axis] = slice(</span><span class="s3">1</span><span class="s0">, None</span><span class="s1">)</span>
    <span class="s1">sl_2[axis] = slice(</span><span class="s0">None, </span><span class="s1">-</span><span class="s3">1</span><span class="s1">)</span>

    <span class="s1">sl_1 = tuple(sl_1)</span>
    <span class="s1">sl_2 = tuple(sl_2)</span>

    <span class="s1">r = a</span>
    <span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">range(n):</span>
        <span class="s1">r = r[sl_1] - r[sl_2]</span>

    <span class="s0">return </span><span class="s1">r</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">ediff1d(ary</span><span class="s0">, </span><span class="s1">to_end=</span><span class="s0">None, </span><span class="s1">to_begin=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s1">ary = asarray(ary)</span>

    <span class="s1">aryf = ary.flatten()</span>
    <span class="s1">r = aryf[</span><span class="s3">1</span><span class="s1">:] - aryf[:-</span><span class="s3">1</span><span class="s1">]</span>

    <span class="s1">r = [r]</span>
    <span class="s0">if </span><span class="s1">to_begin </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">r = [asarray(to_begin).flatten()] + r</span>
    <span class="s0">if </span><span class="s1">to_end </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">r = r + [asarray(to_end).flatten()]</span>
    <span class="s1">r = concatenate(r)</span>

    <span class="s0">return </span><span class="s1">r</span>


<span class="s0">def </span><span class="s1">_gradient_kernel(x</span><span class="s0">, </span><span class="s1">block_id</span><span class="s0">, </span><span class="s1">coord</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">array_locs</span><span class="s0">, </span><span class="s1">grad_kwargs):</span>
    <span class="s5">&quot;&quot;&quot; 
    x: nd-array 
        array of one block 
    coord: 1d-array or scalar 
        coordinate along which the gradient is computed. 
    axis: int 
        axis along which the gradient is computed 
    array_locs: 
        actual location along axis. None if coordinate is scalar 
    grad_kwargs: 
        keyword to be passed to np.gradient 
    &quot;&quot;&quot;</span>
    <span class="s1">block_loc = block_id[axis]</span>
    <span class="s0">if </span><span class="s1">array_locs </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">coord = coord[array_locs[</span><span class="s3">0</span><span class="s1">][block_loc] : array_locs[</span><span class="s3">1</span><span class="s1">][block_loc]]</span>
    <span class="s1">grad = np.gradient(x</span><span class="s0">, </span><span class="s1">coord</span><span class="s0">, </span><span class="s1">axis=axis</span><span class="s0">, </span><span class="s1">**grad_kwargs)</span>
    <span class="s0">return </span><span class="s1">grad</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">gradient(f</span><span class="s0">, </span><span class="s1">*varargs</span><span class="s0">, </span><span class="s1">axis=</span><span class="s0">None, </span><span class="s1">**kwargs):</span>
    <span class="s1">f = asarray(f)</span>

    <span class="s1">kwargs[</span><span class="s4">&quot;edge_order&quot;</span><span class="s1">] = math.ceil(kwargs.get(</span><span class="s4">&quot;edge_order&quot;</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span>
    <span class="s0">if </span><span class="s1">kwargs[</span><span class="s4">&quot;edge_order&quot;</span><span class="s1">] &gt; </span><span class="s3">2</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;edge_order must be less than or equal to 2.&quot;</span><span class="s1">)</span>

    <span class="s1">drop_result_list = </span><span class="s0">False</span>
    <span class="s0">if </span><span class="s1">axis </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">axis = tuple(range(f.ndim))</span>
    <span class="s0">elif </span><span class="s1">isinstance(axis</span><span class="s0">, </span><span class="s1">Integral):</span>
        <span class="s1">drop_result_list = </span><span class="s0">True</span>
        <span class="s1">axis = (axis</span><span class="s0">,</span><span class="s1">)</span>

    <span class="s1">axis = validate_axis(axis</span><span class="s0">, </span><span class="s1">f.ndim)</span>

    <span class="s0">if </span><span class="s1">len(axis) != len(set(axis)):</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;duplicate axes not allowed&quot;</span><span class="s1">)</span>

    <span class="s1">axis = tuple(ax % f.ndim </span><span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">axis)</span>

    <span class="s0">if </span><span class="s1">varargs == ():</span>
        <span class="s1">varargs = (</span><span class="s3">1</span><span class="s0">,</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">len(varargs) == </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s1">varargs = len(axis) * varargs</span>
    <span class="s0">if </span><span class="s1">len(varargs) != len(axis):</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span>
            <span class="s4">&quot;Spacing must either be a single scalar, or a scalar / 1d-array per axis&quot;</span>
        <span class="s1">)</span>

    <span class="s0">if </span><span class="s1">issubclass(f.dtype.type</span><span class="s0">, </span><span class="s1">(np.bool_</span><span class="s0">, </span><span class="s1">Integral)):</span>
        <span class="s1">f = f.astype(float)</span>
    <span class="s0">elif </span><span class="s1">issubclass(f.dtype.type</span><span class="s0">, </span><span class="s1">Real) </span><span class="s0">and </span><span class="s1">f.dtype.itemsize &lt; </span><span class="s3">4</span><span class="s1">:</span>
        <span class="s1">f = f.astype(float)</span>

    <span class="s1">results = []</span>
    <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">enumerate(axis):</span>
        <span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">f.chunks[ax]:</span>
            <span class="s0">if </span><span class="s1">np.min(c) &lt; kwargs[</span><span class="s4">&quot;edge_order&quot;</span><span class="s1">] + </span><span class="s3">1</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">&quot;Chunk size must be larger than edge_order + 1. &quot;</span>
                    <span class="s4">&quot;Minimum chunk for axis {} is {}. Rechunk to &quot;</span>
                    <span class="s4">&quot;proceed.&quot;</span><span class="s1">.format(ax</span><span class="s0">, </span><span class="s1">np.min(c))</span>
                <span class="s1">)</span>

        <span class="s0">if </span><span class="s1">np.isscalar(varargs[i]):</span>
            <span class="s1">array_locs = </span><span class="s0">None</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">isinstance(varargs[i]</span><span class="s0">, </span><span class="s1">Array):</span>
                <span class="s0">raise </span><span class="s1">NotImplementedError(</span><span class="s4">&quot;dask array coordinated is not supported.&quot;</span><span class="s1">)</span>
            <span class="s2"># coordinate position for each block taking overlap into account</span>
            <span class="s1">chunk = np.array(f.chunks[ax])</span>
            <span class="s1">array_loc_stop = np.cumsum(chunk) + </span><span class="s3">1</span>
            <span class="s1">array_loc_start = array_loc_stop - chunk - </span><span class="s3">2</span>
            <span class="s1">array_loc_stop[-</span><span class="s3">1</span><span class="s1">] -= </span><span class="s3">1</span>
            <span class="s1">array_loc_start[</span><span class="s3">0</span><span class="s1">] = </span><span class="s3">0</span>
            <span class="s1">array_locs = (array_loc_start</span><span class="s0">, </span><span class="s1">array_loc_stop)</span>

        <span class="s1">results.append(</span>
            <span class="s1">f.map_overlap(</span>
                <span class="s1">_gradient_kernel</span><span class="s0">,</span>
                <span class="s1">dtype=f.dtype</span><span class="s0">,</span>
                <span class="s1">depth={j: </span><span class="s3">1 </span><span class="s0">if </span><span class="s1">j == ax </span><span class="s0">else </span><span class="s3">0 </span><span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">range(f.ndim)}</span><span class="s0">,</span>
                <span class="s1">boundary=</span><span class="s4">&quot;none&quot;</span><span class="s0">,</span>
                <span class="s1">coord=varargs[i]</span><span class="s0">,</span>
                <span class="s1">axis=ax</span><span class="s0">,</span>
                <span class="s1">array_locs=array_locs</span><span class="s0">,</span>
                <span class="s1">grad_kwargs=kwargs</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s0">if </span><span class="s1">drop_result_list:</span>
        <span class="s1">results = results[</span><span class="s3">0</span><span class="s1">]</span>

    <span class="s0">return </span><span class="s1">results</span>


<span class="s0">def </span><span class="s1">_bincount_agg(bincounts</span><span class="s0">, </span><span class="s1">dtype</span><span class="s0">, </span><span class="s1">**kwargs):</span>
    <span class="s0">if not </span><span class="s1">isinstance(bincounts</span><span class="s0">, </span><span class="s1">list):</span>
        <span class="s0">return </span><span class="s1">bincounts</span>

    <span class="s1">n = max(map(len</span><span class="s0">, </span><span class="s1">bincounts))</span>
    <span class="s1">out = np.zeros_like(bincounts[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">shape=n</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
    <span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">bincounts:</span>
        <span class="s1">out[: len(b)] += b</span>
    <span class="s0">return </span><span class="s1">out</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">bincount(x</span><span class="s0">, </span><span class="s1">weights=</span><span class="s0">None, </span><span class="s1">minlength=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">split_every=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s0">if </span><span class="s1">x.ndim != </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Input array must be one dimensional. Try using x.ravel()&quot;</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">weights </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">weights.chunks != x.chunks:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Chunks of input array x and weights must match.&quot;</span><span class="s1">)</span>

    <span class="s1">token = tokenize(x</span><span class="s0">, </span><span class="s1">weights</span><span class="s0">, </span><span class="s1">minlength)</span>
    <span class="s1">args = [x</span><span class="s0">, </span><span class="s4">&quot;i&quot;</span><span class="s1">]</span>
    <span class="s0">if </span><span class="s1">weights </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">meta = array_safe(np.bincount([</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">weights=[</span><span class="s3">1</span><span class="s1">])</span><span class="s0">, </span><span class="s1">like=meta_from_array(x))</span>
        <span class="s1">args.extend([weights</span><span class="s0">, </span><span class="s4">&quot;i&quot;</span><span class="s1">])</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">meta = array_safe(np.bincount([])</span><span class="s0">, </span><span class="s1">like=meta_from_array(x))</span>

    <span class="s0">if </span><span class="s1">minlength == </span><span class="s3">0</span><span class="s1">:</span>
        <span class="s1">output_size = (np.nan</span><span class="s0">,</span><span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">output_size = (minlength</span><span class="s0">,</span><span class="s1">)</span>

    <span class="s1">chunked_counts = blockwise(</span>
        <span class="s1">partial(np.bincount</span><span class="s0">, </span><span class="s1">minlength=minlength)</span><span class="s0">, </span><span class="s4">&quot;i&quot;</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">token=token</span><span class="s0">, </span><span class="s1">meta=meta</span>
    <span class="s1">)</span>
    <span class="s1">chunked_counts._chunks = (</span>
        <span class="s1">output_size * len(chunked_counts.chunks[</span><span class="s3">0</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">*chunked_counts.chunks[</span><span class="s3">1</span><span class="s1">:]</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s0">from </span><span class="s1">dask.array.reductions </span><span class="s0">import </span><span class="s1">_tree_reduce</span>

    <span class="s1">output = _tree_reduce(</span>
        <span class="s1">chunked_counts</span><span class="s0">,</span>
        <span class="s1">aggregate=partial(_bincount_agg</span><span class="s0">, </span><span class="s1">dtype=meta.dtype)</span><span class="s0">,</span>
        <span class="s1">axis=(</span><span class="s3">0</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">keepdims=</span><span class="s0">True,</span>
        <span class="s1">dtype=meta.dtype</span><span class="s0">,</span>
        <span class="s1">split_every=split_every</span><span class="s0">,</span>
        <span class="s1">concatenate=</span><span class="s0">False,</span>
    <span class="s1">)</span>
    <span class="s1">output._chunks = (output_size</span><span class="s0">, </span><span class="s1">*chunked_counts.chunks[</span><span class="s3">1</span><span class="s1">:])</span>
    <span class="s1">output._meta = meta</span>
    <span class="s0">return </span><span class="s1">output</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">digitize(a</span><span class="s0">, </span><span class="s1">bins</span><span class="s0">, </span><span class="s1">right=</span><span class="s0">False</span><span class="s1">):</span>
    <span class="s1">bins = asarray_safe(bins</span><span class="s0">, </span><span class="s1">like=meta_from_array(a))</span>
    <span class="s1">dtype = np.digitize(asarray_safe([</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">like=bins)</span><span class="s0">, </span><span class="s1">bins</span><span class="s0">, </span><span class="s1">right=</span><span class="s0">False</span><span class="s1">).dtype</span>
    <span class="s0">return </span><span class="s1">a.map_blocks(np.digitize</span><span class="s0">, </span><span class="s1">dtype=dtype</span><span class="s0">, </span><span class="s1">bins=bins</span><span class="s0">, </span><span class="s1">right=right)</span>


<span class="s0">def </span><span class="s1">_searchsorted_block(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">side):</span>
    <span class="s1">res = np.searchsorted(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">side=side)</span>
    <span class="s2"># 0 is only correct for the first block of a, but blockwise doesn't have a way</span>
    <span class="s2"># of telling which block is being operated on (unlike map_blocks),</span>
    <span class="s2"># so set all 0 values to a special value and set back at the end of searchsorted</span>
    <span class="s1">res[res == </span><span class="s3">0</span><span class="s1">] = -</span><span class="s3">1</span>
    <span class="s0">return </span><span class="s1">res[np.newaxis</span><span class="s0">, </span><span class="s1">:]</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">searchsorted(a</span><span class="s0">, </span><span class="s1">v</span><span class="s0">, </span><span class="s1">side=</span><span class="s4">&quot;left&quot;</span><span class="s0">, </span><span class="s1">sorter=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s0">if </span><span class="s1">a.ndim != </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Input array a must be one dimensional&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">sorter </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError(</span>
            <span class="s4">&quot;da.searchsorted with a sorter argument is not supported&quot;</span>
        <span class="s1">)</span>

    <span class="s2"># call np.searchsorted for each pair of blocks in a and v</span>
    <span class="s1">meta = np.searchsorted(a._meta</span><span class="s0">, </span><span class="s1">v._meta)</span>
    <span class="s1">out = blockwise(</span>
        <span class="s1">_searchsorted_block</span><span class="s0">,</span>
        <span class="s1">list(range(v.ndim + </span><span class="s3">1</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">a</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">v</span><span class="s0">,</span>
        <span class="s1">list(range(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">v.ndim + </span><span class="s3">1</span><span class="s1">))</span><span class="s0">,</span>
        <span class="s1">side</span><span class="s0">,</span>
        <span class="s0">None,</span>
        <span class="s1">meta=meta</span><span class="s0">,</span>
        <span class="s1">adjust_chunks={</span><span class="s3">0</span><span class="s1">: </span><span class="s3">1</span><span class="s1">}</span><span class="s0">,  </span><span class="s2"># one row for each block in a</span>
    <span class="s1">)</span>

    <span class="s2"># add offsets to take account of the position of each block within the array a</span>
    <span class="s1">a_chunk_sizes = array_safe((</span><span class="s3">0</span><span class="s0">, </span><span class="s1">*a.chunks[</span><span class="s3">0</span><span class="s1">])</span><span class="s0">, </span><span class="s1">like=meta_from_array(a))</span>
    <span class="s1">a_chunk_offsets = np.cumsum(a_chunk_sizes)[:-</span><span class="s3">1</span><span class="s1">]</span>
    <span class="s1">a_chunk_offsets = a_chunk_offsets[(Ellipsis</span><span class="s0">,</span><span class="s1">) + v.ndim * (np.newaxis</span><span class="s0">,</span><span class="s1">)]</span>
    <span class="s1">a_offsets = asarray(a_chunk_offsets</span><span class="s0">, </span><span class="s1">chunks=</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">out = where(out &lt; </span><span class="s3">0</span><span class="s0">, </span><span class="s1">out</span><span class="s0">, </span><span class="s1">out + a_offsets)</span>

    <span class="s2"># combine the results from each block (of a)</span>
    <span class="s1">out = out.max(axis=</span><span class="s3">0</span><span class="s1">)</span>

    <span class="s2"># fix up any -1 values</span>
    <span class="s1">out[out == -</span><span class="s3">1</span><span class="s1">] = </span><span class="s3">0</span>

    <span class="s0">return </span><span class="s1">out</span>


<span class="s2"># TODO: dask linspace doesn't support delayed values</span>
<span class="s0">def </span><span class="s1">_linspace_from_delayed(start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">num=</span><span class="s3">50</span><span class="s1">):</span>
    <span class="s1">linspace_name = </span><span class="s4">&quot;linspace-&quot; </span><span class="s1">+ tokenize(start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">num)</span>
    <span class="s1">(start_ref</span><span class="s0">, </span><span class="s1">stop_ref</span><span class="s0">, </span><span class="s1">num_ref)</span><span class="s0">, </span><span class="s1">deps = unpack_collections([start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">num])</span>
    <span class="s0">if </span><span class="s1">len(deps) == </span><span class="s3">0</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">np.linspace(start</span><span class="s0">, </span><span class="s1">stop</span><span class="s0">, </span><span class="s1">num=num)</span>

    <span class="s1">linspace_dsk = {(linspace_name</span><span class="s0">, </span><span class="s3">0</span><span class="s1">): (np.linspace</span><span class="s0">, </span><span class="s1">start_ref</span><span class="s0">, </span><span class="s1">stop_ref</span><span class="s0">, </span><span class="s1">num_ref)}</span>
    <span class="s1">linspace_graph = HighLevelGraph.from_collections(</span>
        <span class="s1">linspace_name</span><span class="s0">, </span><span class="s1">linspace_dsk</span><span class="s0">, </span><span class="s1">dependencies=deps</span>
    <span class="s1">)</span>

    <span class="s1">chunks = ((np.nan</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,</span><span class="s1">) </span><span class="s0">if </span><span class="s1">is_dask_collection(num) </span><span class="s0">else </span><span class="s1">((num</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">Array(linspace_graph</span><span class="s0">, </span><span class="s1">linspace_name</span><span class="s0">, </span><span class="s1">chunks</span><span class="s0">, </span><span class="s1">dtype=float)</span>


<span class="s0">def </span><span class="s1">_block_hist(x</span><span class="s0">, </span><span class="s1">bins</span><span class="s0">, </span><span class="s1">range=</span><span class="s0">None, </span><span class="s1">weights=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s0">return </span><span class="s1">np.histogram(x</span><span class="s0">, </span><span class="s1">bins</span><span class="s0">, </span><span class="s1">range=range</span><span class="s0">, </span><span class="s1">weights=weights)[</span><span class="s3">0</span><span class="s1">][np.newaxis]</span>


<span class="s0">def </span><span class="s1">histogram(a</span><span class="s0">, </span><span class="s1">bins=</span><span class="s0">None, </span><span class="s1">range=</span><span class="s0">None, </span><span class="s1">normed=</span><span class="s0">False, </span><span class="s1">weights=</span><span class="s0">None, </span><span class="s1">density=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Blocked variant of :func:`numpy.histogram`. 
 
    Parameters 
    ---------- 
    a : dask.array.Array 
        Input data; the histogram is computed over the flattened 
        array. If the ``weights`` argument is used, the chunks of 
        ``a`` are accessed to check chunking compatibility between 
        ``a`` and ``weights``. If ``weights`` is ``None``, a 
        :py:class:`dask.dataframe.Series` object can be passed as 
        input data. 
    bins : int or sequence of scalars, optional 
        Either an iterable specifying the ``bins`` or the number of ``bins`` 
        and a ``range`` argument is required as computing ``min`` and ``max`` 
        over blocked arrays is an expensive operation that must be performed 
        explicitly. 
        If `bins` is an int, it defines the number of equal-width 
        bins in the given range (10, by default). If `bins` is a 
        sequence, it defines a monotonically increasing array of bin edges, 
        including the rightmost edge, allowing for non-uniform bin widths. 
    range : (float, float), optional 
        The lower and upper range of the bins.  If not provided, range 
        is simply ``(a.min(), a.max())``.  Values outside the range are 
        ignored. The first element of the range must be less than or 
        equal to the second. `range` affects the automatic bin 
        computation as well. While bin width is computed to be optimal 
        based on the actual data within `range`, the bin count will fill 
        the entire range including portions containing no data. 
    normed : bool, optional 
        This is equivalent to the ``density`` argument, but produces incorrect 
        results for unequal bin widths. It should not be used. 
    weights : dask.array.Array, optional 
        A dask.array.Array of weights, of the same block structure as ``a``.  Each value in 
        ``a`` only contributes its associated weight towards the bin count 
        (instead of 1). If ``density`` is True, the weights are 
        normalized, so that the integral of the density over the range 
        remains 1. 
    density : bool, optional 
        If ``False``, the result will contain the number of samples in 
        each bin. If ``True``, the result is the value of the 
        probability *density* function at the bin, normalized such that 
        the *integral* over the range is 1. Note that the sum of the 
        histogram values will not be equal to 1 unless bins of unity 
        width are chosen; it is not a probability *mass* function. 
        Overrides the ``normed`` keyword if given. 
        If ``density`` is True, ``bins`` cannot be a single-number delayed 
        value. It must be a concrete number, or a (possibly-delayed) 
        array/sequence of the bin edges. 
 
    Returns 
    ------- 
    hist : dask Array 
        The values of the histogram. See `density` and `weights` for a 
        description of the possible semantics. 
    bin_edges : dask Array of dtype float 
        Return the bin edges ``(length(hist)+1)``. 
 
    Examples 
    -------- 
    Using number of bins and range: 
 
    &gt;&gt;&gt; import dask.array as da 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; x = da.from_array(np.arange(10000), chunks=10) 
    &gt;&gt;&gt; h, bins = da.histogram(x, bins=10, range=[0, 10000]) 
    &gt;&gt;&gt; bins 
    array([    0.,  1000.,  2000.,  3000.,  4000.,  5000.,  6000.,  7000., 
            8000.,  9000., 10000.]) 
    &gt;&gt;&gt; h.compute() 
    array([1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000]) 
 
    Explicitly specifying the bins: 
 
    &gt;&gt;&gt; h, bins = da.histogram(x, bins=np.array([0, 5000, 10000])) 
    &gt;&gt;&gt; bins 
    array([    0,  5000, 10000]) 
    &gt;&gt;&gt; h.compute() 
    array([5000, 5000]) 
    &quot;&quot;&quot;</span>
    <span class="s0">if </span><span class="s1">isinstance(bins</span><span class="s0">, </span><span class="s1">Array):</span>
        <span class="s1">scalar_bins = bins.ndim == </span><span class="s3">0</span>
        <span class="s2"># ^ `np.ndim` is not implemented by Dask array.</span>
    <span class="s0">elif </span><span class="s1">isinstance(bins</span><span class="s0">, </span><span class="s1">Delayed):</span>
        <span class="s1">scalar_bins = bins._length </span><span class="s0">is None or </span><span class="s1">bins._length == </span><span class="s3">1</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">scalar_bins = np.ndim(bins) == </span><span class="s3">0</span>

    <span class="s0">if </span><span class="s1">bins </span><span class="s0">is None or </span><span class="s1">(scalar_bins </span><span class="s0">and </span><span class="s1">range </span><span class="s0">is None</span><span class="s1">):</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span>
            <span class="s4">&quot;dask.array.histogram requires either specifying &quot;</span>
            <span class="s4">&quot;bins as an iterable or specifying both a range and &quot;</span>
            <span class="s4">&quot;the number of bins&quot;</span>
        <span class="s1">)</span>

    <span class="s0">if </span><span class="s1">weights </span><span class="s0">is not None and </span><span class="s1">weights.chunks != a.chunks:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Input array and weights must have the same chunked structure&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">normed </span><span class="s0">is not False</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span>
            <span class="s4">&quot;The normed= keyword argument has been deprecated. &quot;</span>
            <span class="s4">&quot;Please use density instead. &quot;</span>
            <span class="s4">&quot;See the numpy.histogram docstring for more information.&quot;</span>
        <span class="s1">)</span>

    <span class="s0">if </span><span class="s1">density </span><span class="s0">and </span><span class="s1">scalar_bins </span><span class="s0">and </span><span class="s1">isinstance(bins</span><span class="s0">, </span><span class="s1">(Array</span><span class="s0">, </span><span class="s1">Delayed)):</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError(</span>
            <span class="s4">&quot;When `density` is True, `bins` cannot be a scalar Dask object. &quot;</span>
            <span class="s4">&quot;It must be a concrete number or a (possibly-delayed) array/sequence of bin edges.&quot;</span>
        <span class="s1">)</span>

    <span class="s0">for </span><span class="s1">argname</span><span class="s0">, </span><span class="s1">val </span><span class="s0">in </span><span class="s1">[(</span><span class="s4">&quot;bins&quot;</span><span class="s0">, </span><span class="s1">bins)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">&quot;range&quot;</span><span class="s0">, </span><span class="s1">range)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">&quot;weights&quot;</span><span class="s0">, </span><span class="s1">weights)]:</span>
        <span class="s0">if not </span><span class="s1">isinstance(bins</span><span class="s0">, </span><span class="s1">(Array</span><span class="s0">, </span><span class="s1">Delayed)) </span><span class="s0">and </span><span class="s1">is_dask_collection(bins):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span>
                <span class="s4">&quot;Dask types besides Array and Delayed are not supported &quot;</span>
                <span class="s4">&quot;for `histogram`. For argument `{}`, got: {!r}&quot;</span><span class="s1">.format(argname</span><span class="s0">, </span><span class="s1">val)</span>
            <span class="s1">)</span>

    <span class="s0">if </span><span class="s1">range </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">len(range) != </span><span class="s3">2</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">f&quot;range must be a sequence or array of length 2, but got </span><span class="s0">{</span><span class="s1">len(range)</span><span class="s0">} </span><span class="s4">items&quot;</span>
                <span class="s1">)</span>
            <span class="s0">if </span><span class="s1">isinstance(range</span><span class="s0">, </span><span class="s1">(Array</span><span class="s0">, </span><span class="s1">np.ndarray)) </span><span class="s0">and </span><span class="s1">range.shape != (</span><span class="s3">2</span><span class="s0">,</span><span class="s1">):</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">f&quot;range must be a 1-dimensional array of two items, but got an array of shape </span><span class="s0">{</span><span class="s1">range.shape</span><span class="s0">}</span><span class="s4">&quot;</span>
                <span class="s1">)</span>
        <span class="s0">except </span><span class="s1">TypeError:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span>
                <span class="s4">f&quot;Expected a sequence or array for range, not </span><span class="s0">{</span><span class="s1">range</span><span class="s0">}</span><span class="s4">&quot;</span>
            <span class="s1">) </span><span class="s0">from None</span>

    <span class="s1">token = tokenize(a</span><span class="s0">, </span><span class="s1">bins</span><span class="s0">, </span><span class="s1">range</span><span class="s0">, </span><span class="s1">weights</span><span class="s0">, </span><span class="s1">density)</span>
    <span class="s1">name = </span><span class="s4">&quot;histogram-sum-&quot; </span><span class="s1">+ token</span>

    <span class="s0">if </span><span class="s1">scalar_bins:</span>
        <span class="s1">bins = _linspace_from_delayed(range[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">range[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">bins + </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s2"># ^ NOTE `range[1]` is safe because of the above check, and the initial check</span>
        <span class="s2"># that range must not be None if `scalar_bins`</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">if not </span><span class="s1">isinstance(bins</span><span class="s0">, </span><span class="s1">(Array</span><span class="s0">, </span><span class="s1">np.ndarray)):</span>
            <span class="s1">bins = asarray(bins)</span>
        <span class="s0">if </span><span class="s1">bins.ndim != </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s4">f&quot;bins must be a 1-dimensional array or sequence, got shape </span><span class="s0">{</span><span class="s1">bins.shape</span><span class="s0">}</span><span class="s4">&quot;</span>
            <span class="s1">)</span>

    <span class="s1">(bins_ref</span><span class="s0">, </span><span class="s1">range_ref)</span><span class="s0">, </span><span class="s1">deps = unpack_collections([bins</span><span class="s0">, </span><span class="s1">range])</span>

    <span class="s2"># Map the histogram to all bins, forming a 2D array of histograms, stacked for each chunk</span>
    <span class="s0">if </span><span class="s1">weights </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">dsk = {</span>
            <span class="s1">(name</span><span class="s0">, </span><span class="s1">i</span><span class="s0">, </span><span class="s3">0</span><span class="s1">): (_block_hist</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">bins_ref</span><span class="s0">, </span><span class="s1">range_ref)</span>
            <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">k </span><span class="s0">in </span><span class="s1">enumerate(flatten(a.__dask_keys__()))</span>
        <span class="s1">}</span>
        <span class="s1">dtype = np.histogram([])[</span><span class="s3">0</span><span class="s1">].dtype</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">a_keys = flatten(a.__dask_keys__())</span>
        <span class="s1">w_keys = flatten(weights.__dask_keys__())</span>
        <span class="s1">dsk = {</span>
            <span class="s1">(name</span><span class="s0">, </span><span class="s1">i</span><span class="s0">, </span><span class="s3">0</span><span class="s1">): (_block_hist</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">bins_ref</span><span class="s0">, </span><span class="s1">range_ref</span><span class="s0">, </span><span class="s1">w)</span>
            <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">(k</span><span class="s0">, </span><span class="s1">w) </span><span class="s0">in </span><span class="s1">enumerate(zip(a_keys</span><span class="s0">, </span><span class="s1">w_keys))</span>
        <span class="s1">}</span>
        <span class="s1">dtype = weights.dtype</span>

    <span class="s1">deps = (a</span><span class="s0">,</span><span class="s1">) + deps</span>
    <span class="s0">if </span><span class="s1">weights </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">deps += (weights</span><span class="s0">,</span><span class="s1">)</span>
    <span class="s1">graph = HighLevelGraph.from_collections(name</span><span class="s0">, </span><span class="s1">dsk</span><span class="s0">, </span><span class="s1">dependencies=deps)</span>

    <span class="s2"># Turn graph into a 2D Array of shape (nchunks, nbins)</span>
    <span class="s1">nchunks = len(list(flatten(a.__dask_keys__())))</span>
    <span class="s1">nbins = bins.size - </span><span class="s3">1  </span><span class="s2"># since `bins` is 1D</span>
    <span class="s1">chunks = ((</span><span class="s3">1</span><span class="s0">,</span><span class="s1">) * nchunks</span><span class="s0">, </span><span class="s1">(nbins</span><span class="s0">,</span><span class="s1">))</span>
    <span class="s1">mapped = Array(graph</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">chunks</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>

    <span class="s2"># Sum over chunks to get the final histogram</span>
    <span class="s1">n = mapped.sum(axis=</span><span class="s3">0</span><span class="s1">)</span>

    <span class="s2"># We need to replicate normed and density options from numpy</span>
    <span class="s0">if </span><span class="s1">density </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">density:</span>
            <span class="s1">db = asarray(np.diff(bins).astype(float)</span><span class="s0">, </span><span class="s1">chunks=n.chunks)</span>
            <span class="s0">return </span><span class="s1">n / db / n.sum()</span><span class="s0">, </span><span class="s1">bins</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">n</span><span class="s0">, </span><span class="s1">bins</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">n</span><span class="s0">, </span><span class="s1">bins</span>


<span class="s0">def </span><span class="s1">histogram2d(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">bins=</span><span class="s3">10</span><span class="s0">, </span><span class="s1">range=</span><span class="s0">None, </span><span class="s1">normed=</span><span class="s0">None, </span><span class="s1">weights=</span><span class="s0">None, </span><span class="s1">density=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot;Blocked variant of :func:`numpy.histogram2d`. 
 
    Parameters 
    ---------- 
    x : dask.array.Array 
        An array containing the `x`-coordinates of the points to be 
        histogrammed. 
    y : dask.array.Array 
        An array containing the `y`-coordinates of the points to be 
        histogrammed. 
    bins : sequence of arrays describing bin edges, int, or sequence of ints 
        The bin specification. See the `bins` argument description for 
        :py:func:`histogramdd` for a complete description of all 
        possible bin configurations (this function is a 2D specific 
        version of histogramdd). 
    range : tuple of pairs, optional. 
        The leftmost and rightmost edges of the bins along each 
        dimension when integers are passed to `bins`; of the form: 
        ((xmin, xmax), (ymin, ymax)). 
    normed : bool, optional 
        An alias for the density argument that behaves identically. To 
        avoid confusion with the broken argument in the `histogram` 
        function, `density` should be preferred. 
    weights : dask.array.Array, optional 
        An array of values weighing each sample in the input data. The 
        chunks of the weights must be identical to the chunking along 
        the 0th (row) axis of the data sample. 
    density : bool, optional 
        If False (the default) return the number of samples in each 
        bin. If True, the returned array represents the probability 
        density function at each bin. 
 
    Returns 
    ------- 
    dask.array.Array 
        The values of the histogram. 
    dask.array.Array 
        The edges along the `x`-dimension. 
    dask.array.Array 
        The edges along the `y`-dimension. 
 
    See Also 
    -------- 
    histogram 
    histogramdd 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import dask.array as da 
    &gt;&gt;&gt; x = da.array([2, 4, 2, 4, 2, 4]) 
    &gt;&gt;&gt; y = da.array([2, 2, 4, 4, 2, 4]) 
    &gt;&gt;&gt; bins = 2 
    &gt;&gt;&gt; range = ((0, 6), (0, 6)) 
    &gt;&gt;&gt; h, xedges, yedges = da.histogram2d(x, y, bins=bins, range=range) 
    &gt;&gt;&gt; h 
    dask.array&lt;sum-aggregate, shape=(2, 2), dtype=float64, chunksize=(2, 2), chunktype=numpy.ndarray&gt; 
    &gt;&gt;&gt; xedges 
    dask.array&lt;array, shape=(3,), dtype=float64, chunksize=(3,), chunktype=numpy.ndarray&gt; 
    &gt;&gt;&gt; h.compute() 
    array([[2., 1.], 
           [1., 2.]]) 
    &quot;&quot;&quot;</span>
    <span class="s1">counts</span><span class="s0">, </span><span class="s1">edges = histogramdd(</span>
        <span class="s1">(x</span><span class="s0">, </span><span class="s1">y)</span><span class="s0">,</span>
        <span class="s1">bins=bins</span><span class="s0">,</span>
        <span class="s1">range=range</span><span class="s0">,</span>
        <span class="s1">normed=normed</span><span class="s0">,</span>
        <span class="s1">weights=weights</span><span class="s0">,</span>
        <span class="s1">density=density</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s0">return </span><span class="s1">counts</span><span class="s0">, </span><span class="s1">edges[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">edges[</span><span class="s3">1</span><span class="s1">]</span>


<span class="s0">def </span><span class="s1">_block_histogramdd_rect(sample</span><span class="s0">, </span><span class="s1">bins</span><span class="s0">, </span><span class="s1">range</span><span class="s0">, </span><span class="s1">weights):</span>
    <span class="s5">&quot;&quot;&quot;Call numpy.histogramdd for a blocked/chunked calculation. 
 
    Slurps the result into an additional outer axis; this new axis 
    will be used to stack chunked calls of the numpy function and add 
    them together later. 
 
    Returns 
    ------- 
    :py:object:`np.ndarray` 
        NumPy array with an additional outer dimension. 
 
    &quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">np.histogramdd(sample</span><span class="s0">, </span><span class="s1">bins</span><span class="s0">, </span><span class="s1">range=range</span><span class="s0">, </span><span class="s1">weights=weights)[</span><span class="s3">0</span><span class="s1">:</span><span class="s3">1</span><span class="s1">]</span>


<span class="s0">def </span><span class="s1">_block_histogramdd_multiarg(*args):</span>
    <span class="s5">&quot;&quot;&quot;Call numpy.histogramdd for a multi argument blocked/chunked calculation. 
 
    Slurps the result into an additional outer axis; this new axis 
    will be used to stack chunked calls of the numpy function and add 
    them together later. 
 
    The last three arguments _must be_ (bins, range, weights). 
 
    The difference between this function and 
    _block_histogramdd_rect is that here we expect the sample 
    to be composed of multiple arguments (multiple 1D arrays, each one 
    representing a coordinate), while _block_histogramdd_rect 
    expects a single rectangular (2D array where columns are 
    coordinates) sample. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">bins</span><span class="s0">, </span><span class="s1">range</span><span class="s0">, </span><span class="s1">weights = args[-</span><span class="s3">3</span><span class="s1">:]</span>
    <span class="s1">sample = args[:-</span><span class="s3">3</span><span class="s1">]</span>
    <span class="s0">return </span><span class="s1">np.histogramdd(sample</span><span class="s0">, </span><span class="s1">bins=bins</span><span class="s0">, </span><span class="s1">range=range</span><span class="s0">, </span><span class="s1">weights=weights)[</span><span class="s3">0</span><span class="s1">:</span><span class="s3">1</span><span class="s1">]</span>


<span class="s0">def </span><span class="s1">histogramdd(sample</span><span class="s0">, </span><span class="s1">bins</span><span class="s0">, </span><span class="s1">range=</span><span class="s0">None, </span><span class="s1">normed=</span><span class="s0">None, </span><span class="s1">weights=</span><span class="s0">None, </span><span class="s1">density=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot;Blocked variant of :func:`numpy.histogramdd`. 
 
    Chunking of the input data (``sample``) is only allowed along the 
    0th (row) axis (the axis corresponding to the total number of 
    samples). Data chunked along the 1st axis (column) axis is not 
    compatible with this function. If weights are used, they must be 
    chunked along the 0th axis identically to the input sample. 
 
    An example setup for a three dimensional histogram, where the 
    sample shape is ``(8, 3)`` and weights are shape ``(8,)``, sample 
    chunks would be ``((4, 4), (3,))`` and the weights chunks would be 
    ``((4, 4),)`` a table of the structure: 
 
    +-------+-----------------------+-----------+ 
    |       |      sample (8 x 3)   |  weights  | 
    +=======+=====+=====+=====+=====+=====+=====+ 
    | chunk | row | `x` | `y` | `z` | row | `w` | 
    +-------+-----+-----+-----+-----+-----+-----+ 
    |       |   0 |   5 |   6 |   6 |   0 | 0.5 | 
    |       +-----+-----+-----+-----+-----+-----+ 
    |       |   1 |   8 |   9 |   2 |   1 | 0.8 | 
    |   0   +-----+-----+-----+-----+-----+-----+ 
    |       |   2 |   3 |   3 |   1 |   2 | 0.3 | 
    |       +-----+-----+-----+-----+-----+-----+ 
    |       |   3 |   2 |   5 |   6 |   3 | 0.7 | 
    +-------+-----+-----+-----+-----+-----+-----+ 
    |       |   4 |   3 |   1 |   1 |   4 | 0.3 | 
    |       +-----+-----+-----+-----+-----+-----+ 
    |       |   5 |   3 |   2 |   9 |   5 | 1.3 | 
    |   1   +-----+-----+-----+-----+-----+-----+ 
    |       |   6 |   8 |   1 |   5 |   6 | 0.8 | 
    |       +-----+-----+-----+-----+-----+-----+ 
    |       |   7 |   3 |   5 |   3 |   7 | 0.7 | 
    +-------+-----+-----+-----+-----+-----+-----+ 
 
    If the sample 0th dimension and weight 0th (row) dimension are 
    chunked differently, a ``ValueError`` will be raised. If 
    coordinate groupings ((x, y, z) trios) are separated by a chunk 
    boundry, then a ``ValueError`` will be raised. We suggest that you 
    rechunk your data if it is of that form. 
 
    The chunks property of the data (and optional weights) are used to 
    check for compatibility with the blocked algorithm (as described 
    above); therefore, you must call `to_dask_array` on a collection 
    from ``dask.dataframe``, i.e. :class:`dask.dataframe.Series` or 
    :class:`dask.dataframe.DataFrame`. 
 
    The function is also compatible with `x`, `y`, and `z` being 
    individual 1D arrays with equal chunking. In that case, the data 
    should be passed as a tuple: ``histogramdd((x, y, z), ...)`` 
 
    Parameters 
    ---------- 
    sample : dask.array.Array (N, D) or sequence of dask.array.Array 
        Multidimensional data to be histogrammed. 
 
        Note the unusual interpretation of a sample when it is a 
        sequence of dask Arrays: 
 
        * When a (N, D) dask Array, each row is an entry in the sample 
          (coordinate in D dimensional space). 
        * When a sequence of dask Arrays, each element in the sequence 
          is the array of values for a single coordinate. 
    bins : sequence of arrays describing bin edges, int, or sequence of ints 
        The bin specification. 
 
        The possible binning configurations are: 
 
        * A sequence of arrays describing the monotonically increasing 
          bin edges along each dimension. 
        * A single int describing the total number of bins that will 
          be used in each dimension (this requires the ``range`` 
          argument to be defined). 
        * A sequence of ints describing the total number of bins to be 
          used in each dimension (this requires the ``range`` argument 
          to be defined). 
 
        When bins are described by arrays, the rightmost edge is 
        included. Bins described by arrays also allows for non-uniform 
        bin widths. 
    range : sequence of pairs, optional 
        A sequence of length D, each a (min, max) tuple giving the 
        outer bin edges to be used if the edges are not given 
        explicitly in `bins`. If defined, this argument is required to 
        have an entry for each dimension. Unlike 
        :func:`numpy.histogramdd`, if `bins` does not define bin 
        edges, this argument is required (this function will not 
        automatically use the min and max of of the value in a given 
        dimension because the input data may be lazy in dask). 
    normed : bool, optional 
        An alias for the density argument that behaves identically. To 
        avoid confusion with the broken argument to `histogram`, 
        `density` should be preferred. 
    weights : dask.array.Array, optional 
        An array of values weighing each sample in the input data. The 
        chunks of the weights must be identical to the chunking along 
        the 0th (row) axis of the data sample. 
    density : bool, optional 
        If ``False`` (default), the returned array represents the 
        number of samples in each bin. If ``True``, the returned array 
        represents the probability density function at each bin. 
 
    See Also 
    -------- 
    histogram 
 
    Returns 
    ------- 
    dask.array.Array 
        The values of the histogram. 
    list(dask.array.Array) 
        Sequence of arrays representing the bin edges along each 
        dimension. 
 
    Examples 
    -------- 
    Computing the histogram in 5 blocks using different bin edges 
    along each dimension: 
 
    &gt;&gt;&gt; import dask.array as da 
    &gt;&gt;&gt; x = da.random.uniform(0, 1, size=(1000, 3), chunks=(200, 3)) 
    &gt;&gt;&gt; edges = [ 
    ...     np.linspace(0, 1, 5), # 4 bins in 1st dim 
    ...     np.linspace(0, 1, 6), # 5 in the 2nd 
    ...     np.linspace(0, 1, 4), # 3 in the 3rd 
    ... ] 
    &gt;&gt;&gt; h, edges = da.histogramdd(x, bins=edges) 
    &gt;&gt;&gt; result = h.compute() 
    &gt;&gt;&gt; result.shape 
    (4, 5, 3) 
 
    Defining the bins by total number and their ranges, along with 
    using weights: 
 
    &gt;&gt;&gt; bins = (4, 5, 3) 
    &gt;&gt;&gt; ranges = ((0, 1),) * 3  # expands to ((0, 1), (0, 1), (0, 1)) 
    &gt;&gt;&gt; w = da.random.uniform(0, 1, size=(1000,), chunks=x.chunksize[0]) 
    &gt;&gt;&gt; h, edges = da.histogramdd(x, bins=bins, range=ranges, weights=w) 
    &gt;&gt;&gt; np.isclose(h.sum().compute(), w.sum().compute()) 
    True 
 
    Using a sequence of 1D arrays as the input: 
 
    &gt;&gt;&gt; x = da.array([2, 4, 2, 4, 2, 4]) 
    &gt;&gt;&gt; y = da.array([2, 2, 4, 4, 2, 4]) 
    &gt;&gt;&gt; z = da.array([4, 2, 4, 2, 4, 2]) 
    &gt;&gt;&gt; bins = ([0, 3, 6],) * 3 
    &gt;&gt;&gt; h, edges = da.histogramdd((x, y, z), bins) 
    &gt;&gt;&gt; h 
    dask.array&lt;sum-aggregate, shape=(2, 2, 2), dtype=float64, chunksize=(2, 2, 2), chunktype=numpy.ndarray&gt; 
    &gt;&gt;&gt; edges[0] 
    dask.array&lt;array, shape=(3,), dtype=int64, chunksize=(3,), chunktype=numpy.ndarray&gt; 
    &gt;&gt;&gt; h.compute() 
    array([[[0., 2.], 
            [0., 1.]], 
    &lt;BLANKLINE&gt; 
           [[1., 0.], 
            [2., 0.]]]) 
    &gt;&gt;&gt; edges[0].compute() 
    array([0, 3, 6]) 
    &gt;&gt;&gt; edges[1].compute() 
    array([0, 3, 6]) 
    &gt;&gt;&gt; edges[2].compute() 
    array([0, 3, 6]) 
 
    &quot;&quot;&quot;</span>
    <span class="s2"># logic used in numpy.histogramdd to handle normed/density.</span>
    <span class="s0">if </span><span class="s1">normed </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">density </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">density = </span><span class="s0">False</span>
    <span class="s0">elif </span><span class="s1">density </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s2"># an explicit normed argument was passed, alias it to the new name</span>
        <span class="s1">density = normed</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;Cannot specify both 'normed' and 'density'&quot;</span><span class="s1">)</span>

    <span class="s2"># check if any dask collections (dc) were passed to bins= or</span>
    <span class="s2"># range= these are unsupported.</span>
    <span class="s1">dc_bins = is_dask_collection(bins)</span>
    <span class="s0">if </span><span class="s1">isinstance(bins</span><span class="s0">, </span><span class="s1">(list</span><span class="s0">, </span><span class="s1">tuple)):</span>
        <span class="s1">dc_bins = dc_bins </span><span class="s0">or </span><span class="s1">any([is_dask_collection(b) </span><span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">bins])</span>
    <span class="s1">dc_range = (</span>
        <span class="s1">any([is_dask_collection(r) </span><span class="s0">for </span><span class="s1">r </span><span class="s0">in </span><span class="s1">range]) </span><span class="s0">if </span><span class="s1">range </span><span class="s0">is not None else False</span>
    <span class="s1">)</span>
    <span class="s0">if </span><span class="s1">dc_bins </span><span class="s0">or </span><span class="s1">dc_range:</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError(</span>
            <span class="s4">&quot;Passing dask collections to bins=... or range=... is not supported.&quot;</span>
        <span class="s1">)</span>

    <span class="s2"># generate token and name for task</span>
    <span class="s1">token = tokenize(sample</span><span class="s0">, </span><span class="s1">bins</span><span class="s0">, </span><span class="s1">range</span><span class="s0">, </span><span class="s1">weights</span><span class="s0">, </span><span class="s1">density)</span>
    <span class="s1">name = </span><span class="s4">f&quot;histogramdd-sum-</span><span class="s0">{</span><span class="s1">token</span><span class="s0">}</span><span class="s4">&quot;</span>

    <span class="s2"># N == total number of samples</span>
    <span class="s2"># D == total number of dimensions</span>
    <span class="s0">if </span><span class="s1">hasattr(sample</span><span class="s0">, </span><span class="s4">&quot;shape&quot;</span><span class="s1">):</span>
        <span class="s0">if </span><span class="s1">len(sample.shape) != </span><span class="s3">2</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Single array input to histogramdd should be columnar&quot;</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">_</span><span class="s0">, </span><span class="s1">D = sample.shape</span>
        <span class="s1">n_chunks = sample.numblocks[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">rectangular_sample = </span><span class="s0">True</span>
        <span class="s2"># Require data to be chunked along the first axis only.</span>
        <span class="s0">if </span><span class="s1">sample.shape[</span><span class="s3">1</span><span class="s1">:] != sample.chunksize[</span><span class="s3">1</span><span class="s1">:]:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Input array can only be chunked along the 0th axis.&quot;</span><span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">isinstance(sample</span><span class="s0">, </span><span class="s1">(tuple</span><span class="s0">, </span><span class="s1">list)):</span>
        <span class="s1">rectangular_sample = </span><span class="s0">False</span>
        <span class="s1">D = len(sample)</span>
        <span class="s1">n_chunks = sample[</span><span class="s3">0</span><span class="s1">].numblocks[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">_range(</span><span class="s3">1</span><span class="s0">, </span><span class="s1">D):</span>
            <span class="s0">if </span><span class="s1">sample[i].chunks != sample[</span><span class="s3">0</span><span class="s1">].chunks:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;All coordinate arrays must be chunked identically.&quot;</span><span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span>
            <span class="s4">&quot;Incompatible sample. Must be a 2D array or a sequence of 1D arrays.&quot;</span>
        <span class="s1">)</span>

    <span class="s2"># Require only Array or Delayed objects for bins, range, and weights.</span>
    <span class="s0">for </span><span class="s1">argname</span><span class="s0">, </span><span class="s1">val </span><span class="s0">in </span><span class="s1">[(</span><span class="s4">&quot;bins&quot;</span><span class="s0">, </span><span class="s1">bins)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">&quot;range&quot;</span><span class="s0">, </span><span class="s1">range)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">&quot;weights&quot;</span><span class="s0">, </span><span class="s1">weights)]:</span>
        <span class="s0">if not </span><span class="s1">isinstance(bins</span><span class="s0">, </span><span class="s1">(Array</span><span class="s0">, </span><span class="s1">Delayed)) </span><span class="s0">and </span><span class="s1">is_dask_collection(bins):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span>
                <span class="s4">&quot;Dask types besides Array and Delayed are not supported &quot;</span>
                <span class="s4">&quot;for `histogramdd`. For argument `{}`, got: {!r}&quot;</span><span class="s1">.format(argname</span><span class="s0">, </span><span class="s1">val)</span>
            <span class="s1">)</span>

    <span class="s2"># Require that the chunking of the sample and weights are compatible.</span>
    <span class="s0">if </span><span class="s1">weights </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">rectangular_sample </span><span class="s0">and </span><span class="s1">weights.chunks[</span><span class="s3">0</span><span class="s1">] != sample.chunks[</span><span class="s3">0</span><span class="s1">]:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;Input array and weights must have the same shape &quot;</span>
                <span class="s4">&quot;and chunk structure along the first dimension.&quot;</span>
            <span class="s1">)</span>
        <span class="s0">elif not </span><span class="s1">rectangular_sample </span><span class="s0">and </span><span class="s1">weights.numblocks[</span><span class="s3">0</span><span class="s1">] != n_chunks:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;Input arrays and weights must have the same shape &quot;</span>
                <span class="s4">&quot;and chunk structure.&quot;</span>
            <span class="s1">)</span>

    <span class="s2"># if bins is a list, tuple, then make sure the length is the same</span>
    <span class="s2"># as the number dimensions.</span>
    <span class="s0">if </span><span class="s1">isinstance(bins</span><span class="s0">, </span><span class="s1">(list</span><span class="s0">, </span><span class="s1">tuple)):</span>
        <span class="s0">if </span><span class="s1">len(bins) != D:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;The dimension of bins must be equal to the dimension of the sample.&quot;</span>
            <span class="s1">)</span>

    <span class="s2"># if range is defined, check that it's the right length and also a</span>
    <span class="s2"># sequence of pairs.</span>
    <span class="s0">if </span><span class="s1">range </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">len(range) != D:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;range argument requires one entry, a min max pair, per dimension.&quot;</span>
            <span class="s1">)</span>
        <span class="s0">if not </span><span class="s1">all(len(r) == </span><span class="s3">2 </span><span class="s0">for </span><span class="s1">r </span><span class="s0">in </span><span class="s1">range):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;range argument should be a sequence of pairs&quot;</span><span class="s1">)</span>

    <span class="s2"># If bins is a single int, create a tuple of len `D` containing `bins`.</span>
    <span class="s0">if </span><span class="s1">isinstance(bins</span><span class="s0">, </span><span class="s1">int):</span>
        <span class="s1">bins = (bins</span><span class="s0">,</span><span class="s1">) * D</span>

    <span class="s2"># we will return the edges to mimic the NumPy API (we also use the</span>
    <span class="s2"># edges later as a way to calculate the total number of bins).</span>
    <span class="s0">if </span><span class="s1">all(isinstance(b</span><span class="s0">, </span><span class="s1">int) </span><span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">bins) </span><span class="s0">and </span><span class="s1">all(len(r) == </span><span class="s3">2 </span><span class="s0">for </span><span class="s1">r </span><span class="s0">in </span><span class="s1">range):</span>
        <span class="s1">edges = [np.linspace(r[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">r[</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">b + </span><span class="s3">1</span><span class="s1">) </span><span class="s0">for </span><span class="s1">b</span><span class="s0">, </span><span class="s1">r </span><span class="s0">in </span><span class="s1">zip(bins</span><span class="s0">, </span><span class="s1">range)]</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">edges = [np.asarray(b) </span><span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">bins]</span>

    <span class="s0">if </span><span class="s1">rectangular_sample:</span>
        <span class="s1">deps = (sample</span><span class="s0">,</span><span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">deps = tuple(sample)</span>

    <span class="s0">if </span><span class="s1">weights </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">w_keys = flatten(weights.__dask_keys__())</span>
        <span class="s1">deps += (weights</span><span class="s0">,</span><span class="s1">)</span>
        <span class="s1">dtype = weights.dtype</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">w_keys = (</span><span class="s0">None,</span><span class="s1">) * n_chunks</span>
        <span class="s1">dtype = np.histogramdd([])[</span><span class="s3">0</span><span class="s1">].dtype</span>

    <span class="s2"># This tuple of zeros represents the chunk index along the columns</span>
    <span class="s2"># (we only allow chunking along the rows).</span>
    <span class="s1">column_zeros = tuple(</span><span class="s3">0 </span><span class="s0">for </span><span class="s1">_ </span><span class="s0">in </span><span class="s1">_range(D))</span>

    <span class="s2"># With dsk below, we will construct a (D + 1) dimensional array</span>
    <span class="s2"># stacked for each chunk. For example, if the histogram is going</span>
    <span class="s2"># to be 3 dimensions, this creates a stack of cubes (1 cube for</span>
    <span class="s2"># each sample chunk) that will be collapsed into a final cube (the</span>
    <span class="s2"># result). Depending on the input data, we can do this in two ways</span>
    <span class="s2">#</span>
    <span class="s2"># 1. The rectangular case: when the sample is a single 2D array</span>
    <span class="s2">#    where each column in the sample represents a coordinate of</span>
    <span class="s2">#    the sample).</span>
    <span class="s2">#</span>
    <span class="s2"># 2. The sequence-of-arrays case, when the sample is a tuple or</span>
    <span class="s2">#    list of arrays, with each array in that sequence representing</span>
    <span class="s2">#    the entirety of one coordinate of the complete sample.</span>

    <span class="s0">if </span><span class="s1">rectangular_sample:</span>
        <span class="s1">sample_keys = flatten(sample.__dask_keys__())</span>
        <span class="s1">dsk = {</span>
            <span class="s1">(name</span><span class="s0">, </span><span class="s1">i</span><span class="s0">, </span><span class="s1">*column_zeros): (_block_histogramdd_rect</span><span class="s0">, </span><span class="s1">k</span><span class="s0">, </span><span class="s1">bins</span><span class="s0">, </span><span class="s1">range</span><span class="s0">, </span><span class="s1">w)</span>
            <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">(k</span><span class="s0">, </span><span class="s1">w) </span><span class="s0">in </span><span class="s1">enumerate(zip(sample_keys</span><span class="s0">, </span><span class="s1">w_keys))</span>
        <span class="s1">}</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">sample_keys = [</span>
            <span class="s1">list(flatten(sample[i].__dask_keys__())) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">_range(len(sample))</span>
        <span class="s1">]</span>
        <span class="s1">fused_on_chunk_keys = [</span>
            <span class="s1">tuple(sample_keys[j][i] </span><span class="s0">for </span><span class="s1">j </span><span class="s0">in </span><span class="s1">_range(D)) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">_range(n_chunks)</span>
        <span class="s1">]</span>
        <span class="s1">dsk = {</span>
            <span class="s1">(name</span><span class="s0">, </span><span class="s1">i</span><span class="s0">, </span><span class="s1">*column_zeros): (</span>
                <span class="s1">_block_histogramdd_multiarg</span><span class="s0">,</span>
                <span class="s1">*(*k</span><span class="s0">, </span><span class="s1">bins</span><span class="s0">, </span><span class="s1">range</span><span class="s0">, </span><span class="s1">w)</span><span class="s0">,</span>
            <span class="s1">)</span>
            <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">(k</span><span class="s0">, </span><span class="s1">w) </span><span class="s0">in </span><span class="s1">enumerate(zip(fused_on_chunk_keys</span><span class="s0">, </span><span class="s1">w_keys))</span>
        <span class="s1">}</span>

    <span class="s1">graph = HighLevelGraph.from_collections(name</span><span class="s0">, </span><span class="s1">dsk</span><span class="s0">, </span><span class="s1">dependencies=deps)</span>
    <span class="s1">all_nbins = tuple((b.size - </span><span class="s3">1</span><span class="s0">,</span><span class="s1">) </span><span class="s0">for </span><span class="s1">b </span><span class="s0">in </span><span class="s1">edges)</span>
    <span class="s1">stacked_chunks = ((</span><span class="s3">1</span><span class="s0">,</span><span class="s1">) * n_chunks</span><span class="s0">, </span><span class="s1">*all_nbins)</span>
    <span class="s1">mapped = Array(graph</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">stacked_chunks</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
    <span class="s2"># Finally, sum over chunks providing to get the final D</span>
    <span class="s2"># dimensional result array.</span>
    <span class="s1">n = mapped.sum(axis=</span><span class="s3">0</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">density:</span>
        <span class="s2"># compute array of values to divide by the bin width along</span>
        <span class="s2"># each dimension.</span>
        <span class="s1">width_divider = np.ones(n.shape)</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">_range(D):</span>
            <span class="s1">shape = np.ones(D</span><span class="s0">, </span><span class="s1">int)</span>
            <span class="s1">shape[i] = width_divider.shape[i]</span>
            <span class="s1">width_divider *= np.diff(edges[i]).reshape(shape)</span>
        <span class="s1">width_divider = asarray(width_divider</span><span class="s0">, </span><span class="s1">chunks=n.chunks)</span>
        <span class="s0">return </span><span class="s1">n / width_divider / n.sum()</span><span class="s0">, </span><span class="s1">edges</span>

    <span class="s0">return </span><span class="s1">n</span><span class="s0">, </span><span class="s1">[asarray(entry) </span><span class="s0">for </span><span class="s1">entry </span><span class="s0">in </span><span class="s1">edges]</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">cov(m</span><span class="s0">, </span><span class="s1">y=</span><span class="s0">None, </span><span class="s1">rowvar=</span><span class="s3">1</span><span class="s0">, </span><span class="s1">bias=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">ddof=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s2"># This was copied almost verbatim from np.cov</span>
    <span class="s2"># See numpy license at https://github.com/numpy/numpy/blob/master/LICENSE.txt</span>
    <span class="s2"># or NUMPY_LICENSE.txt within this directory</span>
    <span class="s0">if </span><span class="s1">ddof </span><span class="s0">is not None and </span><span class="s1">ddof != int(ddof):</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;ddof must be integer&quot;</span><span class="s1">)</span>

    <span class="s2"># Handles complex arrays too</span>
    <span class="s1">m = asarray(m)</span>
    <span class="s0">if </span><span class="s1">y </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">dtype = np.result_type(m</span><span class="s0">, </span><span class="s1">np.float64)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">y = asarray(y)</span>
        <span class="s1">dtype = np.result_type(m</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">np.float64)</span>
    <span class="s1">X = array(m</span><span class="s0">, </span><span class="s1">ndmin=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>

    <span class="s0">if </span><span class="s1">X.shape[</span><span class="s3">0</span><span class="s1">] == </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s1">rowvar = </span><span class="s3">1</span>
    <span class="s0">if </span><span class="s1">rowvar:</span>
        <span class="s1">N = X.shape[</span><span class="s3">1</span><span class="s1">]</span>
        <span class="s1">axis = </span><span class="s3">0</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">N = X.shape[</span><span class="s3">0</span><span class="s1">]</span>
        <span class="s1">axis = </span><span class="s3">1</span>

    <span class="s2"># check ddof</span>
    <span class="s0">if </span><span class="s1">ddof </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">bias == </span><span class="s3">0</span><span class="s1">:</span>
            <span class="s1">ddof = </span><span class="s3">1</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">ddof = </span><span class="s3">0</span>
    <span class="s1">fact = float(N - ddof)</span>
    <span class="s0">if </span><span class="s1">fact &lt;= </span><span class="s3">0</span><span class="s1">:</span>
        <span class="s1">warnings.warn(</span><span class="s4">&quot;Degrees of freedom &lt;= 0 for slice&quot;</span><span class="s0">, </span><span class="s1">RuntimeWarning)</span>
        <span class="s1">fact = </span><span class="s3">0.0</span>

    <span class="s0">if </span><span class="s1">y </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">y = array(y</span><span class="s0">, </span><span class="s1">ndmin=</span><span class="s3">2</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>
        <span class="s1">X = concatenate((X</span><span class="s0">, </span><span class="s1">y)</span><span class="s0">, </span><span class="s1">axis)</span>

    <span class="s1">X = X - X.mean(axis=</span><span class="s3">1 </span><span class="s1">- axis</span><span class="s0">, </span><span class="s1">keepdims=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s0">if not </span><span class="s1">rowvar:</span>
        <span class="s0">return </span><span class="s1">(dot(X.T</span><span class="s0">, </span><span class="s1">X.conj()) / fact).squeeze()</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">(dot(X</span><span class="s0">, </span><span class="s1">X.T.conj()) / fact).squeeze()</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">corrcoef(x</span><span class="s0">, </span><span class="s1">y=</span><span class="s0">None, </span><span class="s1">rowvar=</span><span class="s3">1</span><span class="s1">):</span>
    <span class="s1">c = cov(x</span><span class="s0">, </span><span class="s1">y</span><span class="s0">, </span><span class="s1">rowvar)</span>
    <span class="s0">if </span><span class="s1">c.shape == ():</span>
        <span class="s0">return </span><span class="s1">c / c</span>
    <span class="s1">d = diag(c)</span>
    <span class="s1">d = d.reshape((d.shape[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span>
    <span class="s1">sqr_d = sqrt(d)</span>
    <span class="s0">return </span><span class="s1">(c / sqr_d) / sqr_d.T</span>


<span class="s1">@implements(np.round)</span>
<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">round(a</span><span class="s0">, </span><span class="s1">decimals=</span><span class="s3">0</span><span class="s1">):</span>
    <span class="s0">return </span><span class="s1">a.map_blocks(np.round</span><span class="s0">, </span><span class="s1">decimals=decimals</span><span class="s0">, </span><span class="s1">dtype=a.dtype)</span>


<span class="s1">@implements(np.ndim)</span>
<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">ndim(a):</span>
    <span class="s0">return </span><span class="s1">a.ndim</span>


<span class="s1">@implements(np.iscomplexobj)</span>
<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">iscomplexobj(x):</span>
    <span class="s0">return </span><span class="s1">issubclass(x.dtype.type</span><span class="s0">, </span><span class="s1">np.complexfloating)</span>


<span class="s0">def </span><span class="s1">_unique_internal(ar</span><span class="s0">, </span><span class="s1">indices</span><span class="s0">, </span><span class="s1">counts</span><span class="s0">, </span><span class="s1">return_inverse=</span><span class="s0">False</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot; 
    Helper/wrapper function for :func:`numpy.unique`. 
 
    Uses :func:`numpy.unique` to find the unique values for the array chunk. 
    Given this chunk may not represent the whole array, also take the 
    ``indices`` and ``counts`` that are in 1-to-1 correspondence to ``ar`` 
    and reduce them in the same fashion as ``ar`` is reduced. Namely sum 
    any counts that correspond to the same value and take the smallest 
    index that corresponds to the same value. 
 
    To handle the inverse mapping from the unique values to the original 
    array, simply return a NumPy array created with ``arange`` with enough 
    values to correspond 1-to-1 to the unique values. While there is more 
    work needed to be done to create the full inverse mapping for the 
    original array, this provides enough information to generate the 
    inverse mapping in Dask. 
 
    Given Dask likes to have one array returned from functions like 
    ``blockwise``, some formatting is done to stuff all of the resulting arrays 
    into one big NumPy structured array. Dask is then able to handle this 
    object and can split it apart into the separate results on the Dask side, 
    which then can be passed back to this function in concatenated chunks for 
    further reduction or can be return to the user to perform other forms of 
    analysis. 
 
    By handling the problem in this way, it does not matter where a chunk 
    is in a larger array or how big it is. The chunk can still be computed 
    on the same way. Also it does not matter if the chunk is the result of 
    other chunks being run through this function multiple times. The end 
    result will still be just as accurate using this strategy. 
    &quot;&quot;&quot;</span>

    <span class="s1">return_index = indices </span><span class="s0">is not None</span>
    <span class="s1">return_counts = counts </span><span class="s0">is not None</span>

    <span class="s1">u = np.unique(ar)</span>

    <span class="s1">dt = [(</span><span class="s4">&quot;values&quot;</span><span class="s0">, </span><span class="s1">u.dtype)]</span>
    <span class="s0">if </span><span class="s1">return_index:</span>
        <span class="s1">dt.append((</span><span class="s4">&quot;indices&quot;</span><span class="s0">, </span><span class="s1">np.intp))</span>
    <span class="s0">if </span><span class="s1">return_inverse:</span>
        <span class="s1">dt.append((</span><span class="s4">&quot;inverse&quot;</span><span class="s0">, </span><span class="s1">np.intp))</span>
    <span class="s0">if </span><span class="s1">return_counts:</span>
        <span class="s1">dt.append((</span><span class="s4">&quot;counts&quot;</span><span class="s0">, </span><span class="s1">np.intp))</span>

    <span class="s1">r = np.empty(u.shape</span><span class="s0">, </span><span class="s1">dtype=dt)</span>
    <span class="s1">r[</span><span class="s4">&quot;values&quot;</span><span class="s1">] = u</span>
    <span class="s0">if </span><span class="s1">return_inverse:</span>
        <span class="s1">r[</span><span class="s4">&quot;inverse&quot;</span><span class="s1">] = np.arange(len(r)</span><span class="s0">, </span><span class="s1">dtype=np.intp)</span>
    <span class="s0">if </span><span class="s1">return_index </span><span class="s0">or </span><span class="s1">return_counts:</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">enumerate(r[</span><span class="s4">&quot;values&quot;</span><span class="s1">]):</span>
            <span class="s1">m = ar == v</span>
            <span class="s0">if </span><span class="s1">return_index:</span>
                <span class="s1">indices[m].min(keepdims=</span><span class="s0">True, </span><span class="s1">out=r[</span><span class="s4">&quot;indices&quot;</span><span class="s1">][i : i + </span><span class="s3">1</span><span class="s1">])</span>
            <span class="s0">if </span><span class="s1">return_counts:</span>
                <span class="s1">counts[m].sum(keepdims=</span><span class="s0">True, </span><span class="s1">out=r[</span><span class="s4">&quot;counts&quot;</span><span class="s1">][i : i + </span><span class="s3">1</span><span class="s1">])</span>

    <span class="s0">return </span><span class="s1">r</span>


<span class="s0">def </span><span class="s1">unique_no_structured_arr(</span>
    <span class="s1">ar</span><span class="s0">, </span><span class="s1">return_index=</span><span class="s0">False, </span><span class="s1">return_inverse=</span><span class="s0">False, </span><span class="s1">return_counts=</span><span class="s0">False</span>
<span class="s1">):</span>
    <span class="s2"># A simplified version of `unique`, that allows computing unique for array</span>
    <span class="s2"># types that don't support structured arrays (such as cupy.ndarray), but</span>
    <span class="s2"># can only compute values at the moment.</span>

    <span class="s0">if </span><span class="s1">(</span>
        <span class="s1">return_index </span><span class="s0">is not False</span>
        <span class="s0">or </span><span class="s1">return_inverse </span><span class="s0">is not False</span>
        <span class="s0">or </span><span class="s1">return_counts </span><span class="s0">is not False</span>
    <span class="s1">):</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span>
            <span class="s4">&quot;dask.array.unique does not support `return_index`, `return_inverse` &quot;</span>
            <span class="s4">&quot;or `return_counts` with array types that don't support structured &quot;</span>
            <span class="s4">&quot;arrays.&quot;</span>
        <span class="s1">)</span>

    <span class="s1">ar = ar.ravel()</span>

    <span class="s1">args = [ar</span><span class="s0">, </span><span class="s4">&quot;i&quot;</span><span class="s1">]</span>
    <span class="s1">meta = meta_from_array(ar)</span>

    <span class="s1">out = blockwise(np.unique</span><span class="s0">, </span><span class="s4">&quot;i&quot;</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">meta=meta)</span>
    <span class="s1">out._chunks = tuple((np.nan</span><span class="s0">,</span><span class="s1">) * len(c) </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">out.chunks)</span>

    <span class="s1">out_parts = [out]</span>

    <span class="s1">name = </span><span class="s4">&quot;unique-aggregate-&quot; </span><span class="s1">+ out.name</span>
    <span class="s1">dsk = {</span>
        <span class="s1">(name</span><span class="s0">, </span><span class="s3">0</span><span class="s1">): (</span>
            <span class="s1">(np.unique</span><span class="s0">,</span><span class="s1">)</span>
            <span class="s1">+ tuple(</span>
                <span class="s1">(np.concatenate</span><span class="s0">, </span><span class="s1">o.__dask_keys__())</span>
                <span class="s0">if </span><span class="s1">hasattr(o</span><span class="s0">, </span><span class="s4">&quot;__dask_keys__&quot;</span><span class="s1">)</span>
                <span class="s0">else </span><span class="s1">o</span>
                <span class="s0">for </span><span class="s1">o </span><span class="s0">in </span><span class="s1">out_parts</span>
            <span class="s1">)</span>
        <span class="s1">)</span>
    <span class="s1">}</span>

    <span class="s1">dependencies = [o </span><span class="s0">for </span><span class="s1">o </span><span class="s0">in </span><span class="s1">out_parts </span><span class="s0">if </span><span class="s1">hasattr(o</span><span class="s0">, </span><span class="s4">&quot;__dask_keys__&quot;</span><span class="s1">)]</span>
    <span class="s1">graph = HighLevelGraph.from_collections(name</span><span class="s0">, </span><span class="s1">dsk</span><span class="s0">, </span><span class="s1">dependencies=dependencies)</span>
    <span class="s1">chunks = ((np.nan</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,</span><span class="s1">)</span>
    <span class="s1">out = Array(graph</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">chunks</span><span class="s0">, </span><span class="s1">meta=meta)</span>

    <span class="s1">result = [out]</span>

    <span class="s0">if </span><span class="s1">len(result) == </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s1">result = result[</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">result = tuple(result)</span>

    <span class="s0">return </span><span class="s1">result</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">unique(ar</span><span class="s0">, </span><span class="s1">return_index=</span><span class="s0">False, </span><span class="s1">return_inverse=</span><span class="s0">False, </span><span class="s1">return_counts=</span><span class="s0">False</span><span class="s1">):</span>
    <span class="s2"># Test whether the downstream library supports structured arrays. If the</span>
    <span class="s2"># `np.empty_like` call raises a `TypeError`, the downstream library (e.g.,</span>
    <span class="s2"># CuPy) doesn't support it. In that case we return the</span>
    <span class="s2"># `unique_no_structured_arr` implementation, otherwise (e.g., NumPy) just</span>
    <span class="s2"># continue as normal.</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">meta = meta_from_array(ar)</span>
        <span class="s1">np.empty_like(meta</span><span class="s0">, </span><span class="s1">dtype=[(</span><span class="s4">&quot;a&quot;</span><span class="s0">, </span><span class="s1">int)</span><span class="s0">, </span><span class="s1">(</span><span class="s4">&quot;b&quot;</span><span class="s0">, </span><span class="s1">float)])</span>
    <span class="s0">except </span><span class="s1">TypeError:</span>
        <span class="s0">return </span><span class="s1">unique_no_structured_arr(</span>
            <span class="s1">ar</span><span class="s0">,</span>
            <span class="s1">return_index=return_index</span><span class="s0">,</span>
            <span class="s1">return_inverse=return_inverse</span><span class="s0">,</span>
            <span class="s1">return_counts=return_counts</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s1">ar = ar.ravel()</span>

    <span class="s2"># Run unique on each chunk and collect results in a Dask Array of</span>
    <span class="s2"># unknown size.</span>

    <span class="s1">args = [ar</span><span class="s0">, </span><span class="s4">&quot;i&quot;</span><span class="s1">]</span>
    <span class="s1">out_dtype = [(</span><span class="s4">&quot;values&quot;</span><span class="s0">, </span><span class="s1">ar.dtype)]</span>
    <span class="s0">if </span><span class="s1">return_index:</span>
        <span class="s1">args.extend([arange(ar.shape[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.intp</span><span class="s0">, </span><span class="s1">chunks=ar.chunks[</span><span class="s3">0</span><span class="s1">])</span><span class="s0">, </span><span class="s4">&quot;i&quot;</span><span class="s1">])</span>
        <span class="s1">out_dtype.append((</span><span class="s4">&quot;indices&quot;</span><span class="s0">, </span><span class="s1">np.intp))</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">args.extend([</span><span class="s0">None, None</span><span class="s1">])</span>
    <span class="s0">if </span><span class="s1">return_counts:</span>
        <span class="s1">args.extend([ones((ar.shape[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=np.intp</span><span class="s0">, </span><span class="s1">chunks=ar.chunks[</span><span class="s3">0</span><span class="s1">])</span><span class="s0">, </span><span class="s4">&quot;i&quot;</span><span class="s1">])</span>
        <span class="s1">out_dtype.append((</span><span class="s4">&quot;counts&quot;</span><span class="s0">, </span><span class="s1">np.intp))</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">args.extend([</span><span class="s0">None, None</span><span class="s1">])</span>

    <span class="s1">out = blockwise(_unique_internal</span><span class="s0">, </span><span class="s4">&quot;i&quot;</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">dtype=out_dtype</span><span class="s0">, </span><span class="s1">return_inverse=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">out._chunks = tuple((np.nan</span><span class="s0">,</span><span class="s1">) * len(c) </span><span class="s0">for </span><span class="s1">c </span><span class="s0">in </span><span class="s1">out.chunks)</span>

    <span class="s2"># Take the results from the unique chunks and do the following.</span>
    <span class="s2">#</span>
    <span class="s2"># 1. Collect all results as arguments.</span>
    <span class="s2"># 2. Concatenate each result into one big array.</span>
    <span class="s2"># 3. Pass all results as arguments to the internal unique again.</span>
    <span class="s2">#</span>
    <span class="s2"># TODO: This should be replaced with a tree reduction using this strategy.</span>
    <span class="s2"># xref: https://github.com/dask/dask/issues/2851</span>

    <span class="s1">out_parts = [out[</span><span class="s4">&quot;values&quot;</span><span class="s1">]]</span>
    <span class="s0">if </span><span class="s1">return_index:</span>
        <span class="s1">out_parts.append(out[</span><span class="s4">&quot;indices&quot;</span><span class="s1">])</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">out_parts.append(</span><span class="s0">None</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">return_counts:</span>
        <span class="s1">out_parts.append(out[</span><span class="s4">&quot;counts&quot;</span><span class="s1">])</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">out_parts.append(</span><span class="s0">None</span><span class="s1">)</span>

    <span class="s1">name = </span><span class="s4">&quot;unique-aggregate-&quot; </span><span class="s1">+ out.name</span>
    <span class="s1">dsk = {</span>
        <span class="s1">(name</span><span class="s0">, </span><span class="s3">0</span><span class="s1">): (</span>
            <span class="s1">(_unique_internal</span><span class="s0">,</span><span class="s1">)</span>
            <span class="s1">+ tuple(</span>
                <span class="s1">(np.concatenate</span><span class="s0">, </span><span class="s1">o.__dask_keys__())</span>
                <span class="s0">if </span><span class="s1">hasattr(o</span><span class="s0">, </span><span class="s4">&quot;__dask_keys__&quot;</span><span class="s1">)</span>
                <span class="s0">else </span><span class="s1">o</span>
                <span class="s0">for </span><span class="s1">o </span><span class="s0">in </span><span class="s1">out_parts</span>
            <span class="s1">)</span>
            <span class="s1">+ (return_inverse</span><span class="s0">,</span><span class="s1">)</span>
        <span class="s1">)</span>
    <span class="s1">}</span>
    <span class="s1">out_dtype = [(</span><span class="s4">&quot;values&quot;</span><span class="s0">, </span><span class="s1">ar.dtype)]</span>
    <span class="s0">if </span><span class="s1">return_index:</span>
        <span class="s1">out_dtype.append((</span><span class="s4">&quot;indices&quot;</span><span class="s0">, </span><span class="s1">np.intp))</span>
    <span class="s0">if </span><span class="s1">return_inverse:</span>
        <span class="s1">out_dtype.append((</span><span class="s4">&quot;inverse&quot;</span><span class="s0">, </span><span class="s1">np.intp))</span>
    <span class="s0">if </span><span class="s1">return_counts:</span>
        <span class="s1">out_dtype.append((</span><span class="s4">&quot;counts&quot;</span><span class="s0">, </span><span class="s1">np.intp))</span>

    <span class="s1">dependencies = [o </span><span class="s0">for </span><span class="s1">o </span><span class="s0">in </span><span class="s1">out_parts </span><span class="s0">if </span><span class="s1">hasattr(o</span><span class="s0">, </span><span class="s4">&quot;__dask_keys__&quot;</span><span class="s1">)]</span>
    <span class="s1">graph = HighLevelGraph.from_collections(name</span><span class="s0">, </span><span class="s1">dsk</span><span class="s0">, </span><span class="s1">dependencies=dependencies)</span>
    <span class="s1">chunks = ((np.nan</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,</span><span class="s1">)</span>
    <span class="s1">out = Array(graph</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">chunks</span><span class="s0">, </span><span class="s1">out_dtype)</span>

    <span class="s2"># Split out all results to return to the user.</span>

    <span class="s1">result = [out[</span><span class="s4">&quot;values&quot;</span><span class="s1">]]</span>
    <span class="s0">if </span><span class="s1">return_index:</span>
        <span class="s1">result.append(out[</span><span class="s4">&quot;indices&quot;</span><span class="s1">])</span>
    <span class="s0">if </span><span class="s1">return_inverse:</span>
        <span class="s2"># Using the returned unique values and arange of unknown length, find</span>
        <span class="s2"># each value matching a unique value and replace it with its</span>
        <span class="s2"># corresponding index or `0`. There should be only one entry for this</span>
        <span class="s2"># index in axis `1` (the one of unknown length). Reduce axis `1`</span>
        <span class="s2"># through summing to get an array with known dimensionality and the</span>
        <span class="s2"># mapping of the original values.</span>
        <span class="s1">mtches = (ar[:</span><span class="s0">, None</span><span class="s1">] == out[</span><span class="s4">&quot;values&quot;</span><span class="s1">][</span><span class="s0">None, </span><span class="s1">:]).astype(np.intp)</span>
        <span class="s1">result.append((mtches * out[</span><span class="s4">&quot;inverse&quot;</span><span class="s1">]).sum(axis=</span><span class="s3">1</span><span class="s1">))</span>
    <span class="s0">if </span><span class="s1">return_counts:</span>
        <span class="s1">result.append(out[</span><span class="s4">&quot;counts&quot;</span><span class="s1">])</span>

    <span class="s0">if </span><span class="s1">len(result) == </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s1">result = result[</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">result = tuple(result)</span>

    <span class="s0">return </span><span class="s1">result</span>


<span class="s0">def </span><span class="s1">_isin_kernel(element</span><span class="s0">, </span><span class="s1">test_elements</span><span class="s0">, </span><span class="s1">assume_unique=</span><span class="s0">False</span><span class="s1">):</span>
    <span class="s1">values = np.isin(element.ravel()</span><span class="s0">, </span><span class="s1">test_elements</span><span class="s0">, </span><span class="s1">assume_unique=assume_unique)</span>
    <span class="s0">return </span><span class="s1">values.reshape(element.shape + (</span><span class="s3">1</span><span class="s0">,</span><span class="s1">) * test_elements.ndim)</span>


<span class="s1">@safe_wraps(getattr(np</span><span class="s0">, </span><span class="s4">&quot;isin&quot;</span><span class="s0">, None</span><span class="s1">))</span>
<span class="s0">def </span><span class="s1">isin(element</span><span class="s0">, </span><span class="s1">test_elements</span><span class="s0">, </span><span class="s1">assume_unique=</span><span class="s0">False, </span><span class="s1">invert=</span><span class="s0">False</span><span class="s1">):</span>
    <span class="s1">element = asarray(element)</span>
    <span class="s1">test_elements = asarray(test_elements)</span>
    <span class="s1">element_axes = tuple(range(element.ndim))</span>
    <span class="s1">test_axes = tuple(i + element.ndim </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(test_elements.ndim))</span>
    <span class="s1">mapped = blockwise(</span>
        <span class="s1">_isin_kernel</span><span class="s0">,</span>
        <span class="s1">element_axes + test_axes</span><span class="s0">,</span>
        <span class="s1">element</span><span class="s0">,</span>
        <span class="s1">element_axes</span><span class="s0">,</span>
        <span class="s1">test_elements</span><span class="s0">,</span>
        <span class="s1">test_axes</span><span class="s0">,</span>
        <span class="s1">adjust_chunks={axis: </span><span class="s0">lambda </span><span class="s1">_: </span><span class="s3">1 </span><span class="s0">for </span><span class="s1">axis </span><span class="s0">in </span><span class="s1">test_axes}</span><span class="s0">,</span>
        <span class="s1">dtype=bool</span><span class="s0">,</span>
        <span class="s1">assume_unique=assume_unique</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s1">result = mapped.any(axis=test_axes)</span>
    <span class="s0">if </span><span class="s1">invert:</span>
        <span class="s1">result = ~result</span>
    <span class="s0">return </span><span class="s1">result</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">roll(array</span><span class="s0">, </span><span class="s1">shift</span><span class="s0">, </span><span class="s1">axis=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s1">result = array</span>

    <span class="s0">if </span><span class="s1">axis </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">result = ravel(result)</span>

        <span class="s0">if not </span><span class="s1">isinstance(shift</span><span class="s0">, </span><span class="s1">Integral):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span>
                <span class="s4">&quot;Expect `shift` to be an instance of Integral when `axis` is None.&quot;</span>
            <span class="s1">)</span>

        <span class="s1">shift = (shift</span><span class="s0">,</span><span class="s1">)</span>
        <span class="s1">axis = (</span><span class="s3">0</span><span class="s0">,</span><span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">len(shift)</span>
        <span class="s0">except </span><span class="s1">TypeError:</span>
            <span class="s1">shift = (shift</span><span class="s0">,</span><span class="s1">)</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">len(axis)</span>
        <span class="s0">except </span><span class="s1">TypeError:</span>
            <span class="s1">axis = (axis</span><span class="s0">,</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">len(shift) != len(axis):</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Must have the same number of shifts as axes.&quot;</span><span class="s1">)</span>

    <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">s </span><span class="s0">in </span><span class="s1">zip(axis</span><span class="s0">, </span><span class="s1">shift):</span>
        <span class="s1">shape = result.shape[i]</span>
        <span class="s1">s = </span><span class="s3">0 </span><span class="s0">if </span><span class="s1">shape == </span><span class="s3">0 </span><span class="s0">else </span><span class="s1">-s % shape</span>

        <span class="s1">sl1 = result.ndim * [slice(</span><span class="s0">None</span><span class="s1">)]</span>
        <span class="s1">sl2 = result.ndim * [slice(</span><span class="s0">None</span><span class="s1">)]</span>

        <span class="s1">sl1[i] = slice(s</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s1">sl2[i] = slice(</span><span class="s0">None, </span><span class="s1">s)</span>

        <span class="s1">sl1 = tuple(sl1)</span>
        <span class="s1">sl2 = tuple(sl2)</span>

        <span class="s1">result = concatenate([result[sl1]</span><span class="s0">, </span><span class="s1">result[sl2]]</span><span class="s0">, </span><span class="s1">axis=i)</span>

    <span class="s1">result = result.reshape(array.shape)</span>
    <span class="s2"># Ensure that the output is always a new array object</span>
    <span class="s1">result = result.copy() </span><span class="s0">if </span><span class="s1">result </span><span class="s0">is </span><span class="s1">array </span><span class="s0">else </span><span class="s1">result</span>

    <span class="s0">return </span><span class="s1">result</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">shape(array):</span>
    <span class="s0">return </span><span class="s1">array.shape</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">union1d(ar1</span><span class="s0">, </span><span class="s1">ar2):</span>
    <span class="s0">return </span><span class="s1">unique(concatenate((ar1.ravel()</span><span class="s0">, </span><span class="s1">ar2.ravel())))</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">ravel(array_like):</span>
    <span class="s0">return </span><span class="s1">asanyarray(array_like).reshape((-</span><span class="s3">1</span><span class="s0">,</span><span class="s1">))</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">expand_dims(a</span><span class="s0">, </span><span class="s1">axis):</span>
    <span class="s0">if </span><span class="s1">type(axis) </span><span class="s0">not in </span><span class="s1">(tuple</span><span class="s0">, </span><span class="s1">list):</span>
        <span class="s1">axis = (axis</span><span class="s0">,</span><span class="s1">)</span>

    <span class="s1">out_ndim = len(axis) + a.ndim</span>
    <span class="s1">axis = validate_axis(axis</span><span class="s0">, </span><span class="s1">out_ndim)</span>

    <span class="s1">shape_it = iter(a.shape)</span>
    <span class="s1">shape = [</span><span class="s3">1 </span><span class="s0">if </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">axis </span><span class="s0">else </span><span class="s1">next(shape_it) </span><span class="s0">for </span><span class="s1">ax </span><span class="s0">in </span><span class="s1">range(out_ndim)]</span>

    <span class="s0">return </span><span class="s1">a.reshape(shape)</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">squeeze(a</span><span class="s0">, </span><span class="s1">axis=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s0">if </span><span class="s1">axis </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">axis = tuple(i </span><span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">d </span><span class="s0">in </span><span class="s1">enumerate(a.shape) </span><span class="s0">if </span><span class="s1">d == </span><span class="s3">1</span><span class="s1">)</span>
    <span class="s0">elif not </span><span class="s1">isinstance(axis</span><span class="s0">, </span><span class="s1">tuple):</span>
        <span class="s1">axis = (axis</span><span class="s0">,</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">any(a.shape[i] != </span><span class="s3">1 </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">axis):</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;cannot squeeze axis with size other than one&quot;</span><span class="s1">)</span>

    <span class="s1">axis = validate_axis(axis</span><span class="s0">, </span><span class="s1">a.ndim)</span>

    <span class="s1">sl = tuple(</span><span class="s3">0 </span><span class="s0">if </span><span class="s1">i </span><span class="s0">in </span><span class="s1">axis </span><span class="s0">else </span><span class="s1">slice(</span><span class="s0">None</span><span class="s1">) </span><span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">s </span><span class="s0">in </span><span class="s1">enumerate(a.shape))</span>

    <span class="s2"># Return 0d Dask Array if all axes are squeezed,</span>
    <span class="s2"># to be consistent with NumPy. Ref: https://github.com/dask/dask/issues/9183#issuecomment-1155626619</span>
    <span class="s0">if </span><span class="s1">all(s == </span><span class="s3">0 </span><span class="s0">for </span><span class="s1">s </span><span class="s0">in </span><span class="s1">sl) </span><span class="s0">and </span><span class="s1">all(s == </span><span class="s3">1 </span><span class="s0">for </span><span class="s1">s </span><span class="s0">in </span><span class="s1">a.shape):</span>
        <span class="s0">return </span><span class="s1">a.map_blocks(</span>
            <span class="s1">np.squeeze</span><span class="s0">, </span><span class="s1">meta=a._meta</span><span class="s0">, </span><span class="s1">drop_axis=tuple(range(len(a.shape)))</span>
        <span class="s1">)</span>

    <span class="s1">a = a[sl]</span>

    <span class="s0">return </span><span class="s1">a</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">compress(condition</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">axis=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s0">if not </span><span class="s1">is_arraylike(condition):</span>
        <span class="s2"># Allow `condition` to be anything array-like, otherwise ensure `condition`</span>
        <span class="s2"># is a numpy array.</span>
        <span class="s1">condition = np.asarray(condition)</span>
    <span class="s1">condition = condition.astype(bool)</span>
    <span class="s1">a = asarray(a)</span>

    <span class="s0">if </span><span class="s1">condition.ndim != </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Condition must be one dimensional&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">axis </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">a = a.ravel()</span>
        <span class="s1">axis = </span><span class="s3">0</span>
    <span class="s1">axis = validate_axis(axis</span><span class="s0">, </span><span class="s1">a.ndim)</span>

    <span class="s2"># Treat `condition` as filled with `False` (if it is too short)</span>
    <span class="s1">a = a[</span>
        <span class="s1">tuple(</span>
            <span class="s1">slice(</span><span class="s0">None, </span><span class="s1">len(condition)) </span><span class="s0">if </span><span class="s1">i == axis </span><span class="s0">else </span><span class="s1">slice(</span><span class="s0">None</span><span class="s1">)</span>
            <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(a.ndim)</span>
        <span class="s1">)</span>
    <span class="s1">]</span>

    <span class="s2"># Use `condition` to select along 1 dimension</span>
    <span class="s1">a = a[tuple(condition </span><span class="s0">if </span><span class="s1">i == axis </span><span class="s0">else </span><span class="s1">slice(</span><span class="s0">None</span><span class="s1">) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(a.ndim))]</span>

    <span class="s0">return </span><span class="s1">a</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">extract(condition</span><span class="s0">, </span><span class="s1">arr):</span>
    <span class="s1">condition = asarray(condition).astype(bool)</span>
    <span class="s1">arr = asarray(arr)</span>
    <span class="s0">return </span><span class="s1">compress(condition.ravel()</span><span class="s0">, </span><span class="s1">arr.ravel())</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">take(a</span><span class="s0">, </span><span class="s1">indices</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">):</span>
    <span class="s1">axis = validate_axis(axis</span><span class="s0">, </span><span class="s1">a.ndim)</span>

    <span class="s0">if </span><span class="s1">isinstance(a</span><span class="s0">, </span><span class="s1">np.ndarray) </span><span class="s0">and </span><span class="s1">isinstance(indices</span><span class="s0">, </span><span class="s1">Array):</span>
        <span class="s0">return </span><span class="s1">_take_dask_array_from_numpy(a</span><span class="s0">, </span><span class="s1">indices</span><span class="s0">, </span><span class="s1">axis)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">a[(slice(</span><span class="s0">None</span><span class="s1">)</span><span class="s0">,</span><span class="s1">) * axis + (indices</span><span class="s0">,</span><span class="s1">)]</span>


<span class="s0">def </span><span class="s1">_take_dask_array_from_numpy(a</span><span class="s0">, </span><span class="s1">indices</span><span class="s0">, </span><span class="s1">axis):</span>
    <span class="s0">assert </span><span class="s1">isinstance(a</span><span class="s0">, </span><span class="s1">np.ndarray)</span>
    <span class="s0">assert </span><span class="s1">isinstance(indices</span><span class="s0">, </span><span class="s1">Array)</span>

    <span class="s0">return </span><span class="s1">indices.map_blocks(</span>
        <span class="s0">lambda </span><span class="s1">block: np.take(a</span><span class="s0">, </span><span class="s1">block</span><span class="s0">, </span><span class="s1">axis)</span><span class="s0">, </span><span class="s1">chunks=indices.chunks</span><span class="s0">, </span><span class="s1">dtype=a.dtype</span>
    <span class="s1">)</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">around(x</span><span class="s0">, </span><span class="s1">decimals=</span><span class="s3">0</span><span class="s1">):</span>
    <span class="s0">return </span><span class="s1">map_blocks(partial(np.around</span><span class="s0">, </span><span class="s1">decimals=decimals)</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">dtype=x.dtype)</span>


<span class="s0">def </span><span class="s1">_asarray_isnull(values):</span>
    <span class="s0">import </span><span class="s1">pandas </span><span class="s0">as </span><span class="s1">pd</span>

    <span class="s0">return </span><span class="s1">np.asarray(pd.isnull(values))</span>


<span class="s0">def </span><span class="s1">isnull(values):</span>
    <span class="s5">&quot;&quot;&quot;pandas.isnull for dask arrays&quot;&quot;&quot;</span>
    <span class="s2"># eagerly raise ImportError, if pandas isn't available</span>
    <span class="s0">import </span><span class="s1">pandas </span><span class="s0">as </span><span class="s1">pd  </span><span class="s2"># noqa</span>

    <span class="s0">return </span><span class="s1">elemwise(_asarray_isnull</span><span class="s0">, </span><span class="s1">values</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s4">&quot;bool&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">notnull(values):</span>
    <span class="s5">&quot;&quot;&quot;pandas.notnull for dask arrays&quot;&quot;&quot;</span>
    <span class="s0">return </span><span class="s1">~isnull(values)</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">isclose(arr1</span><span class="s0">, </span><span class="s1">arr2</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-5</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-8</span><span class="s0">, </span><span class="s1">equal_nan=</span><span class="s0">False</span><span class="s1">):</span>
    <span class="s1">func = partial(np.isclose</span><span class="s0">, </span><span class="s1">rtol=rtol</span><span class="s0">, </span><span class="s1">atol=atol</span><span class="s0">, </span><span class="s1">equal_nan=equal_nan)</span>
    <span class="s0">return </span><span class="s1">elemwise(func</span><span class="s0">, </span><span class="s1">arr1</span><span class="s0">, </span><span class="s1">arr2</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s4">&quot;bool&quot;</span><span class="s1">)</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">allclose(arr1</span><span class="s0">, </span><span class="s1">arr2</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s3">1e-5</span><span class="s0">, </span><span class="s1">atol=</span><span class="s3">1e-8</span><span class="s0">, </span><span class="s1">equal_nan=</span><span class="s0">False</span><span class="s1">):</span>
    <span class="s0">return </span><span class="s1">isclose(arr1</span><span class="s0">, </span><span class="s1">arr2</span><span class="s0">, </span><span class="s1">rtol=rtol</span><span class="s0">, </span><span class="s1">atol=atol</span><span class="s0">, </span><span class="s1">equal_nan=equal_nan).all()</span>


<span class="s0">def </span><span class="s1">variadic_choose(a</span><span class="s0">, </span><span class="s1">*choices):</span>
    <span class="s0">return </span><span class="s1">np.choose(a</span><span class="s0">, </span><span class="s1">choices)</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">choose(a</span><span class="s0">, </span><span class="s1">choices):</span>
    <span class="s0">return </span><span class="s1">elemwise(variadic_choose</span><span class="s0">, </span><span class="s1">a</span><span class="s0">, </span><span class="s1">*choices)</span>


<span class="s0">def </span><span class="s1">_isnonzero_vec(v):</span>
    <span class="s0">return </span><span class="s1">bool(np.count_nonzero(v))</span>


<span class="s1">_isnonzero_vec = np.vectorize(_isnonzero_vec</span><span class="s0">, </span><span class="s1">otypes=[bool])</span>


<span class="s0">def </span><span class="s1">isnonzero(a):</span>
    <span class="s0">if </span><span class="s1">a.dtype.kind </span><span class="s0">in </span><span class="s1">{</span><span class="s4">&quot;U&quot;</span><span class="s0">, </span><span class="s4">&quot;S&quot;</span><span class="s1">}:</span>
        <span class="s2"># NumPy treats all-whitespace strings as falsy (like in `np.nonzero`).</span>
        <span class="s2"># but not in `.astype(bool)`. To match the behavior of numpy at least until</span>
        <span class="s2"># 1.19, we use `_isnonzero_vec`. When NumPy changes behavior, we should just</span>
        <span class="s2"># use the try block below.</span>
        <span class="s2"># https://github.com/numpy/numpy/issues/9875</span>
        <span class="s0">return </span><span class="s1">a.map_blocks(_isnonzero_vec</span><span class="s0">, </span><span class="s1">dtype=bool)</span>
    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">np.zeros(tuple()</span><span class="s0">, </span><span class="s1">dtype=a.dtype).astype(bool)</span>
    <span class="s0">except </span><span class="s1">ValueError:</span>
        <span class="s2">######################################################</span>
        <span class="s2"># Handle special cases where conversion to bool does #</span>
        <span class="s2"># not work correctly.                                #</span>
        <span class="s2">#                                                    #</span>
        <span class="s2"># xref: https://github.com/numpy/numpy/issues/9479   #</span>
        <span class="s2">######################################################</span>
        <span class="s0">return </span><span class="s1">a.map_blocks(_isnonzero_vec</span><span class="s0">, </span><span class="s1">dtype=bool)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">a.astype(bool)</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">argwhere(a):</span>
    <span class="s1">a = asarray(a)</span>

    <span class="s1">nz = isnonzero(a).flatten()</span>

    <span class="s1">ind = indices(a.shape</span><span class="s0">, </span><span class="s1">dtype=np.intp</span><span class="s0">, </span><span class="s1">chunks=a.chunks)</span>
    <span class="s0">if </span><span class="s1">ind.ndim &gt; </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s1">ind = stack([ind[i].ravel() </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(len(ind))]</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">1</span><span class="s1">)</span>
    <span class="s1">ind = compress(nz</span><span class="s0">, </span><span class="s1">ind</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">)</span>

    <span class="s0">return </span><span class="s1">ind</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">where(condition</span><span class="s0">, </span><span class="s1">x=</span><span class="s0">None, </span><span class="s1">y=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s0">if </span><span class="s1">(x </span><span class="s0">is None</span><span class="s1">) != (y </span><span class="s0">is None</span><span class="s1">):</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;either both or neither of x and y should be given&quot;</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">(x </span><span class="s0">is None</span><span class="s1">) </span><span class="s0">and </span><span class="s1">(y </span><span class="s0">is None</span><span class="s1">):</span>
        <span class="s0">return </span><span class="s1">nonzero(condition)</span>

    <span class="s0">if </span><span class="s1">np.isscalar(condition):</span>
        <span class="s1">dtype = result_type(x</span><span class="s0">, </span><span class="s1">y)</span>
        <span class="s1">x = asarray(x)</span>
        <span class="s1">y = asarray(y)</span>

        <span class="s1">shape = broadcast_shapes(x.shape</span><span class="s0">, </span><span class="s1">y.shape)</span>
        <span class="s1">out = x </span><span class="s0">if </span><span class="s1">condition </span><span class="s0">else </span><span class="s1">y</span>

        <span class="s0">return </span><span class="s1">broadcast_to(out</span><span class="s0">, </span><span class="s1">shape).astype(dtype)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">elemwise(np.where</span><span class="s0">, </span><span class="s1">condition</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">y)</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">count_nonzero(a</span><span class="s0">, </span><span class="s1">axis=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s0">return </span><span class="s1">isnonzero(asarray(a)).astype(np.intp).sum(axis=axis)</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">flatnonzero(a):</span>
    <span class="s0">return </span><span class="s1">argwhere(asarray(a).ravel())[:</span><span class="s0">, </span><span class="s3">0</span><span class="s1">]</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">nonzero(a):</span>
    <span class="s1">ind = argwhere(a)</span>
    <span class="s0">if </span><span class="s1">ind.ndim &gt; </span><span class="s3">1</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">tuple(ind[:</span><span class="s0">, </span><span class="s1">i] </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(ind.shape[</span><span class="s3">1</span><span class="s1">]))</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">(ind</span><span class="s0">,</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">_unravel_index_kernel(indices</span><span class="s0">, </span><span class="s1">func_kwargs):</span>
    <span class="s0">return </span><span class="s1">np.stack(np.unravel_index(indices</span><span class="s0">, </span><span class="s1">**func_kwargs))</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">unravel_index(indices</span><span class="s0">, </span><span class="s1">shape</span><span class="s0">, </span><span class="s1">order=</span><span class="s4">&quot;C&quot;</span><span class="s1">):</span>
    <span class="s0">if </span><span class="s1">shape </span><span class="s0">and </span><span class="s1">indices.size:</span>
        <span class="s1">unraveled_indices = tuple(</span>
            <span class="s1">indices.map_blocks(</span>
                <span class="s1">_unravel_index_kernel</span><span class="s0">,</span>
                <span class="s1">dtype=np.intp</span><span class="s0">,</span>
                <span class="s1">chunks=(((len(shape)</span><span class="s0">,</span><span class="s1">)</span><span class="s0">,</span><span class="s1">) + indices.chunks)</span><span class="s0">,</span>
                <span class="s1">new_axis=</span><span class="s3">0</span><span class="s0">,</span>
                <span class="s1">func_kwargs={</span><span class="s4">&quot;shape&quot;</span><span class="s1">: shape</span><span class="s0">, </span><span class="s4">&quot;order&quot;</span><span class="s1">: order}</span><span class="s0">,</span>
            <span class="s1">)</span>
        <span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">unraveled_indices = tuple(empty((</span><span class="s3">0</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=np.intp</span><span class="s0">, </span><span class="s1">chunks=</span><span class="s3">1</span><span class="s1">) </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">shape)</span>

    <span class="s0">return </span><span class="s1">unraveled_indices</span>


<span class="s1">@wraps(np.ravel_multi_index)</span>
<span class="s0">def </span><span class="s1">ravel_multi_index(multi_index</span><span class="s0">, </span><span class="s1">dims</span><span class="s0">, </span><span class="s1">mode=</span><span class="s4">&quot;raise&quot;</span><span class="s0">, </span><span class="s1">order=</span><span class="s4">&quot;C&quot;</span><span class="s1">):</span>
    <span class="s0">if </span><span class="s1">np.isscalar(dims):</span>
        <span class="s1">dims = (dims</span><span class="s0">,</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">is_dask_collection(dims) </span><span class="s0">or </span><span class="s1">any(is_dask_collection(d) </span><span class="s0">for </span><span class="s1">d </span><span class="s0">in </span><span class="s1">dims):</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError(</span>
            <span class="s4">f&quot;Dask types are not supported in the `dims` argument: </span><span class="s0">{</span><span class="s1">dims</span><span class="s0">!r}</span><span class="s4">&quot;</span>
        <span class="s1">)</span>

    <span class="s0">if </span><span class="s1">is_arraylike(multi_index):</span>
        <span class="s1">index_stack = asarray(multi_index)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">multi_index_arrs = broadcast_arrays(*multi_index)</span>
        <span class="s1">index_stack = stack(multi_index_arrs)</span>

    <span class="s0">if not </span><span class="s1">np.isnan(index_stack.shape).any() </span><span class="s0">and </span><span class="s1">len(index_stack) != len(dims):</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span>
            <span class="s4">f&quot;parameter multi_index must be a sequence of length </span><span class="s0">{</span><span class="s1">len(dims)</span><span class="s0">}</span><span class="s4">&quot;</span>
        <span class="s1">)</span>
    <span class="s0">if not </span><span class="s1">np.issubdtype(index_stack.dtype</span><span class="s0">, </span><span class="s1">np.signedinteger):</span>
        <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;only int indices permitted&quot;</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">index_stack.map_blocks(</span>
        <span class="s1">np.ravel_multi_index</span><span class="s0">,</span>
        <span class="s1">dtype=np.intp</span><span class="s0">,</span>
        <span class="s1">chunks=index_stack.chunks[</span><span class="s3">1</span><span class="s1">:]</span><span class="s0">,</span>
        <span class="s1">drop_axis=</span><span class="s3">0</span><span class="s0">,</span>
        <span class="s1">dims=dims</span><span class="s0">,</span>
        <span class="s1">mode=mode</span><span class="s0">,</span>
        <span class="s1">order=order</span><span class="s0">,</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">_int_piecewise(x</span><span class="s0">, </span><span class="s1">*condlist</span><span class="s0">, </span><span class="s1">**kwargs):</span>
    <span class="s0">return </span><span class="s1">np.piecewise(</span>
        <span class="s1">x</span><span class="s0">, </span><span class="s1">list(condlist)</span><span class="s0">, </span><span class="s1">kwargs[</span><span class="s4">&quot;funclist&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">*kwargs[</span><span class="s4">&quot;func_args&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">**kwargs[</span><span class="s4">&quot;func_kw&quot;</span><span class="s1">]</span>
    <span class="s1">)</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">piecewise(x</span><span class="s0">, </span><span class="s1">condlist</span><span class="s0">, </span><span class="s1">funclist</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kw):</span>
    <span class="s0">return </span><span class="s1">map_blocks(</span>
        <span class="s1">_int_piecewise</span><span class="s0">,</span>
        <span class="s1">x</span><span class="s0">,</span>
        <span class="s1">*condlist</span><span class="s0">,</span>
        <span class="s1">dtype=x.dtype</span><span class="s0">,</span>
        <span class="s1">name=</span><span class="s4">&quot;piecewise&quot;</span><span class="s0">,</span>
        <span class="s1">funclist=funclist</span><span class="s0">,</span>
        <span class="s1">func_args=args</span><span class="s0">,</span>
        <span class="s1">func_kw=kw</span><span class="s0">,</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">_select(*args</span><span class="s0">, </span><span class="s1">**kwargs):</span>
    <span class="s5">&quot;&quot;&quot; 
    This is a version of :func:`numpy.select` that acceptes an arbitrary number of arguments and 
    splits them in half to create ``condlist`` and ``choicelist`` params. 
    &quot;&quot;&quot;</span>
    <span class="s1">split_at = len(args) // </span><span class="s3">2</span>
    <span class="s1">condlist = args[:split_at]</span>
    <span class="s1">choicelist = args[split_at:]</span>
    <span class="s0">return </span><span class="s1">np.select(condlist</span><span class="s0">, </span><span class="s1">choicelist</span><span class="s0">, </span><span class="s1">**kwargs)</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">select(condlist</span><span class="s0">, </span><span class="s1">choicelist</span><span class="s0">, </span><span class="s1">default=</span><span class="s3">0</span><span class="s1">):</span>
    <span class="s2"># Making the same checks that np.select</span>
    <span class="s2"># Check the size of condlist and choicelist are the same, or abort.</span>
    <span class="s0">if </span><span class="s1">len(condlist) != len(choicelist):</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;list of cases must be same length as list of conditions&quot;</span><span class="s1">)</span>

    <span class="s0">if </span><span class="s1">len(condlist) == </span><span class="s3">0</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;select with an empty condition list is not possible&quot;</span><span class="s1">)</span>

    <span class="s1">choicelist = [asarray(choice) </span><span class="s0">for </span><span class="s1">choice </span><span class="s0">in </span><span class="s1">choicelist]</span>

    <span class="s0">try</span><span class="s1">:</span>
        <span class="s1">intermediate_dtype = result_type(*choicelist)</span>
    <span class="s0">except </span><span class="s1">TypeError </span><span class="s0">as </span><span class="s1">e:</span>
        <span class="s1">msg = </span><span class="s4">&quot;Choicelist elements do not have a common dtype.&quot;</span>
        <span class="s0">raise </span><span class="s1">TypeError(msg) </span><span class="s0">from </span><span class="s1">e</span>

    <span class="s1">blockwise_shape = tuple(range(choicelist[</span><span class="s3">0</span><span class="s1">].ndim))</span>

    <span class="s1">condargs = [arg </span><span class="s0">for </span><span class="s1">elem </span><span class="s0">in </span><span class="s1">condlist </span><span class="s0">for </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">(elem</span><span class="s0">, </span><span class="s1">blockwise_shape)]</span>
    <span class="s1">choiceargs = [arg </span><span class="s0">for </span><span class="s1">elem </span><span class="s0">in </span><span class="s1">choicelist </span><span class="s0">for </span><span class="s1">arg </span><span class="s0">in </span><span class="s1">(elem</span><span class="s0">, </span><span class="s1">blockwise_shape)]</span>

    <span class="s0">return </span><span class="s1">blockwise(</span>
        <span class="s1">_select</span><span class="s0">,</span>
        <span class="s1">blockwise_shape</span><span class="s0">,</span>
        <span class="s1">*condargs</span><span class="s0">,</span>
        <span class="s1">*choiceargs</span><span class="s0">,</span>
        <span class="s1">dtype=intermediate_dtype</span><span class="s0">,</span>
        <span class="s1">name=</span><span class="s4">&quot;select&quot;</span><span class="s0">,</span>
        <span class="s1">default=default</span><span class="s0">,</span>
    <span class="s1">)</span>


<span class="s0">def </span><span class="s1">_partition(total: int</span><span class="s0">, </span><span class="s1">divisor: int) -&gt; tuple[tuple[int</span><span class="s0">, </span><span class="s1">...]</span><span class="s0">, </span><span class="s1">tuple[int</span><span class="s0">, </span><span class="s1">...]]:</span>
    <span class="s5">&quot;&quot;&quot;Given a total and a divisor, return two tuples: A tuple containing `divisor` 
    repeated the number of times it divides `total`, and length-1 or empty tuple 
    containing the remainder when `total` is divided by `divisor`. If `divisor` factors 
    `total`, i.e. if the remainder is 0, then `remainder` is empty. 
    &quot;&quot;&quot;</span>
    <span class="s1">multiples = (divisor</span><span class="s0">,</span><span class="s1">) * (total // divisor)</span>
    <span class="s1">remainder = (total % divisor</span><span class="s0">,</span><span class="s1">) </span><span class="s0">if </span><span class="s1">total % divisor </span><span class="s0">else </span><span class="s1">()</span>
    <span class="s0">return </span><span class="s1">multiples</span><span class="s0">, </span><span class="s1">remainder</span>


<span class="s0">def </span><span class="s1">aligned_coarsen_chunks(chunks: list[int]</span><span class="s0">, </span><span class="s1">multiple: int) -&gt; tuple[int</span><span class="s0">, </span><span class="s1">...]:</span>
    <span class="s5">&quot;&quot;&quot; 
    Returns a new chunking aligned with the coarsening multiple. 
    Any excess is at the end of the array. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; aligned_coarsen_chunks(chunks=(1, 2, 3), multiple=4) 
    (4, 2) 
    &gt;&gt;&gt; aligned_coarsen_chunks(chunks=(1, 20, 3, 4), multiple=4) 
    (4, 20, 4) 
    &gt;&gt;&gt; aligned_coarsen_chunks(chunks=(20, 10, 15, 23, 24), multiple=10) 
    (20, 10, 20, 20, 20, 2) 
    &quot;&quot;&quot;</span>
    <span class="s1">overflow = np.array(chunks) % multiple</span>
    <span class="s1">excess = overflow.sum()</span>
    <span class="s1">new_chunks = np.array(chunks) - overflow</span>
    <span class="s2"># valid chunks are those that are already factorizable by `multiple`</span>
    <span class="s1">chunk_validity = new_chunks == chunks</span>
    <span class="s1">valid_inds</span><span class="s0">, </span><span class="s1">invalid_inds = np.where(chunk_validity)[</span><span class="s3">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.where(~chunk_validity)[</span><span class="s3">0</span><span class="s1">]</span>
    <span class="s2"># sort the invalid chunks by size (ascending), then concatenate the results of</span>
    <span class="s2"># sorting the valid chunks by size (ascending)</span>
    <span class="s1">chunk_modification_order = [</span>
        <span class="s1">*invalid_inds[np.argsort(new_chunks[invalid_inds])]</span><span class="s0">,</span>
        <span class="s1">*valid_inds[np.argsort(new_chunks[valid_inds])]</span><span class="s0">,</span>
    <span class="s1">]</span>
    <span class="s1">partitioned_excess</span><span class="s0">, </span><span class="s1">remainder = _partition(excess</span><span class="s0">, </span><span class="s1">multiple)</span>
    <span class="s2"># add elements the partitioned excess to the smallest invalid chunks,</span>
    <span class="s2"># then smallest valid chunks if needed.</span>
    <span class="s0">for </span><span class="s1">idx</span><span class="s0">, </span><span class="s1">extra </span><span class="s0">in </span><span class="s1">enumerate(partitioned_excess):</span>
        <span class="s1">new_chunks[chunk_modification_order[idx]] += extra</span>
    <span class="s2"># create excess chunk with remainder, if any remainder exists</span>
    <span class="s1">new_chunks = np.array([*new_chunks</span><span class="s0">, </span><span class="s1">*remainder])</span>
    <span class="s2"># remove 0-sized chunks</span>
    <span class="s1">new_chunks = new_chunks[new_chunks &gt; </span><span class="s3">0</span><span class="s1">]</span>
    <span class="s0">return </span><span class="s1">tuple(new_chunks)</span>


<span class="s1">@wraps(chunk.coarsen)</span>
<span class="s0">def </span><span class="s1">coarsen(reduction</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">axes</span><span class="s0">, </span><span class="s1">trim_excess=</span><span class="s0">False, </span><span class="s1">**kwargs):</span>
    <span class="s0">if not </span><span class="s1">trim_excess </span><span class="s0">and not </span><span class="s1">all(x.shape[i] % div == </span><span class="s3">0 </span><span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">div </span><span class="s0">in </span><span class="s1">axes.items()):</span>
        <span class="s1">msg = </span><span class="s4">f&quot;Coarsening factors </span><span class="s0">{</span><span class="s1">axes</span><span class="s0">} </span><span class="s4">do not align with array shape </span><span class="s0">{</span><span class="s1">x.shape</span><span class="s0">}</span><span class="s4">.&quot;</span>
        <span class="s0">raise </span><span class="s1">ValueError(msg)</span>

    <span class="s0">if </span><span class="s1">reduction.__module__.startswith(</span><span class="s4">&quot;dask.&quot;</span><span class="s1">):</span>
        <span class="s1">reduction = getattr(np</span><span class="s0">, </span><span class="s1">reduction.__name__)</span>

    <span class="s1">new_chunks = {}</span>
    <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">div </span><span class="s0">in </span><span class="s1">axes.items():</span>
        <span class="s1">aligned = aligned_coarsen_chunks(x.chunks[i]</span><span class="s0">, </span><span class="s1">div)</span>
        <span class="s0">if </span><span class="s1">aligned != x.chunks[i]:</span>
            <span class="s1">new_chunks[i] = aligned</span>
    <span class="s0">if </span><span class="s1">new_chunks:</span>
        <span class="s1">x = x.rechunk(new_chunks)</span>

    <span class="s1">name = </span><span class="s4">&quot;coarsen-&quot; </span><span class="s1">+ tokenize(reduction</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">axes</span><span class="s0">, </span><span class="s1">trim_excess)</span>
    <span class="s1">dsk = {</span>
        <span class="s1">(name</span><span class="s0">,</span><span class="s1">)</span>
        <span class="s1">+ key[</span><span class="s3">1</span><span class="s1">:]: (apply</span><span class="s0">, </span><span class="s1">chunk.coarsen</span><span class="s0">, </span><span class="s1">[reduction</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">axes</span><span class="s0">, </span><span class="s1">trim_excess]</span><span class="s0">, </span><span class="s1">kwargs)</span>
        <span class="s0">for </span><span class="s1">key </span><span class="s0">in </span><span class="s1">flatten(x.__dask_keys__())</span>
    <span class="s1">}</span>

    <span class="s1">coarsen_dim = </span><span class="s0">lambda </span><span class="s1">dim</span><span class="s0">, </span><span class="s1">ax: int(dim // axes.get(ax</span><span class="s0">, </span><span class="s3">1</span><span class="s1">))</span>
    <span class="s1">chunks = tuple(</span>
        <span class="s1">tuple(coarsen_dim(bd</span><span class="s0">, </span><span class="s1">i) </span><span class="s0">for </span><span class="s1">bd </span><span class="s0">in </span><span class="s1">bds </span><span class="s0">if </span><span class="s1">coarsen_dim(bd</span><span class="s0">, </span><span class="s1">i) &gt; </span><span class="s3">0</span><span class="s1">)</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">bds </span><span class="s0">in </span><span class="s1">enumerate(x.chunks)</span>
    <span class="s1">)</span>

    <span class="s1">meta = reduction(np.empty((</span><span class="s3">1</span><span class="s0">,</span><span class="s1">) * x.ndim</span><span class="s0">, </span><span class="s1">dtype=x.dtype)</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s1">graph = HighLevelGraph.from_collections(name</span><span class="s0">, </span><span class="s1">dsk</span><span class="s0">, </span><span class="s1">dependencies=[x])</span>
    <span class="s0">return </span><span class="s1">Array(graph</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">chunks</span><span class="s0">, </span><span class="s1">meta=meta)</span>


<span class="s0">def </span><span class="s1">split_at_breaks(array</span><span class="s0">, </span><span class="s1">breaks</span><span class="s0">, </span><span class="s1">axis=</span><span class="s3">0</span><span class="s1">):</span>
    <span class="s5">&quot;&quot;&quot;Split an array into a list of arrays (using slices) at the given breaks 
 
    &gt;&gt;&gt; split_at_breaks(np.arange(6), [3, 5]) 
    [array([0, 1, 2]), array([3, 4]), array([5])] 
    &quot;&quot;&quot;</span>
    <span class="s1">padded_breaks = concat([[</span><span class="s0">None</span><span class="s1">]</span><span class="s0">, </span><span class="s1">breaks</span><span class="s0">, </span><span class="s1">[</span><span class="s0">None</span><span class="s1">]])</span>
    <span class="s1">slices = [slice(i</span><span class="s0">, </span><span class="s1">j) </span><span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">j </span><span class="s0">in </span><span class="s1">sliding_window(</span><span class="s3">2</span><span class="s0">, </span><span class="s1">padded_breaks)]</span>
    <span class="s1">preslice = (slice(</span><span class="s0">None</span><span class="s1">)</span><span class="s0">,</span><span class="s1">) * axis</span>
    <span class="s1">split_array = [array[preslice + (s</span><span class="s0">,</span><span class="s1">)] </span><span class="s0">for </span><span class="s1">s </span><span class="s0">in </span><span class="s1">slices]</span>
    <span class="s0">return </span><span class="s1">split_array</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">insert(arr</span><span class="s0">, </span><span class="s1">obj</span><span class="s0">, </span><span class="s1">values</span><span class="s0">, </span><span class="s1">axis):</span>
    <span class="s2"># axis is a required argument here to avoid needing to deal with the numpy</span>
    <span class="s2"># default case (which reshapes the array to make it flat)</span>
    <span class="s1">axis = validate_axis(axis</span><span class="s0">, </span><span class="s1">arr.ndim)</span>

    <span class="s0">if </span><span class="s1">isinstance(obj</span><span class="s0">, </span><span class="s1">slice):</span>
        <span class="s1">obj = np.arange(*obj.indices(arr.shape[axis]))</span>
    <span class="s1">obj = np.asarray(obj)</span>
    <span class="s1">scalar_obj = obj.ndim == </span><span class="s3">0</span>
    <span class="s0">if </span><span class="s1">scalar_obj:</span>
        <span class="s1">obj = np.atleast_1d(obj)</span>

    <span class="s1">obj = np.where(obj &lt; </span><span class="s3">0</span><span class="s0">, </span><span class="s1">obj + arr.shape[axis]</span><span class="s0">, </span><span class="s1">obj)</span>
    <span class="s0">if </span><span class="s1">(np.diff(obj) &lt; </span><span class="s3">0</span><span class="s1">).any():</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError(</span>
            <span class="s4">&quot;da.insert only implemented for monotonic ``obj`` argument&quot;</span>
        <span class="s1">)</span>

    <span class="s1">split_arr = split_at_breaks(arr</span><span class="s0">, </span><span class="s1">np.unique(obj)</span><span class="s0">, </span><span class="s1">axis)</span>

    <span class="s0">if </span><span class="s1">getattr(values</span><span class="s0">, </span><span class="s4">&quot;ndim&quot;</span><span class="s0">, </span><span class="s3">0</span><span class="s1">) == </span><span class="s3">0</span><span class="s1">:</span>
        <span class="s2"># we need to turn values into a dask array</span>
        <span class="s1">name = </span><span class="s4">&quot;values-&quot; </span><span class="s1">+ tokenize(values)</span>
        <span class="s1">dtype = getattr(values</span><span class="s0">, </span><span class="s4">&quot;dtype&quot;</span><span class="s0">, </span><span class="s1">type(values))</span>
        <span class="s1">values = Array({(name</span><span class="s0">,</span><span class="s1">): values}</span><span class="s0">, </span><span class="s1">name</span><span class="s0">, </span><span class="s1">chunks=()</span><span class="s0">, </span><span class="s1">dtype=dtype)</span>

        <span class="s1">values_shape = tuple(</span>
            <span class="s1">len(obj) </span><span class="s0">if </span><span class="s1">axis == n </span><span class="s0">else </span><span class="s1">s </span><span class="s0">for </span><span class="s1">n</span><span class="s0">, </span><span class="s1">s </span><span class="s0">in </span><span class="s1">enumerate(arr.shape)</span>
        <span class="s1">)</span>
        <span class="s1">values = broadcast_to(values</span><span class="s0">, </span><span class="s1">values_shape)</span>
    <span class="s0">elif </span><span class="s1">scalar_obj:</span>
        <span class="s1">values = values[(slice(</span><span class="s0">None</span><span class="s1">)</span><span class="s0">,</span><span class="s1">) * axis + (</span><span class="s0">None,</span><span class="s1">)]</span>

    <span class="s1">values_chunks = tuple(</span>
        <span class="s1">values_bd </span><span class="s0">if </span><span class="s1">axis == n </span><span class="s0">else </span><span class="s1">arr_bd</span>
        <span class="s0">for </span><span class="s1">n</span><span class="s0">, </span><span class="s1">(arr_bd</span><span class="s0">, </span><span class="s1">values_bd) </span><span class="s0">in </span><span class="s1">enumerate(zip(arr.chunks</span><span class="s0">, </span><span class="s1">values.chunks))</span>
    <span class="s1">)</span>
    <span class="s1">values = values.rechunk(values_chunks)</span>

    <span class="s1">counts = np.bincount(obj)[:-</span><span class="s3">1</span><span class="s1">]</span>
    <span class="s1">values_breaks = np.cumsum(counts[counts &gt; </span><span class="s3">0</span><span class="s1">])</span>
    <span class="s1">split_values = split_at_breaks(values</span><span class="s0">, </span><span class="s1">values_breaks</span><span class="s0">, </span><span class="s1">axis)</span>

    <span class="s1">interleaved = list(interleave([split_arr</span><span class="s0">, </span><span class="s1">split_values]))</span>
    <span class="s1">interleaved = [i </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">interleaved </span><span class="s0">if </span><span class="s1">i.nbytes]</span>
    <span class="s0">return </span><span class="s1">concatenate(interleaved</span><span class="s0">, </span><span class="s1">axis=axis)</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">delete(arr</span><span class="s0">, </span><span class="s1">obj</span><span class="s0">, </span><span class="s1">axis):</span>
    <span class="s5">&quot;&quot;&quot; 
    NOTE: If ``obj`` is a dask array it is implicitly computed when this function 
    is called. 
    &quot;&quot;&quot;</span>
    <span class="s2"># axis is a required argument here to avoid needing to deal with the numpy</span>
    <span class="s2"># default case (which reshapes the array to make it flat)</span>
    <span class="s1">axis = validate_axis(axis</span><span class="s0">, </span><span class="s1">arr.ndim)</span>

    <span class="s0">if </span><span class="s1">isinstance(obj</span><span class="s0">, </span><span class="s1">slice):</span>
        <span class="s1">tmp = np.arange(*obj.indices(arr.shape[axis]))</span>
        <span class="s1">obj = tmp[::-</span><span class="s3">1</span><span class="s1">] </span><span class="s0">if </span><span class="s1">obj.step </span><span class="s0">and </span><span class="s1">obj.step &lt; </span><span class="s3">0 </span><span class="s0">else </span><span class="s1">tmp</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">obj = np.asarray(obj)</span>
        <span class="s1">obj = np.where(obj &lt; </span><span class="s3">0</span><span class="s0">, </span><span class="s1">obj + arr.shape[axis]</span><span class="s0">, </span><span class="s1">obj)</span>
        <span class="s1">obj = np.unique(obj)</span>

    <span class="s1">target_arr = split_at_breaks(arr</span><span class="s0">, </span><span class="s1">obj</span><span class="s0">, </span><span class="s1">axis)</span>

    <span class="s1">target_arr = [</span>
        <span class="s1">arr[</span>
            <span class="s1">tuple(slice(</span><span class="s3">1</span><span class="s0">, None</span><span class="s1">) </span><span class="s0">if </span><span class="s1">axis == n </span><span class="s0">else </span><span class="s1">slice(</span><span class="s0">None</span><span class="s1">) </span><span class="s0">for </span><span class="s1">n </span><span class="s0">in </span><span class="s1">range(arr.ndim))</span>
        <span class="s1">]</span>
        <span class="s0">if </span><span class="s1">i != </span><span class="s3">0</span>
        <span class="s0">else </span><span class="s1">arr</span>
        <span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">arr </span><span class="s0">in </span><span class="s1">enumerate(target_arr)</span>
    <span class="s1">]</span>
    <span class="s0">return </span><span class="s1">concatenate(target_arr</span><span class="s0">, </span><span class="s1">axis=axis)</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">append(arr</span><span class="s0">, </span><span class="s1">values</span><span class="s0">, </span><span class="s1">axis=</span><span class="s0">None</span><span class="s1">):</span>
    <span class="s2"># based on numpy.append</span>
    <span class="s1">arr = asanyarray(arr)</span>
    <span class="s0">if </span><span class="s1">axis </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">arr.ndim != </span><span class="s3">1</span><span class="s1">:</span>
            <span class="s1">arr = arr.ravel()</span>
        <span class="s1">values = ravel(asanyarray(values))</span>
        <span class="s1">axis = arr.ndim - </span><span class="s3">1</span>
    <span class="s0">return </span><span class="s1">concatenate((arr</span><span class="s0">, </span><span class="s1">values)</span><span class="s0">, </span><span class="s1">axis=axis)</span>


<span class="s0">def </span><span class="s1">_average(</span>
    <span class="s1">a</span><span class="s0">, </span><span class="s1">axis=</span><span class="s0">None, </span><span class="s1">weights=</span><span class="s0">None, </span><span class="s1">returned=</span><span class="s0">False, </span><span class="s1">is_masked=</span><span class="s0">False, </span><span class="s1">keepdims=</span><span class="s0">False</span>
<span class="s1">):</span>
    <span class="s2"># This was minimally modified from numpy.average</span>
    <span class="s2"># See numpy license at https://github.com/numpy/numpy/blob/master/LICENSE.txt</span>
    <span class="s2"># or NUMPY_LICENSE.txt within this directory</span>
    <span class="s2"># Wrapper used by da.average or da.ma.average.</span>
    <span class="s1">a = asanyarray(a)</span>

    <span class="s0">if </span><span class="s1">weights </span><span class="s0">is None</span><span class="s1">:</span>
        <span class="s1">avg = a.mean(axis</span><span class="s0">, </span><span class="s1">keepdims=keepdims)</span>
        <span class="s1">scl = avg.dtype.type(a.size / avg.size)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">wgt = asanyarray(weights)</span>

        <span class="s0">if </span><span class="s1">issubclass(a.dtype.type</span><span class="s0">, </span><span class="s1">(np.integer</span><span class="s0">, </span><span class="s1">np.bool_)):</span>
            <span class="s1">result_dtype = result_type(a.dtype</span><span class="s0">, </span><span class="s1">wgt.dtype</span><span class="s0">, </span><span class="s4">&quot;f8&quot;</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">result_dtype = result_type(a.dtype</span><span class="s0">, </span><span class="s1">wgt.dtype)</span>

        <span class="s2"># Sanity checks</span>
        <span class="s0">if </span><span class="s1">a.shape != wgt.shape:</span>
            <span class="s0">if </span><span class="s1">axis </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span>
                    <span class="s4">&quot;Axis must be specified when shapes of a and weights differ.&quot;</span>
                <span class="s1">)</span>
            <span class="s0">if </span><span class="s1">wgt.ndim != </span><span class="s3">1</span><span class="s1">:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span>
                    <span class="s4">&quot;1D weights expected when shapes of a and weights differ.&quot;</span>
                <span class="s1">)</span>
            <span class="s0">if </span><span class="s1">wgt.shape[</span><span class="s3">0</span><span class="s1">] != a.shape[axis]:</span>
                <span class="s0">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">&quot;Length of weights not compatible with specified axis.&quot;</span>
                <span class="s1">)</span>

            <span class="s2"># setup wgt to broadcast along axis</span>
            <span class="s1">wgt = broadcast_to(wgt</span><span class="s0">, </span><span class="s1">(a.ndim - </span><span class="s3">1</span><span class="s1">) * (</span><span class="s3">1</span><span class="s0">,</span><span class="s1">) + wgt.shape)</span>
            <span class="s1">wgt = wgt.swapaxes(-</span><span class="s3">1</span><span class="s0">, </span><span class="s1">axis)</span>
        <span class="s0">if </span><span class="s1">is_masked:</span>
            <span class="s0">from </span><span class="s1">dask.array.ma </span><span class="s0">import </span><span class="s1">getmaskarray</span>

            <span class="s1">wgt = wgt * (~getmaskarray(a))</span>
        <span class="s1">scl = wgt.sum(axis=axis</span><span class="s0">, </span><span class="s1">dtype=result_dtype</span><span class="s0">, </span><span class="s1">keepdims=keepdims)</span>
        <span class="s1">avg = multiply(a</span><span class="s0">, </span><span class="s1">wgt</span><span class="s0">, </span><span class="s1">dtype=result_dtype).sum(axis</span><span class="s0">, </span><span class="s1">keepdims=keepdims) / scl</span>

    <span class="s0">if </span><span class="s1">returned:</span>
        <span class="s0">if </span><span class="s1">scl.shape != avg.shape:</span>
            <span class="s1">scl = broadcast_to(scl</span><span class="s0">, </span><span class="s1">avg.shape).copy()</span>
        <span class="s0">return </span><span class="s1">avg</span><span class="s0">, </span><span class="s1">scl</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">avg</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">average(a</span><span class="s0">, </span><span class="s1">axis=</span><span class="s0">None, </span><span class="s1">weights=</span><span class="s0">None, </span><span class="s1">returned=</span><span class="s0">False, </span><span class="s1">keepdims=</span><span class="s0">False</span><span class="s1">):</span>
    <span class="s0">return </span><span class="s1">_average(a</span><span class="s0">, </span><span class="s1">axis</span><span class="s0">, </span><span class="s1">weights</span><span class="s0">, </span><span class="s1">returned</span><span class="s0">, </span><span class="s1">is_masked=</span><span class="s0">False, </span><span class="s1">keepdims=keepdims)</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">tril(m</span><span class="s0">, </span><span class="s1">k=</span><span class="s3">0</span><span class="s1">):</span>
    <span class="s1">m = asarray_safe(m</span><span class="s0">, </span><span class="s1">like=m)</span>
    <span class="s1">mask = tri(</span>
        <span class="s1">*m.shape[-</span><span class="s3">2</span><span class="s1">:]</span><span class="s0">,</span>
        <span class="s1">k=k</span><span class="s0">,</span>
        <span class="s1">dtype=bool</span><span class="s0">,</span>
        <span class="s1">chunks=m.chunks[-</span><span class="s3">2</span><span class="s1">:]</span><span class="s0">,</span>
        <span class="s1">like=meta_from_array(m)</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s0">return </span><span class="s1">where(mask</span><span class="s0">, </span><span class="s1">m</span><span class="s0">, </span><span class="s1">np.zeros_like(m</span><span class="s0">, </span><span class="s1">shape=(</span><span class="s3">1</span><span class="s0">,</span><span class="s1">)))</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">triu(m</span><span class="s0">, </span><span class="s1">k=</span><span class="s3">0</span><span class="s1">):</span>
    <span class="s1">m = asarray_safe(m</span><span class="s0">, </span><span class="s1">like=m)</span>
    <span class="s1">mask = tri(</span>
        <span class="s1">*m.shape[-</span><span class="s3">2</span><span class="s1">:]</span><span class="s0">,</span>
        <span class="s1">k=k - </span><span class="s3">1</span><span class="s0">,</span>
        <span class="s1">dtype=bool</span><span class="s0">,</span>
        <span class="s1">chunks=m.chunks[-</span><span class="s3">2</span><span class="s1">:]</span><span class="s0">,</span>
        <span class="s1">like=meta_from_array(m)</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s0">return </span><span class="s1">where(mask</span><span class="s0">, </span><span class="s1">np.zeros_like(m</span><span class="s0">, </span><span class="s1">shape=(</span><span class="s3">1</span><span class="s0">,</span><span class="s1">))</span><span class="s0">, </span><span class="s1">m)</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">tril_indices(n</span><span class="s0">, </span><span class="s1">k=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">m=</span><span class="s0">None, </span><span class="s1">chunks=</span><span class="s4">&quot;auto&quot;</span><span class="s1">):</span>
    <span class="s0">return </span><span class="s1">nonzero(tri(n</span><span class="s0">, </span><span class="s1">m</span><span class="s0">, </span><span class="s1">k=k</span><span class="s0">, </span><span class="s1">dtype=bool</span><span class="s0">, </span><span class="s1">chunks=chunks))</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">tril_indices_from(arr</span><span class="s0">, </span><span class="s1">k=</span><span class="s3">0</span><span class="s1">):</span>
    <span class="s0">if </span><span class="s1">arr.ndim != </span><span class="s3">2</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;input array must be 2-d&quot;</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">tril_indices(arr.shape[-</span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">k=k</span><span class="s0">, </span><span class="s1">m=arr.shape[-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">chunks=arr.chunks)</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">triu_indices(n</span><span class="s0">, </span><span class="s1">k=</span><span class="s3">0</span><span class="s0">, </span><span class="s1">m=</span><span class="s0">None, </span><span class="s1">chunks=</span><span class="s4">&quot;auto&quot;</span><span class="s1">):</span>
    <span class="s0">return </span><span class="s1">nonzero(~tri(n</span><span class="s0">, </span><span class="s1">m</span><span class="s0">, </span><span class="s1">k=k - </span><span class="s3">1</span><span class="s0">, </span><span class="s1">dtype=bool</span><span class="s0">, </span><span class="s1">chunks=chunks))</span>


<span class="s1">@derived_from(np)</span>
<span class="s0">def </span><span class="s1">triu_indices_from(arr</span><span class="s0">, </span><span class="s1">k=</span><span class="s3">0</span><span class="s1">):</span>
    <span class="s0">if </span><span class="s1">arr.ndim != </span><span class="s3">2</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;input array must be 2-d&quot;</span><span class="s1">)</span>
    <span class="s0">return </span><span class="s1">triu_indices(arr.shape[-</span><span class="s3">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">k=k</span><span class="s0">, </span><span class="s1">m=arr.shape[-</span><span class="s3">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">chunks=arr.chunks)</span>
</pre>
</body>
</html>