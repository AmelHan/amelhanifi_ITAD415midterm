<html>
<head>
<title>test_simulation_smoothing.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_simulation_smoothing.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Tests for simulation smoothing 
 
Author: Chad Fulton 
License: Simplified-BSD 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">os</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pandas </span><span class="s2">as </span><span class="s1">pd</span>
<span class="s2">from </span><span class="s1">numpy.testing </span><span class="s2">import </span><span class="s1">assert_allclose</span><span class="s2">, </span><span class="s1">assert_equal</span>
<span class="s2">import </span><span class="s1">pytest</span>

<span class="s2">from </span><span class="s1">statsmodels </span><span class="s2">import </span><span class="s1">datasets</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.statespace </span><span class="s2">import </span><span class="s1">mlemodel</span><span class="s2">, </span><span class="s1">sarimax</span><span class="s2">, </span><span class="s1">structural</span><span class="s2">, </span><span class="s1">varmax</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.statespace.simulation_smoother </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">SIMULATION_STATE</span><span class="s2">, </span><span class="s1">SIMULATION_DISTURBANCE</span><span class="s2">, </span><span class="s1">SIMULATION_ALL)</span>

<span class="s1">current_path = os.path.dirname(os.path.abspath(__file__))</span>


<span class="s2">class </span><span class="s1">MultivariateVARKnown:</span>
    <span class="s0">&quot;&quot;&quot; 
    Tests for simulation smoothing values in a couple of special cases of 
    variates. Both computed values and KFAS values are used for comparison 
    against the simulation smoother output. 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">missing=</span><span class="s2">None, </span><span class="s1">test_against_KFAS=</span><span class="s2">True,</span>
                    <span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">cls.test_against_KFAS = test_against_KFAS</span>
        <span class="s3"># Data</span>
        <span class="s1">dta = datasets.macrodata.load_pandas().data</span>
        <span class="s1">dta.index = pd.date_range(start=</span><span class="s4">'1959-01-01'</span><span class="s2">, </span><span class="s1">end=</span><span class="s4">'2009-7-01'</span><span class="s2">,</span>
                                  <span class="s1">freq=</span><span class="s4">'QS'</span><span class="s1">)</span>
        <span class="s1">obs = np.log(dta[[</span><span class="s4">'realgdp'</span><span class="s2">, </span><span class="s4">'realcons'</span><span class="s2">, </span><span class="s4">'realinv'</span><span class="s1">]]).diff().iloc[</span><span class="s5">1</span><span class="s1">:]</span>

        <span class="s2">if </span><span class="s1">missing == </span><span class="s4">'all'</span><span class="s1">:</span>
            <span class="s1">obs.iloc[</span><span class="s5">0</span><span class="s1">:</span><span class="s5">50</span><span class="s2">, </span><span class="s1">:] = np.nan</span>
        <span class="s2">elif </span><span class="s1">missing == </span><span class="s4">'partial'</span><span class="s1">:</span>
            <span class="s1">obs.iloc[</span><span class="s5">0</span><span class="s1">:</span><span class="s5">50</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] = np.nan</span>
        <span class="s2">elif </span><span class="s1">missing == </span><span class="s4">'mixed'</span><span class="s1">:</span>
            <span class="s1">obs.iloc[</span><span class="s5">0</span><span class="s1">:</span><span class="s5">50</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] = np.nan</span>
            <span class="s1">obs.iloc[</span><span class="s5">19</span><span class="s1">:</span><span class="s5">70</span><span class="s2">, </span><span class="s5">1</span><span class="s1">] = np.nan</span>
            <span class="s1">obs.iloc[</span><span class="s5">39</span><span class="s1">:</span><span class="s5">90</span><span class="s2">, </span><span class="s5">2</span><span class="s1">] = np.nan</span>
            <span class="s1">obs.iloc[</span><span class="s5">119</span><span class="s1">:</span><span class="s5">130</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] = np.nan</span>
            <span class="s1">obs.iloc[</span><span class="s5">119</span><span class="s1">:</span><span class="s5">130</span><span class="s2">, </span><span class="s5">2</span><span class="s1">] = np.nan</span>
            <span class="s1">obs.iloc[-</span><span class="s5">10</span><span class="s1">:</span><span class="s2">, </span><span class="s1">:] = np.nan</span>

        <span class="s2">if </span><span class="s1">test_against_KFAS:</span>
            <span class="s1">obs = obs.iloc[:</span><span class="s5">9</span><span class="s1">]</span>

        <span class="s3"># Create the model</span>
        <span class="s1">mod = mlemodel.MLEModel(obs</span><span class="s2">, </span><span class="s1">k_states=</span><span class="s5">3</span><span class="s2">, </span><span class="s1">k_posdef=</span><span class="s5">3</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">mod[</span><span class="s4">'design'</span><span class="s1">] = np.eye(</span><span class="s5">3</span><span class="s1">)</span>
        <span class="s1">mod[</span><span class="s4">'obs_cov'</span><span class="s1">] = np.array([</span>
            <span class="s1">[</span><span class="s5">0.0000640649</span><span class="s2">,  </span><span class="s5">0.</span><span class="s2">,            </span><span class="s5">0.</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s5">0.</span><span class="s2">,            </span><span class="s5">0.0000572802</span><span class="s2">,  </span><span class="s5">0.</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s5">0.</span><span class="s2">,            </span><span class="s5">0.</span><span class="s2">,            </span><span class="s5">0.0017088585</span><span class="s1">]])</span>
        <span class="s1">mod[</span><span class="s4">'transition'</span><span class="s1">] = np.array([</span>
            <span class="s1">[-</span><span class="s5">0.1119908792</span><span class="s2">,  </span><span class="s5">0.8441841604</span><span class="s2">,  </span><span class="s5">0.0238725303</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s5">0.2629347724</span><span class="s2">,   </span><span class="s5">0.4996718412</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.0173023305</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[-</span><span class="s5">3.2192369082</span><span class="s2">,  </span><span class="s5">4.1536028244</span><span class="s2">,  </span><span class="s5">0.4514379215</span><span class="s1">]])</span>
        <span class="s1">mod[</span><span class="s4">'selection'</span><span class="s1">] = np.eye(</span><span class="s5">3</span><span class="s1">)</span>
        <span class="s1">mod[</span><span class="s4">'state_cov'</span><span class="s1">] = np.array([</span>
            <span class="s1">[</span><span class="s5">0.0000640649</span><span class="s2">,  </span><span class="s5">0.0000388496</span><span class="s2">,  </span><span class="s5">0.0002148769</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s5">0.0000388496</span><span class="s2">,  </span><span class="s5">0.0000572802</span><span class="s2">,  </span><span class="s5">0.000001555</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s5">0.0002148769</span><span class="s2">,  </span><span class="s5">0.000001555</span><span class="s2">,   </span><span class="s5">0.0017088585</span><span class="s1">]])</span>
        <span class="s1">mod.initialize_approximate_diffuse(</span><span class="s5">1e6</span><span class="s1">)</span>
        <span class="s1">mod.ssm.filter_univariate = </span><span class="s2">True</span>
        <span class="s1">cls.model = mod</span>
        <span class="s1">cls.results = mod.smooth([]</span><span class="s2">, </span><span class="s1">return_ssm=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s1">cls.sim = cls.model.simulation_smoother()</span>

    <span class="s2">def </span><span class="s1">test_loglike(self):</span>
        <span class="s1">assert_allclose(np.sum(self.results.llf_obs)</span><span class="s2">, </span><span class="s1">self.true_llf)</span>

    <span class="s2">def </span><span class="s1">test_simulate_0(self):</span>
        <span class="s1">n = </span><span class="s5">10</span>

        <span class="s3"># Test with all inputs as zeros</span>
        <span class="s1">measurement_shocks = np.zeros((n</span><span class="s2">, </span><span class="s1">self.model.k_endog))</span>
        <span class="s1">state_shocks = np.zeros((n</span><span class="s2">, </span><span class="s1">self.model.ssm.k_posdef))</span>
        <span class="s1">initial_state = np.zeros(self.model.k_states)</span>
        <span class="s1">obs</span><span class="s2">, </span><span class="s1">states = self.model.ssm.simulate(</span>
            <span class="s1">nsimulations=n</span><span class="s2">, </span><span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
            <span class="s1">state_shocks=state_shocks</span><span class="s2">, </span><span class="s1">initial_state=initial_state)</span>

        <span class="s1">assert_allclose(obs</span><span class="s2">, </span><span class="s1">np.zeros((n</span><span class="s2">, </span><span class="s1">self.model.k_endog)))</span>
        <span class="s1">assert_allclose(states</span><span class="s2">, </span><span class="s1">np.zeros((n</span><span class="s2">, </span><span class="s1">self.model.k_states)))</span>

    <span class="s2">def </span><span class="s1">test_simulate_1(self):</span>
        <span class="s1">n = </span><span class="s5">10</span>

        <span class="s3"># Test with np.arange / 10 measurement shocks only</span>
        <span class="s1">measurement_shocks = np.reshape(</span>
            <span class="s1">np.arange(n * self.model.k_endog) / </span><span class="s5">10.</span><span class="s2">,</span>
            <span class="s1">(n</span><span class="s2">, </span><span class="s1">self.model.k_endog))</span>
        <span class="s1">state_shocks = np.zeros((n</span><span class="s2">, </span><span class="s1">self.model.ssm.k_posdef))</span>
        <span class="s1">initial_state = np.zeros(self.model.k_states)</span>
        <span class="s1">obs</span><span class="s2">, </span><span class="s1">states = self.model.ssm.simulate(</span>
            <span class="s1">nsimulations=n</span><span class="s2">, </span><span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
            <span class="s1">state_shocks=state_shocks</span><span class="s2">, </span><span class="s1">initial_state=initial_state)</span>

        <span class="s1">assert_allclose(obs</span><span class="s2">, </span><span class="s1">np.reshape(</span>
            <span class="s1">np.arange(n * self.model.k_endog) / </span><span class="s5">10.</span><span class="s2">,</span>
            <span class="s1">(n</span><span class="s2">, </span><span class="s1">self.model.k_endog)))</span>
        <span class="s1">assert_allclose(states</span><span class="s2">, </span><span class="s1">np.zeros((n</span><span class="s2">, </span><span class="s1">self.model.k_states)))</span>

    <span class="s2">def </span><span class="s1">test_simulate_2(self):</span>
        <span class="s1">n = </span><span class="s5">10</span>
        <span class="s1">Z = self.model[</span><span class="s4">'design'</span><span class="s1">]</span>
        <span class="s1">T = self.model[</span><span class="s4">'transition'</span><span class="s1">]</span>

        <span class="s3"># Test with non-zero state shocks and initial state</span>
        <span class="s1">measurement_shocks = np.zeros((n</span><span class="s2">, </span><span class="s1">self.model.k_endog))</span>
        <span class="s1">state_shocks = np.ones((n</span><span class="s2">, </span><span class="s1">self.model.ssm.k_posdef))</span>
        <span class="s1">initial_state = np.ones(self.model.k_states) * </span><span class="s5">2.5</span>
        <span class="s1">obs</span><span class="s2">, </span><span class="s1">states = self.model.ssm.simulate(</span>
            <span class="s1">nsimulations=n</span><span class="s2">, </span><span class="s1">measurement_shocks=measurement_shocks</span><span class="s2">,</span>
            <span class="s1">state_shocks=state_shocks</span><span class="s2">, </span><span class="s1">initial_state=initial_state)</span>

        <span class="s1">desired_obs = np.zeros((n</span><span class="s2">, </span><span class="s1">self.model.k_endog))</span>
        <span class="s1">desired_state = np.zeros((n</span><span class="s2">, </span><span class="s1">self.model.k_states))</span>
        <span class="s1">desired_state[</span><span class="s5">0</span><span class="s1">] = initial_state</span>
        <span class="s1">desired_obs[</span><span class="s5">0</span><span class="s1">] = np.dot(Z</span><span class="s2">, </span><span class="s1">initial_state)</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">1</span><span class="s2">, </span><span class="s1">n):</span>
            <span class="s1">desired_state[i] = np.dot(T</span><span class="s2">, </span><span class="s1">desired_state[i-</span><span class="s5">1</span><span class="s1">]) + state_shocks[i]</span>
            <span class="s1">desired_obs[i] = np.dot(Z</span><span class="s2">, </span><span class="s1">desired_state[i])</span>

        <span class="s1">assert_allclose(obs</span><span class="s2">, </span><span class="s1">desired_obs)</span>
        <span class="s1">assert_allclose(states</span><span class="s2">, </span><span class="s1">desired_state)</span>

    <span class="s2">def </span><span class="s1">test_simulation_smoothing_0(self):</span>
        <span class="s3"># Simulation smoothing when setting all variates to zeros</span>
        <span class="s3"># In this case:</span>
        <span class="s3"># - unconditional disturbances are zero, because they are simply</span>
        <span class="s3">#   transformed to have the appropriate variance matrix, but keep the</span>
        <span class="s3">#   same mean - of zero</span>
        <span class="s3"># - generated states are zeros, because initial state is</span>
        <span class="s3">#   zeros and all state disturbances are zeros</span>
        <span class="s3"># - generated observations are zeros, because states are zeros and all</span>
        <span class="s3">#    measurement disturbances are zeros</span>
        <span class="s3"># - The simulated state is equal to the smoothed state from the</span>
        <span class="s3">#   original model, because</span>
        <span class="s3">#   simulated state = (generated state - smoothed generated state +</span>
        <span class="s3">#                      smoothed state)</span>
        <span class="s3">#   and here generated state = smoothed generated state = 0</span>
        <span class="s3"># - The simulated measurement disturbance is equal to the smoothed</span>
        <span class="s3">#   measurement disturbance for very similar reasons, because</span>
        <span class="s3">#   simulated measurement disturbance = (</span>
        <span class="s3">#       generated measurement disturbance -</span>
        <span class="s3">#       smoothed generated measurement disturbance +</span>
        <span class="s3">#       smoothed measurement disturbance)</span>
        <span class="s3">#   and here generated measurement disturbance and</span>
        <span class="s3">#   smoothed generated measurement disturbance are zero.</span>
        <span class="s3"># - The simulated state disturbance is equal to the smoothed</span>
        <span class="s3">#   state disturbance for exactly the same reason as above.</span>
        <span class="s1">sim = self.sim</span>
        <span class="s1">Z = self.model[</span><span class="s4">'design'</span><span class="s1">]</span>

        <span class="s1">nobs = self.model.nobs</span>
        <span class="s1">k_endog = self.model.k_endog</span>
        <span class="s1">k_posdef = self.model.ssm.k_posdef</span>
        <span class="s1">k_states = self.model.k_states</span>

        <span class="s3"># Test against known quantities (see above for description)</span>
        <span class="s1">sim.simulate(measurement_disturbance_variates=np.zeros(nobs * k_endog)</span><span class="s2">,</span>
                     <span class="s1">state_disturbance_variates=np.zeros(nobs * k_posdef)</span><span class="s2">,</span>
                     <span class="s1">initial_state_variates=np.zeros(k_states))</span>
        <span class="s1">assert_allclose(sim.generated_measurement_disturbance</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(sim.generated_state_disturbance</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(sim.generated_state</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(sim.generated_obs</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(sim.simulated_state</span><span class="s2">, </span><span class="s1">self.results.smoothed_state)</span>
        <span class="s2">if not </span><span class="s1">self.model.ssm.filter_collapsed:</span>
            <span class="s1">assert_allclose(sim.simulated_measurement_disturbance</span><span class="s2">,</span>
                            <span class="s1">self.results.smoothed_measurement_disturbance)</span>
        <span class="s1">assert_allclose(sim.simulated_state_disturbance</span><span class="s2">,</span>
                        <span class="s1">self.results.smoothed_state_disturbance)</span>

        <span class="s3"># Test against R package KFAS values</span>
        <span class="s2">if </span><span class="s1">self.test_against_KFAS:</span>
            <span class="s1">path = os.path.join(current_path</span><span class="s2">, </span><span class="s4">'results'</span><span class="s2">,</span>
                                <span class="s4">'results_simulation_smoothing0.csv'</span><span class="s1">)</span>
            <span class="s1">true = pd.read_csv(path)</span>

            <span class="s1">assert_allclose(sim.simulated_state</span><span class="s2">,</span>
                            <span class="s1">true[[</span><span class="s4">'state1'</span><span class="s2">, </span><span class="s4">'state2'</span><span class="s2">, </span><span class="s4">'state3'</span><span class="s1">]].T</span><span class="s2">,</span>
                            <span class="s1">atol=</span><span class="s5">1e-7</span><span class="s1">)</span>
            <span class="s1">assert_allclose(sim.simulated_measurement_disturbance</span><span class="s2">,</span>
                            <span class="s1">true[[</span><span class="s4">'eps1'</span><span class="s2">, </span><span class="s4">'eps2'</span><span class="s2">, </span><span class="s4">'eps3'</span><span class="s1">]].T</span><span class="s2">,</span>
                            <span class="s1">atol=</span><span class="s5">1e-7</span><span class="s1">)</span>
            <span class="s1">assert_allclose(sim.simulated_state_disturbance</span><span class="s2">,</span>
                            <span class="s1">true[[</span><span class="s4">'eta1'</span><span class="s2">, </span><span class="s4">'eta2'</span><span class="s2">, </span><span class="s4">'eta3'</span><span class="s1">]].T</span><span class="s2">,</span>
                            <span class="s1">atol=</span><span class="s5">1e-7</span><span class="s1">)</span>
            <span class="s1">signals = np.zeros((</span><span class="s5">3</span><span class="s2">, </span><span class="s1">self.model.nobs))</span>
            <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">range(self.model.nobs):</span>
                <span class="s1">signals[:</span><span class="s2">, </span><span class="s1">t] = np.dot(Z</span><span class="s2">, </span><span class="s1">sim.simulated_state[:</span><span class="s2">, </span><span class="s1">t])</span>
            <span class="s1">assert_allclose(signals</span><span class="s2">, </span><span class="s1">true[[</span><span class="s4">'signal1'</span><span class="s2">, </span><span class="s4">'signal2'</span><span class="s2">, </span><span class="s4">'signal3'</span><span class="s1">]].T</span><span class="s2">,</span>
                            <span class="s1">atol=</span><span class="s5">1e-7</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_simulation_smoothing_1(self):</span>
        <span class="s3"># Test with measurement disturbance as np.arange / 10., all other</span>
        <span class="s3"># disturbances are zeros</span>
        <span class="s1">sim = self.sim</span>

        <span class="s1">Z = self.model[</span><span class="s4">'design'</span><span class="s1">]</span>

        <span class="s1">nobs = self.model.nobs</span>
        <span class="s1">k_endog = self.model.k_endog</span>
        <span class="s1">k_posdef = self.model.ssm.k_posdef</span>
        <span class="s1">k_states = self.model.k_states</span>

        <span class="s3"># Construct the variates</span>
        <span class="s1">measurement_disturbance_variates = np.reshape(</span>
            <span class="s1">np.arange(nobs * k_endog) / </span><span class="s5">10.</span><span class="s2">, </span><span class="s1">(nobs</span><span class="s2">, </span><span class="s1">k_endog))</span>
        <span class="s1">state_disturbance_variates = np.zeros(nobs * k_posdef)</span>

        <span class="s3"># Compute some additional known quantities</span>
        <span class="s1">generated_measurement_disturbance = np.zeros(</span>
            <span class="s1">measurement_disturbance_variates.shape)</span>
        <span class="s1">chol = np.linalg.cholesky(self.model[</span><span class="s4">'obs_cov'</span><span class="s1">])</span>
        <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">range(self.model.nobs):</span>
            <span class="s1">generated_measurement_disturbance[t] = np.dot(</span>
                <span class="s1">chol</span><span class="s2">, </span><span class="s1">measurement_disturbance_variates[t])</span>
        <span class="s1">y = generated_measurement_disturbance.copy()</span>
        <span class="s1">y[np.isnan(self.model.endog)] = np.nan</span>

        <span class="s1">generated_model = mlemodel.MLEModel(</span>
            <span class="s1">y</span><span class="s2">, </span><span class="s1">k_states=k_states</span><span class="s2">, </span><span class="s1">k_posdef=k_posdef)</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">[</span><span class="s4">'design'</span><span class="s2">, </span><span class="s4">'obs_cov'</span><span class="s2">, </span><span class="s4">'transition'</span><span class="s2">,</span>
                     <span class="s4">'selection'</span><span class="s2">, </span><span class="s4">'state_cov'</span><span class="s1">]:</span>
            <span class="s1">generated_model[name] = self.model[name]</span>

        <span class="s1">generated_model.initialize_approximate_diffuse(</span><span class="s5">1e6</span><span class="s1">)</span>
        <span class="s1">generated_model.ssm.filter_univariate = </span><span class="s2">True</span>
        <span class="s1">generated_res = generated_model.ssm.smooth()</span>
        <span class="s1">simulated_state = (</span>
            <span class="s5">0 </span><span class="s1">- generated_res.smoothed_state + self.results.smoothed_state)</span>
        <span class="s2">if not </span><span class="s1">self.model.ssm.filter_collapsed:</span>
            <span class="s1">simulated_measurement_disturbance = (</span>
                <span class="s1">generated_measurement_disturbance.T -</span>
                <span class="s1">generated_res.smoothed_measurement_disturbance +</span>
                <span class="s1">self.results.smoothed_measurement_disturbance)</span>
        <span class="s1">simulated_state_disturbance = (</span>
            <span class="s5">0 </span><span class="s1">- generated_res.smoothed_state_disturbance +</span>
            <span class="s1">self.results.smoothed_state_disturbance)</span>

        <span class="s3"># Test against known values</span>
        <span class="s1">sim.simulate(measurement_disturbance_variates=(</span>
                        <span class="s1">measurement_disturbance_variates)</span><span class="s2">,</span>
                     <span class="s1">state_disturbance_variates=state_disturbance_variates</span><span class="s2">,</span>
                     <span class="s1">initial_state_variates=np.zeros(k_states))</span>
        <span class="s1">assert_allclose(sim.generated_measurement_disturbance</span><span class="s2">,</span>
                        <span class="s1">generated_measurement_disturbance)</span>
        <span class="s1">assert_allclose(sim.generated_state_disturbance</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(sim.generated_state</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">assert_allclose(sim.generated_obs</span><span class="s2">,</span>
                        <span class="s1">generated_measurement_disturbance.T)</span>
        <span class="s1">assert_allclose(sim.simulated_state</span><span class="s2">, </span><span class="s1">simulated_state)</span>
        <span class="s2">if not </span><span class="s1">self.model.ssm.filter_collapsed:</span>
            <span class="s1">assert_allclose(sim.simulated_measurement_disturbance</span><span class="s2">,</span>
                            <span class="s1">simulated_measurement_disturbance)</span>
        <span class="s1">assert_allclose(sim.simulated_state_disturbance</span><span class="s2">,</span>
                        <span class="s1">simulated_state_disturbance)</span>

        <span class="s3"># Test against R package KFAS values</span>
        <span class="s2">if </span><span class="s1">self.test_against_KFAS:</span>
            <span class="s1">path = os.path.join(current_path</span><span class="s2">, </span><span class="s4">'results'</span><span class="s2">,</span>
                                <span class="s4">'results_simulation_smoothing1.csv'</span><span class="s1">)</span>
            <span class="s1">true = pd.read_csv(path)</span>
            <span class="s1">assert_allclose(sim.simulated_state</span><span class="s2">,</span>
                            <span class="s1">true[[</span><span class="s4">'state1'</span><span class="s2">, </span><span class="s4">'state2'</span><span class="s2">, </span><span class="s4">'state3'</span><span class="s1">]].T</span><span class="s2">,</span>
                            <span class="s1">atol=</span><span class="s5">1e-7</span><span class="s1">)</span>
            <span class="s1">assert_allclose(sim.simulated_measurement_disturbance</span><span class="s2">,</span>
                            <span class="s1">true[[</span><span class="s4">'eps1'</span><span class="s2">, </span><span class="s4">'eps2'</span><span class="s2">, </span><span class="s4">'eps3'</span><span class="s1">]].T</span><span class="s2">,</span>
                            <span class="s1">atol=</span><span class="s5">1e-7</span><span class="s1">)</span>
            <span class="s1">assert_allclose(sim.simulated_state_disturbance</span><span class="s2">,</span>
                            <span class="s1">true[[</span><span class="s4">'eta1'</span><span class="s2">, </span><span class="s4">'eta2'</span><span class="s2">, </span><span class="s4">'eta3'</span><span class="s1">]].T</span><span class="s2">,</span>
                            <span class="s1">atol=</span><span class="s5">1e-7</span><span class="s1">)</span>
            <span class="s1">signals = np.zeros((</span><span class="s5">3</span><span class="s2">, </span><span class="s1">self.model.nobs))</span>
            <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">range(self.model.nobs):</span>
                <span class="s1">signals[:</span><span class="s2">, </span><span class="s1">t] = np.dot(Z</span><span class="s2">, </span><span class="s1">sim.simulated_state[:</span><span class="s2">, </span><span class="s1">t])</span>
            <span class="s1">assert_allclose(signals</span><span class="s2">, </span><span class="s1">true[[</span><span class="s4">'signal1'</span><span class="s2">, </span><span class="s4">'signal2'</span><span class="s2">, </span><span class="s4">'signal3'</span><span class="s1">]].T</span><span class="s2">,</span>
                            <span class="s1">atol=</span><span class="s5">1e-7</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_simulation_smoothing_2(self):</span>
        <span class="s3"># Test with measurement and state disturbances as np.arange / 10.,</span>
        <span class="s3"># initial state variates are zeros.</span>
        <span class="s1">sim = self.sim</span>

        <span class="s1">Z = self.model[</span><span class="s4">'design'</span><span class="s1">]</span>
        <span class="s1">T = self.model[</span><span class="s4">'transition'</span><span class="s1">]</span>

        <span class="s1">nobs = self.model.nobs</span>
        <span class="s1">k_endog = self.model.k_endog</span>
        <span class="s1">k_posdef = self.model.ssm.k_posdef</span>
        <span class="s1">k_states = self.model.k_states</span>

        <span class="s3"># Construct the variates</span>
        <span class="s1">measurement_disturbance_variates = np.reshape(</span>
            <span class="s1">np.arange(nobs * k_endog) / </span><span class="s5">10.</span><span class="s2">, </span><span class="s1">(nobs</span><span class="s2">, </span><span class="s1">k_endog))</span>
        <span class="s1">state_disturbance_variates = np.reshape(</span>
            <span class="s1">np.arange(nobs * k_posdef) / </span><span class="s5">10.</span><span class="s2">, </span><span class="s1">(nobs</span><span class="s2">, </span><span class="s1">k_posdef))</span>
        <span class="s1">initial_state_variates = np.zeros(k_states)</span>

        <span class="s3"># Compute some additional known quantities</span>
        <span class="s1">generated_measurement_disturbance = np.zeros(</span>
            <span class="s1">measurement_disturbance_variates.shape)</span>
        <span class="s1">chol = np.linalg.cholesky(self.model[</span><span class="s4">'obs_cov'</span><span class="s1">])</span>
        <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">range(self.model.nobs):</span>
            <span class="s1">generated_measurement_disturbance[t] = np.dot(</span>
                <span class="s1">chol</span><span class="s2">, </span><span class="s1">measurement_disturbance_variates[t])</span>

        <span class="s1">generated_state_disturbance = np.zeros(</span>
            <span class="s1">state_disturbance_variates.shape)</span>
        <span class="s1">chol = np.linalg.cholesky(self.model[</span><span class="s4">'state_cov'</span><span class="s1">])</span>
        <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">range(self.model.nobs):</span>
            <span class="s1">generated_state_disturbance[t] = np.dot(</span>
                <span class="s1">chol</span><span class="s2">, </span><span class="s1">state_disturbance_variates[t])</span>

        <span class="s1">generated_obs = np.zeros((self.model.k_endog</span><span class="s2">, </span><span class="s1">self.model.nobs))</span>
        <span class="s1">generated_state = np.zeros((self.model.k_states</span><span class="s2">, </span><span class="s1">self.model.nobs+</span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">chol = np.linalg.cholesky(self.results.initial_state_cov)</span>
        <span class="s1">generated_state[:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] = (</span>
            <span class="s1">self.results.initial_state + np.dot(chol</span><span class="s2">, </span><span class="s1">initial_state_variates))</span>
        <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">range(self.model.nobs):</span>
            <span class="s1">generated_state[:</span><span class="s2">, </span><span class="s1">t+</span><span class="s5">1</span><span class="s1">] = (np.dot(T</span><span class="s2">, </span><span class="s1">generated_state[:</span><span class="s2">, </span><span class="s1">t]) +</span>
                                       <span class="s1">generated_state_disturbance.T[:</span><span class="s2">, </span><span class="s1">t])</span>
            <span class="s1">generated_obs[:</span><span class="s2">, </span><span class="s1">t] = (np.dot(Z</span><span class="s2">, </span><span class="s1">generated_state[:</span><span class="s2">, </span><span class="s1">t]) +</span>
                                   <span class="s1">generated_measurement_disturbance.T[:</span><span class="s2">, </span><span class="s1">t])</span>
        <span class="s1">y = generated_obs.copy().T</span>
        <span class="s1">y[np.isnan(self.model.endog)] = np.nan</span>

        <span class="s1">generated_model = mlemodel.MLEModel(y</span><span class="s2">, </span><span class="s1">k_states=k_states</span><span class="s2">,</span>
                                            <span class="s1">k_posdef=k_posdef)</span>
        <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">[</span><span class="s4">'design'</span><span class="s2">, </span><span class="s4">'obs_cov'</span><span class="s2">, </span><span class="s4">'transition'</span><span class="s2">,</span>
                     <span class="s4">'selection'</span><span class="s2">, </span><span class="s4">'state_cov'</span><span class="s1">]:</span>
            <span class="s1">generated_model[name] = self.model[name]</span>

        <span class="s1">generated_model.initialize_approximate_diffuse(</span><span class="s5">1e6</span><span class="s1">)</span>
        <span class="s1">generated_model.ssm.filter_univariate = </span><span class="s2">True</span>
        <span class="s1">generated_res = generated_model.ssm.smooth()</span>
        <span class="s1">simulated_state = (</span>
            <span class="s1">generated_state[:</span><span class="s2">, </span><span class="s1">:-</span><span class="s5">1</span><span class="s1">] - generated_res.smoothed_state +</span>
            <span class="s1">self.results.smoothed_state)</span>
        <span class="s2">if not </span><span class="s1">self.model.ssm.filter_collapsed:</span>
            <span class="s1">simulated_measurement_disturbance = (</span>
                <span class="s1">generated_measurement_disturbance.T -</span>
                <span class="s1">generated_res.smoothed_measurement_disturbance +</span>
                <span class="s1">self.results.smoothed_measurement_disturbance)</span>
        <span class="s1">simulated_state_disturbance = (</span>
            <span class="s1">generated_state_disturbance.T -</span>
            <span class="s1">generated_res.smoothed_state_disturbance +</span>
            <span class="s1">self.results.smoothed_state_disturbance)</span>

        <span class="s3"># Test against known values</span>
        <span class="s1">sim.simulate(measurement_disturbance_variates=(</span>
                        <span class="s1">measurement_disturbance_variates)</span><span class="s2">,</span>
                     <span class="s1">state_disturbance_variates=state_disturbance_variates</span><span class="s2">,</span>
                     <span class="s1">initial_state_variates=np.zeros(k_states))</span>

        <span class="s1">assert_allclose(sim.generated_measurement_disturbance</span><span class="s2">,</span>
                        <span class="s1">generated_measurement_disturbance)</span>
        <span class="s1">assert_allclose(sim.generated_state_disturbance</span><span class="s2">,</span>
                        <span class="s1">generated_state_disturbance)</span>
        <span class="s1">assert_allclose(sim.generated_state</span><span class="s2">, </span><span class="s1">generated_state)</span>
        <span class="s1">assert_allclose(sim.generated_obs</span><span class="s2">, </span><span class="s1">generated_obs)</span>
        <span class="s1">assert_allclose(sim.simulated_state</span><span class="s2">, </span><span class="s1">simulated_state</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-7</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">self.model.ssm.filter_collapsed:</span>
            <span class="s1">assert_allclose(sim.simulated_measurement_disturbance.T</span><span class="s2">,</span>
                            <span class="s1">simulated_measurement_disturbance.T)</span>
        <span class="s1">assert_allclose(sim.simulated_state_disturbance</span><span class="s2">,</span>
                        <span class="s1">simulated_state_disturbance)</span>

        <span class="s3"># Test against R package KFAS values</span>
        <span class="s2">if </span><span class="s1">self.test_against_KFAS:</span>
            <span class="s1">path = os.path.join(current_path</span><span class="s2">, </span><span class="s4">'results'</span><span class="s2">,</span>
                                <span class="s4">'results_simulation_smoothing2.csv'</span><span class="s1">)</span>
            <span class="s1">true = pd.read_csv(path)</span>
            <span class="s1">assert_allclose(sim.simulated_state.T</span><span class="s2">,</span>
                            <span class="s1">true[[</span><span class="s4">'state1'</span><span class="s2">, </span><span class="s4">'state2'</span><span class="s2">, </span><span class="s4">'state3'</span><span class="s1">]]</span><span class="s2">,</span>
                            <span class="s1">atol=</span><span class="s5">1e-7</span><span class="s1">)</span>
            <span class="s1">assert_allclose(sim.simulated_measurement_disturbance</span><span class="s2">,</span>
                            <span class="s1">true[[</span><span class="s4">'eps1'</span><span class="s2">, </span><span class="s4">'eps2'</span><span class="s2">, </span><span class="s4">'eps3'</span><span class="s1">]].T</span><span class="s2">,</span>
                            <span class="s1">atol=</span><span class="s5">1e-7</span><span class="s1">)</span>
            <span class="s1">assert_allclose(sim.simulated_state_disturbance</span><span class="s2">,</span>
                            <span class="s1">true[[</span><span class="s4">'eta1'</span><span class="s2">, </span><span class="s4">'eta2'</span><span class="s2">, </span><span class="s4">'eta3'</span><span class="s1">]].T</span><span class="s2">,</span>
                            <span class="s1">atol=</span><span class="s5">1e-7</span><span class="s1">)</span>
            <span class="s1">signals = np.zeros((</span><span class="s5">3</span><span class="s2">, </span><span class="s1">self.model.nobs))</span>
            <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">range(self.model.nobs):</span>
                <span class="s1">signals[:</span><span class="s2">, </span><span class="s1">t] = np.dot(Z</span><span class="s2">, </span><span class="s1">sim.simulated_state[:</span><span class="s2">, </span><span class="s1">t])</span>
            <span class="s1">assert_allclose(signals</span><span class="s2">, </span><span class="s1">true[[</span><span class="s4">'signal1'</span><span class="s2">, </span><span class="s4">'signal2'</span><span class="s2">, </span><span class="s4">'signal3'</span><span class="s1">]].T</span><span class="s2">,</span>
                            <span class="s1">atol=</span><span class="s5">1e-7</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestMultivariateVARKnown(MultivariateVARKnown):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super(TestMultivariateVARKnown</span><span class="s2">, </span><span class="s1">cls).setup_class()</span>
        <span class="s1">cls.true_llf = </span><span class="s5">39.01246166</span>


<span class="s2">class </span><span class="s1">TestMultivariateVARKnownMissingAll(MultivariateVARKnown):</span>
    <span class="s0">&quot;&quot;&quot; 
    Notes 
    ----- 
    Cannot test against KFAS because they have a different behavior for 
    missing entries. When an entry is missing, KFAS does not draw a simulation 
    smoothed value for that entry, whereas we draw from the unconditional 
    distribution. It appears there is nothing to definitively recommend one 
    approach over the other, but it makes it difficult to line up the variates 
    correctly in order to replicate results. 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super(TestMultivariateVARKnownMissingAll</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">missing=</span><span class="s4">'all'</span><span class="s2">, </span><span class="s1">test_against_KFAS=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">cls.true_llf = </span><span class="s5">1305.739288</span>


<span class="s2">class </span><span class="s1">TestMultivariateVARKnownMissingPartial(MultivariateVARKnown):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super(TestMultivariateVARKnownMissingPartial</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">missing=</span><span class="s4">'partial'</span><span class="s2">, </span><span class="s1">test_against_KFAS=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">cls.true_llf = </span><span class="s5">1518.449598</span>


<span class="s2">class </span><span class="s1">TestMultivariateVARKnownMissingMixed(MultivariateVARKnown):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s1">super(TestMultivariateVARKnownMissingMixed</span><span class="s2">, </span><span class="s1">cls).setup_class(</span>
            <span class="s1">missing=</span><span class="s4">'mixed'</span><span class="s2">, </span><span class="s1">test_against_KFAS=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">cls.true_llf = </span><span class="s5">1117.265303</span>


<span class="s2">class </span><span class="s1">TestDFM(TestMultivariateVARKnown):</span>
    <span class="s1">test_against_KFAS = </span><span class="s2">False</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">which=</span><span class="s4">'none'</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s3"># Data</span>
        <span class="s1">dta = datasets.macrodata.load_pandas().data</span>
        <span class="s1">dta.index = pd.date_range(start=</span><span class="s4">'1959-01-01'</span><span class="s2">, </span><span class="s1">end=</span><span class="s4">'2009-7-01'</span><span class="s2">,</span>
                                  <span class="s1">freq=</span><span class="s4">'QS'</span><span class="s1">)</span>
        <span class="s1">levels = dta[[</span><span class="s4">'realgdp'</span><span class="s2">, </span><span class="s4">'realcons'</span><span class="s2">, </span><span class="s4">'realinv'</span><span class="s1">]]</span>
        <span class="s1">obs = np.log(levels).diff().iloc[</span><span class="s5">1</span><span class="s1">:] * </span><span class="s5">400</span>

        <span class="s2">if </span><span class="s1">which == </span><span class="s4">'all'</span><span class="s1">:</span>
            <span class="s1">obs.iloc[:</span><span class="s5">50</span><span class="s2">, </span><span class="s1">:] = np.nan</span>
            <span class="s1">obs.iloc[</span><span class="s5">119</span><span class="s1">:</span><span class="s5">130</span><span class="s2">, </span><span class="s1">:] = np.nan</span>
        <span class="s2">elif </span><span class="s1">which == </span><span class="s4">'partial'</span><span class="s1">:</span>
            <span class="s1">obs.iloc[</span><span class="s5">0</span><span class="s1">:</span><span class="s5">50</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] = np.nan</span>
            <span class="s1">obs.iloc[</span><span class="s5">119</span><span class="s1">:</span><span class="s5">130</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] = np.nan</span>
        <span class="s2">elif </span><span class="s1">which == </span><span class="s4">'mixed'</span><span class="s1">:</span>
            <span class="s1">obs.iloc[</span><span class="s5">0</span><span class="s1">:</span><span class="s5">50</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] = np.nan</span>
            <span class="s1">obs.iloc[</span><span class="s5">19</span><span class="s1">:</span><span class="s5">70</span><span class="s2">, </span><span class="s5">1</span><span class="s1">] = np.nan</span>
            <span class="s1">obs.iloc[</span><span class="s5">39</span><span class="s1">:</span><span class="s5">90</span><span class="s2">, </span><span class="s5">2</span><span class="s1">] = np.nan</span>
            <span class="s1">obs.iloc[</span><span class="s5">119</span><span class="s1">:</span><span class="s5">130</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] = np.nan</span>
            <span class="s1">obs.iloc[</span><span class="s5">119</span><span class="s1">:</span><span class="s5">130</span><span class="s2">, </span><span class="s5">2</span><span class="s1">] = np.nan</span>

        <span class="s3"># Create the model with typical state space</span>
        <span class="s1">mod = mlemodel.MLEModel(obs</span><span class="s2">, </span><span class="s1">k_states=</span><span class="s5">2</span><span class="s2">, </span><span class="s1">k_posdef=</span><span class="s5">2</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">mod[</span><span class="s4">'design'</span><span class="s1">] = np.array([[-</span><span class="s5">32.47143586</span><span class="s2">, </span><span class="s5">17.33779024</span><span class="s1">]</span><span class="s2">,</span>
                                  <span class="s1">[-</span><span class="s5">7.40264169</span><span class="s2">, </span><span class="s5">1.69279859</span><span class="s1">]</span><span class="s2">,</span>
                                  <span class="s1">[-</span><span class="s5">209.04702853</span><span class="s2">, </span><span class="s5">125.2879374</span><span class="s1">]])</span>
        <span class="s1">mod[</span><span class="s4">'obs_cov'</span><span class="s1">] = np.diag(</span>
            <span class="s1">np.array([</span><span class="s5">0.0622668</span><span class="s2">, </span><span class="s5">1.95666886</span><span class="s2">, </span><span class="s5">58.37473642</span><span class="s1">]))</span>
        <span class="s1">mod[</span><span class="s4">'transition'</span><span class="s1">] = np.array([[</span><span class="s5">0.29935707</span><span class="s2">, </span><span class="s5">0.33289005</span><span class="s1">]</span><span class="s2">,</span>
                                      <span class="s1">[-</span><span class="s5">0.7639868</span><span class="s2">, </span><span class="s5">1.2844237</span><span class="s1">]])</span>
        <span class="s1">mod[</span><span class="s4">'selection'</span><span class="s1">] = np.eye(</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">mod[</span><span class="s4">'state_cov'</span><span class="s1">] = np.array([[</span><span class="s5">1.2</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.25</span><span class="s1">]</span><span class="s2">,</span>
                                     <span class="s1">[-</span><span class="s5">0.25</span><span class="s2">, </span><span class="s5">1.1</span><span class="s1">]])</span>
        <span class="s1">mod.initialize_approximate_diffuse(</span><span class="s5">1e6</span><span class="s1">)</span>
        <span class="s1">mod.ssm.filter_univariate = </span><span class="s2">True</span>
        <span class="s1">mod.ssm.filter_collapsed = </span><span class="s2">True</span>
        <span class="s1">cls.model = mod</span>
        <span class="s1">cls.results = mod.smooth([]</span><span class="s2">, </span><span class="s1">return_ssm=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s1">cls.sim = cls.model.simulation_smoother()</span>

    <span class="s2">def </span><span class="s1">test_loglike(self):</span>
        <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">MultivariateVAR:</span>
    <span class="s0">&quot;&quot;&quot; 
    More generic tests for simulation smoothing; use actual N(0,1) variates 
    &quot;&quot;&quot;</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls</span><span class="s2">, </span><span class="s1">missing=</span><span class="s4">'none'</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs):</span>
        <span class="s3"># Data</span>
        <span class="s1">dta = datasets.macrodata.load_pandas().data</span>
        <span class="s1">dta.index = pd.date_range(start=</span><span class="s4">'1959-01-01'</span><span class="s2">, </span><span class="s1">end=</span><span class="s4">'2009-7-01'</span><span class="s2">,</span>
                                  <span class="s1">freq=</span><span class="s4">'QS'</span><span class="s1">)</span>
        <span class="s1">obs = np.log(dta[[</span><span class="s4">'realgdp'</span><span class="s2">, </span><span class="s4">'realcons'</span><span class="s2">, </span><span class="s4">'realinv'</span><span class="s1">]]).diff().iloc[</span><span class="s5">1</span><span class="s1">:]</span>

        <span class="s2">if </span><span class="s1">missing == </span><span class="s4">'all'</span><span class="s1">:</span>
            <span class="s1">obs.iloc[</span><span class="s5">0</span><span class="s1">:</span><span class="s5">50</span><span class="s2">, </span><span class="s1">:] = np.nan</span>
        <span class="s2">elif </span><span class="s1">missing == </span><span class="s4">'partial'</span><span class="s1">:</span>
            <span class="s1">obs.iloc[</span><span class="s5">0</span><span class="s1">:</span><span class="s5">50</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] = np.nan</span>
        <span class="s2">elif </span><span class="s1">missing == </span><span class="s4">'mixed'</span><span class="s1">:</span>
            <span class="s1">obs.iloc[</span><span class="s5">0</span><span class="s1">:</span><span class="s5">50</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] = np.nan</span>
            <span class="s1">obs.iloc[</span><span class="s5">19</span><span class="s1">:</span><span class="s5">70</span><span class="s2">, </span><span class="s5">1</span><span class="s1">] = np.nan</span>
            <span class="s1">obs.iloc[</span><span class="s5">39</span><span class="s1">:</span><span class="s5">90</span><span class="s2">, </span><span class="s5">2</span><span class="s1">] = np.nan</span>
            <span class="s1">obs.iloc[</span><span class="s5">119</span><span class="s1">:</span><span class="s5">130</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] = np.nan</span>
            <span class="s1">obs.iloc[</span><span class="s5">119</span><span class="s1">:</span><span class="s5">130</span><span class="s2">, </span><span class="s5">2</span><span class="s1">] = np.nan</span>
            <span class="s1">obs.iloc[-</span><span class="s5">10</span><span class="s1">:</span><span class="s2">, </span><span class="s1">:] = np.nan</span>

        <span class="s3"># Create the model</span>
        <span class="s1">mod = mlemodel.MLEModel(obs</span><span class="s2">, </span><span class="s1">k_states=</span><span class="s5">3</span><span class="s2">, </span><span class="s1">k_posdef=</span><span class="s5">3</span><span class="s2">, </span><span class="s1">**kwargs)</span>
        <span class="s1">mod[</span><span class="s4">'design'</span><span class="s1">] = np.eye(</span><span class="s5">3</span><span class="s1">)</span>
        <span class="s1">mod[</span><span class="s4">'obs_cov'</span><span class="s1">] = np.array([</span>
            <span class="s1">[</span><span class="s5">0.0000640649</span><span class="s2">,  </span><span class="s5">0.</span><span class="s2">,            </span><span class="s5">0.</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s5">0.</span><span class="s2">,            </span><span class="s5">0.0000572802</span><span class="s2">,  </span><span class="s5">0.</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s5">0.</span><span class="s2">,            </span><span class="s5">0.</span><span class="s2">,            </span><span class="s5">0.0017088585</span><span class="s1">]])</span>
        <span class="s1">mod[</span><span class="s4">'transition'</span><span class="s1">] = np.array([</span>
            <span class="s1">[-</span><span class="s5">0.1119908792</span><span class="s2">,  </span><span class="s5">0.8441841604</span><span class="s2">,  </span><span class="s5">0.0238725303</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s5">0.2629347724</span><span class="s2">,   </span><span class="s5">0.4996718412</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.0173023305</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[-</span><span class="s5">3.2192369082</span><span class="s2">,  </span><span class="s5">4.1536028244</span><span class="s2">,  </span><span class="s5">0.4514379215</span><span class="s1">]])</span>
        <span class="s1">mod[</span><span class="s4">'selection'</span><span class="s1">] = np.eye(</span><span class="s5">3</span><span class="s1">)</span>
        <span class="s1">mod[</span><span class="s4">'state_cov'</span><span class="s1">] = np.array([</span>
            <span class="s1">[</span><span class="s5">0.0000640649</span><span class="s2">,  </span><span class="s5">0.0000388496</span><span class="s2">,  </span><span class="s5">0.0002148769</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s5">0.0000388496</span><span class="s2">,  </span><span class="s5">0.0000572802</span><span class="s2">,  </span><span class="s5">0.000001555</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s5">0.0002148769</span><span class="s2">,  </span><span class="s5">0.000001555</span><span class="s2">,   </span><span class="s5">0.0017088585</span><span class="s1">]])</span>
        <span class="s1">mod.initialize_approximate_diffuse(</span><span class="s5">1e6</span><span class="s1">)</span>
        <span class="s1">mod.ssm.filter_univariate = </span><span class="s2">True</span>
        <span class="s1">cls.model = mod</span>
        <span class="s1">cls.results = mod.smooth([]</span><span class="s2">, </span><span class="s1">return_ssm=</span><span class="s2">True</span><span class="s1">)</span>

        <span class="s1">cls.sim = cls.model.simulation_smoother()</span>

    <span class="s2">def </span><span class="s1">test_loglike(self):</span>
        <span class="s1">assert_allclose(np.sum(self.results.llf_obs)</span><span class="s2">, </span><span class="s1">self.true_llf)</span>

    <span class="s2">def </span><span class="s1">test_simulation_smoothing(self):</span>
        <span class="s1">sim = self.sim</span>

        <span class="s1">Z = self.model[</span><span class="s4">'design'</span><span class="s1">]</span>

        <span class="s1">nobs = self.model.nobs</span>
        <span class="s1">k_endog = self.model.k_endog</span>

        <span class="s3"># Simulate with known variates</span>
        <span class="s3"># TODO</span>
        <span class="s1">sim.simulate(measurement_disturbance_variates=(</span>
                        <span class="s1">self.variates[:nobs * k_endog])</span><span class="s2">,</span>
                     <span class="s1">state_disturbance_variates=(</span>
                        <span class="s1">self.variates[nobs * k_endog:-</span><span class="s5">3</span><span class="s1">])</span><span class="s2">,</span>
                     <span class="s1">initial_state_variates=self.variates[-</span><span class="s5">3</span><span class="s1">:])</span>

        <span class="s3"># Test against R package KFAS values</span>
        <span class="s1">assert_allclose(sim.simulated_state.T</span><span class="s2">,</span>
                        <span class="s1">self.true[[</span><span class="s4">'state1'</span><span class="s2">, </span><span class="s4">'state2'</span><span class="s2">, </span><span class="s4">'state3'</span><span class="s1">]]</span><span class="s2">,</span>
                        <span class="s1">atol=</span><span class="s5">1e-7</span><span class="s1">)</span>
        <span class="s1">assert_allclose(sim.simulated_measurement_disturbance</span><span class="s2">,</span>
                        <span class="s1">self.true[[</span><span class="s4">'eps1'</span><span class="s2">, </span><span class="s4">'eps2'</span><span class="s2">, </span><span class="s4">'eps3'</span><span class="s1">]].T</span><span class="s2">,</span>
                        <span class="s1">atol=</span><span class="s5">1e-7</span><span class="s1">)</span>
        <span class="s1">assert_allclose(sim.simulated_state_disturbance</span><span class="s2">,</span>
                        <span class="s1">self.true[[</span><span class="s4">'eta1'</span><span class="s2">, </span><span class="s4">'eta2'</span><span class="s2">, </span><span class="s4">'eta3'</span><span class="s1">]].T</span><span class="s2">,</span>
                        <span class="s1">atol=</span><span class="s5">1e-7</span><span class="s1">)</span>
        <span class="s1">signals = np.zeros((</span><span class="s5">3</span><span class="s2">, </span><span class="s1">self.model.nobs))</span>
        <span class="s2">for </span><span class="s1">t </span><span class="s2">in </span><span class="s1">range(self.model.nobs):</span>
            <span class="s1">signals[:</span><span class="s2">, </span><span class="s1">t] = np.dot(Z</span><span class="s2">, </span><span class="s1">sim.simulated_state[:</span><span class="s2">, </span><span class="s1">t])</span>
        <span class="s1">assert_allclose(signals</span><span class="s2">,</span>
                        <span class="s1">self.true[[</span><span class="s4">'signal1'</span><span class="s2">, </span><span class="s4">'signal2'</span><span class="s2">, </span><span class="s4">'signal3'</span><span class="s1">]].T</span><span class="s2">,</span>
                        <span class="s1">atol=</span><span class="s5">1e-7</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestMultivariateVAR(MultivariateVAR):</span>
    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">super(TestMultivariateVAR</span><span class="s2">, </span><span class="s1">cls).setup_class()</span>
        <span class="s1">path = os.path.join(current_path</span><span class="s2">, </span><span class="s4">'results'</span><span class="s2">,</span>
                            <span class="s4">'results_simulation_smoothing3_variates.csv'</span><span class="s1">)</span>
        <span class="s1">cls.variates = pd.read_csv(path).values.squeeze()</span>
        <span class="s1">path = os.path.join(current_path</span><span class="s2">, </span><span class="s4">'results'</span><span class="s2">,</span>
                            <span class="s4">'results_simulation_smoothing3.csv'</span><span class="s1">)</span>
        <span class="s1">cls.true = pd.read_csv(path)</span>
        <span class="s1">cls.true_llf = </span><span class="s5">1695.34872</span>


<span class="s2">def </span><span class="s1">test_misc():</span>

    <span class="s3"># Create the model and simulation smoother</span>
    <span class="s1">dta = datasets.macrodata.load_pandas().data</span>
    <span class="s1">dta.index = pd.date_range(start=</span><span class="s4">'1959-01-01'</span><span class="s2">, </span><span class="s1">end=</span><span class="s4">'2009-7-01'</span><span class="s2">,</span>
                              <span class="s1">freq=</span><span class="s4">'QS'</span><span class="s1">)</span>
    <span class="s1">obs = np.log(dta[[</span><span class="s4">'realgdp'</span><span class="s2">, </span><span class="s4">'realcons'</span><span class="s2">, </span><span class="s4">'realinv'</span><span class="s1">]]).diff().iloc[</span><span class="s5">1</span><span class="s1">:]</span>

    <span class="s1">mod = sarimax.SARIMAX(obs[</span><span class="s4">'realgdp'</span><span class="s1">]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">))</span>
    <span class="s1">mod[</span><span class="s4">'design'</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] = </span><span class="s5">0.</span>
    <span class="s1">mod[</span><span class="s4">'obs_cov'</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">] = </span><span class="s5">1.</span>
    <span class="s1">mod.update(np.r_[</span><span class="s5">1.</span><span class="s2">, </span><span class="s5">1.</span><span class="s1">])</span>
    <span class="s1">sim = mod.simulation_smoother()</span>

    <span class="s3"># Test that the simulation smoother is drawing variates correctly</span>
    <span class="s1">rs = np.random.RandomState(</span><span class="s5">1234</span><span class="s1">)</span>
    <span class="s1">n_disturbance_variates = mod.nobs * (mod.k_endog + mod.k_states)</span>
    <span class="s1">variates = rs.normal(size=n_disturbance_variates)</span>
    <span class="s1">rs = np.random.RandomState(</span><span class="s5">1234</span><span class="s1">)</span>
    <span class="s1">sim.simulate(random_state=rs)</span>
    <span class="s1">assert_allclose(sim.generated_measurement_disturbance[:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s1">variates[:mod.nobs])</span>
    <span class="s1">assert_allclose(sim.generated_state_disturbance[:</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">,</span>
                    <span class="s1">variates[mod.nobs:])</span>

    <span class="s3"># Test that we can change the options of the simulations smoother</span>
    <span class="s1">assert_equal(sim.simulation_output</span><span class="s2">, </span><span class="s1">mod.ssm.smoother_output)</span>
    <span class="s1">sim.simulation_output = </span><span class="s5">0</span>
    <span class="s1">assert_equal(sim.simulation_output</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>

    <span class="s1">sim.simulate_state = </span><span class="s2">True</span>
    <span class="s1">assert_equal(sim.simulation_output</span><span class="s2">, </span><span class="s1">SIMULATION_STATE)</span>
    <span class="s1">sim.simulate_state = </span><span class="s2">False</span>
    <span class="s1">assert_equal(sim.simulation_output</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>

    <span class="s1">sim.simulate_disturbance = </span><span class="s2">True</span>
    <span class="s1">assert_equal(sim.simulation_output</span><span class="s2">, </span><span class="s1">SIMULATION_DISTURBANCE)</span>
    <span class="s1">sim.simulate_disturbance = </span><span class="s2">False</span>
    <span class="s1">assert_equal(sim.simulation_output</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>

    <span class="s1">sim.simulate_all = </span><span class="s2">True</span>
    <span class="s1">assert_equal(sim.simulation_output</span><span class="s2">, </span><span class="s1">SIMULATION_ALL)</span>
    <span class="s1">sim.simulate_all = </span><span class="s2">False</span>
    <span class="s1">assert_equal(sim.simulation_output</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_simulation_smoothing_obs_intercept():</span>
    <span class="s1">nobs = </span><span class="s5">10</span>
    <span class="s1">intercept = </span><span class="s5">100</span>
    <span class="s1">endog = np.ones(nobs) * intercept</span>
    <span class="s1">mod = structural.UnobservedComponents(endog</span><span class="s2">, </span><span class="s4">'rwalk'</span><span class="s2">, </span><span class="s1">exog=np.ones(nobs))</span>
    <span class="s1">mod.update([</span><span class="s5">1</span><span class="s2">, </span><span class="s1">intercept])</span>
    <span class="s1">sim = mod.simulation_smoother()</span>
    <span class="s1">sim.simulate(measurement_disturbance_variates=np.zeros(mod.nobs)</span><span class="s2">,</span>
                 <span class="s1">state_disturbance_variates=np.zeros(mod.nobs)</span><span class="s2">,</span>
                 <span class="s1">initial_state_variates=np.zeros(</span><span class="s5">1</span><span class="s1">))</span>
    <span class="s1">assert_equal(sim.simulated_state[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">test_simulation_smoothing_state_intercept():</span>
    <span class="s1">nobs = </span><span class="s5">10</span>
    <span class="s1">intercept = </span><span class="s5">100</span>
    <span class="s1">endog = np.ones(nobs) * intercept</span>

    <span class="s1">mod = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s4">'c'</span><span class="s2">,</span>
                          <span class="s1">measurement_error=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">mod.initialize_known([</span><span class="s5">100</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[[</span><span class="s5">0</span><span class="s1">]])</span>
    <span class="s1">mod.update([intercept</span><span class="s2">, </span><span class="s5">1.</span><span class="s2">, </span><span class="s5">1.</span><span class="s1">])</span>

    <span class="s1">sim = mod.simulation_smoother()</span>
    <span class="s1">sim.simulate(measurement_disturbance_variates=np.zeros(mod.nobs)</span><span class="s2">,</span>
                 <span class="s1">state_disturbance_variates=np.zeros(mod.nobs)</span><span class="s2">,</span>
                 <span class="s1">initial_state_variates=np.zeros(</span><span class="s5">1</span><span class="s1">))</span>
    <span class="s1">assert_equal(sim.simulated_state[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">intercept)</span>


<span class="s2">def </span><span class="s1">test_simulation_smoothing_state_intercept_diffuse():</span>
    <span class="s1">nobs = </span><span class="s5">10</span>
    <span class="s1">intercept = </span><span class="s5">100</span>
    <span class="s1">endog = np.ones(nobs) * intercept</span>

    <span class="s3"># Test without missing values</span>
    <span class="s1">mod = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s4">'c'</span><span class="s2">,</span>
                          <span class="s1">measurement_error=</span><span class="s2">True,</span>
                          <span class="s1">initialization=</span><span class="s4">'diffuse'</span><span class="s1">)</span>
    <span class="s1">mod.update([intercept</span><span class="s2">, </span><span class="s5">1.</span><span class="s2">, </span><span class="s5">1.</span><span class="s1">])</span>

    <span class="s1">sim = mod.simulation_smoother()</span>
    <span class="s1">sim.simulate(measurement_disturbance_variates=np.zeros(mod.nobs)</span><span class="s2">,</span>
                 <span class="s1">state_disturbance_variates=np.zeros(mod.nobs)</span><span class="s2">,</span>
                 <span class="s1">initial_state_variates=np.zeros(</span><span class="s5">1</span><span class="s1">))</span>
    <span class="s1">assert_equal(sim.simulated_state[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">intercept)</span>

    <span class="s3"># Test with missing values</span>
    <span class="s1">endog[</span><span class="s5">5</span><span class="s1">] = np.nan</span>
    <span class="s1">mod = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s4">'c'</span><span class="s2">,</span>
                          <span class="s1">measurement_error=</span><span class="s2">True,</span>
                          <span class="s1">initialization=</span><span class="s4">'diffuse'</span><span class="s1">)</span>
    <span class="s1">mod.update([intercept</span><span class="s2">, </span><span class="s5">1.</span><span class="s2">, </span><span class="s5">1.</span><span class="s1">])</span>

    <span class="s1">sim = mod.simulation_smoother()</span>
    <span class="s1">sim.simulate(measurement_disturbance_variates=np.zeros(mod.nobs)</span><span class="s2">,</span>
                 <span class="s1">state_disturbance_variates=np.zeros(mod.nobs)</span><span class="s2">,</span>
                 <span class="s1">initial_state_variates=np.zeros(</span><span class="s5">1</span><span class="s1">))</span>
    <span class="s1">assert_equal(sim.simulated_state[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">intercept)</span>


<span class="s2">def </span><span class="s1">test_deprecated_arguments_univariate():</span>
    <span class="s1">nobs = </span><span class="s5">10</span>
    <span class="s1">intercept = </span><span class="s5">100</span>
    <span class="s1">endog = np.ones(nobs) * intercept</span>

    <span class="s1">mod = sarimax.SARIMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s4">'c'</span><span class="s2">,</span>
                          <span class="s1">measurement_error=</span><span class="s2">True,</span>
                          <span class="s1">initialization=</span><span class="s4">'diffuse'</span><span class="s1">)</span>
    <span class="s1">mod.update([intercept</span><span class="s2">, </span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">2.</span><span class="s1">])</span>

    <span class="s1">mds = np.arange(</span><span class="s5">10</span><span class="s1">) / </span><span class="s5">10.</span>
    <span class="s1">sds = np.arange(</span><span class="s5">10</span><span class="s1">)[::-</span><span class="s5">1</span><span class="s1">] / </span><span class="s5">20.</span>

    <span class="s3"># Test using deprecated `disturbance_variates`</span>
    <span class="s1">sim = mod.simulation_smoother()</span>
    <span class="s1">sim.simulate(measurement_disturbance_variates=mds</span><span class="s2">,</span>
                 <span class="s1">state_disturbance_variates=sds</span><span class="s2">,</span>
                 <span class="s1">initial_state_variates=np.zeros(</span><span class="s5">1</span><span class="s1">))</span>
    <span class="s1">desired = sim.simulated_state[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s2">with </span><span class="s1">pytest.warns(FutureWarning):</span>
        <span class="s1">sim.simulate(disturbance_variates=np.r_[mds</span><span class="s2">, </span><span class="s1">sds]</span><span class="s2">,</span>
                     <span class="s1">initial_state_variates=np.zeros(</span><span class="s5">1</span><span class="s1">))</span>
    <span class="s1">actual = sim.simulated_state[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s3"># Test using deprecated `pretransformed`</span>
    <span class="s1">sim = mod.simulation_smoother()</span>
    <span class="s1">sim.simulate(measurement_disturbance_variates=mds</span><span class="s2">,</span>
                 <span class="s1">state_disturbance_variates=sds</span><span class="s2">,</span>
                 <span class="s1">initial_state_variates=np.zeros(</span><span class="s5">1</span><span class="s1">)</span><span class="s2">,</span>
                 <span class="s1">pretransformed_measurement_disturbance_variates=</span><span class="s2">True,</span>
                 <span class="s1">pretransformed_state_disturbance_variates=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">desired = sim.simulated_state[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s2">with </span><span class="s1">pytest.warns(FutureWarning):</span>
        <span class="s1">sim.simulate(measurement_disturbance_variates=mds</span><span class="s2">,</span>
                     <span class="s1">state_disturbance_variates=sds</span><span class="s2">,</span>
                     <span class="s1">pretransformed=</span><span class="s2">True,</span>
                     <span class="s1">initial_state_variates=np.zeros(</span><span class="s5">1</span><span class="s1">))</span>
    <span class="s1">actual = sim.simulated_state[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>


<span class="s2">def </span><span class="s1">test_deprecated_arguments_multivariate():</span>
    <span class="s1">endog = np.array([[</span><span class="s5">0.3</span><span class="s2">, </span><span class="s5">1.4</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[-</span><span class="s5">0.1</span><span class="s2">, </span><span class="s5">0.6</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s5">0.2</span><span class="s2">, </span><span class="s5">0.7</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s5">0.1</span><span class="s2">, </span><span class="s5">0.9</span><span class="s1">]</span><span class="s2">,</span>
                      <span class="s1">[</span><span class="s5">0.5</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.1</span><span class="s1">]])</span>

    <span class="s1">mod = varmax.VARMAX(endog</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">))</span>
    <span class="s1">mod.update([</span><span class="s5">1.2</span><span class="s2">, </span><span class="s5">0.5</span><span class="s2">,</span>
                <span class="s5">0.8</span><span class="s2">, </span><span class="s5">0.1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">0.2</span><span class="s2">, </span><span class="s5">0.5</span><span class="s2">,</span>
                <span class="s5">5.2</span><span class="s2">, </span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">8.1</span><span class="s1">])</span>

    <span class="s1">mds = np.arange(</span><span class="s5">10</span><span class="s1">).reshape(</span><span class="s5">5</span><span class="s2">, </span><span class="s5">2</span><span class="s1">) / </span><span class="s5">10.</span>
    <span class="s1">sds = np.arange(</span><span class="s5">10</span><span class="s1">).reshape(</span><span class="s5">5</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)[::-</span><span class="s5">1</span><span class="s1">] / </span><span class="s5">20.</span>

    <span class="s3"># Test using deprecated `disturbance_variates`</span>
    <span class="s1">sim = mod.simulation_smoother()</span>
    <span class="s1">sim.simulate(measurement_disturbance_variates=mds</span><span class="s2">,</span>
                 <span class="s1">state_disturbance_variates=sds</span><span class="s2">,</span>
                 <span class="s1">initial_state_variates=np.zeros(</span><span class="s5">2</span><span class="s1">))</span>
    <span class="s1">desired = sim.simulated_state[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s2">with </span><span class="s1">pytest.warns(FutureWarning):</span>
        <span class="s1">sim.simulate(disturbance_variates=np.r_[mds.ravel()</span><span class="s2">, </span><span class="s1">sds.ravel()]</span><span class="s2">,</span>
                     <span class="s1">initial_state_variates=np.zeros(</span><span class="s5">2</span><span class="s1">))</span>
    <span class="s1">actual = sim.simulated_state[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s3"># Test using deprecated `pretransformed`</span>
    <span class="s1">sim = mod.simulation_smoother()</span>
    <span class="s1">sim.simulate(measurement_disturbance_variates=mds</span><span class="s2">,</span>
                 <span class="s1">state_disturbance_variates=sds</span><span class="s2">,</span>
                 <span class="s1">initial_state_variates=np.zeros(</span><span class="s5">2</span><span class="s1">)</span><span class="s2">,</span>
                 <span class="s1">pretransformed_measurement_disturbance_variates=</span><span class="s2">True,</span>
                 <span class="s1">pretransformed_state_disturbance_variates=</span><span class="s2">True</span><span class="s1">)</span>
    <span class="s1">desired = sim.simulated_state[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s2">with </span><span class="s1">pytest.warns(FutureWarning):</span>
        <span class="s1">sim.simulate(measurement_disturbance_variates=mds</span><span class="s2">,</span>
                     <span class="s1">state_disturbance_variates=sds</span><span class="s2">,</span>
                     <span class="s1">pretransformed=</span><span class="s2">True,</span>
                     <span class="s1">initial_state_variates=np.zeros(</span><span class="s5">2</span><span class="s1">))</span>
    <span class="s1">actual = sim.simulated_state[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s1">assert_allclose(actual</span><span class="s2">, </span><span class="s1">desired)</span>


<span class="s2">def </span><span class="s1">test_nan():</span>
    <span class="s0">&quot;&quot;&quot; 
    This is a very slow test to check that the distribution of simulated states 
    (from the posterior) is correct in the presense of NaN values. Here, it 
    checks the marginal distribution of the drawn states against the values 
    computed from the smoother and prints the result. 
 
    With the fixed simulation smoother, it prints: 
 
    True values: 
    [1.         0.66666667 0.66666667 1.        ] 
    [0.         0.95238095 0.95238095 0.        ] 
 
    Simulated values: 
    [1.         0.66699187 0.66456719 1.        ] 
    [0.       0.953608 0.953198 0.      ] 
 
    Previously, it would have printed: 
 
    True values: 
    [1.         0.66666667 0.66666667 1.        ] 
    [0.         0.95238095 0.95238095 0.        ] 
 
    Simulated values: 
    [1.         0.66666667 0.66666667 1.        ] 
    [0. 0. 0. 0.] 
    &quot;&quot;&quot;</span>
    <span class="s2">return</span>
    <span class="s1">mod = sarimax.SARIMAX([</span><span class="s5">1</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s1">np.nan</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">order=(</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s4">'c'</span><span class="s1">)</span>
    <span class="s1">res = mod.smooth([</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">1.0</span><span class="s1">])</span>

    <span class="s1">rs = np.random.RandomState(</span><span class="s5">1234</span><span class="s1">)</span>
    <span class="s1">sim = mod.simulation_smoother(random_state=rs)</span>

    <span class="s1">n = </span><span class="s5">1000000</span>
    <span class="s1">out = np.zeros((n</span><span class="s2">, </span><span class="s1">mod.nobs))</span>
    <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(n):</span>
        <span class="s1">sim.simulate()</span>
        <span class="s1">out[i] = sim.simulated_state</span>

    <span class="s1">print(</span><span class="s4">'True values:'</span><span class="s1">)</span>
    <span class="s1">print(res.smoothed_state[</span><span class="s5">0</span><span class="s1">])</span>
    <span class="s1">print(res.smoothed_state_cov[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">])</span>
    <span class="s1">print()</span>
    <span class="s1">print(</span><span class="s4">'Simulated values:'</span><span class="s1">)</span>
    <span class="s1">print(np.mean(out</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">))</span>
    <span class="s1">print(np.var(out</span><span class="s2">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">).round(</span><span class="s5">6</span><span class="s1">))</span>
</pre>
</body>
</html>