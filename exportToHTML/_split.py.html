<html>
<head>
<title>_split.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_split.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
The :mod:`sklearn.model_selection._split` module includes classes and 
functions to split the data based on a preset strategy. 
&quot;&quot;&quot;</span>

<span class="s2"># Author: Alexandre Gramfort &lt;alexandre.gramfort@inria.fr&gt;</span>
<span class="s2">#         Gael Varoquaux &lt;gael.varoquaux@normalesup.org&gt;</span>
<span class="s2">#         Olivier Grisel &lt;olivier.grisel@ensta.org&gt;</span>
<span class="s2">#         Raghav RV &lt;rvraghav93@gmail.com&gt;</span>
<span class="s2">#         Leandro Hermida &lt;hermidal@cs.umd.edu&gt;</span>
<span class="s2">#         Rodion Martynov &lt;marrodion@gmail.com&gt;</span>
<span class="s2"># License: BSD 3 clause</span>

<span class="s3">import </span><span class="s1">numbers</span>
<span class="s3">import </span><span class="s1">warnings</span>
<span class="s3">from </span><span class="s1">abc </span><span class="s3">import </span><span class="s1">ABCMeta</span><span class="s3">, </span><span class="s1">abstractmethod</span>
<span class="s3">from </span><span class="s1">collections </span><span class="s3">import </span><span class="s1">defaultdict</span>
<span class="s3">from </span><span class="s1">collections.abc </span><span class="s3">import </span><span class="s1">Iterable</span>
<span class="s3">from </span><span class="s1">inspect </span><span class="s3">import </span><span class="s1">signature</span>
<span class="s3">from </span><span class="s1">itertools </span><span class="s3">import </span><span class="s1">chain</span><span class="s3">, </span><span class="s1">combinations</span>
<span class="s3">from </span><span class="s1">math </span><span class="s3">import </span><span class="s1">ceil</span><span class="s3">, </span><span class="s1">floor</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">from </span><span class="s1">scipy.special </span><span class="s3">import </span><span class="s1">comb</span>

<span class="s3">from </span><span class="s1">..utils </span><span class="s3">import </span><span class="s1">(</span>
    <span class="s1">_approximate_mode</span><span class="s3">,</span>
    <span class="s1">_safe_indexing</span><span class="s3">,</span>
    <span class="s1">check_random_state</span><span class="s3">,</span>
    <span class="s1">indexable</span><span class="s3">,</span>
    <span class="s1">metadata_routing</span><span class="s3">,</span>
<span class="s1">)</span>
<span class="s3">from </span><span class="s1">..utils._param_validation </span><span class="s3">import </span><span class="s1">Interval</span><span class="s3">, </span><span class="s1">RealNotInt</span><span class="s3">, </span><span class="s1">validate_params</span>
<span class="s3">from </span><span class="s1">..utils.metadata_routing </span><span class="s3">import </span><span class="s1">_MetadataRequester</span>
<span class="s3">from </span><span class="s1">..utils.multiclass </span><span class="s3">import </span><span class="s1">type_of_target</span>
<span class="s3">from </span><span class="s1">..utils.validation </span><span class="s3">import </span><span class="s1">_num_samples</span><span class="s3">, </span><span class="s1">check_array</span><span class="s3">, </span><span class="s1">column_or_1d</span>

<span class="s1">__all__ = [</span>
    <span class="s4">&quot;BaseCrossValidator&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;KFold&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;GroupKFold&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;LeaveOneGroupOut&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;LeaveOneOut&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;LeavePGroupsOut&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;LeavePOut&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;RepeatedStratifiedKFold&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;RepeatedKFold&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;ShuffleSplit&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;GroupShuffleSplit&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;StratifiedKFold&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;StratifiedGroupKFold&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;StratifiedShuffleSplit&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;PredefinedSplit&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;train_test_split&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;check_cv&quot;</span><span class="s3">,</span>
<span class="s1">]</span>


<span class="s3">class </span><span class="s1">GroupsConsumerMixin(_MetadataRequester):</span>
    <span class="s0">&quot;&quot;&quot;A Mixin to ``groups`` by default. 
 
    This Mixin makes the object to request ``groups`` by default as ``True``. 
 
    .. versionadded:: 1.3 
    &quot;&quot;&quot;</span>

    <span class="s1">__metadata_request__split = {</span><span class="s4">&quot;groups&quot;</span><span class="s1">: </span><span class="s3">True</span><span class="s1">}</span>


<span class="s3">class </span><span class="s1">BaseCrossValidator(_MetadataRequester</span><span class="s3">, </span><span class="s1">metaclass=ABCMeta):</span>
    <span class="s0">&quot;&quot;&quot;Base class for all cross-validators 
 
    Implementations must define `_iter_test_masks` or `_iter_test_indices`. 
    &quot;&quot;&quot;</span>

    <span class="s2"># This indicates that by default CV splitters don't have a &quot;groups&quot; kwarg,</span>
    <span class="s2"># unless indicated by inheriting from ``GroupsConsumerMixin``.</span>
    <span class="s2"># This also prevents ``set_split_request`` to be generated for splitters</span>
    <span class="s2"># which don't support ``groups``.</span>
    <span class="s1">__metadata_request__split = {</span><span class="s4">&quot;groups&quot;</span><span class="s1">: metadata_routing.UNUSED}</span>

    <span class="s3">def </span><span class="s1">split(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y=</span><span class="s3">None, </span><span class="s1">groups=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Generate indices to split data into training and test set. 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) 
            Training data, where `n_samples` is the number of samples 
            and `n_features` is the number of features. 
 
        y : array-like of shape (n_samples,) 
            The target variable for supervised learning problems. 
 
        groups : array-like of shape (n_samples,), default=None 
            Group labels for the samples used while splitting the dataset into 
            train/test set. 
 
        Yields 
        ------ 
        train : ndarray 
            The training set indices for that split. 
 
        test : ndarray 
            The testing set indices for that split. 
        &quot;&quot;&quot;</span>
        <span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups = indexable(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups)</span>
        <span class="s1">indices = np.arange(_num_samples(X))</span>
        <span class="s3">for </span><span class="s1">test_index </span><span class="s3">in </span><span class="s1">self._iter_test_masks(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups):</span>
            <span class="s1">train_index = indices[np.logical_not(test_index)]</span>
            <span class="s1">test_index = indices[test_index]</span>
            <span class="s3">yield </span><span class="s1">train_index</span><span class="s3">, </span><span class="s1">test_index</span>

    <span class="s2"># Since subclasses must implement either _iter_test_masks or</span>
    <span class="s2"># _iter_test_indices, neither can be abstract.</span>
    <span class="s3">def </span><span class="s1">_iter_test_masks(self</span><span class="s3">, </span><span class="s1">X=</span><span class="s3">None, </span><span class="s1">y=</span><span class="s3">None, </span><span class="s1">groups=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Generates boolean masks corresponding to test sets. 
 
        By default, delegates to _iter_test_indices(X, y, groups) 
        &quot;&quot;&quot;</span>
        <span class="s3">for </span><span class="s1">test_index </span><span class="s3">in </span><span class="s1">self._iter_test_indices(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups):</span>
            <span class="s1">test_mask = np.zeros(_num_samples(X)</span><span class="s3">, </span><span class="s1">dtype=bool)</span>
            <span class="s1">test_mask[test_index] = </span><span class="s3">True</span>
            <span class="s3">yield </span><span class="s1">test_mask</span>

    <span class="s3">def </span><span class="s1">_iter_test_indices(self</span><span class="s3">, </span><span class="s1">X=</span><span class="s3">None, </span><span class="s1">y=</span><span class="s3">None, </span><span class="s1">groups=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Generates integer indices corresponding to test sets.&quot;&quot;&quot;</span>
        <span class="s3">raise </span><span class="s1">NotImplementedError</span>

    <span class="s1">@abstractmethod</span>
    <span class="s3">def </span><span class="s1">get_n_splits(self</span><span class="s3">, </span><span class="s1">X=</span><span class="s3">None, </span><span class="s1">y=</span><span class="s3">None, </span><span class="s1">groups=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Returns the number of splitting iterations in the cross-validator&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__repr__(self):</span>
        <span class="s3">return </span><span class="s1">_build_repr(self)</span>


<span class="s3">class </span><span class="s1">LeaveOneOut(BaseCrossValidator):</span>
    <span class="s0">&quot;&quot;&quot;Leave-One-Out cross-validator 
 
    Provides train/test indices to split data in train/test sets. Each 
    sample is used once as a test set (singleton) while the remaining 
    samples form the training set. 
 
    Note: ``LeaveOneOut()`` is equivalent to ``KFold(n_splits=n)`` and 
    ``LeavePOut(p=1)`` where ``n`` is the number of samples. 
 
    Due to the high number of test sets (which is the same as the 
    number of samples) this cross-validation method can be very costly. 
    For large datasets one should favor :class:`KFold`, :class:`ShuffleSplit` 
    or :class:`StratifiedKFold`. 
 
    Read more in the :ref:`User Guide &lt;leave_one_out&gt;`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from sklearn.model_selection import LeaveOneOut 
    &gt;&gt;&gt; X = np.array([[1, 2], [3, 4]]) 
    &gt;&gt;&gt; y = np.array([1, 2]) 
    &gt;&gt;&gt; loo = LeaveOneOut() 
    &gt;&gt;&gt; loo.get_n_splits(X) 
    2 
    &gt;&gt;&gt; print(loo) 
    LeaveOneOut() 
    &gt;&gt;&gt; for i, (train_index, test_index) in enumerate(loo.split(X)): 
    ...     print(f&quot;Fold {i}:&quot;) 
    ...     print(f&quot;  Train: index={train_index}&quot;) 
    ...     print(f&quot;  Test:  index={test_index}&quot;) 
    Fold 0: 
      Train: index=[1] 
      Test:  index=[0] 
    Fold 1: 
      Train: index=[0] 
      Test:  index=[1] 
 
    See Also 
    -------- 
    LeaveOneGroupOut : For splitting the data according to explicit, 
        domain-specific stratification of the dataset. 
    GroupKFold : K-fold iterator variant with non-overlapping groups. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">_iter_test_indices(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y=</span><span class="s3">None, </span><span class="s1">groups=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">n_samples = _num_samples(X)</span>
        <span class="s3">if </span><span class="s1">n_samples &lt;= </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;Cannot perform LeaveOneOut with n_samples={}.&quot;</span><span class="s1">.format(n_samples)</span>
            <span class="s1">)</span>
        <span class="s3">return </span><span class="s1">range(n_samples)</span>

    <span class="s3">def </span><span class="s1">get_n_splits(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y=</span><span class="s3">None, </span><span class="s1">groups=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Returns the number of splitting iterations in the cross-validator 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) 
            Training data, where `n_samples` is the number of samples 
            and `n_features` is the number of features. 
 
        y : object 
            Always ignored, exists for compatibility. 
 
        groups : object 
            Always ignored, exists for compatibility. 
 
        Returns 
        ------- 
        n_splits : int 
            Returns the number of splitting iterations in the cross-validator. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">X </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;The 'X' parameter should not be None.&quot;</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">_num_samples(X)</span>


<span class="s3">class </span><span class="s1">LeavePOut(BaseCrossValidator):</span>
    <span class="s0">&quot;&quot;&quot;Leave-P-Out cross-validator 
 
    Provides train/test indices to split data in train/test sets. This results 
    in testing on all distinct samples of size p, while the remaining n - p 
    samples form the training set in each iteration. 
 
    Note: ``LeavePOut(p)`` is NOT equivalent to 
    ``KFold(n_splits=n_samples // p)`` which creates non-overlapping test sets. 
 
    Due to the high number of iterations which grows combinatorically with the 
    number of samples this cross-validation method can be very costly. For 
    large datasets one should favor :class:`KFold`, :class:`StratifiedKFold` 
    or :class:`ShuffleSplit`. 
 
    Read more in the :ref:`User Guide &lt;leave_p_out&gt;`. 
 
    Parameters 
    ---------- 
    p : int 
        Size of the test sets. Must be strictly less than the number of 
        samples. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from sklearn.model_selection import LeavePOut 
    &gt;&gt;&gt; X = np.array([[1, 2], [3, 4], [5, 6], [7, 8]]) 
    &gt;&gt;&gt; y = np.array([1, 2, 3, 4]) 
    &gt;&gt;&gt; lpo = LeavePOut(2) 
    &gt;&gt;&gt; lpo.get_n_splits(X) 
    6 
    &gt;&gt;&gt; print(lpo) 
    LeavePOut(p=2) 
    &gt;&gt;&gt; for i, (train_index, test_index) in enumerate(lpo.split(X)): 
    ...     print(f&quot;Fold {i}:&quot;) 
    ...     print(f&quot;  Train: index={train_index}&quot;) 
    ...     print(f&quot;  Test:  index={test_index}&quot;) 
    Fold 0: 
      Train: index=[2 3] 
      Test:  index=[0 1] 
    Fold 1: 
      Train: index=[1 3] 
      Test:  index=[0 2] 
    Fold 2: 
      Train: index=[1 2] 
      Test:  index=[0 3] 
    Fold 3: 
      Train: index=[0 3] 
      Test:  index=[1 2] 
    Fold 4: 
      Train: index=[0 2] 
      Test:  index=[1 3] 
    Fold 5: 
      Train: index=[0 1] 
      Test:  index=[2 3] 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">p):</span>
        <span class="s1">self.p = p</span>

    <span class="s3">def </span><span class="s1">_iter_test_indices(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y=</span><span class="s3">None, </span><span class="s1">groups=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">n_samples = _num_samples(X)</span>
        <span class="s3">if </span><span class="s1">n_samples &lt;= self.p:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;p={} must be strictly less than the number of samples={}&quot;</span><span class="s1">.format(</span>
                    <span class="s1">self.p</span><span class="s3">, </span><span class="s1">n_samples</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s3">for </span><span class="s1">combination </span><span class="s3">in </span><span class="s1">combinations(range(n_samples)</span><span class="s3">, </span><span class="s1">self.p):</span>
            <span class="s3">yield </span><span class="s1">np.array(combination)</span>

    <span class="s3">def </span><span class="s1">get_n_splits(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y=</span><span class="s3">None, </span><span class="s1">groups=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Returns the number of splitting iterations in the cross-validator 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) 
            Training data, where `n_samples` is the number of samples 
            and `n_features` is the number of features. 
 
        y : object 
            Always ignored, exists for compatibility. 
 
        groups : object 
            Always ignored, exists for compatibility. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">X </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;The 'X' parameter should not be None.&quot;</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">int(comb(_num_samples(X)</span><span class="s3">, </span><span class="s1">self.p</span><span class="s3">, </span><span class="s1">exact=</span><span class="s3">True</span><span class="s1">))</span>


<span class="s3">class </span><span class="s1">_BaseKFold(BaseCrossValidator</span><span class="s3">, </span><span class="s1">metaclass=ABCMeta):</span>
    <span class="s0">&quot;&quot;&quot;Base class for KFold, GroupKFold, and StratifiedKFold&quot;&quot;&quot;</span>

    <span class="s1">@abstractmethod</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">n_splits</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">shuffle</span><span class="s3">, </span><span class="s1">random_state):</span>
        <span class="s3">if not </span><span class="s1">isinstance(n_splits</span><span class="s3">, </span><span class="s1">numbers.Integral):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;The number of folds must be of Integral type. &quot;</span>
                <span class="s4">&quot;%s of type %s was passed.&quot; </span><span class="s1">% (n_splits</span><span class="s3">, </span><span class="s1">type(n_splits))</span>
            <span class="s1">)</span>
        <span class="s1">n_splits = int(n_splits)</span>

        <span class="s3">if </span><span class="s1">n_splits &lt;= </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;k-fold cross-validation requires at least one&quot;</span>
                <span class="s4">&quot; train/test split by setting n_splits=2 or more,&quot;</span>
                <span class="s4">&quot; got n_splits={0}.&quot;</span><span class="s1">.format(n_splits)</span>
            <span class="s1">)</span>

        <span class="s3">if not </span><span class="s1">isinstance(shuffle</span><span class="s3">, </span><span class="s1">bool):</span>
            <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s4">&quot;shuffle must be True or False; got {0}&quot;</span><span class="s1">.format(shuffle))</span>

        <span class="s3">if not </span><span class="s1">shuffle </span><span class="s3">and </span><span class="s1">random_state </span><span class="s3">is not None</span><span class="s1">:  </span><span class="s2"># None is the default</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span>
                <span class="s1">(</span>
                    <span class="s4">&quot;Setting a random_state has no effect since shuffle is &quot;</span>
                    <span class="s4">&quot;False. You should leave &quot;</span>
                    <span class="s4">&quot;random_state to its default (None), or set shuffle=True.&quot;</span>
                <span class="s1">)</span><span class="s3">,</span>
            <span class="s1">)</span>

        <span class="s1">self.n_splits = n_splits</span>
        <span class="s1">self.shuffle = shuffle</span>
        <span class="s1">self.random_state = random_state</span>

    <span class="s3">def </span><span class="s1">split(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y=</span><span class="s3">None, </span><span class="s1">groups=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Generate indices to split data into training and test set. 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) 
            Training data, where `n_samples` is the number of samples 
            and `n_features` is the number of features. 
 
        y : array-like of shape (n_samples,), default=None 
            The target variable for supervised learning problems. 
 
        groups : array-like of shape (n_samples,), default=None 
            Group labels for the samples used while splitting the dataset into 
            train/test set. 
 
        Yields 
        ------ 
        train : ndarray 
            The training set indices for that split. 
 
        test : ndarray 
            The testing set indices for that split. 
        &quot;&quot;&quot;</span>
        <span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups = indexable(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups)</span>
        <span class="s1">n_samples = _num_samples(X)</span>
        <span class="s3">if </span><span class="s1">self.n_splits &gt; n_samples:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span>
                <span class="s1">(</span>
                    <span class="s4">&quot;Cannot have number of splits n_splits={0} greater&quot;</span>
                    <span class="s4">&quot; than the number of samples: n_samples={1}.&quot;</span>
                <span class="s1">).format(self.n_splits</span><span class="s3">, </span><span class="s1">n_samples)</span>
            <span class="s1">)</span>

        <span class="s3">for </span><span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">in </span><span class="s1">super().split(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups):</span>
            <span class="s3">yield </span><span class="s1">train</span><span class="s3">, </span><span class="s1">test</span>

    <span class="s3">def </span><span class="s1">get_n_splits(self</span><span class="s3">, </span><span class="s1">X=</span><span class="s3">None, </span><span class="s1">y=</span><span class="s3">None, </span><span class="s1">groups=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Returns the number of splitting iterations in the cross-validator 
 
        Parameters 
        ---------- 
        X : object 
            Always ignored, exists for compatibility. 
 
        y : object 
            Always ignored, exists for compatibility. 
 
        groups : object 
            Always ignored, exists for compatibility. 
 
        Returns 
        ------- 
        n_splits : int 
            Returns the number of splitting iterations in the cross-validator. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.n_splits</span>


<span class="s3">class </span><span class="s1">KFold(_BaseKFold):</span>
    <span class="s0">&quot;&quot;&quot;K-Folds cross-validator 
 
    Provides train/test indices to split data in train/test sets. Split 
    dataset into k consecutive folds (without shuffling by default). 
 
    Each fold is then used once as a validation while the k - 1 remaining 
    folds form the training set. 
 
    Read more in the :ref:`User Guide &lt;k_fold&gt;`. 
 
    For visualisation of cross-validation behaviour and 
    comparison between common scikit-learn split methods 
    refer to :ref:`sphx_glr_auto_examples_model_selection_plot_cv_indices.py` 
 
    Parameters 
    ---------- 
    n_splits : int, default=5 
        Number of folds. Must be at least 2. 
 
        .. versionchanged:: 0.22 
            ``n_splits`` default value changed from 3 to 5. 
 
    shuffle : bool, default=False 
        Whether to shuffle the data before splitting into batches. 
        Note that the samples within each split will not be shuffled. 
 
    random_state : int, RandomState instance or None, default=None 
        When `shuffle` is True, `random_state` affects the ordering of the 
        indices, which controls the randomness of each fold. Otherwise, this 
        parameter has no effect. 
        Pass an int for reproducible output across multiple function calls. 
        See :term:`Glossary &lt;random_state&gt;`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from sklearn.model_selection import KFold 
    &gt;&gt;&gt; X = np.array([[1, 2], [3, 4], [1, 2], [3, 4]]) 
    &gt;&gt;&gt; y = np.array([1, 2, 3, 4]) 
    &gt;&gt;&gt; kf = KFold(n_splits=2) 
    &gt;&gt;&gt; kf.get_n_splits(X) 
    2 
    &gt;&gt;&gt; print(kf) 
    KFold(n_splits=2, random_state=None, shuffle=False) 
    &gt;&gt;&gt; for i, (train_index, test_index) in enumerate(kf.split(X)): 
    ...     print(f&quot;Fold {i}:&quot;) 
    ...     print(f&quot;  Train: index={train_index}&quot;) 
    ...     print(f&quot;  Test:  index={test_index}&quot;) 
    Fold 0: 
      Train: index=[2 3] 
      Test:  index=[0 1] 
    Fold 1: 
      Train: index=[0 1] 
      Test:  index=[2 3] 
 
    Notes 
    ----- 
    The first ``n_samples % n_splits`` folds have size 
    ``n_samples // n_splits + 1``, other folds have size 
    ``n_samples // n_splits``, where ``n_samples`` is the number of samples. 
 
    Randomized CV splitters may return different results for each call of 
    split. You can make the results identical by setting `random_state` 
    to an integer. 
 
    See Also 
    -------- 
    StratifiedKFold : Takes class information into account to avoid building 
        folds with imbalanced class distributions (for binary or multiclass 
        classification tasks). 
 
    GroupKFold : K-fold iterator variant with non-overlapping groups. 
 
    RepeatedKFold : Repeats K-Fold n times. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">n_splits=</span><span class="s5">5</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">shuffle=</span><span class="s3">False, </span><span class="s1">random_state=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">super().__init__(n_splits=n_splits</span><span class="s3">, </span><span class="s1">shuffle=shuffle</span><span class="s3">, </span><span class="s1">random_state=random_state)</span>

    <span class="s3">def </span><span class="s1">_iter_test_indices(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y=</span><span class="s3">None, </span><span class="s1">groups=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">n_samples = _num_samples(X)</span>
        <span class="s1">indices = np.arange(n_samples)</span>
        <span class="s3">if </span><span class="s1">self.shuffle:</span>
            <span class="s1">check_random_state(self.random_state).shuffle(indices)</span>

        <span class="s1">n_splits = self.n_splits</span>
        <span class="s1">fold_sizes = np.full(n_splits</span><span class="s3">, </span><span class="s1">n_samples // n_splits</span><span class="s3">, </span><span class="s1">dtype=int)</span>
        <span class="s1">fold_sizes[: n_samples % n_splits] += </span><span class="s5">1</span>
        <span class="s1">current = </span><span class="s5">0</span>
        <span class="s3">for </span><span class="s1">fold_size </span><span class="s3">in </span><span class="s1">fold_sizes:</span>
            <span class="s1">start</span><span class="s3">, </span><span class="s1">stop = current</span><span class="s3">, </span><span class="s1">current + fold_size</span>
            <span class="s3">yield </span><span class="s1">indices[start:stop]</span>
            <span class="s1">current = stop</span>


<span class="s3">class </span><span class="s1">GroupKFold(GroupsConsumerMixin</span><span class="s3">, </span><span class="s1">_BaseKFold):</span>
    <span class="s0">&quot;&quot;&quot;K-fold iterator variant with non-overlapping groups. 
 
    Each group will appear exactly once in the test set across all folds (the 
    number of distinct groups has to be at least equal to the number of folds). 
 
    The folds are approximately balanced in the sense that the number of 
    distinct groups is approximately the same in each fold. 
 
    Read more in the :ref:`User Guide &lt;group_k_fold&gt;`. 
 
    For visualisation of cross-validation behaviour and 
    comparison between common scikit-learn split methods 
    refer to :ref:`sphx_glr_auto_examples_model_selection_plot_cv_indices.py` 
 
    Parameters 
    ---------- 
    n_splits : int, default=5 
        Number of folds. Must be at least 2. 
 
        .. versionchanged:: 0.22 
            ``n_splits`` default value changed from 3 to 5. 
 
    Notes 
    ----- 
    Groups appear in an arbitrary order throughout the folds. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from sklearn.model_selection import GroupKFold 
    &gt;&gt;&gt; X = np.array([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12]]) 
    &gt;&gt;&gt; y = np.array([1, 2, 3, 4, 5, 6]) 
    &gt;&gt;&gt; groups = np.array([0, 0, 2, 2, 3, 3]) 
    &gt;&gt;&gt; group_kfold = GroupKFold(n_splits=2) 
    &gt;&gt;&gt; group_kfold.get_n_splits(X, y, groups) 
    2 
    &gt;&gt;&gt; print(group_kfold) 
    GroupKFold(n_splits=2) 
    &gt;&gt;&gt; for i, (train_index, test_index) in enumerate(group_kfold.split(X, y, groups)): 
    ...     print(f&quot;Fold {i}:&quot;) 
    ...     print(f&quot;  Train: index={train_index}, group={groups[train_index]}&quot;) 
    ...     print(f&quot;  Test:  index={test_index}, group={groups[test_index]}&quot;) 
    Fold 0: 
      Train: index=[2 3], group=[2 2] 
      Test:  index=[0 1 4 5], group=[0 0 3 3] 
    Fold 1: 
      Train: index=[0 1 4 5], group=[0 0 3 3] 
      Test:  index=[2 3], group=[2 2] 
 
    See Also 
    -------- 
    LeaveOneGroupOut : For splitting the data according to explicit 
        domain-specific stratification of the dataset. 
 
    StratifiedKFold : Takes class information into account to avoid building 
        folds with imbalanced class proportions (for binary or multiclass 
        classification tasks). 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">n_splits=</span><span class="s5">5</span><span class="s1">):</span>
        <span class="s1">super().__init__(n_splits</span><span class="s3">, </span><span class="s1">shuffle=</span><span class="s3">False, </span><span class="s1">random_state=</span><span class="s3">None</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">_iter_test_indices(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups):</span>
        <span class="s3">if </span><span class="s1">groups </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;The 'groups' parameter should not be None.&quot;</span><span class="s1">)</span>
        <span class="s1">groups = check_array(groups</span><span class="s3">, </span><span class="s1">input_name=</span><span class="s4">&quot;groups&quot;</span><span class="s3">, </span><span class="s1">ensure_2d=</span><span class="s3">False, </span><span class="s1">dtype=</span><span class="s3">None</span><span class="s1">)</span>

        <span class="s1">unique_groups</span><span class="s3">, </span><span class="s1">groups = np.unique(groups</span><span class="s3">, </span><span class="s1">return_inverse=</span><span class="s3">True</span><span class="s1">)</span>
        <span class="s1">n_groups = len(unique_groups)</span>

        <span class="s3">if </span><span class="s1">self.n_splits &gt; n_groups:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;Cannot have number of splits n_splits=%d greater&quot;</span>
                <span class="s4">&quot; than the number of groups: %d.&quot; </span><span class="s1">% (self.n_splits</span><span class="s3">, </span><span class="s1">n_groups)</span>
            <span class="s1">)</span>

        <span class="s2"># Weight groups by their number of occurrences</span>
        <span class="s1">n_samples_per_group = np.bincount(groups)</span>

        <span class="s2"># Distribute the most frequent groups first</span>
        <span class="s1">indices = np.argsort(n_samples_per_group)[::-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">n_samples_per_group = n_samples_per_group[indices]</span>

        <span class="s2"># Total weight of each fold</span>
        <span class="s1">n_samples_per_fold = np.zeros(self.n_splits)</span>

        <span class="s2"># Mapping from group index to fold index</span>
        <span class="s1">group_to_fold = np.zeros(len(unique_groups))</span>

        <span class="s2"># Distribute samples by adding the largest weight to the lightest fold</span>
        <span class="s3">for </span><span class="s1">group_index</span><span class="s3">, </span><span class="s1">weight </span><span class="s3">in </span><span class="s1">enumerate(n_samples_per_group):</span>
            <span class="s1">lightest_fold = np.argmin(n_samples_per_fold)</span>
            <span class="s1">n_samples_per_fold[lightest_fold] += weight</span>
            <span class="s1">group_to_fold[indices[group_index]] = lightest_fold</span>

        <span class="s1">indices = group_to_fold[groups]</span>

        <span class="s3">for </span><span class="s1">f </span><span class="s3">in </span><span class="s1">range(self.n_splits):</span>
            <span class="s3">yield </span><span class="s1">np.where(indices == f)[</span><span class="s5">0</span><span class="s1">]</span>

    <span class="s3">def </span><span class="s1">split(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y=</span><span class="s3">None, </span><span class="s1">groups=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Generate indices to split data into training and test set. 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) 
            Training data, where `n_samples` is the number of samples 
            and `n_features` is the number of features. 
 
        y : array-like of shape (n_samples,), default=None 
            The target variable for supervised learning problems. 
 
        groups : array-like of shape (n_samples,) 
            Group labels for the samples used while splitting the dataset into 
            train/test set. 
 
        Yields 
        ------ 
        train : ndarray 
            The training set indices for that split. 
 
        test : ndarray 
            The testing set indices for that split. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">super().split(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups)</span>


<span class="s3">class </span><span class="s1">StratifiedKFold(_BaseKFold):</span>
    <span class="s0">&quot;&quot;&quot;Stratified K-Folds cross-validator. 
 
    Provides train/test indices to split data in train/test sets. 
 
    This cross-validation object is a variation of KFold that returns 
    stratified folds. The folds are made by preserving the percentage of 
    samples for each class. 
 
    Read more in the :ref:`User Guide &lt;stratified_k_fold&gt;`. 
 
    For visualisation of cross-validation behaviour and 
    comparison between common scikit-learn split methods 
    refer to :ref:`sphx_glr_auto_examples_model_selection_plot_cv_indices.py` 
 
    Parameters 
    ---------- 
    n_splits : int, default=5 
        Number of folds. Must be at least 2. 
 
        .. versionchanged:: 0.22 
            ``n_splits`` default value changed from 3 to 5. 
 
    shuffle : bool, default=False 
        Whether to shuffle each class's samples before splitting into batches. 
        Note that the samples within each split will not be shuffled. 
 
    random_state : int, RandomState instance or None, default=None 
        When `shuffle` is True, `random_state` affects the ordering of the 
        indices, which controls the randomness of each fold for each class. 
        Otherwise, leave `random_state` as `None`. 
        Pass an int for reproducible output across multiple function calls. 
        See :term:`Glossary &lt;random_state&gt;`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from sklearn.model_selection import StratifiedKFold 
    &gt;&gt;&gt; X = np.array([[1, 2], [3, 4], [1, 2], [3, 4]]) 
    &gt;&gt;&gt; y = np.array([0, 0, 1, 1]) 
    &gt;&gt;&gt; skf = StratifiedKFold(n_splits=2) 
    &gt;&gt;&gt; skf.get_n_splits(X, y) 
    2 
    &gt;&gt;&gt; print(skf) 
    StratifiedKFold(n_splits=2, random_state=None, shuffle=False) 
    &gt;&gt;&gt; for i, (train_index, test_index) in enumerate(skf.split(X, y)): 
    ...     print(f&quot;Fold {i}:&quot;) 
    ...     print(f&quot;  Train: index={train_index}&quot;) 
    ...     print(f&quot;  Test:  index={test_index}&quot;) 
    Fold 0: 
      Train: index=[1 3] 
      Test:  index=[0 2] 
    Fold 1: 
      Train: index=[0 2] 
      Test:  index=[1 3] 
 
    Notes 
    ----- 
    The implementation is designed to: 
 
    * Generate test sets such that all contain the same distribution of 
      classes, or as close as possible. 
    * Be invariant to class label: relabelling ``y = [&quot;Happy&quot;, &quot;Sad&quot;]`` to 
      ``y = [1, 0]`` should not change the indices generated. 
    * Preserve order dependencies in the dataset ordering, when 
      ``shuffle=False``: all samples from class k in some test set were 
      contiguous in y, or separated in y by samples from classes other than k. 
    * Generate test sets where the smallest and largest differ by at most one 
      sample. 
 
    .. versionchanged:: 0.22 
        The previous implementation did not follow the last constraint. 
 
    See Also 
    -------- 
    RepeatedStratifiedKFold : Repeats Stratified K-Fold n times. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">n_splits=</span><span class="s5">5</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">shuffle=</span><span class="s3">False, </span><span class="s1">random_state=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">super().__init__(n_splits=n_splits</span><span class="s3">, </span><span class="s1">shuffle=shuffle</span><span class="s3">, </span><span class="s1">random_state=random_state)</span>

    <span class="s3">def </span><span class="s1">_make_test_folds(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">rng = check_random_state(self.random_state)</span>
        <span class="s1">y = np.asarray(y)</span>
        <span class="s1">type_of_target_y = type_of_target(y)</span>
        <span class="s1">allowed_target_types = (</span><span class="s4">&quot;binary&quot;</span><span class="s3">, </span><span class="s4">&quot;multiclass&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">type_of_target_y </span><span class="s3">not in </span><span class="s1">allowed_target_types:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;Supported target types are: {}. Got {!r} instead.&quot;</span><span class="s1">.format(</span>
                    <span class="s1">allowed_target_types</span><span class="s3">, </span><span class="s1">type_of_target_y</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

        <span class="s1">y = column_or_1d(y)</span>

        <span class="s1">_</span><span class="s3">, </span><span class="s1">y_idx</span><span class="s3">, </span><span class="s1">y_inv = np.unique(y</span><span class="s3">, </span><span class="s1">return_index=</span><span class="s3">True, </span><span class="s1">return_inverse=</span><span class="s3">True</span><span class="s1">)</span>
        <span class="s2"># y_inv encodes y according to lexicographic order. We invert y_idx to</span>
        <span class="s2"># map the classes so that they are encoded by order of appearance:</span>
        <span class="s2"># 0 represents the first label appearing in y, 1 the second, etc.</span>
        <span class="s1">_</span><span class="s3">, </span><span class="s1">class_perm = np.unique(y_idx</span><span class="s3">, </span><span class="s1">return_inverse=</span><span class="s3">True</span><span class="s1">)</span>
        <span class="s1">y_encoded = class_perm[y_inv]</span>

        <span class="s1">n_classes = len(y_idx)</span>
        <span class="s1">y_counts = np.bincount(y_encoded)</span>
        <span class="s1">min_groups = np.min(y_counts)</span>
        <span class="s3">if </span><span class="s1">np.all(self.n_splits &gt; y_counts):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;n_splits=%d cannot be greater than the&quot;</span>
                <span class="s4">&quot; number of members in each class.&quot; </span><span class="s1">% (self.n_splits)</span>
            <span class="s1">)</span>
        <span class="s3">if </span><span class="s1">self.n_splits &gt; min_groups:</span>
            <span class="s1">warnings.warn(</span>
                <span class="s4">&quot;The least populated class in y has only %d&quot;</span>
                <span class="s4">&quot; members, which is less than n_splits=%d.&quot;</span>
                <span class="s1">% (min_groups</span><span class="s3">, </span><span class="s1">self.n_splits)</span><span class="s3">,</span>
                <span class="s1">UserWarning</span><span class="s3">,</span>
            <span class="s1">)</span>

        <span class="s2"># Determine the optimal number of samples from each class in each fold,</span>
        <span class="s2"># using round robin over the sorted y. (This can be done direct from</span>
        <span class="s2"># counts, but that code is unreadable.)</span>
        <span class="s1">y_order = np.sort(y_encoded)</span>
        <span class="s1">allocation = np.asarray(</span>
            <span class="s1">[</span>
                <span class="s1">np.bincount(y_order[i :: self.n_splits]</span><span class="s3">, </span><span class="s1">minlength=n_classes)</span>
                <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(self.n_splits)</span>
            <span class="s1">]</span>
        <span class="s1">)</span>

        <span class="s2"># To maintain the data order dependencies as best as possible within</span>
        <span class="s2"># the stratification constraint, we assign samples from each class in</span>
        <span class="s2"># blocks (and then mess that up when shuffle=True).</span>
        <span class="s1">test_folds = np.empty(len(y)</span><span class="s3">, </span><span class="s1">dtype=</span><span class="s4">&quot;i&quot;</span><span class="s1">)</span>
        <span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">range(n_classes):</span>
            <span class="s2"># since the kth column of allocation stores the number of samples</span>
            <span class="s2"># of class k in each test set, this generates blocks of fold</span>
            <span class="s2"># indices corresponding to the allocation for class k.</span>
            <span class="s1">folds_for_class = np.arange(self.n_splits).repeat(allocation[:</span><span class="s3">, </span><span class="s1">k])</span>
            <span class="s3">if </span><span class="s1">self.shuffle:</span>
                <span class="s1">rng.shuffle(folds_for_class)</span>
            <span class="s1">test_folds[y_encoded == k] = folds_for_class</span>
        <span class="s3">return </span><span class="s1">test_folds</span>

    <span class="s3">def </span><span class="s1">_iter_test_masks(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y=</span><span class="s3">None, </span><span class="s1">groups=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">test_folds = self._make_test_folds(X</span><span class="s3">, </span><span class="s1">y)</span>
        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(self.n_splits):</span>
            <span class="s3">yield </span><span class="s1">test_folds == i</span>

    <span class="s3">def </span><span class="s1">split(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Generate indices to split data into training and test set. 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) 
            Training data, where `n_samples` is the number of samples 
            and `n_features` is the number of features. 
 
            Note that providing ``y`` is sufficient to generate the splits and 
            hence ``np.zeros(n_samples)`` may be used as a placeholder for 
            ``X`` instead of actual training data. 
 
        y : array-like of shape (n_samples,) 
            The target variable for supervised learning problems. 
            Stratification is done based on the y labels. 
 
        groups : object 
            Always ignored, exists for compatibility. 
 
        Yields 
        ------ 
        train : ndarray 
            The training set indices for that split. 
 
        test : ndarray 
            The testing set indices for that split. 
 
        Notes 
        ----- 
        Randomized CV splitters may return different results for each call of 
        split. You can make the results identical by setting `random_state` 
        to an integer. 
        &quot;&quot;&quot;</span>
        <span class="s1">y = check_array(y</span><span class="s3">, </span><span class="s1">input_name=</span><span class="s4">&quot;y&quot;</span><span class="s3">, </span><span class="s1">ensure_2d=</span><span class="s3">False, </span><span class="s1">dtype=</span><span class="s3">None</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">super().split(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups)</span>


<span class="s3">class </span><span class="s1">StratifiedGroupKFold(GroupsConsumerMixin</span><span class="s3">, </span><span class="s1">_BaseKFold):</span>
    <span class="s0">&quot;&quot;&quot;Stratified K-Folds iterator variant with non-overlapping groups. 
 
    This cross-validation object is a variation of StratifiedKFold attempts to 
    return stratified folds with non-overlapping groups. The folds are made by 
    preserving the percentage of samples for each class. 
 
    Each group will appear exactly once in the test set across all folds (the 
    number of distinct groups has to be at least equal to the number of folds). 
 
    The difference between :class:`~sklearn.model_selection.GroupKFold` 
    and :class:`~sklearn.model_selection.StratifiedGroupKFold` is that 
    the former attempts to create balanced folds such that the number of 
    distinct groups is approximately the same in each fold, whereas 
    StratifiedGroupKFold attempts to create folds which preserve the 
    percentage of samples for each class as much as possible given the 
    constraint of non-overlapping groups between splits. 
 
    Read more in the :ref:`User Guide &lt;cross_validation&gt;`. 
 
    For visualisation of cross-validation behaviour and 
    comparison between common scikit-learn split methods 
    refer to :ref:`sphx_glr_auto_examples_model_selection_plot_cv_indices.py` 
 
    Parameters 
    ---------- 
    n_splits : int, default=5 
        Number of folds. Must be at least 2. 
 
    shuffle : bool, default=False 
        Whether to shuffle each class's samples before splitting into batches. 
        Note that the samples within each split will not be shuffled. 
        This implementation can only shuffle groups that have approximately the 
        same y distribution, no global shuffle will be performed. 
 
    random_state : int or RandomState instance, default=None 
        When `shuffle` is True, `random_state` affects the ordering of the 
        indices, which controls the randomness of each fold for each class. 
        Otherwise, leave `random_state` as `None`. 
        Pass an int for reproducible output across multiple function calls. 
        See :term:`Glossary &lt;random_state&gt;`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from sklearn.model_selection import StratifiedGroupKFold 
    &gt;&gt;&gt; X = np.ones((17, 2)) 
    &gt;&gt;&gt; y = np.array([0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]) 
    &gt;&gt;&gt; groups = np.array([1, 1, 2, 2, 3, 3, 3, 4, 5, 5, 5, 5, 6, 6, 7, 8, 8]) 
    &gt;&gt;&gt; sgkf = StratifiedGroupKFold(n_splits=3) 
    &gt;&gt;&gt; sgkf.get_n_splits(X, y) 
    3 
    &gt;&gt;&gt; print(sgkf) 
    StratifiedGroupKFold(n_splits=3, random_state=None, shuffle=False) 
    &gt;&gt;&gt; for i, (train_index, test_index) in enumerate(sgkf.split(X, y, groups)): 
    ...     print(f&quot;Fold {i}:&quot;) 
    ...     print(f&quot;  Train: index={train_index}&quot;) 
    ...     print(f&quot;         group={groups[train_index]}&quot;) 
    ...     print(f&quot;  Test:  index={test_index}&quot;) 
    ...     print(f&quot;         group={groups[test_index]}&quot;) 
    Fold 0: 
      Train: index=[ 0  1  2  3  7  8  9 10 11 15 16] 
             group=[1 1 2 2 4 5 5 5 5 8 8] 
      Test:  index=[ 4  5  6 12 13 14] 
             group=[3 3 3 6 6 7] 
    Fold 1: 
      Train: index=[ 4  5  6  7  8  9 10 11 12 13 14] 
             group=[3 3 3 4 5 5 5 5 6 6 7] 
      Test:  index=[ 0  1  2  3 15 16] 
             group=[1 1 2 2 8 8] 
    Fold 2: 
      Train: index=[ 0  1  2  3  4  5  6 12 13 14 15 16] 
             group=[1 1 2 2 3 3 3 6 6 7 8 8] 
      Test:  index=[ 7  8  9 10 11] 
             group=[4 5 5 5 5] 
 
    Notes 
    ----- 
    The implementation is designed to: 
 
    * Mimic the behavior of StratifiedKFold as much as possible for trivial 
      groups (e.g. when each group contains only one sample). 
    * Be invariant to class label: relabelling ``y = [&quot;Happy&quot;, &quot;Sad&quot;]`` to 
      ``y = [1, 0]`` should not change the indices generated. 
    * Stratify based on samples as much as possible while keeping 
      non-overlapping groups constraint. That means that in some cases when 
      there is a small number of groups containing a large number of samples 
      the stratification will not be possible and the behavior will be close 
      to GroupKFold. 
 
    See also 
    -------- 
    StratifiedKFold: Takes class information into account to build folds which 
        retain class distributions (for binary or multiclass classification 
        tasks). 
 
    GroupKFold: K-fold iterator variant with non-overlapping groups. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">n_splits=</span><span class="s5">5</span><span class="s3">, </span><span class="s1">shuffle=</span><span class="s3">False, </span><span class="s1">random_state=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">super().__init__(n_splits=n_splits</span><span class="s3">, </span><span class="s1">shuffle=shuffle</span><span class="s3">, </span><span class="s1">random_state=random_state)</span>

    <span class="s3">def </span><span class="s1">_iter_test_indices(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups):</span>
        <span class="s2"># Implementation is based on this kaggle kernel:</span>
        <span class="s2"># https://www.kaggle.com/jakubwasikowski/stratified-group-k-fold-cross-validation</span>
        <span class="s2"># and is a subject to Apache 2.0 License. You may obtain a copy of the</span>
        <span class="s2"># License at http://www.apache.org/licenses/LICENSE-2.0</span>
        <span class="s2"># Changelist:</span>
        <span class="s2"># - Refactored function to a class following scikit-learn KFold</span>
        <span class="s2">#   interface.</span>
        <span class="s2"># - Added heuristic for assigning group to the least populated fold in</span>
        <span class="s2">#   cases when all other criteria are equal</span>
        <span class="s2"># - Swtch from using python ``Counter`` to ``np.unique`` to get class</span>
        <span class="s2">#   distribution</span>
        <span class="s2"># - Added scikit-learn checks for input: checking that target is binary</span>
        <span class="s2">#   or multiclass, checking passed random state, checking that number</span>
        <span class="s2">#   of splits is less than number of members in each class, checking</span>
        <span class="s2">#   that least populated class has more members than there are splits.</span>
        <span class="s1">rng = check_random_state(self.random_state)</span>
        <span class="s1">y = np.asarray(y)</span>
        <span class="s1">type_of_target_y = type_of_target(y)</span>
        <span class="s1">allowed_target_types = (</span><span class="s4">&quot;binary&quot;</span><span class="s3">, </span><span class="s4">&quot;multiclass&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">type_of_target_y </span><span class="s3">not in </span><span class="s1">allowed_target_types:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;Supported target types are: {}. Got {!r} instead.&quot;</span><span class="s1">.format(</span>
                    <span class="s1">allowed_target_types</span><span class="s3">, </span><span class="s1">type_of_target_y</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

        <span class="s1">y = column_or_1d(y)</span>
        <span class="s1">_</span><span class="s3">, </span><span class="s1">y_inv</span><span class="s3">, </span><span class="s1">y_cnt = np.unique(y</span><span class="s3">, </span><span class="s1">return_inverse=</span><span class="s3">True, </span><span class="s1">return_counts=</span><span class="s3">True</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">np.all(self.n_splits &gt; y_cnt):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;n_splits=%d cannot be greater than the&quot;</span>
                <span class="s4">&quot; number of members in each class.&quot; </span><span class="s1">% (self.n_splits)</span>
            <span class="s1">)</span>
        <span class="s1">n_smallest_class = np.min(y_cnt)</span>
        <span class="s3">if </span><span class="s1">self.n_splits &gt; n_smallest_class:</span>
            <span class="s1">warnings.warn(</span>
                <span class="s4">&quot;The least populated class in y has only %d&quot;</span>
                <span class="s4">&quot; members, which is less than n_splits=%d.&quot;</span>
                <span class="s1">% (n_smallest_class</span><span class="s3">, </span><span class="s1">self.n_splits)</span><span class="s3">,</span>
                <span class="s1">UserWarning</span><span class="s3">,</span>
            <span class="s1">)</span>
        <span class="s1">n_classes = len(y_cnt)</span>

        <span class="s1">_</span><span class="s3">, </span><span class="s1">groups_inv</span><span class="s3">, </span><span class="s1">groups_cnt = np.unique(</span>
            <span class="s1">groups</span><span class="s3">, </span><span class="s1">return_inverse=</span><span class="s3">True, </span><span class="s1">return_counts=</span><span class="s3">True</span>
        <span class="s1">)</span>
        <span class="s1">y_counts_per_group = np.zeros((len(groups_cnt)</span><span class="s3">, </span><span class="s1">n_classes))</span>
        <span class="s3">for </span><span class="s1">class_idx</span><span class="s3">, </span><span class="s1">group_idx </span><span class="s3">in </span><span class="s1">zip(y_inv</span><span class="s3">, </span><span class="s1">groups_inv):</span>
            <span class="s1">y_counts_per_group[group_idx</span><span class="s3">, </span><span class="s1">class_idx] += </span><span class="s5">1</span>

        <span class="s1">y_counts_per_fold = np.zeros((self.n_splits</span><span class="s3">, </span><span class="s1">n_classes))</span>
        <span class="s1">groups_per_fold = defaultdict(set)</span>

        <span class="s3">if </span><span class="s1">self.shuffle:</span>
            <span class="s1">rng.shuffle(y_counts_per_group)</span>

        <span class="s2"># Stable sort to keep shuffled order for groups with the same</span>
        <span class="s2"># class distribution variance</span>
        <span class="s1">sorted_groups_idx = np.argsort(</span>
            <span class="s1">-np.std(y_counts_per_group</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">kind=</span><span class="s4">&quot;mergesort&quot;</span>
        <span class="s1">)</span>

        <span class="s3">for </span><span class="s1">group_idx </span><span class="s3">in </span><span class="s1">sorted_groups_idx:</span>
            <span class="s1">group_y_counts = y_counts_per_group[group_idx]</span>
            <span class="s1">best_fold = self._find_best_fold(</span>
                <span class="s1">y_counts_per_fold=y_counts_per_fold</span><span class="s3">,</span>
                <span class="s1">y_cnt=y_cnt</span><span class="s3">,</span>
                <span class="s1">group_y_counts=group_y_counts</span><span class="s3">,</span>
            <span class="s1">)</span>
            <span class="s1">y_counts_per_fold[best_fold] += group_y_counts</span>
            <span class="s1">groups_per_fold[best_fold].add(group_idx)</span>

        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(self.n_splits):</span>
            <span class="s1">test_indices = [</span>
                <span class="s1">idx</span>
                <span class="s3">for </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">group_idx </span><span class="s3">in </span><span class="s1">enumerate(groups_inv)</span>
                <span class="s3">if </span><span class="s1">group_idx </span><span class="s3">in </span><span class="s1">groups_per_fold[i]</span>
            <span class="s1">]</span>
            <span class="s3">yield </span><span class="s1">test_indices</span>

    <span class="s3">def </span><span class="s1">_find_best_fold(self</span><span class="s3">, </span><span class="s1">y_counts_per_fold</span><span class="s3">, </span><span class="s1">y_cnt</span><span class="s3">, </span><span class="s1">group_y_counts):</span>
        <span class="s1">best_fold = </span><span class="s3">None</span>
        <span class="s1">min_eval = np.inf</span>
        <span class="s1">min_samples_in_fold = np.inf</span>
        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(self.n_splits):</span>
            <span class="s1">y_counts_per_fold[i] += group_y_counts</span>
            <span class="s2"># Summarise the distribution over classes in each proposed fold</span>
            <span class="s1">std_per_class = np.std(y_counts_per_fold / y_cnt.reshape(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">axis=</span><span class="s5">0</span><span class="s1">)</span>
            <span class="s1">y_counts_per_fold[i] -= group_y_counts</span>
            <span class="s1">fold_eval = np.mean(std_per_class)</span>
            <span class="s1">samples_in_fold = np.sum(y_counts_per_fold[i])</span>
            <span class="s1">is_current_fold_better = (</span>
                <span class="s1">fold_eval &lt; min_eval</span>
                <span class="s3">or </span><span class="s1">np.isclose(fold_eval</span><span class="s3">, </span><span class="s1">min_eval)</span>
                <span class="s3">and </span><span class="s1">samples_in_fold &lt; min_samples_in_fold</span>
            <span class="s1">)</span>
            <span class="s3">if </span><span class="s1">is_current_fold_better:</span>
                <span class="s1">min_eval = fold_eval</span>
                <span class="s1">min_samples_in_fold = samples_in_fold</span>
                <span class="s1">best_fold = i</span>
        <span class="s3">return </span><span class="s1">best_fold</span>


<span class="s3">class </span><span class="s1">TimeSeriesSplit(_BaseKFold):</span>
    <span class="s0">&quot;&quot;&quot;Time Series cross-validator 
 
    Provides train/test indices to split time series data samples 
    that are observed at fixed time intervals, in train/test sets. 
    In each split, test indices must be higher than before, and thus shuffling 
    in cross validator is inappropriate. 
 
    This cross-validation object is a variation of :class:`KFold`. 
    In the kth split, it returns first k folds as train set and the 
    (k+1)th fold as test set. 
 
    Note that unlike standard cross-validation methods, successive 
    training sets are supersets of those that come before them. 
 
    Read more in the :ref:`User Guide &lt;time_series_split&gt;`. 
 
    For visualisation of cross-validation behaviour and 
    comparison between common scikit-learn split methods 
    refer to :ref:`sphx_glr_auto_examples_model_selection_plot_cv_indices.py` 
 
    .. versionadded:: 0.18 
 
    Parameters 
    ---------- 
    n_splits : int, default=5 
        Number of splits. Must be at least 2. 
 
        .. versionchanged:: 0.22 
            ``n_splits`` default value changed from 3 to 5. 
 
    max_train_size : int, default=None 
        Maximum size for a single training set. 
 
    test_size : int, default=None 
        Used to limit the size of the test set. Defaults to 
        ``n_samples // (n_splits + 1)``, which is the maximum allowed value 
        with ``gap=0``. 
 
        .. versionadded:: 0.24 
 
    gap : int, default=0 
        Number of samples to exclude from the end of each train set before 
        the test set. 
 
        .. versionadded:: 0.24 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from sklearn.model_selection import TimeSeriesSplit 
    &gt;&gt;&gt; X = np.array([[1, 2], [3, 4], [1, 2], [3, 4], [1, 2], [3, 4]]) 
    &gt;&gt;&gt; y = np.array([1, 2, 3, 4, 5, 6]) 
    &gt;&gt;&gt; tscv = TimeSeriesSplit() 
    &gt;&gt;&gt; print(tscv) 
    TimeSeriesSplit(gap=0, max_train_size=None, n_splits=5, test_size=None) 
    &gt;&gt;&gt; for i, (train_index, test_index) in enumerate(tscv.split(X)): 
    ...     print(f&quot;Fold {i}:&quot;) 
    ...     print(f&quot;  Train: index={train_index}&quot;) 
    ...     print(f&quot;  Test:  index={test_index}&quot;) 
    Fold 0: 
      Train: index=[0] 
      Test:  index=[1] 
    Fold 1: 
      Train: index=[0 1] 
      Test:  index=[2] 
    Fold 2: 
      Train: index=[0 1 2] 
      Test:  index=[3] 
    Fold 3: 
      Train: index=[0 1 2 3] 
      Test:  index=[4] 
    Fold 4: 
      Train: index=[0 1 2 3 4] 
      Test:  index=[5] 
    &gt;&gt;&gt; # Fix test_size to 2 with 12 samples 
    &gt;&gt;&gt; X = np.random.randn(12, 2) 
    &gt;&gt;&gt; y = np.random.randint(0, 2, 12) 
    &gt;&gt;&gt; tscv = TimeSeriesSplit(n_splits=3, test_size=2) 
    &gt;&gt;&gt; for i, (train_index, test_index) in enumerate(tscv.split(X)): 
    ...     print(f&quot;Fold {i}:&quot;) 
    ...     print(f&quot;  Train: index={train_index}&quot;) 
    ...     print(f&quot;  Test:  index={test_index}&quot;) 
    Fold 0: 
      Train: index=[0 1 2 3 4 5] 
      Test:  index=[6 7] 
    Fold 1: 
      Train: index=[0 1 2 3 4 5 6 7] 
      Test:  index=[8 9] 
    Fold 2: 
      Train: index=[0 1 2 3 4 5 6 7 8 9] 
      Test:  index=[10 11] 
    &gt;&gt;&gt; # Add in a 2 period gap 
    &gt;&gt;&gt; tscv = TimeSeriesSplit(n_splits=3, test_size=2, gap=2) 
    &gt;&gt;&gt; for i, (train_index, test_index) in enumerate(tscv.split(X)): 
    ...     print(f&quot;Fold {i}:&quot;) 
    ...     print(f&quot;  Train: index={train_index}&quot;) 
    ...     print(f&quot;  Test:  index={test_index}&quot;) 
    Fold 0: 
      Train: index=[0 1 2 3] 
      Test:  index=[6 7] 
    Fold 1: 
      Train: index=[0 1 2 3 4 5] 
      Test:  index=[8 9] 
    Fold 2: 
      Train: index=[0 1 2 3 4 5 6 7] 
      Test:  index=[10 11] 
 
    Notes 
    ----- 
    The training set has size ``i * n_samples // (n_splits + 1) 
    + n_samples % (n_splits + 1)`` in the ``i`` th split, 
    with a test set of size ``n_samples//(n_splits + 1)`` by default, 
    where ``n_samples`` is the number of samples. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">n_splits=</span><span class="s5">5</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">max_train_size=</span><span class="s3">None, </span><span class="s1">test_size=</span><span class="s3">None, </span><span class="s1">gap=</span><span class="s5">0</span><span class="s1">):</span>
        <span class="s1">super().__init__(n_splits</span><span class="s3">, </span><span class="s1">shuffle=</span><span class="s3">False, </span><span class="s1">random_state=</span><span class="s3">None</span><span class="s1">)</span>
        <span class="s1">self.max_train_size = max_train_size</span>
        <span class="s1">self.test_size = test_size</span>
        <span class="s1">self.gap = gap</span>

    <span class="s3">def </span><span class="s1">split(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y=</span><span class="s3">None, </span><span class="s1">groups=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Generate indices to split data into training and test set. 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) 
            Training data, where `n_samples` is the number of samples 
            and `n_features` is the number of features. 
 
        y : array-like of shape (n_samples,) 
            Always ignored, exists for compatibility. 
 
        groups : array-like of shape (n_samples,) 
            Always ignored, exists for compatibility. 
 
        Yields 
        ------ 
        train : ndarray 
            The training set indices for that split. 
 
        test : ndarray 
            The testing set indices for that split. 
        &quot;&quot;&quot;</span>
        <span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups = indexable(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups)</span>
        <span class="s1">n_samples = _num_samples(X)</span>
        <span class="s1">n_splits = self.n_splits</span>
        <span class="s1">n_folds = n_splits + </span><span class="s5">1</span>
        <span class="s1">gap = self.gap</span>
        <span class="s1">test_size = (</span>
            <span class="s1">self.test_size </span><span class="s3">if </span><span class="s1">self.test_size </span><span class="s3">is not None else </span><span class="s1">n_samples // n_folds</span>
        <span class="s1">)</span>

        <span class="s2"># Make sure we have enough samples for the given split parameters</span>
        <span class="s3">if </span><span class="s1">n_folds &gt; n_samples:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span>
                <span class="s4">f&quot;Cannot have number of folds=</span><span class="s3">{</span><span class="s1">n_folds</span><span class="s3">} </span><span class="s4">greater&quot;</span>
                <span class="s4">f&quot; than the number of samples=</span><span class="s3">{</span><span class="s1">n_samples</span><span class="s3">}</span><span class="s4">.&quot;</span>
            <span class="s1">)</span>
        <span class="s3">if </span><span class="s1">n_samples - gap - (test_size * n_splits) &lt;= </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span>
                <span class="s4">f&quot;Too many splits=</span><span class="s3">{</span><span class="s1">n_splits</span><span class="s3">} </span><span class="s4">for number of samples&quot;</span>
                <span class="s4">f&quot;=</span><span class="s3">{</span><span class="s1">n_samples</span><span class="s3">} </span><span class="s4">with test_size=</span><span class="s3">{</span><span class="s1">test_size</span><span class="s3">} </span><span class="s4">and gap=</span><span class="s3">{</span><span class="s1">gap</span><span class="s3">}</span><span class="s4">.&quot;</span>
            <span class="s1">)</span>

        <span class="s1">indices = np.arange(n_samples)</span>
        <span class="s1">test_starts = range(n_samples - n_splits * test_size</span><span class="s3">, </span><span class="s1">n_samples</span><span class="s3">, </span><span class="s1">test_size)</span>

        <span class="s3">for </span><span class="s1">test_start </span><span class="s3">in </span><span class="s1">test_starts:</span>
            <span class="s1">train_end = test_start - gap</span>
            <span class="s3">if </span><span class="s1">self.max_train_size </span><span class="s3">and </span><span class="s1">self.max_train_size &lt; train_end:</span>
                <span class="s3">yield </span><span class="s1">(</span>
                    <span class="s1">indices[train_end - self.max_train_size : train_end]</span><span class="s3">,</span>
                    <span class="s1">indices[test_start : test_start + test_size]</span><span class="s3">,</span>
                <span class="s1">)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">yield </span><span class="s1">(</span>
                    <span class="s1">indices[:train_end]</span><span class="s3">,</span>
                    <span class="s1">indices[test_start : test_start + test_size]</span><span class="s3">,</span>
                <span class="s1">)</span>


<span class="s3">class </span><span class="s1">LeaveOneGroupOut(GroupsConsumerMixin</span><span class="s3">, </span><span class="s1">BaseCrossValidator):</span>
    <span class="s0">&quot;&quot;&quot;Leave One Group Out cross-validator 
 
    Provides train/test indices to split data such that each training set is 
    comprised of all samples except ones belonging to one specific group. 
    Arbitrary domain specific group information is provided an array integers 
    that encodes the group of each sample. 
 
    For instance the groups could be the year of collection of the samples 
    and thus allow for cross-validation against time-based splits. 
 
    Read more in the :ref:`User Guide &lt;leave_one_group_out&gt;`. 
 
    Notes 
    ----- 
    Splits are ordered according to the index of the group left out. The first 
    split has testing set consisting of the group whose index in `groups` is 
    lowest, and so on. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from sklearn.model_selection import LeaveOneGroupOut 
    &gt;&gt;&gt; X = np.array([[1, 2], [3, 4], [5, 6], [7, 8]]) 
    &gt;&gt;&gt; y = np.array([1, 2, 1, 2]) 
    &gt;&gt;&gt; groups = np.array([1, 1, 2, 2]) 
    &gt;&gt;&gt; logo = LeaveOneGroupOut() 
    &gt;&gt;&gt; logo.get_n_splits(X, y, groups) 
    2 
    &gt;&gt;&gt; logo.get_n_splits(groups=groups)  # 'groups' is always required 
    2 
    &gt;&gt;&gt; print(logo) 
    LeaveOneGroupOut() 
    &gt;&gt;&gt; for i, (train_index, test_index) in enumerate(logo.split(X, y, groups)): 
    ...     print(f&quot;Fold {i}:&quot;) 
    ...     print(f&quot;  Train: index={train_index}, group={groups[train_index]}&quot;) 
    ...     print(f&quot;  Test:  index={test_index}, group={groups[test_index]}&quot;) 
    Fold 0: 
      Train: index=[2 3], group=[2 2] 
      Test:  index=[0 1], group=[1 1] 
    Fold 1: 
      Train: index=[0 1], group=[1 1] 
      Test:  index=[2 3], group=[2 2] 
 
    See also 
    -------- 
    GroupKFold: K-fold iterator variant with non-overlapping groups. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">_iter_test_masks(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups):</span>
        <span class="s3">if </span><span class="s1">groups </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;The 'groups' parameter should not be None.&quot;</span><span class="s1">)</span>
        <span class="s2"># We make a copy of groups to avoid side-effects during iteration</span>
        <span class="s1">groups = check_array(</span>
            <span class="s1">groups</span><span class="s3">, </span><span class="s1">input_name=</span><span class="s4">&quot;groups&quot;</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">True, </span><span class="s1">ensure_2d=</span><span class="s3">False, </span><span class="s1">dtype=</span><span class="s3">None</span>
        <span class="s1">)</span>
        <span class="s1">unique_groups = np.unique(groups)</span>
        <span class="s3">if </span><span class="s1">len(unique_groups) &lt;= </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;The groups parameter contains fewer than 2 unique groups &quot;</span>
                <span class="s4">&quot;(%s). LeaveOneGroupOut expects at least 2.&quot; </span><span class="s1">% unique_groups</span>
            <span class="s1">)</span>
        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">unique_groups:</span>
            <span class="s3">yield </span><span class="s1">groups == i</span>

    <span class="s3">def </span><span class="s1">get_n_splits(self</span><span class="s3">, </span><span class="s1">X=</span><span class="s3">None, </span><span class="s1">y=</span><span class="s3">None, </span><span class="s1">groups=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Returns the number of splitting iterations in the cross-validator 
 
        Parameters 
        ---------- 
        X : object 
            Always ignored, exists for compatibility. 
 
        y : object 
            Always ignored, exists for compatibility. 
 
        groups : array-like of shape (n_samples,) 
            Group labels for the samples used while splitting the dataset into 
            train/test set. This 'groups' parameter must always be specified to 
            calculate the number of splits, though the other parameters can be 
            omitted. 
 
        Returns 
        ------- 
        n_splits : int 
            Returns the number of splitting iterations in the cross-validator. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">groups </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;The 'groups' parameter should not be None.&quot;</span><span class="s1">)</span>
        <span class="s1">groups = check_array(groups</span><span class="s3">, </span><span class="s1">input_name=</span><span class="s4">&quot;groups&quot;</span><span class="s3">, </span><span class="s1">ensure_2d=</span><span class="s3">False, </span><span class="s1">dtype=</span><span class="s3">None</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">len(np.unique(groups))</span>

    <span class="s3">def </span><span class="s1">split(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y=</span><span class="s3">None, </span><span class="s1">groups=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Generate indices to split data into training and test set. 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) 
            Training data, where `n_samples` is the number of samples 
            and `n_features` is the number of features. 
 
        y : array-like of shape (n_samples,), default=None 
            The target variable for supervised learning problems. 
 
        groups : array-like of shape (n_samples,) 
            Group labels for the samples used while splitting the dataset into 
            train/test set. 
 
        Yields 
        ------ 
        train : ndarray 
            The training set indices for that split. 
 
        test : ndarray 
            The testing set indices for that split. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">super().split(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups)</span>


<span class="s3">class </span><span class="s1">LeavePGroupsOut(GroupsConsumerMixin</span><span class="s3">, </span><span class="s1">BaseCrossValidator):</span>
    <span class="s0">&quot;&quot;&quot;Leave P Group(s) Out cross-validator 
 
    Provides train/test indices to split data according to a third-party 
    provided group. This group information can be used to encode arbitrary 
    domain specific stratifications of the samples as integers. 
 
    For instance the groups could be the year of collection of the samples 
    and thus allow for cross-validation against time-based splits. 
 
    The difference between LeavePGroupsOut and LeaveOneGroupOut is that 
    the former builds the test sets with all the samples assigned to 
    ``p`` different values of the groups while the latter uses samples 
    all assigned the same groups. 
 
    Read more in the :ref:`User Guide &lt;leave_p_groups_out&gt;`. 
 
    Parameters 
    ---------- 
    n_groups : int 
        Number of groups (``p``) to leave out in the test split. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from sklearn.model_selection import LeavePGroupsOut 
    &gt;&gt;&gt; X = np.array([[1, 2], [3, 4], [5, 6]]) 
    &gt;&gt;&gt; y = np.array([1, 2, 1]) 
    &gt;&gt;&gt; groups = np.array([1, 2, 3]) 
    &gt;&gt;&gt; lpgo = LeavePGroupsOut(n_groups=2) 
    &gt;&gt;&gt; lpgo.get_n_splits(X, y, groups) 
    3 
    &gt;&gt;&gt; lpgo.get_n_splits(groups=groups)  # 'groups' is always required 
    3 
    &gt;&gt;&gt; print(lpgo) 
    LeavePGroupsOut(n_groups=2) 
    &gt;&gt;&gt; for i, (train_index, test_index) in enumerate(lpgo.split(X, y, groups)): 
    ...     print(f&quot;Fold {i}:&quot;) 
    ...     print(f&quot;  Train: index={train_index}, group={groups[train_index]}&quot;) 
    ...     print(f&quot;  Test:  index={test_index}, group={groups[test_index]}&quot;) 
    Fold 0: 
      Train: index=[2], group=[3] 
      Test:  index=[0 1], group=[1 2] 
    Fold 1: 
      Train: index=[1], group=[2] 
      Test:  index=[0 2], group=[1 3] 
    Fold 2: 
      Train: index=[0], group=[1] 
      Test:  index=[1 2], group=[2 3] 
 
    See Also 
    -------- 
    GroupKFold : K-fold iterator variant with non-overlapping groups. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">n_groups):</span>
        <span class="s1">self.n_groups = n_groups</span>

    <span class="s3">def </span><span class="s1">_iter_test_masks(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups):</span>
        <span class="s3">if </span><span class="s1">groups </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;The 'groups' parameter should not be None.&quot;</span><span class="s1">)</span>
        <span class="s1">groups = check_array(</span>
            <span class="s1">groups</span><span class="s3">, </span><span class="s1">input_name=</span><span class="s4">&quot;groups&quot;</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">True, </span><span class="s1">ensure_2d=</span><span class="s3">False, </span><span class="s1">dtype=</span><span class="s3">None</span>
        <span class="s1">)</span>
        <span class="s1">unique_groups = np.unique(groups)</span>
        <span class="s3">if </span><span class="s1">self.n_groups &gt;= len(unique_groups):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;The groups parameter contains fewer than (or equal to) &quot;</span>
                <span class="s4">&quot;n_groups (%d) numbers of unique groups (%s). LeavePGroupsOut &quot;</span>
                <span class="s4">&quot;expects that at least n_groups + 1 (%d) unique groups be &quot;</span>
                <span class="s4">&quot;present&quot; </span><span class="s1">% (self.n_groups</span><span class="s3">, </span><span class="s1">unique_groups</span><span class="s3">, </span><span class="s1">self.n_groups + </span><span class="s5">1</span><span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s1">combi = combinations(range(len(unique_groups))</span><span class="s3">, </span><span class="s1">self.n_groups)</span>
        <span class="s3">for </span><span class="s1">indices </span><span class="s3">in </span><span class="s1">combi:</span>
            <span class="s1">test_index = np.zeros(_num_samples(X)</span><span class="s3">, </span><span class="s1">dtype=bool)</span>
            <span class="s3">for </span><span class="s1">l </span><span class="s3">in </span><span class="s1">unique_groups[np.array(indices)]:</span>
                <span class="s1">test_index[groups == l] = </span><span class="s3">True</span>
            <span class="s3">yield </span><span class="s1">test_index</span>

    <span class="s3">def </span><span class="s1">get_n_splits(self</span><span class="s3">, </span><span class="s1">X=</span><span class="s3">None, </span><span class="s1">y=</span><span class="s3">None, </span><span class="s1">groups=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Returns the number of splitting iterations in the cross-validator 
 
        Parameters 
        ---------- 
        X : object 
            Always ignored, exists for compatibility. 
 
        y : object 
            Always ignored, exists for compatibility. 
 
        groups : array-like of shape (n_samples,) 
            Group labels for the samples used while splitting the dataset into 
            train/test set. This 'groups' parameter must always be specified to 
            calculate the number of splits, though the other parameters can be 
            omitted. 
 
        Returns 
        ------- 
        n_splits : int 
            Returns the number of splitting iterations in the cross-validator. 
        &quot;&quot;&quot;</span>
        <span class="s3">if </span><span class="s1">groups </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;The 'groups' parameter should not be None.&quot;</span><span class="s1">)</span>
        <span class="s1">groups = check_array(groups</span><span class="s3">, </span><span class="s1">input_name=</span><span class="s4">&quot;groups&quot;</span><span class="s3">, </span><span class="s1">ensure_2d=</span><span class="s3">False, </span><span class="s1">dtype=</span><span class="s3">None</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">int(comb(len(np.unique(groups))</span><span class="s3">, </span><span class="s1">self.n_groups</span><span class="s3">, </span><span class="s1">exact=</span><span class="s3">True</span><span class="s1">))</span>

    <span class="s3">def </span><span class="s1">split(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y=</span><span class="s3">None, </span><span class="s1">groups=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Generate indices to split data into training and test set. 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) 
            Training data, where `n_samples` is the number of samples 
            and `n_features` is the number of features. 
 
        y : array-like of shape (n_samples,), default=None 
            The target variable for supervised learning problems. 
 
        groups : array-like of shape (n_samples,) 
            Group labels for the samples used while splitting the dataset into 
            train/test set. 
 
        Yields 
        ------ 
        train : ndarray 
            The training set indices for that split. 
 
        test : ndarray 
            The testing set indices for that split. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">super().split(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups)</span>


<span class="s3">class </span><span class="s1">_RepeatedSplits(_MetadataRequester</span><span class="s3">, </span><span class="s1">metaclass=ABCMeta):</span>
    <span class="s0">&quot;&quot;&quot;Repeated splits for an arbitrary randomized CV splitter. 
 
    Repeats splits for cross-validators n times with different randomization 
    in each repetition. 
 
    Parameters 
    ---------- 
    cv : callable 
        Cross-validator class. 
 
    n_repeats : int, default=10 
        Number of times cross-validator needs to be repeated. 
 
    random_state : int, RandomState instance or None, default=None 
        Passes `random_state` to the arbitrary repeating cross validator. 
        Pass an int for reproducible output across multiple function calls. 
        See :term:`Glossary &lt;random_state&gt;`. 
 
    **cvargs : additional params 
        Constructor parameters for cv. Must not contain random_state 
        and shuffle. 
    &quot;&quot;&quot;</span>

    <span class="s2"># This indicates that by default CV splitters don't have a &quot;groups&quot; kwarg,</span>
    <span class="s2"># unless indicated by inheriting from ``GroupsConsumerMixin``.</span>
    <span class="s2"># This also prevents ``set_split_request`` to be generated for splitters</span>
    <span class="s2"># which don't support ``groups``.</span>
    <span class="s1">__metadata_request__split = {</span><span class="s4">&quot;groups&quot;</span><span class="s1">: metadata_routing.UNUSED}</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">cv</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">n_repeats=</span><span class="s5">10</span><span class="s3">, </span><span class="s1">random_state=</span><span class="s3">None, </span><span class="s1">**cvargs):</span>
        <span class="s3">if not </span><span class="s1">isinstance(n_repeats</span><span class="s3">, </span><span class="s1">numbers.Integral):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Number of repetitions must be of Integral type.&quot;</span><span class="s1">)</span>

        <span class="s3">if </span><span class="s1">n_repeats &lt;= </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Number of repetitions must be greater than 0.&quot;</span><span class="s1">)</span>

        <span class="s3">if </span><span class="s1">any(key </span><span class="s3">in </span><span class="s1">cvargs </span><span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">(</span><span class="s4">&quot;random_state&quot;</span><span class="s3">, </span><span class="s4">&quot;shuffle&quot;</span><span class="s1">)):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;cvargs must not contain random_state or shuffle.&quot;</span><span class="s1">)</span>

        <span class="s1">self.cv = cv</span>
        <span class="s1">self.n_repeats = n_repeats</span>
        <span class="s1">self.random_state = random_state</span>
        <span class="s1">self.cvargs = cvargs</span>

    <span class="s3">def </span><span class="s1">split(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y=</span><span class="s3">None, </span><span class="s1">groups=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Generates indices to split data into training and test set. 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) 
            Training data, where `n_samples` is the number of samples 
            and `n_features` is the number of features. 
 
        y : array-like of shape (n_samples,) 
            The target variable for supervised learning problems. 
 
        groups : array-like of shape (n_samples,), default=None 
            Group labels for the samples used while splitting the dataset into 
            train/test set. 
 
        Yields 
        ------ 
        train : ndarray 
            The training set indices for that split. 
 
        test : ndarray 
            The testing set indices for that split. 
        &quot;&quot;&quot;</span>
        <span class="s1">n_repeats = self.n_repeats</span>
        <span class="s1">rng = check_random_state(self.random_state)</span>

        <span class="s3">for </span><span class="s1">idx </span><span class="s3">in </span><span class="s1">range(n_repeats):</span>
            <span class="s1">cv = self.cv(random_state=rng</span><span class="s3">, </span><span class="s1">shuffle=</span><span class="s3">True, </span><span class="s1">**self.cvargs)</span>
            <span class="s3">for </span><span class="s1">train_index</span><span class="s3">, </span><span class="s1">test_index </span><span class="s3">in </span><span class="s1">cv.split(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups):</span>
                <span class="s3">yield </span><span class="s1">train_index</span><span class="s3">, </span><span class="s1">test_index</span>

    <span class="s3">def </span><span class="s1">get_n_splits(self</span><span class="s3">, </span><span class="s1">X=</span><span class="s3">None, </span><span class="s1">y=</span><span class="s3">None, </span><span class="s1">groups=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Returns the number of splitting iterations in the cross-validator 
 
        Parameters 
        ---------- 
        X : object 
            Always ignored, exists for compatibility. 
            ``np.zeros(n_samples)`` may be used as a placeholder. 
 
        y : object 
            Always ignored, exists for compatibility. 
            ``np.zeros(n_samples)`` may be used as a placeholder. 
 
        groups : array-like of shape (n_samples,), default=None 
            Group labels for the samples used while splitting the dataset into 
            train/test set. 
 
        Returns 
        ------- 
        n_splits : int 
            Returns the number of splitting iterations in the cross-validator. 
        &quot;&quot;&quot;</span>
        <span class="s1">rng = check_random_state(self.random_state)</span>
        <span class="s1">cv = self.cv(random_state=rng</span><span class="s3">, </span><span class="s1">shuffle=</span><span class="s3">True, </span><span class="s1">**self.cvargs)</span>
        <span class="s3">return </span><span class="s1">cv.get_n_splits(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups) * self.n_repeats</span>

    <span class="s3">def </span><span class="s1">__repr__(self):</span>
        <span class="s3">return </span><span class="s1">_build_repr(self)</span>


<span class="s3">class </span><span class="s1">RepeatedKFold(_RepeatedSplits):</span>
    <span class="s0">&quot;&quot;&quot;Repeated K-Fold cross validator. 
 
    Repeats K-Fold n times with different randomization in each repetition. 
 
    Read more in the :ref:`User Guide &lt;repeated_k_fold&gt;`. 
 
    Parameters 
    ---------- 
    n_splits : int, default=5 
        Number of folds. Must be at least 2. 
 
    n_repeats : int, default=10 
        Number of times cross-validator needs to be repeated. 
 
    random_state : int, RandomState instance or None, default=None 
        Controls the randomness of each repeated cross-validation instance. 
        Pass an int for reproducible output across multiple function calls. 
        See :term:`Glossary &lt;random_state&gt;`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from sklearn.model_selection import RepeatedKFold 
    &gt;&gt;&gt; X = np.array([[1, 2], [3, 4], [1, 2], [3, 4]]) 
    &gt;&gt;&gt; y = np.array([0, 0, 1, 1]) 
    &gt;&gt;&gt; rkf = RepeatedKFold(n_splits=2, n_repeats=2, random_state=2652124) 
    &gt;&gt;&gt; rkf.get_n_splits(X, y) 
    4 
    &gt;&gt;&gt; print(rkf) 
    RepeatedKFold(n_repeats=2, n_splits=2, random_state=2652124) 
    &gt;&gt;&gt; for i, (train_index, test_index) in enumerate(rkf.split(X)): 
    ...     print(f&quot;Fold {i}:&quot;) 
    ...     print(f&quot;  Train: index={train_index}&quot;) 
    ...     print(f&quot;  Test:  index={test_index}&quot;) 
    ... 
    Fold 0: 
      Train: index=[0 1] 
      Test:  index=[2 3] 
    Fold 1: 
      Train: index=[2 3] 
      Test:  index=[0 1] 
    Fold 2: 
      Train: index=[1 2] 
      Test:  index=[0 3] 
    Fold 3: 
      Train: index=[0 3] 
      Test:  index=[1 2] 
 
    Notes 
    ----- 
    Randomized CV splitters may return different results for each call of 
    split. You can make the results identical by setting `random_state` 
    to an integer. 
 
    See Also 
    -------- 
    RepeatedStratifiedKFold : Repeats Stratified K-Fold n times. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">n_splits=</span><span class="s5">5</span><span class="s3">, </span><span class="s1">n_repeats=</span><span class="s5">10</span><span class="s3">, </span><span class="s1">random_state=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">super().__init__(</span>
            <span class="s1">KFold</span><span class="s3">, </span><span class="s1">n_repeats=n_repeats</span><span class="s3">, </span><span class="s1">random_state=random_state</span><span class="s3">, </span><span class="s1">n_splits=n_splits</span>
        <span class="s1">)</span>


<span class="s3">class </span><span class="s1">RepeatedStratifiedKFold(_RepeatedSplits):</span>
    <span class="s0">&quot;&quot;&quot;Repeated Stratified K-Fold cross validator. 
 
    Repeats Stratified K-Fold n times with different randomization in each 
    repetition. 
 
    Read more in the :ref:`User Guide &lt;repeated_k_fold&gt;`. 
 
    Parameters 
    ---------- 
    n_splits : int, default=5 
        Number of folds. Must be at least 2. 
 
    n_repeats : int, default=10 
        Number of times cross-validator needs to be repeated. 
 
    random_state : int, RandomState instance or None, default=None 
        Controls the generation of the random states for each repetition. 
        Pass an int for reproducible output across multiple function calls. 
        See :term:`Glossary &lt;random_state&gt;`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from sklearn.model_selection import RepeatedStratifiedKFold 
    &gt;&gt;&gt; X = np.array([[1, 2], [3, 4], [1, 2], [3, 4]]) 
    &gt;&gt;&gt; y = np.array([0, 0, 1, 1]) 
    &gt;&gt;&gt; rskf = RepeatedStratifiedKFold(n_splits=2, n_repeats=2, 
    ...     random_state=36851234) 
    &gt;&gt;&gt; rskf.get_n_splits(X, y) 
    4 
    &gt;&gt;&gt; print(rskf) 
    RepeatedStratifiedKFold(n_repeats=2, n_splits=2, random_state=36851234) 
    &gt;&gt;&gt; for i, (train_index, test_index) in enumerate(rskf.split(X, y)): 
    ...     print(f&quot;Fold {i}:&quot;) 
    ...     print(f&quot;  Train: index={train_index}&quot;) 
    ...     print(f&quot;  Test:  index={test_index}&quot;) 
    ... 
    Fold 0: 
      Train: index=[1 2] 
      Test:  index=[0 3] 
    Fold 1: 
      Train: index=[0 3] 
      Test:  index=[1 2] 
    Fold 2: 
      Train: index=[1 3] 
      Test:  index=[0 2] 
    Fold 3: 
      Train: index=[0 2] 
      Test:  index=[1 3] 
 
    Notes 
    ----- 
    Randomized CV splitters may return different results for each call of 
    split. You can make the results identical by setting `random_state` 
    to an integer. 
 
    See Also 
    -------- 
    RepeatedKFold : Repeats K-Fold n times. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">n_splits=</span><span class="s5">5</span><span class="s3">, </span><span class="s1">n_repeats=</span><span class="s5">10</span><span class="s3">, </span><span class="s1">random_state=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">super().__init__(</span>
            <span class="s1">StratifiedKFold</span><span class="s3">,</span>
            <span class="s1">n_repeats=n_repeats</span><span class="s3">,</span>
            <span class="s1">random_state=random_state</span><span class="s3">,</span>
            <span class="s1">n_splits=n_splits</span><span class="s3">,</span>
        <span class="s1">)</span>


<span class="s3">class </span><span class="s1">BaseShuffleSplit(_MetadataRequester</span><span class="s3">, </span><span class="s1">metaclass=ABCMeta):</span>
    <span class="s0">&quot;&quot;&quot;Base class for ShuffleSplit and StratifiedShuffleSplit&quot;&quot;&quot;</span>

    <span class="s2"># This indicates that by default CV splitters don't have a &quot;groups&quot; kwarg,</span>
    <span class="s2"># unless indicated by inheriting from ``GroupsConsumerMixin``.</span>
    <span class="s2"># This also prevents ``set_split_request`` to be generated for splitters</span>
    <span class="s2"># which don't support ``groups``.</span>
    <span class="s1">__metadata_request__split = {</span><span class="s4">&quot;groups&quot;</span><span class="s1">: metadata_routing.UNUSED}</span>

    <span class="s3">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">n_splits=</span><span class="s5">10</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">test_size=</span><span class="s3">None, </span><span class="s1">train_size=</span><span class="s3">None, </span><span class="s1">random_state=</span><span class="s3">None</span>
    <span class="s1">):</span>
        <span class="s1">self.n_splits = n_splits</span>
        <span class="s1">self.test_size = test_size</span>
        <span class="s1">self.train_size = train_size</span>
        <span class="s1">self.random_state = random_state</span>
        <span class="s1">self._default_test_size = </span><span class="s5">0.1</span>

    <span class="s3">def </span><span class="s1">split(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y=</span><span class="s3">None, </span><span class="s1">groups=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Generate indices to split data into training and test set. 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) 
            Training data, where `n_samples` is the number of samples 
            and `n_features` is the number of features. 
 
        y : array-like of shape (n_samples,) 
            The target variable for supervised learning problems. 
 
        groups : array-like of shape (n_samples,), default=None 
            Group labels for the samples used while splitting the dataset into 
            train/test set. 
 
        Yields 
        ------ 
        train : ndarray 
            The training set indices for that split. 
 
        test : ndarray 
            The testing set indices for that split. 
 
        Notes 
        ----- 
        Randomized CV splitters may return different results for each call of 
        split. You can make the results identical by setting `random_state` 
        to an integer. 
        &quot;&quot;&quot;</span>
        <span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups = indexable(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups)</span>
        <span class="s3">for </span><span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">in </span><span class="s1">self._iter_indices(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups):</span>
            <span class="s3">yield </span><span class="s1">train</span><span class="s3">, </span><span class="s1">test</span>

    <span class="s1">@abstractmethod</span>
    <span class="s3">def </span><span class="s1">_iter_indices(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y=</span><span class="s3">None, </span><span class="s1">groups=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Generate (train, test) indices&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">get_n_splits(self</span><span class="s3">, </span><span class="s1">X=</span><span class="s3">None, </span><span class="s1">y=</span><span class="s3">None, </span><span class="s1">groups=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Returns the number of splitting iterations in the cross-validator 
 
        Parameters 
        ---------- 
        X : object 
            Always ignored, exists for compatibility. 
 
        y : object 
            Always ignored, exists for compatibility. 
 
        groups : object 
            Always ignored, exists for compatibility. 
 
        Returns 
        ------- 
        n_splits : int 
            Returns the number of splitting iterations in the cross-validator. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">self.n_splits</span>

    <span class="s3">def </span><span class="s1">__repr__(self):</span>
        <span class="s3">return </span><span class="s1">_build_repr(self)</span>


<span class="s3">class </span><span class="s1">ShuffleSplit(BaseShuffleSplit):</span>
    <span class="s0">&quot;&quot;&quot;Random permutation cross-validator 
 
    Yields indices to split data into training and test sets. 
 
    Note: contrary to other cross-validation strategies, random splits 
    do not guarantee that all folds will be different, although this is 
    still very likely for sizeable datasets. 
 
    Read more in the :ref:`User Guide &lt;ShuffleSplit&gt;`. 
 
    For visualisation of cross-validation behaviour and 
    comparison between common scikit-learn split methods 
    refer to :ref:`sphx_glr_auto_examples_model_selection_plot_cv_indices.py` 
 
    Parameters 
    ---------- 
    n_splits : int, default=10 
        Number of re-shuffling &amp; splitting iterations. 
 
    test_size : float or int, default=None 
        If float, should be between 0.0 and 1.0 and represent the proportion 
        of the dataset to include in the test split. If int, represents the 
        absolute number of test samples. If None, the value is set to the 
        complement of the train size. If ``train_size`` is also None, it will 
        be set to 0.1. 
 
    train_size : float or int, default=None 
        If float, should be between 0.0 and 1.0 and represent the 
        proportion of the dataset to include in the train split. If 
        int, represents the absolute number of train samples. If None, 
        the value is automatically set to the complement of the test size. 
 
    random_state : int, RandomState instance or None, default=None 
        Controls the randomness of the training and testing indices produced. 
        Pass an int for reproducible output across multiple function calls. 
        See :term:`Glossary &lt;random_state&gt;`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from sklearn.model_selection import ShuffleSplit 
    &gt;&gt;&gt; X = np.array([[1, 2], [3, 4], [5, 6], [7, 8], [3, 4], [5, 6]]) 
    &gt;&gt;&gt; y = np.array([1, 2, 1, 2, 1, 2]) 
    &gt;&gt;&gt; rs = ShuffleSplit(n_splits=5, test_size=.25, random_state=0) 
    &gt;&gt;&gt; rs.get_n_splits(X) 
    5 
    &gt;&gt;&gt; print(rs) 
    ShuffleSplit(n_splits=5, random_state=0, test_size=0.25, train_size=None) 
    &gt;&gt;&gt; for i, (train_index, test_index) in enumerate(rs.split(X)): 
    ...     print(f&quot;Fold {i}:&quot;) 
    ...     print(f&quot;  Train: index={train_index}&quot;) 
    ...     print(f&quot;  Test:  index={test_index}&quot;) 
    Fold 0: 
      Train: index=[1 3 0 4] 
      Test:  index=[5 2] 
    Fold 1: 
      Train: index=[4 0 2 5] 
      Test:  index=[1 3] 
    Fold 2: 
      Train: index=[1 2 4 0] 
      Test:  index=[3 5] 
    Fold 3: 
      Train: index=[3 4 1 0] 
      Test:  index=[5 2] 
    Fold 4: 
      Train: index=[3 5 1 0] 
      Test:  index=[2 4] 
    &gt;&gt;&gt; # Specify train and test size 
    &gt;&gt;&gt; rs = ShuffleSplit(n_splits=5, train_size=0.5, test_size=.25, 
    ...                   random_state=0) 
    &gt;&gt;&gt; for i, (train_index, test_index) in enumerate(rs.split(X)): 
    ...     print(f&quot;Fold {i}:&quot;) 
    ...     print(f&quot;  Train: index={train_index}&quot;) 
    ...     print(f&quot;  Test:  index={test_index}&quot;) 
    Fold 0: 
      Train: index=[1 3 0] 
      Test:  index=[5 2] 
    Fold 1: 
      Train: index=[4 0 2] 
      Test:  index=[1 3] 
    Fold 2: 
      Train: index=[1 2 4] 
      Test:  index=[3 5] 
    Fold 3: 
      Train: index=[3 4 1] 
      Test:  index=[5 2] 
    Fold 4: 
      Train: index=[3 5 1] 
      Test:  index=[2 4] 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">n_splits=</span><span class="s5">10</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">test_size=</span><span class="s3">None, </span><span class="s1">train_size=</span><span class="s3">None, </span><span class="s1">random_state=</span><span class="s3">None</span>
    <span class="s1">):</span>
        <span class="s1">super().__init__(</span>
            <span class="s1">n_splits=n_splits</span><span class="s3">,</span>
            <span class="s1">test_size=test_size</span><span class="s3">,</span>
            <span class="s1">train_size=train_size</span><span class="s3">,</span>
            <span class="s1">random_state=random_state</span><span class="s3">,</span>
        <span class="s1">)</span>
        <span class="s1">self._default_test_size = </span><span class="s5">0.1</span>

    <span class="s3">def </span><span class="s1">_iter_indices(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y=</span><span class="s3">None, </span><span class="s1">groups=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">n_samples = _num_samples(X)</span>
        <span class="s1">n_train</span><span class="s3">, </span><span class="s1">n_test = _validate_shuffle_split(</span>
            <span class="s1">n_samples</span><span class="s3">,</span>
            <span class="s1">self.test_size</span><span class="s3">,</span>
            <span class="s1">self.train_size</span><span class="s3">,</span>
            <span class="s1">default_test_size=self._default_test_size</span><span class="s3">,</span>
        <span class="s1">)</span>

        <span class="s1">rng = check_random_state(self.random_state)</span>
        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(self.n_splits):</span>
            <span class="s2"># random partition</span>
            <span class="s1">permutation = rng.permutation(n_samples)</span>
            <span class="s1">ind_test = permutation[:n_test]</span>
            <span class="s1">ind_train = permutation[n_test : (n_test + n_train)]</span>
            <span class="s3">yield </span><span class="s1">ind_train</span><span class="s3">, </span><span class="s1">ind_test</span>


<span class="s3">class </span><span class="s1">GroupShuffleSplit(GroupsConsumerMixin</span><span class="s3">, </span><span class="s1">ShuffleSplit):</span>
    <span class="s0">&quot;&quot;&quot;Shuffle-Group(s)-Out cross-validation iterator 
 
    Provides randomized train/test indices to split data according to a 
    third-party provided group. This group information can be used to encode 
    arbitrary domain specific stratifications of the samples as integers. 
 
    For instance the groups could be the year of collection of the samples 
    and thus allow for cross-validation against time-based splits. 
 
    The difference between LeavePGroupsOut and GroupShuffleSplit is that 
    the former generates splits using all subsets of size ``p`` unique groups, 
    whereas GroupShuffleSplit generates a user-determined number of random 
    test splits, each with a user-determined fraction of unique groups. 
 
    For example, a less computationally intensive alternative to 
    ``LeavePGroupsOut(p=10)`` would be 
    ``GroupShuffleSplit(test_size=10, n_splits=100)``. 
 
    Note: The parameters ``test_size`` and ``train_size`` refer to groups, and 
    not to samples, as in ShuffleSplit. 
 
    Read more in the :ref:`User Guide &lt;group_shuffle_split&gt;`. 
 
    For visualisation of cross-validation behaviour and 
    comparison between common scikit-learn split methods 
    refer to :ref:`sphx_glr_auto_examples_model_selection_plot_cv_indices.py` 
 
    Parameters 
    ---------- 
    n_splits : int, default=5 
        Number of re-shuffling &amp; splitting iterations. 
 
    test_size : float, int, default=0.2 
        If float, should be between 0.0 and 1.0 and represent the proportion 
        of groups to include in the test split (rounded up). If int, 
        represents the absolute number of test groups. If None, the value is 
        set to the complement of the train size. 
        The default will change in version 0.21. It will remain 0.2 only 
        if ``train_size`` is unspecified, otherwise it will complement 
        the specified ``train_size``. 
 
    train_size : float or int, default=None 
        If float, should be between 0.0 and 1.0 and represent the 
        proportion of the groups to include in the train split. If 
        int, represents the absolute number of train groups. If None, 
        the value is automatically set to the complement of the test size. 
 
    random_state : int, RandomState instance or None, default=None 
        Controls the randomness of the training and testing indices produced. 
        Pass an int for reproducible output across multiple function calls. 
        See :term:`Glossary &lt;random_state&gt;`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from sklearn.model_selection import GroupShuffleSplit 
    &gt;&gt;&gt; X = np.ones(shape=(8, 2)) 
    &gt;&gt;&gt; y = np.ones(shape=(8, 1)) 
    &gt;&gt;&gt; groups = np.array([1, 1, 2, 2, 2, 3, 3, 3]) 
    &gt;&gt;&gt; print(groups.shape) 
    (8,) 
    &gt;&gt;&gt; gss = GroupShuffleSplit(n_splits=2, train_size=.7, random_state=42) 
    &gt;&gt;&gt; gss.get_n_splits() 
    2 
    &gt;&gt;&gt; print(gss) 
    GroupShuffleSplit(n_splits=2, random_state=42, test_size=None, train_size=0.7) 
    &gt;&gt;&gt; for i, (train_index, test_index) in enumerate(gss.split(X, y, groups)): 
    ...     print(f&quot;Fold {i}:&quot;) 
    ...     print(f&quot;  Train: index={train_index}, group={groups[train_index]}&quot;) 
    ...     print(f&quot;  Test:  index={test_index}, group={groups[test_index]}&quot;) 
    Fold 0: 
      Train: index=[2 3 4 5 6 7], group=[2 2 2 3 3 3] 
      Test:  index=[0 1], group=[1 1] 
    Fold 1: 
      Train: index=[0 1 5 6 7], group=[1 1 3 3 3] 
      Test:  index=[2 3 4], group=[2 2 2] 
 
    See Also 
    -------- 
    ShuffleSplit : Shuffles samples to create independent test/train sets. 
 
    LeavePGroupsOut : Train set leaves out all possible subsets of `p` groups. 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">n_splits=</span><span class="s5">5</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">test_size=</span><span class="s3">None, </span><span class="s1">train_size=</span><span class="s3">None, </span><span class="s1">random_state=</span><span class="s3">None</span>
    <span class="s1">):</span>
        <span class="s1">super().__init__(</span>
            <span class="s1">n_splits=n_splits</span><span class="s3">,</span>
            <span class="s1">test_size=test_size</span><span class="s3">,</span>
            <span class="s1">train_size=train_size</span><span class="s3">,</span>
            <span class="s1">random_state=random_state</span><span class="s3">,</span>
        <span class="s1">)</span>
        <span class="s1">self._default_test_size = </span><span class="s5">0.2</span>

    <span class="s3">def </span><span class="s1">_iter_indices(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups):</span>
        <span class="s3">if </span><span class="s1">groups </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;The 'groups' parameter should not be None.&quot;</span><span class="s1">)</span>
        <span class="s1">groups = check_array(groups</span><span class="s3">, </span><span class="s1">input_name=</span><span class="s4">&quot;groups&quot;</span><span class="s3">, </span><span class="s1">ensure_2d=</span><span class="s3">False, </span><span class="s1">dtype=</span><span class="s3">None</span><span class="s1">)</span>
        <span class="s1">classes</span><span class="s3">, </span><span class="s1">group_indices = np.unique(groups</span><span class="s3">, </span><span class="s1">return_inverse=</span><span class="s3">True</span><span class="s1">)</span>
        <span class="s3">for </span><span class="s1">group_train</span><span class="s3">, </span><span class="s1">group_test </span><span class="s3">in </span><span class="s1">super()._iter_indices(X=classes):</span>
            <span class="s2"># these are the indices of classes in the partition</span>
            <span class="s2"># invert them into data indices</span>

            <span class="s1">train = np.flatnonzero(np.isin(group_indices</span><span class="s3">, </span><span class="s1">group_train))</span>
            <span class="s1">test = np.flatnonzero(np.isin(group_indices</span><span class="s3">, </span><span class="s1">group_test))</span>

            <span class="s3">yield </span><span class="s1">train</span><span class="s3">, </span><span class="s1">test</span>

    <span class="s3">def </span><span class="s1">split(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y=</span><span class="s3">None, </span><span class="s1">groups=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Generate indices to split data into training and test set. 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) 
            Training data, where `n_samples` is the number of samples 
            and `n_features` is the number of features. 
 
        y : array-like of shape (n_samples,), default=None 
            The target variable for supervised learning problems. 
 
        groups : array-like of shape (n_samples,) 
            Group labels for the samples used while splitting the dataset into 
            train/test set. 
 
        Yields 
        ------ 
        train : ndarray 
            The training set indices for that split. 
 
        test : ndarray 
            The testing set indices for that split. 
 
        Notes 
        ----- 
        Randomized CV splitters may return different results for each call of 
        split. You can make the results identical by setting `random_state` 
        to an integer. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">super().split(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups)</span>


<span class="s3">class </span><span class="s1">StratifiedShuffleSplit(BaseShuffleSplit):</span>
    <span class="s0">&quot;&quot;&quot;Stratified ShuffleSplit cross-validator 
 
    Provides train/test indices to split data in train/test sets. 
 
    This cross-validation object is a merge of StratifiedKFold and 
    ShuffleSplit, which returns stratified randomized folds. The folds 
    are made by preserving the percentage of samples for each class. 
 
    Note: like the ShuffleSplit strategy, stratified random splits 
    do not guarantee that all folds will be different, although this is 
    still very likely for sizeable datasets. 
 
    Read more in the :ref:`User Guide &lt;stratified_shuffle_split&gt;`. 
 
    For visualisation of cross-validation behaviour and 
    comparison between common scikit-learn split methods 
    refer to :ref:`sphx_glr_auto_examples_model_selection_plot_cv_indices.py` 
 
    Parameters 
    ---------- 
    n_splits : int, default=10 
        Number of re-shuffling &amp; splitting iterations. 
 
    test_size : float or int, default=None 
        If float, should be between 0.0 and 1.0 and represent the proportion 
        of the dataset to include in the test split. If int, represents the 
        absolute number of test samples. If None, the value is set to the 
        complement of the train size. If ``train_size`` is also None, it will 
        be set to 0.1. 
 
    train_size : float or int, default=None 
        If float, should be between 0.0 and 1.0 and represent the 
        proportion of the dataset to include in the train split. If 
        int, represents the absolute number of train samples. If None, 
        the value is automatically set to the complement of the test size. 
 
    random_state : int, RandomState instance or None, default=None 
        Controls the randomness of the training and testing indices produced. 
        Pass an int for reproducible output across multiple function calls. 
        See :term:`Glossary &lt;random_state&gt;`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from sklearn.model_selection import StratifiedShuffleSplit 
    &gt;&gt;&gt; X = np.array([[1, 2], [3, 4], [1, 2], [3, 4], [1, 2], [3, 4]]) 
    &gt;&gt;&gt; y = np.array([0, 0, 0, 1, 1, 1]) 
    &gt;&gt;&gt; sss = StratifiedShuffleSplit(n_splits=5, test_size=0.5, random_state=0) 
    &gt;&gt;&gt; sss.get_n_splits(X, y) 
    5 
    &gt;&gt;&gt; print(sss) 
    StratifiedShuffleSplit(n_splits=5, random_state=0, ...) 
    &gt;&gt;&gt; for i, (train_index, test_index) in enumerate(sss.split(X, y)): 
    ...     print(f&quot;Fold {i}:&quot;) 
    ...     print(f&quot;  Train: index={train_index}&quot;) 
    ...     print(f&quot;  Test:  index={test_index}&quot;) 
    Fold 0: 
      Train: index=[5 2 3] 
      Test:  index=[4 1 0] 
    Fold 1: 
      Train: index=[5 1 4] 
      Test:  index=[0 2 3] 
    Fold 2: 
      Train: index=[5 0 2] 
      Test:  index=[4 3 1] 
    Fold 3: 
      Train: index=[4 1 0] 
      Test:  index=[2 3 5] 
    Fold 4: 
      Train: index=[0 5 1] 
      Test:  index=[3 4 2] 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s3">, </span><span class="s1">n_splits=</span><span class="s5">10</span><span class="s3">, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">test_size=</span><span class="s3">None, </span><span class="s1">train_size=</span><span class="s3">None, </span><span class="s1">random_state=</span><span class="s3">None</span>
    <span class="s1">):</span>
        <span class="s1">super().__init__(</span>
            <span class="s1">n_splits=n_splits</span><span class="s3">,</span>
            <span class="s1">test_size=test_size</span><span class="s3">,</span>
            <span class="s1">train_size=train_size</span><span class="s3">,</span>
            <span class="s1">random_state=random_state</span><span class="s3">,</span>
        <span class="s1">)</span>
        <span class="s1">self._default_test_size = </span><span class="s5">0.1</span>

    <span class="s3">def </span><span class="s1">_iter_indices(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">n_samples = _num_samples(X)</span>
        <span class="s1">y = check_array(y</span><span class="s3">, </span><span class="s1">input_name=</span><span class="s4">&quot;y&quot;</span><span class="s3">, </span><span class="s1">ensure_2d=</span><span class="s3">False, </span><span class="s1">dtype=</span><span class="s3">None</span><span class="s1">)</span>
        <span class="s1">n_train</span><span class="s3">, </span><span class="s1">n_test = _validate_shuffle_split(</span>
            <span class="s1">n_samples</span><span class="s3">,</span>
            <span class="s1">self.test_size</span><span class="s3">,</span>
            <span class="s1">self.train_size</span><span class="s3">,</span>
            <span class="s1">default_test_size=self._default_test_size</span><span class="s3">,</span>
        <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">y.ndim == </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s2"># for multi-label y, map each distinct row to a string repr</span>
            <span class="s2"># using join because str(row) uses an ellipsis if len(row) &gt; 1000</span>
            <span class="s1">y = np.array([</span><span class="s4">&quot; &quot;</span><span class="s1">.join(row.astype(</span><span class="s4">&quot;str&quot;</span><span class="s1">)) </span><span class="s3">for </span><span class="s1">row </span><span class="s3">in </span><span class="s1">y])</span>

        <span class="s1">classes</span><span class="s3">, </span><span class="s1">y_indices = np.unique(y</span><span class="s3">, </span><span class="s1">return_inverse=</span><span class="s3">True</span><span class="s1">)</span>
        <span class="s1">n_classes = classes.shape[</span><span class="s5">0</span><span class="s1">]</span>

        <span class="s1">class_counts = np.bincount(y_indices)</span>
        <span class="s3">if </span><span class="s1">np.min(class_counts) &lt; </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;The least populated class in y has only 1&quot;</span>
                <span class="s4">&quot; member, which is too few. The minimum&quot;</span>
                <span class="s4">&quot; number of groups for any class cannot&quot;</span>
                <span class="s4">&quot; be less than 2.&quot;</span>
            <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">n_train &lt; n_classes:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;The train_size = %d should be greater or &quot;</span>
                <span class="s4">&quot;equal to the number of classes = %d&quot; </span><span class="s1">% (n_train</span><span class="s3">, </span><span class="s1">n_classes)</span>
            <span class="s1">)</span>
        <span class="s3">if </span><span class="s1">n_test &lt; n_classes:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;The test_size = %d should be greater or &quot;</span>
                <span class="s4">&quot;equal to the number of classes = %d&quot; </span><span class="s1">% (n_test</span><span class="s3">, </span><span class="s1">n_classes)</span>
            <span class="s1">)</span>

        <span class="s2"># Find the sorted list of instances for each class:</span>
        <span class="s2"># (np.unique above performs a sort, so code is O(n logn) already)</span>
        <span class="s1">class_indices = np.split(</span>
            <span class="s1">np.argsort(y_indices</span><span class="s3">, </span><span class="s1">kind=</span><span class="s4">&quot;mergesort&quot;</span><span class="s1">)</span><span class="s3">, </span><span class="s1">np.cumsum(class_counts)[:-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">)</span>

        <span class="s1">rng = check_random_state(self.random_state)</span>

        <span class="s3">for </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">range(self.n_splits):</span>
            <span class="s2"># if there are ties in the class-counts, we want</span>
            <span class="s2"># to make sure to break them anew in each iteration</span>
            <span class="s1">n_i = _approximate_mode(class_counts</span><span class="s3">, </span><span class="s1">n_train</span><span class="s3">, </span><span class="s1">rng)</span>
            <span class="s1">class_counts_remaining = class_counts - n_i</span>
            <span class="s1">t_i = _approximate_mode(class_counts_remaining</span><span class="s3">, </span><span class="s1">n_test</span><span class="s3">, </span><span class="s1">rng)</span>

            <span class="s1">train = []</span>
            <span class="s1">test = []</span>

            <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(n_classes):</span>
                <span class="s1">permutation = rng.permutation(class_counts[i])</span>
                <span class="s1">perm_indices_class_i = class_indices[i].take(permutation</span><span class="s3">, </span><span class="s1">mode=</span><span class="s4">&quot;clip&quot;</span><span class="s1">)</span>

                <span class="s1">train.extend(perm_indices_class_i[: n_i[i]])</span>
                <span class="s1">test.extend(perm_indices_class_i[n_i[i] : n_i[i] + t_i[i]])</span>

            <span class="s1">train = rng.permutation(train)</span>
            <span class="s1">test = rng.permutation(test)</span>

            <span class="s3">yield </span><span class="s1">train</span><span class="s3">, </span><span class="s1">test</span>

    <span class="s3">def </span><span class="s1">split(self</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Generate indices to split data into training and test set. 
 
        Parameters 
        ---------- 
        X : array-like of shape (n_samples, n_features) 
            Training data, where `n_samples` is the number of samples 
            and `n_features` is the number of features. 
 
            Note that providing ``y`` is sufficient to generate the splits and 
            hence ``np.zeros(n_samples)`` may be used as a placeholder for 
            ``X`` instead of actual training data. 
 
        y : array-like of shape (n_samples,) or (n_samples, n_labels) 
            The target variable for supervised learning problems. 
            Stratification is done based on the y labels. 
 
        groups : object 
            Always ignored, exists for compatibility. 
 
        Yields 
        ------ 
        train : ndarray 
            The training set indices for that split. 
 
        test : ndarray 
            The testing set indices for that split. 
 
        Notes 
        ----- 
        Randomized CV splitters may return different results for each call of 
        split. You can make the results identical by setting `random_state` 
        to an integer. 
        &quot;&quot;&quot;</span>
        <span class="s1">y = check_array(y</span><span class="s3">, </span><span class="s1">input_name=</span><span class="s4">&quot;y&quot;</span><span class="s3">, </span><span class="s1">ensure_2d=</span><span class="s3">False, </span><span class="s1">dtype=</span><span class="s3">None</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">super().split(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups)</span>


<span class="s3">def </span><span class="s1">_validate_shuffle_split(n_samples</span><span class="s3">, </span><span class="s1">test_size</span><span class="s3">, </span><span class="s1">train_size</span><span class="s3">, </span><span class="s1">default_test_size=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Validation helper to check if the test/test sizes are meaningful w.r.t. the 
    size of the data (n_samples). 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">test_size </span><span class="s3">is None and </span><span class="s1">train_size </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">test_size = default_test_size</span>

    <span class="s1">test_size_type = np.asarray(test_size).dtype.kind</span>
    <span class="s1">train_size_type = np.asarray(train_size).dtype.kind</span>

    <span class="s3">if </span><span class="s1">(</span>
        <span class="s1">test_size_type == </span><span class="s4">&quot;i&quot;</span>
        <span class="s3">and </span><span class="s1">(test_size &gt;= n_samples </span><span class="s3">or </span><span class="s1">test_size &lt;= </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s3">or </span><span class="s1">test_size_type == </span><span class="s4">&quot;f&quot;</span>
        <span class="s3">and </span><span class="s1">(test_size &lt;= </span><span class="s5">0 </span><span class="s3">or </span><span class="s1">test_size &gt;= </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">):</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span>
            <span class="s4">&quot;test_size={0} should be either positive and smaller&quot;</span>
            <span class="s4">&quot; than the number of samples {1} or a float in the &quot;</span>
            <span class="s4">&quot;(0, 1) range&quot;</span><span class="s1">.format(test_size</span><span class="s3">, </span><span class="s1">n_samples)</span>
        <span class="s1">)</span>

    <span class="s3">if </span><span class="s1">(</span>
        <span class="s1">train_size_type == </span><span class="s4">&quot;i&quot;</span>
        <span class="s3">and </span><span class="s1">(train_size &gt;= n_samples </span><span class="s3">or </span><span class="s1">train_size &lt;= </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s3">or </span><span class="s1">train_size_type == </span><span class="s4">&quot;f&quot;</span>
        <span class="s3">and </span><span class="s1">(train_size &lt;= </span><span class="s5">0 </span><span class="s3">or </span><span class="s1">train_size &gt;= </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">):</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span>
            <span class="s4">&quot;train_size={0} should be either positive and smaller&quot;</span>
            <span class="s4">&quot; than the number of samples {1} or a float in the &quot;</span>
            <span class="s4">&quot;(0, 1) range&quot;</span><span class="s1">.format(train_size</span><span class="s3">, </span><span class="s1">n_samples)</span>
        <span class="s1">)</span>

    <span class="s3">if </span><span class="s1">train_size </span><span class="s3">is not None and </span><span class="s1">train_size_type </span><span class="s3">not in </span><span class="s1">(</span><span class="s4">&quot;i&quot;</span><span class="s3">, </span><span class="s4">&quot;f&quot;</span><span class="s1">):</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Invalid value for train_size: {}&quot;</span><span class="s1">.format(train_size))</span>
    <span class="s3">if </span><span class="s1">test_size </span><span class="s3">is not None and </span><span class="s1">test_size_type </span><span class="s3">not in </span><span class="s1">(</span><span class="s4">&quot;i&quot;</span><span class="s3">, </span><span class="s4">&quot;f&quot;</span><span class="s1">):</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;Invalid value for test_size: {}&quot;</span><span class="s1">.format(test_size))</span>

    <span class="s3">if </span><span class="s1">train_size_type == </span><span class="s4">&quot;f&quot; </span><span class="s3">and </span><span class="s1">test_size_type == </span><span class="s4">&quot;f&quot; </span><span class="s3">and </span><span class="s1">train_size + test_size &gt; </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span>
            <span class="s4">&quot;The sum of test_size and train_size = {}, should be in the (0, 1)&quot;</span>
            <span class="s4">&quot; range. Reduce test_size and/or train_size.&quot;</span><span class="s1">.format(train_size + test_size)</span>
        <span class="s1">)</span>

    <span class="s3">if </span><span class="s1">test_size_type == </span><span class="s4">&quot;f&quot;</span><span class="s1">:</span>
        <span class="s1">n_test = ceil(test_size * n_samples)</span>
    <span class="s3">elif </span><span class="s1">test_size_type == </span><span class="s4">&quot;i&quot;</span><span class="s1">:</span>
        <span class="s1">n_test = float(test_size)</span>

    <span class="s3">if </span><span class="s1">train_size_type == </span><span class="s4">&quot;f&quot;</span><span class="s1">:</span>
        <span class="s1">n_train = floor(train_size * n_samples)</span>
    <span class="s3">elif </span><span class="s1">train_size_type == </span><span class="s4">&quot;i&quot;</span><span class="s1">:</span>
        <span class="s1">n_train = float(train_size)</span>

    <span class="s3">if </span><span class="s1">train_size </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">n_train = n_samples - n_test</span>
    <span class="s3">elif </span><span class="s1">test_size </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">n_test = n_samples - n_train</span>

    <span class="s3">if </span><span class="s1">n_train + n_test &gt; n_samples:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span>
            <span class="s4">&quot;The sum of train_size and test_size = %d, &quot;</span>
            <span class="s4">&quot;should be smaller than the number of &quot;</span>
            <span class="s4">&quot;samples %d. Reduce test_size and/or &quot;</span>
            <span class="s4">&quot;train_size.&quot; </span><span class="s1">% (n_train + n_test</span><span class="s3">, </span><span class="s1">n_samples)</span>
        <span class="s1">)</span>

    <span class="s1">n_train</span><span class="s3">, </span><span class="s1">n_test = int(n_train)</span><span class="s3">, </span><span class="s1">int(n_test)</span>

    <span class="s3">if </span><span class="s1">n_train == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span>
            <span class="s4">&quot;With n_samples={}, test_size={} and train_size={}, the &quot;</span>
            <span class="s4">&quot;resulting train set will be empty. Adjust any of the &quot;</span>
            <span class="s4">&quot;aforementioned parameters.&quot;</span><span class="s1">.format(n_samples</span><span class="s3">, </span><span class="s1">test_size</span><span class="s3">, </span><span class="s1">train_size)</span>
        <span class="s1">)</span>

    <span class="s3">return </span><span class="s1">n_train</span><span class="s3">, </span><span class="s1">n_test</span>


<span class="s3">class </span><span class="s1">PredefinedSplit(BaseCrossValidator):</span>
    <span class="s0">&quot;&quot;&quot;Predefined split cross-validator 
 
    Provides train/test indices to split data into train/test sets using a 
    predefined scheme specified by the user with the ``test_fold`` parameter. 
 
    Read more in the :ref:`User Guide &lt;predefined_split&gt;`. 
 
    .. versionadded:: 0.16 
 
    Parameters 
    ---------- 
    test_fold : array-like of shape (n_samples,) 
        The entry ``test_fold[i]`` represents the index of the test set that 
        sample ``i`` belongs to. It is possible to exclude sample ``i`` from 
        any test set (i.e. include sample ``i`` in every training set) by 
        setting ``test_fold[i]`` equal to -1. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from sklearn.model_selection import PredefinedSplit 
    &gt;&gt;&gt; X = np.array([[1, 2], [3, 4], [1, 2], [3, 4]]) 
    &gt;&gt;&gt; y = np.array([0, 0, 1, 1]) 
    &gt;&gt;&gt; test_fold = [0, 1, -1, 1] 
    &gt;&gt;&gt; ps = PredefinedSplit(test_fold) 
    &gt;&gt;&gt; ps.get_n_splits() 
    2 
    &gt;&gt;&gt; print(ps) 
    PredefinedSplit(test_fold=array([ 0,  1, -1,  1])) 
    &gt;&gt;&gt; for i, (train_index, test_index) in enumerate(ps.split()): 
    ...     print(f&quot;Fold {i}:&quot;) 
    ...     print(f&quot;  Train: index={train_index}&quot;) 
    ...     print(f&quot;  Test:  index={test_index}&quot;) 
    Fold 0: 
      Train: index=[1 2 3] 
      Test:  index=[0] 
    Fold 1: 
      Train: index=[0 2] 
      Test:  index=[1 3] 
    &quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">test_fold):</span>
        <span class="s1">self.test_fold = np.array(test_fold</span><span class="s3">, </span><span class="s1">dtype=int)</span>
        <span class="s1">self.test_fold = column_or_1d(self.test_fold)</span>
        <span class="s1">self.unique_folds = np.unique(self.test_fold)</span>
        <span class="s1">self.unique_folds = self.unique_folds[self.unique_folds != -</span><span class="s5">1</span><span class="s1">]</span>

    <span class="s3">def </span><span class="s1">split(self</span><span class="s3">, </span><span class="s1">X=</span><span class="s3">None, </span><span class="s1">y=</span><span class="s3">None, </span><span class="s1">groups=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Generate indices to split data into training and test set. 
 
        Parameters 
        ---------- 
        X : object 
            Always ignored, exists for compatibility. 
 
        y : object 
            Always ignored, exists for compatibility. 
 
        groups : object 
            Always ignored, exists for compatibility. 
 
        Yields 
        ------ 
        train : ndarray 
            The training set indices for that split. 
 
        test : ndarray 
            The testing set indices for that split. 
        &quot;&quot;&quot;</span>
        <span class="s1">ind = np.arange(len(self.test_fold))</span>
        <span class="s3">for </span><span class="s1">test_index </span><span class="s3">in </span><span class="s1">self._iter_test_masks():</span>
            <span class="s1">train_index = ind[np.logical_not(test_index)]</span>
            <span class="s1">test_index = ind[test_index]</span>
            <span class="s3">yield </span><span class="s1">train_index</span><span class="s3">, </span><span class="s1">test_index</span>

    <span class="s3">def </span><span class="s1">_iter_test_masks(self):</span>
        <span class="s0">&quot;&quot;&quot;Generates boolean masks corresponding to test sets.&quot;&quot;&quot;</span>
        <span class="s3">for </span><span class="s1">f </span><span class="s3">in </span><span class="s1">self.unique_folds:</span>
            <span class="s1">test_index = np.where(self.test_fold == f)[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s1">test_mask = np.zeros(len(self.test_fold)</span><span class="s3">, </span><span class="s1">dtype=bool)</span>
            <span class="s1">test_mask[test_index] = </span><span class="s3">True</span>
            <span class="s3">yield </span><span class="s1">test_mask</span>

    <span class="s3">def </span><span class="s1">get_n_splits(self</span><span class="s3">, </span><span class="s1">X=</span><span class="s3">None, </span><span class="s1">y=</span><span class="s3">None, </span><span class="s1">groups=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Returns the number of splitting iterations in the cross-validator 
 
        Parameters 
        ---------- 
        X : object 
            Always ignored, exists for compatibility. 
 
        y : object 
            Always ignored, exists for compatibility. 
 
        groups : object 
            Always ignored, exists for compatibility. 
 
        Returns 
        ------- 
        n_splits : int 
            Returns the number of splitting iterations in the cross-validator. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">len(self.unique_folds)</span>


<span class="s3">class </span><span class="s1">_CVIterableWrapper(BaseCrossValidator):</span>
    <span class="s0">&quot;&quot;&quot;Wrapper class for old style cv objects and iterables.&quot;&quot;&quot;</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">cv):</span>
        <span class="s1">self.cv = list(cv)</span>

    <span class="s3">def </span><span class="s1">get_n_splits(self</span><span class="s3">, </span><span class="s1">X=</span><span class="s3">None, </span><span class="s1">y=</span><span class="s3">None, </span><span class="s1">groups=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Returns the number of splitting iterations in the cross-validator 
 
        Parameters 
        ---------- 
        X : object 
            Always ignored, exists for compatibility. 
 
        y : object 
            Always ignored, exists for compatibility. 
 
        groups : object 
            Always ignored, exists for compatibility. 
 
        Returns 
        ------- 
        n_splits : int 
            Returns the number of splitting iterations in the cross-validator. 
        &quot;&quot;&quot;</span>
        <span class="s3">return </span><span class="s1">len(self.cv)</span>

    <span class="s3">def </span><span class="s1">split(self</span><span class="s3">, </span><span class="s1">X=</span><span class="s3">None, </span><span class="s1">y=</span><span class="s3">None, </span><span class="s1">groups=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot;Generate indices to split data into training and test set. 
 
        Parameters 
        ---------- 
        X : object 
            Always ignored, exists for compatibility. 
 
        y : object 
            Always ignored, exists for compatibility. 
 
        groups : object 
            Always ignored, exists for compatibility. 
 
        Yields 
        ------ 
        train : ndarray 
            The training set indices for that split. 
 
        test : ndarray 
            The testing set indices for that split. 
        &quot;&quot;&quot;</span>
        <span class="s3">for </span><span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">in </span><span class="s1">self.cv:</span>
            <span class="s3">yield </span><span class="s1">train</span><span class="s3">, </span><span class="s1">test</span>


<span class="s3">def </span><span class="s1">check_cv(cv=</span><span class="s5">5</span><span class="s3">, </span><span class="s1">y=</span><span class="s3">None, </span><span class="s1">*</span><span class="s3">, </span><span class="s1">classifier=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Input checker utility for building a cross-validator. 
 
    Parameters 
    ---------- 
    cv : int, cross-validation generator or an iterable, default=None 
        Determines the cross-validation splitting strategy. 
        Possible inputs for cv are: 
        - None, to use the default 5-fold cross validation, 
        - integer, to specify the number of folds. 
        - :term:`CV splitter`, 
        - An iterable that generates (train, test) splits as arrays of indices. 
 
        For integer/None inputs, if classifier is True and ``y`` is either 
        binary or multiclass, :class:`StratifiedKFold` is used. In all other 
        cases, :class:`KFold` is used. 
 
        Refer :ref:`User Guide &lt;cross_validation&gt;` for the various 
        cross-validation strategies that can be used here. 
 
        .. versionchanged:: 0.22 
            ``cv`` default value changed from 3-fold to 5-fold. 
 
    y : array-like, default=None 
        The target variable for supervised learning problems. 
 
    classifier : bool, default=False 
        Whether the task is a classification task, in which case 
        stratified KFold will be used. 
 
    Returns 
    ------- 
    checked_cv : a cross-validator instance. 
        The return value is a cross-validator which generates the train/test 
        splits via the ``split`` method. 
    &quot;&quot;&quot;</span>
    <span class="s1">cv = </span><span class="s5">5 </span><span class="s3">if </span><span class="s1">cv </span><span class="s3">is None else </span><span class="s1">cv</span>
    <span class="s3">if </span><span class="s1">isinstance(cv</span><span class="s3">, </span><span class="s1">numbers.Integral):</span>
        <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">classifier</span>
            <span class="s3">and </span><span class="s1">(y </span><span class="s3">is not None</span><span class="s1">)</span>
            <span class="s3">and </span><span class="s1">(type_of_target(y</span><span class="s3">, </span><span class="s1">input_name=</span><span class="s4">&quot;y&quot;</span><span class="s1">) </span><span class="s3">in </span><span class="s1">(</span><span class="s4">&quot;binary&quot;</span><span class="s3">, </span><span class="s4">&quot;multiclass&quot;</span><span class="s1">))</span>
        <span class="s1">):</span>
            <span class="s3">return </span><span class="s1">StratifiedKFold(cv)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">KFold(cv)</span>

    <span class="s3">if not </span><span class="s1">hasattr(cv</span><span class="s3">, </span><span class="s4">&quot;split&quot;</span><span class="s1">) </span><span class="s3">or </span><span class="s1">isinstance(cv</span><span class="s3">, </span><span class="s1">str):</span>
        <span class="s3">if not </span><span class="s1">isinstance(cv</span><span class="s3">, </span><span class="s1">Iterable) </span><span class="s3">or </span><span class="s1">isinstance(cv</span><span class="s3">, </span><span class="s1">str):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;Expected cv as an integer, cross-validation &quot;</span>
                <span class="s4">&quot;object (from sklearn.model_selection) &quot;</span>
                <span class="s4">&quot;or an iterable. Got %s.&quot; </span><span class="s1">% cv</span>
            <span class="s1">)</span>
        <span class="s3">return </span><span class="s1">_CVIterableWrapper(cv)</span>

    <span class="s3">return </span><span class="s1">cv  </span><span class="s2"># New style cv objects are passed without any modification</span>


<span class="s1">@validate_params(</span>
    <span class="s1">{</span>
        <span class="s4">&quot;test_size&quot;</span><span class="s1">: [</span>
            <span class="s1">Interval(RealNotInt</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s1">closed=</span><span class="s4">&quot;neither&quot;</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">Interval(numbers.Integral</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, None, </span><span class="s1">closed=</span><span class="s4">&quot;left&quot;</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s3">None,</span>
        <span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;train_size&quot;</span><span class="s1">: [</span>
            <span class="s1">Interval(RealNotInt</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s1">closed=</span><span class="s4">&quot;neither&quot;</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s1">Interval(numbers.Integral</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, None, </span><span class="s1">closed=</span><span class="s4">&quot;left&quot;</span><span class="s1">)</span><span class="s3">,</span>
            <span class="s3">None,</span>
        <span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;random_state&quot;</span><span class="s1">: [</span><span class="s4">&quot;random_state&quot;</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;shuffle&quot;</span><span class="s1">: [</span><span class="s4">&quot;boolean&quot;</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;stratify&quot;</span><span class="s1">: [</span><span class="s4">&quot;array-like&quot;</span><span class="s3">, None</span><span class="s1">]</span><span class="s3">,</span>
    <span class="s1">}</span><span class="s3">,</span>
    <span class="s1">prefer_skip_nested_validation=</span><span class="s3">True,</span>
<span class="s1">)</span>
<span class="s3">def </span><span class="s1">train_test_split(</span>
    <span class="s1">*arrays</span><span class="s3">,</span>
    <span class="s1">test_size=</span><span class="s3">None,</span>
    <span class="s1">train_size=</span><span class="s3">None,</span>
    <span class="s1">random_state=</span><span class="s3">None,</span>
    <span class="s1">shuffle=</span><span class="s3">True,</span>
    <span class="s1">stratify=</span><span class="s3">None,</span>
<span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Split arrays or matrices into random train and test subsets. 
 
    Quick utility that wraps input validation, 
    ``next(ShuffleSplit().split(X, y))``, and application to input data 
    into a single call for splitting (and optionally subsampling) data into a 
    one-liner. 
 
    Read more in the :ref:`User Guide &lt;cross_validation&gt;`. 
 
    Parameters 
    ---------- 
    *arrays : sequence of indexables with same length / shape[0] 
        Allowed inputs are lists, numpy arrays, scipy-sparse 
        matrices or pandas dataframes. 
 
    test_size : float or int, default=None 
        If float, should be between 0.0 and 1.0 and represent the proportion 
        of the dataset to include in the test split. If int, represents the 
        absolute number of test samples. If None, the value is set to the 
        complement of the train size. If ``train_size`` is also None, it will 
        be set to 0.25. 
 
    train_size : float or int, default=None 
        If float, should be between 0.0 and 1.0 and represent the 
        proportion of the dataset to include in the train split. If 
        int, represents the absolute number of train samples. If None, 
        the value is automatically set to the complement of the test size. 
 
    random_state : int, RandomState instance or None, default=None 
        Controls the shuffling applied to the data before applying the split. 
        Pass an int for reproducible output across multiple function calls. 
        See :term:`Glossary &lt;random_state&gt;`. 
 
    shuffle : bool, default=True 
        Whether or not to shuffle the data before splitting. If shuffle=False 
        then stratify must be None. 
 
    stratify : array-like, default=None 
        If not None, data is split in a stratified fashion, using this as 
        the class labels. 
        Read more in the :ref:`User Guide &lt;stratification&gt;`. 
 
    Returns 
    ------- 
    splitting : list, length=2 * len(arrays) 
        List containing train-test split of inputs. 
 
        .. versionadded:: 0.16 
            If the input is sparse, the output will be a 
            ``scipy.sparse.csr_matrix``. Else, output type is the same as the 
            input type. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from sklearn.model_selection import train_test_split 
    &gt;&gt;&gt; X, y = np.arange(10).reshape((5, 2)), range(5) 
    &gt;&gt;&gt; X 
    array([[0, 1], 
           [2, 3], 
           [4, 5], 
           [6, 7], 
           [8, 9]]) 
    &gt;&gt;&gt; list(y) 
    [0, 1, 2, 3, 4] 
 
    &gt;&gt;&gt; X_train, X_test, y_train, y_test = train_test_split( 
    ...     X, y, test_size=0.33, random_state=42) 
    ... 
    &gt;&gt;&gt; X_train 
    array([[4, 5], 
           [0, 1], 
           [6, 7]]) 
    &gt;&gt;&gt; y_train 
    [2, 0, 3] 
    &gt;&gt;&gt; X_test 
    array([[2, 3], 
           [8, 9]]) 
    &gt;&gt;&gt; y_test 
    [1, 4] 
 
    &gt;&gt;&gt; train_test_split(y, shuffle=False) 
    [[0, 1, 2], [3, 4]] 
    &quot;&quot;&quot;</span>
    <span class="s1">n_arrays = len(arrays)</span>
    <span class="s3">if </span><span class="s1">n_arrays == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;At least one array required as input&quot;</span><span class="s1">)</span>

    <span class="s1">arrays = indexable(*arrays)</span>

    <span class="s1">n_samples = _num_samples(arrays[</span><span class="s5">0</span><span class="s1">])</span>
    <span class="s1">n_train</span><span class="s3">, </span><span class="s1">n_test = _validate_shuffle_split(</span>
        <span class="s1">n_samples</span><span class="s3">, </span><span class="s1">test_size</span><span class="s3">, </span><span class="s1">train_size</span><span class="s3">, </span><span class="s1">default_test_size=</span><span class="s5">0.25</span>
    <span class="s1">)</span>

    <span class="s3">if </span><span class="s1">shuffle </span><span class="s3">is False</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">stratify </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;Stratified train/test split is not implemented for shuffle=False&quot;</span>
            <span class="s1">)</span>

        <span class="s1">train = np.arange(n_train)</span>
        <span class="s1">test = np.arange(n_train</span><span class="s3">, </span><span class="s1">n_train + n_test)</span>

    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">stratify </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">CVClass = StratifiedShuffleSplit</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">CVClass = ShuffleSplit</span>

        <span class="s1">cv = CVClass(test_size=n_test</span><span class="s3">, </span><span class="s1">train_size=n_train</span><span class="s3">, </span><span class="s1">random_state=random_state)</span>

        <span class="s1">train</span><span class="s3">, </span><span class="s1">test = next(cv.split(X=arrays[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">y=stratify))</span>

    <span class="s3">return </span><span class="s1">list(</span>
        <span class="s1">chain.from_iterable(</span>
            <span class="s1">(_safe_indexing(a</span><span class="s3">, </span><span class="s1">train)</span><span class="s3">, </span><span class="s1">_safe_indexing(a</span><span class="s3">, </span><span class="s1">test)) </span><span class="s3">for </span><span class="s1">a </span><span class="s3">in </span><span class="s1">arrays</span>
        <span class="s1">)</span>
    <span class="s1">)</span>


<span class="s2"># Tell nose that train_test_split is not a test.</span>
<span class="s2"># (Needed for external libraries that may use nose.)</span>
<span class="s2"># Use setattr to avoid mypy errors when monkeypatching.</span>
<span class="s1">setattr(train_test_split</span><span class="s3">, </span><span class="s4">&quot;__test__&quot;</span><span class="s3">, False</span><span class="s1">)</span>


<span class="s3">def </span><span class="s1">_pprint(params</span><span class="s3">, </span><span class="s1">offset=</span><span class="s5">0</span><span class="s3">, </span><span class="s1">printer=repr):</span>
    <span class="s0">&quot;&quot;&quot;Pretty print the dictionary 'params' 
 
    Parameters 
    ---------- 
    params : dict 
        The dictionary to pretty print 
 
    offset : int, default=0 
        The offset in characters to add at the begin of each line. 
 
    printer : callable, default=repr 
        The function to convert entries to strings, typically 
        the builtin str or repr 
 
    &quot;&quot;&quot;</span>
    <span class="s2"># Do a multi-line justified repr:</span>
    <span class="s1">options = np.get_printoptions()</span>
    <span class="s1">np.set_printoptions(precision=</span><span class="s5">5</span><span class="s3">, </span><span class="s1">threshold=</span><span class="s5">64</span><span class="s3">, </span><span class="s1">edgeitems=</span><span class="s5">2</span><span class="s1">)</span>
    <span class="s1">params_list = list()</span>
    <span class="s1">this_line_length = offset</span>
    <span class="s1">line_sep = </span><span class="s4">&quot;,</span><span class="s3">\n</span><span class="s4">&quot; </span><span class="s1">+ (</span><span class="s5">1 </span><span class="s1">+ offset // </span><span class="s5">2</span><span class="s1">) * </span><span class="s4">&quot; &quot;</span>
    <span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">(k</span><span class="s3">, </span><span class="s1">v) </span><span class="s3">in </span><span class="s1">enumerate(sorted(params.items())):</span>
        <span class="s3">if </span><span class="s1">isinstance(v</span><span class="s3">, </span><span class="s1">float):</span>
            <span class="s2"># use str for representing floating point numbers</span>
            <span class="s2"># this way we get consistent representation across</span>
            <span class="s2"># architectures and versions.</span>
            <span class="s1">this_repr = </span><span class="s4">&quot;%s=%s&quot; </span><span class="s1">% (k</span><span class="s3">, </span><span class="s1">str(v))</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s2"># use repr of the rest</span>
            <span class="s1">this_repr = </span><span class="s4">&quot;%s=%s&quot; </span><span class="s1">% (k</span><span class="s3">, </span><span class="s1">printer(v))</span>
        <span class="s3">if </span><span class="s1">len(this_repr) &gt; </span><span class="s5">500</span><span class="s1">:</span>
            <span class="s1">this_repr = this_repr[:</span><span class="s5">300</span><span class="s1">] + </span><span class="s4">&quot;...&quot; </span><span class="s1">+ this_repr[-</span><span class="s5">100</span><span class="s1">:]</span>
        <span class="s3">if </span><span class="s1">i &gt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">this_line_length + len(this_repr) &gt;= </span><span class="s5">75 </span><span class="s3">or </span><span class="s4">&quot;</span><span class="s3">\n</span><span class="s4">&quot; </span><span class="s3">in </span><span class="s1">this_repr:</span>
                <span class="s1">params_list.append(line_sep)</span>
                <span class="s1">this_line_length = len(line_sep)</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">params_list.append(</span><span class="s4">&quot;, &quot;</span><span class="s1">)</span>
                <span class="s1">this_line_length += </span><span class="s5">2</span>
        <span class="s1">params_list.append(this_repr)</span>
        <span class="s1">this_line_length += len(this_repr)</span>

    <span class="s1">np.set_printoptions(**options)</span>
    <span class="s1">lines = </span><span class="s4">&quot;&quot;</span><span class="s1">.join(params_list)</span>
    <span class="s2"># Strip trailing space to avoid nightmare in doctests</span>
    <span class="s1">lines = </span><span class="s4">&quot;</span><span class="s3">\n</span><span class="s4">&quot;</span><span class="s1">.join(l.rstrip(</span><span class="s4">&quot; &quot;</span><span class="s1">) </span><span class="s3">for </span><span class="s1">l </span><span class="s3">in </span><span class="s1">lines.split(</span><span class="s4">&quot;</span><span class="s3">\n</span><span class="s4">&quot;</span><span class="s1">))</span>
    <span class="s3">return </span><span class="s1">lines</span>


<span class="s3">def </span><span class="s1">_build_repr(self):</span>
    <span class="s2"># XXX This is copied from BaseEstimator's get_params</span>
    <span class="s1">cls = self.__class__</span>
    <span class="s1">init = getattr(cls.__init__</span><span class="s3">, </span><span class="s4">&quot;deprecated_original&quot;</span><span class="s3">, </span><span class="s1">cls.__init__)</span>
    <span class="s2"># Ignore varargs, kw and default values and pop self</span>
    <span class="s1">init_signature = signature(init)</span>
    <span class="s2"># Consider the constructor parameters excluding 'self'</span>
    <span class="s3">if </span><span class="s1">init </span><span class="s3">is </span><span class="s1">object.__init__:</span>
        <span class="s1">args = []</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">args = sorted(</span>
            <span class="s1">[</span>
                <span class="s1">p.name</span>
                <span class="s3">for </span><span class="s1">p </span><span class="s3">in </span><span class="s1">init_signature.parameters.values()</span>
                <span class="s3">if </span><span class="s1">p.name != </span><span class="s4">&quot;self&quot; </span><span class="s3">and </span><span class="s1">p.kind != p.VAR_KEYWORD</span>
            <span class="s1">]</span>
        <span class="s1">)</span>
    <span class="s1">class_name = self.__class__.__name__</span>
    <span class="s1">params = dict()</span>
    <span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">args:</span>
        <span class="s2"># We need deprecation warnings to always be on in order to</span>
        <span class="s2"># catch deprecated param values.</span>
        <span class="s2"># This is set in utils/__init__.py but it gets overwritten</span>
        <span class="s2"># when running under python3 somehow.</span>
        <span class="s1">warnings.simplefilter(</span><span class="s4">&quot;always&quot;</span><span class="s3">, </span><span class="s1">FutureWarning)</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s3">with </span><span class="s1">warnings.catch_warnings(record=</span><span class="s3">True</span><span class="s1">) </span><span class="s3">as </span><span class="s1">w:</span>
                <span class="s1">value = getattr(self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, None</span><span class="s1">)</span>
                <span class="s3">if </span><span class="s1">value </span><span class="s3">is None and </span><span class="s1">hasattr(self</span><span class="s3">, </span><span class="s4">&quot;cvargs&quot;</span><span class="s1">):</span>
                    <span class="s1">value = self.cvargs.get(key</span><span class="s3">, None</span><span class="s1">)</span>
            <span class="s3">if </span><span class="s1">len(w) </span><span class="s3">and </span><span class="s1">w[</span><span class="s5">0</span><span class="s1">].category == FutureWarning:</span>
                <span class="s2"># if the parameter is deprecated, don't show it</span>
                <span class="s3">continue</span>
        <span class="s3">finally</span><span class="s1">:</span>
            <span class="s1">warnings.filters.pop(</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">params[key] = value</span>

    <span class="s3">return </span><span class="s4">&quot;%s(%s)&quot; </span><span class="s1">% (class_name</span><span class="s3">, </span><span class="s1">_pprint(params</span><span class="s3">, </span><span class="s1">offset=len(class_name)))</span>


<span class="s3">def </span><span class="s1">_yields_constant_splits(cv):</span>
    <span class="s2"># Return True if calling cv.split() always returns the same splits</span>
    <span class="s2"># We assume that if a cv doesn't have a shuffle parameter, it shuffles by</span>
    <span class="s2"># default (e.g. ShuffleSplit). If it actually doesn't shuffle (e.g.</span>
    <span class="s2"># LeaveOneOut), then it won't have a random_state parameter anyway, in</span>
    <span class="s2"># which case it will default to 0, leading to output=True</span>
    <span class="s1">shuffle = getattr(cv</span><span class="s3">, </span><span class="s4">&quot;shuffle&quot;</span><span class="s3">, True</span><span class="s1">)</span>
    <span class="s1">random_state = getattr(cv</span><span class="s3">, </span><span class="s4">&quot;random_state&quot;</span><span class="s3">, </span><span class="s5">0</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">isinstance(random_state</span><span class="s3">, </span><span class="s1">numbers.Integral) </span><span class="s3">or not </span><span class="s1">shuffle</span>
</pre>
</body>
</html>