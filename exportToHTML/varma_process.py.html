<html>
<head>
<title>varma_process.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #808080;}
.s1 { color: #a9b7c6;}
.s2 { color: #629755; font-style: italic;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
varma_process.py</font>
</center></td></tr></table>
<pre><span class="s0"># -*- coding: utf-8 -*-</span>
<span class="s2">&quot;&quot;&quot; Helper and filter functions for VAR and VARMA, and basic VAR class 
 
Created on Mon Jan 11 11:04:23 2010 
Author: josef-pktd 
License: BSD 
 
This is a new version, I did not look at the old version again, but similar 
ideas. 
 
not copied/cleaned yet: 
 * fftn based filtering, creating samples with fft 
 * Tests: I ran examples but did not convert them to tests 
   examples look good for parameter estimate and forecast, and filter functions 
 
main TODOs: 
* result statistics 
* see whether Bayesian dummy observation can be included without changing 
  the single call to linalg.lstsq 
* impulse response function does not treat correlation, see Hamilton and jplv 
 
Extensions 
* constraints, Bayesian priors/penalization 
* Error Correction Form and Cointegration 
* Factor Models Stock-Watson,  ??? 
 
 
see also VAR section in Notes.txt 
 
&quot;&quot;&quot;</span>
<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">from </span><span class="s1">scipy </span><span class="s3">import </span><span class="s1">signal</span>

<span class="s3">from </span><span class="s1">statsmodels.tsa.tsatools </span><span class="s3">import </span><span class="s1">lagmat</span>


<span class="s3">def </span><span class="s1">varfilter(x</span><span class="s3">, </span><span class="s1">a):</span>
    <span class="s2">'''apply an autoregressive filter to a series x 
 
    Warning: I just found out that convolve does not work as I 
       thought, this likely does not work correctly for 
       nvars&gt;3 
 
 
    x can be 2d, a can be 1d, 2d, or 3d 
 
    Parameters 
    ---------- 
    x : array_like 
        data array, 1d or 2d, if 2d then observations in rows 
    a : array_like 
        autoregressive filter coefficients, ar lag polynomial 
        see Notes 
 
    Returns 
    ------- 
    y : ndarray, 2d 
        filtered array, number of columns determined by x and a 
 
    Notes 
    ----- 
 
    In general form this uses the linear filter :: 
 
        y = a(L)x 
 
    where 
    x : nobs, nvars 
    a : nlags, nvars, npoly 
 
    Depending on the shape and dimension of a this uses different 
    Lag polynomial arrays 
 
    case 1 : a is 1d or (nlags,1) 
        one lag polynomial is applied to all variables (columns of x) 
    case 2 : a is 2d, (nlags, nvars) 
        each series is independently filtered with its own 
        lag polynomial, uses loop over nvar 
    case 3 : a is 3d, (nlags, nvars, npoly) 
        the ith column of the output array is given by the linear filter 
        defined by the 2d array a[:,:,i], i.e. :: 
 
            y[:,i] = a(.,.,i)(L) * x 
            y[t,i] = sum_p sum_j a(p,j,i)*x(t-p,j) 
                     for p = 0,...nlags-1, j = 0,...nvars-1, 
                     for all t &gt;= nlags 
 
 
    Note: maybe convert to axis=1, Not 
 
    TODO: initial conditions 
 
    '''</span>
    <span class="s1">x = np.asarray(x)</span>
    <span class="s1">a = np.asarray(a)</span>
    <span class="s3">if </span><span class="s1">x.ndim == </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s1">x = x[:</span><span class="s3">,None</span><span class="s1">]</span>
    <span class="s3">if </span><span class="s1">x.ndim &gt; </span><span class="s4">2</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'x array has to be 1d or 2d'</span><span class="s1">)</span>
    <span class="s1">nvar = x.shape[</span><span class="s4">1</span><span class="s1">]</span>
    <span class="s1">nlags = a.shape[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">ntrim = nlags//</span><span class="s4">2</span>
    <span class="s0"># for x is 2d with ncols &gt;1</span>

    <span class="s3">if </span><span class="s1">a.ndim == </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s0"># case: identical ar filter (lag polynomial)</span>
        <span class="s3">return </span><span class="s1">signal.convolve(x</span><span class="s3">, </span><span class="s1">a[:</span><span class="s3">,None</span><span class="s1">]</span><span class="s3">, </span><span class="s1">mode=</span><span class="s5">'valid'</span><span class="s1">)</span>
        <span class="s0"># alternative:</span>
        <span class="s0">#return signal.lfilter(a,[1],x.astype(float),axis=0)</span>
    <span class="s3">elif </span><span class="s1">a.ndim == </span><span class="s4">2</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">min(a.shape) == </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s0"># case: identical ar filter (lag polynomial)</span>
            <span class="s3">return </span><span class="s1">signal.convolve(x</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">mode=</span><span class="s5">'valid'</span><span class="s1">)</span>

        <span class="s0"># case: independent ar</span>
        <span class="s0">#(a bit like recserar in gauss, but no x yet)</span>
        <span class="s0">#(no, reserar is inverse filter)</span>
        <span class="s1">result = np.zeros((x.shape[</span><span class="s4">0</span><span class="s1">]-nlags+</span><span class="s4">1</span><span class="s3">, </span><span class="s1">nvar))</span>
        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(nvar):</span>
            <span class="s0"># could also use np.convolve, but easier for swiching to fft</span>
            <span class="s1">result[:</span><span class="s3">,</span><span class="s1">i] = signal.convolve(x[:</span><span class="s3">,</span><span class="s1">i]</span><span class="s3">, </span><span class="s1">a[:</span><span class="s3">,</span><span class="s1">i]</span><span class="s3">, </span><span class="s1">mode=</span><span class="s5">'valid'</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">result</span>

    <span class="s3">elif </span><span class="s1">a.ndim == </span><span class="s4">3</span><span class="s1">:</span>
        <span class="s0"># case: vector autoregressive with lag matrices</span>
        <span class="s0"># Note: we must have shape[1] == shape[2] == nvar</span>
        <span class="s1">yf = signal.convolve(x[:</span><span class="s3">,</span><span class="s1">:</span><span class="s3">,None</span><span class="s1">]</span><span class="s3">, </span><span class="s1">a)</span>
        <span class="s1">yvalid = yf[ntrim:-ntrim</span><span class="s3">, </span><span class="s1">yf.shape[</span><span class="s4">1</span><span class="s1">]//</span><span class="s4">2</span><span class="s3">,</span><span class="s1">:]</span>
        <span class="s3">return </span><span class="s1">yvalid</span>


<span class="s3">def </span><span class="s1">varinversefilter(ar</span><span class="s3">, </span><span class="s1">nobs</span><span class="s3">, </span><span class="s1">version=</span><span class="s4">1</span><span class="s1">):</span>
    <span class="s2">'''creates inverse ar filter (MA representation) recursively 
 
    The VAR lag polynomial is defined by :: 
 
        ar(L) y_t = u_t  or 
        y_t = -ar_{-1}(L) y_{t-1} + u_t 
 
    the returned lagpolynomial is arinv(L)=ar^{-1}(L) in :: 
 
        y_t = arinv(L) u_t 
 
 
 
    Parameters 
    ---------- 
    ar : ndarray, (nlags,nvars,nvars) 
        matrix lagpolynomial, currently no exog 
        first row should be identity 
 
    Returns 
    ------- 
    arinv : ndarray, (nobs,nvars,nvars) 
 
 
    Notes 
    ----- 
 
    '''</span>
    <span class="s1">nlags</span><span class="s3">, </span><span class="s1">nvars</span><span class="s3">, </span><span class="s1">nvarsex = ar.shape</span>
    <span class="s3">if </span><span class="s1">nvars != nvarsex:</span>
        <span class="s1">print(</span><span class="s5">'exogenous variables not implemented not tested'</span><span class="s1">)</span>
    <span class="s1">arinv = np.zeros((nobs+</span><span class="s4">1</span><span class="s3">, </span><span class="s1">nvarsex</span><span class="s3">, </span><span class="s1">nvars))</span>
    <span class="s1">arinv[</span><span class="s4">0</span><span class="s3">,</span><span class="s1">:</span><span class="s3">,</span><span class="s1">:] = ar[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s1">arinv[</span><span class="s4">1</span><span class="s1">:nlags</span><span class="s3">,</span><span class="s1">:</span><span class="s3">,</span><span class="s1">:] = -ar[</span><span class="s4">1</span><span class="s1">:]</span>
    <span class="s3">if </span><span class="s1">version == </span><span class="s4">1</span><span class="s1">:</span>
        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(</span><span class="s4">2</span><span class="s3">,</span><span class="s1">nobs+</span><span class="s4">1</span><span class="s1">):</span>
            <span class="s1">tmp = np.zeros((nvars</span><span class="s3">,</span><span class="s1">nvars))</span>
            <span class="s3">for </span><span class="s1">p </span><span class="s3">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s3">,</span><span class="s1">nlags):</span>
                <span class="s1">tmp += np.dot(-ar[p]</span><span class="s3">,</span><span class="s1">arinv[i-p</span><span class="s3">,</span><span class="s1">:</span><span class="s3">,</span><span class="s1">:])</span>
            <span class="s1">arinv[i</span><span class="s3">,</span><span class="s1">:</span><span class="s3">,</span><span class="s1">:] = tmp</span>
    <span class="s3">if </span><span class="s1">version == </span><span class="s4">0</span><span class="s1">:</span>
        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(nlags+</span><span class="s4">1</span><span class="s3">,</span><span class="s1">nobs+</span><span class="s4">1</span><span class="s1">):</span>
            <span class="s1">print(ar[</span><span class="s4">1</span><span class="s1">:].shape</span><span class="s3">, </span><span class="s1">arinv[i-</span><span class="s4">1</span><span class="s1">:i-nlags:-</span><span class="s4">1</span><span class="s3">,</span><span class="s1">:</span><span class="s3">,</span><span class="s1">:].shape)</span>
            <span class="s0">#arinv[i,:,:] = np.dot(-ar[1:],arinv[i-1:i-nlags:-1,:,:])</span>
            <span class="s0">#print(np.tensordot(-ar[1:],arinv[i-1:i-nlags:-1,:,:],axes=([2],[1])).shape</span>
            <span class="s0">#arinv[i,:,:] = np.tensordot(-ar[1:],arinv[i-1:i-nlags:-1,:,:],axes=([2],[1]))</span>
            <span class="s3">raise </span><span class="s1">NotImplementedError(</span><span class="s5">'waiting for generalized ufuncs or something'</span><span class="s1">)</span>

    <span class="s3">return </span><span class="s1">arinv</span>


<span class="s3">def </span><span class="s1">vargenerate(ar</span><span class="s3">, </span><span class="s1">u</span><span class="s3">, </span><span class="s1">initvalues=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s2">'''generate an VAR process with errors u 
 
    similar to gauss 
    uses loop 
 
    Parameters 
    ---------- 
    ar : array (nlags,nvars,nvars) 
        matrix lagpolynomial 
    u : array (nobs,nvars) 
        exogenous variable, error term for VAR 
 
    Returns 
    ------- 
    sar : array (1+nobs,nvars) 
        sample of var process, inverse filtered u 
        does not trim initial condition y_0 = 0 
 
    Examples 
    -------- 
    # generate random sample of VAR 
    nobs, nvars = 10, 2 
    u = numpy.random.randn(nobs,nvars) 
    a21 = np.array([[[ 1. ,  0. ], 
                     [ 0. ,  1. ]], 
 
                    [[-0.8,  0. ], 
                     [ 0.,  -0.6]]]) 
    vargenerate(a21,u) 
 
    # Impulse Response to an initial shock to the first variable 
    imp = np.zeros((nobs, nvars)) 
    imp[0,0] = 1 
    vargenerate(a21,imp) 
 
    '''</span>
    <span class="s1">nlags</span><span class="s3">, </span><span class="s1">nvars</span><span class="s3">, </span><span class="s1">nvarsex = ar.shape</span>
    <span class="s1">nlagsm1 = nlags - </span><span class="s4">1</span>
    <span class="s1">nobs = u.shape[</span><span class="s4">0</span><span class="s1">]</span>
    <span class="s3">if </span><span class="s1">nvars != nvarsex:</span>
        <span class="s1">print(</span><span class="s5">'exogenous variables not implemented not tested'</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">u.shape[</span><span class="s4">1</span><span class="s1">] != nvars:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'u needs to have nvars columns'</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">initvalues </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">sar = np.zeros((nobs+nlagsm1</span><span class="s3">, </span><span class="s1">nvars))</span>
        <span class="s1">start = nlagsm1</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">start = max(nlagsm1</span><span class="s3">, </span><span class="s1">initvalues.shape[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">sar = np.zeros((nobs+start</span><span class="s3">, </span><span class="s1">nvars))</span>
        <span class="s1">sar[start-initvalues.shape[</span><span class="s4">0</span><span class="s1">]:start] = initvalues</span>
    <span class="s0">#sar[nlagsm1:] = u</span>
    <span class="s1">sar[start:] = u</span>
    <span class="s0">#if version == 1:</span>
    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(start</span><span class="s3">,</span><span class="s1">start+nobs):</span>
        <span class="s3">for </span><span class="s1">p </span><span class="s3">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s3">,</span><span class="s1">nlags):</span>
            <span class="s1">sar[i] += np.dot(sar[i-p</span><span class="s3">,</span><span class="s1">:]</span><span class="s3">,</span><span class="s1">-ar[p])</span>

    <span class="s3">return </span><span class="s1">sar</span>


<span class="s3">def </span><span class="s1">padone(x</span><span class="s3">, </span><span class="s1">front=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">back=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">fillvalue=</span><span class="s4">0</span><span class="s1">):</span>
    <span class="s2">'''pad with zeros along one axis, currently only axis=0 
 
 
    can be used sequentially to pad several axis 
 
    Examples 
    -------- 
    &gt;&gt;&gt; padone(np.ones((2,3)),1,3,axis=1) 
    array([[ 0.,  1.,  1.,  1.,  0.,  0.,  0.], 
           [ 0.,  1.,  1.,  1.,  0.,  0.,  0.]]) 
 
    &gt;&gt;&gt; padone(np.ones((2,3)),1,1, fillvalue=np.nan) 
    array([[ NaN,  NaN,  NaN], 
           [  1.,   1.,   1.], 
           [  1.,   1.,   1.], 
           [ NaN,  NaN,  NaN]]) 
    '''</span>
    <span class="s0">#primitive version</span>
    <span class="s1">shape = np.array(x.shape)</span>
    <span class="s1">shape[axis] += (front + back)</span>
    <span class="s1">shapearr = np.array(x.shape)</span>
    <span class="s1">out = np.empty(shape)</span>
    <span class="s1">out.fill(fillvalue)</span>
    <span class="s1">startind = np.zeros(x.ndim)</span>
    <span class="s1">startind[axis] = front</span>
    <span class="s1">endind = startind + shapearr</span>
    <span class="s1">myslice = [slice(startind[k]</span><span class="s3">, </span><span class="s1">endind[k]) </span><span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">range(len(endind))]</span>
    <span class="s0">#print(myslice</span>
    <span class="s0">#print(out.shape</span>
    <span class="s0">#print(out[tuple(myslice)].shape</span>
    <span class="s1">out[tuple(myslice)] = x</span>
    <span class="s3">return </span><span class="s1">out</span>


<span class="s3">def </span><span class="s1">trimone(x</span><span class="s3">, </span><span class="s1">front=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">back=</span><span class="s4">0</span><span class="s3">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">):</span>
    <span class="s2">'''trim number of array elements along one axis 
 
 
    Examples 
    -------- 
    &gt;&gt;&gt; xp = padone(np.ones((2,3)),1,3,axis=1) 
    &gt;&gt;&gt; xp 
    array([[ 0.,  1.,  1.,  1.,  0.,  0.,  0.], 
           [ 0.,  1.,  1.,  1.,  0.,  0.,  0.]]) 
    &gt;&gt;&gt; trimone(xp,1,3,1) 
    array([[ 1.,  1.,  1.], 
           [ 1.,  1.,  1.]]) 
    '''</span>
    <span class="s1">shape = np.array(x.shape)</span>
    <span class="s1">shape[axis] -= (front + back)</span>
    <span class="s0">#print(shape, front, back</span>
    <span class="s1">shapearr = np.array(x.shape)</span>
    <span class="s1">startind = np.zeros(x.ndim)</span>
    <span class="s1">startind[axis] = front</span>
    <span class="s1">endind = startind + shape</span>
    <span class="s1">myslice = [slice(startind[k]</span><span class="s3">, </span><span class="s1">endind[k]) </span><span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">range(len(endind))]</span>
    <span class="s0">#print(myslice</span>
    <span class="s0">#print(shape, endind</span>
    <span class="s0">#print(x[tuple(myslice)].shape</span>
    <span class="s3">return </span><span class="s1">x[tuple(myslice)]</span>


<span class="s3">def </span><span class="s1">ar2full(ar):</span>
    <span class="s2">'''make reduced lagpolynomial into a right side lagpoly array 
    '''</span>
    <span class="s1">nlags</span><span class="s3">, </span><span class="s1">nvar</span><span class="s3">,</span><span class="s1">nvarex = ar.shape</span>
    <span class="s3">return </span><span class="s1">np.r_[np.eye(nvar</span><span class="s3">,</span><span class="s1">nvarex)[</span><span class="s3">None,</span><span class="s1">:</span><span class="s3">,</span><span class="s1">:]</span><span class="s3">,</span><span class="s1">-ar]</span>


<span class="s3">def </span><span class="s1">ar2lhs(ar):</span>
    <span class="s2">'''convert full (rhs) lagpolynomial into a reduced, left side lagpoly array 
 
    this is mainly a reminder about the definition 
    '''</span>
    <span class="s3">return </span><span class="s1">-ar[</span><span class="s4">1</span><span class="s1">:]</span>


<span class="s3">class </span><span class="s1">_Var:</span>
    <span class="s2">'''obsolete VAR class, use tsa.VAR instead, for internal use only 
 
 
    Examples 
    -------- 
 
    &gt;&gt;&gt; v = Var(ar2s) 
    &gt;&gt;&gt; v.fit(1) 
    &gt;&gt;&gt; v.arhat 
    array([[[ 1.        ,  0.        ], 
            [ 0.        ,  1.        ]], 
 
           [[-0.77784898,  0.01726193], 
            [ 0.10733009, -0.78665335]]]) 
 
    '''</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">y):</span>
        <span class="s1">self.y = y</span>
        <span class="s1">self.nobs</span><span class="s3">, </span><span class="s1">self.nvars = y.shape</span>

    <span class="s3">def </span><span class="s1">fit(self</span><span class="s3">, </span><span class="s1">nlags):</span>
        <span class="s2">'''estimate parameters using ols 
 
        Parameters 
        ---------- 
        nlags : int 
            number of lags to include in regression, same for all variables 
 
        Returns 
        ------- 
        None, but attaches 
 
        arhat : array (nlags, nvar, nvar) 
            full lag polynomial array 
        arlhs : array (nlags-1, nvar, nvar) 
            reduced lag polynomial for left hand side 
        other statistics as returned by linalg.lstsq : need to be completed 
 
 
 
        This currently assumes all parameters are estimated without restrictions. 
        In this case SUR is identical to OLS 
 
        estimation results are attached to the class instance 
 
 
        '''</span>
        <span class="s1">self.nlags = nlags </span><span class="s0"># without current period</span>
        <span class="s1">nvars = self.nvars</span>
        <span class="s0">#TODO: ar2s looks like a module variable, bug?</span>
        <span class="s0">#lmat = lagmat(ar2s, nlags, trim='both', original='in')</span>
        <span class="s1">lmat = lagmat(self.y</span><span class="s3">, </span><span class="s1">nlags</span><span class="s3">, </span><span class="s1">trim=</span><span class="s5">'both'</span><span class="s3">, </span><span class="s1">original=</span><span class="s5">'in'</span><span class="s1">)</span>
        <span class="s1">self.yred = lmat[:</span><span class="s3">,</span><span class="s1">:nvars]</span>
        <span class="s1">self.xred = lmat[:</span><span class="s3">,</span><span class="s1">nvars:]</span>
        <span class="s1">res = np.linalg.lstsq(self.xred</span><span class="s3">, </span><span class="s1">self.yred</span><span class="s3">, </span><span class="s1">rcond=-</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">self.estresults = res</span>
        <span class="s1">self.arlhs = res[</span><span class="s4">0</span><span class="s1">].reshape(nlags</span><span class="s3">, </span><span class="s1">nvars</span><span class="s3">, </span><span class="s1">nvars)</span>
        <span class="s1">self.arhat = ar2full(self.arlhs)</span>
        <span class="s1">self.rss = res[</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">self.xredrank = res[</span><span class="s4">2</span><span class="s1">]</span>

    <span class="s3">def </span><span class="s1">predict(self):</span>
        <span class="s2">'''calculate estimated timeseries (yhat) for sample 
 
        '''</span>

        <span class="s3">if not </span><span class="s1">hasattr(self</span><span class="s3">, </span><span class="s5">'yhat'</span><span class="s1">):</span>
            <span class="s1">self.yhat = varfilter(self.y</span><span class="s3">, </span><span class="s1">self.arhat)</span>
        <span class="s3">return </span><span class="s1">self.yhat</span>

    <span class="s3">def </span><span class="s1">covmat(self):</span>
        <span class="s2">''' covariance matrix of estimate 
        # not sure it's correct, need to check orientation everywhere 
        # looks ok, display needs getting used to 
        &gt;&gt;&gt; v.rss[None,None,:]*np.linalg.inv(np.dot(v.xred.T,v.xred))[:,:,None] 
        array([[[ 0.37247445,  0.32210609], 
                [ 0.1002642 ,  0.08670584]], 
 
               [[ 0.1002642 ,  0.08670584], 
                [ 0.45903637,  0.39696255]]]) 
        &gt;&gt;&gt; 
        &gt;&gt;&gt; v.rss[0]*np.linalg.inv(np.dot(v.xred.T,v.xred)) 
        array([[ 0.37247445,  0.1002642 ], 
               [ 0.1002642 ,  0.45903637]]) 
        &gt;&gt;&gt; v.rss[1]*np.linalg.inv(np.dot(v.xred.T,v.xred)) 
        array([[ 0.32210609,  0.08670584], 
               [ 0.08670584,  0.39696255]]) 
       '''</span>

        <span class="s0">#check if orientation is same as self.arhat</span>
        <span class="s1">self.paramcov = (self.rss[</span><span class="s3">None,None,</span><span class="s1">:] *</span>
            <span class="s1">np.linalg.inv(np.dot(self.xred.T</span><span class="s3">, </span><span class="s1">self.xred))[:</span><span class="s3">,</span><span class="s1">:</span><span class="s3">,None</span><span class="s1">])</span>

    <span class="s3">def </span><span class="s1">forecast(self</span><span class="s3">, </span><span class="s1">horiz=</span><span class="s4">1</span><span class="s3">, </span><span class="s1">u=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">'''calculates forcast for horiz number of periods at end of sample 
 
        Parameters 
        ---------- 
        horiz : int (optional, default=1) 
            forecast horizon 
        u : array (horiz, nvars) 
            error term for forecast periods. If None, then u is zero. 
 
        Returns 
        ------- 
        yforecast : array (nobs+horiz, nvars) 
            this includes the sample and the forecasts 
        '''</span>
        <span class="s3">if </span><span class="s1">u </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">u = np.zeros((horiz</span><span class="s3">, </span><span class="s1">self.nvars))</span>
        <span class="s3">return </span><span class="s1">vargenerate(self.arhat</span><span class="s3">, </span><span class="s1">u</span><span class="s3">, </span><span class="s1">initvalues=self.y)</span>


<span class="s3">class </span><span class="s1">VarmaPoly:</span>
    <span class="s2">'''class to keep track of Varma polynomial format 
 
 
    Examples 
    -------- 
 
    ar23 = np.array([[[ 1. ,  0. ], 
                     [ 0. ,  1. ]], 
 
                    [[-0.6,  0. ], 
                     [ 0.2, -0.6]], 
 
                    [[-0.1,  0. ], 
                     [ 0.1, -0.1]]]) 
 
    ma22 = np.array([[[ 1. ,  0. ], 
                     [ 0. ,  1. ]], 
 
                    [[ 0.4,  0. ], 
                     [ 0.2, 0.3]]]) 
 
 
    '''</span>
    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">ar</span><span class="s3">, </span><span class="s1">ma=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">self.ar = ar</span>
        <span class="s1">self.ma = ma</span>
        <span class="s1">nlags</span><span class="s3">, </span><span class="s1">nvarall</span><span class="s3">, </span><span class="s1">nvars = ar.shape</span>
        <span class="s1">self.nlags</span><span class="s3">, </span><span class="s1">self.nvarall</span><span class="s3">, </span><span class="s1">self.nvars = nlags</span><span class="s3">, </span><span class="s1">nvarall</span><span class="s3">, </span><span class="s1">nvars</span>
        <span class="s1">self.isstructured = </span><span class="s3">not </span><span class="s1">(ar[</span><span class="s4">0</span><span class="s3">,</span><span class="s1">:nvars] == np.eye(nvars)).all()</span>
        <span class="s3">if </span><span class="s1">self.ma </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">self.ma = np.eye(nvars)[</span><span class="s3">None,</span><span class="s1">...]</span>
            <span class="s1">self.isindependent = </span><span class="s3">True</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">self.isindependent = </span><span class="s3">not </span><span class="s1">(ma[</span><span class="s4">0</span><span class="s1">] == np.eye(nvars)).all()</span>
        <span class="s1">self.malags = ar.shape[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">self.hasexog = nvarall &gt; nvars</span>
        <span class="s1">self.arm1 = -ar[</span><span class="s4">1</span><span class="s1">:]</span>

    <span class="s0">#@property</span>
    <span class="s3">def </span><span class="s1">vstack(self</span><span class="s3">, </span><span class="s1">a=</span><span class="s3">None, </span><span class="s1">name=</span><span class="s5">'ar'</span><span class="s1">):</span>
        <span class="s2">'''stack lagpolynomial vertically in 2d array 
 
        '''</span>
        <span class="s3">if </span><span class="s1">a </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">a = a</span>
        <span class="s3">elif </span><span class="s1">name == </span><span class="s5">'ar'</span><span class="s1">:</span>
            <span class="s1">a = self.ar</span>
        <span class="s3">elif </span><span class="s1">name == </span><span class="s5">'ma'</span><span class="s1">:</span>
            <span class="s1">a = self.ma</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'no array or name given'</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">a.reshape(-</span><span class="s4">1</span><span class="s3">, </span><span class="s1">self.nvarall)</span>

    <span class="s0">#@property</span>
    <span class="s3">def </span><span class="s1">hstack(self</span><span class="s3">, </span><span class="s1">a=</span><span class="s3">None, </span><span class="s1">name=</span><span class="s5">'ar'</span><span class="s1">):</span>
        <span class="s2">'''stack lagpolynomial horizontally in 2d array 
 
        '''</span>
        <span class="s3">if </span><span class="s1">a </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">a = a</span>
        <span class="s3">elif </span><span class="s1">name == </span><span class="s5">'ar'</span><span class="s1">:</span>
            <span class="s1">a = self.ar</span>
        <span class="s3">elif </span><span class="s1">name == </span><span class="s5">'ma'</span><span class="s1">:</span>
            <span class="s1">a = self.ma</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'no array or name given'</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">a.swapaxes(</span><span class="s4">1</span><span class="s3">,</span><span class="s4">2</span><span class="s1">).reshape(-</span><span class="s4">1</span><span class="s3">, </span><span class="s1">self.nvarall).T</span>

    <span class="s0">#@property</span>
    <span class="s3">def </span><span class="s1">stacksquare(self</span><span class="s3">, </span><span class="s1">a=</span><span class="s3">None, </span><span class="s1">name=</span><span class="s5">'ar'</span><span class="s3">, </span><span class="s1">orientation=</span><span class="s5">'vertical'</span><span class="s1">):</span>
        <span class="s2">'''stack lagpolynomial vertically in 2d square array with eye 
 
        '''</span>
        <span class="s3">if </span><span class="s1">a </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">a = a</span>
        <span class="s3">elif </span><span class="s1">name == </span><span class="s5">'ar'</span><span class="s1">:</span>
            <span class="s1">a = self.ar</span>
        <span class="s3">elif </span><span class="s1">name == </span><span class="s5">'ma'</span><span class="s1">:</span>
            <span class="s1">a = self.ma</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'no array or name given'</span><span class="s1">)</span>
        <span class="s1">astacked = a.reshape(-</span><span class="s4">1</span><span class="s3">, </span><span class="s1">self.nvarall)</span>
        <span class="s1">lenpk</span><span class="s3">, </span><span class="s1">nvars = astacked.shape </span><span class="s0">#[0]</span>
        <span class="s1">amat = np.eye(lenpk</span><span class="s3">, </span><span class="s1">k=nvars)</span>
        <span class="s1">amat[:</span><span class="s3">,</span><span class="s1">:nvars] = astacked</span>
        <span class="s3">return </span><span class="s1">amat</span>

    <span class="s0">#@property</span>
    <span class="s3">def </span><span class="s1">vstackarma_minus1(self):</span>
        <span class="s2">'''stack ar and lagpolynomial vertically in 2d array 
 
        '''</span>
        <span class="s1">a = np.concatenate((self.ar[</span><span class="s4">1</span><span class="s1">:]</span><span class="s3">, </span><span class="s1">self.ma[</span><span class="s4">1</span><span class="s1">:])</span><span class="s3">,</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">a.reshape(-</span><span class="s4">1</span><span class="s3">, </span><span class="s1">self.nvarall)</span>

    <span class="s0">#@property</span>
    <span class="s3">def </span><span class="s1">hstackarma_minus1(self):</span>
        <span class="s2">'''stack ar and lagpolynomial vertically in 2d array 
 
        this is the Kalman Filter representation, I think 
        '''</span>
        <span class="s1">a = np.concatenate((self.ar[</span><span class="s4">1</span><span class="s1">:]</span><span class="s3">, </span><span class="s1">self.ma[</span><span class="s4">1</span><span class="s1">:])</span><span class="s3">,</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">a.swapaxes(</span><span class="s4">1</span><span class="s3">,</span><span class="s4">2</span><span class="s1">).reshape(-</span><span class="s4">1</span><span class="s3">, </span><span class="s1">self.nvarall)</span>

    <span class="s3">def </span><span class="s1">getisstationary(self</span><span class="s3">, </span><span class="s1">a=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">'''check whether the auto-regressive lag-polynomial is stationary 
 
        Returns 
        ------- 
        isstationary : bool 
 
        *attaches* 
 
        areigenvalues : complex array 
            eigenvalues sorted by absolute value 
 
        References 
        ---------- 
        formula taken from NAG manual 
 
        '''</span>
        <span class="s3">if </span><span class="s1">a </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">a = a</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">self.isstructured:</span>
                <span class="s1">a = -self.reduceform(self.ar)[</span><span class="s4">1</span><span class="s1">:]</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">a = -self.ar[</span><span class="s4">1</span><span class="s1">:]</span>
        <span class="s1">amat = self.stacksquare(a)</span>
        <span class="s1">ev = np.sort(np.linalg.eigvals(amat))[::-</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">self.areigenvalues = ev</span>
        <span class="s3">return </span><span class="s1">(np.abs(ev) &lt; </span><span class="s4">1</span><span class="s1">).all()</span>

    <span class="s3">def </span><span class="s1">getisinvertible(self</span><span class="s3">, </span><span class="s1">a=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s2">'''check whether the auto-regressive lag-polynomial is stationary 
 
        Returns 
        ------- 
        isinvertible : bool 
 
        *attaches* 
 
        maeigenvalues : complex array 
            eigenvalues sorted by absolute value 
 
        References 
        ---------- 
        formula taken from NAG manual 
 
        '''</span>
        <span class="s3">if </span><span class="s1">a </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">a = a</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">self.isindependent:</span>
                <span class="s1">a = self.reduceform(self.ma)[</span><span class="s4">1</span><span class="s1">:]</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">a = self.ma[</span><span class="s4">1</span><span class="s1">:]</span>
        <span class="s3">if </span><span class="s1">a.shape[</span><span class="s4">0</span><span class="s1">] == </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s0"># no ma lags</span>
            <span class="s1">self.maeigenvalues = np.array([]</span><span class="s3">, </span><span class="s1">np.complex)</span>
            <span class="s3">return True</span>

        <span class="s1">amat = self.stacksquare(a)</span>
        <span class="s1">ev = np.sort(np.linalg.eigvals(amat))[::-</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">self.maeigenvalues = ev</span>
        <span class="s3">return </span><span class="s1">(np.abs(ev) &lt; </span><span class="s4">1</span><span class="s1">).all()</span>

    <span class="s3">def </span><span class="s1">reduceform(self</span><span class="s3">, </span><span class="s1">apoly):</span>
        <span class="s2">''' 
 
        this assumes no exog, todo 
 
        '''</span>
        <span class="s3">if </span><span class="s1">apoly.ndim != </span><span class="s4">3</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'apoly needs to be 3d'</span><span class="s1">)</span>
        <span class="s1">nlags</span><span class="s3">, </span><span class="s1">nvarsex</span><span class="s3">, </span><span class="s1">nvars = apoly.shape</span>

        <span class="s1">a = np.empty_like(apoly)</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">a0inv = np.linalg.inv(a[</span><span class="s4">0</span><span class="s3">,</span><span class="s1">:nvars</span><span class="s3">, </span><span class="s1">:])</span>
        <span class="s3">except </span><span class="s1">np.linalg.LinAlgError:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s5">'matrix not invertible'</span><span class="s3">,</span>
                             <span class="s5">'ask for implementation of pinv'</span><span class="s1">)</span>

        <span class="s3">for </span><span class="s1">lag </span><span class="s3">in </span><span class="s1">range(nlags):</span>
            <span class="s1">a[lag] = np.dot(a0inv</span><span class="s3">, </span><span class="s1">apoly[lag])</span>

        <span class="s3">return </span><span class="s1">a</span>


<span class="s3">if </span><span class="s1">__name__ == </span><span class="s5">&quot;__main__&quot;</span><span class="s1">:</span>
    <span class="s0"># some example lag polynomials</span>
    <span class="s1">a21 = np.array([[[ </span><span class="s4">1. </span><span class="s3">,  </span><span class="s4">0. </span><span class="s1">]</span><span class="s3">,</span>
                     <span class="s1">[ </span><span class="s4">0. </span><span class="s3">,  </span><span class="s4">1. </span><span class="s1">]]</span><span class="s3">,</span>

                    <span class="s1">[[-</span><span class="s4">0.8</span><span class="s3">,  </span><span class="s4">0. </span><span class="s1">]</span><span class="s3">,</span>
                     <span class="s1">[ </span><span class="s4">0.</span><span class="s3">,  </span><span class="s1">-</span><span class="s4">0.6</span><span class="s1">]]])</span>

    <span class="s1">a22 = np.array([[[ </span><span class="s4">1. </span><span class="s3">,  </span><span class="s4">0. </span><span class="s1">]</span><span class="s3">,</span>
                     <span class="s1">[ </span><span class="s4">0. </span><span class="s3">,  </span><span class="s4">1. </span><span class="s1">]]</span><span class="s3">,</span>

                    <span class="s1">[[-</span><span class="s4">0.8</span><span class="s3">,  </span><span class="s4">0. </span><span class="s1">]</span><span class="s3">,</span>
                     <span class="s1">[ </span><span class="s4">0.1</span><span class="s3">, </span><span class="s1">-</span><span class="s4">0.8</span><span class="s1">]]])</span>

    <span class="s1">a23 = np.array([[[ </span><span class="s4">1. </span><span class="s3">,  </span><span class="s4">0. </span><span class="s1">]</span><span class="s3">,</span>
                     <span class="s1">[ </span><span class="s4">0. </span><span class="s3">,  </span><span class="s4">1. </span><span class="s1">]]</span><span class="s3">,</span>

                    <span class="s1">[[-</span><span class="s4">0.8</span><span class="s3">,  </span><span class="s4">0.2</span><span class="s1">]</span><span class="s3">,</span>
                     <span class="s1">[ </span><span class="s4">0.1</span><span class="s3">, </span><span class="s1">-</span><span class="s4">0.6</span><span class="s1">]]])</span>

    <span class="s1">a24 = np.array([[[ </span><span class="s4">1. </span><span class="s3">,  </span><span class="s4">0. </span><span class="s1">]</span><span class="s3">,</span>
                     <span class="s1">[ </span><span class="s4">0. </span><span class="s3">,  </span><span class="s4">1. </span><span class="s1">]]</span><span class="s3">,</span>

                    <span class="s1">[[-</span><span class="s4">0.6</span><span class="s3">,  </span><span class="s4">0. </span><span class="s1">]</span><span class="s3">,</span>
                     <span class="s1">[ </span><span class="s4">0.2</span><span class="s3">, </span><span class="s1">-</span><span class="s4">0.6</span><span class="s1">]]</span><span class="s3">,</span>

                    <span class="s1">[[-</span><span class="s4">0.1</span><span class="s3">,  </span><span class="s4">0. </span><span class="s1">]</span><span class="s3">,</span>
                     <span class="s1">[ </span><span class="s4">0.1</span><span class="s3">, </span><span class="s1">-</span><span class="s4">0.1</span><span class="s1">]]])</span>

    <span class="s1">a31 = np.r_[np.eye(</span><span class="s4">3</span><span class="s1">)[</span><span class="s3">None,</span><span class="s1">:</span><span class="s3">,</span><span class="s1">:]</span><span class="s3">, </span><span class="s4">0.8</span><span class="s1">*np.eye(</span><span class="s4">3</span><span class="s1">)[</span><span class="s3">None,</span><span class="s1">:</span><span class="s3">,</span><span class="s1">:]]</span>
    <span class="s1">a32 = np.array([[[ </span><span class="s4">1. </span><span class="s3">,  </span><span class="s4">0. </span><span class="s3">,  </span><span class="s4">0. </span><span class="s1">]</span><span class="s3">,</span>
                     <span class="s1">[ </span><span class="s4">0. </span><span class="s3">,  </span><span class="s4">1. </span><span class="s3">,  </span><span class="s4">0. </span><span class="s1">]</span><span class="s3">,</span>
                     <span class="s1">[ </span><span class="s4">0. </span><span class="s3">,  </span><span class="s4">0. </span><span class="s3">,  </span><span class="s4">1. </span><span class="s1">]]</span><span class="s3">,</span>

                    <span class="s1">[[ </span><span class="s4">0.8</span><span class="s3">,  </span><span class="s4">0. </span><span class="s3">,  </span><span class="s4">0. </span><span class="s1">]</span><span class="s3">,</span>
                     <span class="s1">[ </span><span class="s4">0.1</span><span class="s3">,  </span><span class="s4">0.6</span><span class="s3">,  </span><span class="s4">0. </span><span class="s1">]</span><span class="s3">,</span>
                     <span class="s1">[ </span><span class="s4">0. </span><span class="s3">,  </span><span class="s4">0. </span><span class="s3">,  </span><span class="s4">0.9</span><span class="s1">]]])</span>

    <span class="s0">########</span>
    <span class="s1">ut = np.random.randn(</span><span class="s4">1000</span><span class="s3">,</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">ar2s = vargenerate(a22</span><span class="s3">,</span><span class="s1">ut)</span>
    <span class="s0">#res = np.linalg.lstsq(lagmat(ar2s,1)[:,1:], ar2s)</span>
    <span class="s1">res = np.linalg.lstsq(lagmat(ar2s</span><span class="s3">,</span><span class="s4">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">ar2s</span><span class="s3">, </span><span class="s1">rcond=-</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">bhat = res[</span><span class="s4">0</span><span class="s1">].reshape(</span><span class="s4">1</span><span class="s3">,</span><span class="s4">2</span><span class="s3">,</span><span class="s4">2</span><span class="s1">)</span>
    <span class="s1">arhat = ar2full(bhat)</span>
    <span class="s0">#print(maxabs(arhat - a22)</span>

    <span class="s1">v = _Var(ar2s)</span>
    <span class="s1">v.fit(</span><span class="s4">1</span><span class="s1">)</span>
    <span class="s1">v.forecast()</span>
    <span class="s1">v.forecast(</span><span class="s4">25</span><span class="s1">)[-</span><span class="s4">30</span><span class="s1">:]</span>

    <span class="s1">ar23 = np.array([[[ </span><span class="s4">1. </span><span class="s3">,  </span><span class="s4">0. </span><span class="s1">]</span><span class="s3">,</span>
                     <span class="s1">[ </span><span class="s4">0. </span><span class="s3">,  </span><span class="s4">1. </span><span class="s1">]]</span><span class="s3">,</span>

                    <span class="s1">[[-</span><span class="s4">0.6</span><span class="s3">,  </span><span class="s4">0. </span><span class="s1">]</span><span class="s3">,</span>
                     <span class="s1">[ </span><span class="s4">0.2</span><span class="s3">, </span><span class="s1">-</span><span class="s4">0.6</span><span class="s1">]]</span><span class="s3">,</span>

                    <span class="s1">[[-</span><span class="s4">0.1</span><span class="s3">,  </span><span class="s4">0. </span><span class="s1">]</span><span class="s3">,</span>
                     <span class="s1">[ </span><span class="s4">0.1</span><span class="s3">, </span><span class="s1">-</span><span class="s4">0.1</span><span class="s1">]]])</span>

    <span class="s1">ma22 = np.array([[[ </span><span class="s4">1. </span><span class="s3">,  </span><span class="s4">0. </span><span class="s1">]</span><span class="s3">,</span>
                     <span class="s1">[ </span><span class="s4">0. </span><span class="s3">,  </span><span class="s4">1. </span><span class="s1">]]</span><span class="s3">,</span>

                    <span class="s1">[[ </span><span class="s4">0.4</span><span class="s3">,  </span><span class="s4">0. </span><span class="s1">]</span><span class="s3">,</span>
                     <span class="s1">[ </span><span class="s4">0.2</span><span class="s3">, </span><span class="s4">0.3</span><span class="s1">]]])</span>

    <span class="s1">ar23ns = np.array([[[ </span><span class="s4">1. </span><span class="s3">,  </span><span class="s4">0. </span><span class="s1">]</span><span class="s3">,</span>
                     <span class="s1">[ </span><span class="s4">0. </span><span class="s3">,  </span><span class="s4">1. </span><span class="s1">]]</span><span class="s3">,</span>

                    <span class="s1">[[-</span><span class="s4">1.9</span><span class="s3">,  </span><span class="s4">0. </span><span class="s1">]</span><span class="s3">,</span>
                     <span class="s1">[ </span><span class="s4">0.4</span><span class="s3">, </span><span class="s1">-</span><span class="s4">0.6</span><span class="s1">]]</span><span class="s3">,</span>

                    <span class="s1">[[ </span><span class="s4">0.3</span><span class="s3">,  </span><span class="s4">0. </span><span class="s1">]</span><span class="s3">,</span>
                     <span class="s1">[ </span><span class="s4">0.1</span><span class="s3">, </span><span class="s1">-</span><span class="s4">0.1</span><span class="s1">]]])</span>

    <span class="s1">vp = VarmaPoly(ar23</span><span class="s3">, </span><span class="s1">ma22)</span>
    <span class="s1">print(vars(vp))</span>
    <span class="s1">print(vp.vstack())</span>
    <span class="s1">print(vp.vstack(a24))</span>
    <span class="s1">print(vp.hstackarma_minus1())</span>
    <span class="s1">print(vp.getisstationary())</span>
    <span class="s1">print(vp.getisinvertible())</span>

    <span class="s1">vp2 = VarmaPoly(ar23ns)</span>
    <span class="s1">print(vp2.getisstationary())</span>
    <span class="s1">print(vp2.getisinvertible()) </span><span class="s0"># no ma lags</span>
</pre>
</body>
</html>