<html>
<head>
<title>test_nonlin.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_nonlin.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; Unit tests for nonlinear solvers 
Author: Ondrej Certik 
May 2007 
&quot;&quot;&quot;</span>
<span class="s2">from </span><span class="s1">numpy.testing </span><span class="s2">import </span><span class="s1">assert_</span>
<span class="s2">import </span><span class="s1">pytest</span>

<span class="s2">from </span><span class="s1">scipy.optimize </span><span class="s2">import </span><span class="s1">_nonlin </span><span class="s2">as </span><span class="s1">nonlin</span><span class="s2">, </span><span class="s1">root</span>
<span class="s2">from </span><span class="s1">numpy </span><span class="s2">import </span><span class="s1">diag</span><span class="s2">, </span><span class="s1">dot</span>
<span class="s2">from </span><span class="s1">numpy.linalg </span><span class="s2">import </span><span class="s1">inv</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>

<span class="s2">from </span><span class="s1">.test_minpack </span><span class="s2">import </span><span class="s1">pressure_network</span>

<span class="s1">SOLVERS = {</span><span class="s3">'anderson'</span><span class="s1">: nonlin.anderson</span><span class="s2">, </span><span class="s3">'diagbroyden'</span><span class="s1">: nonlin.diagbroyden</span><span class="s2">,</span>
           <span class="s3">'linearmixing'</span><span class="s1">: nonlin.linearmixing</span><span class="s2">, </span><span class="s3">'excitingmixing'</span><span class="s1">: nonlin.excitingmixing</span><span class="s2">,</span>
           <span class="s3">'broyden1'</span><span class="s1">: nonlin.broyden1</span><span class="s2">, </span><span class="s3">'broyden2'</span><span class="s1">: nonlin.broyden2</span><span class="s2">,</span>
           <span class="s3">'krylov'</span><span class="s1">: nonlin.newton_krylov}</span>
<span class="s1">MUST_WORK = {</span><span class="s3">'anderson'</span><span class="s1">: nonlin.anderson</span><span class="s2">, </span><span class="s3">'broyden1'</span><span class="s1">: nonlin.broyden1</span><span class="s2">,</span>
             <span class="s3">'broyden2'</span><span class="s1">: nonlin.broyden2</span><span class="s2">, </span><span class="s3">'krylov'</span><span class="s1">: nonlin.newton_krylov}</span>

<span class="s4">#-------------------------------------------------------------------------------</span>
<span class="s4"># Test problems</span>
<span class="s4">#-------------------------------------------------------------------------------</span>


<span class="s2">def </span><span class="s1">F(x):</span>
    <span class="s1">x = np.asarray(x).T</span>
    <span class="s1">d = diag([</span><span class="s5">3</span><span class="s2">,</span><span class="s5">2</span><span class="s2">,</span><span class="s5">1.5</span><span class="s2">,</span><span class="s5">1</span><span class="s2">,</span><span class="s5">0.5</span><span class="s1">])</span>
    <span class="s1">c = </span><span class="s5">0.01</span>
    <span class="s1">f = -d @ x - c * float(x.T @ x) * x</span>
    <span class="s2">return </span><span class="s1">f</span>


<span class="s1">F.xin = [</span><span class="s5">1</span><span class="s2">,</span><span class="s5">1</span><span class="s2">,</span><span class="s5">1</span><span class="s2">,</span><span class="s5">1</span><span class="s2">,</span><span class="s5">1</span><span class="s1">]</span>
<span class="s1">F.KNOWN_BAD = {}</span>
<span class="s1">F.JAC_KSP_BAD = {}</span>
<span class="s1">F.ROOT_JAC_KSP_BAD = {}</span>


<span class="s2">def </span><span class="s1">F2(x):</span>
    <span class="s2">return </span><span class="s1">x</span>


<span class="s1">F2.xin = [</span><span class="s5">1</span><span class="s2">,</span><span class="s5">2</span><span class="s2">,</span><span class="s5">3</span><span class="s2">,</span><span class="s5">4</span><span class="s2">,</span><span class="s5">5</span><span class="s2">,</span><span class="s5">6</span><span class="s1">]</span>
<span class="s1">F2.KNOWN_BAD = {</span><span class="s3">'linearmixing'</span><span class="s1">: nonlin.linearmixing</span><span class="s2">,</span>
                <span class="s3">'excitingmixing'</span><span class="s1">: nonlin.excitingmixing}</span>
<span class="s1">F2.JAC_KSP_BAD = {}</span>
<span class="s1">F2.ROOT_JAC_KSP_BAD = {}</span>


<span class="s2">def </span><span class="s1">F2_lucky(x):</span>
    <span class="s2">return </span><span class="s1">x</span>


<span class="s1">F2_lucky.xin = [</span><span class="s5">0</span><span class="s2">,</span><span class="s5">0</span><span class="s2">,</span><span class="s5">0</span><span class="s2">,</span><span class="s5">0</span><span class="s2">,</span><span class="s5">0</span><span class="s2">,</span><span class="s5">0</span><span class="s1">]</span>
<span class="s1">F2_lucky.KNOWN_BAD = {}</span>
<span class="s1">F2_lucky.JAC_KSP_BAD = {}</span>
<span class="s1">F2_lucky.ROOT_JAC_KSP_BAD = {}</span>


<span class="s2">def </span><span class="s1">F3(x):</span>
    <span class="s1">A = np.array([[-</span><span class="s5">2</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">0.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">2</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">2</span><span class="s1">]])</span>
    <span class="s1">b = np.array([</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3.</span><span class="s1">])</span>
    <span class="s2">return </span><span class="s1">A @ x - b</span>


<span class="s1">F3.xin = [</span><span class="s5">1</span><span class="s2">,</span><span class="s5">2</span><span class="s2">,</span><span class="s5">3</span><span class="s1">]</span>
<span class="s1">F3.KNOWN_BAD = {}</span>
<span class="s1">F3.JAC_KSP_BAD = {}</span>
<span class="s1">F3.ROOT_JAC_KSP_BAD = {}</span>


<span class="s2">def </span><span class="s1">F4_powell(x):</span>
    <span class="s1">A = </span><span class="s5">1e4</span>
    <span class="s2">return </span><span class="s1">[A*x[</span><span class="s5">0</span><span class="s1">]*x[</span><span class="s5">1</span><span class="s1">] - </span><span class="s5">1</span><span class="s2">, </span><span class="s1">np.exp(-x[</span><span class="s5">0</span><span class="s1">]) + np.exp(-x[</span><span class="s5">1</span><span class="s1">]) - (</span><span class="s5">1 </span><span class="s1">+ </span><span class="s5">1</span><span class="s1">/A)]</span>


<span class="s1">F4_powell.xin = [-</span><span class="s5">1</span><span class="s2">, </span><span class="s1">-</span><span class="s5">2</span><span class="s1">]</span>
<span class="s1">F4_powell.KNOWN_BAD = {</span><span class="s3">'linearmixing'</span><span class="s1">: nonlin.linearmixing</span><span class="s2">,</span>
                       <span class="s3">'excitingmixing'</span><span class="s1">: nonlin.excitingmixing</span><span class="s2">,</span>
                       <span class="s3">'diagbroyden'</span><span class="s1">: nonlin.diagbroyden}</span>
<span class="s4"># In the extreme case, it does not converge for nolinear problem solved by</span>
<span class="s4"># MINRES and root problem solved by GMRES/BiCGStab/CGS/MINRES/TFQMR when using</span>
<span class="s4"># Krylov method to approximate Jacobian</span>
<span class="s1">F4_powell.JAC_KSP_BAD = {</span><span class="s3">'minres'</span><span class="s1">}</span>
<span class="s1">F4_powell.ROOT_JAC_KSP_BAD = {</span><span class="s3">'gmres'</span><span class="s2">, </span><span class="s3">'bicgstab'</span><span class="s2">, </span><span class="s3">'cgs'</span><span class="s2">, </span><span class="s3">'minres'</span><span class="s2">, </span><span class="s3">'tfqmr'</span><span class="s1">}</span>


<span class="s2">def </span><span class="s1">F5(x):</span>
    <span class="s2">return </span><span class="s1">pressure_network(x</span><span class="s2">, </span><span class="s5">4</span><span class="s2">, </span><span class="s1">np.array([</span><span class="s5">.5</span><span class="s2">, </span><span class="s5">.5</span><span class="s2">, </span><span class="s5">.5</span><span class="s2">, </span><span class="s5">.5</span><span class="s1">]))</span>


<span class="s1">F5.xin = [</span><span class="s5">2.</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span>
<span class="s1">F5.KNOWN_BAD = {</span><span class="s3">'excitingmixing'</span><span class="s1">: nonlin.excitingmixing</span><span class="s2">,</span>
                <span class="s3">'linearmixing'</span><span class="s1">: nonlin.linearmixing</span><span class="s2">,</span>
                <span class="s3">'diagbroyden'</span><span class="s1">: nonlin.diagbroyden}</span>
<span class="s4"># In the extreme case, the Jacobian inversion yielded zero vector for nonlinear</span>
<span class="s4"># problem solved by CGS/MINRES and it does not converge for root problem solved</span>
<span class="s4"># by MINRES and when using Krylov method to approximate Jacobian</span>
<span class="s1">F5.JAC_KSP_BAD = {</span><span class="s3">'cgs'</span><span class="s2">, </span><span class="s3">'minres'</span><span class="s1">}</span>
<span class="s1">F5.ROOT_JAC_KSP_BAD = {</span><span class="s3">'minres'</span><span class="s1">}</span>


<span class="s2">def </span><span class="s1">F6(x):</span>
    <span class="s1">x1</span><span class="s2">, </span><span class="s1">x2 = x</span>
    <span class="s1">J0 = np.array([[-</span><span class="s5">4.256</span><span class="s2">, </span><span class="s5">14.7</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">[</span><span class="s5">0.8394989</span><span class="s2">, </span><span class="s5">0.59964207</span><span class="s1">]])</span>
    <span class="s1">v = np.array([(x1 + </span><span class="s5">3</span><span class="s1">) * (x2**</span><span class="s5">5 </span><span class="s1">- </span><span class="s5">7</span><span class="s1">) + </span><span class="s5">3</span><span class="s1">*</span><span class="s5">6</span><span class="s2">,</span>
                  <span class="s1">np.sin(x2 * np.exp(x1) - </span><span class="s5">1</span><span class="s1">)])</span>
    <span class="s2">return </span><span class="s1">-np.linalg.solve(J0</span><span class="s2">, </span><span class="s1">v)</span>


<span class="s1">F6.xin = [-</span><span class="s5">0.5</span><span class="s2">, </span><span class="s5">1.4</span><span class="s1">]</span>
<span class="s1">F6.KNOWN_BAD = {</span><span class="s3">'excitingmixing'</span><span class="s1">: nonlin.excitingmixing</span><span class="s2">,</span>
                <span class="s3">'linearmixing'</span><span class="s1">: nonlin.linearmixing</span><span class="s2">,</span>
                <span class="s3">'diagbroyden'</span><span class="s1">: nonlin.diagbroyden}</span>
<span class="s1">F6.JAC_KSP_BAD = {}</span>
<span class="s1">F6.ROOT_JAC_KSP_BAD = {}</span>


<span class="s4">#-------------------------------------------------------------------------------</span>
<span class="s4"># Tests</span>
<span class="s4">#-------------------------------------------------------------------------------</span>


<span class="s2">class </span><span class="s1">TestNonlin:</span>
    <span class="s0">&quot;&quot;&quot; 
    Check the Broyden methods for a few test problems. 
 
    broyden1, broyden2, and newton_krylov must succeed for 
    all functions. Some of the others don't -- tests in KNOWN_BAD are skipped. 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">_check_nonlin_func(self</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">f_tol=</span><span class="s5">1e-2</span><span class="s1">):</span>
        <span class="s4"># Test all methods mentioned in the class `KrylovJacobian`</span>
        <span class="s2">if </span><span class="s1">func == SOLVERS[</span><span class="s3">'krylov'</span><span class="s1">]:</span>
            <span class="s2">for </span><span class="s1">method </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'gmres'</span><span class="s2">, </span><span class="s3">'bicgstab'</span><span class="s2">, </span><span class="s3">'cgs'</span><span class="s2">, </span><span class="s3">'minres'</span><span class="s2">, </span><span class="s3">'tfqmr'</span><span class="s1">]:</span>
                <span class="s2">if </span><span class="s1">method </span><span class="s2">in </span><span class="s1">f.JAC_KSP_BAD:</span>
                    <span class="s2">continue</span>

                <span class="s1">x = func(f</span><span class="s2">, </span><span class="s1">f.xin</span><span class="s2">, </span><span class="s1">method=method</span><span class="s2">, </span><span class="s1">line_search=</span><span class="s2">None,</span>
                         <span class="s1">f_tol=f_tol</span><span class="s2">, </span><span class="s1">maxiter=</span><span class="s5">200</span><span class="s2">, </span><span class="s1">verbose=</span><span class="s5">0</span><span class="s1">)</span>
                <span class="s1">assert_(np.absolute(f(x)).max() &lt; f_tol)</span>

        <span class="s1">x = func(f</span><span class="s2">, </span><span class="s1">f.xin</span><span class="s2">, </span><span class="s1">f_tol=f_tol</span><span class="s2">, </span><span class="s1">maxiter=</span><span class="s5">200</span><span class="s2">, </span><span class="s1">verbose=</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">assert_(np.absolute(f(x)).max() &lt; f_tol)</span>

    <span class="s2">def </span><span class="s1">_check_root(self</span><span class="s2">, </span><span class="s1">f</span><span class="s2">, </span><span class="s1">method</span><span class="s2">, </span><span class="s1">f_tol=</span><span class="s5">1e-2</span><span class="s1">):</span>
        <span class="s4"># Test Krylov methods</span>
        <span class="s2">if </span><span class="s1">method == </span><span class="s3">'krylov'</span><span class="s1">:</span>
            <span class="s2">for </span><span class="s1">jac_method </span><span class="s2">in </span><span class="s1">[</span><span class="s3">'gmres'</span><span class="s2">, </span><span class="s3">'bicgstab'</span><span class="s2">, </span><span class="s3">'cgs'</span><span class="s2">, </span><span class="s3">'minres'</span><span class="s2">, </span><span class="s3">'tfqmr'</span><span class="s1">]:</span>
                <span class="s2">if </span><span class="s1">jac_method </span><span class="s2">in </span><span class="s1">f.ROOT_JAC_KSP_BAD:</span>
                    <span class="s2">continue</span>

                <span class="s1">res = root(f</span><span class="s2">, </span><span class="s1">f.xin</span><span class="s2">, </span><span class="s1">method=method</span><span class="s2">,</span>
                           <span class="s1">options={</span><span class="s3">'ftol'</span><span class="s1">: f_tol</span><span class="s2">, </span><span class="s3">'maxiter'</span><span class="s1">: </span><span class="s5">200</span><span class="s2">,</span>
                                    <span class="s3">'disp'</span><span class="s1">: </span><span class="s5">0</span><span class="s2">,</span>
                                    <span class="s3">'jac_options'</span><span class="s1">: {</span><span class="s3">'method'</span><span class="s1">: jac_method}})</span>
                <span class="s1">assert_(np.absolute(res.fun).max() &lt; f_tol)</span>

        <span class="s1">res = root(f</span><span class="s2">, </span><span class="s1">f.xin</span><span class="s2">, </span><span class="s1">method=method</span><span class="s2">,</span>
                   <span class="s1">options={</span><span class="s3">'ftol'</span><span class="s1">: f_tol</span><span class="s2">, </span><span class="s3">'maxiter'</span><span class="s1">: </span><span class="s5">200</span><span class="s2">, </span><span class="s3">'disp'</span><span class="s1">: </span><span class="s5">0</span><span class="s1">})</span>
        <span class="s1">assert_(np.absolute(res.fun).max() &lt; f_tol)</span>

    <span class="s1">@pytest.mark.xfail</span>
    <span class="s2">def </span><span class="s1">_check_func_fail(self</span><span class="s2">, </span><span class="s1">*a</span><span class="s2">, </span><span class="s1">**kw):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">test_problem_nonlin(self):</span>
        <span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">[F</span><span class="s2">, </span><span class="s1">F2</span><span class="s2">, </span><span class="s1">F2_lucky</span><span class="s2">, </span><span class="s1">F3</span><span class="s2">, </span><span class="s1">F4_powell</span><span class="s2">, </span><span class="s1">F5</span><span class="s2">, </span><span class="s1">F6]:</span>
            <span class="s2">for </span><span class="s1">func </span><span class="s2">in </span><span class="s1">SOLVERS.values():</span>
                <span class="s2">if </span><span class="s1">func </span><span class="s2">in </span><span class="s1">f.KNOWN_BAD.values():</span>
                    <span class="s2">if </span><span class="s1">func </span><span class="s2">in </span><span class="s1">MUST_WORK.values():</span>
                        <span class="s1">self._check_func_fail(f</span><span class="s2">, </span><span class="s1">func)</span>
                    <span class="s2">continue</span>
                <span class="s1">self._check_nonlin_func(f</span><span class="s2">, </span><span class="s1">func)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s3">&quot;method&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">'lgmres'</span><span class="s2">, </span><span class="s3">'gmres'</span><span class="s2">, </span><span class="s3">'bicgstab'</span><span class="s2">, </span><span class="s3">'cgs'</span><span class="s2">,</span>
                                        <span class="s3">'minres'</span><span class="s2">, </span><span class="s3">'tfqmr'</span><span class="s1">])</span>
    <span class="s2">def </span><span class="s1">test_tol_norm_called(self</span><span class="s2">, </span><span class="s1">method):</span>
        <span class="s4"># Check that supplying tol_norm keyword to nonlin_solve works</span>
        <span class="s1">self._tol_norm_used = </span><span class="s2">False</span>

        <span class="s2">def </span><span class="s1">local_norm_func(x):</span>
            <span class="s1">self._tol_norm_used = </span><span class="s2">True</span>
            <span class="s2">return </span><span class="s1">np.absolute(x).max()</span>

        <span class="s1">nonlin.newton_krylov(F</span><span class="s2">, </span><span class="s1">F.xin</span><span class="s2">, </span><span class="s1">method=method</span><span class="s2">, </span><span class="s1">f_tol=</span><span class="s5">1e-2</span><span class="s2">,</span>
                             <span class="s1">maxiter=</span><span class="s5">200</span><span class="s2">, </span><span class="s1">verbose=</span><span class="s5">0</span><span class="s2">,</span>
                             <span class="s1">tol_norm=local_norm_func)</span>
        <span class="s1">assert_(self._tol_norm_used)</span>

    <span class="s2">def </span><span class="s1">test_problem_root(self):</span>
        <span class="s2">for </span><span class="s1">f </span><span class="s2">in </span><span class="s1">[F</span><span class="s2">, </span><span class="s1">F2</span><span class="s2">, </span><span class="s1">F2_lucky</span><span class="s2">, </span><span class="s1">F3</span><span class="s2">, </span><span class="s1">F4_powell</span><span class="s2">, </span><span class="s1">F5</span><span class="s2">, </span><span class="s1">F6]:</span>
            <span class="s2">for </span><span class="s1">meth </span><span class="s2">in </span><span class="s1">SOLVERS:</span>
                <span class="s2">if </span><span class="s1">meth </span><span class="s2">in </span><span class="s1">f.KNOWN_BAD:</span>
                    <span class="s2">if </span><span class="s1">meth </span><span class="s2">in </span><span class="s1">MUST_WORK:</span>
                        <span class="s1">self._check_func_fail(f</span><span class="s2">, </span><span class="s1">meth)</span>
                    <span class="s2">continue</span>
                <span class="s1">self._check_root(f</span><span class="s2">, </span><span class="s1">meth)</span>


<span class="s2">class </span><span class="s1">TestSecant:</span>
    <span class="s0">&quot;&quot;&quot;Check that some Jacobian approximations satisfy the secant condition&quot;&quot;&quot;</span>

    <span class="s1">xs = [np.array([</span><span class="s5">1</span><span class="s2">,</span><span class="s5">2</span><span class="s2">,</span><span class="s5">3</span><span class="s2">,</span><span class="s5">4</span><span class="s2">,</span><span class="s5">5</span><span class="s1">]</span><span class="s2">, </span><span class="s1">float)</span><span class="s2">,</span>
          <span class="s1">np.array([</span><span class="s5">2</span><span class="s2">,</span><span class="s5">3</span><span class="s2">,</span><span class="s5">4</span><span class="s2">,</span><span class="s5">5</span><span class="s2">,</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">float)</span><span class="s2">,</span>
          <span class="s1">np.array([</span><span class="s5">3</span><span class="s2">,</span><span class="s5">4</span><span class="s2">,</span><span class="s5">5</span><span class="s2">,</span><span class="s5">1</span><span class="s2">,</span><span class="s5">2</span><span class="s1">]</span><span class="s2">, </span><span class="s1">float)</span><span class="s2">,</span>
          <span class="s1">np.array([</span><span class="s5">4</span><span class="s2">,</span><span class="s5">5</span><span class="s2">,</span><span class="s5">1</span><span class="s2">,</span><span class="s5">2</span><span class="s2">,</span><span class="s5">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">float)</span><span class="s2">,</span>
          <span class="s1">np.array([</span><span class="s5">9</span><span class="s2">,</span><span class="s5">1</span><span class="s2">,</span><span class="s5">9</span><span class="s2">,</span><span class="s5">1</span><span class="s2">,</span><span class="s5">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">float)</span><span class="s2">,</span>
          <span class="s1">np.array([</span><span class="s5">0</span><span class="s2">,</span><span class="s5">1</span><span class="s2">,</span><span class="s5">9</span><span class="s2">,</span><span class="s5">1</span><span class="s2">,</span><span class="s5">3</span><span class="s1">]</span><span class="s2">, </span><span class="s1">float)</span><span class="s2">,</span>
          <span class="s1">np.array([</span><span class="s5">5</span><span class="s2">,</span><span class="s5">5</span><span class="s2">,</span><span class="s5">7</span><span class="s2">,</span><span class="s5">1</span><span class="s2">,</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">float)</span><span class="s2">,</span>
          <span class="s1">np.array([</span><span class="s5">1</span><span class="s2">,</span><span class="s5">2</span><span class="s2">,</span><span class="s5">7</span><span class="s2">,</span><span class="s5">5</span><span class="s2">,</span><span class="s5">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">float)</span><span class="s2">,</span><span class="s1">]</span>
    <span class="s1">fs = [x**</span><span class="s5">2 </span><span class="s1">- </span><span class="s5">1 </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">xs]</span>

    <span class="s2">def </span><span class="s1">_check_secant(self</span><span class="s2">, </span><span class="s1">jac_cls</span><span class="s2">, </span><span class="s1">npoints=</span><span class="s5">1</span><span class="s2">, </span><span class="s1">**kw):</span>
        <span class="s0">&quot;&quot;&quot; 
        Check that the given Jacobian approximation satisfies secant 
        conditions for last `npoints` points. 
        &quot;&quot;&quot;</span>
        <span class="s1">jac = jac_cls(**kw)</span>
        <span class="s1">jac.setup(self.xs[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.fs[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">j</span><span class="s2">, </span><span class="s1">(x</span><span class="s2">, </span><span class="s1">f) </span><span class="s2">in </span><span class="s1">enumerate(zip(self.xs[</span><span class="s5">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">self.fs[</span><span class="s5">1</span><span class="s1">:])):</span>
            <span class="s1">jac.update(x</span><span class="s2">, </span><span class="s1">f)</span>

            <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range(min(npoints</span><span class="s2">, </span><span class="s1">j+</span><span class="s5">1</span><span class="s1">)):</span>
                <span class="s1">dx = self.xs[j-k+</span><span class="s5">1</span><span class="s1">] - self.xs[j-k]</span>
                <span class="s1">df = self.fs[j-k+</span><span class="s5">1</span><span class="s1">] - self.fs[j-k]</span>
                <span class="s1">assert_(np.allclose(dx</span><span class="s2">, </span><span class="s1">jac.solve(df)))</span>

            <span class="s4"># Check that the `npoints` secant bound is strict</span>
            <span class="s2">if </span><span class="s1">j &gt;= npoints:</span>
                <span class="s1">dx = self.xs[j-npoints+</span><span class="s5">1</span><span class="s1">] - self.xs[j-npoints]</span>
                <span class="s1">df = self.fs[j-npoints+</span><span class="s5">1</span><span class="s1">] - self.fs[j-npoints]</span>
                <span class="s1">assert_(</span><span class="s2">not </span><span class="s1">np.allclose(dx</span><span class="s2">, </span><span class="s1">jac.solve(df)))</span>

    <span class="s2">def </span><span class="s1">test_broyden1(self):</span>
        <span class="s1">self._check_secant(nonlin.BroydenFirst)</span>

    <span class="s2">def </span><span class="s1">test_broyden2(self):</span>
        <span class="s1">self._check_secant(nonlin.BroydenSecond)</span>

    <span class="s2">def </span><span class="s1">test_broyden1_update(self):</span>
        <span class="s4"># Check that BroydenFirst update works as for a dense matrix</span>
        <span class="s1">jac = nonlin.BroydenFirst(alpha=</span><span class="s5">0.1</span><span class="s1">)</span>
        <span class="s1">jac.setup(self.xs[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.fs[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, None</span><span class="s1">)</span>

        <span class="s1">B = np.identity(</span><span class="s5">5</span><span class="s1">) * (-</span><span class="s5">1</span><span class="s1">/</span><span class="s5">0.1</span><span class="s1">)</span>

        <span class="s2">for </span><span class="s1">last_j</span><span class="s2">, </span><span class="s1">(x</span><span class="s2">, </span><span class="s1">f) </span><span class="s2">in </span><span class="s1">enumerate(zip(self.xs[</span><span class="s5">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">self.fs[</span><span class="s5">1</span><span class="s1">:])):</span>
            <span class="s1">df = f - self.fs[last_j]</span>
            <span class="s1">dx = x - self.xs[last_j]</span>
            <span class="s1">B += (df - dot(B</span><span class="s2">, </span><span class="s1">dx))[:</span><span class="s2">,None</span><span class="s1">] * dx[</span><span class="s2">None,</span><span class="s1">:] / dot(dx</span><span class="s2">, </span><span class="s1">dx)</span>
            <span class="s1">jac.update(x</span><span class="s2">, </span><span class="s1">f)</span>
            <span class="s1">assert_(np.allclose(jac.todense()</span><span class="s2">, </span><span class="s1">B</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-10</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-13</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_broyden2_update(self):</span>
        <span class="s4"># Check that BroydenSecond update works as for a dense matrix</span>
        <span class="s1">jac = nonlin.BroydenSecond(alpha=</span><span class="s5">0.1</span><span class="s1">)</span>
        <span class="s1">jac.setup(self.xs[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">self.fs[</span><span class="s5">0</span><span class="s1">]</span><span class="s2">, None</span><span class="s1">)</span>

        <span class="s1">H = np.identity(</span><span class="s5">5</span><span class="s1">) * (-</span><span class="s5">0.1</span><span class="s1">)</span>

        <span class="s2">for </span><span class="s1">last_j</span><span class="s2">, </span><span class="s1">(x</span><span class="s2">, </span><span class="s1">f) </span><span class="s2">in </span><span class="s1">enumerate(zip(self.xs[</span><span class="s5">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">self.fs[</span><span class="s5">1</span><span class="s1">:])):</span>
            <span class="s1">df = f - self.fs[last_j]</span>
            <span class="s1">dx = x - self.xs[last_j]</span>
            <span class="s1">H += (dx - dot(H</span><span class="s2">, </span><span class="s1">df))[:</span><span class="s2">,None</span><span class="s1">] * df[</span><span class="s2">None,</span><span class="s1">:] / dot(df</span><span class="s2">, </span><span class="s1">df)</span>
            <span class="s1">jac.update(x</span><span class="s2">, </span><span class="s1">f)</span>
            <span class="s1">assert_(np.allclose(jac.todense()</span><span class="s2">, </span><span class="s1">inv(H)</span><span class="s2">, </span><span class="s1">rtol=</span><span class="s5">1e-10</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-13</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_anderson(self):</span>
        <span class="s4"># Anderson mixing (with w0=0) satisfies secant conditions</span>
        <span class="s4"># for the last M iterates, see [Ey]_</span>
        <span class="s4">#</span>
        <span class="s4"># .. [Ey] V. Eyert, J. Comp. Phys., 124, 271 (1996).</span>
        <span class="s1">self._check_secant(nonlin.Anderson</span><span class="s2">, </span><span class="s1">M=</span><span class="s5">3</span><span class="s2">, </span><span class="s1">w0=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">npoints=</span><span class="s5">3</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestLinear:</span>
    <span class="s0">&quot;&quot;&quot;Solve a linear equation; 
    some methods find the exact solution in a finite number of steps&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">_check(self</span><span class="s2">, </span><span class="s1">jac</span><span class="s2">, </span><span class="s1">N</span><span class="s2">, </span><span class="s1">maxiter</span><span class="s2">, </span><span class="s1">complex=</span><span class="s2">False, </span><span class="s1">**kw):</span>
        <span class="s1">np.random.seed(</span><span class="s5">123</span><span class="s1">)</span>

        <span class="s1">A = np.random.randn(N</span><span class="s2">, </span><span class="s1">N)</span>
        <span class="s2">if </span><span class="s1">complex:</span>
            <span class="s1">A = A + </span><span class="s5">1j</span><span class="s1">*np.random.randn(N</span><span class="s2">, </span><span class="s1">N)</span>
        <span class="s1">b = np.random.randn(N)</span>
        <span class="s2">if </span><span class="s1">complex:</span>
            <span class="s1">b = b + </span><span class="s5">1j</span><span class="s1">*np.random.randn(N)</span>

        <span class="s2">def </span><span class="s1">func(x):</span>
            <span class="s2">return </span><span class="s1">dot(A</span><span class="s2">, </span><span class="s1">x) - b</span>

        <span class="s1">sol = nonlin.nonlin_solve(func</span><span class="s2">, </span><span class="s1">np.zeros(N)</span><span class="s2">, </span><span class="s1">jac</span><span class="s2">, </span><span class="s1">maxiter=maxiter</span><span class="s2">,</span>
                                  <span class="s1">f_tol=</span><span class="s5">1e-6</span><span class="s2">, </span><span class="s1">line_search=</span><span class="s2">None, </span><span class="s1">verbose=</span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">assert_(np.allclose(dot(A</span><span class="s2">, </span><span class="s1">sol)</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">atol=</span><span class="s5">1e-6</span><span class="s1">))</span>

    <span class="s2">def </span><span class="s1">test_broyden1(self):</span>
        <span class="s4"># Broyden methods solve linear systems exactly in 2*N steps</span>
        <span class="s1">self._check(nonlin.BroydenFirst(alpha=</span><span class="s5">1.0</span><span class="s1">)</span><span class="s2">, </span><span class="s5">20</span><span class="s2">, </span><span class="s5">41</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s1">self._check(nonlin.BroydenFirst(alpha=</span><span class="s5">1.0</span><span class="s1">)</span><span class="s2">, </span><span class="s5">20</span><span class="s2">, </span><span class="s5">41</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_broyden2(self):</span>
        <span class="s4"># Broyden methods solve linear systems exactly in 2*N steps</span>
        <span class="s1">self._check(nonlin.BroydenSecond(alpha=</span><span class="s5">1.0</span><span class="s1">)</span><span class="s2">, </span><span class="s5">20</span><span class="s2">, </span><span class="s5">41</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s1">self._check(nonlin.BroydenSecond(alpha=</span><span class="s5">1.0</span><span class="s1">)</span><span class="s2">, </span><span class="s5">20</span><span class="s2">, </span><span class="s5">41</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_anderson(self):</span>
        <span class="s4"># Anderson is rather similar to Broyden, if given enough storage space</span>
        <span class="s1">self._check(nonlin.Anderson(M=</span><span class="s5">50</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s5">1.0</span><span class="s1">)</span><span class="s2">, </span><span class="s5">20</span><span class="s2">, </span><span class="s5">29</span><span class="s2">, False</span><span class="s1">)</span>
        <span class="s1">self._check(nonlin.Anderson(M=</span><span class="s5">50</span><span class="s2">, </span><span class="s1">alpha=</span><span class="s5">1.0</span><span class="s1">)</span><span class="s2">, </span><span class="s5">20</span><span class="s2">, </span><span class="s5">29</span><span class="s2">, True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_krylov(self):</span>
        <span class="s4"># Krylov methods solve linear systems exactly in N inner steps</span>
        <span class="s1">self._check(nonlin.KrylovJacobian</span><span class="s2">, </span><span class="s5">20</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, False, </span><span class="s1">inner_m=</span><span class="s5">10</span><span class="s1">)</span>
        <span class="s1">self._check(nonlin.KrylovJacobian</span><span class="s2">, </span><span class="s5">20</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, True, </span><span class="s1">inner_m=</span><span class="s5">10</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestJacobianDotSolve:</span>
    <span class="s0">&quot;&quot;&quot;Check that solve/dot methods in Jacobian approximations are consistent&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">_func(self</span><span class="s2">, </span><span class="s1">x):</span>
        <span class="s2">return </span><span class="s1">x**</span><span class="s5">2 </span><span class="s1">- </span><span class="s5">1 </span><span class="s1">+ np.dot(self.A</span><span class="s2">, </span><span class="s1">x)</span>

    <span class="s2">def </span><span class="s1">_check_dot(self</span><span class="s2">, </span><span class="s1">jac_cls</span><span class="s2">, </span><span class="s1">complex=</span><span class="s2">False, </span><span class="s1">tol=</span><span class="s5">1e-6</span><span class="s2">, </span><span class="s1">**kw):</span>
        <span class="s1">np.random.seed(</span><span class="s5">123</span><span class="s1">)</span>

        <span class="s1">N = </span><span class="s5">7</span>

        <span class="s2">def </span><span class="s1">rand(*a):</span>
            <span class="s1">q = np.random.rand(*a)</span>
            <span class="s2">if </span><span class="s1">complex:</span>
                <span class="s1">q = q + </span><span class="s5">1j</span><span class="s1">*np.random.rand(*a)</span>
            <span class="s2">return </span><span class="s1">q</span>

        <span class="s2">def </span><span class="s1">assert_close(a</span><span class="s2">, </span><span class="s1">b</span><span class="s2">, </span><span class="s1">msg):</span>
            <span class="s1">d = abs(a - b).max()</span>
            <span class="s1">f = tol + abs(b).max()*tol</span>
            <span class="s2">if </span><span class="s1">d &gt; f:</span>
                <span class="s2">raise </span><span class="s1">AssertionError(</span><span class="s3">f'</span><span class="s2">{</span><span class="s1">msg</span><span class="s2">}</span><span class="s3">: err </span><span class="s2">{</span><span class="s1">d</span><span class="s2">:</span><span class="s3">g</span><span class="s2">}</span><span class="s3">'</span><span class="s1">)</span>

        <span class="s1">self.A = rand(N</span><span class="s2">, </span><span class="s1">N)</span>

        <span class="s4"># initialize</span>
        <span class="s1">x0 = np.random.rand(N)</span>
        <span class="s1">jac = jac_cls(**kw)</span>
        <span class="s1">jac.setup(x0</span><span class="s2">, </span><span class="s1">self._func(x0)</span><span class="s2">, </span><span class="s1">self._func)</span>

        <span class="s4"># check consistency</span>
        <span class="s2">for </span><span class="s1">k </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">2</span><span class="s1">*N):</span>
            <span class="s1">v = rand(N)</span>

            <span class="s2">if </span><span class="s1">hasattr(jac</span><span class="s2">, </span><span class="s3">'__array__'</span><span class="s1">):</span>
                <span class="s1">Jd = np.array(jac)</span>
                <span class="s2">if </span><span class="s1">hasattr(jac</span><span class="s2">, </span><span class="s3">'solve'</span><span class="s1">):</span>
                    <span class="s1">Gv = jac.solve(v)</span>
                    <span class="s1">Gv2 = np.linalg.solve(Jd</span><span class="s2">, </span><span class="s1">v)</span>
                    <span class="s1">assert_close(Gv</span><span class="s2">, </span><span class="s1">Gv2</span><span class="s2">, </span><span class="s3">'solve vs array'</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s1">hasattr(jac</span><span class="s2">, </span><span class="s3">'rsolve'</span><span class="s1">):</span>
                    <span class="s1">Gv = jac.rsolve(v)</span>
                    <span class="s1">Gv2 = np.linalg.solve(Jd.T.conj()</span><span class="s2">, </span><span class="s1">v)</span>
                    <span class="s1">assert_close(Gv</span><span class="s2">, </span><span class="s1">Gv2</span><span class="s2">, </span><span class="s3">'rsolve vs array'</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s1">hasattr(jac</span><span class="s2">, </span><span class="s3">'matvec'</span><span class="s1">):</span>
                    <span class="s1">Jv = jac.matvec(v)</span>
                    <span class="s1">Jv2 = np.dot(Jd</span><span class="s2">, </span><span class="s1">v)</span>
                    <span class="s1">assert_close(Jv</span><span class="s2">, </span><span class="s1">Jv2</span><span class="s2">, </span><span class="s3">'dot vs array'</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s1">hasattr(jac</span><span class="s2">, </span><span class="s3">'rmatvec'</span><span class="s1">):</span>
                    <span class="s1">Jv = jac.rmatvec(v)</span>
                    <span class="s1">Jv2 = np.dot(Jd.T.conj()</span><span class="s2">, </span><span class="s1">v)</span>
                    <span class="s1">assert_close(Jv</span><span class="s2">, </span><span class="s1">Jv2</span><span class="s2">, </span><span class="s3">'rmatvec vs array'</span><span class="s1">)</span>

            <span class="s2">if </span><span class="s1">hasattr(jac</span><span class="s2">, </span><span class="s3">'matvec'</span><span class="s1">) </span><span class="s2">and </span><span class="s1">hasattr(jac</span><span class="s2">, </span><span class="s3">'solve'</span><span class="s1">):</span>
                <span class="s1">Jv = jac.matvec(v)</span>
                <span class="s1">Jv2 = jac.solve(jac.matvec(Jv))</span>
                <span class="s1">assert_close(Jv</span><span class="s2">, </span><span class="s1">Jv2</span><span class="s2">, </span><span class="s3">'dot vs solve'</span><span class="s1">)</span>

            <span class="s2">if </span><span class="s1">hasattr(jac</span><span class="s2">, </span><span class="s3">'rmatvec'</span><span class="s1">) </span><span class="s2">and </span><span class="s1">hasattr(jac</span><span class="s2">, </span><span class="s3">'rsolve'</span><span class="s1">):</span>
                <span class="s1">Jv = jac.rmatvec(v)</span>
                <span class="s1">Jv2 = jac.rmatvec(jac.rsolve(Jv))</span>
                <span class="s1">assert_close(Jv</span><span class="s2">, </span><span class="s1">Jv2</span><span class="s2">, </span><span class="s3">'rmatvec vs rsolve'</span><span class="s1">)</span>

            <span class="s1">x = rand(N)</span>
            <span class="s1">jac.update(x</span><span class="s2">, </span><span class="s1">self._func(x))</span>

    <span class="s2">def </span><span class="s1">test_broyden1(self):</span>
        <span class="s1">self._check_dot(nonlin.BroydenFirst</span><span class="s2">, </span><span class="s1">complex=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">self._check_dot(nonlin.BroydenFirst</span><span class="s2">, </span><span class="s1">complex=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_broyden2(self):</span>
        <span class="s1">self._check_dot(nonlin.BroydenSecond</span><span class="s2">, </span><span class="s1">complex=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">self._check_dot(nonlin.BroydenSecond</span><span class="s2">, </span><span class="s1">complex=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_anderson(self):</span>
        <span class="s1">self._check_dot(nonlin.Anderson</span><span class="s2">, </span><span class="s1">complex=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">self._check_dot(nonlin.Anderson</span><span class="s2">, </span><span class="s1">complex=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_diagbroyden(self):</span>
        <span class="s1">self._check_dot(nonlin.DiagBroyden</span><span class="s2">, </span><span class="s1">complex=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">self._check_dot(nonlin.DiagBroyden</span><span class="s2">, </span><span class="s1">complex=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_linearmixing(self):</span>
        <span class="s1">self._check_dot(nonlin.LinearMixing</span><span class="s2">, </span><span class="s1">complex=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">self._check_dot(nonlin.LinearMixing</span><span class="s2">, </span><span class="s1">complex=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_excitingmixing(self):</span>
        <span class="s1">self._check_dot(nonlin.ExcitingMixing</span><span class="s2">, </span><span class="s1">complex=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">self._check_dot(nonlin.ExcitingMixing</span><span class="s2">, </span><span class="s1">complex=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_krylov(self):</span>
        <span class="s1">self._check_dot(nonlin.KrylovJacobian</span><span class="s2">, </span><span class="s1">complex=</span><span class="s2">False, </span><span class="s1">tol=</span><span class="s5">1e-3</span><span class="s1">)</span>
        <span class="s1">self._check_dot(nonlin.KrylovJacobian</span><span class="s2">, </span><span class="s1">complex=</span><span class="s2">True, </span><span class="s1">tol=</span><span class="s5">1e-3</span><span class="s1">)</span>


<span class="s2">class </span><span class="s1">TestNonlinOldTests:</span>
    <span class="s0">&quot;&quot;&quot; Test case for a simple constrained entropy maximization problem 
    (the machine translation example of Berger et al in 
    Computational Linguistics, vol 22, num 1, pp 39--72, 1996.) 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">test_broyden1(self):</span>
        <span class="s1">x = nonlin.broyden1(F</span><span class="s2">,</span><span class="s1">F.xin</span><span class="s2">,</span><span class="s1">iter=</span><span class="s5">12</span><span class="s2">,</span><span class="s1">alpha=</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">assert_(nonlin.norm(x) &lt; </span><span class="s5">1e-9</span><span class="s1">)</span>
        <span class="s1">assert_(nonlin.norm(F(x)) &lt; </span><span class="s5">1e-9</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_broyden2(self):</span>
        <span class="s1">x = nonlin.broyden2(F</span><span class="s2">,</span><span class="s1">F.xin</span><span class="s2">,</span><span class="s1">iter=</span><span class="s5">12</span><span class="s2">,</span><span class="s1">alpha=</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">assert_(nonlin.norm(x) &lt; </span><span class="s5">1e-9</span><span class="s1">)</span>
        <span class="s1">assert_(nonlin.norm(F(x)) &lt; </span><span class="s5">1e-9</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_anderson(self):</span>
        <span class="s1">x = nonlin.anderson(F</span><span class="s2">,</span><span class="s1">F.xin</span><span class="s2">,</span><span class="s1">iter=</span><span class="s5">12</span><span class="s2">,</span><span class="s1">alpha=</span><span class="s5">0.03</span><span class="s2">,</span><span class="s1">M=</span><span class="s5">5</span><span class="s1">)</span>
        <span class="s1">assert_(nonlin.norm(x) &lt; </span><span class="s5">0.33</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_linearmixing(self):</span>
        <span class="s1">x = nonlin.linearmixing(F</span><span class="s2">,</span><span class="s1">F.xin</span><span class="s2">,</span><span class="s1">iter=</span><span class="s5">60</span><span class="s2">,</span><span class="s1">alpha=</span><span class="s5">0.5</span><span class="s1">)</span>
        <span class="s1">assert_(nonlin.norm(x) &lt; </span><span class="s5">1e-7</span><span class="s1">)</span>
        <span class="s1">assert_(nonlin.norm(F(x)) &lt; </span><span class="s5">1e-7</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_exciting(self):</span>
        <span class="s1">x = nonlin.excitingmixing(F</span><span class="s2">,</span><span class="s1">F.xin</span><span class="s2">,</span><span class="s1">iter=</span><span class="s5">20</span><span class="s2">,</span><span class="s1">alpha=</span><span class="s5">0.5</span><span class="s1">)</span>
        <span class="s1">assert_(nonlin.norm(x) &lt; </span><span class="s5">1e-5</span><span class="s1">)</span>
        <span class="s1">assert_(nonlin.norm(F(x)) &lt; </span><span class="s5">1e-5</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_diagbroyden(self):</span>
        <span class="s1">x = nonlin.diagbroyden(F</span><span class="s2">,</span><span class="s1">F.xin</span><span class="s2">,</span><span class="s1">iter=</span><span class="s5">11</span><span class="s2">,</span><span class="s1">alpha=</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">assert_(nonlin.norm(x) &lt; </span><span class="s5">1e-8</span><span class="s1">)</span>
        <span class="s1">assert_(nonlin.norm(F(x)) &lt; </span><span class="s5">1e-8</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_root_broyden1(self):</span>
        <span class="s1">res = root(F</span><span class="s2">, </span><span class="s1">F.xin</span><span class="s2">, </span><span class="s1">method=</span><span class="s3">'broyden1'</span><span class="s2">,</span>
                   <span class="s1">options={</span><span class="s3">'nit'</span><span class="s1">: </span><span class="s5">12</span><span class="s2">, </span><span class="s3">'jac_options'</span><span class="s1">: {</span><span class="s3">'alpha'</span><span class="s1">: </span><span class="s5">1</span><span class="s1">}})</span>
        <span class="s1">assert_(nonlin.norm(res.x) &lt; </span><span class="s5">1e-9</span><span class="s1">)</span>
        <span class="s1">assert_(nonlin.norm(res.fun) &lt; </span><span class="s5">1e-9</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_root_broyden2(self):</span>
        <span class="s1">res = root(F</span><span class="s2">, </span><span class="s1">F.xin</span><span class="s2">, </span><span class="s1">method=</span><span class="s3">'broyden2'</span><span class="s2">,</span>
                   <span class="s1">options={</span><span class="s3">'nit'</span><span class="s1">: </span><span class="s5">12</span><span class="s2">, </span><span class="s3">'jac_options'</span><span class="s1">: {</span><span class="s3">'alpha'</span><span class="s1">: </span><span class="s5">1</span><span class="s1">}})</span>
        <span class="s1">assert_(nonlin.norm(res.x) &lt; </span><span class="s5">1e-9</span><span class="s1">)</span>
        <span class="s1">assert_(nonlin.norm(res.fun) &lt; </span><span class="s5">1e-9</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_root_anderson(self):</span>
        <span class="s1">res = root(F</span><span class="s2">, </span><span class="s1">F.xin</span><span class="s2">, </span><span class="s1">method=</span><span class="s3">'anderson'</span><span class="s2">,</span>
                   <span class="s1">options={</span><span class="s3">'nit'</span><span class="s1">: </span><span class="s5">12</span><span class="s2">,</span>
                            <span class="s3">'jac_options'</span><span class="s1">: {</span><span class="s3">'alpha'</span><span class="s1">: </span><span class="s5">0.03</span><span class="s2">, </span><span class="s3">'M'</span><span class="s1">: </span><span class="s5">5</span><span class="s1">}})</span>
        <span class="s1">assert_(nonlin.norm(res.x) &lt; </span><span class="s5">0.33</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_root_linearmixing(self):</span>
        <span class="s1">res = root(F</span><span class="s2">, </span><span class="s1">F.xin</span><span class="s2">, </span><span class="s1">method=</span><span class="s3">'linearmixing'</span><span class="s2">,</span>
                   <span class="s1">options={</span><span class="s3">'nit'</span><span class="s1">: </span><span class="s5">60</span><span class="s2">,</span>
                            <span class="s3">'jac_options'</span><span class="s1">: {</span><span class="s3">'alpha'</span><span class="s1">: </span><span class="s5">0.5</span><span class="s1">}})</span>
        <span class="s1">assert_(nonlin.norm(res.x) &lt; </span><span class="s5">1e-7</span><span class="s1">)</span>
        <span class="s1">assert_(nonlin.norm(res.fun) &lt; </span><span class="s5">1e-7</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_root_excitingmixing(self):</span>
        <span class="s1">res = root(F</span><span class="s2">, </span><span class="s1">F.xin</span><span class="s2">, </span><span class="s1">method=</span><span class="s3">'excitingmixing'</span><span class="s2">,</span>
                   <span class="s1">options={</span><span class="s3">'nit'</span><span class="s1">: </span><span class="s5">20</span><span class="s2">,</span>
                            <span class="s3">'jac_options'</span><span class="s1">: {</span><span class="s3">'alpha'</span><span class="s1">: </span><span class="s5">0.5</span><span class="s1">}})</span>
        <span class="s1">assert_(nonlin.norm(res.x) &lt; </span><span class="s5">1e-5</span><span class="s1">)</span>
        <span class="s1">assert_(nonlin.norm(res.fun) &lt; </span><span class="s5">1e-5</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">test_root_diagbroyden(self):</span>
        <span class="s1">res = root(F</span><span class="s2">, </span><span class="s1">F.xin</span><span class="s2">, </span><span class="s1">method=</span><span class="s3">'diagbroyden'</span><span class="s2">,</span>
                   <span class="s1">options={</span><span class="s3">'nit'</span><span class="s1">: </span><span class="s5">11</span><span class="s2">,</span>
                            <span class="s3">'jac_options'</span><span class="s1">: {</span><span class="s3">'alpha'</span><span class="s1">: </span><span class="s5">1</span><span class="s1">}})</span>
        <span class="s1">assert_(nonlin.norm(res.x) &lt; </span><span class="s5">1e-8</span><span class="s1">)</span>
        <span class="s1">assert_(nonlin.norm(res.fun) &lt; </span><span class="s5">1e-8</span><span class="s1">)</span>
</pre>
</body>
</html>