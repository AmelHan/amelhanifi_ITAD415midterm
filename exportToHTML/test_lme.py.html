<html>
<head>
<title>test_lme.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #629755; font-style: italic;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_lme.py</font>
</center></td></tr></table>
<pre><span class="s0">from </span><span class="s1">statsmodels.compat.platform </span><span class="s0">import </span><span class="s1">PLATFORM_OSX</span>

<span class="s0">import </span><span class="s1">os</span>
<span class="s0">import </span><span class="s1">csv</span>
<span class="s0">import </span><span class="s1">warnings</span>

<span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">pandas </span><span class="s0">as </span><span class="s1">pd</span>
<span class="s0">from </span><span class="s1">scipy </span><span class="s0">import </span><span class="s1">sparse</span>
<span class="s0">import </span><span class="s1">pytest</span>

<span class="s0">from </span><span class="s1">statsmodels.regression.mixed_linear_model </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">MixedLM</span><span class="s0">, </span><span class="s1">MixedLMParams</span><span class="s0">, </span><span class="s1">_smw_solver</span><span class="s0">, </span><span class="s1">_smw_logdet)</span>
<span class="s0">from </span><span class="s1">numpy.testing </span><span class="s0">import </span><span class="s1">(assert_almost_equal</span><span class="s0">, </span><span class="s1">assert_equal</span><span class="s0">, </span><span class="s1">assert_allclose</span><span class="s0">,</span>
                           <span class="s1">assert_)</span>

<span class="s0">from </span><span class="s1">statsmodels.base </span><span class="s0">import </span><span class="s1">_penalties </span><span class="s0">as </span><span class="s1">penalties</span>
<span class="s0">import </span><span class="s1">statsmodels.tools.numdiff </span><span class="s0">as </span><span class="s1">nd</span>

<span class="s0">from </span><span class="s1">.results </span><span class="s0">import </span><span class="s1">lme_r_results</span>

<span class="s2"># TODO: add tests with unequal group sizes</span>


<span class="s0">class </span><span class="s1">R_Results:</span>
    <span class="s3">&quot;&quot;&quot; 
    A class for holding various results obtained from fitting one data 
    set using lmer in R. 
 
    Parameters 
    ---------- 
    meth : str 
        Either &quot;ml&quot; or &quot;reml&quot;. 
    irfs : str 
        Either &quot;irf&quot;, for independent random effects, or &quot;drf&quot; for 
        dependent random effects. 
    ds_ix : int 
        The number of the data set 
    &quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">meth</span><span class="s0">, </span><span class="s1">irfs</span><span class="s0">, </span><span class="s1">ds_ix):</span>

        <span class="s1">bname = </span><span class="s4">&quot;_%s_%s_%d&quot; </span><span class="s1">% (meth</span><span class="s0">, </span><span class="s1">irfs</span><span class="s0">, </span><span class="s1">ds_ix)</span>

        <span class="s1">self.coef = getattr(lme_r_results</span><span class="s0">, </span><span class="s4">&quot;coef&quot; </span><span class="s1">+ bname)</span>
        <span class="s1">self.vcov_r = getattr(lme_r_results</span><span class="s0">, </span><span class="s4">&quot;vcov&quot; </span><span class="s1">+ bname)</span>
        <span class="s1">self.cov_re_r = getattr(lme_r_results</span><span class="s0">, </span><span class="s4">&quot;cov_re&quot; </span><span class="s1">+ bname)</span>
        <span class="s1">self.scale_r = getattr(lme_r_results</span><span class="s0">, </span><span class="s4">&quot;scale&quot; </span><span class="s1">+ bname)</span>
        <span class="s1">self.loglike = getattr(lme_r_results</span><span class="s0">, </span><span class="s4">&quot;loglike&quot; </span><span class="s1">+ bname)</span>

        <span class="s0">if </span><span class="s1">hasattr(lme_r_results</span><span class="s0">, </span><span class="s4">&quot;ranef_mean&quot; </span><span class="s1">+ bname):</span>
            <span class="s1">self.ranef_postmean = getattr(lme_r_results</span><span class="s0">, </span><span class="s4">&quot;ranef_mean&quot; </span><span class="s1">+ bname)</span>
            <span class="s1">self.ranef_condvar = getattr(lme_r_results</span><span class="s0">,</span>
                                         <span class="s4">&quot;ranef_condvar&quot; </span><span class="s1">+ bname)</span>
            <span class="s1">self.ranef_condvar = np.atleast_2d(self.ranef_condvar)</span>

        <span class="s2"># Load the data file</span>
        <span class="s1">cur_dir = os.path.dirname(os.path.abspath(__file__))</span>
        <span class="s1">rdir = os.path.join(cur_dir</span><span class="s0">, </span><span class="s4">'results'</span><span class="s1">)</span>
        <span class="s1">fname = os.path.join(rdir</span><span class="s0">, </span><span class="s4">&quot;lme%02d.csv&quot; </span><span class="s1">% ds_ix)</span>
        <span class="s0">with </span><span class="s1">open(fname</span><span class="s0">, </span><span class="s1">encoding=</span><span class="s4">&quot;utf-8&quot;</span><span class="s1">) </span><span class="s0">as </span><span class="s1">fid:</span>
            <span class="s1">rdr = csv.reader(fid)</span>
            <span class="s1">header = next(rdr)</span>
            <span class="s1">data = [[float(x) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">line] </span><span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">rdr]</span>
        <span class="s1">data = np.asarray(data)</span>

        <span class="s2"># Split into exog, endog, etc.</span>
        <span class="s1">self.endog = data[:</span><span class="s0">, </span><span class="s1">header.index(</span><span class="s4">&quot;endog&quot;</span><span class="s1">)]</span>
        <span class="s1">self.groups = data[:</span><span class="s0">, </span><span class="s1">header.index(</span><span class="s4">&quot;groups&quot;</span><span class="s1">)]</span>
        <span class="s1">ii = [i </span><span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">x </span><span class="s0">in </span><span class="s1">enumerate(header) </span><span class="s0">if </span><span class="s1">x.startswith(</span><span class="s4">&quot;exog_fe&quot;</span><span class="s1">)]</span>
        <span class="s1">self.exog_fe = data[:</span><span class="s0">, </span><span class="s1">ii]</span>
        <span class="s1">ii = [i </span><span class="s0">for </span><span class="s1">i</span><span class="s0">, </span><span class="s1">x </span><span class="s0">in </span><span class="s1">enumerate(header) </span><span class="s0">if </span><span class="s1">x.startswith(</span><span class="s4">&quot;exog_re&quot;</span><span class="s1">)]</span>
        <span class="s1">self.exog_re = data[:</span><span class="s0">, </span><span class="s1">ii]</span>


<span class="s0">def </span><span class="s1">loglike_function(model</span><span class="s0">, </span><span class="s1">profile_fe</span><span class="s0">, </span><span class="s1">has_fe):</span>
    <span class="s2"># Returns a function that evaluates the negative log-likelihood for</span>
    <span class="s2"># the given model.</span>

    <span class="s0">def </span><span class="s1">f(x):</span>
        <span class="s1">params = MixedLMParams.from_packed(</span>
            <span class="s1">x</span><span class="s0">, </span><span class="s1">model.k_fe</span><span class="s0">, </span><span class="s1">model.k_re</span><span class="s0">, </span><span class="s1">model.use_sqrt</span><span class="s0">, </span><span class="s1">has_fe=has_fe)</span>
        <span class="s0">return </span><span class="s1">-model.loglike(params</span><span class="s0">, </span><span class="s1">profile_fe=profile_fe)</span>

    <span class="s0">return </span><span class="s1">f</span>


<span class="s0">class </span><span class="s1">TestMixedLM:</span>

    <span class="s2"># Test analytic scores and Hessian using numeric differentiation</span>
    <span class="s1">@pytest.mark.slow</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;use_sqrt&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">False, True</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;reml&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">False, True</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;profile_fe&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">False, True</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_compare_numdiff(self</span><span class="s0">, </span><span class="s1">use_sqrt</span><span class="s0">, </span><span class="s1">reml</span><span class="s0">, </span><span class="s1">profile_fe):</span>

        <span class="s1">n_grp = </span><span class="s5">200</span>
        <span class="s1">grpsize = </span><span class="s5">5</span>
        <span class="s1">k_fe = </span><span class="s5">3</span>
        <span class="s1">k_re = </span><span class="s5">2</span>

        <span class="s1">np.random.seed(</span><span class="s5">3558</span><span class="s1">)</span>
        <span class="s1">exog_fe = np.random.normal(size=(n_grp * grpsize</span><span class="s0">, </span><span class="s1">k_fe))</span>
        <span class="s1">exog_re = np.random.normal(size=(n_grp * grpsize</span><span class="s0">, </span><span class="s1">k_re))</span>
        <span class="s1">exog_re[:</span><span class="s0">, </span><span class="s5">0</span><span class="s1">] = </span><span class="s5">1</span>
        <span class="s1">exog_vc = np.random.normal(size=(n_grp * grpsize</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span>
        <span class="s1">slopes = np.random.normal(size=(n_grp</span><span class="s0">, </span><span class="s1">k_re))</span>
        <span class="s1">slopes[:</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">] *= </span><span class="s5">2</span>
        <span class="s1">slopes = np.kron(slopes</span><span class="s0">, </span><span class="s1">np.ones((grpsize</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)))</span>
        <span class="s1">slopes_vc = np.random.normal(size=(n_grp</span><span class="s0">, </span><span class="s5">3</span><span class="s1">))</span>
        <span class="s1">slopes_vc = np.kron(slopes_vc</span><span class="s0">, </span><span class="s1">np.ones((grpsize</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)))</span>
        <span class="s1">slopes_vc[:</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">] *= </span><span class="s5">2</span>
        <span class="s1">re_values = (slopes * exog_re).sum(</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">vc_values = (slopes_vc * exog_vc).sum(</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">err = np.random.normal(size=n_grp * grpsize)</span>
        <span class="s1">endog = exog_fe.sum(</span><span class="s5">1</span><span class="s1">) + re_values + vc_values + err</span>
        <span class="s1">groups = np.kron(range(n_grp)</span><span class="s0">, </span><span class="s1">np.ones(grpsize))</span>

        <span class="s1">vc = {</span><span class="s4">&quot;a&quot;</span><span class="s1">: {}</span><span class="s0">, </span><span class="s4">&quot;b&quot;</span><span class="s1">: {}}</span>
        <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(n_grp):</span>
            <span class="s1">ix = np.flatnonzero(groups == i)</span>
            <span class="s1">vc[</span><span class="s4">&quot;a&quot;</span><span class="s1">][i] = exog_vc[ix</span><span class="s0">, </span><span class="s5">0</span><span class="s1">:</span><span class="s5">2</span><span class="s1">]</span>
            <span class="s1">vc[</span><span class="s4">&quot;b&quot;</span><span class="s1">][i] = exog_vc[ix</span><span class="s0">, </span><span class="s5">2</span><span class="s1">:</span><span class="s5">3</span><span class="s1">]</span>

        <span class="s0">with </span><span class="s1">pytest.warns(UserWarning</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;Using deprecated variance&quot;</span><span class="s1">):</span>
            <span class="s1">model = MixedLM(</span>
                <span class="s1">endog</span><span class="s0">,</span>
                <span class="s1">exog_fe</span><span class="s0">,</span>
                <span class="s1">groups</span><span class="s0">,</span>
                <span class="s1">exog_re</span><span class="s0">,</span>
                <span class="s1">exog_vc=vc</span><span class="s0">,</span>
                <span class="s1">use_sqrt=use_sqrt)</span>
        <span class="s1">rslt = model.fit(reml=reml)</span>

        <span class="s1">loglike = loglike_function(</span>
            <span class="s1">model</span><span class="s0">, </span><span class="s1">profile_fe=profile_fe</span><span class="s0">, </span><span class="s1">has_fe=</span><span class="s0">not </span><span class="s1">profile_fe)</span>

        <span class="s0">try</span><span class="s1">:</span>
            <span class="s2"># Test the score at several points.</span>
            <span class="s0">for </span><span class="s1">kr </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">5</span><span class="s1">):</span>
                <span class="s1">fe_params = np.random.normal(size=k_fe)</span>
                <span class="s1">cov_re = np.random.normal(size=(k_re</span><span class="s0">, </span><span class="s1">k_re))</span>
                <span class="s1">cov_re = np.dot(cov_re.T</span><span class="s0">, </span><span class="s1">cov_re)</span>
                <span class="s1">vcomp = np.random.normal(size=</span><span class="s5">2</span><span class="s1">)**</span><span class="s5">2</span>
                <span class="s1">params = MixedLMParams.from_components(</span>
                    <span class="s1">fe_params</span><span class="s0">, </span><span class="s1">cov_re=cov_re</span><span class="s0">, </span><span class="s1">vcomp=vcomp)</span>
                <span class="s1">params_vec = params.get_packed(</span>
                    <span class="s1">has_fe=</span><span class="s0">not </span><span class="s1">profile_fe</span><span class="s0">, </span><span class="s1">use_sqrt=use_sqrt)</span>

                <span class="s2"># Check scores</span>
                <span class="s1">gr = -model.score(params</span><span class="s0">, </span><span class="s1">profile_fe=profile_fe)</span>
                <span class="s1">ngr = nd.approx_fprime(params_vec</span><span class="s0">, </span><span class="s1">loglike)</span>
                <span class="s1">assert_allclose(gr</span><span class="s0">, </span><span class="s1">ngr</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s5">1e-3</span><span class="s1">)</span>

            <span class="s2"># Check Hessian matrices at the MLE (we do not have</span>
            <span class="s2"># the profile Hessian matrix and we do not care</span>
            <span class="s2"># about the Hessian for the square root</span>
            <span class="s2"># transformed parameter).</span>
            <span class="s0">if </span><span class="s1">(profile_fe </span><span class="s0">is False</span><span class="s1">) </span><span class="s0">and </span><span class="s1">(use_sqrt </span><span class="s0">is False</span><span class="s1">):</span>
                <span class="s1">hess</span><span class="s0">, </span><span class="s1">sing = model.hessian(rslt.params_object)</span>
                <span class="s0">if </span><span class="s1">sing:</span>
                    <span class="s1">pytest.fail(</span><span class="s4">&quot;hessian should not be singular&quot;</span><span class="s1">)</span>
                <span class="s1">hess *= -</span><span class="s5">1</span>
                <span class="s1">params_vec = rslt.params_object.get_packed(</span>
                    <span class="s1">use_sqrt=</span><span class="s0">False, </span><span class="s1">has_fe=</span><span class="s0">True</span><span class="s1">)</span>
                <span class="s1">loglike_h = loglike_function(</span>
                    <span class="s1">model</span><span class="s0">, </span><span class="s1">profile_fe=</span><span class="s0">False, </span><span class="s1">has_fe=</span><span class="s0">True</span><span class="s1">)</span>
                <span class="s1">nhess = nd.approx_hess(params_vec</span><span class="s0">, </span><span class="s1">loglike_h)</span>
                <span class="s1">assert_allclose(hess</span><span class="s0">, </span><span class="s1">nhess</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s5">1e-3</span><span class="s1">)</span>
        <span class="s0">except </span><span class="s1">AssertionError:</span>
            <span class="s2"># See GH#5628; because this test fails unpredictably but only on</span>
            <span class="s2">#  OSX, we only xfail it there.</span>
            <span class="s0">if </span><span class="s1">PLATFORM_OSX:</span>
                <span class="s1">pytest.xfail(</span><span class="s4">&quot;fails on OSX due to unresolved &quot;</span>
                             <span class="s4">&quot;numerical differences&quot;</span><span class="s1">)</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s0">raise</span>

    <span class="s0">def </span><span class="s1">test_default_re(self):</span>

        <span class="s1">np.random.seed(</span><span class="s5">3235</span><span class="s1">)</span>
        <span class="s1">exog = np.random.normal(size=(</span><span class="s5">300</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">groups = np.kron(np.arange(</span><span class="s5">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">g_errors = np.kron(np.random.normal(size=</span><span class="s5">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">endog = exog.sum(</span><span class="s5">1</span><span class="s1">) + g_errors + np.random.normal(size=</span><span class="s5">300</span><span class="s1">)</span>
        <span class="s1">mdf1 = MixedLM(endog</span><span class="s0">, </span><span class="s1">exog</span><span class="s0">, </span><span class="s1">groups).fit()</span>
        <span class="s1">mdf2 = MixedLM(endog</span><span class="s0">, </span><span class="s1">exog</span><span class="s0">, </span><span class="s1">groups</span><span class="s0">, </span><span class="s1">np.ones(</span><span class="s5">300</span><span class="s1">)).fit()</span>
        <span class="s1">assert_almost_equal(mdf1.params</span><span class="s0">, </span><span class="s1">mdf2.params</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s5">8</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_history(self):</span>

        <span class="s1">np.random.seed(</span><span class="s5">3235</span><span class="s1">)</span>
        <span class="s1">exog = np.random.normal(size=(</span><span class="s5">300</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">groups = np.kron(np.arange(</span><span class="s5">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">g_errors = np.kron(np.random.normal(size=</span><span class="s5">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">endog = exog.sum(</span><span class="s5">1</span><span class="s1">) + g_errors + np.random.normal(size=</span><span class="s5">300</span><span class="s1">)</span>
        <span class="s1">mod = MixedLM(endog</span><span class="s0">, </span><span class="s1">exog</span><span class="s0">, </span><span class="s1">groups)</span>
        <span class="s1">rslt = mod.fit(full_output=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s1">assert_equal(hasattr(rslt</span><span class="s0">, </span><span class="s4">&quot;hist&quot;</span><span class="s1">)</span><span class="s0">, True</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s1">@pytest.mark.smoke</span>
    <span class="s0">def </span><span class="s1">test_profile_inference(self):</span>
        <span class="s1">np.random.seed(</span><span class="s5">9814</span><span class="s1">)</span>
        <span class="s1">k_fe = </span><span class="s5">2</span>
        <span class="s1">gsize = </span><span class="s5">3</span>
        <span class="s1">n_grp = </span><span class="s5">100</span>
        <span class="s1">exog = np.random.normal(size=(n_grp * gsize</span><span class="s0">, </span><span class="s1">k_fe))</span>
        <span class="s1">exog_re = np.ones((n_grp * gsize</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">groups = np.kron(np.arange(n_grp)</span><span class="s0">, </span><span class="s1">np.ones(gsize))</span>
        <span class="s1">vca = np.random.normal(size=n_grp * gsize)</span>
        <span class="s1">vcb = np.random.normal(size=n_grp * gsize)</span>
        <span class="s1">errors = </span><span class="s5">0</span>
        <span class="s1">g_errors = np.kron(np.random.normal(size=</span><span class="s5">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.ones(gsize))</span>
        <span class="s1">errors += g_errors + exog_re[:</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">rc = np.random.normal(size=n_grp)</span>
        <span class="s1">errors += np.kron(rc</span><span class="s0">, </span><span class="s1">np.ones(gsize)) * vca</span>
        <span class="s1">rc = np.random.normal(size=n_grp)</span>
        <span class="s1">errors += np.kron(rc</span><span class="s0">, </span><span class="s1">np.ones(gsize)) * vcb</span>
        <span class="s1">errors += np.random.normal(size=n_grp * gsize)</span>

        <span class="s1">endog = exog.sum(</span><span class="s5">1</span><span class="s1">) + errors</span>
        <span class="s1">vc = {</span><span class="s4">&quot;a&quot;</span><span class="s1">: {}</span><span class="s0">, </span><span class="s4">&quot;b&quot;</span><span class="s1">: {}}</span>
        <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range(n_grp):</span>
            <span class="s1">ii = np.flatnonzero(groups == k)</span>
            <span class="s1">vc[</span><span class="s4">&quot;a&quot;</span><span class="s1">][k] = vca[ii][:</span><span class="s0">, None</span><span class="s1">]</span>
            <span class="s1">vc[</span><span class="s4">&quot;b&quot;</span><span class="s1">][k] = vcb[ii][:</span><span class="s0">, None</span><span class="s1">]</span>
        <span class="s0">with </span><span class="s1">pytest.warns(UserWarning</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;Using deprecated variance&quot;</span><span class="s1">):</span>
            <span class="s1">rslt = MixedLM(endog</span><span class="s0">, </span><span class="s1">exog</span><span class="s0">, </span><span class="s1">groups=groups</span><span class="s0">,</span>
                           <span class="s1">exog_re=exog_re</span><span class="s0">, </span><span class="s1">exog_vc=vc).fit()</span>
        <span class="s1">rslt.profile_re(</span><span class="s5">0</span><span class="s0">, </span><span class="s1">vtype=</span><span class="s4">'re'</span><span class="s0">, </span><span class="s1">dist_low=</span><span class="s5">1</span><span class="s0">, </span><span class="s1">num_low=</span><span class="s5">3</span><span class="s0">,</span>
                        <span class="s1">dist_high=</span><span class="s5">1</span><span class="s0">, </span><span class="s1">num_high=</span><span class="s5">3</span><span class="s1">)</span>
        <span class="s1">rslt.profile_re(</span><span class="s4">'b'</span><span class="s0">, </span><span class="s1">vtype=</span><span class="s4">'vc'</span><span class="s0">, </span><span class="s1">dist_low=</span><span class="s5">0.5</span><span class="s0">, </span><span class="s1">num_low=</span><span class="s5">3</span><span class="s0">,</span>
                        <span class="s1">dist_high=</span><span class="s5">0.5</span><span class="s0">, </span><span class="s1">num_high=</span><span class="s5">3</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_vcomp_1(self):</span>
        <span class="s2"># Fit the same model using constrained random effects and</span>
        <span class="s2"># variance components.</span>

        <span class="s1">np.random.seed(</span><span class="s5">4279</span><span class="s1">)</span>
        <span class="s1">exog = np.random.normal(size=(</span><span class="s5">400</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))</span>
        <span class="s1">exog_re = np.random.normal(size=(</span><span class="s5">400</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span>
        <span class="s1">groups = np.kron(np.arange(</span><span class="s5">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.ones(</span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">slopes = np.random.normal(size=(</span><span class="s5">100</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span>
        <span class="s1">slopes[:</span><span class="s0">, </span><span class="s5">1</span><span class="s1">] *= </span><span class="s5">2</span>
        <span class="s1">slopes = np.kron(slopes</span><span class="s0">, </span><span class="s1">np.ones((</span><span class="s5">4</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))) * exog_re</span>
        <span class="s1">errors = slopes.sum(</span><span class="s5">1</span><span class="s1">) + np.random.normal(size=</span><span class="s5">400</span><span class="s1">)</span>
        <span class="s1">endog = exog.sum(</span><span class="s5">1</span><span class="s1">) + errors</span>

        <span class="s1">free = MixedLMParams(</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">free.fe_params = np.ones(</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">free.cov_re = np.eye(</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">free.vcomp = np.zeros(</span><span class="s5">0</span><span class="s1">)</span>

        <span class="s1">model1 = MixedLM(endog</span><span class="s0">, </span><span class="s1">exog</span><span class="s0">, </span><span class="s1">groups</span><span class="s0">, </span><span class="s1">exog_re=exog_re)</span>
        <span class="s1">result1 = model1.fit(free=free)</span>

        <span class="s1">exog_vc = {</span><span class="s4">&quot;a&quot;</span><span class="s1">: {}</span><span class="s0">, </span><span class="s4">&quot;b&quot;</span><span class="s1">: {}}</span>
        <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">group </span><span class="s0">in </span><span class="s1">enumerate(model1.group_labels):</span>
            <span class="s1">ix = model1.row_indices[group]</span>
            <span class="s1">exog_vc[</span><span class="s4">&quot;a&quot;</span><span class="s1">][group] = exog_re[ix</span><span class="s0">, </span><span class="s5">0</span><span class="s1">:</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s1">exog_vc[</span><span class="s4">&quot;b&quot;</span><span class="s1">][group] = exog_re[ix</span><span class="s0">, </span><span class="s5">1</span><span class="s1">:</span><span class="s5">2</span><span class="s1">]</span>
        <span class="s0">with </span><span class="s1">pytest.warns(UserWarning</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;Using deprecated variance&quot;</span><span class="s1">):</span>
            <span class="s1">model2 = MixedLM(endog</span><span class="s0">, </span><span class="s1">exog</span><span class="s0">, </span><span class="s1">groups</span><span class="s0">, </span><span class="s1">exog_vc=exog_vc)</span>
        <span class="s1">result2 = model2.fit()</span>
        <span class="s1">result2.summary()</span>

        <span class="s1">assert_allclose(result1.fe_params</span><span class="s0">, </span><span class="s1">result2.fe_params</span><span class="s0">, </span><span class="s1">atol=</span><span class="s5">1e-4</span><span class="s1">)</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">np.diag(result1.cov_re)</span><span class="s0">, </span><span class="s1">result2.vcomp</span><span class="s0">, </span><span class="s1">atol=</span><span class="s5">1e-2</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s5">1e-4</span><span class="s1">)</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">result1.bse[[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">3</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">result2.bse</span><span class="s0">, </span><span class="s1">atol=</span><span class="s5">1e-2</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s5">1e-2</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_vcomp_2(self):</span>
        <span class="s2"># Simulated data comparison to R</span>

        <span class="s1">np.random.seed(</span><span class="s5">6241</span><span class="s1">)</span>
        <span class="s1">n = </span><span class="s5">1600</span>
        <span class="s1">exog = np.random.normal(size=(n</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span>
        <span class="s1">groups = np.kron(np.arange(n / </span><span class="s5">16</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.ones(</span><span class="s5">16</span><span class="s1">))</span>

        <span class="s2"># Build up the random error vector</span>
        <span class="s1">errors = </span><span class="s5">0</span>

        <span class="s2"># The random effects</span>
        <span class="s1">exog_re = np.random.normal(size=(n</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span>
        <span class="s1">slopes = np.random.normal(size=(n // </span><span class="s5">16</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span>
        <span class="s1">slopes = np.kron(slopes</span><span class="s0">, </span><span class="s1">np.ones((</span><span class="s5">16</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))) * exog_re</span>
        <span class="s1">errors += slopes.sum(</span><span class="s5">1</span><span class="s1">)</span>

        <span class="s2"># First variance component</span>
        <span class="s1">subgroups1 = np.kron(np.arange(n / </span><span class="s5">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.ones(</span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">errors += np.kron(</span><span class="s5">2 </span><span class="s1">* np.random.normal(size=n // </span><span class="s5">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.ones(</span><span class="s5">4</span><span class="s1">))</span>

        <span class="s2"># Second variance component</span>
        <span class="s1">subgroups2 = np.kron(np.arange(n / </span><span class="s5">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.ones(</span><span class="s5">2</span><span class="s1">))</span>
        <span class="s1">errors += np.kron(</span><span class="s5">2 </span><span class="s1">* np.random.normal(size=n // </span><span class="s5">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.ones(</span><span class="s5">2</span><span class="s1">))</span>

        <span class="s2"># iid errors</span>
        <span class="s1">errors += np.random.normal(size=n)</span>

        <span class="s1">endog = exog.sum(</span><span class="s5">1</span><span class="s1">) + errors</span>

        <span class="s1">df = pd.DataFrame(index=range(n))</span>
        <span class="s1">df[</span><span class="s4">&quot;y&quot;</span><span class="s1">] = endog</span>
        <span class="s1">df[</span><span class="s4">&quot;groups&quot;</span><span class="s1">] = groups</span>
        <span class="s1">df[</span><span class="s4">&quot;x1&quot;</span><span class="s1">] = exog[:</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">df[</span><span class="s4">&quot;x2&quot;</span><span class="s1">] = exog[:</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">df[</span><span class="s4">&quot;z1&quot;</span><span class="s1">] = exog_re[:</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">df[</span><span class="s4">&quot;z2&quot;</span><span class="s1">] = exog_re[:</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">df[</span><span class="s4">&quot;v1&quot;</span><span class="s1">] = subgroups1</span>
        <span class="s1">df[</span><span class="s4">&quot;v2&quot;</span><span class="s1">] = subgroups2</span>

        <span class="s2"># Equivalent model in R:</span>
        <span class="s2"># df.to_csv(&quot;tst.csv&quot;)</span>
        <span class="s2"># model = lmer(y ~ x1 + x2 + (0 + z1 + z2 | groups) + (1 | v1) + (1 |</span>
        <span class="s2"># v2), df)</span>

        <span class="s1">vcf = {</span><span class="s4">&quot;a&quot;</span><span class="s1">: </span><span class="s4">&quot;0 + C(v1)&quot;</span><span class="s0">, </span><span class="s4">&quot;b&quot;</span><span class="s1">: </span><span class="s4">&quot;0 + C(v2)&quot;</span><span class="s1">}</span>
        <span class="s1">model1 = MixedLM.from_formula(</span>
            <span class="s4">&quot;y ~ x1 + x2&quot;</span><span class="s0">,</span>
            <span class="s1">groups=groups</span><span class="s0">,</span>
            <span class="s1">re_formula=</span><span class="s4">&quot;0+z1+z2&quot;</span><span class="s0">,</span>
            <span class="s1">vc_formula=vcf</span><span class="s0">,</span>
            <span class="s1">data=df)</span>
        <span class="s1">result1 = model1.fit()</span>

        <span class="s2"># Compare to R</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">result1.fe_params</span><span class="s0">, </span><span class="s1">[</span><span class="s5">0.16527</span><span class="s0">, </span><span class="s5">0.99911</span><span class="s0">, </span><span class="s5">0.96217</span><span class="s1">]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s5">1e-4</span><span class="s1">)</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">result1.cov_re</span><span class="s0">, </span><span class="s1">[[</span><span class="s5">1.244</span><span class="s0">, </span><span class="s5">0.146</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">0.146</span><span class="s0">, </span><span class="s5">1.371</span><span class="s1">]]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s5">1e-3</span><span class="s1">)</span>
        <span class="s1">assert_allclose(result1.vcomp</span><span class="s0">, </span><span class="s1">[</span><span class="s5">4.024</span><span class="s0">, </span><span class="s5">3.997</span><span class="s1">]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s5">1e-3</span><span class="s1">)</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">result1.bse.iloc[</span><span class="s5">0</span><span class="s1">:</span><span class="s5">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">0.12610</span><span class="s0">, </span><span class="s5">0.03938</span><span class="s0">, </span><span class="s5">0.03848</span><span class="s1">]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s5">1e-3</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_vcomp_3(self):</span>
        <span class="s2"># Test a model with vcomp but no other random effects, using formulas.</span>

        <span class="s1">np.random.seed(</span><span class="s5">4279</span><span class="s1">)</span>
        <span class="s1">x1 = np.random.normal(size=</span><span class="s5">400</span><span class="s1">)</span>
        <span class="s1">groups = np.kron(np.arange(</span><span class="s5">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.ones(</span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">slopes = np.random.normal(size=</span><span class="s5">100</span><span class="s1">)</span>
        <span class="s1">slopes = np.kron(slopes</span><span class="s0">, </span><span class="s1">np.ones(</span><span class="s5">4</span><span class="s1">)) * x1</span>
        <span class="s1">y = slopes + np.random.normal(size=</span><span class="s5">400</span><span class="s1">)</span>
        <span class="s1">vc_fml = {</span><span class="s4">&quot;a&quot;</span><span class="s1">: </span><span class="s4">&quot;0 + x1&quot;</span><span class="s1">}</span>
        <span class="s1">df = pd.DataFrame({</span><span class="s4">&quot;y&quot;</span><span class="s1">: y</span><span class="s0">, </span><span class="s4">&quot;x1&quot;</span><span class="s1">: x1</span><span class="s0">, </span><span class="s4">&quot;groups&quot;</span><span class="s1">: groups})</span>

        <span class="s1">model = MixedLM.from_formula(</span>
            <span class="s4">&quot;y ~ 1&quot;</span><span class="s0">, </span><span class="s1">groups=</span><span class="s4">&quot;groups&quot;</span><span class="s0">, </span><span class="s1">vc_formula=vc_fml</span><span class="s0">, </span><span class="s1">data=df)</span>
        <span class="s1">result = model.fit()</span>
        <span class="s1">result.summary()</span>

        <span class="s1">assert_allclose(</span>
            <span class="s1">result.resid.iloc[</span><span class="s5">0</span><span class="s1">:</span><span class="s5">4</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">np.r_[-</span><span class="s5">1.180753</span><span class="s0">, </span><span class="s5">0.279966</span><span class="s0">, </span><span class="s5">0.578576</span><span class="s0">, </span><span class="s1">-</span><span class="s5">0.667916</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">rtol=</span><span class="s5">1e-3</span><span class="s1">)</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">result.fittedvalues.iloc[</span><span class="s5">0</span><span class="s1">:</span><span class="s5">4</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">np.r_[-</span><span class="s5">0.101549</span><span class="s0">, </span><span class="s5">0.028613</span><span class="s0">, </span><span class="s1">-</span><span class="s5">0.224621</span><span class="s0">, </span><span class="s1">-</span><span class="s5">0.126295</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">rtol=</span><span class="s5">1e-3</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_sparse(self):</span>

        <span class="s1">cur_dir = os.path.dirname(os.path.abspath(__file__))</span>
        <span class="s1">rdir = os.path.join(cur_dir</span><span class="s0">, </span><span class="s4">'results'</span><span class="s1">)</span>
        <span class="s1">fname = os.path.join(rdir</span><span class="s0">, </span><span class="s4">'pastes.csv'</span><span class="s1">)</span>

        <span class="s2"># Dense</span>
        <span class="s1">data = pd.read_csv(fname)</span>
        <span class="s1">vcf = {</span><span class="s4">&quot;cask&quot;</span><span class="s1">: </span><span class="s4">&quot;0 + cask&quot;</span><span class="s1">}</span>
        <span class="s1">model = MixedLM.from_formula(</span>
            <span class="s4">&quot;strength ~ 1&quot;</span><span class="s0">,</span>
            <span class="s1">groups=</span><span class="s4">&quot;batch&quot;</span><span class="s0">,</span>
            <span class="s1">re_formula=</span><span class="s4">&quot;1&quot;</span><span class="s0">,</span>
            <span class="s1">vc_formula=vcf</span><span class="s0">,</span>
            <span class="s1">data=data)</span>
        <span class="s1">result = model.fit()</span>

        <span class="s2"># Sparse</span>
        <span class="s1">model2 = MixedLM.from_formula(</span>
            <span class="s4">&quot;strength ~ 1&quot;</span><span class="s0">,</span>
            <span class="s1">groups=</span><span class="s4">&quot;batch&quot;</span><span class="s0">,</span>
            <span class="s1">re_formula=</span><span class="s4">&quot;1&quot;</span><span class="s0">,</span>
            <span class="s1">vc_formula=vcf</span><span class="s0">,</span>
            <span class="s1">use_sparse=</span><span class="s0">True,</span>
            <span class="s1">data=data)</span>
        <span class="s1">result2 = model2.fit()</span>

        <span class="s1">assert_allclose(result.params</span><span class="s0">, </span><span class="s1">result2.params)</span>
        <span class="s1">assert_allclose(result.bse</span><span class="s0">, </span><span class="s1">result2.bse)</span>

    <span class="s0">def </span><span class="s1">test_dietox(self):</span>
        <span class="s2"># dietox data from geepack using random intercepts</span>
        <span class="s2">#</span>
        <span class="s2"># Fit in R using</span>
        <span class="s2">#</span>
        <span class="s2"># library(geepack)</span>
        <span class="s2"># rm = lmer(Weight ~ Time + (1 | Pig), data=dietox)</span>
        <span class="s2"># rm = lmer(Weight ~ Time + (1 | Pig), REML=FALSE, data=dietox)</span>
        <span class="s2">#</span>
        <span class="s2"># Comments below are R code used to extract the numbers used</span>
        <span class="s2"># for comparison.</span>

        <span class="s1">cur_dir = os.path.dirname(os.path.abspath(__file__))</span>
        <span class="s1">rdir = os.path.join(cur_dir</span><span class="s0">, </span><span class="s4">'results'</span><span class="s1">)</span>
        <span class="s1">fname = os.path.join(rdir</span><span class="s0">, </span><span class="s4">'dietox.csv'</span><span class="s1">)</span>

        <span class="s2"># REML</span>
        <span class="s1">data = pd.read_csv(fname)</span>
        <span class="s1">model = MixedLM.from_formula(</span><span class="s4">&quot;Weight ~ Time&quot;</span><span class="s0">, </span><span class="s1">groups=</span><span class="s4">&quot;Pig&quot;</span><span class="s0">, </span><span class="s1">data=data)</span>
        <span class="s1">result = model.fit()</span>

        <span class="s2"># fixef(rm)</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">result.fe_params</span><span class="s0">, </span><span class="s1">np.r_[</span><span class="s5">15.723523</span><span class="s0">, </span><span class="s5">6.942505</span><span class="s1">]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s5">1e-5</span><span class="s1">)</span>

        <span class="s2"># sqrt(diag(vcov(rm)))</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">result.bse[</span><span class="s5">0</span><span class="s1">:</span><span class="s5">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.r_[</span><span class="s5">0.78805374</span><span class="s0">, </span><span class="s5">0.03338727</span><span class="s1">]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s5">1e-5</span><span class="s1">)</span>

        <span class="s2"># attr(VarCorr(rm), &quot;sc&quot;)^2</span>
        <span class="s1">assert_allclose(result.scale</span><span class="s0">, </span><span class="s5">11.36692</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s5">1e-5</span><span class="s1">)</span>

        <span class="s2"># VarCorr(rm)[[1]][[1]]</span>
        <span class="s1">assert_allclose(result.cov_re</span><span class="s0">, </span><span class="s5">40.39395</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s5">1e-5</span><span class="s1">)</span>

        <span class="s2"># logLik(rm)</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">model.loglike(result.params_object)</span><span class="s0">, </span><span class="s1">-</span><span class="s5">2404.775</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s5">1e-5</span><span class="s1">)</span>

        <span class="s2"># ML</span>
        <span class="s1">data = pd.read_csv(fname)</span>
        <span class="s1">model = MixedLM.from_formula(</span><span class="s4">&quot;Weight ~ Time&quot;</span><span class="s0">, </span><span class="s1">groups=</span><span class="s4">&quot;Pig&quot;</span><span class="s0">, </span><span class="s1">data=data)</span>
        <span class="s1">result = model.fit(reml=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s2"># fixef(rm)</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">result.fe_params</span><span class="s0">, </span><span class="s1">np.r_[</span><span class="s5">15.723517</span><span class="s0">, </span><span class="s5">6.942506</span><span class="s1">]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s5">1e-5</span><span class="s1">)</span>

        <span class="s2"># sqrt(diag(vcov(rm)))</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">result.bse[</span><span class="s5">0</span><span class="s1">:</span><span class="s5">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.r_[</span><span class="s5">0.7829397</span><span class="s0">, </span><span class="s5">0.0333661</span><span class="s1">]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s5">1e-5</span><span class="s1">)</span>

        <span class="s2"># attr(VarCorr(rm), &quot;sc&quot;)^2</span>
        <span class="s1">assert_allclose(result.scale</span><span class="s0">, </span><span class="s5">11.35251</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s5">1e-5</span><span class="s1">)</span>

        <span class="s2"># VarCorr(rm)[[1]][[1]]</span>
        <span class="s1">assert_allclose(result.cov_re</span><span class="s0">, </span><span class="s5">39.82097</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s5">1e-5</span><span class="s1">)</span>

        <span class="s2"># logLik(rm)</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">model.loglike(result.params_object)</span><span class="s0">, </span><span class="s1">-</span><span class="s5">2402.932</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s5">1e-5</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_dietox_slopes(self):</span>
        <span class="s2"># dietox data from geepack using random intercepts</span>
        <span class="s2">#</span>
        <span class="s2"># Fit in R using</span>
        <span class="s2">#</span>
        <span class="s2"># library(geepack)</span>
        <span class="s2"># r = lmer(Weight ~ Time + (1 + Time | Pig), data=dietox)</span>
        <span class="s2"># r = lmer(Weight ~ Time + (1 + Time | Pig), REML=FALSE, data=dietox)</span>
        <span class="s2">#</span>
        <span class="s2"># Comments below are the R code used to extract the constants</span>
        <span class="s2"># for comparison.</span>

        <span class="s1">cur_dir = os.path.dirname(os.path.abspath(__file__))</span>
        <span class="s1">rdir = os.path.join(cur_dir</span><span class="s0">, </span><span class="s4">'results'</span><span class="s1">)</span>
        <span class="s1">fname = os.path.join(rdir</span><span class="s0">, </span><span class="s4">'dietox.csv'</span><span class="s1">)</span>

        <span class="s2"># REML</span>
        <span class="s1">data = pd.read_csv(fname)</span>
        <span class="s1">model = MixedLM.from_formula(</span>
            <span class="s4">&quot;Weight ~ Time&quot;</span><span class="s0">, </span><span class="s1">groups=</span><span class="s4">&quot;Pig&quot;</span><span class="s0">, </span><span class="s1">re_formula=</span><span class="s4">&quot;1 + Time&quot;</span><span class="s0">, </span><span class="s1">data=data)</span>
        <span class="s1">result = model.fit(method=</span><span class="s4">&quot;cg&quot;</span><span class="s1">)</span>

        <span class="s2"># fixef(r)</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">result.fe_params</span><span class="s0">, </span><span class="s1">np.r_[</span><span class="s5">15.738650</span><span class="s0">, </span><span class="s5">6.939014</span><span class="s1">]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s5">1e-5</span><span class="s1">)</span>

        <span class="s2"># sqrt(diag(vcov(r)))</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">result.bse[</span><span class="s5">0</span><span class="s1">:</span><span class="s5">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.r_[</span><span class="s5">0.5501253</span><span class="s0">, </span><span class="s5">0.0798254</span><span class="s1">]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s5">1e-3</span><span class="s1">)</span>

        <span class="s2"># attr(VarCorr(r), &quot;sc&quot;)^2</span>
        <span class="s1">assert_allclose(result.scale</span><span class="s0">, </span><span class="s5">6.03745</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s5">1e-3</span><span class="s1">)</span>

        <span class="s2"># as.numeric(VarCorr(r)[[1]])</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">result.cov_re.values.ravel()</span><span class="s0">,</span>
            <span class="s1">np.r_[</span><span class="s5">19.4934552</span><span class="s0">, </span><span class="s5">0.2938323</span><span class="s0">, </span><span class="s5">0.2938323</span><span class="s0">, </span><span class="s5">0.4160620</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">rtol=</span><span class="s5">1e-1</span><span class="s1">)</span>

        <span class="s2"># logLik(r)</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">model.loglike(result.params_object)</span><span class="s0">, </span><span class="s1">-</span><span class="s5">2217.047</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s5">1e-5</span><span class="s1">)</span>

        <span class="s2"># ML</span>
        <span class="s1">data = pd.read_csv(fname)</span>
        <span class="s1">model = MixedLM.from_formula(</span>
            <span class="s4">&quot;Weight ~ Time&quot;</span><span class="s0">, </span><span class="s1">groups=</span><span class="s4">&quot;Pig&quot;</span><span class="s0">, </span><span class="s1">re_formula=</span><span class="s4">&quot;1 + Time&quot;</span><span class="s0">, </span><span class="s1">data=data)</span>
        <span class="s1">result = model.fit(method=</span><span class="s4">'cg'</span><span class="s0">, </span><span class="s1">reml=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s2"># fixef(r)</span>
        <span class="s1">assert_allclose(result.fe_params</span><span class="s0">, </span><span class="s1">np.r_[</span><span class="s5">15.73863</span><span class="s0">, </span><span class="s5">6.93902</span><span class="s1">]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s5">1e-5</span><span class="s1">)</span>

        <span class="s2"># sqrt(diag(vcov(r)))</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">result.bse[</span><span class="s5">0</span><span class="s1">:</span><span class="s5">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.r_[</span><span class="s5">0.54629282</span><span class="s0">, </span><span class="s5">0.07926954</span><span class="s1">]</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s5">1e-3</span><span class="s1">)</span>

        <span class="s2"># attr(VarCorr(r), &quot;sc&quot;)^2</span>
        <span class="s1">assert_allclose(result.scale</span><span class="s0">, </span><span class="s5">6.037441</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s5">1e-3</span><span class="s1">)</span>

        <span class="s2">#  as.numeric(VarCorr(r)[[1]])</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">result.cov_re.values.ravel()</span><span class="s0">,</span>
            <span class="s1">np.r_[</span><span class="s5">19.190922</span><span class="s0">, </span><span class="s5">0.293568</span><span class="s0">, </span><span class="s5">0.293568</span><span class="s0">, </span><span class="s5">0.409695</span><span class="s1">]</span><span class="s0">,</span>
            <span class="s1">rtol=</span><span class="s5">1e-2</span><span class="s1">)</span>

        <span class="s2"># logLik(r)</span>
        <span class="s1">assert_allclose(</span>
            <span class="s1">model.loglike(result.params_object)</span><span class="s0">, </span><span class="s1">-</span><span class="s5">2215.753</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s5">1e-5</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_pastes_vcomp(self):</span>
        <span class="s2"># pastes data from lme4</span>
        <span class="s2">#</span>
        <span class="s2"># Fit in R using:</span>
        <span class="s2">#</span>
        <span class="s2"># r = lmer(strength ~ (1|batch) + (1|batch:cask), data=data)</span>
        <span class="s2"># r = lmer(strength ~ (1|batch) + (1|batch:cask), data=data,</span>
        <span class="s2">#          reml=FALSE)</span>

        <span class="s1">cur_dir = os.path.dirname(os.path.abspath(__file__))</span>
        <span class="s1">rdir = os.path.join(cur_dir</span><span class="s0">, </span><span class="s4">'results'</span><span class="s1">)</span>
        <span class="s1">fname = os.path.join(rdir</span><span class="s0">, </span><span class="s4">'pastes.csv'</span><span class="s1">)</span>
        <span class="s1">data = pd.read_csv(fname)</span>
        <span class="s1">vcf = {</span><span class="s4">&quot;cask&quot;</span><span class="s1">: </span><span class="s4">&quot;0 + cask&quot;</span><span class="s1">}</span>

        <span class="s2"># REML</span>
        <span class="s1">model = MixedLM.from_formula(</span>
            <span class="s4">&quot;strength ~ 1&quot;</span><span class="s0">,</span>
            <span class="s1">groups=</span><span class="s4">&quot;batch&quot;</span><span class="s0">,</span>
            <span class="s1">re_formula=</span><span class="s4">&quot;1&quot;</span><span class="s0">,</span>
            <span class="s1">vc_formula=vcf</span><span class="s0">,</span>
            <span class="s1">data=data)</span>
        <span class="s1">result = model.fit()</span>

        <span class="s2"># fixef(r)</span>
        <span class="s1">assert_allclose(result.fe_params.iloc[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s5">60.0533</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s5">1e-3</span><span class="s1">)</span>

        <span class="s2"># sqrt(diag(vcov(r)))</span>
        <span class="s1">assert_allclose(result.bse.iloc[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s5">0.6769</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s5">1e-3</span><span class="s1">)</span>

        <span class="s2"># VarCorr(r)$batch[[1]]</span>
        <span class="s1">assert_allclose(result.cov_re.iloc[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s5">1.657</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s5">1e-3</span><span class="s1">)</span>

        <span class="s2"># attr(VarCorr(r), &quot;sc&quot;)^2</span>
        <span class="s1">assert_allclose(result.scale</span><span class="s0">, </span><span class="s5">0.678</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s5">1e-3</span><span class="s1">)</span>

        <span class="s2"># logLik(r)</span>
        <span class="s1">assert_allclose(result.llf</span><span class="s0">, </span><span class="s1">-</span><span class="s5">123.49</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s5">1e-1</span><span class="s1">)</span>

        <span class="s2"># do not provide aic/bic with REML</span>
        <span class="s1">assert_equal(result.aic</span><span class="s0">, </span><span class="s1">np.nan)</span>
        <span class="s1">assert_equal(result.bic</span><span class="s0">, </span><span class="s1">np.nan)</span>

        <span class="s2"># resid(r)[1:5]</span>
        <span class="s1">resid = np.r_[</span><span class="s5">0.17133538</span><span class="s0">, </span><span class="s1">-</span><span class="s5">0.02866462</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1.08662875</span><span class="s0">, </span><span class="s5">1.11337125</span><span class="s0">,</span>
                      <span class="s1">-</span><span class="s5">0.12093607</span><span class="s1">]</span>
        <span class="s1">assert_allclose(result.resid[</span><span class="s5">0</span><span class="s1">:</span><span class="s5">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">resid</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s5">1e-3</span><span class="s1">)</span>

        <span class="s2"># predict(r)[1:5]</span>
        <span class="s1">fit = np.r_[</span><span class="s5">62.62866</span><span class="s0">, </span><span class="s5">62.62866</span><span class="s0">, </span><span class="s5">61.18663</span><span class="s0">, </span><span class="s5">61.18663</span><span class="s0">, </span><span class="s5">62.82094</span><span class="s1">]</span>
        <span class="s1">assert_allclose(result.fittedvalues[</span><span class="s5">0</span><span class="s1">:</span><span class="s5">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">fit</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s5">1e-4</span><span class="s1">)</span>

        <span class="s2"># ML</span>
        <span class="s1">model = MixedLM.from_formula(</span>
            <span class="s4">&quot;strength ~ 1&quot;</span><span class="s0">,</span>
            <span class="s1">groups=</span><span class="s4">&quot;batch&quot;</span><span class="s0">,</span>
            <span class="s1">re_formula=</span><span class="s4">&quot;1&quot;</span><span class="s0">,</span>
            <span class="s1">vc_formula=vcf</span><span class="s0">,</span>
            <span class="s1">data=data)</span>
        <span class="s1">result = model.fit(reml=</span><span class="s0">False</span><span class="s1">)</span>

        <span class="s2"># fixef(r)</span>
        <span class="s1">assert_allclose(result.fe_params.iloc[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s5">60.0533</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s5">1e-3</span><span class="s1">)</span>

        <span class="s2"># sqrt(diag(vcov(r)))</span>
        <span class="s1">assert_allclose(result.bse.iloc[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s5">0.642</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s5">1e-3</span><span class="s1">)</span>

        <span class="s2"># VarCorr(r)$batch[[1]]</span>
        <span class="s1">assert_allclose(result.cov_re.iloc[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s5">1.199</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s5">1e-3</span><span class="s1">)</span>

        <span class="s2"># attr(VarCorr(r), &quot;sc&quot;)^2</span>
        <span class="s1">assert_allclose(result.scale</span><span class="s0">, </span><span class="s5">0.67799</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s5">1e-3</span><span class="s1">)</span>

        <span class="s2"># logLik(r)</span>
        <span class="s1">assert_allclose(result.llf</span><span class="s0">, </span><span class="s1">-</span><span class="s5">123.997</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s5">1e-1</span><span class="s1">)</span>

        <span class="s2"># AIC(r)</span>
        <span class="s1">assert_allclose(result.aic</span><span class="s0">, </span><span class="s5">255.9944</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s5">1e-3</span><span class="s1">)</span>

        <span class="s2"># BIC(r)</span>
        <span class="s1">assert_allclose(result.bic</span><span class="s0">, </span><span class="s5">264.3718</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s5">1e-3</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s0">def </span><span class="s1">test_vcomp_formula(self):</span>

        <span class="s1">np.random.seed(</span><span class="s5">6241</span><span class="s1">)</span>
        <span class="s1">n = </span><span class="s5">800</span>
        <span class="s1">exog = np.random.normal(size=(n</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span>
        <span class="s1">exog[:</span><span class="s0">, </span><span class="s5">0</span><span class="s1">] = </span><span class="s5">1</span>
        <span class="s1">ex_vc = []</span>
        <span class="s1">groups = np.kron(np.arange(n / </span><span class="s5">4</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.ones(</span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">errors = </span><span class="s5">0</span>
        <span class="s1">exog_re = np.random.normal(size=(n</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span>
        <span class="s1">slopes = np.random.normal(size=(n // </span><span class="s5">4</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span>
        <span class="s1">slopes = np.kron(slopes</span><span class="s0">, </span><span class="s1">np.ones((</span><span class="s5">4</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))) * exog_re</span>
        <span class="s1">errors += slopes.sum(</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">ex_vc = np.random.normal(size=(n</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">slopes = np.random.normal(size=(n // </span><span class="s5">4</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">slopes[:</span><span class="s0">, </span><span class="s5">2</span><span class="s1">:] *= </span><span class="s5">2</span>
        <span class="s1">slopes = np.kron(slopes</span><span class="s0">, </span><span class="s1">np.ones((</span><span class="s5">4</span><span class="s0">, </span><span class="s5">1</span><span class="s1">))) * ex_vc</span>
        <span class="s1">errors += slopes.sum(</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">errors += np.random.normal(size=n)</span>
        <span class="s1">endog = exog.sum(</span><span class="s5">1</span><span class="s1">) + errors</span>

        <span class="s1">exog_vc = {</span><span class="s4">&quot;a&quot;</span><span class="s1">: {}</span><span class="s0">, </span><span class="s4">&quot;b&quot;</span><span class="s1">: {}}</span>
        <span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">group </span><span class="s0">in </span><span class="s1">enumerate(range(int(n / </span><span class="s5">4</span><span class="s1">))):</span>
            <span class="s1">ix = np.flatnonzero(groups == group)</span>
            <span class="s1">exog_vc[</span><span class="s4">&quot;a&quot;</span><span class="s1">][group] = ex_vc[ix</span><span class="s0">, </span><span class="s5">0</span><span class="s1">:</span><span class="s5">2</span><span class="s1">]</span>
            <span class="s1">exog_vc[</span><span class="s4">&quot;b&quot;</span><span class="s1">][group] = ex_vc[ix</span><span class="s0">, </span><span class="s5">2</span><span class="s1">:]</span>
        <span class="s0">with </span><span class="s1">pytest.warns(UserWarning</span><span class="s0">, </span><span class="s1">match=</span><span class="s4">&quot;Using deprecated variance&quot;</span><span class="s1">):</span>
            <span class="s1">model1 = MixedLM(endog</span><span class="s0">, </span><span class="s1">exog</span><span class="s0">, </span><span class="s1">groups</span><span class="s0">, </span><span class="s1">exog_re=exog_re</span><span class="s0">,</span>
                             <span class="s1">exog_vc=exog_vc)</span>
        <span class="s1">result1 = model1.fit()</span>

        <span class="s1">df = pd.DataFrame(exog[:</span><span class="s0">, </span><span class="s5">1</span><span class="s1">:]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s4">&quot;x1&quot;</span><span class="s1">])</span>
        <span class="s1">df[</span><span class="s4">&quot;y&quot;</span><span class="s1">] = endog</span>
        <span class="s1">df[</span><span class="s4">&quot;re1&quot;</span><span class="s1">] = exog_re[:</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">df[</span><span class="s4">&quot;re2&quot;</span><span class="s1">] = exog_re[:</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">df[</span><span class="s4">&quot;vc1&quot;</span><span class="s1">] = ex_vc[:</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">df[</span><span class="s4">&quot;vc2&quot;</span><span class="s1">] = ex_vc[:</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">df[</span><span class="s4">&quot;vc3&quot;</span><span class="s1">] = ex_vc[:</span><span class="s0">, </span><span class="s5">2</span><span class="s1">]</span>
        <span class="s1">df[</span><span class="s4">&quot;vc4&quot;</span><span class="s1">] = ex_vc[:</span><span class="s0">, </span><span class="s5">3</span><span class="s1">]</span>
        <span class="s1">vc_formula = {</span><span class="s4">&quot;a&quot;</span><span class="s1">: </span><span class="s4">&quot;0 + vc1 + vc2&quot;</span><span class="s0">, </span><span class="s4">&quot;b&quot;</span><span class="s1">: </span><span class="s4">&quot;0 + vc3 + vc4&quot;</span><span class="s1">}</span>
        <span class="s1">model2 = MixedLM.from_formula(</span>
            <span class="s4">&quot;y ~ x1&quot;</span><span class="s0">,</span>
            <span class="s1">groups=groups</span><span class="s0">,</span>
            <span class="s1">re_formula=</span><span class="s4">&quot;0 + re1 + re2&quot;</span><span class="s0">,</span>
            <span class="s1">vc_formula=vc_formula</span><span class="s0">,</span>
            <span class="s1">data=df)</span>
        <span class="s1">result2 = model2.fit()</span>

        <span class="s1">assert_allclose(result1.fe_params</span><span class="s0">, </span><span class="s1">result2.fe_params</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s5">1e-8</span><span class="s1">)</span>
        <span class="s1">assert_allclose(result1.cov_re</span><span class="s0">, </span><span class="s1">result2.cov_re</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s5">1e-8</span><span class="s1">)</span>
        <span class="s1">assert_allclose(result1.vcomp</span><span class="s0">, </span><span class="s1">result2.vcomp</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s5">1e-8</span><span class="s1">)</span>
        <span class="s1">assert_allclose(result1.params</span><span class="s0">, </span><span class="s1">result2.params</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s5">1e-8</span><span class="s1">)</span>
        <span class="s1">assert_allclose(result1.bse</span><span class="s0">, </span><span class="s1">result2.bse</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s5">1e-8</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">test_formulas(self):</span>
        <span class="s1">np.random.seed(</span><span class="s5">2410</span><span class="s1">)</span>
        <span class="s1">exog = np.random.normal(size=(</span><span class="s5">300</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">exog_re = np.random.normal(size=</span><span class="s5">300</span><span class="s1">)</span>
        <span class="s1">groups = np.kron(np.arange(</span><span class="s5">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">g_errors = exog_re * np.kron(np.random.normal(size=</span><span class="s5">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">endog = exog.sum(</span><span class="s5">1</span><span class="s1">) + g_errors + np.random.normal(size=</span><span class="s5">300</span><span class="s1">)</span>

        <span class="s1">mod1 = MixedLM(endog</span><span class="s0">, </span><span class="s1">exog</span><span class="s0">, </span><span class="s1">groups</span><span class="s0">, </span><span class="s1">exog_re)</span>
        <span class="s2"># test the names</span>
        <span class="s1">assert_(mod1.data.xnames == [</span><span class="s4">&quot;x1&quot;</span><span class="s0">, </span><span class="s4">&quot;x2&quot;</span><span class="s0">, </span><span class="s4">&quot;x3&quot;</span><span class="s0">, </span><span class="s4">&quot;x4&quot;</span><span class="s1">])</span>
        <span class="s1">assert_(mod1.data.exog_re_names == [</span><span class="s4">&quot;x_re1&quot;</span><span class="s1">])</span>
        <span class="s1">assert_(mod1.data.exog_re_names_full == [</span><span class="s4">&quot;x_re1 Var&quot;</span><span class="s1">])</span>
        <span class="s1">rslt1 = mod1.fit()</span>

        <span class="s2"># Fit with a formula, passing groups as the actual values.</span>
        <span class="s1">df = pd.DataFrame({</span><span class="s4">&quot;endog&quot;</span><span class="s1">: endog})</span>
        <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range(exog.shape[</span><span class="s5">1</span><span class="s1">]):</span>
            <span class="s1">df[</span><span class="s4">&quot;exog%d&quot; </span><span class="s1">% k] = exog[:</span><span class="s0">, </span><span class="s1">k]</span>
        <span class="s1">df[</span><span class="s4">&quot;exog_re&quot;</span><span class="s1">] = exog_re</span>
        <span class="s1">fml = </span><span class="s4">&quot;endog ~ 0 + exog0 + exog1 + exog2 + exog3&quot;</span>
        <span class="s1">re_fml = </span><span class="s4">&quot;0 + exog_re&quot;</span>
        <span class="s1">mod2 = MixedLM.from_formula(fml</span><span class="s0">, </span><span class="s1">df</span><span class="s0">, </span><span class="s1">re_formula=re_fml</span><span class="s0">, </span><span class="s1">groups=groups)</span>

        <span class="s1">assert_(mod2.data.xnames == [</span><span class="s4">&quot;exog0&quot;</span><span class="s0">, </span><span class="s4">&quot;exog1&quot;</span><span class="s0">, </span><span class="s4">&quot;exog2&quot;</span><span class="s0">, </span><span class="s4">&quot;exog3&quot;</span><span class="s1">])</span>
        <span class="s1">assert_(mod2.data.exog_re_names == [</span><span class="s4">&quot;exog_re&quot;</span><span class="s1">])</span>
        <span class="s1">assert_(mod2.data.exog_re_names_full == [</span><span class="s4">&quot;exog_re Var&quot;</span><span class="s1">])</span>

        <span class="s1">rslt2 = mod2.fit()</span>
        <span class="s1">assert_almost_equal(rslt1.params</span><span class="s0">, </span><span class="s1">rslt2.params)</span>

        <span class="s2"># Fit with a formula, passing groups as the variable name.</span>
        <span class="s1">df[</span><span class="s4">&quot;groups&quot;</span><span class="s1">] = groups</span>
        <span class="s1">mod3 = MixedLM.from_formula(</span>
            <span class="s1">fml</span><span class="s0">, </span><span class="s1">df</span><span class="s0">, </span><span class="s1">re_formula=re_fml</span><span class="s0">, </span><span class="s1">groups=</span><span class="s4">&quot;groups&quot;</span><span class="s1">)</span>
        <span class="s1">assert_(mod3.data.xnames == [</span><span class="s4">&quot;exog0&quot;</span><span class="s0">, </span><span class="s4">&quot;exog1&quot;</span><span class="s0">, </span><span class="s4">&quot;exog2&quot;</span><span class="s0">, </span><span class="s4">&quot;exog3&quot;</span><span class="s1">])</span>
        <span class="s1">assert_(mod3.data.exog_re_names == [</span><span class="s4">&quot;exog_re&quot;</span><span class="s1">])</span>
        <span class="s1">assert_(mod3.data.exog_re_names_full == [</span><span class="s4">&quot;exog_re Var&quot;</span><span class="s1">])</span>

        <span class="s1">rslt3 = mod3.fit(start_params=rslt2.params)</span>
        <span class="s1">assert_allclose(rslt1.params</span><span class="s0">, </span><span class="s1">rslt3.params</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s5">1e-4</span><span class="s1">)</span>

        <span class="s2"># Check default variance structure with non-formula model</span>
        <span class="s2"># creation, also use different exog_re that produces a zero</span>
        <span class="s2"># estimated variance parameter.</span>
        <span class="s1">exog_re = np.ones(len(endog)</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span>
        <span class="s1">mod4 = MixedLM(endog</span><span class="s0">, </span><span class="s1">exog</span><span class="s0">, </span><span class="s1">groups</span><span class="s0">, </span><span class="s1">exog_re)</span>
        <span class="s0">with </span><span class="s1">warnings.catch_warnings():</span>
            <span class="s1">warnings.simplefilter(</span><span class="s4">&quot;ignore&quot;</span><span class="s1">)</span>
            <span class="s1">rslt4 = mod4.fit()</span>
        <span class="s0">from </span><span class="s1">statsmodels.formula.api </span><span class="s0">import </span><span class="s1">mixedlm</span>
        <span class="s1">mod5 = mixedlm(fml</span><span class="s0">, </span><span class="s1">df</span><span class="s0">, </span><span class="s1">groups=</span><span class="s4">&quot;groups&quot;</span><span class="s1">)</span>
        <span class="s1">assert_(mod5.data.exog_re_names == [</span><span class="s4">&quot;groups&quot;</span><span class="s1">])</span>
        <span class="s1">assert_(mod5.data.exog_re_names_full == [</span><span class="s4">&quot;groups Var&quot;</span><span class="s1">])</span>
        <span class="s0">with </span><span class="s1">warnings.catch_warnings():</span>
            <span class="s1">warnings.simplefilter(</span><span class="s4">&quot;ignore&quot;</span><span class="s1">)</span>
            <span class="s1">rslt5 = mod5.fit()</span>
        <span class="s1">assert_almost_equal(rslt4.params</span><span class="s0">, </span><span class="s1">rslt5.params)</span>

    <span class="s1">@pytest.mark.slow</span>
    <span class="s0">def </span><span class="s1">test_regularized(self):</span>

        <span class="s1">np.random.seed(</span><span class="s5">3453</span><span class="s1">)</span>
        <span class="s1">exog = np.random.normal(size=(</span><span class="s5">400</span><span class="s0">, </span><span class="s5">5</span><span class="s1">))</span>
        <span class="s1">groups = np.kron(np.arange(</span><span class="s5">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.ones(</span><span class="s5">4</span><span class="s1">))</span>
        <span class="s1">expected_endog = exog[:</span><span class="s0">, </span><span class="s5">0</span><span class="s1">] - exog[:</span><span class="s0">, </span><span class="s5">2</span><span class="s1">]</span>
        <span class="s1">endog = expected_endog +\</span>
            <span class="s1">np.kron(np.random.normal(size=</span><span class="s5">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.ones(</span><span class="s5">4</span><span class="s1">)) +\</span>
            <span class="s1">np.random.normal(size=</span><span class="s5">400</span><span class="s1">)</span>

        <span class="s2"># L1 regularization</span>
        <span class="s1">md = MixedLM(endog</span><span class="s0">, </span><span class="s1">exog</span><span class="s0">, </span><span class="s1">groups)</span>
        <span class="s1">mdf1 = md.fit_regularized(alpha=</span><span class="s5">1.</span><span class="s1">)</span>
        <span class="s1">mdf1.summary()</span>

        <span class="s2"># L1 regularization</span>
        <span class="s1">md = MixedLM(endog</span><span class="s0">, </span><span class="s1">exog</span><span class="s0">, </span><span class="s1">groups)</span>
        <span class="s1">mdf2 = md.fit_regularized(alpha=</span><span class="s5">10 </span><span class="s1">* np.ones(</span><span class="s5">5</span><span class="s1">))</span>
        <span class="s1">mdf2.summary()</span>

        <span class="s2"># L2 regularization</span>
        <span class="s1">pen = penalties.L2()</span>
        <span class="s1">mdf3 = md.fit_regularized(method=pen</span><span class="s0">, </span><span class="s1">alpha=</span><span class="s5">0.</span><span class="s1">)</span>
        <span class="s1">mdf3.summary()</span>

        <span class="s2"># L2 regularization</span>
        <span class="s1">pen = penalties.L2()</span>
        <span class="s0">with </span><span class="s1">warnings.catch_warnings():</span>
            <span class="s1">warnings.simplefilter(</span><span class="s4">&quot;ignore&quot;</span><span class="s1">)</span>
            <span class="s1">mdf4 = md.fit_regularized(method=pen</span><span class="s0">, </span><span class="s1">alpha=</span><span class="s5">10.</span><span class="s1">)</span>
        <span class="s1">mdf4.summary()</span>

        <span class="s2"># Pseudo-Huber regularization</span>
        <span class="s1">pen = penalties.PseudoHuber(</span><span class="s5">0.3</span><span class="s1">)</span>
        <span class="s1">mdf5 = md.fit_regularized(method=pen</span><span class="s0">, </span><span class="s1">alpha=</span><span class="s5">1.</span><span class="s1">)</span>
        <span class="s1">mdf5.summary()</span>


<span class="s2"># ------------------------------------------------------------------</span>


<span class="s0">class </span><span class="s1">TestMixedLMSummary:</span>
    <span class="s2"># Test various aspects of the MixedLM summary</span>
    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">setup_class(cls):</span>
        <span class="s2"># Setup the model and estimate it.</span>
        <span class="s1">pid = np.repeat([</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s5">5</span><span class="s1">)</span>
        <span class="s1">x0 = np.repeat([</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s5">10</span><span class="s1">)</span>
        <span class="s1">x1 = [</span><span class="s5">1</span><span class="s0">, </span><span class="s5">5</span><span class="s0">, </span><span class="s5">7</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">5</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">6</span><span class="s0">, </span><span class="s5">9</span><span class="s0">, </span><span class="s5">8</span><span class="s1">]</span>
        <span class="s1">x2 = [</span><span class="s5">6</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">4</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">8</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">y = [</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s0">, </span><span class="s5">5</span><span class="s0">, </span><span class="s5">6</span><span class="s0">, </span><span class="s5">7</span><span class="s0">, </span><span class="s5">8</span><span class="s0">, </span><span class="s5">9</span><span class="s1">]</span>
        <span class="s1">df = pd.DataFrame({</span><span class="s4">&quot;y&quot;</span><span class="s1">: y</span><span class="s0">, </span><span class="s4">&quot;pid&quot;</span><span class="s1">: pid</span><span class="s0">, </span><span class="s4">&quot;x0&quot;</span><span class="s1">: x0</span><span class="s0">, </span><span class="s4">&quot;x1&quot;</span><span class="s1">: x1</span><span class="s0">, </span><span class="s4">&quot;x2&quot;</span><span class="s1">: x2})</span>
        <span class="s1">endog = df[</span><span class="s4">&quot;y&quot;</span><span class="s1">].values</span>
        <span class="s1">exog = df[[</span><span class="s4">&quot;x0&quot;</span><span class="s0">, </span><span class="s4">&quot;x1&quot;</span><span class="s0">, </span><span class="s4">&quot;x2&quot;</span><span class="s1">]].values</span>
        <span class="s1">groups = df[</span><span class="s4">&quot;pid&quot;</span><span class="s1">].values</span>
        <span class="s1">cls.res = MixedLM(endog</span><span class="s0">, </span><span class="s1">exog</span><span class="s0">, </span><span class="s1">groups=groups).fit()</span>

    <span class="s0">def </span><span class="s1">test_summary(self):</span>
        <span class="s2"># Test that the summary correctly includes all variables.</span>
        <span class="s1">summ = self.res.summary()</span>
        <span class="s1">desired = [</span><span class="s4">&quot;const&quot;</span><span class="s0">, </span><span class="s4">&quot;x1&quot;</span><span class="s0">, </span><span class="s4">&quot;x2&quot;</span><span class="s0">, </span><span class="s4">&quot;Group Var&quot;</span><span class="s1">]</span>
        <span class="s2"># Second table is summary of params</span>
        <span class="s1">actual = summ.tables[</span><span class="s5">1</span><span class="s1">].index.values</span>
        <span class="s1">assert_equal(actual</span><span class="s0">, </span><span class="s1">desired)</span>

    <span class="s0">def </span><span class="s1">test_summary_xname_fe(self):</span>
        <span class="s2"># Test that the `xname_fe` argument is reflected in the summary table.</span>
        <span class="s1">summ = self.res.summary(xname_fe=[</span><span class="s4">&quot;Constant&quot;</span><span class="s0">, </span><span class="s4">&quot;Age&quot;</span><span class="s0">, </span><span class="s4">&quot;Weight&quot;</span><span class="s1">])</span>
        <span class="s1">desired = [</span><span class="s4">&quot;Constant&quot;</span><span class="s0">, </span><span class="s4">&quot;Age&quot;</span><span class="s0">, </span><span class="s4">&quot;Weight&quot;</span><span class="s0">, </span><span class="s4">&quot;Group Var&quot;</span><span class="s1">]</span>
        <span class="s1">actual = summ.tables[</span>
            <span class="s5">1</span><span class="s1">].index.values  </span><span class="s2"># Second table is summary of params</span>
        <span class="s1">assert_equal(actual</span><span class="s0">, </span><span class="s1">desired)</span>

    <span class="s0">def </span><span class="s1">test_summary_xname_re(self):</span>
        <span class="s2"># Test that the `xname_re` argument is reflected in the summary table.</span>
        <span class="s1">summ = self.res.summary(xname_re=[</span><span class="s4">&quot;Random Effects&quot;</span><span class="s1">])</span>
        <span class="s1">desired = [</span><span class="s4">&quot;const&quot;</span><span class="s0">, </span><span class="s4">&quot;x1&quot;</span><span class="s0">, </span><span class="s4">&quot;x2&quot;</span><span class="s0">, </span><span class="s4">&quot;Random Effects&quot;</span><span class="s1">]</span>
        <span class="s1">actual = summ.tables[</span>
            <span class="s5">1</span><span class="s1">].index.values  </span><span class="s2"># Second table is summary of params</span>
        <span class="s1">assert_equal(actual</span><span class="s0">, </span><span class="s1">desired)</span>


<span class="s2"># ------------------------------------------------------------------</span>


<span class="s0">class </span><span class="s1">TestMixedLMSummaryRegularized(TestMixedLMSummary):</span>
    <span class="s2"># Test various aspects of the MixedLM summary</span>
    <span class="s2"># after fitting model with fit_regularized function</span>
    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">setup_class(cls):</span>
        <span class="s2"># Setup the model and estimate it.</span>
        <span class="s1">pid = np.repeat([</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s5">5</span><span class="s1">)</span>
        <span class="s1">x0 = np.repeat([</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s5">10</span><span class="s1">)</span>
        <span class="s1">x1 = [</span><span class="s5">1</span><span class="s0">, </span><span class="s5">5</span><span class="s0">, </span><span class="s5">7</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">5</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">6</span><span class="s0">, </span><span class="s5">9</span><span class="s0">, </span><span class="s5">8</span><span class="s1">]</span>
        <span class="s1">x2 = [</span><span class="s5">6</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">4</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">8</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">y = [</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s0">, </span><span class="s5">5</span><span class="s0">, </span><span class="s5">6</span><span class="s0">, </span><span class="s5">7</span><span class="s0">, </span><span class="s5">8</span><span class="s0">, </span><span class="s5">9</span><span class="s1">]</span>
        <span class="s1">df = pd.DataFrame({</span><span class="s4">&quot;y&quot;</span><span class="s1">: y</span><span class="s0">, </span><span class="s4">&quot;pid&quot;</span><span class="s1">: pid</span><span class="s0">, </span><span class="s4">&quot;x0&quot;</span><span class="s1">: x0</span><span class="s0">, </span><span class="s4">&quot;x1&quot;</span><span class="s1">: x1</span><span class="s0">, </span><span class="s4">&quot;x2&quot;</span><span class="s1">: x2})</span>
        <span class="s1">endog = df[</span><span class="s4">&quot;y&quot;</span><span class="s1">].values</span>
        <span class="s1">exog = df[[</span><span class="s4">&quot;x0&quot;</span><span class="s0">, </span><span class="s4">&quot;x1&quot;</span><span class="s0">, </span><span class="s4">&quot;x2&quot;</span><span class="s1">]].values</span>
        <span class="s1">groups = df[</span><span class="s4">&quot;pid&quot;</span><span class="s1">].values</span>
        <span class="s1">cls.res = MixedLM(endog</span><span class="s0">, </span><span class="s1">exog</span><span class="s0">, </span><span class="s1">groups=groups).fit_regularized()</span>


<span class="s2"># ------------------------------------------------------------------</span>


<span class="s2"># TODO: better name</span>
<span class="s0">def </span><span class="s1">do1(reml</span><span class="s0">, </span><span class="s1">irf</span><span class="s0">, </span><span class="s1">ds_ix):</span>

    <span class="s2"># No need to check independent random effects when there is</span>
    <span class="s2"># only one of them.</span>
    <span class="s0">if </span><span class="s1">irf </span><span class="s0">and </span><span class="s1">ds_ix &lt; </span><span class="s5">6</span><span class="s1">:</span>
        <span class="s0">return</span>

    <span class="s1">irfs = </span><span class="s4">&quot;irf&quot; </span><span class="s0">if </span><span class="s1">irf </span><span class="s0">else </span><span class="s4">&quot;drf&quot;</span>
    <span class="s1">meth = </span><span class="s4">&quot;reml&quot; </span><span class="s0">if </span><span class="s1">reml </span><span class="s0">else </span><span class="s4">&quot;ml&quot;</span>

    <span class="s1">rslt = R_Results(meth</span><span class="s0">, </span><span class="s1">irfs</span><span class="s0">, </span><span class="s1">ds_ix)</span>

    <span class="s2"># Fit the model</span>
    <span class="s1">md = MixedLM(rslt.endog</span><span class="s0">, </span><span class="s1">rslt.exog_fe</span><span class="s0">, </span><span class="s1">rslt.groups</span><span class="s0">, </span><span class="s1">rslt.exog_re)</span>
    <span class="s0">if not </span><span class="s1">irf:  </span><span class="s2"># Free random effects covariance</span>
        <span class="s0">if </span><span class="s1">np.any(np.diag(rslt.cov_re_r) &lt; </span><span class="s5">1e-5</span><span class="s1">):</span>
            <span class="s0">with </span><span class="s1">warnings.catch_warnings():</span>
                <span class="s1">warnings.simplefilter(</span><span class="s4">&quot;ignore&quot;</span><span class="s1">)</span>
                <span class="s1">mdf = md.fit(gtol=</span><span class="s5">1e-7</span><span class="s0">, </span><span class="s1">reml=reml)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">mdf = md.fit(gtol=</span><span class="s5">1e-7</span><span class="s0">, </span><span class="s1">reml=reml)</span>

    <span class="s0">else</span><span class="s1">:  </span><span class="s2"># Independent random effects</span>
        <span class="s1">k_fe = rslt.exog_fe.shape[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">k_re = rslt.exog_re.shape[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">free = MixedLMParams(k_fe</span><span class="s0">, </span><span class="s1">k_re</span><span class="s0">, </span><span class="s5">0</span><span class="s1">)</span>
        <span class="s1">free.fe_params = np.ones(k_fe)</span>
        <span class="s1">free.cov_re = np.eye(k_re)</span>
        <span class="s1">free.vcomp = np.array([])</span>
        <span class="s0">if </span><span class="s1">np.any(np.diag(rslt.cov_re_r) &lt; </span><span class="s5">1e-5</span><span class="s1">):</span>
            <span class="s0">with </span><span class="s1">warnings.catch_warnings():</span>
                <span class="s1">warnings.simplefilter(</span><span class="s4">&quot;ignore&quot;</span><span class="s1">)</span>
                <span class="s1">mdf = md.fit(reml=reml</span><span class="s0">, </span><span class="s1">gtol=</span><span class="s5">1e-7</span><span class="s0">, </span><span class="s1">free=free)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">mdf = md.fit(reml=reml</span><span class="s0">, </span><span class="s1">gtol=</span><span class="s5">1e-7</span><span class="s0">, </span><span class="s1">free=free)</span>

    <span class="s1">assert_almost_equal(mdf.fe_params</span><span class="s0">, </span><span class="s1">rslt.coef</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s5">4</span><span class="s1">)</span>
    <span class="s1">assert_almost_equal(mdf.cov_re</span><span class="s0">, </span><span class="s1">rslt.cov_re_r</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s5">4</span><span class="s1">)</span>
    <span class="s1">assert_almost_equal(mdf.scale</span><span class="s0">, </span><span class="s1">rslt.scale_r</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s5">4</span><span class="s1">)</span>

    <span class="s1">k_fe = md.k_fe</span>
    <span class="s1">assert_almost_equal(</span>
        <span class="s1">rslt.vcov_r</span><span class="s0">, </span><span class="s1">mdf.cov_params()[</span><span class="s5">0</span><span class="s1">:k_fe</span><span class="s0">, </span><span class="s5">0</span><span class="s1">:k_fe]</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s5">3</span><span class="s1">)</span>

    <span class="s1">assert_almost_equal(mdf.llf</span><span class="s0">, </span><span class="s1">rslt.loglike[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s5">2</span><span class="s1">)</span>

    <span class="s2"># Not supported in R except for independent random effects</span>
    <span class="s0">if not </span><span class="s1">irf:</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">mdf.random_effects[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">rslt.ranef_postmean</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s5">3</span><span class="s1">)</span>
        <span class="s1">assert_almost_equal(</span>
            <span class="s1">mdf.random_effects_cov[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">rslt.ranef_condvar</span><span class="s0">, </span><span class="s1">decimal=</span><span class="s5">3</span><span class="s1">)</span>


<span class="s2"># ------------------------------------------------------------------</span>

<span class="s2"># Run all the tests against R</span>
<span class="s1">cur_dir = os.path.dirname(os.path.abspath(__file__))</span>
<span class="s1">rdir = os.path.join(cur_dir</span><span class="s0">, </span><span class="s4">'results'</span><span class="s1">)</span>
<span class="s1">fnames = os.listdir(rdir)</span>
<span class="s1">fnames = [x </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">fnames </span><span class="s0">if </span><span class="s1">x.startswith(</span><span class="s4">&quot;lme&quot;</span><span class="s1">) </span><span class="s0">and </span><span class="s1">x.endswith(</span><span class="s4">&quot;.csv&quot;</span><span class="s1">)]</span>


<span class="s2"># Copied from #3847</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">'fname'</span><span class="s0">, </span><span class="s1">fnames)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">'reml'</span><span class="s0">, </span><span class="s1">[</span><span class="s0">False, True</span><span class="s1">])</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s4">'irf'</span><span class="s0">, </span><span class="s1">[</span><span class="s0">False, True</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_r(fname</span><span class="s0">, </span><span class="s1">reml</span><span class="s0">, </span><span class="s1">irf):</span>
    <span class="s1">ds_ix = int(fname[</span><span class="s5">3</span><span class="s1">:</span><span class="s5">5</span><span class="s1">])</span>
    <span class="s1">do1(reml</span><span class="s0">, </span><span class="s1">irf</span><span class="s0">, </span><span class="s1">ds_ix)</span>


<span class="s2"># ------------------------------------------------------------------</span>


<span class="s0">def </span><span class="s1">test_mixed_lm_wrapper():</span>
    <span class="s2"># a bit more complicated model to test</span>
    <span class="s1">np.random.seed(</span><span class="s5">2410</span><span class="s1">)</span>
    <span class="s1">exog = np.random.normal(size=(</span><span class="s5">300</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span>
    <span class="s1">exog_re = np.random.normal(size=</span><span class="s5">300</span><span class="s1">)</span>
    <span class="s1">groups = np.kron(np.arange(</span><span class="s5">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">])</span>
    <span class="s1">g_errors = exog_re * np.kron(np.random.normal(size=</span><span class="s5">100</span><span class="s1">)</span><span class="s0">, </span><span class="s1">[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s1">])</span>
    <span class="s1">endog = exog.sum(</span><span class="s5">1</span><span class="s1">) + g_errors + np.random.normal(size=</span><span class="s5">300</span><span class="s1">)</span>

    <span class="s2"># Fit with a formula, passing groups as the actual values.</span>
    <span class="s1">df = pd.DataFrame({</span><span class="s4">&quot;endog&quot;</span><span class="s1">: endog})</span>
    <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range(exog.shape[</span><span class="s5">1</span><span class="s1">]):</span>
        <span class="s1">df[</span><span class="s4">&quot;exog%d&quot; </span><span class="s1">% k] = exog[:</span><span class="s0">, </span><span class="s1">k]</span>
    <span class="s1">df[</span><span class="s4">&quot;exog_re&quot;</span><span class="s1">] = exog_re</span>
    <span class="s1">fml = </span><span class="s4">&quot;endog ~ 0 + exog0 + exog1 + exog2 + exog3&quot;</span>
    <span class="s1">re_fml = </span><span class="s4">&quot;~ exog_re&quot;</span>
    <span class="s1">mod2 = MixedLM.from_formula(fml</span><span class="s0">, </span><span class="s1">df</span><span class="s0">, </span><span class="s1">re_formula=re_fml</span><span class="s0">, </span><span class="s1">groups=groups)</span>
    <span class="s1">result = mod2.fit()</span>
    <span class="s1">result.summary()</span>

    <span class="s1">xnames = [</span><span class="s4">&quot;exog0&quot;</span><span class="s0">, </span><span class="s4">&quot;exog1&quot;</span><span class="s0">, </span><span class="s4">&quot;exog2&quot;</span><span class="s0">, </span><span class="s4">&quot;exog3&quot;</span><span class="s1">]</span>
    <span class="s1">re_names = [</span><span class="s4">&quot;Group&quot;</span><span class="s0">, </span><span class="s4">&quot;exog_re&quot;</span><span class="s1">]</span>
    <span class="s1">re_names_full = [</span><span class="s4">&quot;Group Var&quot;</span><span class="s0">, </span><span class="s4">&quot;Group x exog_re Cov&quot;</span><span class="s0">, </span><span class="s4">&quot;exog_re Var&quot;</span><span class="s1">]</span>

    <span class="s1">assert_(mod2.data.xnames == xnames)</span>
    <span class="s1">assert_(mod2.data.exog_re_names == re_names)</span>
    <span class="s1">assert_(mod2.data.exog_re_names_full == re_names_full)</span>

    <span class="s1">params = result.params</span>
    <span class="s1">assert_(params.index.tolist() == xnames + re_names_full)</span>
    <span class="s1">bse = result.bse</span>
    <span class="s1">assert_(bse.index.tolist() == xnames + re_names_full)</span>
    <span class="s1">tvalues = result.tvalues</span>
    <span class="s1">assert_(tvalues.index.tolist() == xnames + re_names_full)</span>
    <span class="s1">cov_params = result.cov_params()</span>
    <span class="s1">assert_(cov_params.index.tolist() == xnames + re_names_full)</span>
    <span class="s1">assert_(cov_params.columns.tolist() == xnames + re_names_full)</span>
    <span class="s1">fe = result.fe_params</span>
    <span class="s1">assert_(fe.index.tolist() == xnames)</span>
    <span class="s1">bse_fe = result.bse_fe</span>
    <span class="s1">assert_(bse_fe.index.tolist() == xnames)</span>
    <span class="s1">cov_re = result.cov_re</span>
    <span class="s1">assert_(cov_re.index.tolist() == re_names)</span>
    <span class="s1">assert_(cov_re.columns.tolist() == re_names)</span>
    <span class="s1">cov_re_u = result.cov_re_unscaled</span>
    <span class="s1">assert_(cov_re_u.index.tolist() == re_names)</span>
    <span class="s1">assert_(cov_re_u.columns.tolist() == re_names)</span>
    <span class="s1">bse_re = result.bse_re</span>
    <span class="s1">assert_(bse_re.index.tolist() == re_names_full)</span>


<span class="s0">def </span><span class="s1">test_random_effects():</span>

    <span class="s1">np.random.seed(</span><span class="s5">23429</span><span class="s1">)</span>

    <span class="s2"># Default model (random effects only)</span>
    <span class="s1">ngrp = </span><span class="s5">100</span>
    <span class="s1">gsize = </span><span class="s5">10</span>
    <span class="s1">rsd = </span><span class="s5">2</span>
    <span class="s1">gsd = </span><span class="s5">3</span>
    <span class="s1">mn = gsd * np.random.normal(size=ngrp)</span>
    <span class="s1">gmn = np.kron(mn</span><span class="s0">, </span><span class="s1">np.ones(gsize))</span>
    <span class="s1">y = gmn + rsd * np.random.normal(size=ngrp * gsize)</span>
    <span class="s1">gr = np.kron(np.arange(ngrp)</span><span class="s0">, </span><span class="s1">np.ones(gsize))</span>
    <span class="s1">x = np.ones(ngrp * gsize)</span>
    <span class="s1">model = MixedLM(y</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">groups=gr)</span>
    <span class="s1">result = model.fit()</span>
    <span class="s1">re = result.random_effects</span>
    <span class="s1">assert_(isinstance(re</span><span class="s0">, </span><span class="s1">dict))</span>
    <span class="s1">assert_(len(re) == ngrp)</span>
    <span class="s1">assert_(isinstance(re[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">pd.Series))</span>
    <span class="s1">assert_(len(re[</span><span class="s5">0</span><span class="s1">]) == </span><span class="s5">1</span><span class="s1">)</span>

    <span class="s2"># Random intercept only, set explicitly</span>
    <span class="s1">model = MixedLM(y</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">exog_re=x</span><span class="s0">, </span><span class="s1">groups=gr)</span>
    <span class="s1">result = model.fit()</span>
    <span class="s1">re = result.random_effects</span>
    <span class="s1">assert_(isinstance(re</span><span class="s0">, </span><span class="s1">dict))</span>
    <span class="s1">assert_(len(re) == ngrp)</span>
    <span class="s1">assert_(isinstance(re[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">pd.Series))</span>
    <span class="s1">assert_(len(re[</span><span class="s5">0</span><span class="s1">]) == </span><span class="s5">1</span><span class="s1">)</span>

    <span class="s2"># Random intercept and slope</span>
    <span class="s1">xr = np.random.normal(size=(ngrp * gsize</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span>
    <span class="s1">xr[:</span><span class="s0">, </span><span class="s5">0</span><span class="s1">] = </span><span class="s5">1</span>
    <span class="s1">qp = np.linspace(-</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s1">gsize)</span>
    <span class="s1">xr[:</span><span class="s0">, </span><span class="s5">1</span><span class="s1">] = np.kron(np.ones(ngrp)</span><span class="s0">, </span><span class="s1">qp)</span>
    <span class="s1">model = MixedLM(y</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">exog_re=xr</span><span class="s0">, </span><span class="s1">groups=gr)</span>
    <span class="s1">result = model.fit()</span>
    <span class="s1">re = result.random_effects</span>
    <span class="s1">assert_(isinstance(re</span><span class="s0">, </span><span class="s1">dict))</span>
    <span class="s1">assert_(len(re) == ngrp)</span>
    <span class="s1">assert_(isinstance(re[</span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">pd.Series))</span>
    <span class="s1">assert_(len(re[</span><span class="s5">0</span><span class="s1">]) == </span><span class="s5">2</span><span class="s1">)</span>


<span class="s1">@pytest.mark.slow</span>
<span class="s0">def </span><span class="s1">test_handle_missing():</span>

    <span class="s1">np.random.seed(</span><span class="s5">23423</span><span class="s1">)</span>
    <span class="s1">df = np.random.normal(size=(</span><span class="s5">100</span><span class="s0">, </span><span class="s5">6</span><span class="s1">))</span>
    <span class="s1">df = pd.DataFrame(df)</span>
    <span class="s1">df.columns = [</span><span class="s4">&quot;y&quot;</span><span class="s0">, </span><span class="s4">&quot;g&quot;</span><span class="s0">, </span><span class="s4">&quot;x1&quot;</span><span class="s0">, </span><span class="s4">&quot;z1&quot;</span><span class="s0">, </span><span class="s4">&quot;c1&quot;</span><span class="s0">, </span><span class="s4">&quot;c2&quot;</span><span class="s1">]</span>
    <span class="s1">df[</span><span class="s4">&quot;g&quot;</span><span class="s1">] = np.kron(np.arange(</span><span class="s5">50</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.ones(</span><span class="s5">2</span><span class="s1">))</span>
    <span class="s1">re = np.random.normal(size=(</span><span class="s5">50</span><span class="s0">, </span><span class="s5">4</span><span class="s1">))</span>
    <span class="s1">re = np.kron(re</span><span class="s0">, </span><span class="s1">np.ones((</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1</span><span class="s1">)))</span>
    <span class="s1">df[</span><span class="s4">&quot;y&quot;</span><span class="s1">] = re[:</span><span class="s0">, </span><span class="s5">0</span><span class="s1">] + re[:</span><span class="s0">, </span><span class="s5">1</span><span class="s1">] * df.z1 + re[:</span><span class="s0">, </span><span class="s5">2</span><span class="s1">] * df.c1</span>
    <span class="s1">df[</span><span class="s4">&quot;y&quot;</span><span class="s1">] += re[:</span><span class="s0">, </span><span class="s5">3</span><span class="s1">] * df.c2 + np.random.normal(size=</span><span class="s5">100</span><span class="s1">)</span>
    <span class="s1">df.loc[</span><span class="s5">1</span><span class="s0">, </span><span class="s4">&quot;y&quot;</span><span class="s1">] = np.NaN</span>
    <span class="s1">df.loc[</span><span class="s5">2</span><span class="s0">, </span><span class="s4">&quot;g&quot;</span><span class="s1">] = np.NaN</span>
    <span class="s1">df.loc[</span><span class="s5">3</span><span class="s0">, </span><span class="s4">&quot;x1&quot;</span><span class="s1">] = np.NaN</span>
    <span class="s1">df.loc[</span><span class="s5">4</span><span class="s0">, </span><span class="s4">&quot;z1&quot;</span><span class="s1">] = np.NaN</span>
    <span class="s1">df.loc[</span><span class="s5">5</span><span class="s0">, </span><span class="s4">&quot;c1&quot;</span><span class="s1">] = np.NaN</span>
    <span class="s1">df.loc[</span><span class="s5">6</span><span class="s0">, </span><span class="s4">&quot;c2&quot;</span><span class="s1">] = np.NaN</span>

    <span class="s1">fml = </span><span class="s4">&quot;y ~ x1&quot;</span>
    <span class="s1">re_formula = </span><span class="s4">&quot;1 + z1&quot;</span>
    <span class="s1">vc_formula = {</span><span class="s4">&quot;a&quot;</span><span class="s1">: </span><span class="s4">&quot;0 + c1&quot;</span><span class="s0">, </span><span class="s4">&quot;b&quot;</span><span class="s1">: </span><span class="s4">&quot;0 + c2&quot;</span><span class="s1">}</span>
    <span class="s0">for </span><span class="s1">include_re </span><span class="s0">in False, True</span><span class="s1">:</span>
        <span class="s0">for </span><span class="s1">include_vc </span><span class="s0">in False, True</span><span class="s1">:</span>
            <span class="s1">kwargs = {}</span>
            <span class="s1">dx = df.copy()</span>
            <span class="s1">va = [</span><span class="s4">&quot;y&quot;</span><span class="s0">, </span><span class="s4">&quot;g&quot;</span><span class="s0">, </span><span class="s4">&quot;x1&quot;</span><span class="s1">]</span>
            <span class="s0">if </span><span class="s1">include_re:</span>
                <span class="s1">kwargs[</span><span class="s4">&quot;re_formula&quot;</span><span class="s1">] = re_formula</span>
                <span class="s1">va.append(</span><span class="s4">&quot;z1&quot;</span><span class="s1">)</span>
            <span class="s0">if </span><span class="s1">include_vc:</span>
                <span class="s1">kwargs[</span><span class="s4">&quot;vc_formula&quot;</span><span class="s1">] = vc_formula</span>
                <span class="s1">va.extend([</span><span class="s4">&quot;c1&quot;</span><span class="s0">, </span><span class="s4">&quot;c2&quot;</span><span class="s1">])</span>

            <span class="s1">dx = dx[va].dropna()</span>

            <span class="s2"># Some of these models are severely misspecified with</span>
            <span class="s2"># small n, so produce convergence warnings.  Not relevant</span>
            <span class="s2"># to what we are checking here.</span>
            <span class="s0">with </span><span class="s1">warnings.catch_warnings():</span>
                <span class="s1">warnings.simplefilter(</span><span class="s4">&quot;ignore&quot;</span><span class="s1">)</span>

                <span class="s2"># Drop missing externally</span>
                <span class="s1">model1 = MixedLM.from_formula(</span>
                    <span class="s1">fml</span><span class="s0">, </span><span class="s1">groups=</span><span class="s4">&quot;g&quot;</span><span class="s0">, </span><span class="s1">data=dx</span><span class="s0">, </span><span class="s1">**kwargs)</span>
                <span class="s1">result1 = model1.fit()</span>

                <span class="s2"># MixeLM handles missing</span>
                <span class="s1">model2 = MixedLM.from_formula(</span>
                    <span class="s1">fml</span><span class="s0">, </span><span class="s1">groups=</span><span class="s4">&quot;g&quot;</span><span class="s0">, </span><span class="s1">data=df</span><span class="s0">, </span><span class="s1">missing=</span><span class="s4">'drop'</span><span class="s0">, </span><span class="s1">**kwargs)</span>
                <span class="s1">result2 = model2.fit()</span>

                <span class="s1">assert_allclose(result1.params</span><span class="s0">, </span><span class="s1">result2.params)</span>
                <span class="s1">assert_allclose(result1.bse</span><span class="s0">, </span><span class="s1">result2.bse)</span>
                <span class="s1">assert_equal(len(result1.fittedvalues)</span><span class="s0">, </span><span class="s1">result1.nobs)</span>


<span class="s0">def </span><span class="s1">test_summary_col():</span>
    <span class="s0">from </span><span class="s1">statsmodels.iolib.summary2 </span><span class="s0">import </span><span class="s1">summary_col</span>
    <span class="s1">ids = [</span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">3</span><span class="s1">]</span>
    <span class="s1">x = [</span><span class="s5">1</span><span class="s0">, </span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s0">, </span><span class="s5">4</span><span class="s0">, </span><span class="s5">5</span><span class="s0">, </span><span class="s5">6</span><span class="s0">, </span><span class="s5">7</span><span class="s0">, </span><span class="s5">8</span><span class="s0">, </span><span class="s5">9</span><span class="s0">, </span><span class="s5">10</span><span class="s0">, </span><span class="s5">11</span><span class="s0">, </span><span class="s5">12</span><span class="s0">, </span><span class="s5">13</span><span class="s0">, </span><span class="s5">14</span><span class="s0">, </span><span class="s5">15</span><span class="s1">]</span>
    <span class="s2"># hard coded simulated y</span>
    <span class="s2"># ids = np.asarray(ids)</span>
    <span class="s2"># np.random.seed(123987)</span>
    <span class="s2"># y = x + np.array([-1, 0, 1])[ids - 1] + 2 * np.random.randn(len(y))</span>
    <span class="s1">y = np.array([</span>
        <span class="s5">1.727</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1.037</span><span class="s0">, </span><span class="s5">2.904</span><span class="s0">, </span><span class="s5">3.569</span><span class="s0">, </span><span class="s5">4.629</span><span class="s0">, </span><span class="s5">5.736</span><span class="s0">, </span><span class="s5">6.747</span><span class="s0">, </span><span class="s5">7.020</span><span class="s0">, </span><span class="s5">5.624</span><span class="s0">, </span><span class="s5">10.155</span><span class="s0">,</span>
        <span class="s5">10.400</span><span class="s0">, </span><span class="s5">17.164</span><span class="s0">, </span><span class="s5">17.276</span><span class="s0">, </span><span class="s5">14.988</span><span class="s0">, </span><span class="s5">14.453</span>
    <span class="s1">])</span>
    <span class="s1">d = {</span><span class="s4">'Y'</span><span class="s1">: y</span><span class="s0">, </span><span class="s4">'X'</span><span class="s1">: x</span><span class="s0">, </span><span class="s4">'IDS'</span><span class="s1">: ids}</span>
    <span class="s1">d = pd.DataFrame(d)</span>

    <span class="s2"># provide start_params to speed up convergence</span>
    <span class="s1">sp1 = np.array([-</span><span class="s5">1.26722599</span><span class="s0">, </span><span class="s5">1.1617587</span><span class="s0">, </span><span class="s5">0.19547518</span><span class="s1">])</span>
    <span class="s1">mod1 = MixedLM.from_formula(</span><span class="s4">'Y ~ X'</span><span class="s0">, </span><span class="s1">d</span><span class="s0">, </span><span class="s1">groups=d[</span><span class="s4">'IDS'</span><span class="s1">])</span>
    <span class="s1">results1 = mod1.fit(start_params=sp1)</span>
    <span class="s1">sp2 = np.array([</span><span class="s5">3.48416861</span><span class="s0">, </span><span class="s5">0.55287862</span><span class="s0">, </span><span class="s5">1.38537901</span><span class="s1">])</span>
    <span class="s1">mod2 = MixedLM.from_formula(</span><span class="s4">'X ~ Y'</span><span class="s0">, </span><span class="s1">d</span><span class="s0">, </span><span class="s1">groups=d[</span><span class="s4">'IDS'</span><span class="s1">])</span>
    <span class="s1">results2 = mod2.fit(start_params=sp2)</span>

    <span class="s1">out = summary_col([results1</span><span class="s0">, </span><span class="s1">results2]</span><span class="s0">, </span><span class="s1">stars=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">s = (</span><span class="s4">'</span><span class="s0">\n</span><span class="s4">=============================</span><span class="s0">\n              </span><span class="s4">Y         X    </span><span class="s0">\n</span><span class="s4">'</span>
         <span class="s4">'-----------------------------</span><span class="s0">\n</span><span class="s4">Group Var 0.1955    1.3854   </span><span class="s0">\n</span><span class="s4">'</span>
         <span class="s4">'          (0.6032)  (2.7377) </span><span class="s0">\n</span><span class="s4">Intercept -1.2672   3.4842*  </span><span class="s0">\n</span><span class="s4">'</span>
         <span class="s4">'          (1.6546)  (1.8882) </span><span class="s0">\n</span><span class="s4">X         1.1618***          </span><span class="s0">\n</span><span class="s4">'</span>
         <span class="s4">'          (0.1959)           </span><span class="s0">\n</span><span class="s4">Y                   0.5529***</span><span class="s0">\n</span><span class="s4">'</span>
         <span class="s4">'                    (0.2080) </span><span class="s0">\n</span><span class="s4">=============================</span><span class="s0">\n</span><span class="s4">'</span>
         <span class="s4">'Standard errors in</span><span class="s0">\n</span><span class="s4">parentheses.</span><span class="s0">\n</span><span class="s4">* p&lt;.1, ** p&lt;.05, ***p&lt;.01'</span><span class="s1">)</span>
    <span class="s1">assert_equal(str(out)</span><span class="s0">, </span><span class="s1">s)</span>


<span class="s1">@pytest.mark.slow</span>
<span class="s0">def </span><span class="s1">test_random_effects_getters():</span>
    <span class="s2"># Simulation-based test to make sure that the BLUPs and actual</span>
    <span class="s2"># random effects line up.</span>

    <span class="s1">np.random.seed(</span><span class="s5">34234</span><span class="s1">)</span>
    <span class="s1">ng = </span><span class="s5">500  </span><span class="s2"># number of groups</span>
    <span class="s1">m = </span><span class="s5">10  </span><span class="s2"># group size</span>

    <span class="s1">y</span><span class="s0">, </span><span class="s1">x</span><span class="s0">, </span><span class="s1">z</span><span class="s0">, </span><span class="s1">v0</span><span class="s0">, </span><span class="s1">v1</span><span class="s0">, </span><span class="s1">g</span><span class="s0">, </span><span class="s1">b</span><span class="s0">, </span><span class="s1">c0</span><span class="s0">, </span><span class="s1">c1 = []</span><span class="s0">, </span><span class="s1">[]</span><span class="s0">, </span><span class="s1">[]</span><span class="s0">, </span><span class="s1">[]</span><span class="s0">, </span><span class="s1">[]</span><span class="s0">, </span><span class="s1">[]</span><span class="s0">, </span><span class="s1">[]</span><span class="s0">, </span><span class="s1">[]</span><span class="s0">, </span><span class="s1">[]</span>

    <span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">range(ng):</span>

        <span class="s2"># Fixed effects</span>
        <span class="s1">xx = np.random.normal(size=(m</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span>
        <span class="s1">yy = xx[:</span><span class="s0">, </span><span class="s5">0</span><span class="s1">] + </span><span class="s5">0.5 </span><span class="s1">* np.random.normal(size=m)</span>

        <span class="s2"># Random effects (re_formula)</span>
        <span class="s1">zz = np.random.normal(size=(m</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span>
        <span class="s1">bb = np.random.normal(size=</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">bb[</span><span class="s5">0</span><span class="s1">] *= </span><span class="s5">3</span>
        <span class="s1">bb[</span><span class="s5">1</span><span class="s1">] *= </span><span class="s5">1</span>
        <span class="s1">yy += np.dot(zz</span><span class="s0">, </span><span class="s1">bb).flat</span>
        <span class="s1">b.append(bb)</span>

        <span class="s2"># First variance component</span>
        <span class="s1">vv0 = np.kron(np.r_[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">np.ones(m // </span><span class="s5">2</span><span class="s1">)).astype(int)</span>
        <span class="s1">cc0 = np.random.normal(size=</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">yy += cc0[vv0]</span>
        <span class="s1">v0.append(vv0)</span>
        <span class="s1">c0.append(cc0)</span>

        <span class="s2"># Second variance component</span>
        <span class="s1">vv1 = np.kron(np.ones(m // </span><span class="s5">2</span><span class="s1">)</span><span class="s0">, </span><span class="s1">np.r_[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]).astype(int)</span>
        <span class="s1">cc1 = np.random.normal(size=</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">yy += cc1[vv1]</span>
        <span class="s1">v1.append(vv1)</span>
        <span class="s1">c1.append(cc1)</span>

        <span class="s1">y.append(yy)</span>
        <span class="s1">x.append(xx)</span>
        <span class="s1">z.append(zz)</span>
        <span class="s1">g.append([</span><span class="s4">&quot;g%d&quot; </span><span class="s1">% i] * m)</span>

    <span class="s1">y = np.concatenate(y)</span>
    <span class="s1">x = np.concatenate(x)</span>
    <span class="s1">z = np.concatenate(z)</span>
    <span class="s1">v0 = np.concatenate(v0)</span>
    <span class="s1">v1 = np.concatenate(v1)</span>
    <span class="s1">g = np.concatenate(g)</span>
    <span class="s1">df = pd.DataFrame({</span>
        <span class="s4">&quot;y&quot;</span><span class="s1">: y</span><span class="s0">,</span>
        <span class="s4">&quot;x0&quot;</span><span class="s1">: x[:</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s4">&quot;x1&quot;</span><span class="s1">: x[:</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s4">&quot;z0&quot;</span><span class="s1">: z[:</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s4">&quot;z1&quot;</span><span class="s1">: z[:</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s4">&quot;v0&quot;</span><span class="s1">: v0</span><span class="s0">,</span>
        <span class="s4">&quot;v1&quot;</span><span class="s1">: v1</span><span class="s0">,</span>
        <span class="s4">&quot;g&quot;</span><span class="s1">: g</span>
    <span class="s1">})</span>

    <span class="s1">b = np.asarray(b)</span>
    <span class="s1">c0 = np.asarray(c0)</span>
    <span class="s1">c1 = np.asarray(c1)</span>
    <span class="s1">cc = np.concatenate((c0</span><span class="s0">, </span><span class="s1">c1)</span><span class="s0">, </span><span class="s1">axis=</span><span class="s5">1</span><span class="s1">)</span>

    <span class="s1">model = MixedLM.from_formula(</span>
        <span class="s4">&quot;y ~ x0 + x1&quot;</span><span class="s0">,</span>
        <span class="s1">re_formula=</span><span class="s4">&quot;~0 + z0 + z1&quot;</span><span class="s0">,</span>
        <span class="s1">vc_formula={</span>
            <span class="s4">&quot;v0&quot;</span><span class="s1">: </span><span class="s4">&quot;~0+C(v0)&quot;</span><span class="s0">,</span>
            <span class="s4">&quot;v1&quot;</span><span class="s1">: </span><span class="s4">&quot;0+C(v1)&quot;</span>
        <span class="s1">}</span><span class="s0">,</span>
        <span class="s1">groups=</span><span class="s4">&quot;g&quot;</span><span class="s0">,</span>
        <span class="s1">data=df)</span>
    <span class="s1">result = model.fit()</span>

    <span class="s1">ref = result.random_effects</span>
    <span class="s1">b0 = [ref[</span><span class="s4">&quot;g%d&quot; </span><span class="s1">% k][</span><span class="s5">0</span><span class="s1">:</span><span class="s5">2</span><span class="s1">] </span><span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range(ng)]</span>
    <span class="s1">b0 = np.asarray(b0)</span>
    <span class="s0">assert </span><span class="s1">(np.corrcoef(b0[:</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">b[:</span><span class="s0">, </span><span class="s5">0</span><span class="s1">])[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">] &gt; </span><span class="s5">0.8</span><span class="s1">)</span>
    <span class="s0">assert </span><span class="s1">(np.corrcoef(b0[:</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">b[:</span><span class="s0">, </span><span class="s5">1</span><span class="s1">])[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">] &gt; </span><span class="s5">0.8</span><span class="s1">)</span>

    <span class="s1">cf0 = [ref[</span><span class="s4">&quot;g%d&quot; </span><span class="s1">% k][</span><span class="s5">2</span><span class="s1">:</span><span class="s5">6</span><span class="s1">] </span><span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range(ng)]</span>
    <span class="s1">cf0 = np.asarray(cf0)</span>
    <span class="s0">for </span><span class="s1">k </span><span class="s0">in </span><span class="s1">range(</span><span class="s5">4</span><span class="s1">):</span>
        <span class="s0">assert </span><span class="s1">(np.corrcoef(cf0[:</span><span class="s0">, </span><span class="s1">k]</span><span class="s0">, </span><span class="s1">cc[:</span><span class="s0">, </span><span class="s1">k])[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">1</span><span class="s1">] &gt; </span><span class="s5">0.8</span><span class="s1">)</span>

    <span class="s2"># Smoke test for predictive covariances</span>
    <span class="s1">refc = result.random_effects_cov</span>
    <span class="s0">for </span><span class="s1">g </span><span class="s0">in </span><span class="s1">refc.keys():</span>
        <span class="s1">p = ref[g].size</span>
        <span class="s0">assert </span><span class="s1">(refc[g].shape == (p</span><span class="s0">, </span><span class="s1">p))</span>


<span class="s0">def </span><span class="s1">check_smw_solver(p</span><span class="s0">, </span><span class="s1">q</span><span class="s0">, </span><span class="s1">r</span><span class="s0">, </span><span class="s1">s):</span>
    <span class="s2"># Helper to check that _smw_solver results do in fact solve the desired</span>
    <span class="s2"># SMW equation</span>
    <span class="s1">d = q - r</span>

    <span class="s1">A = np.random.normal(size=(p</span><span class="s0">, </span><span class="s1">q))</span>
    <span class="s1">AtA = np.dot(A.T</span><span class="s0">, </span><span class="s1">A)</span>

    <span class="s1">B = np.zeros((q</span><span class="s0">, </span><span class="s1">q))</span>
    <span class="s1">B[</span><span class="s5">0</span><span class="s1">:r</span><span class="s0">, </span><span class="s5">0</span><span class="s1">:r] = np.random.normal(size=(r</span><span class="s0">, </span><span class="s1">r))</span>
    <span class="s1">di = np.random.uniform(size=d)</span>
    <span class="s1">B[r:q</span><span class="s0">, </span><span class="s1">r:q] = np.diag(</span><span class="s5">1 </span><span class="s1">/ di)</span>
    <span class="s1">Qi = np.linalg.inv(B[</span><span class="s5">0</span><span class="s1">:r</span><span class="s0">, </span><span class="s5">0</span><span class="s1">:r])</span>
    <span class="s1">s = </span><span class="s5">0.5</span>

    <span class="s1">x = np.random.normal(size=p)</span>
    <span class="s1">y2 = np.linalg.solve(s * np.eye(p</span><span class="s0">, </span><span class="s1">p) + np.dot(A</span><span class="s0">, </span><span class="s1">np.dot(B</span><span class="s0">, </span><span class="s1">A.T))</span><span class="s0">, </span><span class="s1">x)</span>

    <span class="s1">f = _smw_solver(s</span><span class="s0">, </span><span class="s1">A</span><span class="s0">, </span><span class="s1">AtA</span><span class="s0">, </span><span class="s1">Qi</span><span class="s0">, </span><span class="s1">di)</span>
    <span class="s1">y1 = f(x)</span>
    <span class="s1">assert_allclose(y1</span><span class="s0">, </span><span class="s1">y2)</span>

    <span class="s1">f = _smw_solver(s</span><span class="s0">, </span><span class="s1">sparse.csr_matrix(A)</span><span class="s0">, </span><span class="s1">sparse.csr_matrix(AtA)</span><span class="s0">, </span><span class="s1">Qi</span><span class="s0">,</span>
                    <span class="s1">di)</span>
    <span class="s1">y1 = f(x)</span>
    <span class="s1">assert_allclose(y1</span><span class="s0">, </span><span class="s1">y2)</span>


<span class="s0">class </span><span class="s1">TestSMWSolver:</span>
    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">np.random.seed(</span><span class="s5">23</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;p&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s5">5</span><span class="s0">, </span><span class="s5">10</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;q&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s5">4</span><span class="s0">, </span><span class="s5">8</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;r&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;s&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0.5</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_smw_solver(self</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">q</span><span class="s0">, </span><span class="s1">r</span><span class="s0">, </span><span class="s1">s):</span>
        <span class="s1">check_smw_solver(p</span><span class="s0">, </span><span class="s1">q</span><span class="s0">, </span><span class="s1">r</span><span class="s0">, </span><span class="s1">s)</span>


<span class="s0">def </span><span class="s1">check_smw_logdet(p</span><span class="s0">, </span><span class="s1">q</span><span class="s0">, </span><span class="s1">r</span><span class="s0">, </span><span class="s1">s):</span>
    <span class="s2"># Helper to check that _smw_logdet results match non-optimized equivalent</span>
    <span class="s1">d = q - r</span>
    <span class="s1">A = np.random.normal(size=(p</span><span class="s0">, </span><span class="s1">q))</span>
    <span class="s1">AtA = np.dot(A.T</span><span class="s0">, </span><span class="s1">A)</span>

    <span class="s1">B = np.zeros((q</span><span class="s0">, </span><span class="s1">q))</span>
    <span class="s1">c = np.random.normal(size=(r</span><span class="s0">, </span><span class="s1">r))</span>
    <span class="s1">B[</span><span class="s5">0</span><span class="s1">:r</span><span class="s0">, </span><span class="s5">0</span><span class="s1">:r] = np.dot(c.T</span><span class="s0">, </span><span class="s1">c)</span>
    <span class="s1">di = np.random.uniform(size=d)</span>
    <span class="s1">B[r:q</span><span class="s0">, </span><span class="s1">r:q] = np.diag(</span><span class="s5">1 </span><span class="s1">/ di)</span>
    <span class="s1">Qi = np.linalg.inv(B[</span><span class="s5">0</span><span class="s1">:r</span><span class="s0">, </span><span class="s5">0</span><span class="s1">:r])</span>
    <span class="s1">s = </span><span class="s5">0.5</span>

    <span class="s1">_</span><span class="s0">, </span><span class="s1">d2 = np.linalg.slogdet(s * np.eye(p</span><span class="s0">, </span><span class="s1">p) + np.dot(A</span><span class="s0">, </span><span class="s1">np.dot(B</span><span class="s0">, </span><span class="s1">A.T)))</span>

    <span class="s1">_</span><span class="s0">, </span><span class="s1">bd = np.linalg.slogdet(B)</span>
    <span class="s1">d1 = _smw_logdet(s</span><span class="s0">, </span><span class="s1">A</span><span class="s0">, </span><span class="s1">AtA</span><span class="s0">, </span><span class="s1">Qi</span><span class="s0">, </span><span class="s1">di</span><span class="s0">, </span><span class="s1">bd)</span>
    <span class="s2"># GH 5642, OSX OpenBlas tolerance increase</span>
    <span class="s1">rtol = </span><span class="s5">1e-6 </span><span class="s0">if </span><span class="s1">PLATFORM_OSX </span><span class="s0">else </span><span class="s5">1e-7</span>
    <span class="s1">assert_allclose(d1</span><span class="s0">, </span><span class="s1">d2</span><span class="s0">, </span><span class="s1">rtol=rtol)</span>


<span class="s0">class </span><span class="s1">TestSMWLogdet:</span>
    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">setup_class(cls):</span>
        <span class="s1">np.random.seed(</span><span class="s5">23</span><span class="s1">)</span>

    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;p&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s5">5</span><span class="s0">, </span><span class="s5">10</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;q&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s5">4</span><span class="s0">, </span><span class="s5">8</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;r&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s5">2</span><span class="s0">, </span><span class="s5">3</span><span class="s1">])</span>
    <span class="s1">@pytest.mark.parametrize(</span><span class="s4">&quot;s&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s5">0</span><span class="s0">, </span><span class="s5">0.5</span><span class="s1">])</span>
    <span class="s0">def </span><span class="s1">test_smw_logdet(self</span><span class="s0">, </span><span class="s1">p</span><span class="s0">, </span><span class="s1">q</span><span class="s0">, </span><span class="s1">r</span><span class="s0">, </span><span class="s1">s):</span>
        <span class="s1">check_smw_logdet(p</span><span class="s0">, </span><span class="s1">q</span><span class="s0">, </span><span class="s1">r</span><span class="s0">, </span><span class="s1">s)</span>


<span class="s0">def </span><span class="s1">test_singular():</span>
    <span class="s2"># Issue #7051</span>

    <span class="s1">np.random.seed(</span><span class="s5">3423</span><span class="s1">)</span>
    <span class="s1">n = </span><span class="s5">100</span>

    <span class="s1">data = np.random.randn(n</span><span class="s0">, </span><span class="s5">2</span><span class="s1">)</span>
    <span class="s1">df = pd.DataFrame(data</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s4">'Y'</span><span class="s0">, </span><span class="s4">'X'</span><span class="s1">])</span>
    <span class="s1">df[</span><span class="s4">'class'</span><span class="s1">] = pd.Series([i % </span><span class="s5">3 </span><span class="s0">for </span><span class="s1">i </span><span class="s0">in </span><span class="s1">df.index]</span><span class="s0">, </span><span class="s1">index=df.index)</span>

    <span class="s0">with </span><span class="s1">pytest.warns(Warning) </span><span class="s0">as </span><span class="s1">wrn:</span>
        <span class="s1">md = MixedLM.from_formula(</span><span class="s4">&quot;Y ~ X&quot;</span><span class="s0">, </span><span class="s1">df</span><span class="s0">, </span><span class="s1">groups=df[</span><span class="s4">'class'</span><span class="s1">])</span>
        <span class="s1">mdf = md.fit()</span>
        <span class="s1">mdf.summary()</span>
        <span class="s0">if not </span><span class="s1">wrn:</span>
            <span class="s1">pytest.fail(</span><span class="s4">&quot;warning expected&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_get_distribution():</span>

    <span class="s1">np.random.seed(</span><span class="s5">234</span><span class="s1">)</span>

    <span class="s1">n = </span><span class="s5">100</span>
    <span class="s1">n_groups = </span><span class="s5">10</span>
    <span class="s1">fe_params = np.r_[</span><span class="s5">1</span><span class="s0">, </span><span class="s1">-</span><span class="s5">2</span><span class="s1">]</span>
    <span class="s1">cov_re = np.asarray([[</span><span class="s5">1</span><span class="s0">, </span><span class="s5">0.5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s5">0.5</span><span class="s0">, </span><span class="s5">2</span><span class="s1">]])</span>
    <span class="s1">vcomp = np.r_[</span><span class="s5">0.5</span><span class="s1">**</span><span class="s5">2</span><span class="s0">, </span><span class="s5">1.5</span><span class="s1">**</span><span class="s5">2</span><span class="s1">]</span>
    <span class="s1">scale = </span><span class="s5">1.5</span>

    <span class="s1">exog_fe = np.random.normal(size=(n</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span>
    <span class="s1">exog_re = np.random.normal(size=(n</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span>
    <span class="s1">exog_vca = np.random.normal(size=(n</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span>
    <span class="s1">exog_vcb = np.random.normal(size=(n</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span>

    <span class="s1">groups = np.repeat(np.arange(n_groups</span><span class="s0">, </span><span class="s1">dtype=int)</span><span class="s0">,</span>
                       <span class="s1">n / n_groups)</span>

    <span class="s1">ey = np.dot(exog_fe</span><span class="s0">, </span><span class="s1">fe_params)</span>

    <span class="s1">u = np.random.normal(size=(n_groups</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span>
    <span class="s1">u = np.dot(u</span><span class="s0">, </span><span class="s1">np.linalg.cholesky(cov_re).T)</span>

    <span class="s1">u1 = np.sqrt(vcomp[</span><span class="s5">0</span><span class="s1">]) * np.random.normal(size=(n_groups</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span>
    <span class="s1">u2 = np.sqrt(vcomp[</span><span class="s5">1</span><span class="s1">]) * np.random.normal(size=(n_groups</span><span class="s0">, </span><span class="s5">2</span><span class="s1">))</span>

    <span class="s1">y = ey + (u[groups</span><span class="s0">, </span><span class="s1">:] * exog_re).sum(</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">y += (u1[groups</span><span class="s0">, </span><span class="s1">:] * exog_vca).sum(</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">y += (u2[groups</span><span class="s0">, </span><span class="s1">:] * exog_vcb).sum(</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">y += np.sqrt(scale) * np.random.normal(size=n)</span>

    <span class="s1">df = pd.DataFrame({</span><span class="s4">&quot;y&quot;</span><span class="s1">: y</span><span class="s0">, </span><span class="s4">&quot;x1&quot;</span><span class="s1">: exog_fe[:</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s4">&quot;x2&quot;</span><span class="s1">: exog_fe[:</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span><span class="s0">,</span>
                       <span class="s4">&quot;z0&quot;</span><span class="s1">: exog_re[:</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]</span><span class="s0">, </span><span class="s4">&quot;z1&quot;</span><span class="s1">: exog_re[:</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span><span class="s0">,</span>
                       <span class="s4">&quot;grp&quot;</span><span class="s1">: groups})</span>
    <span class="s1">df[</span><span class="s4">&quot;z2&quot;</span><span class="s1">] = exog_vca[:</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">df[</span><span class="s4">&quot;z3&quot;</span><span class="s1">] = exog_vca[:</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">df[</span><span class="s4">&quot;z4&quot;</span><span class="s1">] = exog_vcb[:</span><span class="s0">, </span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">df[</span><span class="s4">&quot;z5&quot;</span><span class="s1">] = exog_vcb[:</span><span class="s0">, </span><span class="s5">1</span><span class="s1">]</span>

    <span class="s1">vcf = {</span><span class="s4">&quot;a&quot;</span><span class="s1">: </span><span class="s4">&quot;0 + z2 + z3&quot;</span><span class="s0">, </span><span class="s4">&quot;b&quot;</span><span class="s1">: </span><span class="s4">&quot;0 + z4 + z5&quot;</span><span class="s1">}</span>
    <span class="s1">m = MixedLM.from_formula(</span><span class="s4">&quot;y ~ 0 + x1 + x2&quot;</span><span class="s0">, </span><span class="s1">groups=</span><span class="s4">&quot;grp&quot;</span><span class="s0">,</span>
                             <span class="s1">re_formula=</span><span class="s4">&quot;0 + z0 + z1&quot;</span><span class="s0">,</span>
                             <span class="s1">vc_formula=vcf</span><span class="s0">, </span><span class="s1">data=df)</span>

    <span class="s2"># Build a params vector that is comparable to</span>
    <span class="s2"># MixedLMResults.params</span>
    <span class="s0">import </span><span class="s1">statsmodels</span>
    <span class="s1">mp = statsmodels.regression.mixed_linear_model.MixedLMParams</span>
    <span class="s1">po = mp.from_components(fe_params=fe_params</span><span class="s0">, </span><span class="s1">cov_re=cov_re</span><span class="s0">,</span>
                            <span class="s1">vcomp=vcomp)</span>
    <span class="s1">pa = po.get_packed(has_fe=</span><span class="s0">True, </span><span class="s1">use_sqrt=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s1">pa[len(fe_params):] /= scale</span>

    <span class="s2"># Get a realization</span>
    <span class="s1">dist = m.get_distribution(pa</span><span class="s0">, </span><span class="s1">scale</span><span class="s0">, None</span><span class="s1">)</span>
    <span class="s1">yr = dist.rvs(</span><span class="s5">0</span><span class="s1">)</span>

    <span class="s2"># Check the overall variance</span>
    <span class="s1">v = (np.dot(exog_re</span><span class="s0">, </span><span class="s1">cov_re) * exog_re).sum(</span><span class="s5">1</span><span class="s1">).mean()</span>
    <span class="s1">v += vcomp[</span><span class="s5">0</span><span class="s1">] * (exog_vca**</span><span class="s5">2</span><span class="s1">).sum(</span><span class="s5">1</span><span class="s1">).mean()</span>
    <span class="s1">v += vcomp[</span><span class="s5">1</span><span class="s1">] * (exog_vcb**</span><span class="s5">2</span><span class="s1">).sum(</span><span class="s5">1</span><span class="s1">).mean()</span>
    <span class="s1">v += scale</span>
    <span class="s1">assert_allclose(np.var(yr - ey)</span><span class="s0">, </span><span class="s1">v</span><span class="s0">, </span><span class="s1">rtol=</span><span class="s5">1e-2</span><span class="s0">, </span><span class="s1">atol=</span><span class="s5">1e-4</span><span class="s1">)</span>
</pre>
</body>
</html>