<html>
<head>
<title>_lil.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #cc7832;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_lil.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;List of Lists sparse matrix class 
&quot;&quot;&quot;</span>

<span class="s1">__docformat__ = </span><span class="s2">&quot;restructuredtext en&quot;</span>

<span class="s1">__all__ = [</span><span class="s2">'lil_array'</span><span class="s3">, </span><span class="s2">'lil_matrix'</span><span class="s3">, </span><span class="s2">'isspmatrix_lil'</span><span class="s1">]</span>

<span class="s3">from </span><span class="s1">bisect </span><span class="s3">import </span><span class="s1">bisect_left</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>

<span class="s3">from </span><span class="s1">._matrix </span><span class="s3">import </span><span class="s1">spmatrix</span><span class="s3">, </span><span class="s1">_array_doc_to_matrix</span>
<span class="s3">from </span><span class="s1">._base </span><span class="s3">import </span><span class="s1">_spbase</span><span class="s3">, </span><span class="s1">sparray</span><span class="s3">, </span><span class="s1">issparse</span>
<span class="s3">from </span><span class="s1">._index </span><span class="s3">import </span><span class="s1">IndexMixin</span><span class="s3">, </span><span class="s1">INT_TYPES</span><span class="s3">, </span><span class="s1">_broadcast_arrays</span>
<span class="s3">from </span><span class="s1">._sputils </span><span class="s3">import </span><span class="s1">(getdtype</span><span class="s3">, </span><span class="s1">isshape</span><span class="s3">, </span><span class="s1">isscalarlike</span><span class="s3">, </span><span class="s1">upcast_scalar</span><span class="s3">,</span>
                       <span class="s1">check_shape</span><span class="s3">, </span><span class="s1">check_reshape_kwargs)</span>
<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">_csparsetools</span>


<span class="s3">class </span><span class="s1">_lil_base(_spbase</span><span class="s3">, </span><span class="s1">IndexMixin):</span>
    <span class="s0">&quot;&quot;&quot;Row-based LIst of Lists sparse matrix 
 
    This is a structure for constructing sparse matrices incrementally. 
    Note that inserting a single item can take linear time in the worst case; 
    to construct a matrix efficiently, make sure the items are pre-sorted by 
    index, per row. 
 
    This can be instantiated in several ways: 
        lil_array(D) 
            with a dense matrix or rank-2 ndarray D 
 
        lil_array(S) 
            with another sparse matrix S (equivalent to S.tolil()) 
 
        lil_array((M, N), [dtype]) 
            to construct an empty matrix with shape (M, N) 
            dtype is optional, defaulting to dtype='d'. 
 
    Attributes 
    ---------- 
    dtype : dtype 
        Data type of the matrix 
    shape : 2-tuple 
        Shape of the matrix 
    ndim : int 
        Number of dimensions (this is always 2) 
    nnz 
        Number of stored values, including explicit zeros 
    data 
        LIL format data array of the matrix 
    rows 
        LIL format row index array of the matrix 
 
    Notes 
    ----- 
    Sparse matrices can be used in arithmetic operations: they support 
    addition, subtraction, multiplication, division, and matrix power. 
 
    Advantages of the LIL format 
        - supports flexible slicing 
        - changes to the matrix sparsity structure are efficient 
 
    Disadvantages of the LIL format 
        - arithmetic operations LIL + LIL are slow (consider CSR or CSC) 
        - slow column slicing (consider CSC) 
        - slow matrix vector products (consider CSR or CSC) 
 
    Intended Usage 
        - LIL is a convenient format for constructing sparse matrices 
        - once a matrix has been constructed, convert to CSR or 
          CSC format for fast arithmetic and matrix vector operations 
        - consider using the COO format when constructing large matrices 
 
    Data Structure 
        - An array (``self.rows``) of rows, each of which is a sorted 
          list of column indices of non-zero elements. 
        - The corresponding nonzero values are stored in similar 
          fashion in ``self.data``. 
 
 
    &quot;&quot;&quot;</span>
    <span class="s1">_format = </span><span class="s2">'lil'</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">arg1</span><span class="s3">, </span><span class="s1">shape=</span><span class="s3">None, </span><span class="s1">dtype=</span><span class="s3">None, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s1">_spbase.__init__(self)</span>
        <span class="s1">self.dtype = getdtype(dtype</span><span class="s3">, </span><span class="s1">arg1</span><span class="s3">, </span><span class="s1">default=float)</span>

        <span class="s4"># First get the shape</span>
        <span class="s3">if </span><span class="s1">issparse(arg1):</span>
            <span class="s3">if </span><span class="s1">arg1.format == </span><span class="s2">&quot;lil&quot; </span><span class="s3">and </span><span class="s1">copy:</span>
                <span class="s1">A = arg1.copy()</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">A = arg1.tolil()</span>

            <span class="s3">if </span><span class="s1">dtype </span><span class="s3">is not None</span><span class="s1">:</span>
                <span class="s1">A = A.astype(dtype</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">)</span>

            <span class="s1">self._shape = check_shape(A.shape)</span>
            <span class="s1">self.dtype = A.dtype</span>
            <span class="s1">self.rows = A.rows</span>
            <span class="s1">self.data = A.data</span>
        <span class="s3">elif </span><span class="s1">isinstance(arg1</span><span class="s3">,</span><span class="s1">tuple):</span>
            <span class="s3">if </span><span class="s1">isshape(arg1):</span>
                <span class="s3">if </span><span class="s1">shape </span><span class="s3">is not None</span><span class="s1">:</span>
                    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">'invalid use of shape parameter'</span><span class="s1">)</span>
                <span class="s1">M</span><span class="s3">, </span><span class="s1">N = arg1</span>
                <span class="s1">self._shape = check_shape((M</span><span class="s3">, </span><span class="s1">N))</span>
                <span class="s1">self.rows = np.empty((M</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">dtype=object)</span>
                <span class="s1">self.data = np.empty((M</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">dtype=object)</span>
                <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(M):</span>
                    <span class="s1">self.rows[i] = []</span>
                    <span class="s1">self.data[i] = []</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">'unrecognized lil_array constructor usage'</span><span class="s1">)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s4"># assume A is dense</span>
            <span class="s3">try</span><span class="s1">:</span>
                <span class="s1">A = self._ascontainer(arg1)</span>
            <span class="s3">except </span><span class="s1">TypeError </span><span class="s3">as </span><span class="s1">e:</span>
                <span class="s3">raise </span><span class="s1">TypeError(</span><span class="s2">'unsupported matrix type'</span><span class="s1">) </span><span class="s3">from </span><span class="s1">e</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">A = self._csr_container(A</span><span class="s3">, </span><span class="s1">dtype=dtype).tolil()</span>

                <span class="s1">self._shape = check_shape(A.shape)</span>
                <span class="s1">self.dtype = A.dtype</span>
                <span class="s1">self.rows = A.rows</span>
                <span class="s1">self.data = A.data</span>

    <span class="s3">def </span><span class="s1">__iadd__(self</span><span class="s3">,</span><span class="s1">other):</span>
        <span class="s1">self[:</span><span class="s3">,</span><span class="s1">:] = self + other</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">__isub__(self</span><span class="s3">,</span><span class="s1">other):</span>
        <span class="s1">self[:</span><span class="s3">,</span><span class="s1">:] = self - other</span>
        <span class="s3">return </span><span class="s1">self</span>

    <span class="s3">def </span><span class="s1">__imul__(self</span><span class="s3">,</span><span class="s1">other):</span>
        <span class="s3">if </span><span class="s1">isscalarlike(other):</span>
            <span class="s1">self[:</span><span class="s3">,</span><span class="s1">:] = self * other</span>
            <span class="s3">return </span><span class="s1">self</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">NotImplemented</span>

    <span class="s3">def </span><span class="s1">__itruediv__(self</span><span class="s3">,</span><span class="s1">other):</span>
        <span class="s3">if </span><span class="s1">isscalarlike(other):</span>
            <span class="s1">self[:</span><span class="s3">,</span><span class="s1">:] = self / other</span>
            <span class="s3">return </span><span class="s1">self</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">NotImplemented</span>

    <span class="s4"># Whenever the dimensions change, empty lists should be created for each</span>
    <span class="s4"># row</span>

    <span class="s3">def </span><span class="s1">_getnnz(self</span><span class="s3">, </span><span class="s1">axis=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">axis </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">sum([len(rowvals) </span><span class="s3">for </span><span class="s1">rowvals </span><span class="s3">in </span><span class="s1">self.data])</span>
        <span class="s3">if </span><span class="s1">axis &lt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">axis += </span><span class="s5">2</span>
        <span class="s3">if </span><span class="s1">axis == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">out = np.zeros(self.shape[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dtype=np.intp)</span>
            <span class="s3">for </span><span class="s1">row </span><span class="s3">in </span><span class="s1">self.rows:</span>
                <span class="s1">out[row] += </span><span class="s5">1</span>
            <span class="s3">return </span><span class="s1">out</span>
        <span class="s3">elif </span><span class="s1">axis == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">np.array([len(rowvals) </span><span class="s3">for </span><span class="s1">rowvals </span><span class="s3">in </span><span class="s1">self.data]</span><span class="s3">, </span><span class="s1">dtype=np.intp)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">'axis out of bounds'</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">count_nonzero(self):</span>
        <span class="s3">return </span><span class="s1">sum(np.count_nonzero(rowvals) </span><span class="s3">for </span><span class="s1">rowvals </span><span class="s3">in </span><span class="s1">self.data)</span>

    <span class="s1">_getnnz.__doc__ = _spbase._getnnz.__doc__</span>
    <span class="s1">count_nonzero.__doc__ = _spbase.count_nonzero.__doc__</span>

    <span class="s3">def </span><span class="s1">__str__(self):</span>
        <span class="s1">val = </span><span class="s2">''</span>
        <span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">row </span><span class="s3">in </span><span class="s1">enumerate(self.rows):</span>
            <span class="s3">for </span><span class="s1">pos</span><span class="s3">, </span><span class="s1">j </span><span class="s3">in </span><span class="s1">enumerate(row):</span>
                <span class="s1">val += </span><span class="s2">f&quot;  </span><span class="s3">{</span><span class="s1">str((i</span><span class="s3">, </span><span class="s1">j))</span><span class="s3">}\t{</span><span class="s1">str(self.data[i][pos])</span><span class="s3">}\n</span><span class="s2">&quot;</span>
        <span class="s3">return </span><span class="s1">val[:-</span><span class="s5">1</span><span class="s1">]</span>

    <span class="s3">def </span><span class="s1">getrowview(self</span><span class="s3">, </span><span class="s1">i):</span>
        <span class="s0">&quot;&quot;&quot;Returns a view of the 'i'th row (without copying). 
        &quot;&quot;&quot;</span>
        <span class="s1">new = self._lil_container((</span><span class="s5">1</span><span class="s3">, </span><span class="s1">self.shape[</span><span class="s5">1</span><span class="s1">])</span><span class="s3">, </span><span class="s1">dtype=self.dtype)</span>
        <span class="s1">new.rows[</span><span class="s5">0</span><span class="s1">] = self.rows[i]</span>
        <span class="s1">new.data[</span><span class="s5">0</span><span class="s1">] = self.data[i]</span>
        <span class="s3">return </span><span class="s1">new</span>

    <span class="s3">def </span><span class="s1">getrow(self</span><span class="s3">, </span><span class="s1">i):</span>
        <span class="s0">&quot;&quot;&quot;Returns a copy of the 'i'th row. 
        &quot;&quot;&quot;</span>
        <span class="s1">M</span><span class="s3">, </span><span class="s1">N = self.shape</span>
        <span class="s3">if </span><span class="s1">i &lt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">i += M</span>
        <span class="s3">if </span><span class="s1">i &lt; </span><span class="s5">0 </span><span class="s3">or </span><span class="s1">i &gt;= M:</span>
            <span class="s3">raise </span><span class="s1">IndexError(</span><span class="s2">'row index out of bounds'</span><span class="s1">)</span>
        <span class="s1">new = self._lil_container((</span><span class="s5">1</span><span class="s3">, </span><span class="s1">N)</span><span class="s3">, </span><span class="s1">dtype=self.dtype)</span>
        <span class="s1">new.rows[</span><span class="s5">0</span><span class="s1">] = self.rows[i][:]</span>
        <span class="s1">new.data[</span><span class="s5">0</span><span class="s1">] = self.data[i][:]</span>
        <span class="s3">return </span><span class="s1">new</span>

    <span class="s3">def </span><span class="s1">__getitem__(self</span><span class="s3">, </span><span class="s1">key):</span>
        <span class="s4"># Fast path for simple (int, int) indexing.</span>
        <span class="s3">if </span><span class="s1">(isinstance(key</span><span class="s3">, </span><span class="s1">tuple) </span><span class="s3">and </span><span class="s1">len(key) == </span><span class="s5">2 </span><span class="s3">and</span>
                <span class="s1">isinstance(key[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">INT_TYPES) </span><span class="s3">and</span>
                <span class="s1">isinstance(key[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">INT_TYPES)):</span>
            <span class="s4"># lil_get1 handles validation for us.</span>
            <span class="s3">return </span><span class="s1">self._get_intXint(*key)</span>
        <span class="s4"># Everything else takes the normal path.</span>
        <span class="s3">return </span><span class="s1">IndexMixin.__getitem__(self</span><span class="s3">, </span><span class="s1">key)</span>

    <span class="s3">def </span><span class="s1">_asindices(self</span><span class="s3">, </span><span class="s1">idx</span><span class="s3">, </span><span class="s1">N):</span>
        <span class="s4"># LIL routines handle bounds-checking for us, so don't do it here.</span>
        <span class="s3">try</span><span class="s1">:</span>
            <span class="s1">x = np.asarray(idx)</span>
        <span class="s3">except </span><span class="s1">(ValueError</span><span class="s3">, </span><span class="s1">TypeError</span><span class="s3">, </span><span class="s1">MemoryError) </span><span class="s3">as </span><span class="s1">e:</span>
            <span class="s3">raise </span><span class="s1">IndexError(</span><span class="s2">'invalid index'</span><span class="s1">) </span><span class="s3">from </span><span class="s1">e</span>
        <span class="s3">if </span><span class="s1">x.ndim </span><span class="s3">not in </span><span class="s1">(</span><span class="s5">1</span><span class="s3">, </span><span class="s5">2</span><span class="s1">):</span>
            <span class="s3">raise </span><span class="s1">IndexError(</span><span class="s2">'Index dimension must be &lt;= 2'</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">x</span>

    <span class="s3">def </span><span class="s1">_get_intXint(self</span><span class="s3">, </span><span class="s1">row</span><span class="s3">, </span><span class="s1">col):</span>
        <span class="s1">v = _csparsetools.lil_get1(self.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">self.shape[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">self.rows</span><span class="s3">,</span>
                                   <span class="s1">self.data</span><span class="s3">, </span><span class="s1">row</span><span class="s3">, </span><span class="s1">col)</span>
        <span class="s3">return </span><span class="s1">self.dtype.type(v)</span>

    <span class="s3">def </span><span class="s1">_get_sliceXint(self</span><span class="s3">, </span><span class="s1">row</span><span class="s3">, </span><span class="s1">col):</span>
        <span class="s1">row = range(*row.indices(self.shape[</span><span class="s5">0</span><span class="s1">]))</span>
        <span class="s3">return </span><span class="s1">self._get_row_ranges(row</span><span class="s3">, </span><span class="s1">slice(col</span><span class="s3">, </span><span class="s1">col+</span><span class="s5">1</span><span class="s1">))</span>

    <span class="s3">def </span><span class="s1">_get_arrayXint(self</span><span class="s3">, </span><span class="s1">row</span><span class="s3">, </span><span class="s1">col):</span>
        <span class="s1">row = row.squeeze()</span>
        <span class="s3">return </span><span class="s1">self._get_row_ranges(row</span><span class="s3">, </span><span class="s1">slice(col</span><span class="s3">, </span><span class="s1">col+</span><span class="s5">1</span><span class="s1">))</span>

    <span class="s3">def </span><span class="s1">_get_intXslice(self</span><span class="s3">, </span><span class="s1">row</span><span class="s3">, </span><span class="s1">col):</span>
        <span class="s3">return </span><span class="s1">self._get_row_ranges((row</span><span class="s3">,</span><span class="s1">)</span><span class="s3">, </span><span class="s1">col)</span>

    <span class="s3">def </span><span class="s1">_get_sliceXslice(self</span><span class="s3">, </span><span class="s1">row</span><span class="s3">, </span><span class="s1">col):</span>
        <span class="s1">row = range(*row.indices(self.shape[</span><span class="s5">0</span><span class="s1">]))</span>
        <span class="s3">return </span><span class="s1">self._get_row_ranges(row</span><span class="s3">, </span><span class="s1">col)</span>

    <span class="s3">def </span><span class="s1">_get_arrayXslice(self</span><span class="s3">, </span><span class="s1">row</span><span class="s3">, </span><span class="s1">col):</span>
        <span class="s3">return </span><span class="s1">self._get_row_ranges(row</span><span class="s3">, </span><span class="s1">col)</span>

    <span class="s3">def </span><span class="s1">_get_intXarray(self</span><span class="s3">, </span><span class="s1">row</span><span class="s3">, </span><span class="s1">col):</span>
        <span class="s1">row = np.array(row</span><span class="s3">, </span><span class="s1">dtype=col.dtype</span><span class="s3">, </span><span class="s1">ndmin=</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s3">return </span><span class="s1">self._get_columnXarray(row</span><span class="s3">, </span><span class="s1">col)</span>

    <span class="s3">def </span><span class="s1">_get_sliceXarray(self</span><span class="s3">, </span><span class="s1">row</span><span class="s3">, </span><span class="s1">col):</span>
        <span class="s1">row = np.arange(*row.indices(self.shape[</span><span class="s5">0</span><span class="s1">]))</span>
        <span class="s3">return </span><span class="s1">self._get_columnXarray(row</span><span class="s3">, </span><span class="s1">col)</span>

    <span class="s3">def </span><span class="s1">_get_columnXarray(self</span><span class="s3">, </span><span class="s1">row</span><span class="s3">, </span><span class="s1">col):</span>
        <span class="s4"># outer indexing</span>
        <span class="s1">row</span><span class="s3">, </span><span class="s1">col = _broadcast_arrays(row[:</span><span class="s3">,None</span><span class="s1">]</span><span class="s3">, </span><span class="s1">col)</span>
        <span class="s3">return </span><span class="s1">self._get_arrayXarray(row</span><span class="s3">, </span><span class="s1">col)</span>

    <span class="s3">def </span><span class="s1">_get_arrayXarray(self</span><span class="s3">, </span><span class="s1">row</span><span class="s3">, </span><span class="s1">col):</span>
        <span class="s4"># inner indexing</span>
        <span class="s1">i</span><span class="s3">, </span><span class="s1">j = map(np.atleast_2d</span><span class="s3">, </span><span class="s1">_prepare_index_for_memoryview(row</span><span class="s3">, </span><span class="s1">col))</span>
        <span class="s1">new = self._lil_container(i.shape</span><span class="s3">, </span><span class="s1">dtype=self.dtype)</span>
        <span class="s1">_csparsetools.lil_fancy_get(self.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">self.shape[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">,</span>
                                    <span class="s1">self.rows</span><span class="s3">, </span><span class="s1">self.data</span><span class="s3">,</span>
                                    <span class="s1">new.rows</span><span class="s3">, </span><span class="s1">new.data</span><span class="s3">,</span>
                                    <span class="s1">i</span><span class="s3">, </span><span class="s1">j)</span>
        <span class="s3">return </span><span class="s1">new</span>

    <span class="s3">def </span><span class="s1">_get_row_ranges(self</span><span class="s3">, </span><span class="s1">rows</span><span class="s3">, </span><span class="s1">col_slice):</span>
        <span class="s0">&quot;&quot;&quot; 
        Fast path for indexing in the case where column index is slice. 
 
        This gains performance improvement over brute force by more 
        efficient skipping of zeros, by accessing the elements 
        column-wise in order. 
 
        Parameters 
        ---------- 
        rows : sequence or range 
            Rows indexed. If range, must be within valid bounds. 
        col_slice : slice 
            Columns indexed 
 
        &quot;&quot;&quot;</span>
        <span class="s1">j_start</span><span class="s3">, </span><span class="s1">j_stop</span><span class="s3">, </span><span class="s1">j_stride = col_slice.indices(self.shape[</span><span class="s5">1</span><span class="s1">])</span>
        <span class="s1">col_range = range(j_start</span><span class="s3">, </span><span class="s1">j_stop</span><span class="s3">, </span><span class="s1">j_stride)</span>
        <span class="s1">nj = len(col_range)</span>
        <span class="s1">new = self._lil_container((len(rows)</span><span class="s3">, </span><span class="s1">nj)</span><span class="s3">, </span><span class="s1">dtype=self.dtype)</span>

        <span class="s1">_csparsetools.lil_get_row_ranges(self.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">self.shape[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">,</span>
                                         <span class="s1">self.rows</span><span class="s3">, </span><span class="s1">self.data</span><span class="s3">,</span>
                                         <span class="s1">new.rows</span><span class="s3">, </span><span class="s1">new.data</span><span class="s3">,</span>
                                         <span class="s1">rows</span><span class="s3">,</span>
                                         <span class="s1">j_start</span><span class="s3">, </span><span class="s1">j_stop</span><span class="s3">, </span><span class="s1">j_stride</span><span class="s3">, </span><span class="s1">nj)</span>

        <span class="s3">return </span><span class="s1">new</span>

    <span class="s3">def </span><span class="s1">_set_intXint(self</span><span class="s3">, </span><span class="s1">row</span><span class="s3">, </span><span class="s1">col</span><span class="s3">, </span><span class="s1">x):</span>
        <span class="s1">_csparsetools.lil_insert(self.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">self.shape[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">self.rows</span><span class="s3">,</span>
                                 <span class="s1">self.data</span><span class="s3">, </span><span class="s1">row</span><span class="s3">, </span><span class="s1">col</span><span class="s3">, </span><span class="s1">x)</span>

    <span class="s3">def </span><span class="s1">_set_arrayXarray(self</span><span class="s3">, </span><span class="s1">row</span><span class="s3">, </span><span class="s1">col</span><span class="s3">, </span><span class="s1">x):</span>
        <span class="s1">i</span><span class="s3">, </span><span class="s1">j</span><span class="s3">, </span><span class="s1">x = map(np.atleast_2d</span><span class="s3">, </span><span class="s1">_prepare_index_for_memoryview(row</span><span class="s3">, </span><span class="s1">col</span><span class="s3">, </span><span class="s1">x))</span>
        <span class="s1">_csparsetools.lil_fancy_set(self.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">self.shape[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">,</span>
                                    <span class="s1">self.rows</span><span class="s3">, </span><span class="s1">self.data</span><span class="s3">,</span>
                                    <span class="s1">i</span><span class="s3">, </span><span class="s1">j</span><span class="s3">, </span><span class="s1">x)</span>

    <span class="s3">def </span><span class="s1">_set_arrayXarray_sparse(self</span><span class="s3">, </span><span class="s1">row</span><span class="s3">, </span><span class="s1">col</span><span class="s3">, </span><span class="s1">x):</span>
        <span class="s4"># Fall back to densifying x</span>
        <span class="s1">x = np.asarray(x.toarray()</span><span class="s3">, </span><span class="s1">dtype=self.dtype)</span>
        <span class="s1">x</span><span class="s3">, </span><span class="s1">_ = _broadcast_arrays(x</span><span class="s3">, </span><span class="s1">row)</span>
        <span class="s1">self._set_arrayXarray(row</span><span class="s3">, </span><span class="s1">col</span><span class="s3">, </span><span class="s1">x)</span>

    <span class="s3">def </span><span class="s1">__setitem__(self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">x):</span>
        <span class="s3">if </span><span class="s1">isinstance(key</span><span class="s3">, </span><span class="s1">tuple) </span><span class="s3">and </span><span class="s1">len(key) == </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">row</span><span class="s3">, </span><span class="s1">col = key</span>
            <span class="s4"># Fast path for simple (int, int) indexing.</span>
            <span class="s3">if </span><span class="s1">isinstance(row</span><span class="s3">, </span><span class="s1">INT_TYPES) </span><span class="s3">and </span><span class="s1">isinstance(col</span><span class="s3">, </span><span class="s1">INT_TYPES):</span>
                <span class="s1">x = self.dtype.type(x)</span>
                <span class="s3">if </span><span class="s1">x.size &gt; </span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;Trying to assign a sequence to an item&quot;</span><span class="s1">)</span>
                <span class="s3">return </span><span class="s1">self._set_intXint(row</span><span class="s3">, </span><span class="s1">col</span><span class="s3">, </span><span class="s1">x)</span>
            <span class="s4"># Fast path for full-matrix sparse assignment.</span>
            <span class="s3">if </span><span class="s1">(isinstance(row</span><span class="s3">, </span><span class="s1">slice) </span><span class="s3">and </span><span class="s1">isinstance(col</span><span class="s3">, </span><span class="s1">slice) </span><span class="s3">and</span>
                    <span class="s1">row == slice(</span><span class="s3">None</span><span class="s1">) </span><span class="s3">and </span><span class="s1">col == slice(</span><span class="s3">None</span><span class="s1">) </span><span class="s3">and</span>
                    <span class="s1">issparse(x) </span><span class="s3">and </span><span class="s1">x.shape == self.shape):</span>
                <span class="s1">x = self._lil_container(x</span><span class="s3">, </span><span class="s1">dtype=self.dtype)</span>
                <span class="s1">self.rows = x.rows</span>
                <span class="s1">self.data = x.data</span>
                <span class="s3">return</span>
        <span class="s4"># Everything else takes the normal path.</span>
        <span class="s1">IndexMixin.__setitem__(self</span><span class="s3">, </span><span class="s1">key</span><span class="s3">, </span><span class="s1">x)</span>

    <span class="s3">def </span><span class="s1">_mul_scalar(self</span><span class="s3">, </span><span class="s1">other):</span>
        <span class="s3">if </span><span class="s1">other == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s4"># Multiply by zero: return the zero matrix</span>
            <span class="s1">new = self._lil_container(self.shape</span><span class="s3">, </span><span class="s1">dtype=self.dtype)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">res_dtype = upcast_scalar(self.dtype</span><span class="s3">, </span><span class="s1">other)</span>

            <span class="s1">new = self.copy()</span>
            <span class="s1">new = new.astype(res_dtype)</span>
            <span class="s4"># Multiply this scalar by every element.</span>
            <span class="s3">for </span><span class="s1">j</span><span class="s3">, </span><span class="s1">rowvals </span><span class="s3">in </span><span class="s1">enumerate(new.data):</span>
                <span class="s1">new.data[j] = [val*other </span><span class="s3">for </span><span class="s1">val </span><span class="s3">in </span><span class="s1">rowvals]</span>
        <span class="s3">return </span><span class="s1">new</span>

    <span class="s3">def </span><span class="s1">__truediv__(self</span><span class="s3">, </span><span class="s1">other):           </span><span class="s4"># self / other</span>
        <span class="s3">if </span><span class="s1">isscalarlike(other):</span>
            <span class="s1">new = self.copy()</span>
            <span class="s4"># Divide every element by this scalar</span>
            <span class="s3">for </span><span class="s1">j</span><span class="s3">, </span><span class="s1">rowvals </span><span class="s3">in </span><span class="s1">enumerate(new.data):</span>
                <span class="s1">new.data[j] = [val/other </span><span class="s3">for </span><span class="s1">val </span><span class="s3">in </span><span class="s1">rowvals]</span>
            <span class="s3">return </span><span class="s1">new</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self.tocsr() / other</span>

    <span class="s3">def </span><span class="s1">copy(self):</span>
        <span class="s1">M</span><span class="s3">, </span><span class="s1">N = self.shape</span>
        <span class="s1">new = self._lil_container(self.shape</span><span class="s3">, </span><span class="s1">dtype=self.dtype)</span>
        <span class="s4"># This is ~14x faster than calling deepcopy() on rows and data.</span>
        <span class="s1">_csparsetools.lil_get_row_ranges(M</span><span class="s3">, </span><span class="s1">N</span><span class="s3">, </span><span class="s1">self.rows</span><span class="s3">, </span><span class="s1">self.data</span><span class="s3">,</span>
                                         <span class="s1">new.rows</span><span class="s3">, </span><span class="s1">new.data</span><span class="s3">, </span><span class="s1">range(M)</span><span class="s3">,</span>
                                         <span class="s5">0</span><span class="s3">, </span><span class="s1">N</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s1">N)</span>
        <span class="s3">return </span><span class="s1">new</span>

    <span class="s1">copy.__doc__ = _spbase.copy.__doc__</span>

    <span class="s3">def </span><span class="s1">reshape(self</span><span class="s3">, </span><span class="s1">*args</span><span class="s3">, </span><span class="s1">**kwargs):</span>
        <span class="s1">shape = check_shape(args</span><span class="s3">, </span><span class="s1">self.shape)</span>
        <span class="s1">order</span><span class="s3">, </span><span class="s1">copy = check_reshape_kwargs(kwargs)</span>

        <span class="s4"># Return early if reshape is not required</span>
        <span class="s3">if </span><span class="s1">shape == self.shape:</span>
            <span class="s3">if </span><span class="s1">copy:</span>
                <span class="s3">return </span><span class="s1">self.copy()</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s3">return </span><span class="s1">self</span>

        <span class="s1">new = self._lil_container(shape</span><span class="s3">, </span><span class="s1">dtype=self.dtype)</span>

        <span class="s3">if </span><span class="s1">order == </span><span class="s2">'C'</span><span class="s1">:</span>
            <span class="s1">ncols = self.shape[</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">row </span><span class="s3">in </span><span class="s1">enumerate(self.rows):</span>
                <span class="s3">for </span><span class="s1">col</span><span class="s3">, </span><span class="s1">j </span><span class="s3">in </span><span class="s1">enumerate(row):</span>
                    <span class="s1">new_r</span><span class="s3">, </span><span class="s1">new_c = np.unravel_index(i * ncols + j</span><span class="s3">, </span><span class="s1">shape)</span>
                    <span class="s1">new[new_r</span><span class="s3">, </span><span class="s1">new_c] = self[i</span><span class="s3">, </span><span class="s1">j]</span>
        <span class="s3">elif </span><span class="s1">order == </span><span class="s2">'F'</span><span class="s1">:</span>
            <span class="s1">nrows = self.shape[</span><span class="s5">0</span><span class="s1">]</span>
            <span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">row </span><span class="s3">in </span><span class="s1">enumerate(self.rows):</span>
                <span class="s3">for </span><span class="s1">col</span><span class="s3">, </span><span class="s1">j </span><span class="s3">in </span><span class="s1">enumerate(row):</span>
                    <span class="s1">new_r</span><span class="s3">, </span><span class="s1">new_c = np.unravel_index(i + j * nrows</span><span class="s3">, </span><span class="s1">shape</span><span class="s3">, </span><span class="s1">order)</span>
                    <span class="s1">new[new_r</span><span class="s3">, </span><span class="s1">new_c] = self[i</span><span class="s3">, </span><span class="s1">j]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;'order' must be 'C' or 'F'&quot;</span><span class="s1">)</span>

        <span class="s3">return </span><span class="s1">new</span>

    <span class="s1">reshape.__doc__ = _spbase.reshape.__doc__</span>

    <span class="s3">def </span><span class="s1">resize(self</span><span class="s3">, </span><span class="s1">*shape):</span>
        <span class="s1">shape = check_shape(shape)</span>
        <span class="s1">new_M</span><span class="s3">, </span><span class="s1">new_N = shape</span>
        <span class="s1">M</span><span class="s3">, </span><span class="s1">N = self.shape</span>

        <span class="s3">if </span><span class="s1">new_M &lt; M:</span>
            <span class="s1">self.rows = self.rows[:new_M]</span>
            <span class="s1">self.data = self.data[:new_M]</span>
        <span class="s3">elif </span><span class="s1">new_M &gt; M:</span>
            <span class="s1">self.rows = np.resize(self.rows</span><span class="s3">, </span><span class="s1">new_M)</span>
            <span class="s1">self.data = np.resize(self.data</span><span class="s3">, </span><span class="s1">new_M)</span>
            <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(M</span><span class="s3">, </span><span class="s1">new_M):</span>
                <span class="s1">self.rows[i] = []</span>
                <span class="s1">self.data[i] = []</span>

        <span class="s3">if </span><span class="s1">new_N &lt; N:</span>
            <span class="s3">for </span><span class="s1">row</span><span class="s3">, </span><span class="s1">data </span><span class="s3">in </span><span class="s1">zip(self.rows</span><span class="s3">, </span><span class="s1">self.data):</span>
                <span class="s1">trunc = bisect_left(row</span><span class="s3">, </span><span class="s1">new_N)</span>
                <span class="s3">del </span><span class="s1">row[trunc:]</span>
                <span class="s3">del </span><span class="s1">data[trunc:]</span>

        <span class="s1">self._shape = shape</span>

    <span class="s1">resize.__doc__ = _spbase.resize.__doc__</span>

    <span class="s3">def </span><span class="s1">toarray(self</span><span class="s3">, </span><span class="s1">order=</span><span class="s3">None, </span><span class="s1">out=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">d = self._process_toarray_args(order</span><span class="s3">, </span><span class="s1">out)</span>
        <span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">row </span><span class="s3">in </span><span class="s1">enumerate(self.rows):</span>
            <span class="s3">for </span><span class="s1">pos</span><span class="s3">, </span><span class="s1">j </span><span class="s3">in </span><span class="s1">enumerate(row):</span>
                <span class="s1">d[i</span><span class="s3">, </span><span class="s1">j] = self.data[i][pos]</span>
        <span class="s3">return </span><span class="s1">d</span>

    <span class="s1">toarray.__doc__ = _spbase.toarray.__doc__</span>

    <span class="s3">def </span><span class="s1">transpose(self</span><span class="s3">, </span><span class="s1">axes=</span><span class="s3">None, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s3">return </span><span class="s1">self.tocsr(copy=copy).transpose(axes=axes</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">).tolil(copy=</span><span class="s3">False</span><span class="s1">)</span>

    <span class="s1">transpose.__doc__ = _spbase.transpose.__doc__</span>

    <span class="s3">def </span><span class="s1">tolil(self</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s3">if </span><span class="s1">copy:</span>
            <span class="s3">return </span><span class="s1">self.copy()</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self</span>

    <span class="s1">tolil.__doc__ = _spbase.tolil.__doc__</span>

    <span class="s3">def </span><span class="s1">tocsr(self</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False</span><span class="s1">):</span>
        <span class="s1">M</span><span class="s3">, </span><span class="s1">N = self.shape</span>
        <span class="s3">if </span><span class="s1">M == </span><span class="s5">0 </span><span class="s3">or </span><span class="s1">N == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">self._csr_container((M</span><span class="s3">, </span><span class="s1">N)</span><span class="s3">, </span><span class="s1">dtype=self.dtype)</span>

        <span class="s4"># construct indptr array</span>
        <span class="s3">if </span><span class="s1">M*N &lt;= np.iinfo(np.int32).max:</span>
            <span class="s4"># fast path: it is known that 64-bit indexing will not be needed.</span>
            <span class="s1">idx_dtype = np.int32</span>
            <span class="s1">indptr = np.empty(M + </span><span class="s5">1</span><span class="s3">, </span><span class="s1">dtype=idx_dtype)</span>
            <span class="s1">indptr[</span><span class="s5">0</span><span class="s1">] = </span><span class="s5">0</span>
            <span class="s1">_csparsetools.lil_get_lengths(self.rows</span><span class="s3">, </span><span class="s1">indptr[</span><span class="s5">1</span><span class="s1">:])</span>
            <span class="s1">np.cumsum(indptr</span><span class="s3">, </span><span class="s1">out=indptr)</span>
            <span class="s1">nnz = indptr[-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">idx_dtype = self._get_index_dtype(maxval=N)</span>
            <span class="s1">lengths = np.empty(M</span><span class="s3">, </span><span class="s1">dtype=idx_dtype)</span>
            <span class="s1">_csparsetools.lil_get_lengths(self.rows</span><span class="s3">, </span><span class="s1">lengths)</span>
            <span class="s1">nnz = lengths.sum(dtype=np.int64)</span>
            <span class="s1">idx_dtype = self._get_index_dtype(maxval=max(N</span><span class="s3">, </span><span class="s1">nnz))</span>
            <span class="s1">indptr = np.empty(M + </span><span class="s5">1</span><span class="s3">, </span><span class="s1">dtype=idx_dtype)</span>
            <span class="s1">indptr[</span><span class="s5">0</span><span class="s1">] = </span><span class="s5">0</span>
            <span class="s1">np.cumsum(lengths</span><span class="s3">, </span><span class="s1">dtype=idx_dtype</span><span class="s3">, </span><span class="s1">out=indptr[</span><span class="s5">1</span><span class="s1">:])</span>

        <span class="s1">indices = np.empty(nnz</span><span class="s3">, </span><span class="s1">dtype=idx_dtype)</span>
        <span class="s1">data = np.empty(nnz</span><span class="s3">, </span><span class="s1">dtype=self.dtype)</span>
        <span class="s1">_csparsetools.lil_flatten_to_array(self.rows</span><span class="s3">, </span><span class="s1">indices)</span>
        <span class="s1">_csparsetools.lil_flatten_to_array(self.data</span><span class="s3">, </span><span class="s1">data)</span>

        <span class="s4"># init csr matrix</span>
        <span class="s3">return </span><span class="s1">self._csr_container((data</span><span class="s3">, </span><span class="s1">indices</span><span class="s3">, </span><span class="s1">indptr)</span><span class="s3">, </span><span class="s1">shape=self.shape)</span>

    <span class="s1">tocsr.__doc__ = _spbase.tocsr.__doc__</span>


<span class="s3">def </span><span class="s1">_prepare_index_for_memoryview(i</span><span class="s3">, </span><span class="s1">j</span><span class="s3">, </span><span class="s1">x=</span><span class="s3">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; 
    Convert index and data arrays to form suitable for passing to the 
    Cython fancy getset routines. 
 
    The conversions are necessary since to (i) ensure the integer 
    index arrays are in one of the accepted types, and (ii) to ensure 
    the arrays are writable so that Cython memoryview support doesn't 
    choke on them. 
 
    Parameters 
    ---------- 
    i, j 
        Index arrays 
    x : optional 
        Data arrays 
 
    Returns 
    ------- 
    i, j, x 
        Re-formatted arrays (x is omitted, if input was None) 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">i.dtype &gt; j.dtype:</span>
        <span class="s1">j = j.astype(i.dtype)</span>
    <span class="s3">elif </span><span class="s1">i.dtype &lt; j.dtype:</span>
        <span class="s1">i = i.astype(j.dtype)</span>

    <span class="s3">if not </span><span class="s1">i.flags.writeable </span><span class="s3">or </span><span class="s1">i.dtype </span><span class="s3">not in </span><span class="s1">(np.int32</span><span class="s3">, </span><span class="s1">np.int64):</span>
        <span class="s1">i = i.astype(np.intp)</span>
    <span class="s3">if not </span><span class="s1">j.flags.writeable </span><span class="s3">or </span><span class="s1">j.dtype </span><span class="s3">not in </span><span class="s1">(np.int32</span><span class="s3">, </span><span class="s1">np.int64):</span>
        <span class="s1">j = j.astype(np.intp)</span>

    <span class="s3">if </span><span class="s1">x </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s3">if not </span><span class="s1">x.flags.writeable:</span>
            <span class="s1">x = x.copy()</span>
        <span class="s3">return </span><span class="s1">i</span><span class="s3">, </span><span class="s1">j</span><span class="s3">, </span><span class="s1">x</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">i</span><span class="s3">, </span><span class="s1">j</span>


<span class="s3">def </span><span class="s1">isspmatrix_lil(x):</span>
    <span class="s0">&quot;&quot;&quot;Is `x` of lil_matrix type? 
 
    Parameters 
    ---------- 
    x 
        object to check for being a lil matrix 
 
    Returns 
    ------- 
    bool 
        True if `x` is a lil matrix, False otherwise 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy.sparse import lil_array, lil_matrix, coo_matrix, isspmatrix_lil 
    &gt;&gt;&gt; isspmatrix_lil(lil_matrix([[5]])) 
    True 
    &gt;&gt;&gt; isspmatrix_lil(lil_array([[5]])) 
    False 
    &gt;&gt;&gt; isspmatrix_lil(coo_matrix([[5]])) 
    False 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">isinstance(x</span><span class="s3">, </span><span class="s1">lil_matrix)</span>


<span class="s4"># This namespace class separates array from matrix with isinstance</span>
<span class="s3">class </span><span class="s1">lil_array(_lil_base</span><span class="s3">, </span><span class="s1">sparray):</span>
    <span class="s3">pass</span>

<span class="s1">lil_array.__doc__ = _lil_base.__doc__</span>

<span class="s3">class </span><span class="s1">lil_matrix(spmatrix</span><span class="s3">, </span><span class="s1">_lil_base):</span>
    <span class="s3">pass</span>

<span class="s1">lil_matrix.__doc__ = _array_doc_to_matrix(_lil_base.__doc__)</span>
</pre>
</body>
</html>