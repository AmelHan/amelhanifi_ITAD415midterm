<html>
<head>
<title>_orthogonal.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_orthogonal.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
A collection of functions to find the weights and abscissas for 
Gaussian Quadrature. 
 
These calculations are done by finding the eigenvalues of a 
tridiagonal matrix whose entries are dependent on the coefficients 
in the recursion formula for the orthogonal polynomials with the 
corresponding weighting function over the interval. 
 
Many recursion relations for orthogonal polynomials are given: 
 
.. math:: 
 
    a1n f_{n+1} (x) = (a2n + a3n x ) f_n (x) - a4n f_{n-1} (x) 
 
The recursion relation of interest is 
 
.. math:: 
 
    P_{n+1} (x) = (x - A_n) P_n (x) - B_n P_{n-1} (x) 
 
where :math:`P` has a different normalization than :math:`f`. 
 
The coefficients can be found as: 
 
.. math:: 
 
    A_n = -a2n / a3n 
    \\qquad 
    B_n = ( a4n / a3n \\sqrt{h_n-1 / h_n})^2 
 
where 
 
.. math:: 
 
    h_n = \\int_a^b w(x) f_n(x)^2 
 
assume: 
 
.. math:: 
 
    P_0 (x) = 1 
    \\qquad 
    P_{-1} (x) == 0 
 
For the mathematical background, see [golub.welsch-1969-mathcomp]_ and 
[abramowitz.stegun-1965]_. 
 
References 
---------- 
.. [golub.welsch-1969-mathcomp] 
   Golub, Gene H, and John H Welsch. 1969. Calculation of Gauss 
   Quadrature Rules. *Mathematics of Computation* 23, 221-230+s1--s10. 
 
.. [abramowitz.stegun-1965] 
   Abramowitz, Milton, and Irene A Stegun. (1965) *Handbook of 
   Mathematical Functions: with Formulas, Graphs, and Mathematical 
   Tables*. Gaithersburg, MD: National Bureau of Standards. 
   http://www.math.sfu.ca/~cbm/aands/ 
 
.. [townsend.trogdon.olver-2014] 
   Townsend, A. and Trogdon, T. and Olver, S. (2014) 
   *Fast computation of Gauss quadrature nodes and 
   weights on the whole real line*. :arXiv:`1410.5286`. 
 
.. [townsend.trogdon.olver-2015] 
   Townsend, A. and Trogdon, T. and Olver, S. (2015) 
   *Fast computation of Gauss quadrature nodes and 
   weights on the whole real line*. 
   IMA Journal of Numerical Analysis 
   :doi:`10.1093/imanum/drv002`. 
&quot;&quot;&quot;</span>
<span class="s2">#</span>
<span class="s2"># Author:  Travis Oliphant 2000</span>
<span class="s2"># Updated Sep. 2003 (fixed bugs --- tested to be accurate)</span>

<span class="s2"># SciPy imports.</span>
<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">from </span><span class="s1">numpy </span><span class="s3">import </span><span class="s1">(exp</span><span class="s3">, </span><span class="s1">inf</span><span class="s3">, </span><span class="s1">pi</span><span class="s3">, </span><span class="s1">sqrt</span><span class="s3">, </span><span class="s1">floor</span><span class="s3">, </span><span class="s1">sin</span><span class="s3">, </span><span class="s1">cos</span><span class="s3">, </span><span class="s1">around</span><span class="s3">,</span>
                   <span class="s1">hstack</span><span class="s3">, </span><span class="s1">arccos</span><span class="s3">, </span><span class="s1">arange)</span>
<span class="s3">from </span><span class="s1">scipy </span><span class="s3">import </span><span class="s1">linalg</span>
<span class="s3">from </span><span class="s1">scipy.special </span><span class="s3">import </span><span class="s1">airy</span>

<span class="s2"># Local imports.</span>
<span class="s2"># There is no .pyi file for _specfun</span>
<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">_specfun  </span><span class="s2"># type: ignore</span>
<span class="s3">from </span><span class="s1">. </span><span class="s3">import </span><span class="s1">_ufuncs</span>
<span class="s1">_gam = _ufuncs.gamma</span>

<span class="s1">_polyfuns = [</span><span class="s4">'legendre'</span><span class="s3">, </span><span class="s4">'chebyt'</span><span class="s3">, </span><span class="s4">'chebyu'</span><span class="s3">, </span><span class="s4">'chebyc'</span><span class="s3">, </span><span class="s4">'chebys'</span><span class="s3">,</span>
             <span class="s4">'jacobi'</span><span class="s3">, </span><span class="s4">'laguerre'</span><span class="s3">, </span><span class="s4">'genlaguerre'</span><span class="s3">, </span><span class="s4">'hermite'</span><span class="s3">,</span>
             <span class="s4">'hermitenorm'</span><span class="s3">, </span><span class="s4">'gegenbauer'</span><span class="s3">, </span><span class="s4">'sh_legendre'</span><span class="s3">, </span><span class="s4">'sh_chebyt'</span><span class="s3">,</span>
             <span class="s4">'sh_chebyu'</span><span class="s3">, </span><span class="s4">'sh_jacobi'</span><span class="s1">]</span>

<span class="s2"># Correspondence between new and old names of root functions</span>
<span class="s1">_rootfuns_map = {</span><span class="s4">'roots_legendre'</span><span class="s1">: </span><span class="s4">'p_roots'</span><span class="s3">,</span>
                 <span class="s4">'roots_chebyt'</span><span class="s1">: </span><span class="s4">'t_roots'</span><span class="s3">,</span>
                 <span class="s4">'roots_chebyu'</span><span class="s1">: </span><span class="s4">'u_roots'</span><span class="s3">,</span>
                 <span class="s4">'roots_chebyc'</span><span class="s1">: </span><span class="s4">'c_roots'</span><span class="s3">,</span>
                 <span class="s4">'roots_chebys'</span><span class="s1">: </span><span class="s4">'s_roots'</span><span class="s3">,</span>
                 <span class="s4">'roots_jacobi'</span><span class="s1">: </span><span class="s4">'j_roots'</span><span class="s3">,</span>
                 <span class="s4">'roots_laguerre'</span><span class="s1">: </span><span class="s4">'l_roots'</span><span class="s3">,</span>
                 <span class="s4">'roots_genlaguerre'</span><span class="s1">: </span><span class="s4">'la_roots'</span><span class="s3">,</span>
                 <span class="s4">'roots_hermite'</span><span class="s1">: </span><span class="s4">'h_roots'</span><span class="s3">,</span>
                 <span class="s4">'roots_hermitenorm'</span><span class="s1">: </span><span class="s4">'he_roots'</span><span class="s3">,</span>
                 <span class="s4">'roots_gegenbauer'</span><span class="s1">: </span><span class="s4">'cg_roots'</span><span class="s3">,</span>
                 <span class="s4">'roots_sh_legendre'</span><span class="s1">: </span><span class="s4">'ps_roots'</span><span class="s3">,</span>
                 <span class="s4">'roots_sh_chebyt'</span><span class="s1">: </span><span class="s4">'ts_roots'</span><span class="s3">,</span>
                 <span class="s4">'roots_sh_chebyu'</span><span class="s1">: </span><span class="s4">'us_roots'</span><span class="s3">,</span>
                 <span class="s4">'roots_sh_jacobi'</span><span class="s1">: </span><span class="s4">'js_roots'</span><span class="s1">}</span>

<span class="s1">__all__ = _polyfuns + list(_rootfuns_map.keys())</span>


<span class="s3">class </span><span class="s1">orthopoly1d(np.poly1d):</span>

    <span class="s3">def </span><span class="s1">__init__(self</span><span class="s3">, </span><span class="s1">roots</span><span class="s3">, </span><span class="s1">weights=</span><span class="s3">None, </span><span class="s1">hn=</span><span class="s5">1.0</span><span class="s3">, </span><span class="s1">kn=</span><span class="s5">1.0</span><span class="s3">, </span><span class="s1">wfunc=</span><span class="s3">None,</span>
                 <span class="s1">limits=</span><span class="s3">None, </span><span class="s1">monic=</span><span class="s3">False, </span><span class="s1">eval_func=</span><span class="s3">None</span><span class="s1">):</span>
        <span class="s1">equiv_weights = [weights[k] / wfunc(roots[k]) </span><span class="s3">for</span>
                         <span class="s1">k </span><span class="s3">in </span><span class="s1">range(len(roots))]</span>
        <span class="s1">mu = sqrt(hn)</span>
        <span class="s3">if </span><span class="s1">monic:</span>
            <span class="s1">evf = eval_func</span>
            <span class="s3">if </span><span class="s1">evf:</span>
                <span class="s1">knn = kn</span>
                <span class="s3">def </span><span class="s1">eval_func(x):</span>
                    <span class="s3">return </span><span class="s1">evf(x) / knn</span>
            <span class="s1">mu = mu / abs(kn)</span>
            <span class="s1">kn = </span><span class="s5">1.0</span>

        <span class="s2"># compute coefficients from roots, then scale</span>
        <span class="s1">poly = np.poly1d(roots</span><span class="s3">, </span><span class="s1">r=</span><span class="s3">True</span><span class="s1">)</span>
        <span class="s1">np.poly1d.__init__(self</span><span class="s3">, </span><span class="s1">poly.coeffs * float(kn))</span>

        <span class="s1">self.weights = np.array(list(zip(roots</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">, </span><span class="s1">equiv_weights)))</span>
        <span class="s1">self.weight_func = wfunc</span>
        <span class="s1">self.limits = limits</span>
        <span class="s1">self.normcoef = mu</span>

        <span class="s2"># Note: eval_func will be discarded on arithmetic</span>
        <span class="s1">self._eval_func = eval_func</span>

    <span class="s3">def </span><span class="s1">__call__(self</span><span class="s3">, </span><span class="s1">v):</span>
        <span class="s3">if </span><span class="s1">self._eval_func </span><span class="s3">and not </span><span class="s1">isinstance(v</span><span class="s3">, </span><span class="s1">np.poly1d):</span>
            <span class="s3">return </span><span class="s1">self._eval_func(v)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">np.poly1d.__call__(self</span><span class="s3">, </span><span class="s1">v)</span>

    <span class="s3">def </span><span class="s1">_scale(self</span><span class="s3">, </span><span class="s1">p):</span>
        <span class="s3">if </span><span class="s1">p == </span><span class="s5">1.0</span><span class="s1">:</span>
            <span class="s3">return</span>
        <span class="s1">self._coeffs *= p</span>

        <span class="s1">evf = self._eval_func</span>
        <span class="s3">if </span><span class="s1">evf:</span>
            <span class="s1">self._eval_func = </span><span class="s3">lambda </span><span class="s1">x: evf(x) * p</span>
        <span class="s1">self.normcoef *= p</span>


<span class="s3">def </span><span class="s1">_gen_roots_and_weights(n</span><span class="s3">, </span><span class="s1">mu0</span><span class="s3">, </span><span class="s1">an_func</span><span class="s3">, </span><span class="s1">bn_func</span><span class="s3">, </span><span class="s1">f</span><span class="s3">, </span><span class="s1">df</span><span class="s3">, </span><span class="s1">symmetrize</span><span class="s3">, </span><span class="s1">mu):</span>
    <span class="s0">&quot;&quot;&quot;[x,w] = gen_roots_and_weights(n,an_func,sqrt_bn_func,mu) 
 
    Returns the roots (x) of an nth order orthogonal polynomial, 
    and weights (w) to use in appropriate Gaussian quadrature with that 
    orthogonal polynomial. 
 
    The polynomials have the recurrence relation 
          P_n+1(x) = (x - A_n) P_n(x) - B_n P_n-1(x) 
 
    an_func(n)          should return A_n 
    sqrt_bn_func(n)     should return sqrt(B_n) 
    mu ( = h_0 )        is the integral of the weight over the orthogonal 
                        interval 
    &quot;&quot;&quot;</span>
    <span class="s1">k = np.arange(n</span><span class="s3">, </span><span class="s1">dtype=</span><span class="s4">'d'</span><span class="s1">)</span>
    <span class="s1">c = np.zeros((</span><span class="s5">2</span><span class="s3">, </span><span class="s1">n))</span>
    <span class="s1">c[</span><span class="s5">0</span><span class="s3">,</span><span class="s5">1</span><span class="s1">:] = bn_func(k[</span><span class="s5">1</span><span class="s1">:])</span>
    <span class="s1">c[</span><span class="s5">1</span><span class="s3">,</span><span class="s1">:] = an_func(k)</span>
    <span class="s1">x = linalg.eigvals_banded(c</span><span class="s3">, </span><span class="s1">overwrite_a_band=</span><span class="s3">True</span><span class="s1">)</span>

    <span class="s2"># improve roots by one application of Newton's method</span>
    <span class="s1">y = f(n</span><span class="s3">, </span><span class="s1">x)</span>
    <span class="s1">dy = df(n</span><span class="s3">, </span><span class="s1">x)</span>
    <span class="s1">x -= y/dy</span>

    <span class="s2"># fm and dy may contain very large/small values, so we</span>
    <span class="s2"># log-normalize them to maintain precision in the product fm*dy</span>
    <span class="s1">fm = f(n-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">x)</span>
    <span class="s1">log_fm = np.log(np.abs(fm))</span>
    <span class="s1">log_dy = np.log(np.abs(dy))</span>
    <span class="s1">fm /= np.exp((log_fm.max() + log_fm.min()) / </span><span class="s5">2.</span><span class="s1">)</span>
    <span class="s1">dy /= np.exp((log_dy.max() + log_dy.min()) / </span><span class="s5">2.</span><span class="s1">)</span>
    <span class="s1">w = </span><span class="s5">1.0 </span><span class="s1">/ (fm * dy)</span>

    <span class="s3">if </span><span class="s1">symmetrize:</span>
        <span class="s1">w = (w + w[::-</span><span class="s5">1</span><span class="s1">]) / </span><span class="s5">2</span>
        <span class="s1">x = (x - x[::-</span><span class="s5">1</span><span class="s1">]) / </span><span class="s5">2</span>

    <span class="s1">w *= mu0 / w.sum()</span>

    <span class="s3">if </span><span class="s1">mu:</span>
        <span class="s3">return </span><span class="s1">x</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">mu0</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">x</span><span class="s3">, </span><span class="s1">w</span>

<span class="s2"># Jacobi Polynomials 1               P^(alpha,beta)_n(x)</span>


<span class="s3">def </span><span class="s1">roots_jacobi(n</span><span class="s3">, </span><span class="s1">alpha</span><span class="s3">, </span><span class="s1">beta</span><span class="s3">, </span><span class="s1">mu=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s0">r&quot;&quot;&quot;Gauss-Jacobi quadrature. 
 
    Compute the sample points and weights for Gauss-Jacobi 
    quadrature. The sample points are the roots of the nth degree 
    Jacobi polynomial, :math:`P^{\alpha, \beta}_n(x)`. These sample 
    points and weights correctly integrate polynomials of degree 
    :math:`2n - 1` or less over the interval :math:`[-1, 1]` with 
    weight function :math:`w(x) = (1 - x)^{\alpha} (1 + 
    x)^{\beta}`. See 22.2.1 in [AS]_ for details. 
 
    Parameters 
    ---------- 
    n : int 
        quadrature order 
    alpha : float 
        alpha must be &gt; -1 
    beta : float 
        beta must be &gt; -1 
    mu : bool, optional 
        If True, return the sum of the weights, optional. 
 
    Returns 
    ------- 
    x : ndarray 
        Sample points 
    w : ndarray 
        Weights 
    mu : float 
        Sum of the weights 
 
    See Also 
    -------- 
    scipy.integrate.quadrature 
    scipy.integrate.fixed_quad 
 
    References 
    ---------- 
    .. [AS] Milton Abramowitz and Irene A. Stegun, eds. 
        Handbook of Mathematical Functions with Formulas, 
        Graphs, and Mathematical Tables. New York: Dover, 1972. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">m = int(n)</span>
    <span class="s3">if </span><span class="s1">n &lt; </span><span class="s5">1 </span><span class="s3">or </span><span class="s1">n != m:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;n must be a positive integer.&quot;</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">alpha &lt;= -</span><span class="s5">1 </span><span class="s3">or </span><span class="s1">beta &lt;= -</span><span class="s5">1</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;alpha and beta must be greater than -1.&quot;</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">alpha == </span><span class="s5">0.0 </span><span class="s3">and </span><span class="s1">beta == </span><span class="s5">0.0</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">roots_legendre(m</span><span class="s3">, </span><span class="s1">mu)</span>
    <span class="s3">if </span><span class="s1">alpha == beta:</span>
        <span class="s3">return </span><span class="s1">roots_gegenbauer(m</span><span class="s3">, </span><span class="s1">alpha+</span><span class="s5">0.5</span><span class="s3">, </span><span class="s1">mu)</span>

    <span class="s3">if </span><span class="s1">(alpha + beta) &lt;= </span><span class="s5">1000</span><span class="s1">:</span>
        <span class="s1">mu0 = </span><span class="s5">2.0</span><span class="s1">**(alpha+beta+</span><span class="s5">1</span><span class="s1">) * _ufuncs.beta(alpha+</span><span class="s5">1</span><span class="s3">, </span><span class="s1">beta+</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s2"># Avoid overflows in pow and beta for very large parameters</span>
        <span class="s1">mu0 = np.exp((alpha + beta + </span><span class="s5">1</span><span class="s1">) * np.log(</span><span class="s5">2.0</span><span class="s1">)</span>
                     <span class="s1">+ _ufuncs.betaln(alpha+</span><span class="s5">1</span><span class="s3">, </span><span class="s1">beta+</span><span class="s5">1</span><span class="s1">))</span>
    <span class="s1">a = alpha</span>
    <span class="s1">b = beta</span>
    <span class="s3">if </span><span class="s1">a + b == </span><span class="s5">0.0</span><span class="s1">:</span>
        <span class="s3">def </span><span class="s1">an_func(k):</span>
            <span class="s3">return </span><span class="s1">np.where(k == </span><span class="s5">0</span><span class="s3">, </span><span class="s1">(b - a) / (</span><span class="s5">2 </span><span class="s1">+ a + b)</span><span class="s3">, </span><span class="s5">0.0</span><span class="s1">)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">def </span><span class="s1">an_func(k):</span>
            <span class="s3">return </span><span class="s1">np.where(k == </span><span class="s5">0</span><span class="s3">, </span><span class="s1">(b - a) / (</span><span class="s5">2 </span><span class="s1">+ a + b)</span><span class="s3">, </span><span class="s1">(b * b - a * a) / ((</span><span class="s5">2.0 </span><span class="s1">* k + a + b) * (</span><span class="s5">2.0 </span><span class="s1">* k + a + b + </span><span class="s5">2</span><span class="s1">)))</span>

    <span class="s3">def </span><span class="s1">bn_func(k):</span>
        <span class="s3">return </span><span class="s5">2.0 </span><span class="s1">/ (</span><span class="s5">2.0 </span><span class="s1">* k + a + b) * np.sqrt((k + a) * (k + b) / (</span><span class="s5">2 </span><span class="s1">* k + a + b + </span><span class="s5">1</span><span class="s1">)) * np.where(k == </span><span class="s5">1</span><span class="s3">, </span><span class="s5">1.0</span><span class="s3">, </span><span class="s1">np.sqrt(k * (k + a + b) / (</span><span class="s5">2.0 </span><span class="s1">* k + a + b - </span><span class="s5">1</span><span class="s1">)))</span>

    <span class="s3">def </span><span class="s1">f(n</span><span class="s3">, </span><span class="s1">x):</span>
        <span class="s3">return </span><span class="s1">_ufuncs.eval_jacobi(n</span><span class="s3">, </span><span class="s1">a</span><span class="s3">, </span><span class="s1">b</span><span class="s3">, </span><span class="s1">x)</span>
    <span class="s3">def </span><span class="s1">df(n</span><span class="s3">, </span><span class="s1">x):</span>
        <span class="s3">return </span><span class="s5">0.5 </span><span class="s1">* (n + a + b + </span><span class="s5">1</span><span class="s1">) * _ufuncs.eval_jacobi(n - </span><span class="s5">1</span><span class="s3">, </span><span class="s1">a + </span><span class="s5">1</span><span class="s3">, </span><span class="s1">b + </span><span class="s5">1</span><span class="s3">, </span><span class="s1">x)</span>
    <span class="s3">return </span><span class="s1">_gen_roots_and_weights(m</span><span class="s3">, </span><span class="s1">mu0</span><span class="s3">, </span><span class="s1">an_func</span><span class="s3">, </span><span class="s1">bn_func</span><span class="s3">, </span><span class="s1">f</span><span class="s3">, </span><span class="s1">df</span><span class="s3">, False, </span><span class="s1">mu)</span>


<span class="s3">def </span><span class="s1">jacobi(n</span><span class="s3">, </span><span class="s1">alpha</span><span class="s3">, </span><span class="s1">beta</span><span class="s3">, </span><span class="s1">monic=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s0">r&quot;&quot;&quot;Jacobi polynomial. 
 
    Defined to be the solution of 
 
    .. math:: 
        (1 - x^2)\frac{d^2}{dx^2}P_n^{(\alpha, \beta)} 
          + (\beta - \alpha - (\alpha + \beta + 2)x) 
            \frac{d}{dx}P_n^{(\alpha, \beta)} 
          + n(n + \alpha + \beta + 1)P_n^{(\alpha, \beta)} = 0 
 
    for :math:`\alpha, \beta &gt; -1`; :math:`P_n^{(\alpha, \beta)}` is a 
    polynomial of degree :math:`n`. 
 
    Parameters 
    ---------- 
    n : int 
        Degree of the polynomial. 
    alpha : float 
        Parameter, must be greater than -1. 
    beta : float 
        Parameter, must be greater than -1. 
    monic : bool, optional 
        If `True`, scale the leading coefficient to be 1. Default is 
        `False`. 
 
    Returns 
    ------- 
    P : orthopoly1d 
        Jacobi polynomial. 
 
    Notes 
    ----- 
    For fixed :math:`\alpha, \beta`, the polynomials 
    :math:`P_n^{(\alpha, \beta)}` are orthogonal over :math:`[-1, 1]` 
    with weight function :math:`(1 - x)^\alpha(1 + x)^\beta`. 
 
    References 
    ---------- 
    .. [AS] Milton Abramowitz and Irene A. Stegun, eds. 
        Handbook of Mathematical Functions with Formulas, 
        Graphs, and Mathematical Tables. New York: Dover, 1972. 
 
    Examples 
    -------- 
    The Jacobi polynomials satisfy the recurrence relation: 
 
    .. math:: 
        P_n^{(\alpha, \beta-1)}(x) - P_n^{(\alpha-1, \beta)}(x) 
          = P_{n-1}^{(\alpha, \beta)}(x) 
 
    This can be verified, for example, for :math:`\alpha = \beta = 2` 
    and :math:`n = 1` over the interval :math:`[-1, 1]`: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import jacobi 
    &gt;&gt;&gt; x = np.arange(-1.0, 1.0, 0.01) 
    &gt;&gt;&gt; np.allclose(jacobi(0, 2, 2)(x), 
    ...             jacobi(1, 2, 1)(x) - jacobi(1, 1, 2)(x)) 
    True 
 
    Plot of the Jacobi polynomial :math:`P_5^{(\alpha, -0.5)}` for 
    different values of :math:`\alpha`: 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; x = np.arange(-1.0, 1.0, 0.01) 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; ax.set_ylim(-2.0, 2.0) 
    &gt;&gt;&gt; ax.set_title(r'Jacobi polynomials $P_5^{(\alpha, -0.5)}$') 
    &gt;&gt;&gt; for alpha in np.arange(0, 4, 1): 
    ...     ax.plot(x, jacobi(5, alpha, -0.5)(x), label=rf'$\alpha={alpha}$') 
    &gt;&gt;&gt; plt.legend(loc='best') 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">n &lt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;n must be nonnegative.&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">wfunc(x):</span>
        <span class="s3">return </span><span class="s1">(</span><span class="s5">1 </span><span class="s1">- x) ** alpha * (</span><span class="s5">1 </span><span class="s1">+ x) ** beta</span>
    <span class="s3">if </span><span class="s1">n == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">orthopoly1d([]</span><span class="s3">, </span><span class="s1">[]</span><span class="s3">, </span><span class="s5">1.0</span><span class="s3">, </span><span class="s5">1.0</span><span class="s3">, </span><span class="s1">wfunc</span><span class="s3">, </span><span class="s1">(-</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">monic</span><span class="s3">,</span>
                           <span class="s1">eval_func=np.ones_like)</span>
    <span class="s1">x</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">mu = roots_jacobi(n</span><span class="s3">, </span><span class="s1">alpha</span><span class="s3">, </span><span class="s1">beta</span><span class="s3">, </span><span class="s1">mu=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s1">ab1 = alpha + beta + </span><span class="s5">1.0</span>
    <span class="s1">hn = </span><span class="s5">2</span><span class="s1">**ab1 / (</span><span class="s5">2 </span><span class="s1">* n + ab1) * _gam(n + alpha + </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">hn *= _gam(n + beta + </span><span class="s5">1.0</span><span class="s1">) / _gam(n + </span><span class="s5">1</span><span class="s1">) / _gam(n + ab1)</span>
    <span class="s1">kn = _gam(</span><span class="s5">2 </span><span class="s1">* n + ab1) / </span><span class="s5">2.0</span><span class="s1">**n / _gam(n + </span><span class="s5">1</span><span class="s1">) / _gam(n + ab1)</span>
    <span class="s2"># here kn = coefficient on x^n term</span>
    <span class="s1">p = orthopoly1d(x</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">hn</span><span class="s3">, </span><span class="s1">kn</span><span class="s3">, </span><span class="s1">wfunc</span><span class="s3">, </span><span class="s1">(-</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">monic</span><span class="s3">,</span>
                    <span class="s3">lambda </span><span class="s1">x: _ufuncs.eval_jacobi(n</span><span class="s3">, </span><span class="s1">alpha</span><span class="s3">, </span><span class="s1">beta</span><span class="s3">, </span><span class="s1">x))</span>
    <span class="s3">return </span><span class="s1">p</span>

<span class="s2"># Jacobi Polynomials shifted         G_n(p,q,x)</span>


<span class="s3">def </span><span class="s1">roots_sh_jacobi(n</span><span class="s3">, </span><span class="s1">p1</span><span class="s3">, </span><span class="s1">q1</span><span class="s3">, </span><span class="s1">mu=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Gauss-Jacobi (shifted) quadrature. 
 
    Compute the sample points and weights for Gauss-Jacobi (shifted) 
    quadrature. The sample points are the roots of the nth degree 
    shifted Jacobi polynomial, :math:`G^{p,q}_n(x)`. These sample 
    points and weights correctly integrate polynomials of degree 
    :math:`2n - 1` or less over the interval :math:`[0, 1]` with 
    weight function :math:`w(x) = (1 - x)^{p-q} x^{q-1}`. See 22.2.2 
    in [AS]_ for details. 
 
    Parameters 
    ---------- 
    n : int 
        quadrature order 
    p1 : float 
        (p1 - q1) must be &gt; -1 
    q1 : float 
        q1 must be &gt; 0 
    mu : bool, optional 
        If True, return the sum of the weights, optional. 
 
    Returns 
    ------- 
    x : ndarray 
        Sample points 
    w : ndarray 
        Weights 
    mu : float 
        Sum of the weights 
 
    See Also 
    -------- 
    scipy.integrate.quadrature 
    scipy.integrate.fixed_quad 
 
    References 
    ---------- 
    .. [AS] Milton Abramowitz and Irene A. Stegun, eds. 
        Handbook of Mathematical Functions with Formulas, 
        Graphs, and Mathematical Tables. New York: Dover, 1972. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">(p1-q1) &lt;= -</span><span class="s5">1 </span><span class="s3">or </span><span class="s1">q1 &lt;= </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;(p - q) must be greater than -1, and q must be greater than 0.&quot;</span><span class="s1">)</span>
    <span class="s1">x</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">m = roots_jacobi(n</span><span class="s3">, </span><span class="s1">p1-q1</span><span class="s3">, </span><span class="s1">q1-</span><span class="s5">1</span><span class="s3">, True</span><span class="s1">)</span>
    <span class="s1">x = (x + </span><span class="s5">1</span><span class="s1">) / </span><span class="s5">2</span>
    <span class="s1">scale = </span><span class="s5">2.0</span><span class="s1">**p1</span>
    <span class="s1">w /= scale</span>
    <span class="s1">m /= scale</span>
    <span class="s3">if </span><span class="s1">mu:</span>
        <span class="s3">return </span><span class="s1">x</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">m</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">x</span><span class="s3">, </span><span class="s1">w</span>


<span class="s3">def </span><span class="s1">sh_jacobi(n</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">q</span><span class="s3">, </span><span class="s1">monic=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s0">r&quot;&quot;&quot;Shifted Jacobi polynomial. 
 
    Defined by 
 
    .. math:: 
 
        G_n^{(p, q)}(x) 
          = \binom{2n + p - 1}{n}^{-1}P_n^{(p - q, q - 1)}(2x - 1), 
 
    where :math:`P_n^{(\cdot, \cdot)}` is the nth Jacobi polynomial. 
 
    Parameters 
    ---------- 
    n : int 
        Degree of the polynomial. 
    p : float 
        Parameter, must have :math:`p &gt; q - 1`. 
    q : float 
        Parameter, must be greater than 0. 
    monic : bool, optional 
        If `True`, scale the leading coefficient to be 1. Default is 
        `False`. 
 
    Returns 
    ------- 
    G : orthopoly1d 
        Shifted Jacobi polynomial. 
 
    Notes 
    ----- 
    For fixed :math:`p, q`, the polynomials :math:`G_n^{(p, q)}` are 
    orthogonal over :math:`[0, 1]` with weight function :math:`(1 - 
    x)^{p - q}x^{q - 1}`. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">n &lt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;n must be nonnegative.&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">wfunc(x):</span>
        <span class="s3">return </span><span class="s1">(</span><span class="s5">1.0 </span><span class="s1">- x) ** (p - q) * x ** (q - </span><span class="s5">1.0</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">n == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">orthopoly1d([]</span><span class="s3">, </span><span class="s1">[]</span><span class="s3">, </span><span class="s5">1.0</span><span class="s3">, </span><span class="s5">1.0</span><span class="s3">, </span><span class="s1">wfunc</span><span class="s3">, </span><span class="s1">(-</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">monic</span><span class="s3">,</span>
                           <span class="s1">eval_func=np.ones_like)</span>
    <span class="s1">n1 = n</span>
    <span class="s1">x</span><span class="s3">, </span><span class="s1">w = roots_sh_jacobi(n1</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">q)</span>
    <span class="s1">hn = _gam(n + </span><span class="s5">1</span><span class="s1">) * _gam(n + q) * _gam(n + p) * _gam(n + p - q + </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">hn /= (</span><span class="s5">2 </span><span class="s1">* n + p) * (_gam(</span><span class="s5">2 </span><span class="s1">* n + p)**</span><span class="s5">2</span><span class="s1">)</span>
    <span class="s2"># kn = 1.0 in standard form so monic is redundant. Kept for compatibility.</span>
    <span class="s1">kn = </span><span class="s5">1.0</span>
    <span class="s1">pp = orthopoly1d(x</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">hn</span><span class="s3">, </span><span class="s1">kn</span><span class="s3">, </span><span class="s1">wfunc=wfunc</span><span class="s3">, </span><span class="s1">limits=(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">monic=monic</span><span class="s3">,</span>
                     <span class="s1">eval_func=</span><span class="s3">lambda </span><span class="s1">x: _ufuncs.eval_sh_jacobi(n</span><span class="s3">, </span><span class="s1">p</span><span class="s3">, </span><span class="s1">q</span><span class="s3">, </span><span class="s1">x))</span>
    <span class="s3">return </span><span class="s1">pp</span>

<span class="s2"># Generalized Laguerre               L^(alpha)_n(x)</span>


<span class="s3">def </span><span class="s1">roots_genlaguerre(n</span><span class="s3">, </span><span class="s1">alpha</span><span class="s3">, </span><span class="s1">mu=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s0">r&quot;&quot;&quot;Gauss-generalized Laguerre quadrature. 
 
    Compute the sample points and weights for Gauss-generalized 
    Laguerre quadrature. The sample points are the roots of the nth 
    degree generalized Laguerre polynomial, :math:`L^{\alpha}_n(x)`. 
    These sample points and weights correctly integrate polynomials of 
    degree :math:`2n - 1` or less over the interval :math:`[0, 
    \infty]` with weight function :math:`w(x) = x^{\alpha} 
    e^{-x}`. See 22.3.9 in [AS]_ for details. 
 
    Parameters 
    ---------- 
    n : int 
        quadrature order 
    alpha : float 
        alpha must be &gt; -1 
    mu : bool, optional 
        If True, return the sum of the weights, optional. 
 
    Returns 
    ------- 
    x : ndarray 
        Sample points 
    w : ndarray 
        Weights 
    mu : float 
        Sum of the weights 
 
    See Also 
    -------- 
    scipy.integrate.quadrature 
    scipy.integrate.fixed_quad 
 
    References 
    ---------- 
    .. [AS] Milton Abramowitz and Irene A. Stegun, eds. 
        Handbook of Mathematical Functions with Formulas, 
        Graphs, and Mathematical Tables. New York: Dover, 1972. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">m = int(n)</span>
    <span class="s3">if </span><span class="s1">n &lt; </span><span class="s5">1 </span><span class="s3">or </span><span class="s1">n != m:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;n must be a positive integer.&quot;</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">alpha &lt; -</span><span class="s5">1</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;alpha must be greater than -1.&quot;</span><span class="s1">)</span>

    <span class="s1">mu0 = _ufuncs.gamma(alpha + </span><span class="s5">1</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">m == </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">x = np.array([alpha+</span><span class="s5">1.0</span><span class="s1">]</span><span class="s3">, </span><span class="s4">'d'</span><span class="s1">)</span>
        <span class="s1">w = np.array([mu0]</span><span class="s3">, </span><span class="s4">'d'</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">mu:</span>
            <span class="s3">return </span><span class="s1">x</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">mu0</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">x</span><span class="s3">, </span><span class="s1">w</span>

    <span class="s3">def </span><span class="s1">an_func(k):</span>
        <span class="s3">return </span><span class="s5">2 </span><span class="s1">* k + alpha + </span><span class="s5">1</span>
    <span class="s3">def </span><span class="s1">bn_func(k):</span>
        <span class="s3">return </span><span class="s1">-np.sqrt(k * (k + alpha))</span>
    <span class="s3">def </span><span class="s1">f(n</span><span class="s3">, </span><span class="s1">x):</span>
        <span class="s3">return </span><span class="s1">_ufuncs.eval_genlaguerre(n</span><span class="s3">, </span><span class="s1">alpha</span><span class="s3">, </span><span class="s1">x)</span>
    <span class="s3">def </span><span class="s1">df(n</span><span class="s3">, </span><span class="s1">x):</span>
        <span class="s3">return </span><span class="s1">(n * _ufuncs.eval_genlaguerre(n</span><span class="s3">, </span><span class="s1">alpha</span><span class="s3">, </span><span class="s1">x) - (n + alpha) * _ufuncs.eval_genlaguerre(n - </span><span class="s5">1</span><span class="s3">, </span><span class="s1">alpha</span><span class="s3">, </span><span class="s1">x)) / x</span>
    <span class="s3">return </span><span class="s1">_gen_roots_and_weights(m</span><span class="s3">, </span><span class="s1">mu0</span><span class="s3">, </span><span class="s1">an_func</span><span class="s3">, </span><span class="s1">bn_func</span><span class="s3">, </span><span class="s1">f</span><span class="s3">, </span><span class="s1">df</span><span class="s3">, False, </span><span class="s1">mu)</span>


<span class="s3">def </span><span class="s1">genlaguerre(n</span><span class="s3">, </span><span class="s1">alpha</span><span class="s3">, </span><span class="s1">monic=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s0">r&quot;&quot;&quot;Generalized (associated) Laguerre polynomial. 
 
    Defined to be the solution of 
 
    .. math:: 
        x\frac{d^2}{dx^2}L_n^{(\alpha)} 
          + (\alpha + 1 - x)\frac{d}{dx}L_n^{(\alpha)} 
          + nL_n^{(\alpha)} = 0, 
 
    where :math:`\alpha &gt; -1`; :math:`L_n^{(\alpha)}` is a polynomial 
    of degree :math:`n`. 
 
    Parameters 
    ---------- 
    n : int 
        Degree of the polynomial. 
    alpha : float 
        Parameter, must be greater than -1. 
    monic : bool, optional 
        If `True`, scale the leading coefficient to be 1. Default is 
        `False`. 
 
    Returns 
    ------- 
    L : orthopoly1d 
        Generalized Laguerre polynomial. 
 
    Notes 
    ----- 
    For fixed :math:`\alpha`, the polynomials :math:`L_n^{(\alpha)}` 
    are orthogonal over :math:`[0, \infty)` with weight function 
    :math:`e^{-x}x^\alpha`. 
 
    The Laguerre polynomials are the special case where :math:`\alpha 
    = 0`. 
 
    See Also 
    -------- 
    laguerre : Laguerre polynomial. 
    hyp1f1 : confluent hypergeometric function 
 
    References 
    ---------- 
    .. [AS] Milton Abramowitz and Irene A. Stegun, eds. 
        Handbook of Mathematical Functions with Formulas, 
        Graphs, and Mathematical Tables. New York: Dover, 1972. 
 
    Examples 
    -------- 
    The generalized Laguerre polynomials are closely related to the confluent 
    hypergeometric function :math:`{}_1F_1`: 
 
        .. math:: 
            L_n^{(\alpha)} = \binom{n + \alpha}{n} {}_1F_1(-n, \alpha +1, x) 
 
    This can be verified, for example,  for :math:`n = \alpha = 3` over the 
    interval :math:`[-1, 1]`: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import binom 
    &gt;&gt;&gt; from scipy.special import genlaguerre 
    &gt;&gt;&gt; from scipy.special import hyp1f1 
    &gt;&gt;&gt; x = np.arange(-1.0, 1.0, 0.01) 
    &gt;&gt;&gt; np.allclose(genlaguerre(3, 3)(x), binom(6, 3) * hyp1f1(-3, 4, x)) 
    True 
 
    This is the plot of the generalized Laguerre polynomials 
    :math:`L_3^{(\alpha)}` for some values of :math:`\alpha`: 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; x = np.arange(-4.0, 12.0, 0.01) 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; ax.set_ylim(-5.0, 10.0) 
    &gt;&gt;&gt; ax.set_title(r'Generalized Laguerre polynomials $L_3^{\alpha}$') 
    &gt;&gt;&gt; for alpha in np.arange(0, 5): 
    ...     ax.plot(x, genlaguerre(3, alpha)(x), label=rf'$L_3^{(alpha)}$') 
    &gt;&gt;&gt; plt.legend(loc='best') 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">alpha &lt;= -</span><span class="s5">1</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;alpha must be &gt; -1&quot;</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">n &lt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;n must be nonnegative.&quot;</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">n == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">n1 = n + </span><span class="s5">1</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">n1 = n</span>
    <span class="s1">x</span><span class="s3">, </span><span class="s1">w = roots_genlaguerre(n1</span><span class="s3">, </span><span class="s1">alpha)</span>
    <span class="s3">def </span><span class="s1">wfunc(x):</span>
        <span class="s3">return </span><span class="s1">exp(-x) * x ** alpha</span>
    <span class="s3">if </span><span class="s1">n == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">x</span><span class="s3">, </span><span class="s1">w = []</span><span class="s3">, </span><span class="s1">[]</span>
    <span class="s1">hn = _gam(n + alpha + </span><span class="s5">1</span><span class="s1">) / _gam(n + </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">kn = (-</span><span class="s5">1</span><span class="s1">)**n / _gam(n + </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">p = orthopoly1d(x</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">hn</span><span class="s3">, </span><span class="s1">kn</span><span class="s3">, </span><span class="s1">wfunc</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">inf)</span><span class="s3">, </span><span class="s1">monic</span><span class="s3">,</span>
                    <span class="s3">lambda </span><span class="s1">x: _ufuncs.eval_genlaguerre(n</span><span class="s3">, </span><span class="s1">alpha</span><span class="s3">, </span><span class="s1">x))</span>
    <span class="s3">return </span><span class="s1">p</span>

<span class="s2"># Laguerre                      L_n(x)</span>


<span class="s3">def </span><span class="s1">roots_laguerre(n</span><span class="s3">, </span><span class="s1">mu=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s0">r&quot;&quot;&quot;Gauss-Laguerre quadrature. 
 
    Compute the sample points and weights for Gauss-Laguerre 
    quadrature. The sample points are the roots of the nth degree 
    Laguerre polynomial, :math:`L_n(x)`. These sample points and 
    weights correctly integrate polynomials of degree :math:`2n - 1` 
    or less over the interval :math:`[0, \infty]` with weight function 
    :math:`w(x) = e^{-x}`. See 22.2.13 in [AS]_ for details. 
 
    Parameters 
    ---------- 
    n : int 
        quadrature order 
    mu : bool, optional 
        If True, return the sum of the weights, optional. 
 
    Returns 
    ------- 
    x : ndarray 
        Sample points 
    w : ndarray 
        Weights 
    mu : float 
        Sum of the weights 
 
    See Also 
    -------- 
    scipy.integrate.quadrature 
    scipy.integrate.fixed_quad 
    numpy.polynomial.laguerre.laggauss 
 
    References 
    ---------- 
    .. [AS] Milton Abramowitz and Irene A. Stegun, eds. 
        Handbook of Mathematical Functions with Formulas, 
        Graphs, and Mathematical Tables. New York: Dover, 1972. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">roots_genlaguerre(n</span><span class="s3">, </span><span class="s5">0.0</span><span class="s3">, </span><span class="s1">mu=mu)</span>


<span class="s3">def </span><span class="s1">laguerre(n</span><span class="s3">, </span><span class="s1">monic=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s0">r&quot;&quot;&quot;Laguerre polynomial. 
 
    Defined to be the solution of 
 
    .. math:: 
        x\frac{d^2}{dx^2}L_n + (1 - x)\frac{d}{dx}L_n + nL_n = 0; 
 
    :math:`L_n` is a polynomial of degree :math:`n`. 
 
    Parameters 
    ---------- 
    n : int 
        Degree of the polynomial. 
    monic : bool, optional 
        If `True`, scale the leading coefficient to be 1. Default is 
        `False`. 
 
    Returns 
    ------- 
    L : orthopoly1d 
        Laguerre Polynomial. 
 
    Notes 
    ----- 
    The polynomials :math:`L_n` are orthogonal over :math:`[0, 
    \infty)` with weight function :math:`e^{-x}`. 
 
    See Also 
    -------- 
    genlaguerre : Generalized (associated) Laguerre polynomial. 
 
    References 
    ---------- 
    .. [AS] Milton Abramowitz and Irene A. Stegun, eds. 
        Handbook of Mathematical Functions with Formulas, 
        Graphs, and Mathematical Tables. New York: Dover, 1972. 
 
    Examples 
    -------- 
    The Laguerre polynomials :math:`L_n` are the special case 
    :math:`\alpha = 0` of the generalized Laguerre polynomials 
    :math:`L_n^{(\alpha)}`. 
    Let's verify it on the interval :math:`[-1, 1]`: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import genlaguerre 
    &gt;&gt;&gt; from scipy.special import laguerre 
    &gt;&gt;&gt; x = np.arange(-1.0, 1.0, 0.01) 
    &gt;&gt;&gt; np.allclose(genlaguerre(3, 0)(x), laguerre(3)(x)) 
    True 
 
    The polynomials :math:`L_n` also satisfy the recurrence relation: 
 
    .. math:: 
        (n + 1)L_{n+1}(x) = (2n +1 -x)L_n(x) - nL_{n-1}(x) 
 
    This can be easily checked on :math:`[0, 1]` for :math:`n = 3`: 
 
    &gt;&gt;&gt; x = np.arange(0.0, 1.0, 0.01) 
    &gt;&gt;&gt; np.allclose(4 * laguerre(4)(x), 
    ...             (7 - x) * laguerre(3)(x) - 3 * laguerre(2)(x)) 
    True 
 
    This is the plot of the first few Laguerre polynomials :math:`L_n`: 
 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; x = np.arange(-1.0, 5.0, 0.01) 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; ax.set_ylim(-5.0, 5.0) 
    &gt;&gt;&gt; ax.set_title(r'Laguerre polynomials $L_n$') 
    &gt;&gt;&gt; for n in np.arange(0, 5): 
    ...     ax.plot(x, laguerre(n)(x), label=rf'$L_{n}$') 
    &gt;&gt;&gt; plt.legend(loc='best') 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">n &lt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;n must be nonnegative.&quot;</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">n == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">n1 = n + </span><span class="s5">1</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">n1 = n</span>
    <span class="s1">x</span><span class="s3">, </span><span class="s1">w = roots_laguerre(n1)</span>
    <span class="s3">if </span><span class="s1">n == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">x</span><span class="s3">, </span><span class="s1">w = []</span><span class="s3">, </span><span class="s1">[]</span>
    <span class="s1">hn = </span><span class="s5">1.0</span>
    <span class="s1">kn = (-</span><span class="s5">1</span><span class="s1">)**n / _gam(n + </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">p = orthopoly1d(x</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">hn</span><span class="s3">, </span><span class="s1">kn</span><span class="s3">, lambda </span><span class="s1">x: exp(-x)</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">, </span><span class="s1">inf)</span><span class="s3">, </span><span class="s1">monic</span><span class="s3">,</span>
                    <span class="s3">lambda </span><span class="s1">x: _ufuncs.eval_laguerre(n</span><span class="s3">, </span><span class="s1">x))</span>
    <span class="s3">return </span><span class="s1">p</span>

<span class="s2"># Hermite  1                         H_n(x)</span>


<span class="s3">def </span><span class="s1">roots_hermite(n</span><span class="s3">, </span><span class="s1">mu=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s0">r&quot;&quot;&quot;Gauss-Hermite (physicist's) quadrature. 
 
    Compute the sample points and weights for Gauss-Hermite 
    quadrature. The sample points are the roots of the nth degree 
    Hermite polynomial, :math:`H_n(x)`. These sample points and 
    weights correctly integrate polynomials of degree :math:`2n - 1` 
    or less over the interval :math:`[-\infty, \infty]` with weight 
    function :math:`w(x) = e^{-x^2}`. See 22.2.14 in [AS]_ for 
    details. 
 
    Parameters 
    ---------- 
    n : int 
        quadrature order 
    mu : bool, optional 
        If True, return the sum of the weights, optional. 
 
    Returns 
    ------- 
    x : ndarray 
        Sample points 
    w : ndarray 
        Weights 
    mu : float 
        Sum of the weights 
 
    Notes 
    ----- 
    For small n up to 150 a modified version of the Golub-Welsch 
    algorithm is used. Nodes are computed from the eigenvalue 
    problem and improved by one step of a Newton iteration. 
    The weights are computed from the well-known analytical formula. 
 
    For n larger than 150 an optimal asymptotic algorithm is applied 
    which computes nodes and weights in a numerically stable manner. 
    The algorithm has linear runtime making computation for very 
    large n (several thousand or more) feasible. 
 
    See Also 
    -------- 
    scipy.integrate.quadrature 
    scipy.integrate.fixed_quad 
    numpy.polynomial.hermite.hermgauss 
    roots_hermitenorm 
 
    References 
    ---------- 
    .. [townsend.trogdon.olver-2014] 
        Townsend, A. and Trogdon, T. and Olver, S. (2014) 
        *Fast computation of Gauss quadrature nodes and 
        weights on the whole real line*. :arXiv:`1410.5286`. 
    .. [townsend.trogdon.olver-2015] 
        Townsend, A. and Trogdon, T. and Olver, S. (2015) 
        *Fast computation of Gauss quadrature nodes and 
        weights on the whole real line*. 
        IMA Journal of Numerical Analysis 
        :doi:`10.1093/imanum/drv002`. 
    .. [AS] Milton Abramowitz and Irene A. Stegun, eds. 
        Handbook of Mathematical Functions with Formulas, 
        Graphs, and Mathematical Tables. New York: Dover, 1972. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">m = int(n)</span>
    <span class="s3">if </span><span class="s1">n &lt; </span><span class="s5">1 </span><span class="s3">or </span><span class="s1">n != m:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;n must be a positive integer.&quot;</span><span class="s1">)</span>

    <span class="s1">mu0 = np.sqrt(np.pi)</span>
    <span class="s3">if </span><span class="s1">n &lt;= </span><span class="s5">150</span><span class="s1">:</span>
        <span class="s3">def </span><span class="s1">an_func(k):</span>
            <span class="s3">return </span><span class="s5">0.0 </span><span class="s1">* k</span>
        <span class="s3">def </span><span class="s1">bn_func(k):</span>
            <span class="s3">return </span><span class="s1">np.sqrt(k / </span><span class="s5">2.0</span><span class="s1">)</span>
        <span class="s1">f = _ufuncs.eval_hermite</span>
        <span class="s3">def </span><span class="s1">df(n</span><span class="s3">, </span><span class="s1">x):</span>
            <span class="s3">return </span><span class="s5">2.0 </span><span class="s1">* n * _ufuncs.eval_hermite(n - </span><span class="s5">1</span><span class="s3">, </span><span class="s1">x)</span>
        <span class="s3">return </span><span class="s1">_gen_roots_and_weights(m</span><span class="s3">, </span><span class="s1">mu0</span><span class="s3">, </span><span class="s1">an_func</span><span class="s3">, </span><span class="s1">bn_func</span><span class="s3">, </span><span class="s1">f</span><span class="s3">, </span><span class="s1">df</span><span class="s3">, True, </span><span class="s1">mu)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">nodes</span><span class="s3">, </span><span class="s1">weights = _roots_hermite_asy(m)</span>
        <span class="s3">if </span><span class="s1">mu:</span>
            <span class="s3">return </span><span class="s1">nodes</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">, </span><span class="s1">mu0</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">nodes</span><span class="s3">, </span><span class="s1">weights</span>


<span class="s3">def </span><span class="s1">_compute_tauk(n</span><span class="s3">, </span><span class="s1">k</span><span class="s3">, </span><span class="s1">maxit=</span><span class="s5">5</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Helper function for Tricomi initial guesses 
 
    For details, see formula 3.1 in lemma 3.1 in the 
    original paper. 
 
    Parameters 
    ---------- 
    n : int 
        Quadrature order 
    k : ndarray of type int 
        Index of roots :math:`\tau_k` to compute 
    maxit : int 
        Number of Newton maxit performed, the default 
        value of 5 is sufficient. 
 
    Returns 
    ------- 
    tauk : ndarray 
        Roots of equation 3.1 
 
    See Also 
    -------- 
    initial_nodes_a 
    roots_hermite_asy 
    &quot;&quot;&quot;</span>
    <span class="s1">a = n % </span><span class="s5">2 </span><span class="s1">- </span><span class="s5">0.5</span>
    <span class="s1">c = (</span><span class="s5">4.0</span><span class="s1">*floor(n/</span><span class="s5">2.0</span><span class="s1">) - </span><span class="s5">4.0</span><span class="s1">*k + </span><span class="s5">3.0</span><span class="s1">)*pi / (</span><span class="s5">4.0</span><span class="s1">*floor(n/</span><span class="s5">2.0</span><span class="s1">) + </span><span class="s5">2.0</span><span class="s1">*a + </span><span class="s5">2.0</span><span class="s1">)</span>
    <span class="s3">def </span><span class="s1">f(x):</span>
        <span class="s3">return </span><span class="s1">x - sin(x) - c</span>
    <span class="s3">def </span><span class="s1">df(x):</span>
        <span class="s3">return </span><span class="s5">1.0 </span><span class="s1">- cos(x)</span>
    <span class="s1">xi = </span><span class="s5">0.5</span><span class="s1">*pi</span>
    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(maxit):</span>
        <span class="s1">xi = xi - f(xi)/df(xi)</span>
    <span class="s3">return </span><span class="s1">xi</span>


<span class="s3">def </span><span class="s1">_initial_nodes_a(n</span><span class="s3">, </span><span class="s1">k):</span>
    <span class="s0">r&quot;&quot;&quot;Tricomi initial guesses 
 
    Computes an initial approximation to the square of the `k`-th 
    (positive) root :math:`x_k` of the Hermite polynomial :math:`H_n` 
    of order :math:`n`. The formula is the one from lemma 3.1 in the 
    original paper. The guesses are accurate except in the region 
    near :math:`\sqrt{2n + 1}`. 
 
    Parameters 
    ---------- 
    n : int 
        Quadrature order 
    k : ndarray of type int 
        Index of roots to compute 
 
    Returns 
    ------- 
    xksq : ndarray 
        Square of the approximate roots 
 
    See Also 
    -------- 
    initial_nodes 
    roots_hermite_asy 
    &quot;&quot;&quot;</span>
    <span class="s1">tauk = _compute_tauk(n</span><span class="s3">, </span><span class="s1">k)</span>
    <span class="s1">sigk = cos(</span><span class="s5">0.5</span><span class="s1">*tauk)**</span><span class="s5">2</span>
    <span class="s1">a = n % </span><span class="s5">2 </span><span class="s1">- </span><span class="s5">0.5</span>
    <span class="s1">nu = </span><span class="s5">4.0</span><span class="s1">*floor(n/</span><span class="s5">2.0</span><span class="s1">) + </span><span class="s5">2.0</span><span class="s1">*a + </span><span class="s5">2.0</span>
    <span class="s2"># Initial approximation of Hermite roots (square)</span>
    <span class="s1">xksq = nu*sigk - </span><span class="s5">1.0</span><span class="s1">/(</span><span class="s5">3.0</span><span class="s1">*nu) * (</span><span class="s5">5.0</span><span class="s1">/(</span><span class="s5">4.0</span><span class="s1">*(</span><span class="s5">1.0</span><span class="s1">-sigk)**</span><span class="s5">2</span><span class="s1">) - </span><span class="s5">1.0</span><span class="s1">/(</span><span class="s5">1.0</span><span class="s1">-sigk) - </span><span class="s5">0.25</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">xksq</span>


<span class="s3">def </span><span class="s1">_initial_nodes_b(n</span><span class="s3">, </span><span class="s1">k):</span>
    <span class="s0">r&quot;&quot;&quot;Gatteschi initial guesses 
 
    Computes an initial approximation to the square of the kth 
    (positive) root :math:`x_k` of the Hermite polynomial :math:`H_n` 
    of order :math:`n`. The formula is the one from lemma 3.2 in the 
    original paper. The guesses are accurate in the region just 
    below :math:`\sqrt{2n + 1}`. 
 
    Parameters 
    ---------- 
    n : int 
        Quadrature order 
    k : ndarray of type int 
        Index of roots to compute 
 
    Returns 
    ------- 
    xksq : ndarray 
        Square of the approximate root 
 
    See Also 
    -------- 
    initial_nodes 
    roots_hermite_asy 
    &quot;&quot;&quot;</span>
    <span class="s1">a = n % </span><span class="s5">2 </span><span class="s1">- </span><span class="s5">0.5</span>
    <span class="s1">nu = </span><span class="s5">4.0</span><span class="s1">*floor(n/</span><span class="s5">2.0</span><span class="s1">) + </span><span class="s5">2.0</span><span class="s1">*a + </span><span class="s5">2.0</span>
    <span class="s2"># Airy roots by approximation</span>
    <span class="s1">ak = _specfun.airyzo(k.max()</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">][::-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s2"># Initial approximation of Hermite roots (square)</span>
    <span class="s1">xksq = (nu +</span>
            <span class="s5">2.0</span><span class="s1">**(</span><span class="s5">2.0</span><span class="s1">/</span><span class="s5">3.0</span><span class="s1">) * ak * nu**(</span><span class="s5">1.0</span><span class="s1">/</span><span class="s5">3.0</span><span class="s1">) +</span>
            <span class="s5">1.0</span><span class="s1">/</span><span class="s5">5.0 </span><span class="s1">* </span><span class="s5">2.0</span><span class="s1">**(</span><span class="s5">4.0</span><span class="s1">/</span><span class="s5">3.0</span><span class="s1">) * ak**</span><span class="s5">2 </span><span class="s1">* nu**(-</span><span class="s5">1.0</span><span class="s1">/</span><span class="s5">3.0</span><span class="s1">) +</span>
            <span class="s1">(</span><span class="s5">9.0</span><span class="s1">/</span><span class="s5">140.0 </span><span class="s1">- </span><span class="s5">12.0</span><span class="s1">/</span><span class="s5">175.0 </span><span class="s1">* ak**</span><span class="s5">3</span><span class="s1">) * nu**(-</span><span class="s5">1.0</span><span class="s1">) +</span>
            <span class="s1">(</span><span class="s5">16.0</span><span class="s1">/</span><span class="s5">1575.0 </span><span class="s1">* ak + </span><span class="s5">92.0</span><span class="s1">/</span><span class="s5">7875.0 </span><span class="s1">* ak**</span><span class="s5">4</span><span class="s1">) * </span><span class="s5">2.0</span><span class="s1">**(</span><span class="s5">2.0</span><span class="s1">/</span><span class="s5">3.0</span><span class="s1">) * nu**(-</span><span class="s5">5.0</span><span class="s1">/</span><span class="s5">3.0</span><span class="s1">) -</span>
            <span class="s1">(</span><span class="s5">15152.0</span><span class="s1">/</span><span class="s5">3031875.0 </span><span class="s1">* ak**</span><span class="s5">5 </span><span class="s1">+ </span><span class="s5">1088.0</span><span class="s1">/</span><span class="s5">121275.0 </span><span class="s1">* ak**</span><span class="s5">2</span><span class="s1">) * </span><span class="s5">2.0</span><span class="s1">**(</span><span class="s5">1.0</span><span class="s1">/</span><span class="s5">3.0</span><span class="s1">) * nu**(-</span><span class="s5">7.0</span><span class="s1">/</span><span class="s5">3.0</span><span class="s1">))</span>
    <span class="s3">return </span><span class="s1">xksq</span>


<span class="s3">def </span><span class="s1">_initial_nodes(n):</span>
    <span class="s0">&quot;&quot;&quot;Initial guesses for the Hermite roots 
 
    Computes an initial approximation to the non-negative 
    roots :math:`x_k` of the Hermite polynomial :math:`H_n` 
    of order :math:`n`. The Tricomi and Gatteschi initial 
    guesses are used in the region where they are accurate. 
 
    Parameters 
    ---------- 
    n : int 
        Quadrature order 
 
    Returns 
    ------- 
    xk : ndarray 
        Approximate roots 
 
    See Also 
    -------- 
    roots_hermite_asy 
    &quot;&quot;&quot;</span>
    <span class="s2"># Turnover point</span>
    <span class="s2"># linear polynomial fit to error of 10, 25, 40, ..., 1000 point rules</span>
    <span class="s1">fit = </span><span class="s5">0.49082003</span><span class="s1">*n - </span><span class="s5">4.37859653</span>
    <span class="s1">turnover = around(fit).astype(int)</span>
    <span class="s2"># Compute all approximations</span>
    <span class="s1">ia = arange(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">int(floor(n*</span><span class="s5">0.5</span><span class="s1">)+</span><span class="s5">1</span><span class="s1">))</span>
    <span class="s1">ib = ia[::-</span><span class="s5">1</span><span class="s1">]</span>
    <span class="s1">xasq = _initial_nodes_a(n</span><span class="s3">, </span><span class="s1">ia[:turnover+</span><span class="s5">1</span><span class="s1">])</span>
    <span class="s1">xbsq = _initial_nodes_b(n</span><span class="s3">, </span><span class="s1">ib[turnover+</span><span class="s5">1</span><span class="s1">:])</span>
    <span class="s2"># Combine</span>
    <span class="s1">iv = sqrt(hstack([xasq</span><span class="s3">, </span><span class="s1">xbsq]))</span>
    <span class="s2"># Central node is always zero</span>
    <span class="s3">if </span><span class="s1">n % </span><span class="s5">2 </span><span class="s1">== </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">iv = hstack([</span><span class="s5">0.0</span><span class="s3">, </span><span class="s1">iv])</span>
    <span class="s3">return </span><span class="s1">iv</span>


<span class="s3">def </span><span class="s1">_pbcf(n</span><span class="s3">, </span><span class="s1">theta):</span>
    <span class="s0">r&quot;&quot;&quot;Asymptotic series expansion of parabolic cylinder function 
 
    The implementation is based on sections 3.2 and 3.3 from the 
    original paper. Compared to the published version this code 
    adds one more term to the asymptotic series. The detailed 
    formulas can be found at [parabolic-asymptotics]_. The evaluation 
    is done in a transformed variable :math:`\theta := \arccos(t)` 
    where :math:`t := x / \mu` and :math:`\mu := \sqrt{2n + 1}`. 
 
    Parameters 
    ---------- 
    n : int 
        Quadrature order 
    theta : ndarray 
        Transformed position variable 
 
    Returns 
    ------- 
    U : ndarray 
        Value of the parabolic cylinder function :math:`U(a, \theta)`. 
    Ud : ndarray 
        Value of the derivative :math:`U^{\prime}(a, \theta)` of 
        the parabolic cylinder function. 
 
    See Also 
    -------- 
    roots_hermite_asy 
 
    References 
    ---------- 
    .. [parabolic-asymptotics] 
       https://dlmf.nist.gov/12.10#vii 
    &quot;&quot;&quot;</span>
    <span class="s1">st = sin(theta)</span>
    <span class="s1">ct = cos(theta)</span>
    <span class="s2"># https://dlmf.nist.gov/12.10#vii</span>
    <span class="s1">mu = </span><span class="s5">2.0</span><span class="s1">*n + </span><span class="s5">1.0</span>
    <span class="s2"># https://dlmf.nist.gov/12.10#E23</span>
    <span class="s1">eta = </span><span class="s5">0.5</span><span class="s1">*theta - </span><span class="s5">0.5</span><span class="s1">*st*ct</span>
    <span class="s2"># https://dlmf.nist.gov/12.10#E39</span>
    <span class="s1">zeta = -(</span><span class="s5">3.0</span><span class="s1">*eta/</span><span class="s5">2.0</span><span class="s1">) ** (</span><span class="s5">2.0</span><span class="s1">/</span><span class="s5">3.0</span><span class="s1">)</span>
    <span class="s2"># https://dlmf.nist.gov/12.10#E40</span>
    <span class="s1">phi = (-zeta / st**</span><span class="s5">2</span><span class="s1">) ** (</span><span class="s5">0.25</span><span class="s1">)</span>
    <span class="s2"># Coefficients</span>
    <span class="s2"># https://dlmf.nist.gov/12.10#E43</span>
    <span class="s1">a0 = </span><span class="s5">1.0</span>
    <span class="s1">a1 = </span><span class="s5">0.10416666666666666667</span>
    <span class="s1">a2 = </span><span class="s5">0.08355034722222222222</span>
    <span class="s1">a3 = </span><span class="s5">0.12822657455632716049</span>
    <span class="s1">a4 = </span><span class="s5">0.29184902646414046425</span>
    <span class="s1">a5 = </span><span class="s5">0.88162726744375765242</span>
    <span class="s1">b0 = </span><span class="s5">1.0</span>
    <span class="s1">b1 = -</span><span class="s5">0.14583333333333333333</span>
    <span class="s1">b2 = -</span><span class="s5">0.09874131944444444444</span>
    <span class="s1">b3 = -</span><span class="s5">0.14331205391589506173</span>
    <span class="s1">b4 = -</span><span class="s5">0.31722720267841354810</span>
    <span class="s1">b5 = -</span><span class="s5">0.94242914795712024914</span>
    <span class="s2"># Polynomials</span>
    <span class="s2"># https://dlmf.nist.gov/12.10#E9</span>
    <span class="s2"># https://dlmf.nist.gov/12.10#E10</span>
    <span class="s1">ctp = ct ** arange(</span><span class="s5">16</span><span class="s1">).reshape((-</span><span class="s5">1</span><span class="s3">,</span><span class="s5">1</span><span class="s1">))</span>
    <span class="s1">u0 = </span><span class="s5">1.0</span>
    <span class="s1">u1 = (</span><span class="s5">1.0</span><span class="s1">*ctp[</span><span class="s5">3</span><span class="s3">,</span><span class="s1">:] - </span><span class="s5">6.0</span><span class="s1">*ct) / </span><span class="s5">24.0</span>
    <span class="s1">u2 = (-</span><span class="s5">9.0</span><span class="s1">*ctp[</span><span class="s5">4</span><span class="s3">,</span><span class="s1">:] + </span><span class="s5">249.0</span><span class="s1">*ctp[</span><span class="s5">2</span><span class="s3">,</span><span class="s1">:] + </span><span class="s5">145.0</span><span class="s1">) / </span><span class="s5">1152.0</span>
    <span class="s1">u3 = (-</span><span class="s5">4042.0</span><span class="s1">*ctp[</span><span class="s5">9</span><span class="s3">,</span><span class="s1">:] + </span><span class="s5">18189.0</span><span class="s1">*ctp[</span><span class="s5">7</span><span class="s3">,</span><span class="s1">:] - </span><span class="s5">28287.0</span><span class="s1">*ctp[</span><span class="s5">5</span><span class="s3">,</span><span class="s1">:] - </span><span class="s5">151995.0</span><span class="s1">*ctp[</span><span class="s5">3</span><span class="s3">,</span><span class="s1">:] - </span><span class="s5">259290.0</span><span class="s1">*ct) / </span><span class="s5">414720.0</span>
    <span class="s1">u4 = (</span><span class="s5">72756.0</span><span class="s1">*ctp[</span><span class="s5">10</span><span class="s3">,</span><span class="s1">:] - </span><span class="s5">321339.0</span><span class="s1">*ctp[</span><span class="s5">8</span><span class="s3">,</span><span class="s1">:] - </span><span class="s5">154982.0</span><span class="s1">*ctp[</span><span class="s5">6</span><span class="s3">,</span><span class="s1">:] + </span><span class="s5">50938215.0</span><span class="s1">*ctp[</span><span class="s5">4</span><span class="s3">,</span><span class="s1">:] + </span><span class="s5">122602962.0</span><span class="s1">*ctp[</span><span class="s5">2</span><span class="s3">,</span><span class="s1">:] + </span><span class="s5">12773113.0</span><span class="s1">) / </span><span class="s5">39813120.0</span>
    <span class="s1">u5 = (</span><span class="s5">82393456.0</span><span class="s1">*ctp[</span><span class="s5">15</span><span class="s3">,</span><span class="s1">:] - </span><span class="s5">617950920.0</span><span class="s1">*ctp[</span><span class="s5">13</span><span class="s3">,</span><span class="s1">:] + </span><span class="s5">1994971575.0</span><span class="s1">*ctp[</span><span class="s5">11</span><span class="s3">,</span><span class="s1">:] - </span><span class="s5">3630137104.0</span><span class="s1">*ctp[</span><span class="s5">9</span><span class="s3">,</span><span class="s1">:] + </span><span class="s5">4433574213.0</span><span class="s1">*ctp[</span><span class="s5">7</span><span class="s3">,</span><span class="s1">:]</span>
          <span class="s1">- </span><span class="s5">37370295816.0</span><span class="s1">*ctp[</span><span class="s5">5</span><span class="s3">,</span><span class="s1">:] - </span><span class="s5">119582875013.0</span><span class="s1">*ctp[</span><span class="s5">3</span><span class="s3">,</span><span class="s1">:] - </span><span class="s5">34009066266.0</span><span class="s1">*ct) / </span><span class="s5">6688604160.0</span>
    <span class="s1">v0 = </span><span class="s5">1.0</span>
    <span class="s1">v1 = (</span><span class="s5">1.0</span><span class="s1">*ctp[</span><span class="s5">3</span><span class="s3">,</span><span class="s1">:] + </span><span class="s5">6.0</span><span class="s1">*ct) / </span><span class="s5">24.0</span>
    <span class="s1">v2 = (</span><span class="s5">15.0</span><span class="s1">*ctp[</span><span class="s5">4</span><span class="s3">,</span><span class="s1">:] - </span><span class="s5">327.0</span><span class="s1">*ctp[</span><span class="s5">2</span><span class="s3">,</span><span class="s1">:] - </span><span class="s5">143.0</span><span class="s1">) / </span><span class="s5">1152.0</span>
    <span class="s1">v3 = (-</span><span class="s5">4042.0</span><span class="s1">*ctp[</span><span class="s5">9</span><span class="s3">,</span><span class="s1">:] + </span><span class="s5">18189.0</span><span class="s1">*ctp[</span><span class="s5">7</span><span class="s3">,</span><span class="s1">:] - </span><span class="s5">36387.0</span><span class="s1">*ctp[</span><span class="s5">5</span><span class="s3">,</span><span class="s1">:] + </span><span class="s5">238425.0</span><span class="s1">*ctp[</span><span class="s5">3</span><span class="s3">,</span><span class="s1">:] + </span><span class="s5">259290.0</span><span class="s1">*ct) / </span><span class="s5">414720.0</span>
    <span class="s1">v4 = (-</span><span class="s5">121260.0</span><span class="s1">*ctp[</span><span class="s5">10</span><span class="s3">,</span><span class="s1">:] + </span><span class="s5">551733.0</span><span class="s1">*ctp[</span><span class="s5">8</span><span class="s3">,</span><span class="s1">:] - </span><span class="s5">151958.0</span><span class="s1">*ctp[</span><span class="s5">6</span><span class="s3">,</span><span class="s1">:] - </span><span class="s5">57484425.0</span><span class="s1">*ctp[</span><span class="s5">4</span><span class="s3">,</span><span class="s1">:] - </span><span class="s5">132752238.0</span><span class="s1">*ctp[</span><span class="s5">2</span><span class="s3">,</span><span class="s1">:] - </span><span class="s5">12118727</span><span class="s1">) / </span><span class="s5">39813120.0</span>
    <span class="s1">v5 = (</span><span class="s5">82393456.0</span><span class="s1">*ctp[</span><span class="s5">15</span><span class="s3">,</span><span class="s1">:] - </span><span class="s5">617950920.0</span><span class="s1">*ctp[</span><span class="s5">13</span><span class="s3">,</span><span class="s1">:] + </span><span class="s5">2025529095.0</span><span class="s1">*ctp[</span><span class="s5">11</span><span class="s3">,</span><span class="s1">:] - </span><span class="s5">3750839308.0</span><span class="s1">*ctp[</span><span class="s5">9</span><span class="s3">,</span><span class="s1">:] + </span><span class="s5">3832454253.0</span><span class="s1">*ctp[</span><span class="s5">7</span><span class="s3">,</span><span class="s1">:]</span>
          <span class="s1">+ </span><span class="s5">35213253348.0</span><span class="s1">*ctp[</span><span class="s5">5</span><span class="s3">,</span><span class="s1">:] + </span><span class="s5">130919230435.0</span><span class="s1">*ctp[</span><span class="s5">3</span><span class="s3">,</span><span class="s1">:] + </span><span class="s5">34009066266</span><span class="s1">*ct) / </span><span class="s5">6688604160.0</span>
    <span class="s2"># Airy Evaluation (Bi and Bip unused)</span>
    <span class="s1">Ai</span><span class="s3">, </span><span class="s1">Aip</span><span class="s3">, </span><span class="s1">Bi</span><span class="s3">, </span><span class="s1">Bip = airy(mu**(</span><span class="s5">4.0</span><span class="s1">/</span><span class="s5">6.0</span><span class="s1">) * zeta)</span>
    <span class="s2"># Prefactor for U</span>
    <span class="s1">P = </span><span class="s5">2.0</span><span class="s1">*sqrt(pi) * mu**(</span><span class="s5">1.0</span><span class="s1">/</span><span class="s5">6.0</span><span class="s1">) * phi</span>
    <span class="s2"># Terms for U</span>
    <span class="s2"># https://dlmf.nist.gov/12.10#E42</span>
    <span class="s1">phip = phi ** arange(</span><span class="s5">6</span><span class="s3">, </span><span class="s5">31</span><span class="s3">, </span><span class="s5">6</span><span class="s1">).reshape((-</span><span class="s5">1</span><span class="s3">,</span><span class="s5">1</span><span class="s1">))</span>
    <span class="s1">A0 = b0*u0</span>
    <span class="s1">A1 = (b2*u0 + phip[</span><span class="s5">0</span><span class="s3">,</span><span class="s1">:]*b1*u1 + phip[</span><span class="s5">1</span><span class="s3">,</span><span class="s1">:]*b0*u2) / zeta**</span><span class="s5">3</span>
    <span class="s1">A2 = (b4*u0 + phip[</span><span class="s5">0</span><span class="s3">,</span><span class="s1">:]*b3*u1 + phip[</span><span class="s5">1</span><span class="s3">,</span><span class="s1">:]*b2*u2 + phip[</span><span class="s5">2</span><span class="s3">,</span><span class="s1">:]*b1*u3 + phip[</span><span class="s5">3</span><span class="s3">,</span><span class="s1">:]*b0*u4) / zeta**</span><span class="s5">6</span>
    <span class="s1">B0 = -(a1*u0 + phip[</span><span class="s5">0</span><span class="s3">,</span><span class="s1">:]*a0*u1) / zeta**</span><span class="s5">2</span>
    <span class="s1">B1 = -(a3*u0 + phip[</span><span class="s5">0</span><span class="s3">,</span><span class="s1">:]*a2*u1 + phip[</span><span class="s5">1</span><span class="s3">,</span><span class="s1">:]*a1*u2 + phip[</span><span class="s5">2</span><span class="s3">,</span><span class="s1">:]*a0*u3) / zeta**</span><span class="s5">5</span>
    <span class="s1">B2 = -(a5*u0 + phip[</span><span class="s5">0</span><span class="s3">,</span><span class="s1">:]*a4*u1 + phip[</span><span class="s5">1</span><span class="s3">,</span><span class="s1">:]*a3*u2 + phip[</span><span class="s5">2</span><span class="s3">,</span><span class="s1">:]*a2*u3 + phip[</span><span class="s5">3</span><span class="s3">,</span><span class="s1">:]*a1*u4 + phip[</span><span class="s5">4</span><span class="s3">,</span><span class="s1">:]*a0*u5) / zeta**</span><span class="s5">8</span>
    <span class="s2"># U</span>
    <span class="s2"># https://dlmf.nist.gov/12.10#E35</span>
    <span class="s1">U = P * (Ai * (A0 + A1/mu**</span><span class="s5">2.0 </span><span class="s1">+ A2/mu**</span><span class="s5">4.0</span><span class="s1">) +</span>
             <span class="s1">Aip * (B0 + B1/mu**</span><span class="s5">2.0 </span><span class="s1">+ B2/mu**</span><span class="s5">4.0</span><span class="s1">) / mu**(</span><span class="s5">8.0</span><span class="s1">/</span><span class="s5">6.0</span><span class="s1">))</span>
    <span class="s2"># Prefactor for derivative of U</span>
    <span class="s1">Pd = sqrt(</span><span class="s5">2.0</span><span class="s1">*pi) * mu**(</span><span class="s5">2.0</span><span class="s1">/</span><span class="s5">6.0</span><span class="s1">) / phi</span>
    <span class="s2"># Terms for derivative of U</span>
    <span class="s2"># https://dlmf.nist.gov/12.10#E46</span>
    <span class="s1">C0 = -(b1*v0 + phip[</span><span class="s5">0</span><span class="s3">,</span><span class="s1">:]*b0*v1) / zeta</span>
    <span class="s1">C1 = -(b3*v0 + phip[</span><span class="s5">0</span><span class="s3">,</span><span class="s1">:]*b2*v1 + phip[</span><span class="s5">1</span><span class="s3">,</span><span class="s1">:]*b1*v2 + phip[</span><span class="s5">2</span><span class="s3">,</span><span class="s1">:]*b0*v3) / zeta**</span><span class="s5">4</span>
    <span class="s1">C2 = -(b5*v0 + phip[</span><span class="s5">0</span><span class="s3">,</span><span class="s1">:]*b4*v1 + phip[</span><span class="s5">1</span><span class="s3">,</span><span class="s1">:]*b3*v2 + phip[</span><span class="s5">2</span><span class="s3">,</span><span class="s1">:]*b2*v3 + phip[</span><span class="s5">3</span><span class="s3">,</span><span class="s1">:]*b1*v4 + phip[</span><span class="s5">4</span><span class="s3">,</span><span class="s1">:]*b0*v5) / zeta**</span><span class="s5">7</span>
    <span class="s1">D0 = a0*v0</span>
    <span class="s1">D1 = (a2*v0 + phip[</span><span class="s5">0</span><span class="s3">,</span><span class="s1">:]*a1*v1 + phip[</span><span class="s5">1</span><span class="s3">,</span><span class="s1">:]*a0*v2) / zeta**</span><span class="s5">3</span>
    <span class="s1">D2 = (a4*v0 + phip[</span><span class="s5">0</span><span class="s3">,</span><span class="s1">:]*a3*v1 + phip[</span><span class="s5">1</span><span class="s3">,</span><span class="s1">:]*a2*v2 + phip[</span><span class="s5">2</span><span class="s3">,</span><span class="s1">:]*a1*v3 + phip[</span><span class="s5">3</span><span class="s3">,</span><span class="s1">:]*a0*v4) / zeta**</span><span class="s5">6</span>
    <span class="s2"># Derivative of U</span>
    <span class="s2"># https://dlmf.nist.gov/12.10#E36</span>
    <span class="s1">Ud = Pd * (Ai * (C0 + C1/mu**</span><span class="s5">2.0 </span><span class="s1">+ C2/mu**</span><span class="s5">4.0</span><span class="s1">) / mu**(</span><span class="s5">4.0</span><span class="s1">/</span><span class="s5">6.0</span><span class="s1">) +</span>
               <span class="s1">Aip * (D0 + D1/mu**</span><span class="s5">2.0 </span><span class="s1">+ D2/mu**</span><span class="s5">4.0</span><span class="s1">))</span>
    <span class="s3">return </span><span class="s1">U</span><span class="s3">, </span><span class="s1">Ud</span>


<span class="s3">def </span><span class="s1">_newton(n</span><span class="s3">, </span><span class="s1">x_initial</span><span class="s3">, </span><span class="s1">maxit=</span><span class="s5">5</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Newton iteration for polishing the asymptotic approximation 
    to the zeros of the Hermite polynomials. 
 
    Parameters 
    ---------- 
    n : int 
        Quadrature order 
    x_initial : ndarray 
        Initial guesses for the roots 
    maxit : int 
        Maximal number of Newton iterations. 
        The default 5 is sufficient, usually 
        only one or two steps are needed. 
 
    Returns 
    ------- 
    nodes : ndarray 
        Quadrature nodes 
    weights : ndarray 
        Quadrature weights 
 
    See Also 
    -------- 
    roots_hermite_asy 
    &quot;&quot;&quot;</span>
    <span class="s2"># Variable transformation</span>
    <span class="s1">mu = sqrt(</span><span class="s5">2.0</span><span class="s1">*n + </span><span class="s5">1.0</span><span class="s1">)</span>
    <span class="s1">t = x_initial / mu</span>
    <span class="s1">theta = arccos(t)</span>
    <span class="s2"># Newton iteration</span>
    <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">range(maxit):</span>
        <span class="s1">u</span><span class="s3">, </span><span class="s1">ud = _pbcf(n</span><span class="s3">, </span><span class="s1">theta)</span>
        <span class="s1">dtheta = u / (sqrt(</span><span class="s5">2.0</span><span class="s1">) * mu * sin(theta) * ud)</span>
        <span class="s1">theta = theta + dtheta</span>
        <span class="s3">if </span><span class="s1">max(abs(dtheta)) &lt; </span><span class="s5">1e-14</span><span class="s1">:</span>
            <span class="s3">break</span>
    <span class="s2"># Undo variable transformation</span>
    <span class="s1">x = mu * cos(theta)</span>
    <span class="s2"># Central node is always zero</span>
    <span class="s3">if </span><span class="s1">n % </span><span class="s5">2 </span><span class="s1">== </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">x[</span><span class="s5">0</span><span class="s1">] = </span><span class="s5">0.0</span>
    <span class="s2"># Compute weights</span>
    <span class="s1">w = exp(-x**</span><span class="s5">2</span><span class="s1">) / (</span><span class="s5">2.0</span><span class="s1">*ud**</span><span class="s5">2</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">x</span><span class="s3">, </span><span class="s1">w</span>


<span class="s3">def </span><span class="s1">_roots_hermite_asy(n):</span>
    <span class="s0">r&quot;&quot;&quot;Gauss-Hermite (physicist's) quadrature for large n. 
 
    Computes the sample points and weights for Gauss-Hermite quadrature. 
    The sample points are the roots of the nth degree Hermite polynomial, 
    :math:`H_n(x)`. These sample points and weights correctly integrate 
    polynomials of degree :math:`2n - 1` or less over the interval 
    :math:`[-\infty, \infty]` with weight function :math:`f(x) = e^{-x^2}`. 
 
    This method relies on asymptotic expansions which work best for n &gt; 150. 
    The algorithm has linear runtime making computation for very large n 
    feasible. 
 
    Parameters 
    ---------- 
    n : int 
        quadrature order 
 
    Returns 
    ------- 
    nodes : ndarray 
        Quadrature nodes 
    weights : ndarray 
        Quadrature weights 
 
    See Also 
    -------- 
    roots_hermite 
 
    References 
    ---------- 
    .. [townsend.trogdon.olver-2014] 
       Townsend, A. and Trogdon, T. and Olver, S. (2014) 
       *Fast computation of Gauss quadrature nodes and 
       weights on the whole real line*. :arXiv:`1410.5286`. 
 
    .. [townsend.trogdon.olver-2015] 
       Townsend, A. and Trogdon, T. and Olver, S. (2015) 
       *Fast computation of Gauss quadrature nodes and 
       weights on the whole real line*. 
       IMA Journal of Numerical Analysis 
       :doi:`10.1093/imanum/drv002`. 
    &quot;&quot;&quot;</span>
    <span class="s1">iv = _initial_nodes(n)</span>
    <span class="s1">nodes</span><span class="s3">, </span><span class="s1">weights = _newton(n</span><span class="s3">, </span><span class="s1">iv)</span>
    <span class="s2"># Combine with negative parts</span>
    <span class="s3">if </span><span class="s1">n % </span><span class="s5">2 </span><span class="s1">== </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">nodes = hstack([-nodes[::-</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">nodes])</span>
        <span class="s1">weights = hstack([weights[::-</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">weights])</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">nodes = hstack([-nodes[-</span><span class="s5">1</span><span class="s1">:</span><span class="s5">0</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">nodes])</span>
        <span class="s1">weights = hstack([weights[-</span><span class="s5">1</span><span class="s1">:</span><span class="s5">0</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">]</span><span class="s3">, </span><span class="s1">weights])</span>
    <span class="s2"># Scale weights</span>
    <span class="s1">weights *= sqrt(pi) / sum(weights)</span>
    <span class="s3">return </span><span class="s1">nodes</span><span class="s3">, </span><span class="s1">weights</span>


<span class="s3">def </span><span class="s1">hermite(n</span><span class="s3">, </span><span class="s1">monic=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s0">r&quot;&quot;&quot;Physicist's Hermite polynomial. 
 
    Defined by 
 
    .. math:: 
 
        H_n(x) = (-1)^ne^{x^2}\frac{d^n}{dx^n}e^{-x^2}; 
 
    :math:`H_n` is a polynomial of degree :math:`n`. 
 
    Parameters 
    ---------- 
    n : int 
        Degree of the polynomial. 
    monic : bool, optional 
        If `True`, scale the leading coefficient to be 1. Default is 
        `False`. 
 
    Returns 
    ------- 
    H : orthopoly1d 
        Hermite polynomial. 
 
    Notes 
    ----- 
    The polynomials :math:`H_n` are orthogonal over :math:`(-\infty, 
    \infty)` with weight function :math:`e^{-x^2}`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from scipy import special 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; import numpy as np 
 
    &gt;&gt;&gt; p_monic = special.hermite(3, monic=True) 
    &gt;&gt;&gt; p_monic 
    poly1d([ 1. ,  0. , -1.5,  0. ]) 
    &gt;&gt;&gt; p_monic(1) 
    -0.49999999999999983 
    &gt;&gt;&gt; x = np.linspace(-3, 3, 400) 
    &gt;&gt;&gt; y = p_monic(x) 
    &gt;&gt;&gt; plt.plot(x, y) 
    &gt;&gt;&gt; plt.title(&quot;Monic Hermite polynomial of degree 3&quot;) 
    &gt;&gt;&gt; plt.xlabel(&quot;x&quot;) 
    &gt;&gt;&gt; plt.ylabel(&quot;H_3(x)&quot;) 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">n &lt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;n must be nonnegative.&quot;</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">n == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">n1 = n + </span><span class="s5">1</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">n1 = n</span>
    <span class="s1">x</span><span class="s3">, </span><span class="s1">w = roots_hermite(n1)</span>
    <span class="s3">def </span><span class="s1">wfunc(x):</span>
        <span class="s3">return </span><span class="s1">exp(-x * x)</span>
    <span class="s3">if </span><span class="s1">n == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">x</span><span class="s3">, </span><span class="s1">w = []</span><span class="s3">, </span><span class="s1">[]</span>
    <span class="s1">hn = </span><span class="s5">2</span><span class="s1">**n * _gam(n + </span><span class="s5">1</span><span class="s1">) * sqrt(pi)</span>
    <span class="s1">kn = </span><span class="s5">2</span><span class="s1">**n</span>
    <span class="s1">p = orthopoly1d(x</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">hn</span><span class="s3">, </span><span class="s1">kn</span><span class="s3">, </span><span class="s1">wfunc</span><span class="s3">, </span><span class="s1">(-inf</span><span class="s3">, </span><span class="s1">inf)</span><span class="s3">, </span><span class="s1">monic</span><span class="s3">,</span>
                    <span class="s3">lambda </span><span class="s1">x: _ufuncs.eval_hermite(n</span><span class="s3">, </span><span class="s1">x))</span>
    <span class="s3">return </span><span class="s1">p</span>

<span class="s2"># Hermite  2                         He_n(x)</span>


<span class="s3">def </span><span class="s1">roots_hermitenorm(n</span><span class="s3">, </span><span class="s1">mu=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s0">r&quot;&quot;&quot;Gauss-Hermite (statistician's) quadrature. 
 
    Compute the sample points and weights for Gauss-Hermite 
    quadrature. The sample points are the roots of the nth degree 
    Hermite polynomial, :math:`He_n(x)`. These sample points and 
    weights correctly integrate polynomials of degree :math:`2n - 1` 
    or less over the interval :math:`[-\infty, \infty]` with weight 
    function :math:`w(x) = e^{-x^2/2}`. See 22.2.15 in [AS]_ for more 
    details. 
 
    Parameters 
    ---------- 
    n : int 
        quadrature order 
    mu : bool, optional 
        If True, return the sum of the weights, optional. 
 
    Returns 
    ------- 
    x : ndarray 
        Sample points 
    w : ndarray 
        Weights 
    mu : float 
        Sum of the weights 
 
    Notes 
    ----- 
    For small n up to 150 a modified version of the Golub-Welsch 
    algorithm is used. Nodes are computed from the eigenvalue 
    problem and improved by one step of a Newton iteration. 
    The weights are computed from the well-known analytical formula. 
 
    For n larger than 150 an optimal asymptotic algorithm is used 
    which computes nodes and weights in a numerical stable manner. 
    The algorithm has linear runtime making computation for very 
    large n (several thousand or more) feasible. 
 
    See Also 
    -------- 
    scipy.integrate.quadrature 
    scipy.integrate.fixed_quad 
    numpy.polynomial.hermite_e.hermegauss 
 
    References 
    ---------- 
    .. [AS] Milton Abramowitz and Irene A. Stegun, eds. 
        Handbook of Mathematical Functions with Formulas, 
        Graphs, and Mathematical Tables. New York: Dover, 1972. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">m = int(n)</span>
    <span class="s3">if </span><span class="s1">n &lt; </span><span class="s5">1 </span><span class="s3">or </span><span class="s1">n != m:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;n must be a positive integer.&quot;</span><span class="s1">)</span>

    <span class="s1">mu0 = np.sqrt(</span><span class="s5">2.0</span><span class="s1">*np.pi)</span>
    <span class="s3">if </span><span class="s1">n &lt;= </span><span class="s5">150</span><span class="s1">:</span>
        <span class="s3">def </span><span class="s1">an_func(k):</span>
            <span class="s3">return </span><span class="s5">0.0 </span><span class="s1">* k</span>
        <span class="s3">def </span><span class="s1">bn_func(k):</span>
            <span class="s3">return </span><span class="s1">np.sqrt(k)</span>
        <span class="s1">f = _ufuncs.eval_hermitenorm</span>
        <span class="s3">def </span><span class="s1">df(n</span><span class="s3">, </span><span class="s1">x):</span>
            <span class="s3">return </span><span class="s1">n * _ufuncs.eval_hermitenorm(n - </span><span class="s5">1</span><span class="s3">, </span><span class="s1">x)</span>
        <span class="s3">return </span><span class="s1">_gen_roots_and_weights(m</span><span class="s3">, </span><span class="s1">mu0</span><span class="s3">, </span><span class="s1">an_func</span><span class="s3">, </span><span class="s1">bn_func</span><span class="s3">, </span><span class="s1">f</span><span class="s3">, </span><span class="s1">df</span><span class="s3">, True, </span><span class="s1">mu)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">nodes</span><span class="s3">, </span><span class="s1">weights = _roots_hermite_asy(m)</span>
        <span class="s2"># Transform</span>
        <span class="s1">nodes *= sqrt(</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">weights *= sqrt(</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">mu:</span>
            <span class="s3">return </span><span class="s1">nodes</span><span class="s3">, </span><span class="s1">weights</span><span class="s3">, </span><span class="s1">mu0</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">return </span><span class="s1">nodes</span><span class="s3">, </span><span class="s1">weights</span>


<span class="s3">def </span><span class="s1">hermitenorm(n</span><span class="s3">, </span><span class="s1">monic=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s0">r&quot;&quot;&quot;Normalized (probabilist's) Hermite polynomial. 
 
    Defined by 
 
    .. math:: 
 
        He_n(x) = (-1)^ne^{x^2/2}\frac{d^n}{dx^n}e^{-x^2/2}; 
 
    :math:`He_n` is a polynomial of degree :math:`n`. 
 
    Parameters 
    ---------- 
    n : int 
        Degree of the polynomial. 
    monic : bool, optional 
        If `True`, scale the leading coefficient to be 1. Default is 
        `False`. 
 
    Returns 
    ------- 
    He : orthopoly1d 
        Hermite polynomial. 
 
    Notes 
    ----- 
 
    The polynomials :math:`He_n` are orthogonal over :math:`(-\infty, 
    \infty)` with weight function :math:`e^{-x^2/2}`. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">n &lt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;n must be nonnegative.&quot;</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">n == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">n1 = n + </span><span class="s5">1</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">n1 = n</span>
    <span class="s1">x</span><span class="s3">, </span><span class="s1">w = roots_hermitenorm(n1)</span>
    <span class="s3">def </span><span class="s1">wfunc(x):</span>
        <span class="s3">return </span><span class="s1">exp(-x * x / </span><span class="s5">2.0</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">n == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">x</span><span class="s3">, </span><span class="s1">w = []</span><span class="s3">, </span><span class="s1">[]</span>
    <span class="s1">hn = sqrt(</span><span class="s5">2 </span><span class="s1">* pi) * _gam(n + </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">kn = </span><span class="s5">1.0</span>
    <span class="s1">p = orthopoly1d(x</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">hn</span><span class="s3">, </span><span class="s1">kn</span><span class="s3">, </span><span class="s1">wfunc=wfunc</span><span class="s3">, </span><span class="s1">limits=(-inf</span><span class="s3">, </span><span class="s1">inf)</span><span class="s3">, </span><span class="s1">monic=monic</span><span class="s3">,</span>
                    <span class="s1">eval_func=</span><span class="s3">lambda </span><span class="s1">x: _ufuncs.eval_hermitenorm(n</span><span class="s3">, </span><span class="s1">x))</span>
    <span class="s3">return </span><span class="s1">p</span>

<span class="s2"># The remainder of the polynomials can be derived from the ones above.</span>

<span class="s2"># Ultraspherical (Gegenbauer)        C^(alpha)_n(x)</span>


<span class="s3">def </span><span class="s1">roots_gegenbauer(n</span><span class="s3">, </span><span class="s1">alpha</span><span class="s3">, </span><span class="s1">mu=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s0">r&quot;&quot;&quot;Gauss-Gegenbauer quadrature. 
 
    Compute the sample points and weights for Gauss-Gegenbauer 
    quadrature. The sample points are the roots of the nth degree 
    Gegenbauer polynomial, :math:`C^{\alpha}_n(x)`. These sample 
    points and weights correctly integrate polynomials of degree 
    :math:`2n - 1` or less over the interval :math:`[-1, 1]` with 
    weight function :math:`w(x) = (1 - x^2)^{\alpha - 1/2}`. See 
    22.2.3 in [AS]_ for more details. 
 
    Parameters 
    ---------- 
    n : int 
        quadrature order 
    alpha : float 
        alpha must be &gt; -0.5 
    mu : bool, optional 
        If True, return the sum of the weights, optional. 
 
    Returns 
    ------- 
    x : ndarray 
        Sample points 
    w : ndarray 
        Weights 
    mu : float 
        Sum of the weights 
 
    See Also 
    -------- 
    scipy.integrate.quadrature 
    scipy.integrate.fixed_quad 
 
    References 
    ---------- 
    .. [AS] Milton Abramowitz and Irene A. Stegun, eds. 
        Handbook of Mathematical Functions with Formulas, 
        Graphs, and Mathematical Tables. New York: Dover, 1972. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">m = int(n)</span>
    <span class="s3">if </span><span class="s1">n &lt; </span><span class="s5">1 </span><span class="s3">or </span><span class="s1">n != m:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;n must be a positive integer.&quot;</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">alpha &lt; -</span><span class="s5">0.5</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;alpha must be greater than -0.5.&quot;</span><span class="s1">)</span>
    <span class="s3">elif </span><span class="s1">alpha == </span><span class="s5">0.0</span><span class="s1">:</span>
        <span class="s2"># C(n,0,x) == 0 uniformly, however, as alpha-&gt;0, C(n,alpha,x)-&gt;T(n,x)</span>
        <span class="s2"># strictly, we should just error out here, since the roots are not</span>
        <span class="s2"># really defined, but we used to return something useful, so let's</span>
        <span class="s2"># keep doing so.</span>
        <span class="s3">return </span><span class="s1">roots_chebyt(n</span><span class="s3">, </span><span class="s1">mu)</span>

    <span class="s3">if </span><span class="s1">alpha &lt;= </span><span class="s5">170</span><span class="s1">:</span>
        <span class="s1">mu0 = (np.sqrt(np.pi) * _ufuncs.gamma(alpha + </span><span class="s5">0.5</span><span class="s1">)) \</span>
              <span class="s1">/ _ufuncs.gamma(alpha + </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s2"># For large alpha we use a Taylor series expansion around inf,</span>
        <span class="s2"># expressed as a 6th order polynomial of a^-1 and using Horner's</span>
        <span class="s2"># method to minimize computation and maximize precision</span>
        <span class="s1">inv_alpha = </span><span class="s5">1. </span><span class="s1">/ alpha</span>
        <span class="s1">coeffs = np.array([</span><span class="s5">0.000207186</span><span class="s3">, </span><span class="s1">-</span><span class="s5">0.00152206</span><span class="s3">, </span><span class="s1">-</span><span class="s5">0.000640869</span><span class="s3">,</span>
                           <span class="s5">0.00488281</span><span class="s3">, </span><span class="s5">0.0078125</span><span class="s3">, </span><span class="s1">-</span><span class="s5">0.125</span><span class="s3">, </span><span class="s5">1.</span><span class="s1">])</span>
        <span class="s1">mu0 = coeffs[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s3">for </span><span class="s1">term </span><span class="s3">in </span><span class="s1">range(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">len(coeffs)):</span>
            <span class="s1">mu0 = mu0 * inv_alpha + coeffs[term]</span>
        <span class="s1">mu0 = mu0 * np.sqrt(np.pi / alpha)</span>
    <span class="s3">def </span><span class="s1">an_func(k):</span>
        <span class="s3">return </span><span class="s5">0.0 </span><span class="s1">* k</span>
    <span class="s3">def </span><span class="s1">bn_func(k):</span>
        <span class="s3">return </span><span class="s1">np.sqrt(k * (k + </span><span class="s5">2 </span><span class="s1">* alpha - </span><span class="s5">1</span><span class="s1">) / (</span><span class="s5">4 </span><span class="s1">* (k + alpha) * (k + alpha - </span><span class="s5">1</span><span class="s1">)))</span>
    <span class="s3">def </span><span class="s1">f(n</span><span class="s3">, </span><span class="s1">x):</span>
        <span class="s3">return </span><span class="s1">_ufuncs.eval_gegenbauer(n</span><span class="s3">, </span><span class="s1">alpha</span><span class="s3">, </span><span class="s1">x)</span>
    <span class="s3">def </span><span class="s1">df(n</span><span class="s3">, </span><span class="s1">x):</span>
        <span class="s3">return </span><span class="s1">(-n * x * _ufuncs.eval_gegenbauer(n</span><span class="s3">, </span><span class="s1">alpha</span><span class="s3">, </span><span class="s1">x) + (n + </span><span class="s5">2 </span><span class="s1">* alpha - </span><span class="s5">1</span><span class="s1">) * _ufuncs.eval_gegenbauer(n - </span><span class="s5">1</span><span class="s3">, </span><span class="s1">alpha</span><span class="s3">, </span><span class="s1">x)) / (</span><span class="s5">1 </span><span class="s1">- x ** </span><span class="s5">2</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">_gen_roots_and_weights(m</span><span class="s3">, </span><span class="s1">mu0</span><span class="s3">, </span><span class="s1">an_func</span><span class="s3">, </span><span class="s1">bn_func</span><span class="s3">, </span><span class="s1">f</span><span class="s3">, </span><span class="s1">df</span><span class="s3">, True, </span><span class="s1">mu)</span>


<span class="s3">def </span><span class="s1">gegenbauer(n</span><span class="s3">, </span><span class="s1">alpha</span><span class="s3">, </span><span class="s1">monic=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s0">r&quot;&quot;&quot;Gegenbauer (ultraspherical) polynomial. 
 
    Defined to be the solution of 
 
    .. math:: 
        (1 - x^2)\frac{d^2}{dx^2}C_n^{(\alpha)} 
          - (2\alpha + 1)x\frac{d}{dx}C_n^{(\alpha)} 
          + n(n + 2\alpha)C_n^{(\alpha)} = 0 
 
    for :math:`\alpha &gt; -1/2`; :math:`C_n^{(\alpha)}` is a polynomial 
    of degree :math:`n`. 
 
    Parameters 
    ---------- 
    n : int 
        Degree of the polynomial. 
    alpha : float 
        Parameter, must be greater than -0.5. 
    monic : bool, optional 
        If `True`, scale the leading coefficient to be 1. Default is 
        `False`. 
 
    Returns 
    ------- 
    C : orthopoly1d 
        Gegenbauer polynomial. 
 
    Notes 
    ----- 
    The polynomials :math:`C_n^{(\alpha)}` are orthogonal over 
    :math:`[-1,1]` with weight function :math:`(1 - x^2)^{(\alpha - 
    1/2)}`. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy import special 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
 
    We can initialize a variable ``p`` as a Gegenbauer polynomial using the 
    `gegenbauer` function and evaluate at a point ``x = 1``. 
 
    &gt;&gt;&gt; p = special.gegenbauer(3, 0.5, monic=False) 
    &gt;&gt;&gt; p 
    poly1d([ 2.5,  0. , -1.5,  0. ]) 
    &gt;&gt;&gt; p(1) 
    1.0 
 
    To evaluate ``p`` at various points ``x`` in the interval ``(-3, 3)``, 
    simply pass an array ``x`` to ``p`` as follows: 
 
    &gt;&gt;&gt; x = np.linspace(-3, 3, 400) 
    &gt;&gt;&gt; y = p(x) 
 
    We can then visualize ``x, y`` using `matplotlib.pyplot`. 
 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; ax.plot(x, y) 
    &gt;&gt;&gt; ax.set_title(&quot;Gegenbauer (ultraspherical) polynomial of degree 3&quot;) 
    &gt;&gt;&gt; ax.set_xlabel(&quot;x&quot;) 
    &gt;&gt;&gt; ax.set_ylabel(&quot;G_3(x)&quot;) 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">base = jacobi(n</span><span class="s3">, </span><span class="s1">alpha - </span><span class="s5">0.5</span><span class="s3">, </span><span class="s1">alpha - </span><span class="s5">0.5</span><span class="s3">, </span><span class="s1">monic=monic)</span>
    <span class="s3">if </span><span class="s1">monic:</span>
        <span class="s3">return </span><span class="s1">base</span>
    <span class="s2">#  Abrahmowitz and Stegan 22.5.20</span>
    <span class="s1">factor = (_gam(</span><span class="s5">2</span><span class="s1">*alpha + n) * _gam(alpha + </span><span class="s5">0.5</span><span class="s1">) /</span>
              <span class="s1">_gam(</span><span class="s5">2</span><span class="s1">*alpha) / _gam(alpha + </span><span class="s5">0.5 </span><span class="s1">+ n))</span>
    <span class="s1">base._scale(factor)</span>
    <span class="s1">base.__dict__[</span><span class="s4">'_eval_func'</span><span class="s1">] = </span><span class="s3">lambda </span><span class="s1">x: _ufuncs.eval_gegenbauer(float(n)</span><span class="s3">,</span>
                                                                    <span class="s1">alpha</span><span class="s3">, </span><span class="s1">x)</span>
    <span class="s3">return </span><span class="s1">base</span>

<span class="s2"># Chebyshev of the first kind: T_n(x) =</span>
<span class="s2">#     n! sqrt(pi) / _gam(n+1./2)* P^(-1/2,-1/2)_n(x)</span>
<span class="s2"># Computed anew.</span>


<span class="s3">def </span><span class="s1">roots_chebyt(n</span><span class="s3">, </span><span class="s1">mu=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s0">r&quot;&quot;&quot;Gauss-Chebyshev (first kind) quadrature. 
 
    Computes the sample points and weights for Gauss-Chebyshev 
    quadrature. The sample points are the roots of the nth degree 
    Chebyshev polynomial of the first kind, :math:`T_n(x)`. These 
    sample points and weights correctly integrate polynomials of 
    degree :math:`2n - 1` or less over the interval :math:`[-1, 1]` 
    with weight function :math:`w(x) = 1/\sqrt{1 - x^2}`. See 22.2.4 
    in [AS]_ for more details. 
 
    Parameters 
    ---------- 
    n : int 
        quadrature order 
    mu : bool, optional 
        If True, return the sum of the weights, optional. 
 
    Returns 
    ------- 
    x : ndarray 
        Sample points 
    w : ndarray 
        Weights 
    mu : float 
        Sum of the weights 
 
    See Also 
    -------- 
    scipy.integrate.quadrature 
    scipy.integrate.fixed_quad 
    numpy.polynomial.chebyshev.chebgauss 
 
    References 
    ---------- 
    .. [AS] Milton Abramowitz and Irene A. Stegun, eds. 
        Handbook of Mathematical Functions with Formulas, 
        Graphs, and Mathematical Tables. New York: Dover, 1972. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">m = int(n)</span>
    <span class="s3">if </span><span class="s1">n &lt; </span><span class="s5">1 </span><span class="s3">or </span><span class="s1">n != m:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'n must be a positive integer.'</span><span class="s1">)</span>
    <span class="s1">x = _ufuncs._sinpi(np.arange(-m + </span><span class="s5">1</span><span class="s3">, </span><span class="s1">m</span><span class="s3">, </span><span class="s5">2</span><span class="s1">) / (</span><span class="s5">2</span><span class="s1">*m))</span>
    <span class="s1">w = np.full_like(x</span><span class="s3">, </span><span class="s1">pi/m)</span>
    <span class="s3">if </span><span class="s1">mu:</span>
        <span class="s3">return </span><span class="s1">x</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">pi</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">x</span><span class="s3">, </span><span class="s1">w</span>


<span class="s3">def </span><span class="s1">chebyt(n</span><span class="s3">, </span><span class="s1">monic=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s0">r&quot;&quot;&quot;Chebyshev polynomial of the first kind. 
 
    Defined to be the solution of 
 
    .. math:: 
        (1 - x^2)\frac{d^2}{dx^2}T_n - x\frac{d}{dx}T_n + n^2T_n = 0; 
 
    :math:`T_n` is a polynomial of degree :math:`n`. 
 
    Parameters 
    ---------- 
    n : int 
        Degree of the polynomial. 
    monic : bool, optional 
        If `True`, scale the leading coefficient to be 1. Default is 
        `False`. 
 
    Returns 
    ------- 
    T : orthopoly1d 
        Chebyshev polynomial of the first kind. 
 
    Notes 
    ----- 
    The polynomials :math:`T_n` are orthogonal over :math:`[-1, 1]` 
    with weight function :math:`(1 - x^2)^{-1/2}`. 
 
    See Also 
    -------- 
    chebyu : Chebyshev polynomial of the second kind. 
 
    References 
    ---------- 
    .. [AS] Milton Abramowitz and Irene A. Stegun, eds. 
        Handbook of Mathematical Functions with Formulas, 
        Graphs, and Mathematical Tables. New York: Dover, 1972. 
 
    Examples 
    -------- 
    Chebyshev polynomials of the first kind of order :math:`n` can 
    be obtained as the determinant of specific :math:`n \times n` 
    matrices. As an example we can check how the points obtained from 
    the determinant of the following :math:`3 \times 3` matrix 
    lay exacty on :math:`T_3`: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; from scipy.linalg import det 
    &gt;&gt;&gt; from scipy.special import chebyt 
    &gt;&gt;&gt; x = np.arange(-1.0, 1.0, 0.01) 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; ax.set_ylim(-2.0, 2.0) 
    &gt;&gt;&gt; ax.set_title(r'Chebyshev polynomial $T_3$') 
    &gt;&gt;&gt; ax.plot(x, chebyt(3)(x), label=rf'$T_3$') 
    &gt;&gt;&gt; for p in np.arange(-1.0, 1.0, 0.1): 
    ...     ax.plot(p, 
    ...             det(np.array([[p, 1, 0], [1, 2*p, 1], [0, 1, 2*p]])), 
    ...             'rx') 
    &gt;&gt;&gt; plt.legend(loc='best') 
    &gt;&gt;&gt; plt.show() 
 
    They are also related to the Jacobi Polynomials 
    :math:`P_n^{(-0.5, -0.5)}` through the relation: 
 
    .. math:: 
        P_n^{(-0.5, -0.5)}(x) = \frac{1}{4^n} \binom{2n}{n} T_n(x) 
 
    Let's verify it for :math:`n = 3`: 
 
    &gt;&gt;&gt; from scipy.special import binom 
    &gt;&gt;&gt; from scipy.special import jacobi 
    &gt;&gt;&gt; x = np.arange(-1.0, 1.0, 0.01) 
    &gt;&gt;&gt; np.allclose(jacobi(3, -0.5, -0.5)(x), 
    ...             1/64 * binom(6, 3) * chebyt(3)(x)) 
    True 
 
    We can plot the Chebyshev polynomials :math:`T_n` for some values 
    of :math:`n`: 
 
    &gt;&gt;&gt; x = np.arange(-1.5, 1.5, 0.01) 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; ax.set_ylim(-4.0, 4.0) 
    &gt;&gt;&gt; ax.set_title(r'Chebyshev polynomials $T_n$') 
    &gt;&gt;&gt; for n in np.arange(2,5): 
    ...     ax.plot(x, chebyt(n)(x), label=rf'$T_n={n}$') 
    &gt;&gt;&gt; plt.legend(loc='best') 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">n &lt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;n must be nonnegative.&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">wfunc(x):</span>
        <span class="s3">return </span><span class="s5">1.0 </span><span class="s1">/ sqrt(</span><span class="s5">1 </span><span class="s1">- x * x)</span>
    <span class="s3">if </span><span class="s1">n == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">orthopoly1d([]</span><span class="s3">, </span><span class="s1">[]</span><span class="s3">, </span><span class="s1">pi</span><span class="s3">, </span><span class="s5">1.0</span><span class="s3">, </span><span class="s1">wfunc</span><span class="s3">, </span><span class="s1">(-</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">monic</span><span class="s3">,</span>
                           <span class="s3">lambda </span><span class="s1">x: _ufuncs.eval_chebyt(n</span><span class="s3">, </span><span class="s1">x))</span>
    <span class="s1">n1 = n</span>
    <span class="s1">x</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">mu = roots_chebyt(n1</span><span class="s3">, </span><span class="s1">mu=</span><span class="s3">True</span><span class="s1">)</span>
    <span class="s1">hn = pi / </span><span class="s5">2</span>
    <span class="s1">kn = </span><span class="s5">2</span><span class="s1">**(n - </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">p = orthopoly1d(x</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">hn</span><span class="s3">, </span><span class="s1">kn</span><span class="s3">, </span><span class="s1">wfunc</span><span class="s3">, </span><span class="s1">(-</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">monic</span><span class="s3">,</span>
                    <span class="s3">lambda </span><span class="s1">x: _ufuncs.eval_chebyt(n</span><span class="s3">, </span><span class="s1">x))</span>
    <span class="s3">return </span><span class="s1">p</span>

<span class="s2"># Chebyshev of the second kind</span>
<span class="s2">#    U_n(x) = (n+1)! sqrt(pi) / (2*_gam(n+3./2)) * P^(1/2,1/2)_n(x)</span>


<span class="s3">def </span><span class="s1">roots_chebyu(n</span><span class="s3">, </span><span class="s1">mu=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s0">r&quot;&quot;&quot;Gauss-Chebyshev (second kind) quadrature. 
 
    Computes the sample points and weights for Gauss-Chebyshev 
    quadrature. The sample points are the roots of the nth degree 
    Chebyshev polynomial of the second kind, :math:`U_n(x)`. These 
    sample points and weights correctly integrate polynomials of 
    degree :math:`2n - 1` or less over the interval :math:`[-1, 1]` 
    with weight function :math:`w(x) = \sqrt{1 - x^2}`. See 22.2.5 in 
    [AS]_ for details. 
 
    Parameters 
    ---------- 
    n : int 
        quadrature order 
    mu : bool, optional 
        If True, return the sum of the weights, optional. 
 
    Returns 
    ------- 
    x : ndarray 
        Sample points 
    w : ndarray 
        Weights 
    mu : float 
        Sum of the weights 
 
    See Also 
    -------- 
    scipy.integrate.quadrature 
    scipy.integrate.fixed_quad 
 
    References 
    ---------- 
    .. [AS] Milton Abramowitz and Irene A. Stegun, eds. 
        Handbook of Mathematical Functions with Formulas, 
        Graphs, and Mathematical Tables. New York: Dover, 1972. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">m = int(n)</span>
    <span class="s3">if </span><span class="s1">n &lt; </span><span class="s5">1 </span><span class="s3">or </span><span class="s1">n != m:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">'n must be a positive integer.'</span><span class="s1">)</span>
    <span class="s1">t = np.arange(m</span><span class="s3">, </span><span class="s5">0</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">) * pi / (m + </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">x = np.cos(t)</span>
    <span class="s1">w = pi * np.sin(t)**</span><span class="s5">2 </span><span class="s1">/ (m + </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s3">if </span><span class="s1">mu:</span>
        <span class="s3">return </span><span class="s1">x</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">pi / </span><span class="s5">2</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">x</span><span class="s3">, </span><span class="s1">w</span>


<span class="s3">def </span><span class="s1">chebyu(n</span><span class="s3">, </span><span class="s1">monic=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s0">r&quot;&quot;&quot;Chebyshev polynomial of the second kind. 
 
    Defined to be the solution of 
 
    .. math:: 
        (1 - x^2)\frac{d^2}{dx^2}U_n - 3x\frac{d}{dx}U_n 
          + n(n + 2)U_n = 0; 
 
    :math:`U_n` is a polynomial of degree :math:`n`. 
 
    Parameters 
    ---------- 
    n : int 
        Degree of the polynomial. 
    monic : bool, optional 
        If `True`, scale the leading coefficient to be 1. Default is 
        `False`. 
 
    Returns 
    ------- 
    U : orthopoly1d 
        Chebyshev polynomial of the second kind. 
 
    Notes 
    ----- 
    The polynomials :math:`U_n` are orthogonal over :math:`[-1, 1]` 
    with weight function :math:`(1 - x^2)^{1/2}`. 
 
    See Also 
    -------- 
    chebyt : Chebyshev polynomial of the first kind. 
 
    References 
    ---------- 
    .. [AS] Milton Abramowitz and Irene A. Stegun, eds. 
        Handbook of Mathematical Functions with Formulas, 
        Graphs, and Mathematical Tables. New York: Dover, 1972. 
 
    Examples 
    -------- 
    Chebyshev polynomials of the second kind of order :math:`n` can 
    be obtained as the determinant of specific :math:`n \times n` 
    matrices. As an example we can check how the points obtained from 
    the determinant of the following :math:`3 \times 3` matrix 
    lay exacty on :math:`U_3`: 
 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; import matplotlib.pyplot as plt 
    &gt;&gt;&gt; from scipy.linalg import det 
    &gt;&gt;&gt; from scipy.special import chebyu 
    &gt;&gt;&gt; x = np.arange(-1.0, 1.0, 0.01) 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; ax.set_ylim(-2.0, 2.0) 
    &gt;&gt;&gt; ax.set_title(r'Chebyshev polynomial $U_3$') 
    &gt;&gt;&gt; ax.plot(x, chebyu(3)(x), label=rf'$U_3$') 
    &gt;&gt;&gt; for p in np.arange(-1.0, 1.0, 0.1): 
    ...     ax.plot(p, 
    ...             det(np.array([[2*p, 1, 0], [1, 2*p, 1], [0, 1, 2*p]])), 
    ...             'rx') 
    &gt;&gt;&gt; plt.legend(loc='best') 
    &gt;&gt;&gt; plt.show() 
 
    They satisfy the recurrence relation: 
 
    .. math:: 
        U_{2n-1}(x) = 2 T_n(x)U_{n-1}(x) 
 
    where the :math:`T_n` are the Chebyshev polynomial of the first kind. 
    Let's verify it for :math:`n = 2`: 
 
    &gt;&gt;&gt; from scipy.special import chebyt 
    &gt;&gt;&gt; x = np.arange(-1.0, 1.0, 0.01) 
    &gt;&gt;&gt; np.allclose(chebyu(3)(x), 2 * chebyt(2)(x) * chebyu(1)(x)) 
    True 
 
    We can plot the Chebyshev polynomials :math:`U_n` for some values 
    of :math:`n`: 
 
    &gt;&gt;&gt; x = np.arange(-1.0, 1.0, 0.01) 
    &gt;&gt;&gt; fig, ax = plt.subplots() 
    &gt;&gt;&gt; ax.set_ylim(-1.5, 1.5) 
    &gt;&gt;&gt; ax.set_title(r'Chebyshev polynomials $U_n$') 
    &gt;&gt;&gt; for n in np.arange(1,5): 
    ...     ax.plot(x, chebyu(n)(x), label=rf'$U_n={n}$') 
    &gt;&gt;&gt; plt.legend(loc='best') 
    &gt;&gt;&gt; plt.show() 
 
    &quot;&quot;&quot;</span>
    <span class="s1">base = jacobi(n</span><span class="s3">, </span><span class="s5">0.5</span><span class="s3">, </span><span class="s5">0.5</span><span class="s3">, </span><span class="s1">monic=monic)</span>
    <span class="s3">if </span><span class="s1">monic:</span>
        <span class="s3">return </span><span class="s1">base</span>
    <span class="s1">factor = sqrt(pi) / </span><span class="s5">2.0 </span><span class="s1">* _gam(n + </span><span class="s5">2</span><span class="s1">) / _gam(n + </span><span class="s5">1.5</span><span class="s1">)</span>
    <span class="s1">base._scale(factor)</span>
    <span class="s3">return </span><span class="s1">base</span>

<span class="s2"># Chebyshev of the first kind        C_n(x)</span>


<span class="s3">def </span><span class="s1">roots_chebyc(n</span><span class="s3">, </span><span class="s1">mu=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s0">r&quot;&quot;&quot;Gauss-Chebyshev (first kind) quadrature. 
 
    Compute the sample points and weights for Gauss-Chebyshev 
    quadrature. The sample points are the roots of the nth degree 
    Chebyshev polynomial of the first kind, :math:`C_n(x)`. These 
    sample points and weights correctly integrate polynomials of 
    degree :math:`2n - 1` or less over the interval :math:`[-2, 2]` 
    with weight function :math:`w(x) = 1 / \sqrt{1 - (x/2)^2}`. See 
    22.2.6 in [AS]_ for more details. 
 
    Parameters 
    ---------- 
    n : int 
        quadrature order 
    mu : bool, optional 
        If True, return the sum of the weights, optional. 
 
    Returns 
    ------- 
    x : ndarray 
        Sample points 
    w : ndarray 
        Weights 
    mu : float 
        Sum of the weights 
 
    See Also 
    -------- 
    scipy.integrate.quadrature 
    scipy.integrate.fixed_quad 
 
    References 
    ---------- 
    .. [AS] Milton Abramowitz and Irene A. Stegun, eds. 
        Handbook of Mathematical Functions with Formulas, 
        Graphs, and Mathematical Tables. New York: Dover, 1972. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">x</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">m = roots_chebyt(n</span><span class="s3">, True</span><span class="s1">)</span>
    <span class="s1">x *= </span><span class="s5">2</span>
    <span class="s1">w *= </span><span class="s5">2</span>
    <span class="s1">m *= </span><span class="s5">2</span>
    <span class="s3">if </span><span class="s1">mu:</span>
        <span class="s3">return </span><span class="s1">x</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">m</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">x</span><span class="s3">, </span><span class="s1">w</span>


<span class="s3">def </span><span class="s1">chebyc(n</span><span class="s3">, </span><span class="s1">monic=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s0">r&quot;&quot;&quot;Chebyshev polynomial of the first kind on :math:`[-2, 2]`. 
 
    Defined as :math:`C_n(x) = 2T_n(x/2)`, where :math:`T_n` is the 
    nth Chebychev polynomial of the first kind. 
 
    Parameters 
    ---------- 
    n : int 
        Degree of the polynomial. 
    monic : bool, optional 
        If `True`, scale the leading coefficient to be 1. Default is 
        `False`. 
 
    Returns 
    ------- 
    C : orthopoly1d 
        Chebyshev polynomial of the first kind on :math:`[-2, 2]`. 
 
    Notes 
    ----- 
    The polynomials :math:`C_n(x)` are orthogonal over :math:`[-2, 2]` 
    with weight function :math:`1/\sqrt{1 - (x/2)^2}`. 
 
    See Also 
    -------- 
    chebyt : Chebyshev polynomial of the first kind. 
 
    References 
    ---------- 
    .. [1] Abramowitz and Stegun, &quot;Handbook of Mathematical Functions&quot; 
           Section 22. National Bureau of Standards, 1972. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">n &lt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;n must be nonnegative.&quot;</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">n == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">n1 = n + </span><span class="s5">1</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">n1 = n</span>
    <span class="s1">x</span><span class="s3">, </span><span class="s1">w = roots_chebyc(n1)</span>
    <span class="s3">if </span><span class="s1">n == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">x</span><span class="s3">, </span><span class="s1">w = []</span><span class="s3">, </span><span class="s1">[]</span>
    <span class="s1">hn = </span><span class="s5">4 </span><span class="s1">* pi * ((n == </span><span class="s5">0</span><span class="s1">) + </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">kn = </span><span class="s5">1.0</span>
    <span class="s1">p = orthopoly1d(x</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">hn</span><span class="s3">, </span><span class="s1">kn</span><span class="s3">,</span>
                    <span class="s1">wfunc=</span><span class="s3">lambda </span><span class="s1">x: </span><span class="s5">1.0 </span><span class="s1">/ sqrt(</span><span class="s5">1 </span><span class="s1">- x * x / </span><span class="s5">4.0</span><span class="s1">)</span><span class="s3">,</span>
                    <span class="s1">limits=(-</span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">, </span><span class="s1">monic=monic)</span>
    <span class="s3">if not </span><span class="s1">monic:</span>
        <span class="s1">p._scale(</span><span class="s5">2.0 </span><span class="s1">/ p(</span><span class="s5">2</span><span class="s1">))</span>
        <span class="s1">p.__dict__[</span><span class="s4">'_eval_func'</span><span class="s1">] = </span><span class="s3">lambda </span><span class="s1">x: _ufuncs.eval_chebyc(n</span><span class="s3">, </span><span class="s1">x)</span>
    <span class="s3">return </span><span class="s1">p</span>

<span class="s2"># Chebyshev of the second kind       S_n(x)</span>


<span class="s3">def </span><span class="s1">roots_chebys(n</span><span class="s3">, </span><span class="s1">mu=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s0">r&quot;&quot;&quot;Gauss-Chebyshev (second kind) quadrature. 
 
    Compute the sample points and weights for Gauss-Chebyshev 
    quadrature. The sample points are the roots of the nth degree 
    Chebyshev polynomial of the second kind, :math:`S_n(x)`. These 
    sample points and weights correctly integrate polynomials of 
    degree :math:`2n - 1` or less over the interval :math:`[-2, 2]` 
    with weight function :math:`w(x) = \sqrt{1 - (x/2)^2}`. See 22.2.7 
    in [AS]_ for more details. 
 
    Parameters 
    ---------- 
    n : int 
        quadrature order 
    mu : bool, optional 
        If True, return the sum of the weights, optional. 
 
    Returns 
    ------- 
    x : ndarray 
        Sample points 
    w : ndarray 
        Weights 
    mu : float 
        Sum of the weights 
 
    See Also 
    -------- 
    scipy.integrate.quadrature 
    scipy.integrate.fixed_quad 
 
    References 
    ---------- 
    .. [AS] Milton Abramowitz and Irene A. Stegun, eds. 
        Handbook of Mathematical Functions with Formulas, 
        Graphs, and Mathematical Tables. New York: Dover, 1972. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">x</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">m = roots_chebyu(n</span><span class="s3">, True</span><span class="s1">)</span>
    <span class="s1">x *= </span><span class="s5">2</span>
    <span class="s1">w *= </span><span class="s5">2</span>
    <span class="s1">m *= </span><span class="s5">2</span>
    <span class="s3">if </span><span class="s1">mu:</span>
        <span class="s3">return </span><span class="s1">x</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">m</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">x</span><span class="s3">, </span><span class="s1">w</span>


<span class="s3">def </span><span class="s1">chebys(n</span><span class="s3">, </span><span class="s1">monic=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s0">r&quot;&quot;&quot;Chebyshev polynomial of the second kind on :math:`[-2, 2]`. 
 
    Defined as :math:`S_n(x) = U_n(x/2)` where :math:`U_n` is the 
    nth Chebychev polynomial of the second kind. 
 
    Parameters 
    ---------- 
    n : int 
        Degree of the polynomial. 
    monic : bool, optional 
        If `True`, scale the leading coefficient to be 1. Default is 
        `False`. 
 
    Returns 
    ------- 
    S : orthopoly1d 
        Chebyshev polynomial of the second kind on :math:`[-2, 2]`. 
 
    Notes 
    ----- 
    The polynomials :math:`S_n(x)` are orthogonal over :math:`[-2, 2]` 
    with weight function :math:`\sqrt{1 - (x/2)}^2`. 
 
    See Also 
    -------- 
    chebyu : Chebyshev polynomial of the second kind 
 
    References 
    ---------- 
    .. [1] Abramowitz and Stegun, &quot;Handbook of Mathematical Functions&quot; 
           Section 22. National Bureau of Standards, 1972. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">n &lt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;n must be nonnegative.&quot;</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">n == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">n1 = n + </span><span class="s5">1</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">n1 = n</span>
    <span class="s1">x</span><span class="s3">, </span><span class="s1">w = roots_chebys(n1)</span>
    <span class="s3">if </span><span class="s1">n == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">x</span><span class="s3">, </span><span class="s1">w = []</span><span class="s3">, </span><span class="s1">[]</span>
    <span class="s1">hn = pi</span>
    <span class="s1">kn = </span><span class="s5">1.0</span>
    <span class="s1">p = orthopoly1d(x</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">hn</span><span class="s3">, </span><span class="s1">kn</span><span class="s3">,</span>
                    <span class="s1">wfunc=</span><span class="s3">lambda </span><span class="s1">x: sqrt(</span><span class="s5">1 </span><span class="s1">- x * x / </span><span class="s5">4.0</span><span class="s1">)</span><span class="s3">,</span>
                    <span class="s1">limits=(-</span><span class="s5">2</span><span class="s3">, </span><span class="s5">2</span><span class="s1">)</span><span class="s3">, </span><span class="s1">monic=monic)</span>
    <span class="s3">if not </span><span class="s1">monic:</span>
        <span class="s1">factor = (n + </span><span class="s5">1.0</span><span class="s1">) / p(</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s1">p._scale(factor)</span>
        <span class="s1">p.__dict__[</span><span class="s4">'_eval_func'</span><span class="s1">] = </span><span class="s3">lambda </span><span class="s1">x: _ufuncs.eval_chebys(n</span><span class="s3">, </span><span class="s1">x)</span>
    <span class="s3">return </span><span class="s1">p</span>

<span class="s2"># Shifted Chebyshev of the first kind     T^*_n(x)</span>


<span class="s3">def </span><span class="s1">roots_sh_chebyt(n</span><span class="s3">, </span><span class="s1">mu=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s0">r&quot;&quot;&quot;Gauss-Chebyshev (first kind, shifted) quadrature. 
 
    Compute the sample points and weights for Gauss-Chebyshev 
    quadrature. The sample points are the roots of the nth degree 
    shifted Chebyshev polynomial of the first kind, :math:`T_n(x)`. 
    These sample points and weights correctly integrate polynomials of 
    degree :math:`2n - 1` or less over the interval :math:`[0, 1]` 
    with weight function :math:`w(x) = 1/\sqrt{x - x^2}`. See 22.2.8 
    in [AS]_ for more details. 
 
    Parameters 
    ---------- 
    n : int 
        quadrature order 
    mu : bool, optional 
        If True, return the sum of the weights, optional. 
 
    Returns 
    ------- 
    x : ndarray 
        Sample points 
    w : ndarray 
        Weights 
    mu : float 
        Sum of the weights 
 
    See Also 
    -------- 
    scipy.integrate.quadrature 
    scipy.integrate.fixed_quad 
 
    References 
    ---------- 
    .. [AS] Milton Abramowitz and Irene A. Stegun, eds. 
        Handbook of Mathematical Functions with Formulas, 
        Graphs, and Mathematical Tables. New York: Dover, 1972. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">xw = roots_chebyt(n</span><span class="s3">, </span><span class="s1">mu)</span>
    <span class="s3">return </span><span class="s1">((xw[</span><span class="s5">0</span><span class="s1">] + </span><span class="s5">1</span><span class="s1">) / </span><span class="s5">2</span><span class="s3">,</span><span class="s1">) + xw[</span><span class="s5">1</span><span class="s1">:]</span>


<span class="s3">def </span><span class="s1">sh_chebyt(n</span><span class="s3">, </span><span class="s1">monic=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s0">r&quot;&quot;&quot;Shifted Chebyshev polynomial of the first kind. 
 
    Defined as :math:`T^*_n(x) = T_n(2x - 1)` for :math:`T_n` the nth 
    Chebyshev polynomial of the first kind. 
 
    Parameters 
    ---------- 
    n : int 
        Degree of the polynomial. 
    monic : bool, optional 
        If `True`, scale the leading coefficient to be 1. Default is 
        `False`. 
 
    Returns 
    ------- 
    T : orthopoly1d 
        Shifted Chebyshev polynomial of the first kind. 
 
    Notes 
    ----- 
    The polynomials :math:`T^*_n` are orthogonal over :math:`[0, 1]` 
    with weight function :math:`(x - x^2)^{-1/2}`. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">base = sh_jacobi(n</span><span class="s3">, </span><span class="s5">0.0</span><span class="s3">, </span><span class="s5">0.5</span><span class="s3">, </span><span class="s1">monic=monic)</span>
    <span class="s3">if </span><span class="s1">monic:</span>
        <span class="s3">return </span><span class="s1">base</span>
    <span class="s3">if </span><span class="s1">n &gt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">factor = </span><span class="s5">4</span><span class="s1">**n / </span><span class="s5">2.0</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">factor = </span><span class="s5">1.0</span>
    <span class="s1">base._scale(factor)</span>
    <span class="s3">return </span><span class="s1">base</span>


<span class="s2"># Shifted Chebyshev of the second kind    U^*_n(x)</span>
<span class="s3">def </span><span class="s1">roots_sh_chebyu(n</span><span class="s3">, </span><span class="s1">mu=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s0">r&quot;&quot;&quot;Gauss-Chebyshev (second kind, shifted) quadrature. 
 
    Computes the sample points and weights for Gauss-Chebyshev 
    quadrature. The sample points are the roots of the nth degree 
    shifted Chebyshev polynomial of the second kind, :math:`U_n(x)`. 
    These sample points and weights correctly integrate polynomials of 
    degree :math:`2n - 1` or less over the interval :math:`[0, 1]` 
    with weight function :math:`w(x) = \sqrt{x - x^2}`. See 22.2.9 in 
    [AS]_ for more details. 
 
    Parameters 
    ---------- 
    n : int 
        quadrature order 
    mu : bool, optional 
        If True, return the sum of the weights, optional. 
 
    Returns 
    ------- 
    x : ndarray 
        Sample points 
    w : ndarray 
        Weights 
    mu : float 
        Sum of the weights 
 
    See Also 
    -------- 
    scipy.integrate.quadrature 
    scipy.integrate.fixed_quad 
 
    References 
    ---------- 
    .. [AS] Milton Abramowitz and Irene A. Stegun, eds. 
        Handbook of Mathematical Functions with Formulas, 
        Graphs, and Mathematical Tables. New York: Dover, 1972. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">x</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">m = roots_chebyu(n</span><span class="s3">, True</span><span class="s1">)</span>
    <span class="s1">x = (x + </span><span class="s5">1</span><span class="s1">) / </span><span class="s5">2</span>
    <span class="s1">m_us = _ufuncs.beta(</span><span class="s5">1.5</span><span class="s3">, </span><span class="s5">1.5</span><span class="s1">)</span>
    <span class="s1">w *= m_us / m</span>
    <span class="s3">if </span><span class="s1">mu:</span>
        <span class="s3">return </span><span class="s1">x</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">m_us</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">x</span><span class="s3">, </span><span class="s1">w</span>


<span class="s3">def </span><span class="s1">sh_chebyu(n</span><span class="s3">, </span><span class="s1">monic=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s0">r&quot;&quot;&quot;Shifted Chebyshev polynomial of the second kind. 
 
    Defined as :math:`U^*_n(x) = U_n(2x - 1)` for :math:`U_n` the nth 
    Chebyshev polynomial of the second kind. 
 
    Parameters 
    ---------- 
    n : int 
        Degree of the polynomial. 
    monic : bool, optional 
        If `True`, scale the leading coefficient to be 1. Default is 
        `False`. 
 
    Returns 
    ------- 
    U : orthopoly1d 
        Shifted Chebyshev polynomial of the second kind. 
 
    Notes 
    ----- 
    The polynomials :math:`U^*_n` are orthogonal over :math:`[0, 1]` 
    with weight function :math:`(x - x^2)^{1/2}`. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">base = sh_jacobi(n</span><span class="s3">, </span><span class="s5">2.0</span><span class="s3">, </span><span class="s5">1.5</span><span class="s3">, </span><span class="s1">monic=monic)</span>
    <span class="s3">if </span><span class="s1">monic:</span>
        <span class="s3">return </span><span class="s1">base</span>
    <span class="s1">factor = </span><span class="s5">4</span><span class="s1">**n</span>
    <span class="s1">base._scale(factor)</span>
    <span class="s3">return </span><span class="s1">base</span>

<span class="s2"># Legendre</span>


<span class="s3">def </span><span class="s1">roots_legendre(n</span><span class="s3">, </span><span class="s1">mu=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s0">r&quot;&quot;&quot;Gauss-Legendre quadrature. 
 
    Compute the sample points and weights for Gauss-Legendre 
    quadrature [GL]_. The sample points are the roots of the nth degree 
    Legendre polynomial :math:`P_n(x)`. These sample points and 
    weights correctly integrate polynomials of degree :math:`2n - 1` 
    or less over the interval :math:`[-1, 1]` with weight function 
    :math:`w(x) = 1`. See 2.2.10 in [AS]_ for more details. 
 
    Parameters 
    ---------- 
    n : int 
        quadrature order 
    mu : bool, optional 
        If True, return the sum of the weights, optional. 
 
    Returns 
    ------- 
    x : ndarray 
        Sample points 
    w : ndarray 
        Weights 
    mu : float 
        Sum of the weights 
 
    See Also 
    -------- 
    scipy.integrate.quadrature 
    scipy.integrate.fixed_quad 
    numpy.polynomial.legendre.leggauss 
 
    References 
    ---------- 
    .. [AS] Milton Abramowitz and Irene A. Stegun, eds. 
        Handbook of Mathematical Functions with Formulas, 
        Graphs, and Mathematical Tables. New York: Dover, 1972. 
    .. [GL] Gauss-Legendre quadrature, Wikipedia, 
        https://en.wikipedia.org/wiki/Gauss%E2%80%93Legendre_quadrature 
 
    Examples 
    -------- 
    &gt;&gt;&gt; import numpy as np 
    &gt;&gt;&gt; from scipy.special import roots_legendre, eval_legendre 
    &gt;&gt;&gt; roots, weights = roots_legendre(9) 
 
    ``roots`` holds the roots, and ``weights`` holds the weights for 
    Gauss-Legendre quadrature. 
 
    &gt;&gt;&gt; roots 
    array([-0.96816024, -0.83603111, -0.61337143, -0.32425342,  0.        , 
            0.32425342,  0.61337143,  0.83603111,  0.96816024]) 
    &gt;&gt;&gt; weights 
    array([0.08127439, 0.18064816, 0.2606107 , 0.31234708, 0.33023936, 
           0.31234708, 0.2606107 , 0.18064816, 0.08127439]) 
 
    Verify that we have the roots by evaluating the degree 9 Legendre 
    polynomial at ``roots``.  All the values are approximately zero: 
 
    &gt;&gt;&gt; eval_legendre(9, roots) 
    array([-8.88178420e-16, -2.22044605e-16,  1.11022302e-16,  1.11022302e-16, 
            0.00000000e+00, -5.55111512e-17, -1.94289029e-16,  1.38777878e-16, 
           -8.32667268e-17]) 
 
    Here we'll show how the above values can be used to estimate the 
    integral from 1 to 2 of f(t) = t + 1/t with Gauss-Legendre 
    quadrature [GL]_.  First define the function and the integration 
    limits. 
 
    &gt;&gt;&gt; def f(t): 
    ...    return t + 1/t 
    ... 
    &gt;&gt;&gt; a = 1 
    &gt;&gt;&gt; b = 2 
 
    We'll use ``integral(f(t), t=a, t=b)`` to denote the definite integral 
    of f from t=a to t=b.  The sample points in ``roots`` are from the 
    interval [-1, 1], so we'll rewrite the integral with the simple change 
    of variable:: 
 
        x = 2/(b - a) * t - (a + b)/(b - a) 
 
    with inverse:: 
 
        t = (b - a)/2 * x + (a + 2)/2 
 
    Then:: 
 
        integral(f(t), a, b) = 
            (b - a)/2 * integral(f((b-a)/2*x + (a+b)/2), x=-1, x=1) 
 
    We can approximate the latter integral with the values returned 
    by `roots_legendre`. 
 
    Map the roots computed above from [-1, 1] to [a, b]. 
 
    &gt;&gt;&gt; t = (b - a)/2 * roots + (a + b)/2 
 
    Approximate the integral as the weighted sum of the function values. 
 
    &gt;&gt;&gt; (b - a)/2 * f(t).dot(weights) 
    2.1931471805599276 
 
    Compare that to the exact result, which is 3/2 + log(2): 
 
    &gt;&gt;&gt; 1.5 + np.log(2) 
    2.1931471805599454 
 
    &quot;&quot;&quot;</span>
    <span class="s1">m = int(n)</span>
    <span class="s3">if </span><span class="s1">n &lt; </span><span class="s5">1 </span><span class="s3">or </span><span class="s1">n != m:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;n must be a positive integer.&quot;</span><span class="s1">)</span>

    <span class="s1">mu0 = </span><span class="s5">2.0</span>
    <span class="s3">def </span><span class="s1">an_func(k):</span>
        <span class="s3">return </span><span class="s5">0.0 </span><span class="s1">* k</span>
    <span class="s3">def </span><span class="s1">bn_func(k):</span>
        <span class="s3">return </span><span class="s1">k * np.sqrt(</span><span class="s5">1.0 </span><span class="s1">/ (</span><span class="s5">4 </span><span class="s1">* k * k - </span><span class="s5">1</span><span class="s1">))</span>
    <span class="s1">f = _ufuncs.eval_legendre</span>
    <span class="s3">def </span><span class="s1">df(n</span><span class="s3">, </span><span class="s1">x):</span>
        <span class="s3">return </span><span class="s1">(-n * x * _ufuncs.eval_legendre(n</span><span class="s3">, </span><span class="s1">x) + n * _ufuncs.eval_legendre(n - </span><span class="s5">1</span><span class="s3">, </span><span class="s1">x)) / (</span><span class="s5">1 </span><span class="s1">- x ** </span><span class="s5">2</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">_gen_roots_and_weights(m</span><span class="s3">, </span><span class="s1">mu0</span><span class="s3">, </span><span class="s1">an_func</span><span class="s3">, </span><span class="s1">bn_func</span><span class="s3">, </span><span class="s1">f</span><span class="s3">, </span><span class="s1">df</span><span class="s3">, True, </span><span class="s1">mu)</span>


<span class="s3">def </span><span class="s1">legendre(n</span><span class="s3">, </span><span class="s1">monic=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s0">r&quot;&quot;&quot;Legendre polynomial. 
 
    Defined to be the solution of 
 
    .. math:: 
        \frac{d}{dx}\left[(1 - x^2)\frac{d}{dx}P_n(x)\right] 
          + n(n + 1)P_n(x) = 0; 
 
    :math:`P_n(x)` is a polynomial of degree :math:`n`. 
 
    Parameters 
    ---------- 
    n : int 
        Degree of the polynomial. 
    monic : bool, optional 
        If `True`, scale the leading coefficient to be 1. Default is 
        `False`. 
 
    Returns 
    ------- 
    P : orthopoly1d 
        Legendre polynomial. 
 
    Notes 
    ----- 
    The polynomials :math:`P_n` are orthogonal over :math:`[-1, 1]` 
    with weight function 1. 
 
    Examples 
    -------- 
    Generate the 3rd-order Legendre polynomial 1/2*(5x^3 + 0x^2 - 3x + 0): 
 
    &gt;&gt;&gt; from scipy.special import legendre 
    &gt;&gt;&gt; legendre(3) 
    poly1d([ 2.5,  0. , -1.5,  0. ]) 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">n &lt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;n must be nonnegative.&quot;</span><span class="s1">)</span>

    <span class="s3">if </span><span class="s1">n == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">n1 = n + </span><span class="s5">1</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">n1 = n</span>
    <span class="s1">x</span><span class="s3">, </span><span class="s1">w = roots_legendre(n1)</span>
    <span class="s3">if </span><span class="s1">n == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">x</span><span class="s3">, </span><span class="s1">w = []</span><span class="s3">, </span><span class="s1">[]</span>
    <span class="s1">hn = </span><span class="s5">2.0 </span><span class="s1">/ (</span><span class="s5">2 </span><span class="s1">* n + </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">kn = _gam(</span><span class="s5">2 </span><span class="s1">* n + </span><span class="s5">1</span><span class="s1">) / _gam(n + </span><span class="s5">1</span><span class="s1">)**</span><span class="s5">2 </span><span class="s1">/ </span><span class="s5">2.0</span><span class="s1">**n</span>
    <span class="s1">p = orthopoly1d(x</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">hn</span><span class="s3">, </span><span class="s1">kn</span><span class="s3">, </span><span class="s1">wfunc=</span><span class="s3">lambda </span><span class="s1">x: </span><span class="s5">1.0</span><span class="s3">, </span><span class="s1">limits=(-</span><span class="s5">1</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">,</span>
                    <span class="s1">monic=monic</span><span class="s3">,</span>
                    <span class="s1">eval_func=</span><span class="s3">lambda </span><span class="s1">x: _ufuncs.eval_legendre(n</span><span class="s3">, </span><span class="s1">x))</span>
    <span class="s3">return </span><span class="s1">p</span>

<span class="s2"># Shifted Legendre              P^*_n(x)</span>


<span class="s3">def </span><span class="s1">roots_sh_legendre(n</span><span class="s3">, </span><span class="s1">mu=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s0">r&quot;&quot;&quot;Gauss-Legendre (shifted) quadrature. 
 
    Compute the sample points and weights for Gauss-Legendre 
    quadrature. The sample points are the roots of the nth degree 
    shifted Legendre polynomial :math:`P^*_n(x)`. These sample points 
    and weights correctly integrate polynomials of degree :math:`2n - 
    1` or less over the interval :math:`[0, 1]` with weight function 
    :math:`w(x) = 1.0`. See 2.2.11 in [AS]_ for details. 
 
    Parameters 
    ---------- 
    n : int 
        quadrature order 
    mu : bool, optional 
        If True, return the sum of the weights, optional. 
 
    Returns 
    ------- 
    x : ndarray 
        Sample points 
    w : ndarray 
        Weights 
    mu : float 
        Sum of the weights 
 
    See Also 
    -------- 
    scipy.integrate.quadrature 
    scipy.integrate.fixed_quad 
 
    References 
    ---------- 
    .. [AS] Milton Abramowitz and Irene A. Stegun, eds. 
        Handbook of Mathematical Functions with Formulas, 
        Graphs, and Mathematical Tables. New York: Dover, 1972. 
 
    &quot;&quot;&quot;</span>
    <span class="s1">x</span><span class="s3">, </span><span class="s1">w = roots_legendre(n)</span>
    <span class="s1">x = (x + </span><span class="s5">1</span><span class="s1">) / </span><span class="s5">2</span>
    <span class="s1">w /= </span><span class="s5">2</span>
    <span class="s3">if </span><span class="s1">mu:</span>
        <span class="s3">return </span><span class="s1">x</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s5">1.0</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">x</span><span class="s3">, </span><span class="s1">w</span>


<span class="s3">def </span><span class="s1">sh_legendre(n</span><span class="s3">, </span><span class="s1">monic=</span><span class="s3">False</span><span class="s1">):</span>
    <span class="s0">r&quot;&quot;&quot;Shifted Legendre polynomial. 
 
    Defined as :math:`P^*_n(x) = P_n(2x - 1)` for :math:`P_n` the nth 
    Legendre polynomial. 
 
    Parameters 
    ---------- 
    n : int 
        Degree of the polynomial. 
    monic : bool, optional 
        If `True`, scale the leading coefficient to be 1. Default is 
        `False`. 
 
    Returns 
    ------- 
    P : orthopoly1d 
        Shifted Legendre polynomial. 
 
    Notes 
    ----- 
    The polynomials :math:`P^*_n` are orthogonal over :math:`[0, 1]` 
    with weight function 1. 
 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">n &lt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;n must be nonnegative.&quot;</span><span class="s1">)</span>

    <span class="s3">def </span><span class="s1">wfunc(x):</span>
        <span class="s3">return </span><span class="s5">0.0 </span><span class="s1">* x + </span><span class="s5">1.0</span>
    <span class="s3">if </span><span class="s1">n == </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">orthopoly1d([]</span><span class="s3">, </span><span class="s1">[]</span><span class="s3">, </span><span class="s5">1.0</span><span class="s3">, </span><span class="s5">1.0</span><span class="s3">, </span><span class="s1">wfunc</span><span class="s3">, </span><span class="s1">(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">monic</span><span class="s3">,</span>
                           <span class="s3">lambda </span><span class="s1">x: _ufuncs.eval_sh_legendre(n</span><span class="s3">, </span><span class="s1">x))</span>
    <span class="s1">x</span><span class="s3">, </span><span class="s1">w = roots_sh_legendre(n)</span>
    <span class="s1">hn = </span><span class="s5">1.0 </span><span class="s1">/ (</span><span class="s5">2 </span><span class="s1">* n + </span><span class="s5">1.0</span><span class="s1">)</span>
    <span class="s1">kn = _gam(</span><span class="s5">2 </span><span class="s1">* n + </span><span class="s5">1</span><span class="s1">) / _gam(n + </span><span class="s5">1</span><span class="s1">)**</span><span class="s5">2</span>
    <span class="s1">p = orthopoly1d(x</span><span class="s3">, </span><span class="s1">w</span><span class="s3">, </span><span class="s1">hn</span><span class="s3">, </span><span class="s1">kn</span><span class="s3">, </span><span class="s1">wfunc</span><span class="s3">, </span><span class="s1">limits=(</span><span class="s5">0</span><span class="s3">, </span><span class="s5">1</span><span class="s1">)</span><span class="s3">, </span><span class="s1">monic=monic</span><span class="s3">,</span>
                    <span class="s1">eval_func=</span><span class="s3">lambda </span><span class="s1">x: _ufuncs.eval_sh_legendre(n</span><span class="s3">, </span><span class="s1">x))</span>
    <span class="s3">return </span><span class="s1">p</span>


<span class="s2"># Make the old root function names an alias for the new ones</span>
<span class="s1">_modattrs = globals()</span>
<span class="s3">for </span><span class="s1">newfun</span><span class="s3">, </span><span class="s1">oldfun </span><span class="s3">in </span><span class="s1">_rootfuns_map.items():</span>
    <span class="s1">_modattrs[oldfun] = _modattrs[newfun]</span>
    <span class="s1">__all__.append(oldfun)</span>
</pre>
</body>
</html>