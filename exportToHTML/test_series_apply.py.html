<html>
<head>
<title>test_series_apply.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
test_series_apply.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">numpy </span><span class="s0">as </span><span class="s1">np</span>
<span class="s0">import </span><span class="s1">pytest</span>

<span class="s0">import </span><span class="s1">pandas </span><span class="s0">as </span><span class="s1">pd</span>
<span class="s0">from </span><span class="s1">pandas </span><span class="s0">import </span><span class="s1">(</span>
    <span class="s1">DataFrame</span><span class="s0">,</span>
    <span class="s1">Index</span><span class="s0">,</span>
    <span class="s1">MultiIndex</span><span class="s0">,</span>
    <span class="s1">Series</span><span class="s0">,</span>
    <span class="s1">concat</span><span class="s0">,</span>
    <span class="s1">timedelta_range</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">import </span><span class="s1">pandas._testing </span><span class="s0">as </span><span class="s1">tm</span>
<span class="s0">from </span><span class="s1">pandas.tests.apply.common </span><span class="s0">import </span><span class="s1">series_transform_kernels</span>


<span class="s1">@pytest.fixture(params=[</span><span class="s0">False, </span><span class="s2">&quot;compat&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">by_row(request):</span>
    <span class="s0">return </span><span class="s1">request.param</span>


<span class="s0">def </span><span class="s1">test_series_map_box_timedelta(by_row):</span>
    <span class="s3"># GH#11349</span>
    <span class="s1">ser = Series(timedelta_range(</span><span class="s2">&quot;1 day 1 s&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s4">3</span><span class="s0">, </span><span class="s1">freq=</span><span class="s2">&quot;h&quot;</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">f(x):</span>
        <span class="s0">return </span><span class="s1">x.total_seconds() </span><span class="s0">if </span><span class="s1">by_row </span><span class="s0">else </span><span class="s1">x.dt.total_seconds()</span>

    <span class="s1">result = ser.apply(f</span><span class="s0">, </span><span class="s1">by_row=by_row)</span>

    <span class="s1">expected = ser.map(</span><span class="s0">lambda </span><span class="s1">x: x.total_seconds())</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">expected = Series([</span><span class="s4">86401.0</span><span class="s0">, </span><span class="s4">90001.0</span><span class="s0">, </span><span class="s4">93601.0</span><span class="s1">])</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_apply(datetime_series</span><span class="s0">, </span><span class="s1">by_row):</span>
    <span class="s1">result = datetime_series.apply(np.sqrt</span><span class="s0">, </span><span class="s1">by_row=by_row)</span>
    <span class="s0">with </span><span class="s1">np.errstate(all=</span><span class="s2">&quot;ignore&quot;</span><span class="s1">):</span>
        <span class="s1">expected = np.sqrt(datetime_series)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s3"># element-wise apply (ufunc)</span>
    <span class="s1">result = datetime_series.apply(np.exp</span><span class="s0">, </span><span class="s1">by_row=by_row)</span>
    <span class="s1">expected = np.exp(datetime_series)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s3"># empty series</span>
    <span class="s1">s = Series(dtype=object</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;foo&quot;</span><span class="s0">, </span><span class="s1">index=Index([]</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;bar&quot;</span><span class="s1">))</span>
    <span class="s1">rs = s.apply(</span><span class="s0">lambda </span><span class="s1">x: x</span><span class="s0">, </span><span class="s1">by_row=by_row)</span>
    <span class="s1">tm.assert_series_equal(s</span><span class="s0">, </span><span class="s1">rs)</span>

    <span class="s3"># check all metadata (GH 9322)</span>
    <span class="s0">assert </span><span class="s1">s </span><span class="s0">is not </span><span class="s1">rs</span>
    <span class="s0">assert </span><span class="s1">s.index </span><span class="s0">is </span><span class="s1">rs.index</span>
    <span class="s0">assert </span><span class="s1">s.dtype == rs.dtype</span>
    <span class="s0">assert </span><span class="s1">s.name == rs.name</span>

    <span class="s3"># index but no data</span>
    <span class="s1">s = Series(index=[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">dtype=np.float64)</span>
    <span class="s1">rs = s.apply(</span><span class="s0">lambda </span><span class="s1">x: x</span><span class="s0">, </span><span class="s1">by_row=by_row)</span>
    <span class="s1">tm.assert_series_equal(s</span><span class="s0">, </span><span class="s1">rs)</span>


<span class="s0">def </span><span class="s1">test_apply_map_same_length_inference_bug():</span>
    <span class="s1">s = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">f(x):</span>
        <span class="s0">return </span><span class="s1">(x</span><span class="s0">, </span><span class="s1">x + </span><span class="s4">1</span><span class="s1">)</span>

    <span class="s1">result = s.apply(f</span><span class="s0">, </span><span class="s1">by_row=</span><span class="s2">&quot;compat&quot;</span><span class="s1">)</span>
    <span class="s1">expected = s.map(f)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;convert_dtype&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_apply_convert_dtype_deprecated(convert_dtype):</span>
    <span class="s1">ser = Series(np.random.default_rng(</span><span class="s4">2</span><span class="s1">).standard_normal(</span><span class="s4">10</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">func(x):</span>
        <span class="s0">return </span><span class="s1">x </span><span class="s0">if </span><span class="s1">x &gt; </span><span class="s4">0 </span><span class="s0">else </span><span class="s1">np.nan</span>

    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning):</span>
        <span class="s1">ser.apply(func</span><span class="s0">, </span><span class="s1">convert_dtype=convert_dtype</span><span class="s0">, </span><span class="s1">by_row=</span><span class="s2">&quot;compat&quot;</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_apply_args():</span>
    <span class="s1">s = Series([</span><span class="s2">&quot;foo,bar&quot;</span><span class="s1">])</span>

    <span class="s1">result = s.apply(str.split</span><span class="s0">, </span><span class="s1">args=(</span><span class="s2">&quot;,&quot;</span><span class="s0">,</span><span class="s1">))</span>
    <span class="s0">assert </span><span class="s1">result[</span><span class="s4">0</span><span class="s1">] == [</span><span class="s2">&quot;foo&quot;</span><span class="s0">, </span><span class="s2">&quot;bar&quot;</span><span class="s1">]</span>
    <span class="s0">assert </span><span class="s1">isinstance(result[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">list)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;args, kwargs, increment&quot;</span><span class="s0">,</span>
    <span class="s1">[(()</span><span class="s0">, </span><span class="s1">{}</span><span class="s0">, </span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">(()</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;a&quot;</span><span class="s1">: </span><span class="s4">1</span><span class="s1">}</span><span class="s0">, </span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">((</span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">{}</span><span class="s0">, </span><span class="s4">32</span><span class="s1">)</span><span class="s0">, </span><span class="s1">((</span><span class="s4">1</span><span class="s0">,</span><span class="s1">)</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;c&quot;</span><span class="s1">: </span><span class="s4">2</span><span class="s1">}</span><span class="s0">, </span><span class="s4">201</span><span class="s1">)]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_agg_args(args</span><span class="s0">, </span><span class="s1">kwargs</span><span class="s0">, </span><span class="s1">increment):</span>
    <span class="s3"># GH 43357</span>
    <span class="s0">def </span><span class="s1">f(x</span><span class="s0">, </span><span class="s1">a=</span><span class="s4">0</span><span class="s0">, </span><span class="s1">b=</span><span class="s4">0</span><span class="s0">, </span><span class="s1">c=</span><span class="s4">0</span><span class="s1">):</span>
        <span class="s0">return </span><span class="s1">x + a + </span><span class="s4">10 </span><span class="s1">* b + </span><span class="s4">100 </span><span class="s1">* c</span>

    <span class="s1">s = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">])</span>
    <span class="s1">msg = (</span>
        <span class="s2">&quot;in Series.agg cannot aggregate and has been deprecated. &quot;</span>
        <span class="s2">&quot;Use Series.transform to keep behavior unchanged.&quot;</span>
    <span class="s1">)</span>
    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">result = s.agg(f</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s1">*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s1">expected = s + increment</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_agg_mapping_func_deprecated():</span>
    <span class="s3"># GH 53325</span>
    <span class="s1">s = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">foo1(x</span><span class="s0">, </span><span class="s1">a=</span><span class="s4">1</span><span class="s0">, </span><span class="s1">c=</span><span class="s4">0</span><span class="s1">):</span>
        <span class="s0">return </span><span class="s1">x + a + c</span>

    <span class="s0">def </span><span class="s1">foo2(x</span><span class="s0">, </span><span class="s1">b=</span><span class="s4">2</span><span class="s0">, </span><span class="s1">c=</span><span class="s4">0</span><span class="s1">):</span>
        <span class="s0">return </span><span class="s1">x + b + c</span>

    <span class="s1">msg = </span><span class="s2">&quot;using .+ in Series.agg cannot aggregate and&quot;</span>
    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">s.agg(foo1</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s1">c=</span><span class="s4">4</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">s.agg([foo1</span><span class="s0">, </span><span class="s1">foo2]</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s1">c=</span><span class="s4">4</span><span class="s1">)</span>
    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">s.agg({</span><span class="s2">&quot;a&quot;</span><span class="s1">: foo1</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s1">: foo2}</span><span class="s0">, </span><span class="s4">0</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s1">c=</span><span class="s4">4</span><span class="s1">)</span>


<span class="s0">def </span><span class="s1">test_series_apply_map_box_timestamps(by_row):</span>
    <span class="s3"># GH#2689, GH#2627</span>
    <span class="s1">ser = Series(pd.date_range(</span><span class="s2">&quot;1/1/2000&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s4">10</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">func(x):</span>
        <span class="s0">return </span><span class="s1">(x.hour</span><span class="s0">, </span><span class="s1">x.day</span><span class="s0">, </span><span class="s1">x.month)</span>

    <span class="s0">if not </span><span class="s1">by_row:</span>
        <span class="s1">msg = </span><span class="s2">&quot;Series' object has no attribute 'hour'&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(AttributeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">ser.apply(func</span><span class="s0">, </span><span class="s1">by_row=by_row)</span>
        <span class="s0">return</span>

    <span class="s1">result = ser.apply(func</span><span class="s0">, </span><span class="s1">by_row=by_row)</span>
    <span class="s1">expected = ser.map(func)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_apply_box():</span>
    <span class="s3"># ufunc will not be boxed. Same test cases as the test_map_box</span>
    <span class="s1">vals = [pd.Timestamp(</span><span class="s2">&quot;2011-01-01&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pd.Timestamp(</span><span class="s2">&quot;2011-01-02&quot;</span><span class="s1">)]</span>
    <span class="s1">s = Series(vals)</span>
    <span class="s0">assert </span><span class="s1">s.dtype == </span><span class="s2">&quot;datetime64[ns]&quot;</span>
    <span class="s3"># boxed value must be Timestamp instance</span>
    <span class="s1">res = s.apply(</span><span class="s0">lambda </span><span class="s1">x: </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">type(x).__name__</span><span class="s0">}</span><span class="s2">_</span><span class="s0">{</span><span class="s1">x.day</span><span class="s0">}</span><span class="s2">_</span><span class="s0">{</span><span class="s1">x.tz</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s0">, </span><span class="s1">by_row=</span><span class="s2">&quot;compat&quot;</span><span class="s1">)</span>
    <span class="s1">exp = Series([</span><span class="s2">&quot;Timestamp_1_None&quot;</span><span class="s0">, </span><span class="s2">&quot;Timestamp_2_None&quot;</span><span class="s1">])</span>
    <span class="s1">tm.assert_series_equal(res</span><span class="s0">, </span><span class="s1">exp)</span>

    <span class="s1">vals = [</span>
        <span class="s1">pd.Timestamp(</span><span class="s2">&quot;2011-01-01&quot;</span><span class="s0">, </span><span class="s1">tz=</span><span class="s2">&quot;US/Eastern&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">pd.Timestamp(</span><span class="s2">&quot;2011-01-02&quot;</span><span class="s0">, </span><span class="s1">tz=</span><span class="s2">&quot;US/Eastern&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span>
    <span class="s1">s = Series(vals)</span>
    <span class="s0">assert </span><span class="s1">s.dtype == </span><span class="s2">&quot;datetime64[ns, US/Eastern]&quot;</span>
    <span class="s1">res = s.apply(</span><span class="s0">lambda </span><span class="s1">x: </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">type(x).__name__</span><span class="s0">}</span><span class="s2">_</span><span class="s0">{</span><span class="s1">x.day</span><span class="s0">}</span><span class="s2">_</span><span class="s0">{</span><span class="s1">x.tz</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s0">, </span><span class="s1">by_row=</span><span class="s2">&quot;compat&quot;</span><span class="s1">)</span>
    <span class="s1">exp = Series([</span><span class="s2">&quot;Timestamp_1_US/Eastern&quot;</span><span class="s0">, </span><span class="s2">&quot;Timestamp_2_US/Eastern&quot;</span><span class="s1">])</span>
    <span class="s1">tm.assert_series_equal(res</span><span class="s0">, </span><span class="s1">exp)</span>

    <span class="s3"># timedelta</span>
    <span class="s1">vals = [pd.Timedelta(</span><span class="s2">&quot;1 days&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pd.Timedelta(</span><span class="s2">&quot;2 days&quot;</span><span class="s1">)]</span>
    <span class="s1">s = Series(vals)</span>
    <span class="s0">assert </span><span class="s1">s.dtype == </span><span class="s2">&quot;timedelta64[ns]&quot;</span>
    <span class="s1">res = s.apply(</span><span class="s0">lambda </span><span class="s1">x: </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">type(x).__name__</span><span class="s0">}</span><span class="s2">_</span><span class="s0">{</span><span class="s1">x.days</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s0">, </span><span class="s1">by_row=</span><span class="s2">&quot;compat&quot;</span><span class="s1">)</span>
    <span class="s1">exp = Series([</span><span class="s2">&quot;Timedelta_1&quot;</span><span class="s0">, </span><span class="s2">&quot;Timedelta_2&quot;</span><span class="s1">])</span>
    <span class="s1">tm.assert_series_equal(res</span><span class="s0">, </span><span class="s1">exp)</span>

    <span class="s3"># period</span>
    <span class="s1">vals = [pd.Period(</span><span class="s2">&quot;2011-01-01&quot;</span><span class="s0">, </span><span class="s1">freq=</span><span class="s2">&quot;M&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">pd.Period(</span><span class="s2">&quot;2011-01-02&quot;</span><span class="s0">, </span><span class="s1">freq=</span><span class="s2">&quot;M&quot;</span><span class="s1">)]</span>
    <span class="s1">s = Series(vals)</span>
    <span class="s0">assert </span><span class="s1">s.dtype == </span><span class="s2">&quot;Period[M]&quot;</span>
    <span class="s1">res = s.apply(</span><span class="s0">lambda </span><span class="s1">x: </span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">type(x).__name__</span><span class="s0">}</span><span class="s2">_</span><span class="s0">{</span><span class="s1">x.freqstr</span><span class="s0">}</span><span class="s2">&quot;</span><span class="s0">, </span><span class="s1">by_row=</span><span class="s2">&quot;compat&quot;</span><span class="s1">)</span>
    <span class="s1">exp = Series([</span><span class="s2">&quot;Period_M&quot;</span><span class="s0">, </span><span class="s2">&quot;Period_M&quot;</span><span class="s1">])</span>
    <span class="s1">tm.assert_series_equal(res</span><span class="s0">, </span><span class="s1">exp)</span>


<span class="s0">def </span><span class="s1">test_apply_datetimetz(by_row):</span>
    <span class="s1">values = pd.date_range(</span><span class="s2">&quot;2011-01-01&quot;</span><span class="s0">, </span><span class="s2">&quot;2011-01-02&quot;</span><span class="s0">, </span><span class="s1">freq=</span><span class="s2">&quot;H&quot;</span><span class="s1">).tz_localize(</span>
        <span class="s2">&quot;Asia/Tokyo&quot;</span>
    <span class="s1">)</span>
    <span class="s1">s = Series(values</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;XX&quot;</span><span class="s1">)</span>

    <span class="s1">result = s.apply(</span><span class="s0">lambda </span><span class="s1">x: x + pd.offsets.Day()</span><span class="s0">, </span><span class="s1">by_row=by_row)</span>
    <span class="s1">exp_values = pd.date_range(</span><span class="s2">&quot;2011-01-02&quot;</span><span class="s0">, </span><span class="s2">&quot;2011-01-03&quot;</span><span class="s0">, </span><span class="s1">freq=</span><span class="s2">&quot;H&quot;</span><span class="s1">).tz_localize(</span>
        <span class="s2">&quot;Asia/Tokyo&quot;</span>
    <span class="s1">)</span>
    <span class="s1">exp = Series(exp_values</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;XX&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">exp)</span>

    <span class="s1">result = s.apply(</span><span class="s0">lambda </span><span class="s1">x: x.hour </span><span class="s0">if </span><span class="s1">by_row </span><span class="s0">else </span><span class="s1">x.dt.hour</span><span class="s0">, </span><span class="s1">by_row=by_row)</span>
    <span class="s1">exp = Series(list(range(</span><span class="s4">24</span><span class="s1">)) + [</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;XX&quot;</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;int64&quot; </span><span class="s0">if </span><span class="s1">by_row </span><span class="s0">else </span><span class="s2">&quot;int32&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">exp)</span>

    <span class="s3"># not vectorized</span>
    <span class="s0">def </span><span class="s1">f(x):</span>
        <span class="s0">return </span><span class="s1">str(x.tz) </span><span class="s0">if </span><span class="s1">by_row </span><span class="s0">else </span><span class="s1">str(x.dt.tz)</span>

    <span class="s1">result = s.apply(f</span><span class="s0">, </span><span class="s1">by_row=by_row)</span>
    <span class="s0">if </span><span class="s1">by_row:</span>
        <span class="s1">exp = Series([</span><span class="s2">&quot;Asia/Tokyo&quot;</span><span class="s1">] * </span><span class="s4">25</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;XX&quot;</span><span class="s1">)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">exp)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">result == </span><span class="s2">&quot;Asia/Tokyo&quot;</span>


<span class="s0">def </span><span class="s1">test_apply_categorical(by_row):</span>
    <span class="s1">values = pd.Categorical(list(</span><span class="s2">&quot;ABBABCD&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">categories=list(</span><span class="s2">&quot;DCBA&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">ordered=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">ser = Series(values</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;XX&quot;</span><span class="s0">, </span><span class="s1">index=list(</span><span class="s2">&quot;abcdefg&quot;</span><span class="s1">))</span>

    <span class="s0">if not </span><span class="s1">by_row:</span>
        <span class="s1">msg = </span><span class="s2">&quot;Series' object has no attribute 'lower&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(AttributeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">ser.apply(</span><span class="s0">lambda </span><span class="s1">x: x.lower()</span><span class="s0">, </span><span class="s1">by_row=by_row)</span>
        <span class="s0">assert </span><span class="s1">ser.apply(</span><span class="s0">lambda </span><span class="s1">x: </span><span class="s2">&quot;A&quot;</span><span class="s0">, </span><span class="s1">by_row=by_row) == </span><span class="s2">&quot;A&quot;</span>
        <span class="s0">return</span>

    <span class="s1">result = ser.apply(</span><span class="s0">lambda </span><span class="s1">x: x.lower()</span><span class="s0">, </span><span class="s1">by_row=by_row)</span>

    <span class="s3"># should be categorical dtype when the number of categories are</span>
    <span class="s3"># the same</span>
    <span class="s1">values = pd.Categorical(list(</span><span class="s2">&quot;abbabcd&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">categories=list(</span><span class="s2">&quot;dcba&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">ordered=</span><span class="s0">True</span><span class="s1">)</span>
    <span class="s1">exp = Series(values</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;XX&quot;</span><span class="s0">, </span><span class="s1">index=list(</span><span class="s2">&quot;abcdefg&quot;</span><span class="s1">))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">exp)</span>
    <span class="s1">tm.assert_categorical_equal(result.values</span><span class="s0">, </span><span class="s1">exp.values)</span>

    <span class="s1">result = ser.apply(</span><span class="s0">lambda </span><span class="s1">x: </span><span class="s2">&quot;A&quot;</span><span class="s1">)</span>
    <span class="s1">exp = Series([</span><span class="s2">&quot;A&quot;</span><span class="s1">] * </span><span class="s4">7</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;XX&quot;</span><span class="s0">, </span><span class="s1">index=list(</span><span class="s2">&quot;abcdefg&quot;</span><span class="s1">))</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">exp)</span>
    <span class="s0">assert </span><span class="s1">result.dtype == object</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;series&quot;</span><span class="s0">, </span><span class="s1">[[</span><span class="s2">&quot;1-1&quot;</span><span class="s0">, </span><span class="s2">&quot;1-1&quot;</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;1-1&quot;</span><span class="s0">, </span><span class="s2">&quot;1-2&quot;</span><span class="s0">, </span><span class="s1">np.nan]])</span>
<span class="s0">def </span><span class="s1">test_apply_categorical_with_nan_values(series</span><span class="s0">, </span><span class="s1">by_row):</span>
    <span class="s3"># GH 20714 bug fixed in: GH 24275</span>
    <span class="s1">s = Series(series</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;category&quot;</span><span class="s1">)</span>
    <span class="s0">if not </span><span class="s1">by_row:</span>
        <span class="s1">msg = </span><span class="s2">&quot;'Series' object has no attribute 'split'&quot;</span>
        <span class="s0">with </span><span class="s1">pytest.raises(AttributeError</span><span class="s0">, </span><span class="s1">match=msg):</span>
            <span class="s1">s.apply(</span><span class="s0">lambda </span><span class="s1">x: x.split(</span><span class="s2">&quot;-&quot;</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">by_row=by_row)</span>
        <span class="s0">return</span>

    <span class="s1">result = s.apply(</span><span class="s0">lambda </span><span class="s1">x: x.split(</span><span class="s2">&quot;-&quot;</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">by_row=by_row)</span>
    <span class="s1">result = result.astype(object)</span>
    <span class="s1">expected = Series([</span><span class="s2">&quot;1&quot;</span><span class="s0">, </span><span class="s2">&quot;1&quot;</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;category&quot;</span><span class="s1">)</span>
    <span class="s1">expected = expected.astype(object)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_apply_empty_integer_series_with_datetime_index(by_row):</span>
    <span class="s3"># GH 21245</span>
    <span class="s1">s = Series([]</span><span class="s0">, </span><span class="s1">index=pd.date_range(start=</span><span class="s2">&quot;2018-01-01&quot;</span><span class="s0">, </span><span class="s1">periods=</span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=int)</span>
    <span class="s1">result = s.apply(</span><span class="s0">lambda </span><span class="s1">x: x</span><span class="s0">, </span><span class="s1">by_row=by_row)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">s)</span>


<span class="s0">def </span><span class="s1">test_apply_dataframe_iloc():</span>
    <span class="s1">uintDF = DataFrame(np.uint64([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">5</span><span class="s1">])</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;Numbers&quot;</span><span class="s1">])</span>
    <span class="s1">indexDF = DataFrame([</span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">columns=[</span><span class="s2">&quot;Indices&quot;</span><span class="s1">])</span>

    <span class="s0">def </span><span class="s1">retrieve(targetRow</span><span class="s0">, </span><span class="s1">targetDF):</span>
        <span class="s1">val = targetDF[</span><span class="s2">&quot;Numbers&quot;</span><span class="s1">].iloc[targetRow]</span>
        <span class="s0">return </span><span class="s1">val</span>

    <span class="s1">result = indexDF[</span><span class="s2">&quot;Indices&quot;</span><span class="s1">].apply(retrieve</span><span class="s0">, </span><span class="s1">args=(uintDF</span><span class="s0">,</span><span class="s1">))</span>
    <span class="s1">expected = Series([</span><span class="s4">3</span><span class="s0">, </span><span class="s4">4</span><span class="s0">, </span><span class="s4">3</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;Indices&quot;</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;uint64&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_transform(string_series</span><span class="s0">, </span><span class="s1">by_row):</span>
    <span class="s3"># transforming functions</span>

    <span class="s0">with </span><span class="s1">np.errstate(all=</span><span class="s2">&quot;ignore&quot;</span><span class="s1">):</span>
        <span class="s1">f_sqrt = np.sqrt(string_series)</span>
        <span class="s1">f_abs = np.abs(string_series)</span>

        <span class="s3"># ufunc</span>
        <span class="s1">result = string_series.apply(np.sqrt</span><span class="s0">, </span><span class="s1">by_row=by_row)</span>
        <span class="s1">expected = f_sqrt.copy()</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s3"># list-like</span>
        <span class="s1">result = string_series.apply([np.sqrt]</span><span class="s0">, </span><span class="s1">by_row=by_row)</span>
        <span class="s1">expected = f_sqrt.to_frame().copy()</span>
        <span class="s1">expected.columns = [</span><span class="s2">&quot;sqrt&quot;</span><span class="s1">]</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s1">result = string_series.apply([</span><span class="s2">&quot;sqrt&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">by_row=by_row)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s3"># multiple items in list</span>
        <span class="s3"># these are in the order as if we are applying both functions per</span>
        <span class="s3"># series and then concatting</span>
        <span class="s1">expected = concat([f_sqrt</span><span class="s0">, </span><span class="s1">f_abs]</span><span class="s0">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">expected.columns = [</span><span class="s2">&quot;sqrt&quot;</span><span class="s0">, </span><span class="s2">&quot;absolute&quot;</span><span class="s1">]</span>
        <span class="s1">result = string_series.apply([np.sqrt</span><span class="s0">, </span><span class="s1">np.abs]</span><span class="s0">, </span><span class="s1">by_row=by_row)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

        <span class="s3"># dict, provide renaming</span>
        <span class="s1">expected = concat([f_sqrt</span><span class="s0">, </span><span class="s1">f_abs]</span><span class="s0">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">expected.columns = [</span><span class="s2">&quot;foo&quot;</span><span class="s0">, </span><span class="s2">&quot;bar&quot;</span><span class="s1">]</span>
        <span class="s1">expected = expected.unstack().rename(</span><span class="s2">&quot;series&quot;</span><span class="s1">)</span>

        <span class="s1">result = string_series.apply({</span><span class="s2">&quot;foo&quot;</span><span class="s1">: np.sqrt</span><span class="s0">, </span><span class="s2">&quot;bar&quot;</span><span class="s1">: np.abs}</span><span class="s0">, </span><span class="s1">by_row=by_row)</span>
        <span class="s1">tm.assert_series_equal(result.reindex_like(expected)</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;op&quot;</span><span class="s0">, </span><span class="s1">series_transform_kernels)</span>
<span class="s0">def </span><span class="s1">test_transform_partial_failure(op</span><span class="s0">, </span><span class="s1">request):</span>
    <span class="s3"># GH 35964</span>
    <span class="s0">if </span><span class="s1">op </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;ffill&quot;</span><span class="s0">, </span><span class="s2">&quot;bfill&quot;</span><span class="s0">, </span><span class="s2">&quot;pad&quot;</span><span class="s0">, </span><span class="s2">&quot;backfill&quot;</span><span class="s0">, </span><span class="s2">&quot;shift&quot;</span><span class="s1">):</span>
        <span class="s1">request.node.add_marker(</span>
            <span class="s1">pytest.mark.xfail(reason=</span><span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">op</span><span class="s0">} </span><span class="s2">is successful on any dtype&quot;</span><span class="s1">)</span>
        <span class="s1">)</span>

    <span class="s3"># Using object makes most transform kernels fail</span>
    <span class="s1">ser = Series(</span><span class="s4">3 </span><span class="s1">* [object])</span>

    <span class="s0">if </span><span class="s1">op </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;fillna&quot;</span><span class="s0">, </span><span class="s2">&quot;ngroup&quot;</span><span class="s1">):</span>
        <span class="s1">error = ValueError</span>
        <span class="s1">msg = </span><span class="s2">&quot;Transform function failed&quot;</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">error = TypeError</span>
        <span class="s1">msg = </span><span class="s2">&quot;|&quot;</span><span class="s1">.join(</span>
            <span class="s1">[</span>
                <span class="s2">&quot;not supported between instances of 'type' and 'type'&quot;</span><span class="s0">,</span>
                <span class="s2">&quot;unsupported operand type&quot;</span><span class="s0">,</span>
            <span class="s1">]</span>
        <span class="s1">)</span>

    <span class="s0">with </span><span class="s1">pytest.raises(error</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">ser.transform([op</span><span class="s0">, </span><span class="s2">&quot;shift&quot;</span><span class="s1">])</span>

    <span class="s0">with </span><span class="s1">pytest.raises(error</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">ser.transform({</span><span class="s2">&quot;A&quot;</span><span class="s1">: op</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">: </span><span class="s2">&quot;shift&quot;</span><span class="s1">})</span>

    <span class="s0">with </span><span class="s1">pytest.raises(error</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">ser.transform({</span><span class="s2">&quot;A&quot;</span><span class="s1">: [op]</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">: [</span><span class="s2">&quot;shift&quot;</span><span class="s1">]})</span>

    <span class="s0">with </span><span class="s1">pytest.raises(error</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">ser.transform({</span><span class="s2">&quot;A&quot;</span><span class="s1">: [op</span><span class="s0">, </span><span class="s2">&quot;shift&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">: [op]})</span>


<span class="s0">def </span><span class="s1">test_transform_partial_failure_valueerror():</span>
    <span class="s3"># GH 40211</span>
    <span class="s0">def </span><span class="s1">noop(x):</span>
        <span class="s0">return </span><span class="s1">x</span>

    <span class="s0">def </span><span class="s1">raising_op(_):</span>
        <span class="s0">raise </span><span class="s1">ValueError</span>

    <span class="s1">ser = Series(</span><span class="s4">3 </span><span class="s1">* [object])</span>
    <span class="s1">msg = </span><span class="s2">&quot;Transform function failed&quot;</span>

    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">ser.transform([noop</span><span class="s0">, </span><span class="s1">raising_op])</span>

    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">ser.transform({</span><span class="s2">&quot;A&quot;</span><span class="s1">: raising_op</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">: noop})</span>

    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">ser.transform({</span><span class="s2">&quot;A&quot;</span><span class="s1">: [raising_op]</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">: [noop]})</span>

    <span class="s0">with </span><span class="s1">pytest.raises(ValueError</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">ser.transform({</span><span class="s2">&quot;A&quot;</span><span class="s1">: [noop</span><span class="s0">, </span><span class="s1">raising_op]</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">: [noop]})</span>


<span class="s0">def </span><span class="s1">test_demo():</span>
    <span class="s3"># demonstration tests</span>
    <span class="s1">s = Series(range(</span><span class="s4">6</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;int64&quot;</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;series&quot;</span><span class="s1">)</span>

    <span class="s1">result = s.agg([</span><span class="s2">&quot;min&quot;</span><span class="s0">, </span><span class="s2">&quot;max&quot;</span><span class="s1">])</span>
    <span class="s1">expected = Series([</span><span class="s4">0</span><span class="s0">, </span><span class="s4">5</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=[</span><span class="s2">&quot;min&quot;</span><span class="s0">, </span><span class="s2">&quot;max&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;series&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">result = s.agg({</span><span class="s2">&quot;foo&quot;</span><span class="s1">: </span><span class="s2">&quot;min&quot;</span><span class="s1">})</span>
    <span class="s1">expected = Series([</span><span class="s4">0</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=[</span><span class="s2">&quot;foo&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;series&quot;</span><span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;func&quot;</span><span class="s0">, </span><span class="s1">[str</span><span class="s0">, lambda </span><span class="s1">x: str(x)])</span>
<span class="s0">def </span><span class="s1">test_apply_map_evaluate_lambdas_the_same(string_series</span><span class="s0">, </span><span class="s1">func</span><span class="s0">, </span><span class="s1">by_row):</span>
    <span class="s3"># test that we are evaluating row-by-row first if by_row=&quot;compat&quot;</span>
    <span class="s3"># else vectorized evaluation</span>
    <span class="s1">result = string_series.apply(func</span><span class="s0">, </span><span class="s1">by_row=by_row)</span>

    <span class="s0">if </span><span class="s1">by_row:</span>
        <span class="s1">expected = string_series.map(func)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">assert </span><span class="s1">result == str(string_series)</span>


<span class="s0">def </span><span class="s1">test_agg_evaluate_lambdas(string_series):</span>
    <span class="s3"># GH53325</span>
    <span class="s3"># in the future, the result will be a Series class.</span>

    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning):</span>
        <span class="s1">result = string_series.agg(</span><span class="s0">lambda </span><span class="s1">x: type(x))</span>
    <span class="s0">assert </span><span class="s1">isinstance(result</span><span class="s0">, </span><span class="s1">Series) </span><span class="s0">and </span><span class="s1">len(result) == len(string_series)</span>

    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning):</span>
        <span class="s1">result = string_series.agg(type)</span>
    <span class="s0">assert </span><span class="s1">isinstance(result</span><span class="s0">, </span><span class="s1">Series) </span><span class="s0">and </span><span class="s1">len(result) == len(string_series)</span>


<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;op_name&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;agg&quot;</span><span class="s0">, </span><span class="s2">&quot;apply&quot;</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_with_nested_series(datetime_series</span><span class="s0">, </span><span class="s1">op_name):</span>
    <span class="s3"># GH 2316</span>
    <span class="s3"># .agg with a reducer and a transform, what to do</span>
    <span class="s1">msg = </span><span class="s2">&quot;cannot aggregate&quot;</span>
    <span class="s1">warning = FutureWarning </span><span class="s0">if </span><span class="s1">op_name == </span><span class="s2">&quot;agg&quot; </span><span class="s0">else None</span>
    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(warning</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s3"># GH52123</span>
        <span class="s1">result = getattr(datetime_series</span><span class="s0">, </span><span class="s1">op_name)(</span>
            <span class="s0">lambda </span><span class="s1">x: Series([x</span><span class="s0">, </span><span class="s1">x**</span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=[</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s2">&quot;x^2&quot;</span><span class="s1">])</span>
        <span class="s1">)</span>
    <span class="s1">expected = DataFrame({</span><span class="s2">&quot;x&quot;</span><span class="s1">: datetime_series</span><span class="s0">, </span><span class="s2">&quot;x^2&quot;</span><span class="s1">: datetime_series**</span><span class="s4">2</span><span class="s1">})</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(FutureWarning</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">result = datetime_series.agg(</span><span class="s0">lambda </span><span class="s1">x: Series([x</span><span class="s0">, </span><span class="s1">x**</span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=[</span><span class="s2">&quot;x&quot;</span><span class="s0">, </span><span class="s2">&quot;x^2&quot;</span><span class="s1">]))</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_replicate_describe(string_series):</span>
    <span class="s3"># this also tests a result set that is all scalars</span>
    <span class="s1">expected = string_series.describe()</span>
    <span class="s1">result = string_series.apply(</span>
        <span class="s1">{</span>
            <span class="s2">&quot;count&quot;</span><span class="s1">: </span><span class="s2">&quot;count&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;mean&quot;</span><span class="s1">: </span><span class="s2">&quot;mean&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;std&quot;</span><span class="s1">: </span><span class="s2">&quot;std&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;min&quot;</span><span class="s1">: </span><span class="s2">&quot;min&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;25%&quot;</span><span class="s1">: </span><span class="s0">lambda </span><span class="s1">x: x.quantile(</span><span class="s4">0.25</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;50%&quot;</span><span class="s1">: </span><span class="s2">&quot;median&quot;</span><span class="s0">,</span>
            <span class="s2">&quot;75%&quot;</span><span class="s1">: </span><span class="s0">lambda </span><span class="s1">x: x.quantile(</span><span class="s4">0.75</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s2">&quot;max&quot;</span><span class="s1">: </span><span class="s2">&quot;max&quot;</span><span class="s0">,</span>
        <span class="s1">}</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_reduce(string_series):</span>
    <span class="s3"># reductions with named functions</span>
    <span class="s1">result = string_series.agg([</span><span class="s2">&quot;sum&quot;</span><span class="s0">, </span><span class="s2">&quot;mean&quot;</span><span class="s1">])</span>
    <span class="s1">expected = Series(</span>
        <span class="s1">[string_series.sum()</span><span class="s0">, </span><span class="s1">string_series.mean()]</span><span class="s0">,</span>
        <span class="s1">[</span><span class="s2">&quot;sum&quot;</span><span class="s0">, </span><span class="s2">&quot;mean&quot;</span><span class="s1">]</span><span class="s0">,</span>
        <span class="s1">name=string_series.name</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;how, kwds&quot;</span><span class="s0">,</span>
    <span class="s1">[(</span><span class="s2">&quot;agg&quot;</span><span class="s0">, </span><span class="s1">{})</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;apply&quot;</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;by_row&quot;</span><span class="s1">: </span><span class="s2">&quot;compat&quot;</span><span class="s1">})</span><span class="s0">, </span><span class="s1">(</span><span class="s2">&quot;apply&quot;</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;by_row&quot;</span><span class="s1">: </span><span class="s0">False</span><span class="s1">})]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_non_callable_aggregates(how</span><span class="s0">, </span><span class="s1">kwds):</span>
    <span class="s3"># test agg using non-callable series attributes</span>
    <span class="s3"># GH 39116 - expand to apply</span>
    <span class="s1">s = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, None</span><span class="s1">])</span>

    <span class="s3"># Calling agg w/ just a string arg same as calling s.arg</span>
    <span class="s1">result = getattr(s</span><span class="s0">, </span><span class="s1">how)(</span><span class="s2">&quot;size&quot;</span><span class="s0">, </span><span class="s1">**kwds)</span>
    <span class="s1">expected = s.size</span>
    <span class="s0">assert </span><span class="s1">result == expected</span>

    <span class="s3"># test when mixed w/ callable reducers</span>
    <span class="s1">result = getattr(s</span><span class="s0">, </span><span class="s1">how)([</span><span class="s2">&quot;size&quot;</span><span class="s0">, </span><span class="s2">&quot;count&quot;</span><span class="s0">, </span><span class="s2">&quot;mean&quot;</span><span class="s1">]</span><span class="s0">, </span><span class="s1">**kwds)</span>
    <span class="s1">expected = Series({</span><span class="s2">&quot;size&quot;</span><span class="s1">: </span><span class="s4">3.0</span><span class="s0">, </span><span class="s2">&quot;count&quot;</span><span class="s1">: </span><span class="s4">2.0</span><span class="s0">, </span><span class="s2">&quot;mean&quot;</span><span class="s1">: </span><span class="s4">1.5</span><span class="s1">})</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>

    <span class="s1">result = getattr(s</span><span class="s0">, </span><span class="s1">how)({</span><span class="s2">&quot;size&quot;</span><span class="s1">: </span><span class="s2">&quot;size&quot;</span><span class="s0">, </span><span class="s2">&quot;count&quot;</span><span class="s1">: </span><span class="s2">&quot;count&quot;</span><span class="s0">, </span><span class="s2">&quot;mean&quot;</span><span class="s1">: </span><span class="s2">&quot;mean&quot;</span><span class="s1">}</span><span class="s0">, </span><span class="s1">**kwds)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_series_apply_no_suffix_index(by_row):</span>
    <span class="s3"># GH36189</span>
    <span class="s1">s = Series([</span><span class="s4">4</span><span class="s1">] * </span><span class="s4">3</span><span class="s1">)</span>
    <span class="s1">result = s.apply([</span><span class="s2">&quot;sum&quot;</span><span class="s0">, lambda </span><span class="s1">x: x.sum()</span><span class="s0">, lambda </span><span class="s1">x: x.sum()]</span><span class="s0">, </span><span class="s1">by_row=by_row)</span>
    <span class="s1">expected = Series([</span><span class="s4">12</span><span class="s0">, </span><span class="s4">12</span><span class="s0">, </span><span class="s4">12</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=[</span><span class="s2">&quot;sum&quot;</span><span class="s0">, </span><span class="s2">&quot;&lt;lambda&gt;&quot;</span><span class="s0">, </span><span class="s2">&quot;&lt;lambda&gt;&quot;</span><span class="s1">])</span>

    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;dti,exp&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span>
            <span class="s1">Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=pd.DatetimeIndex([</span><span class="s4">0</span><span class="s0">, </span><span class="s4">31536000000</span><span class="s1">]))</span><span class="s0">,</span>
            <span class="s1">DataFrame(np.repeat([[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]]</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;int64&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">(</span>
            <span class="s1">tm.makeTimeSeries(nper=</span><span class="s4">30</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">DataFrame(np.repeat([[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]]</span><span class="s0">, </span><span class="s4">30</span><span class="s0">, </span><span class="s1">axis=</span><span class="s4">0</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;int64&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span><span class="s2">&quot;aware&quot;</span><span class="s0">, </span><span class="s1">[</span><span class="s0">True, False</span><span class="s1">])</span>
<span class="s0">def </span><span class="s1">test_apply_series_on_date_time_index_aware_series(dti</span><span class="s0">, </span><span class="s1">exp</span><span class="s0">, </span><span class="s1">aware):</span>
    <span class="s3"># GH 25959</span>
    <span class="s3"># Calling apply on a localized time series should not cause an error</span>
    <span class="s0">if </span><span class="s1">aware:</span>
        <span class="s1">index = dti.tz_localize(</span><span class="s2">&quot;UTC&quot;</span><span class="s1">).index</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s1">index = dti.index</span>
    <span class="s1">result = Series(index).apply(</span><span class="s0">lambda </span><span class="s1">x: Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s1">]))</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">exp)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;by_row, expected&quot;</span><span class="s0">, </span><span class="s1">[(</span><span class="s2">&quot;compat&quot;</span><span class="s0">, </span><span class="s1">Series(np.ones(</span><span class="s4">30</span><span class="s1">)</span><span class="s0">, </span><span class="s1">dtype=</span><span class="s2">&quot;int64&quot;</span><span class="s1">))</span><span class="s0">, </span><span class="s1">(</span><span class="s0">False, </span><span class="s4">1</span><span class="s1">)]</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_apply_scalar_on_date_time_index_aware_series(by_row</span><span class="s0">, </span><span class="s1">expected):</span>
    <span class="s3"># GH 25959</span>
    <span class="s3"># Calling apply on a localized time series should not cause an error</span>
    <span class="s1">series = tm.makeTimeSeries(nper=</span><span class="s4">30</span><span class="s1">).tz_localize(</span><span class="s2">&quot;UTC&quot;</span><span class="s1">)</span>
    <span class="s1">result = Series(series.index).apply(</span><span class="s0">lambda </span><span class="s1">x: </span><span class="s4">1</span><span class="s0">, </span><span class="s1">by_row=by_row)</span>
    <span class="s1">tm.assert_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_apply_to_timedelta(by_row):</span>
    <span class="s1">list_of_valid_strings = [</span><span class="s2">&quot;00:00:01&quot;</span><span class="s0">, </span><span class="s2">&quot;00:00:02&quot;</span><span class="s1">]</span>
    <span class="s1">a = pd.to_timedelta(list_of_valid_strings)</span>
    <span class="s1">b = Series(list_of_valid_strings).apply(pd.to_timedelta</span><span class="s0">, </span><span class="s1">by_row=by_row)</span>
    <span class="s1">tm.assert_series_equal(Series(a)</span><span class="s0">, </span><span class="s1">b)</span>

    <span class="s1">list_of_strings = [</span><span class="s2">&quot;00:00:01&quot;</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">pd.NaT</span><span class="s0">, </span><span class="s1">pd.NaT]</span>

    <span class="s1">a = pd.to_timedelta(list_of_strings)</span>
    <span class="s1">ser = Series(list_of_strings)</span>
    <span class="s1">b = ser.apply(pd.to_timedelta</span><span class="s0">, </span><span class="s1">by_row=by_row)</span>
    <span class="s1">tm.assert_series_equal(Series(a)</span><span class="s0">, </span><span class="s1">b)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;ops, names&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">([np.sum]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;sum&quot;</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">([np.sum</span><span class="s0">, </span><span class="s1">np.mean]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;sum&quot;</span><span class="s0">, </span><span class="s2">&quot;mean&quot;</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">(np.array([np.sum])</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;sum&quot;</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">(np.array([np.sum</span><span class="s0">, </span><span class="s1">np.mean])</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;sum&quot;</span><span class="s0">, </span><span class="s2">&quot;mean&quot;</span><span class="s1">])</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;how, kwargs&quot;</span><span class="s0">,</span>
    <span class="s1">[[</span><span class="s2">&quot;agg&quot;</span><span class="s0">, </span><span class="s1">{}]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;apply&quot;</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;by_row&quot;</span><span class="s1">: </span><span class="s2">&quot;compat&quot;</span><span class="s1">}]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;apply&quot;</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;by_row&quot;</span><span class="s1">: </span><span class="s0">False</span><span class="s1">}]]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_apply_listlike_reducer(string_series</span><span class="s0">, </span><span class="s1">ops</span><span class="s0">, </span><span class="s1">names</span><span class="s0">, </span><span class="s1">how</span><span class="s0">, </span><span class="s1">kwargs):</span>
    <span class="s3"># GH 39140</span>
    <span class="s1">expected = Series({name: op(string_series) </span><span class="s0">for </span><span class="s1">name</span><span class="s0">, </span><span class="s1">op </span><span class="s0">in </span><span class="s1">zip(names</span><span class="s0">, </span><span class="s1">ops)})</span>
    <span class="s1">expected.name = </span><span class="s2">&quot;series&quot;</span>
    <span class="s1">warn = FutureWarning </span><span class="s0">if </span><span class="s1">how == </span><span class="s2">&quot;agg&quot; </span><span class="s0">else None</span>
    <span class="s1">msg = </span><span class="s2">f&quot;using Series.[</span><span class="s0">{</span><span class="s2">'|'</span><span class="s1">.join(names)</span><span class="s0">}</span><span class="s2">]&quot;</span>
    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(warn</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">result = getattr(string_series</span><span class="s0">, </span><span class="s1">how)(ops</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;ops&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">{</span><span class="s2">&quot;A&quot;</span><span class="s1">: np.sum}</span><span class="s0">,</span>
        <span class="s1">{</span><span class="s2">&quot;A&quot;</span><span class="s1">: np.sum</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">: np.mean}</span><span class="s0">,</span>
        <span class="s1">Series({</span><span class="s2">&quot;A&quot;</span><span class="s1">: np.sum})</span><span class="s0">,</span>
        <span class="s1">Series({</span><span class="s2">&quot;A&quot;</span><span class="s1">: np.sum</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">: np.mean})</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;how, kwargs&quot;</span><span class="s0">,</span>
    <span class="s1">[[</span><span class="s2">&quot;agg&quot;</span><span class="s0">, </span><span class="s1">{}]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;apply&quot;</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;by_row&quot;</span><span class="s1">: </span><span class="s2">&quot;compat&quot;</span><span class="s1">}]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;apply&quot;</span><span class="s0">, </span><span class="s1">{</span><span class="s2">&quot;by_row&quot;</span><span class="s1">: </span><span class="s0">False</span><span class="s1">}]]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_apply_dictlike_reducer(string_series</span><span class="s0">, </span><span class="s1">ops</span><span class="s0">, </span><span class="s1">how</span><span class="s0">, </span><span class="s1">kwargs</span><span class="s0">, </span><span class="s1">by_row):</span>
    <span class="s3"># GH 39140</span>
    <span class="s1">expected = Series({name: op(string_series) </span><span class="s0">for </span><span class="s1">name</span><span class="s0">, </span><span class="s1">op </span><span class="s0">in </span><span class="s1">ops.items()})</span>
    <span class="s1">expected.name = string_series.name</span>
    <span class="s1">warn = FutureWarning </span><span class="s0">if </span><span class="s1">how == </span><span class="s2">&quot;agg&quot; </span><span class="s0">else None</span>
    <span class="s1">msg = </span><span class="s2">&quot;using Series.[sum|mean]&quot;</span>
    <span class="s0">with </span><span class="s1">tm.assert_produces_warning(warn</span><span class="s0">, </span><span class="s1">match=msg):</span>
        <span class="s1">result = getattr(string_series</span><span class="s0">, </span><span class="s1">how)(ops</span><span class="s0">, </span><span class="s1">**kwargs)</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;ops, names&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">([np.sqrt]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;sqrt&quot;</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">([np.abs</span><span class="s0">, </span><span class="s1">np.sqrt]</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;absolute&quot;</span><span class="s0">, </span><span class="s2">&quot;sqrt&quot;</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">(np.array([np.sqrt])</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;sqrt&quot;</span><span class="s1">])</span><span class="s0">,</span>
        <span class="s1">(np.array([np.abs</span><span class="s0">, </span><span class="s1">np.sqrt])</span><span class="s0">, </span><span class="s1">[</span><span class="s2">&quot;absolute&quot;</span><span class="s0">, </span><span class="s2">&quot;sqrt&quot;</span><span class="s1">])</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_apply_listlike_transformer(string_series</span><span class="s0">, </span><span class="s1">ops</span><span class="s0">, </span><span class="s1">names</span><span class="s0">, </span><span class="s1">by_row):</span>
    <span class="s3"># GH 39140</span>
    <span class="s0">with </span><span class="s1">np.errstate(all=</span><span class="s2">&quot;ignore&quot;</span><span class="s1">):</span>
        <span class="s1">expected = concat([op(string_series) </span><span class="s0">for </span><span class="s1">op </span><span class="s0">in </span><span class="s1">ops]</span><span class="s0">, </span><span class="s1">axis=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">expected.columns = names</span>
        <span class="s1">result = string_series.apply(ops</span><span class="s0">, </span><span class="s1">by_row=by_row)</span>
        <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;ops, expected&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">([</span><span class="s0">lambda </span><span class="s1">x: x]</span><span class="s0">, </span><span class="s1">DataFrame({</span><span class="s2">&quot;&lt;lambda&gt;&quot;</span><span class="s1">: [</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]}))</span><span class="s0">,</span>
        <span class="s1">([</span><span class="s0">lambda </span><span class="s1">x: x.sum()]</span><span class="s0">, </span><span class="s1">Series([</span><span class="s4">6</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=[</span><span class="s2">&quot;&lt;lambda&gt;&quot;</span><span class="s1">]))</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_apply_listlike_lambda(ops</span><span class="s0">, </span><span class="s1">expected</span><span class="s0">, </span><span class="s1">by_row):</span>
    <span class="s3"># GH53400</span>
    <span class="s1">ser = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">])</span>
    <span class="s1">result = ser.apply(ops</span><span class="s0">, </span><span class="s1">by_row=by_row)</span>
    <span class="s1">tm.assert_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;ops&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">{</span><span class="s2">&quot;A&quot;</span><span class="s1">: np.sqrt}</span><span class="s0">,</span>
        <span class="s1">{</span><span class="s2">&quot;A&quot;</span><span class="s1">: np.sqrt</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">: np.exp}</span><span class="s0">,</span>
        <span class="s1">Series({</span><span class="s2">&quot;A&quot;</span><span class="s1">: np.sqrt})</span><span class="s0">,</span>
        <span class="s1">Series({</span><span class="s2">&quot;A&quot;</span><span class="s1">: np.sqrt</span><span class="s0">, </span><span class="s2">&quot;B&quot;</span><span class="s1">: np.exp})</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_apply_dictlike_transformer(string_series</span><span class="s0">, </span><span class="s1">ops</span><span class="s0">, </span><span class="s1">by_row):</span>
    <span class="s3"># GH 39140</span>
    <span class="s0">with </span><span class="s1">np.errstate(all=</span><span class="s2">&quot;ignore&quot;</span><span class="s1">):</span>
        <span class="s1">expected = concat({name: op(string_series) </span><span class="s0">for </span><span class="s1">name</span><span class="s0">, </span><span class="s1">op </span><span class="s0">in </span><span class="s1">ops.items()})</span>
        <span class="s1">expected.name = string_series.name</span>
        <span class="s1">result = string_series.apply(ops</span><span class="s0">, </span><span class="s1">by_row=by_row)</span>
        <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s1">@pytest.mark.parametrize(</span>
    <span class="s2">&quot;ops, expected&quot;</span><span class="s0">,</span>
    <span class="s1">[</span>
        <span class="s1">(</span>
            <span class="s1">{</span><span class="s2">&quot;a&quot;</span><span class="s1">: </span><span class="s0">lambda </span><span class="s1">x: x}</span><span class="s0">,</span>
            <span class="s1">Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=MultiIndex.from_arrays([[</span><span class="s2">&quot;a&quot;</span><span class="s1">] * </span><span class="s4">3</span><span class="s0">, </span><span class="s1">range(</span><span class="s4">3</span><span class="s1">)]))</span><span class="s0">,</span>
        <span class="s1">)</span><span class="s0">,</span>
        <span class="s1">({</span><span class="s2">&quot;a&quot;</span><span class="s1">: </span><span class="s0">lambda </span><span class="s1">x: x.sum()}</span><span class="s0">, </span><span class="s1">Series([</span><span class="s4">6</span><span class="s1">]</span><span class="s0">, </span><span class="s1">index=[</span><span class="s2">&quot;a&quot;</span><span class="s1">]))</span><span class="s0">,</span>
    <span class="s1">]</span><span class="s0">,</span>
<span class="s1">)</span>
<span class="s0">def </span><span class="s1">test_apply_dictlike_lambda(ops</span><span class="s0">, </span><span class="s1">by_row</span><span class="s0">, </span><span class="s1">expected):</span>
    <span class="s3"># GH53400</span>
    <span class="s1">ser = Series([</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">])</span>
    <span class="s1">result = ser.apply(ops</span><span class="s0">, </span><span class="s1">by_row=by_row)</span>
    <span class="s1">tm.assert_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_apply_retains_column_name(by_row):</span>
    <span class="s3"># GH 16380</span>
    <span class="s1">df = DataFrame({</span><span class="s2">&quot;x&quot;</span><span class="s1">: range(</span><span class="s4">3</span><span class="s1">)}</span><span class="s0">, </span><span class="s1">Index(range(</span><span class="s4">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;x&quot;</span><span class="s1">))</span>
    <span class="s1">result = df.x.apply(</span><span class="s0">lambda </span><span class="s1">x: Series(range(x + </span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">Index(range(x + </span><span class="s4">1</span><span class="s1">)</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;y&quot;</span><span class="s1">)))</span>
    <span class="s1">expected = DataFrame(</span>
        <span class="s1">[[</span><span class="s4">0.0</span><span class="s0">, </span><span class="s1">np.nan</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0.0</span><span class="s0">, </span><span class="s4">1.0</span><span class="s0">, </span><span class="s1">np.nan]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">0.0</span><span class="s0">, </span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">2.0</span><span class="s1">]]</span><span class="s0">,</span>
        <span class="s1">columns=Index(range(</span><span class="s4">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;y&quot;</span><span class="s1">)</span><span class="s0">,</span>
        <span class="s1">index=Index(range(</span><span class="s4">3</span><span class="s1">)</span><span class="s0">, </span><span class="s1">name=</span><span class="s2">&quot;x&quot;</span><span class="s1">)</span><span class="s0">,</span>
    <span class="s1">)</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_apply_type():</span>
    <span class="s3"># GH 46719</span>
    <span class="s1">s = Series([</span><span class="s4">3</span><span class="s0">, </span><span class="s2">&quot;string&quot;</span><span class="s0">, </span><span class="s1">float]</span><span class="s0">, </span><span class="s1">index=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">])</span>
    <span class="s1">result = s.apply(type)</span>
    <span class="s1">expected = Series([int</span><span class="s0">, </span><span class="s1">str</span><span class="s0">, </span><span class="s1">type]</span><span class="s0">, </span><span class="s1">index=[</span><span class="s2">&quot;a&quot;</span><span class="s0">, </span><span class="s2">&quot;b&quot;</span><span class="s0">, </span><span class="s2">&quot;c&quot;</span><span class="s1">])</span>
    <span class="s1">tm.assert_series_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>


<span class="s0">def </span><span class="s1">test_series_apply_unpack_nested_data():</span>
    <span class="s3"># GH#55189</span>
    <span class="s1">ser = Series([[</span><span class="s4">1</span><span class="s0">, </span><span class="s4">2</span><span class="s0">, </span><span class="s4">3</span><span class="s1">]</span><span class="s0">, </span><span class="s1">[</span><span class="s4">4</span><span class="s0">, </span><span class="s4">5</span><span class="s0">, </span><span class="s4">6</span><span class="s0">, </span><span class="s4">7</span><span class="s1">]])</span>
    <span class="s1">result = ser.apply(</span><span class="s0">lambda </span><span class="s1">x: Series(x))</span>
    <span class="s1">expected = DataFrame({</span><span class="s4">0</span><span class="s1">: [</span><span class="s4">1.0</span><span class="s0">, </span><span class="s4">4.0</span><span class="s1">]</span><span class="s0">, </span><span class="s4">1</span><span class="s1">: [</span><span class="s4">2.0</span><span class="s0">, </span><span class="s4">5.0</span><span class="s1">]</span><span class="s0">, </span><span class="s4">2</span><span class="s1">: [</span><span class="s4">3.0</span><span class="s0">, </span><span class="s4">6.0</span><span class="s1">]</span><span class="s0">, </span><span class="s4">3</span><span class="s1">: [np.nan</span><span class="s0">, </span><span class="s4">7</span><span class="s1">]})</span>
    <span class="s1">tm.assert_frame_equal(result</span><span class="s0">, </span><span class="s1">expected)</span>
</pre>
</body>
</html>