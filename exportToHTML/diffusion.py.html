<html>
<head>
<title>diffusion.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6897bb;}
.s5 { color: #6a8759;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
diffusion.py</font>
</center></td></tr></table>
<pre><span class="s0">'''getting started with diffusions, continuous time stochastic processes 
 
Author: josef-pktd 
License: BSD 
 
 
References 
---------- 
 
An Algorithmic Introduction to Numerical Simulation of Stochastic Differential 
Equations 
Author(s): Desmond J. Higham 
Source: SIAM Review, Vol. 43, No. 3 (Sep., 2001), pp. 525-546 
Published by: Society for Industrial and Applied Mathematics 
Stable URL: http://www.jstor.org/stable/3649798 
 
http://www.sitmo.com/  especially the formula collection 
 
 
Notes 
----- 
 
OU process: use same trick for ARMA with constant (non-zero mean) and drift 
some of the processes have easy multivariate extensions 
 
*Open Issues* 
 
include xzero in returned sample or not? currently not 
 
*TODOS* 
 
* Milstein from Higham paper, for which processes does it apply 
* Maximum Likelihood estimation 
* more statistical properties (useful for tests) 
* helper functions for display and MonteCarlo summaries (also for testing/checking) 
* more processes for the menagerie (e.g. from empirical papers) 
* characteristic functions 
* transformations, non-linear e.g. log 
* special estimators, e.g. Ait Sahalia, empirical characteristic functions 
* fft examples 
* check naming of methods, &quot;simulate&quot;, &quot;sample&quot;, &quot;simexact&quot;, ... ? 
 
 
 
stochastic volatility models: estimation unclear 
 
finance applications ? option pricing, interest rate models 
 
 
'''</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">from </span><span class="s1">scipy </span><span class="s2">import </span><span class="s1">stats</span><span class="s2">, </span><span class="s1">signal</span>
<span class="s2">import </span><span class="s1">matplotlib.pyplot </span><span class="s2">as </span><span class="s1">plt</span>

<span class="s3">#np.random.seed(987656789)</span>

<span class="s2">class </span><span class="s1">Diffusion:</span>
    <span class="s0">'''Wiener Process, Brownian Motion with mu=0 and sigma=1 
    '''</span>
    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">simulateW(self</span><span class="s2">, </span><span class="s1">nobs=</span><span class="s4">100</span><span class="s2">, </span><span class="s1">T=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">dt=</span><span class="s2">None, </span><span class="s1">nrepl=</span><span class="s4">1</span><span class="s1">):</span>
        <span class="s0">'''generate sample of Wiener Process 
        '''</span>
        <span class="s1">dt = T*</span><span class="s4">1.0</span><span class="s1">/nobs</span>
        <span class="s1">t = np.linspace(dt</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">nobs)</span>
        <span class="s1">dW = np.sqrt(dt)*np.random.normal(size=(nrepl</span><span class="s2">, </span><span class="s1">nobs))</span>
        <span class="s1">W = np.cumsum(dW</span><span class="s2">,</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">self.dW = dW</span>
        <span class="s2">return </span><span class="s1">W</span><span class="s2">, </span><span class="s1">t</span>

    <span class="s2">def </span><span class="s1">expectedsim(self</span><span class="s2">, </span><span class="s1">func</span><span class="s2">, </span><span class="s1">nobs=</span><span class="s4">100</span><span class="s2">, </span><span class="s1">T=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">dt=</span><span class="s2">None, </span><span class="s1">nrepl=</span><span class="s4">1</span><span class="s1">):</span>
        <span class="s0">'''get expectation of a function of a Wiener Process by simulation 
 
        initially test example from 
        '''</span>
        <span class="s1">W</span><span class="s2">, </span><span class="s1">t = self.simulateW(nobs=nobs</span><span class="s2">, </span><span class="s1">T=T</span><span class="s2">, </span><span class="s1">dt=dt</span><span class="s2">, </span><span class="s1">nrepl=nrepl)</span>
        <span class="s1">U = func(t</span><span class="s2">, </span><span class="s1">W)</span>
        <span class="s1">Umean = U.mean(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">U</span><span class="s2">, </span><span class="s1">Umean</span><span class="s2">, </span><span class="s1">t</span>

<span class="s2">class </span><span class="s1">AffineDiffusion(Diffusion):</span>
    <span class="s0">r''' 
 
    differential equation: 
 
    :math:: 
    dx_t = f(t,x)dt + \sigma(t,x)dW_t 
 
    integral: 
 
    :math:: 
    x_T = x_0 + \int_{0}^{T}f(t,S)dt + \int_0^T  \sigma(t,S)dW_t 
 
    TODO: check definition, affine, what about jump diffusion? 
 
    '''</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">sim(self</span><span class="s2">, </span><span class="s1">nobs=</span><span class="s4">100</span><span class="s2">, </span><span class="s1">T=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">dt=</span><span class="s2">None, </span><span class="s1">nrepl=</span><span class="s4">1</span><span class="s1">):</span>
        <span class="s3"># this does not look correct if drift or sig depend on x</span>
        <span class="s3"># see arithmetic BM</span>
        <span class="s1">W</span><span class="s2">, </span><span class="s1">t = self.simulateW(nobs=nobs</span><span class="s2">, </span><span class="s1">T=T</span><span class="s2">, </span><span class="s1">dt=dt</span><span class="s2">, </span><span class="s1">nrepl=nrepl)</span>
        <span class="s1">dx =  self._drift() + self._sig() * W</span>
        <span class="s1">x  = np.cumsum(dx</span><span class="s2">,</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">xmean = x.mean(</span><span class="s4">0</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">x</span><span class="s2">, </span><span class="s1">xmean</span><span class="s2">, </span><span class="s1">t</span>

    <span class="s2">def </span><span class="s1">simEM(self</span><span class="s2">, </span><span class="s1">xzero=</span><span class="s2">None, </span><span class="s1">nobs=</span><span class="s4">100</span><span class="s2">, </span><span class="s1">T=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">dt=</span><span class="s2">None, </span><span class="s1">nrepl=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">Tratio=</span><span class="s4">4</span><span class="s1">):</span>
        <span class="s0">''' 
 
        from Higham 2001 
 
        TODO: reverse parameterization to start with final nobs and DT 
        TODO: check if I can skip the loop using my way from exactprocess 
              problem might be Winc (reshape into 3d and sum) 
        TODO: (later) check memory efficiency for large simulations 
        '''</span>
        <span class="s3">#TODO: reverse parameterization to start with final nobs and DT</span>
        <span class="s1">nobs = nobs * Tratio  </span><span class="s3"># simple way to change parameter</span>
        <span class="s3"># maybe wrong parameterization,</span>
        <span class="s3"># drift too large, variance too small ? which dt/Dt</span>
        <span class="s3"># _drift, _sig independent of dt is wrong</span>
        <span class="s2">if </span><span class="s1">xzero </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">xzero = self.xzero</span>
        <span class="s2">if </span><span class="s1">dt </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">dt = T*</span><span class="s4">1.0</span><span class="s1">/nobs</span>
        <span class="s1">W</span><span class="s2">, </span><span class="s1">t = self.simulateW(nobs=nobs</span><span class="s2">, </span><span class="s1">T=T</span><span class="s2">, </span><span class="s1">dt=dt</span><span class="s2">, </span><span class="s1">nrepl=nrepl)</span>
        <span class="s1">dW = self.dW</span>
        <span class="s1">t = np.linspace(dt</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">nobs)</span>
        <span class="s1">Dt = Tratio*dt</span>
        <span class="s1">L = nobs/Tratio        </span><span class="s3"># L EM steps of size Dt = R*dt</span>
        <span class="s1">Xem = np.zeros((nrepl</span><span class="s2">,</span><span class="s1">L))    </span><span class="s3"># preallocate for efficiency</span>
        <span class="s1">Xtemp = xzero</span>
        <span class="s1">Xem[:</span><span class="s2">,</span><span class="s4">0</span><span class="s1">] = xzero</span>
        <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">np.arange(</span><span class="s4">1</span><span class="s2">,</span><span class="s1">L):</span>
            <span class="s3">#Winc = np.sum(dW[:,Tratio*(j-1)+1:Tratio*j],1)</span>
            <span class="s1">Winc = np.sum(dW[:</span><span class="s2">,</span><span class="s1">np.arange(Tratio*(j-</span><span class="s4">1</span><span class="s1">)+</span><span class="s4">1</span><span class="s2">,</span><span class="s1">Tratio*j)]</span><span class="s2">,</span><span class="s4">1</span><span class="s1">)</span>
            <span class="s3">#Xtemp = Xtemp + Dt*lamda*Xtemp + mu*Xtemp*Winc;</span>
            <span class="s1">Xtemp = Xtemp + self._drift(x=Xtemp) + self._sig(x=Xtemp) * Winc</span>
            <span class="s3">#Dt*lamda*Xtemp + mu*Xtemp*Winc;</span>
            <span class="s1">Xem[:</span><span class="s2">,</span><span class="s1">j] = Xtemp</span>
        <span class="s2">return </span><span class="s1">Xem</span>

<span class="s5">''' 
    R = 4; Dt = R*dt; L = N/R;        % L EM steps of size Dt = R*dt 
    Xem = zeros(1,L);                 % preallocate for efficiency 
    Xtemp = Xzero; 
    for j = 1:L 
       Winc = sum(dW(R*(j-1)+1:R*j)); 
       Xtemp = Xtemp + Dt*lambda*Xtemp + mu*Xtemp*Winc; 
       Xem(j) = Xtemp; 
    end 
'''</span>

<span class="s2">class </span><span class="s1">ExactDiffusion(AffineDiffusion):</span>
    <span class="s0">'''Diffusion that has an exact integral representation 
 
    this is currently mainly for geometric, log processes 
 
    '''</span>

    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">exactprocess(self</span><span class="s2">, </span><span class="s1">xzero</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">, </span><span class="s1">ddt=</span><span class="s4">1.</span><span class="s2">, </span><span class="s1">nrepl=</span><span class="s4">2</span><span class="s1">):</span>
        <span class="s0">'''ddt : discrete delta t 
 
 
 
        should be the same as an AR(1) 
        not tested yet 
        '''</span>
        <span class="s1">t = np.linspace(ddt</span><span class="s2">, </span><span class="s1">nobs*ddt</span><span class="s2">, </span><span class="s1">nobs)</span>
        <span class="s3">#expnt = np.exp(-self.lambd * t)</span>
        <span class="s1">expddt = np.exp(-self.lambd * ddt)</span>
        <span class="s1">normrvs = np.random.normal(size=(nrepl</span><span class="s2">,</span><span class="s1">nobs))</span>
        <span class="s3">#do I need lfilter here AR(1) ? if mean reverting lag-coeff&lt;1</span>
        <span class="s3">#lfilter does not handle 2d arrays, it does?</span>
        <span class="s1">inc = self._exactconst(expddt) + self._exactstd(expddt) * normrvs</span>
        <span class="s2">return </span><span class="s1">signal.lfilter([</span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1.</span><span class="s2">,</span><span class="s1">-expddt]</span><span class="s2">, </span><span class="s1">inc)</span>

    <span class="s2">def </span><span class="s1">exactdist(self</span><span class="s2">, </span><span class="s1">xzero</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s1">expnt = np.exp(-self.lambd * t)</span>
        <span class="s1">meant = xzero * expnt + self._exactconst(expnt)</span>
        <span class="s1">stdt = self._exactstd(expnt)</span>
        <span class="s2">return </span><span class="s1">stats.norm(loc=meant</span><span class="s2">, </span><span class="s1">scale=stdt)</span>

<span class="s2">class </span><span class="s1">ArithmeticBrownian(AffineDiffusion):</span>
    <span class="s0">''' 
    :math:: 
    dx_t &amp;= \\mu dt + \\sigma dW_t 
    '''</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">xzero</span><span class="s2">, </span><span class="s1">mu</span><span class="s2">, </span><span class="s1">sigma):</span>
        <span class="s1">self.xzero = xzero</span>
        <span class="s1">self.mu = mu</span>
        <span class="s1">self.sigma = sigma</span>

    <span class="s2">def </span><span class="s1">_drift(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwds):</span>
        <span class="s2">return </span><span class="s1">self.mu</span>
    <span class="s2">def </span><span class="s1">_sig(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwds):</span>
        <span class="s2">return </span><span class="s1">self.sigma</span>
    <span class="s2">def </span><span class="s1">exactprocess(self</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">, </span><span class="s1">xzero=</span><span class="s2">None, </span><span class="s1">ddt=</span><span class="s4">1.</span><span class="s2">, </span><span class="s1">nrepl=</span><span class="s4">2</span><span class="s1">):</span>
        <span class="s0">'''ddt : discrete delta t 
 
        not tested yet 
        '''</span>
        <span class="s2">if </span><span class="s1">xzero </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">xzero = self.xzero</span>
        <span class="s1">t = np.linspace(ddt</span><span class="s2">, </span><span class="s1">nobs*ddt</span><span class="s2">, </span><span class="s1">nobs)</span>
        <span class="s1">normrvs = np.random.normal(size=(nrepl</span><span class="s2">,</span><span class="s1">nobs))</span>
        <span class="s1">inc = self._drift + self._sigma * np.sqrt(ddt) * normrvs</span>
        <span class="s3">#return signal.lfilter([1.], [1.,-1], inc)</span>
        <span class="s2">return </span><span class="s1">xzero + np.cumsum(inc</span><span class="s2">,</span><span class="s4">1</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">exactdist(self</span><span class="s2">, </span><span class="s1">xzero</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s1">expnt = np.exp(-self.lambd * t)</span>
        <span class="s1">meant = self._drift * t</span>
        <span class="s1">stdt = self._sigma * np.sqrt(t)</span>
        <span class="s2">return </span><span class="s1">stats.norm(loc=meant</span><span class="s2">, </span><span class="s1">scale=stdt)</span>


<span class="s2">class </span><span class="s1">GeometricBrownian(AffineDiffusion):</span>
    <span class="s0">'''Geometric Brownian Motion 
 
    :math:: 
    dx_t &amp;= \\mu x_t dt + \\sigma x_t dW_t 
 
    $x_t $ stochastic process of Geometric Brownian motion, 
    $\\mu $ is the drift, 
    $\\sigma $ is the Volatility, 
    $W$ is the Wiener process (Brownian motion). 
 
    '''</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">xzero</span><span class="s2">, </span><span class="s1">mu</span><span class="s2">, </span><span class="s1">sigma):</span>
        <span class="s1">self.xzero = xzero</span>
        <span class="s1">self.mu = mu</span>
        <span class="s1">self.sigma = sigma</span>

    <span class="s2">def </span><span class="s1">_drift(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwds):</span>
        <span class="s1">x = kwds[</span><span class="s5">'x'</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s1">self.mu * x</span>
    <span class="s2">def </span><span class="s1">_sig(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwds):</span>
        <span class="s1">x = kwds[</span><span class="s5">'x'</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s1">self.sigma * x</span>


<span class="s2">class </span><span class="s1">OUprocess(AffineDiffusion):</span>
    <span class="s0">'''Ornstein-Uhlenbeck 
 
    :math:: 
      dx_t&amp;=\\lambda(\\mu - x_t)dt+\\sigma dW_t 
 
    mean reverting process 
 
 
 
    TODO: move exact higher up in class hierarchy 
    '''</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">xzero</span><span class="s2">, </span><span class="s1">mu</span><span class="s2">, </span><span class="s1">lambd</span><span class="s2">, </span><span class="s1">sigma):</span>
        <span class="s1">self.xzero = xzero</span>
        <span class="s1">self.lambd = lambd</span>
        <span class="s1">self.mu = mu</span>
        <span class="s1">self.sigma = sigma</span>

    <span class="s2">def </span><span class="s1">_drift(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwds):</span>
        <span class="s1">x = kwds[</span><span class="s5">'x'</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s1">self.lambd * (self.mu - x)</span>
    <span class="s2">def </span><span class="s1">_sig(self</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwds):</span>
        <span class="s1">x = kwds[</span><span class="s5">'x'</span><span class="s1">]</span>
        <span class="s2">return </span><span class="s1">self.sigma * x</span>
    <span class="s2">def </span><span class="s1">exact(self</span><span class="s2">, </span><span class="s1">xzero</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">normrvs):</span>
        <span class="s3">#TODO: aggregate over time for process with observations for all t</span>
        <span class="s3">#      i.e. exact conditional distribution for discrete time increment</span>
        <span class="s3">#      -&gt; exactprocess</span>
        <span class="s3">#TODO: for single t, return stats.norm -&gt; exactdist</span>
        <span class="s1">expnt = np.exp(-self.lambd * t)</span>
        <span class="s2">return </span><span class="s1">(xzero * expnt + self.mu * (</span><span class="s4">1</span><span class="s1">-expnt) +</span>
                <span class="s1">self.sigma * np.sqrt((</span><span class="s4">1</span><span class="s1">-expnt*expnt)/</span><span class="s4">2.</span><span class="s1">/self.lambd) * normrvs)</span>

    <span class="s2">def </span><span class="s1">exactprocess(self</span><span class="s2">, </span><span class="s1">xzero</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">, </span><span class="s1">ddt=</span><span class="s4">1.</span><span class="s2">, </span><span class="s1">nrepl=</span><span class="s4">2</span><span class="s1">):</span>
        <span class="s0">'''ddt : discrete delta t 
 
        should be the same as an AR(1) 
        not tested yet 
        # after writing this I saw the same use of lfilter in sitmo 
        '''</span>
        <span class="s1">t = np.linspace(ddt</span><span class="s2">, </span><span class="s1">nobs*ddt</span><span class="s2">, </span><span class="s1">nobs)</span>
        <span class="s1">expnt = np.exp(-self.lambd * t)</span>
        <span class="s1">expddt = np.exp(-self.lambd * ddt)</span>
        <span class="s1">normrvs = np.random.normal(size=(nrepl</span><span class="s2">,</span><span class="s1">nobs))</span>
        <span class="s3">#do I need lfilter here AR(1) ? lfilter does not handle 2d arrays, it does?</span>
        <span class="s2">from </span><span class="s1">scipy </span><span class="s2">import </span><span class="s1">signal</span>
        <span class="s3">#xzero * expnt</span>
        <span class="s1">inc = ( self.mu * (</span><span class="s4">1</span><span class="s1">-expddt) +</span>
                <span class="s1">self.sigma * np.sqrt((</span><span class="s4">1</span><span class="s1">-expddt*expddt)/</span><span class="s4">2.</span><span class="s1">/self.lambd) * normrvs )</span>

        <span class="s2">return </span><span class="s1">signal.lfilter([</span><span class="s4">1.</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[</span><span class="s4">1.</span><span class="s2">,</span><span class="s1">-expddt]</span><span class="s2">, </span><span class="s1">inc)</span>


    <span class="s2">def </span><span class="s1">exactdist(self</span><span class="s2">, </span><span class="s1">xzero</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s3">#TODO: aggregate over time for process with observations for all t</span>
        <span class="s3">#TODO: for single t, return stats.norm</span>
        <span class="s1">expnt = np.exp(-self.lambd * t)</span>
        <span class="s1">meant = xzero * expnt + self.mu * (</span><span class="s4">1</span><span class="s1">-expnt)</span>
        <span class="s1">stdt = self.sigma * np.sqrt((</span><span class="s4">1</span><span class="s1">-expnt*expnt)/</span><span class="s4">2.</span><span class="s1">/self.lambd)</span>
        <span class="s2">from </span><span class="s1">scipy </span><span class="s2">import </span><span class="s1">stats</span>
        <span class="s2">return </span><span class="s1">stats.norm(loc=meant</span><span class="s2">, </span><span class="s1">scale=stdt)</span>

    <span class="s2">def </span><span class="s1">fitls(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">dt):</span>
        <span class="s0">'''assumes data is 1d, univariate time series 
        formula from sitmo 
        '''</span>
        <span class="s3"># brute force, no parameter estimation errors</span>
        <span class="s1">nobs = len(data)-</span><span class="s4">1</span>
        <span class="s1">exog = np.column_stack((np.ones(nobs)</span><span class="s2">, </span><span class="s1">data[:-</span><span class="s4">1</span><span class="s1">]))</span>
        <span class="s1">parest</span><span class="s2">, </span><span class="s1">res</span><span class="s2">, </span><span class="s1">rank</span><span class="s2">, </span><span class="s1">sing = np.linalg.lstsq(exog</span><span class="s2">, </span><span class="s1">data[</span><span class="s4">1</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">rcond=-</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">const</span><span class="s2">, </span><span class="s1">slope = parest</span>
        <span class="s1">errvar = res/(nobs-</span><span class="s4">2.</span><span class="s1">)</span>
        <span class="s1">lambd = -np.log(slope)/dt</span>
        <span class="s1">sigma = np.sqrt(-errvar * </span><span class="s4">2.</span><span class="s1">*np.log(slope)/ (</span><span class="s4">1</span><span class="s1">-slope**</span><span class="s4">2</span><span class="s1">)/dt)</span>
        <span class="s1">mu = const / (</span><span class="s4">1</span><span class="s1">-slope)</span>
        <span class="s2">return </span><span class="s1">mu</span><span class="s2">, </span><span class="s1">lambd</span><span class="s2">, </span><span class="s1">sigma</span>


<span class="s2">class </span><span class="s1">SchwartzOne(ExactDiffusion):</span>
    <span class="s0">'''the Schwartz type 1 stochastic process 
 
    :math:: 
    dx_t = \\kappa (\\mu - \\ln x_t) x_t dt + \\sigma x_tdW \\ 
 
    The Schwartz type 1 process is a log of the Ornstein-Uhlenbeck stochastic 
    process. 
 
    '''</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">xzero</span><span class="s2">, </span><span class="s1">mu</span><span class="s2">, </span><span class="s1">kappa</span><span class="s2">, </span><span class="s1">sigma):</span>
        <span class="s1">self.xzero = xzero</span>
        <span class="s1">self.mu = mu</span>
        <span class="s1">self.kappa = kappa</span>
        <span class="s1">self.lambd = kappa </span><span class="s3">#alias until I fix exact</span>
        <span class="s1">self.sigma = sigma</span>

    <span class="s2">def </span><span class="s1">_exactconst(self</span><span class="s2">, </span><span class="s1">expnt):</span>
        <span class="s2">return </span><span class="s1">(</span><span class="s4">1</span><span class="s1">-expnt) * (self.mu - self.sigma**</span><span class="s4">2 </span><span class="s1">/ </span><span class="s4">2. </span><span class="s1">/self.kappa)</span>

    <span class="s2">def </span><span class="s1">_exactstd(self</span><span class="s2">, </span><span class="s1">expnt):</span>
        <span class="s2">return </span><span class="s1">self.sigma * np.sqrt((</span><span class="s4">1</span><span class="s1">-expnt*expnt)/</span><span class="s4">2.</span><span class="s1">/self.kappa)</span>

    <span class="s2">def </span><span class="s1">exactprocess(self</span><span class="s2">, </span><span class="s1">xzero</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">, </span><span class="s1">ddt=</span><span class="s4">1.</span><span class="s2">, </span><span class="s1">nrepl=</span><span class="s4">2</span><span class="s1">):</span>
        <span class="s0">'''uses exact solution for log of process 
        '''</span>
        <span class="s1">lnxzero = np.log(xzero)</span>
        <span class="s1">lnx = super(self.__class__</span><span class="s2">, </span><span class="s1">self).exactprocess(xzero</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">, </span><span class="s1">ddt=ddt</span><span class="s2">, </span><span class="s1">nrepl=nrepl)</span>
        <span class="s2">return </span><span class="s1">np.exp(lnx)</span>

    <span class="s2">def </span><span class="s1">exactdist(self</span><span class="s2">, </span><span class="s1">xzero</span><span class="s2">, </span><span class="s1">t):</span>
        <span class="s1">expnt = np.exp(-self.lambd * t)</span>
        <span class="s3">#TODO: check this is still wrong, just guessing</span>
        <span class="s1">meant = np.log(xzero) * expnt + self._exactconst(expnt)</span>
        <span class="s1">stdt = self._exactstd(expnt)</span>
        <span class="s2">return </span><span class="s1">stats.lognorm(loc=meant</span><span class="s2">, </span><span class="s1">scale=stdt)</span>

    <span class="s2">def </span><span class="s1">fitls(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">dt):</span>
        <span class="s0">'''assumes data is 1d, univariate time series 
        formula from sitmo 
        '''</span>
        <span class="s3"># brute force, no parameter estimation errors</span>
        <span class="s1">nobs = len(data)-</span><span class="s4">1</span>
        <span class="s1">exog = np.column_stack((np.ones(nobs)</span><span class="s2">,</span><span class="s1">np.log(data[:-</span><span class="s4">1</span><span class="s1">])))</span>
        <span class="s1">parest</span><span class="s2">, </span><span class="s1">res</span><span class="s2">, </span><span class="s1">rank</span><span class="s2">, </span><span class="s1">sing = np.linalg.lstsq(exog</span><span class="s2">, </span><span class="s1">np.log(data[</span><span class="s4">1</span><span class="s1">:])</span><span class="s2">, </span><span class="s1">rcond=-</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">const</span><span class="s2">, </span><span class="s1">slope = parest</span>
        <span class="s1">errvar = res/(nobs-</span><span class="s4">2.</span><span class="s1">)  </span><span class="s3">#check denominator estimate, of sigma too low</span>
        <span class="s1">kappa = -np.log(slope)/dt</span>
        <span class="s1">sigma = np.sqrt(errvar * kappa / (</span><span class="s4">1</span><span class="s1">-np.exp(-</span><span class="s4">2</span><span class="s1">*kappa*dt)))</span>
        <span class="s1">mu = const / (</span><span class="s4">1</span><span class="s1">-np.exp(-kappa*dt)) + sigma**</span><span class="s4">2</span><span class="s1">/</span><span class="s4">2.</span><span class="s1">/kappa</span>
        <span class="s2">if </span><span class="s1">np.shape(mu)== (</span><span class="s4">1</span><span class="s2">,</span><span class="s1">):</span>
            <span class="s1">mu = mu[</span><span class="s4">0</span><span class="s1">]   </span><span class="s3"># TODO: how to remove scalar array ?</span>
        <span class="s2">if </span><span class="s1">np.shape(sigma)== (</span><span class="s4">1</span><span class="s2">,</span><span class="s1">):</span>
            <span class="s1">sigma = sigma[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s3">#mu, kappa are good, sigma too small</span>
        <span class="s2">return </span><span class="s1">mu</span><span class="s2">, </span><span class="s1">kappa</span><span class="s2">, </span><span class="s1">sigma</span>



<span class="s2">class </span><span class="s1">BrownianBridge:</span>
    <span class="s2">def </span><span class="s1">__init__(self):</span>
        <span class="s2">pass</span>

    <span class="s2">def </span><span class="s1">simulate(self</span><span class="s2">, </span><span class="s1">x0</span><span class="s2">, </span><span class="s1">x1</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">, </span><span class="s1">nrepl=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">ddt=</span><span class="s4">1.</span><span class="s2">, </span><span class="s1">sigma=</span><span class="s4">1.</span><span class="s1">):</span>
        <span class="s1">nobs=nobs+</span><span class="s4">1</span>
        <span class="s1">dt = ddt*</span><span class="s4">1.</span><span class="s1">/nobs</span>
        <span class="s1">t = np.linspace(dt</span><span class="s2">, </span><span class="s1">ddt-dt</span><span class="s2">, </span><span class="s1">nobs)</span>
        <span class="s1">t = np.linspace(dt</span><span class="s2">, </span><span class="s1">ddt</span><span class="s2">, </span><span class="s1">nobs)</span>
        <span class="s1">wm = [t/ddt</span><span class="s2">, </span><span class="s4">1</span><span class="s1">-t/ddt]</span>
        <span class="s3">#wmi = wm[1]</span>
        <span class="s3">#wm1 = x1*wm[0]</span>
        <span class="s1">wmi = </span><span class="s4">1</span><span class="s1">-dt/(ddt-t)</span>
        <span class="s1">wm1 = x1*(dt/(ddt-t))</span>
        <span class="s1">su = sigma* np.sqrt(t*(</span><span class="s4">1</span><span class="s1">-t)/ddt)</span>
        <span class="s1">s = sigma* np.sqrt(dt*(ddt-t-dt)/(ddt-t))</span>
        <span class="s1">x = np.zeros((nrepl</span><span class="s2">, </span><span class="s1">nobs))</span>
        <span class="s1">x[:</span><span class="s2">,</span><span class="s4">0</span><span class="s1">] = x0</span>
        <span class="s1">rvs = s*np.random.normal(size=(nrepl</span><span class="s2">,</span><span class="s1">nobs))</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">1</span><span class="s2">,</span><span class="s1">nobs):</span>
            <span class="s1">x[:</span><span class="s2">,</span><span class="s1">i] = x[:</span><span class="s2">,</span><span class="s1">i-</span><span class="s4">1</span><span class="s1">]*wmi[i] + wm1[i] + rvs[:</span><span class="s2">,</span><span class="s1">i]</span>
        <span class="s2">return </span><span class="s1">x</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">su</span>


<span class="s2">class </span><span class="s1">CompoundPoisson:</span>
    <span class="s0">'''nobs iid compound poisson distributions, not a process in time 
    '''</span>
    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">lambd</span><span class="s2">, </span><span class="s1">randfn=np.random.normal):</span>
        <span class="s2">if </span><span class="s1">len(lambd) != len(randfn):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s5">'lambd and randfn need to have the same number of elements'</span><span class="s1">)</span>

        <span class="s1">self.nobj = len(lambd)</span>
        <span class="s1">self.randfn = randfn</span>
        <span class="s1">self.lambd = np.asarray(lambd)</span>

    <span class="s2">def </span><span class="s1">simulate(self</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">, </span><span class="s1">nrepl=</span><span class="s4">1</span><span class="s1">):</span>
        <span class="s1">nobj = self.nobj</span>
        <span class="s1">x = np.zeros((nrepl</span><span class="s2">, </span><span class="s1">nobs</span><span class="s2">, </span><span class="s1">nobj))</span>
        <span class="s1">N = np.random.poisson(self.lambd[</span><span class="s2">None,None,</span><span class="s1">:]</span><span class="s2">, </span><span class="s1">size=(nrepl</span><span class="s2">,</span><span class="s1">nobs</span><span class="s2">,</span><span class="s1">nobj))</span>
        <span class="s2">for </span><span class="s1">io </span><span class="s2">in </span><span class="s1">range(nobj):</span>
            <span class="s1">randfnc = self.randfn[io]</span>

            <span class="s1">nc = N[:</span><span class="s2">,</span><span class="s1">:</span><span class="s2">,</span><span class="s1">io]</span>
            <span class="s3">#print nrepl,nobs,nc</span>
            <span class="s3">#xio = randfnc(size=(nrepl,nobs,np.max(nc))).cumsum(-1)[np.arange(nrepl)[:,None],np.arange(nobs),nc-1]</span>
            <span class="s1">rvs = randfnc(size=(nrepl</span><span class="s2">,</span><span class="s1">nobs</span><span class="s2">,</span><span class="s1">np.max(nc)))</span>
            <span class="s1">print(</span><span class="s5">'rvs.sum()'</span><span class="s2">, </span><span class="s1">rvs.sum()</span><span class="s2">, </span><span class="s1">rvs.shape)</span>
            <span class="s1">xio = rvs.cumsum(-</span><span class="s4">1</span><span class="s1">)[np.arange(nrepl)[:</span><span class="s2">,None</span><span class="s1">]</span><span class="s2">,</span><span class="s1">np.arange(nobs)</span><span class="s2">,</span><span class="s1">nc-</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s3">#print xio.shape</span>
            <span class="s1">x[:</span><span class="s2">,</span><span class="s1">:</span><span class="s2">,</span><span class="s1">io] = xio</span>
        <span class="s1">x[N==</span><span class="s4">0</span><span class="s1">] = </span><span class="s4">0</span>
        <span class="s2">return </span><span class="s1">x</span><span class="s2">, </span><span class="s1">N</span>









<span class="s5">''' 
randn('state',100)                                % set the state of randn 
T = 1; N = 500; dt = T/N; t = [dt:dt:1]; 
 
M = 1000;                                         % M paths simultaneously 
dW = sqrt(dt)*randn(M,N);                         % increments 
W = cumsum(dW,2);                                 % cumulative sum 
U = exp(repmat(t,[M 1]) + 0.5*W); 
Umean = mean(U); 
plot([0,t],[1,Umean],'b-'), hold on               % plot mean over M paths 
plot([0,t],[ones(5,1),U(1:5,:)],'r--'), hold off  % plot 5 individual paths 
xlabel('t','FontSize',16) 
ylabel('U(t)','FontSize',16,'Rotation',0,'HorizontalAlignment','right') 
legend('mean of 1000 paths','5 individual paths',2) 
 
averr = norm((Umean - exp(9*t/8)),'inf')          % sample error 
'''</span>

<span class="s2">if </span><span class="s1">__name__ == </span><span class="s5">'__main__'</span><span class="s1">:</span>
    <span class="s1">doplot = </span><span class="s4">1</span>
    <span class="s1">nrepl = </span><span class="s4">1000</span>
    <span class="s1">examples = []</span><span class="s3">#['all']</span>

    <span class="s2">if </span><span class="s5">'all' </span><span class="s2">in </span><span class="s1">examples:</span>
        <span class="s1">w = Diffusion()</span>

        <span class="s3"># Wiener Process</span>
        <span class="s3"># ^^^^^^^^^^^^^^</span>

        <span class="s1">ws = w.simulateW(</span><span class="s4">1000</span><span class="s2">, </span><span class="s1">nrepl=nrepl)</span>
        <span class="s2">if </span><span class="s1">doplot:</span>
            <span class="s1">plt.figure()</span>
            <span class="s1">tmp = plt.plot(ws[</span><span class="s4">0</span><span class="s1">].T)</span>
            <span class="s1">tmp = plt.plot(ws[</span><span class="s4">0</span><span class="s1">].mean(</span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">linewidth=</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s1">plt.title(</span><span class="s5">'Standard Brownian Motion (Wiener Process)'</span><span class="s1">)</span>

        <span class="s1">func = </span><span class="s2">lambda </span><span class="s1">t</span><span class="s2">, </span><span class="s1">W: np.exp(t + </span><span class="s4">0.5</span><span class="s1">*W)</span>
        <span class="s1">us = w.expectedsim(func</span><span class="s2">, </span><span class="s1">nobs=</span><span class="s4">500</span><span class="s2">, </span><span class="s1">nrepl=nrepl)</span>
        <span class="s2">if </span><span class="s1">doplot:</span>
            <span class="s1">plt.figure()</span>
            <span class="s1">tmp = plt.plot(us[</span><span class="s4">0</span><span class="s1">].T)</span>
            <span class="s1">tmp = plt.plot(us[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">linewidth=</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s1">plt.title(</span><span class="s5">'Brownian Motion - exp'</span><span class="s1">)</span>
        <span class="s3">#plt.show()</span>
        <span class="s1">averr = np.linalg.norm(us[</span><span class="s4">1</span><span class="s1">] - np.exp(</span><span class="s4">9</span><span class="s1">*us[</span><span class="s4">2</span><span class="s1">]/</span><span class="s4">8.</span><span class="s1">)</span><span class="s2">, </span><span class="s1">np.inf)</span>
        <span class="s1">print(averr)</span>
        <span class="s3">#print us[1][:10]</span>
        <span class="s3">#print np.exp(9.*us[2][:10]/8.)</span>

        <span class="s3"># Geometric Brownian</span>
        <span class="s3"># ^^^^^^^^^^^^^^^^^^</span>

        <span class="s1">gb = GeometricBrownian(xzero=</span><span class="s4">1.</span><span class="s2">, </span><span class="s1">mu=</span><span class="s4">0.01</span><span class="s2">, </span><span class="s1">sigma=</span><span class="s4">0.5</span><span class="s1">)</span>
        <span class="s1">gbs = gb.simEM(nobs=</span><span class="s4">100</span><span class="s2">, </span><span class="s1">nrepl=</span><span class="s4">100</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">doplot:</span>
            <span class="s1">plt.figure()</span>
            <span class="s1">tmp = plt.plot(gbs.T)</span>
            <span class="s1">tmp = plt.plot(gbs.mean(</span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">linewidth=</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s1">plt.title(</span><span class="s5">'Geometric Brownian'</span><span class="s1">)</span>
            <span class="s1">plt.figure()</span>
            <span class="s1">tmp = plt.plot(np.log(gbs).T)</span>
            <span class="s1">tmp = plt.plot(np.log(gbs.mean(</span><span class="s4">0</span><span class="s1">))</span><span class="s2">, </span><span class="s1">linewidth=</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s1">plt.title(</span><span class="s5">'Geometric Brownian - log-transformed'</span><span class="s1">)</span>

        <span class="s1">ab = ArithmeticBrownian(xzero=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">mu=</span><span class="s4">0.05</span><span class="s2">, </span><span class="s1">sigma=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s1">abs = ab.simEM(nobs=</span><span class="s4">100</span><span class="s2">, </span><span class="s1">nrepl=</span><span class="s4">100</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">doplot:</span>
            <span class="s1">plt.figure()</span>
            <span class="s1">tmp = plt.plot(abs.T)</span>
            <span class="s1">tmp = plt.plot(abs.mean(</span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">linewidth=</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s1">plt.title(</span><span class="s5">'Arithmetic Brownian'</span><span class="s1">)</span>

        <span class="s3"># Ornstein-Uhlenbeck</span>
        <span class="s3"># ^^^^^^^^^^^^^^^^^^</span>

        <span class="s1">ou = OUprocess(xzero=</span><span class="s4">2</span><span class="s2">, </span><span class="s1">mu=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">lambd=</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">sigma=</span><span class="s4">0.1</span><span class="s1">)</span>
        <span class="s1">ous = ou.simEM()</span>
        <span class="s1">oue = ou.exact(</span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s1">np.random.normal(size=(</span><span class="s4">5</span><span class="s2">,</span><span class="s4">10</span><span class="s1">)))</span>
        <span class="s1">ou.exact(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">np.linspace(</span><span class="s4">0</span><span class="s2">,</span><span class="s4">10</span><span class="s2">,</span><span class="s4">10</span><span class="s1">/</span><span class="s4">0.1</span><span class="s1">)</span><span class="s2">, </span><span class="s4">0</span><span class="s1">)</span>
        <span class="s1">ou.exactprocess(</span><span class="s4">0</span><span class="s2">,</span><span class="s4">10</span><span class="s1">)</span>
        <span class="s1">print(ou.exactprocess(</span><span class="s4">0</span><span class="s2">,</span><span class="s4">10</span><span class="s2">, </span><span class="s1">ddt=</span><span class="s4">0.1</span><span class="s2">,</span><span class="s1">nrepl=</span><span class="s4">10</span><span class="s1">).mean(</span><span class="s4">0</span><span class="s1">))</span>
        <span class="s3">#the following looks good, approaches mu</span>
        <span class="s1">oues = ou.exactprocess(</span><span class="s4">0</span><span class="s2">,</span><span class="s4">100</span><span class="s2">, </span><span class="s1">ddt=</span><span class="s4">0.1</span><span class="s2">,</span><span class="s1">nrepl=</span><span class="s4">100</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">doplot:</span>
            <span class="s1">plt.figure()</span>
            <span class="s1">tmp = plt.plot(oues.T)</span>
            <span class="s1">tmp = plt.plot(oues.mean(</span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">linewidth=</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s1">plt.title(</span><span class="s5">'Ornstein-Uhlenbeck'</span><span class="s1">)</span>

        <span class="s3"># SchwartsOne</span>
        <span class="s3"># ^^^^^^^^^^^</span>

        <span class="s1">so = SchwartzOne(xzero=</span><span class="s4">0</span><span class="s2">, </span><span class="s1">mu=</span><span class="s4">1</span><span class="s2">, </span><span class="s1">kappa=</span><span class="s4">0.5</span><span class="s2">, </span><span class="s1">sigma=</span><span class="s4">0.1</span><span class="s1">)</span>
        <span class="s1">sos = so.exactprocess(</span><span class="s4">0</span><span class="s2">,</span><span class="s4">50</span><span class="s2">, </span><span class="s1">ddt=</span><span class="s4">0.1</span><span class="s2">,</span><span class="s1">nrepl=</span><span class="s4">100</span><span class="s1">)</span>
        <span class="s1">print(sos.mean(</span><span class="s4">0</span><span class="s1">))</span>
        <span class="s1">print(np.log(sos.mean(</span><span class="s4">0</span><span class="s1">)))</span>
        <span class="s1">doplot = </span><span class="s4">1</span>
        <span class="s2">if </span><span class="s1">doplot:</span>
            <span class="s1">plt.figure()</span>
            <span class="s1">tmp = plt.plot(sos.T)</span>
            <span class="s1">tmp = plt.plot(sos.mean(</span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">linewidth=</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s1">plt.title(</span><span class="s5">'Schwartz One'</span><span class="s1">)</span>
        <span class="s1">print(so.fitls(sos[</span><span class="s4">0</span><span class="s2">,</span><span class="s1">:]</span><span class="s2">,</span><span class="s1">dt=</span><span class="s4">0.1</span><span class="s1">))</span>
        <span class="s1">sos2 = so.exactprocess(</span><span class="s4">0</span><span class="s2">,</span><span class="s4">500</span><span class="s2">, </span><span class="s1">ddt=</span><span class="s4">0.1</span><span class="s2">,</span><span class="s1">nrepl=</span><span class="s4">5</span><span class="s1">)</span>
        <span class="s1">print(</span><span class="s5">'true: mu=1, kappa=0.5, sigma=0.1'</span><span class="s1">)</span>
        <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(</span><span class="s4">5</span><span class="s1">):</span>
            <span class="s1">print(so.fitls(sos2[i]</span><span class="s2">,</span><span class="s1">dt=</span><span class="s4">0.1</span><span class="s1">))</span>



        <span class="s3"># Brownian Bridge</span>
        <span class="s3"># ^^^^^^^^^^^^^^^</span>

        <span class="s1">bb = BrownianBridge()</span>
        <span class="s3">#bbs = bb.sample(x0, x1, nobs, nrepl=1, ddt=1., sigma=1.)</span>
        <span class="s1">bbs</span><span class="s2">, </span><span class="s1">t</span><span class="s2">, </span><span class="s1">wm = bb.simulate(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">0.5</span><span class="s2">, </span><span class="s4">99</span><span class="s2">, </span><span class="s1">nrepl=</span><span class="s4">500</span><span class="s2">, </span><span class="s1">ddt=</span><span class="s4">1.</span><span class="s2">, </span><span class="s1">sigma=</span><span class="s4">0.1</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">doplot:</span>
            <span class="s1">plt.figure()</span>
            <span class="s1">tmp = plt.plot(bbs.T)</span>
            <span class="s1">tmp = plt.plot(bbs.mean(</span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">linewidth=</span><span class="s4">2</span><span class="s1">)</span>
            <span class="s1">plt.title(</span><span class="s5">'Brownian Bridge'</span><span class="s1">)</span>
            <span class="s1">plt.figure()</span>
            <span class="s1">plt.plot(wm</span><span class="s2">,</span><span class="s5">'r'</span><span class="s2">, </span><span class="s1">label=</span><span class="s5">'theoretical'</span><span class="s1">)</span>
            <span class="s1">plt.plot(bbs.std(</span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">label=</span><span class="s5">'simulated'</span><span class="s1">)</span>
            <span class="s1">plt.title(</span><span class="s5">'Brownian Bridge - Variance'</span><span class="s1">)</span>
            <span class="s1">plt.legend()</span>

    <span class="s3"># Compound Poisson</span>
    <span class="s3"># ^^^^^^^^^^^^^^^^</span>
    <span class="s1">cp = CompoundPoisson([</span><span class="s4">1</span><span class="s2">,</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s1">[np.random.normal</span><span class="s2">,</span><span class="s1">np.random.normal])</span>
    <span class="s1">cps = cp.simulate(nobs=</span><span class="s4">20000</span><span class="s2">,</span><span class="s1">nrepl=</span><span class="s4">3</span><span class="s1">)</span>
    <span class="s1">print(cps[</span><span class="s4">0</span><span class="s1">].sum(-</span><span class="s4">1</span><span class="s1">).sum(-</span><span class="s4">1</span><span class="s1">))</span>
    <span class="s1">print(cps[</span><span class="s4">0</span><span class="s1">].sum())</span>
    <span class="s1">print(cps[</span><span class="s4">0</span><span class="s1">].mean(-</span><span class="s4">1</span><span class="s1">).mean(-</span><span class="s4">1</span><span class="s1">))</span>
    <span class="s1">print(cps[</span><span class="s4">0</span><span class="s1">].mean())</span>
    <span class="s1">print(cps[</span><span class="s4">1</span><span class="s1">].size)</span>
    <span class="s1">print(cps[</span><span class="s4">1</span><span class="s1">].sum())</span>
    <span class="s3">#Note Y = sum^{N} X is compound poisson of iid x, then</span>
    <span class="s3">#E(Y) = E(N)*E(X)   eg. eq. (6.37) page 385 in http://ee.stanford.edu/~gray/sp.html</span>


    <span class="s3">#plt.show()</span>
</pre>
</body>
</html>