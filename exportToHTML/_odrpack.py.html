<html>
<head>
<title>_odrpack.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_odrpack.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
Python wrappers for Orthogonal Distance Regression (ODRPACK). 
 
Notes 
===== 
 
* Array formats -- FORTRAN stores its arrays in memory column first, i.e., an 
  array element A(i, j, k) will be next to A(i+1, j, k). In C and, consequently, 
  NumPy, arrays are stored row first: A[i, j, k] is next to A[i, j, k+1]. For 
  efficiency and convenience, the input and output arrays of the fitting 
  function (and its Jacobians) are passed to FORTRAN without transposition. 
  Therefore, where the ODRPACK documentation says that the X array is of shape 
  (N, M), it will be passed to the Python function as an array of shape (M, N). 
  If M==1, the 1-D case, then nothing matters; if M&gt;1, then your 
  Python functions will be dealing with arrays that are indexed in reverse of 
  the ODRPACK documentation. No real issue, but watch out for your indexing of 
  the Jacobians: the i,jth elements (@f_i/@x_j) evaluated at the nth 
  observation will be returned as jacd[j, i, n]. Except for the Jacobians, it 
  really is easier to deal with x[0] and x[1] than x[:,0] and x[:,1]. Of course, 
  you can always use the transpose() function from SciPy explicitly. 
 
* Examples -- See the accompanying file test/test.py for examples of how to set 
  up fits of your own. Some are taken from the User's Guide; some are from 
  other sources. 
 
* Models -- Some common models are instantiated in the accompanying module 
  models.py . Contributions are welcome. 
 
Credits 
======= 
 
* Thanks to Arnold Moene and Gerard Vermeulen for fixing some killer bugs. 
 
Robert Kern 
robert.kern@gmail.com 
 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">os</span>

<span class="s2">import </span><span class="s1">numpy</span>
<span class="s2">from </span><span class="s1">warnings </span><span class="s2">import </span><span class="s1">warn</span>
<span class="s2">from </span><span class="s1">scipy.odr </span><span class="s2">import </span><span class="s1">__odrpack</span>

<span class="s1">__all__ = [</span><span class="s3">'odr'</span><span class="s2">, </span><span class="s3">'OdrWarning'</span><span class="s2">, </span><span class="s3">'OdrError'</span><span class="s2">, </span><span class="s3">'OdrStop'</span><span class="s2">,</span>
           <span class="s3">'Data'</span><span class="s2">, </span><span class="s3">'RealData'</span><span class="s2">, </span><span class="s3">'Model'</span><span class="s2">, </span><span class="s3">'Output'</span><span class="s2">, </span><span class="s3">'ODR'</span><span class="s2">,</span>
           <span class="s3">'odr_error'</span><span class="s2">, </span><span class="s3">'odr_stop'</span><span class="s1">]</span>

<span class="s1">odr = __odrpack.odr</span>


<span class="s2">class </span><span class="s1">OdrWarning(UserWarning):</span>
    <span class="s0">&quot;&quot;&quot; 
    Warning indicating that the data passed into 
    ODR will cause problems when passed into 'odr' 
    that the user should be aware of. 
    &quot;&quot;&quot;</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">OdrError(Exception):</span>
    <span class="s0">&quot;&quot;&quot; 
    Exception indicating an error in fitting. 
 
    This is raised by `~scipy.odr.odr` if an error occurs during fitting. 
    &quot;&quot;&quot;</span>
    <span class="s2">pass</span>


<span class="s2">class </span><span class="s1">OdrStop(Exception):</span>
    <span class="s0">&quot;&quot;&quot; 
    Exception stopping fitting. 
 
    You can raise this exception in your objective function to tell 
    `~scipy.odr.odr` to stop fitting. 
    &quot;&quot;&quot;</span>
    <span class="s2">pass</span>


<span class="s4"># Backwards compatibility</span>
<span class="s1">odr_error = OdrError</span>
<span class="s1">odr_stop = OdrStop</span>

<span class="s1">__odrpack._set_exceptions(OdrError</span><span class="s2">, </span><span class="s1">OdrStop)</span>


<span class="s2">def </span><span class="s1">_conv(obj</span><span class="s2">, </span><span class="s1">dtype=</span><span class="s2">None</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot; Convert an object to the preferred form for input to the odr routine. 
    &quot;&quot;&quot;</span>

    <span class="s2">if </span><span class="s1">obj </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">obj</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">dtype </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">obj = numpy.asarray(obj)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">obj = numpy.asarray(obj</span><span class="s2">, </span><span class="s1">dtype)</span>
        <span class="s2">if </span><span class="s1">obj.shape == ():</span>
            <span class="s4"># Scalar.</span>
            <span class="s2">return </span><span class="s1">obj.dtype.type(obj)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">obj</span>


<span class="s2">def </span><span class="s1">_report_error(info):</span>
    <span class="s0">&quot;&quot;&quot; Interprets the return code of the odr routine. 
 
    Parameters 
    ---------- 
    info : int 
        The return code of the odr routine. 
 
    Returns 
    ------- 
    problems : list(str) 
        A list of messages about why the odr() routine stopped. 
    &quot;&quot;&quot;</span>

    <span class="s1">stopreason = (</span><span class="s3">'Blank'</span><span class="s2">,</span>
                  <span class="s3">'Sum of squares convergence'</span><span class="s2">,</span>
                  <span class="s3">'Parameter convergence'</span><span class="s2">,</span>
                  <span class="s3">'Both sum of squares and parameter convergence'</span><span class="s2">,</span>
                  <span class="s3">'Iteration limit reached'</span><span class="s1">)[info % </span><span class="s5">5</span><span class="s1">]</span>

    <span class="s2">if </span><span class="s1">info &gt;= </span><span class="s5">5</span><span class="s1">:</span>
        <span class="s4"># questionable results or fatal error</span>

        <span class="s1">I = (info//</span><span class="s5">10000 </span><span class="s1">% </span><span class="s5">10</span><span class="s2">,</span>
             <span class="s1">info//</span><span class="s5">1000 </span><span class="s1">% </span><span class="s5">10</span><span class="s2">,</span>
             <span class="s1">info//</span><span class="s5">100 </span><span class="s1">% </span><span class="s5">10</span><span class="s2">,</span>
             <span class="s1">info//</span><span class="s5">10 </span><span class="s1">% </span><span class="s5">10</span><span class="s2">,</span>
             <span class="s1">info % </span><span class="s5">10</span><span class="s1">)</span>
        <span class="s1">problems = []</span>

        <span class="s2">if </span><span class="s1">I[</span><span class="s5">0</span><span class="s1">] == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">I[</span><span class="s5">1</span><span class="s1">] != </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">problems.append(</span><span class="s3">'Derivatives possibly not correct'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">I[</span><span class="s5">2</span><span class="s1">] != </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">problems.append(</span><span class="s3">'Error occurred in callback'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">I[</span><span class="s5">3</span><span class="s1">] != </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">problems.append(</span><span class="s3">'Problem is not full rank at solution'</span><span class="s1">)</span>
            <span class="s1">problems.append(stopreason)</span>
        <span class="s2">elif </span><span class="s1">I[</span><span class="s5">0</span><span class="s1">] == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">I[</span><span class="s5">1</span><span class="s1">] != </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">problems.append(</span><span class="s3">'N &lt; 1'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">I[</span><span class="s5">2</span><span class="s1">] != </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">problems.append(</span><span class="s3">'M &lt; 1'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">I[</span><span class="s5">3</span><span class="s1">] != </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">problems.append(</span><span class="s3">'NP &lt; 1 or NP &gt; N'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">I[</span><span class="s5">4</span><span class="s1">] != </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">problems.append(</span><span class="s3">'NQ &lt; 1'</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">I[</span><span class="s5">0</span><span class="s1">] == </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">I[</span><span class="s5">1</span><span class="s1">] != </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">problems.append(</span><span class="s3">'LDY and/or LDX incorrect'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">I[</span><span class="s5">2</span><span class="s1">] != </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">problems.append(</span><span class="s3">'LDWE, LD2WE, LDWD, and/or LD2WD incorrect'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">I[</span><span class="s5">3</span><span class="s1">] != </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">problems.append(</span><span class="s3">'LDIFX, LDSTPD, and/or LDSCLD incorrect'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">I[</span><span class="s5">4</span><span class="s1">] != </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">problems.append(</span><span class="s3">'LWORK and/or LIWORK too small'</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">I[</span><span class="s5">0</span><span class="s1">] == </span><span class="s5">3</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">I[</span><span class="s5">1</span><span class="s1">] != </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">problems.append(</span><span class="s3">'STPB and/or STPD incorrect'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">I[</span><span class="s5">2</span><span class="s1">] != </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">problems.append(</span><span class="s3">'SCLB and/or SCLD incorrect'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">I[</span><span class="s5">3</span><span class="s1">] != </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">problems.append(</span><span class="s3">'WE incorrect'</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">I[</span><span class="s5">4</span><span class="s1">] != </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">problems.append(</span><span class="s3">'WD incorrect'</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">I[</span><span class="s5">0</span><span class="s1">] == </span><span class="s5">4</span><span class="s1">:</span>
            <span class="s1">problems.append(</span><span class="s3">'Error in derivatives'</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">I[</span><span class="s5">0</span><span class="s1">] == </span><span class="s5">5</span><span class="s1">:</span>
            <span class="s1">problems.append(</span><span class="s3">'Error occurred in callback'</span><span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">I[</span><span class="s5">0</span><span class="s1">] == </span><span class="s5">6</span><span class="s1">:</span>
            <span class="s1">problems.append(</span><span class="s3">'Numerical error detected'</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">problems</span>

    <span class="s2">else</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">[stopreason]</span>


<span class="s2">class </span><span class="s1">Data:</span>
    <span class="s0">&quot;&quot;&quot; 
    The data to fit. 
 
    Parameters 
    ---------- 
    x : array_like 
        Observed data for the independent variable of the regression 
    y : array_like, optional 
        If array-like, observed data for the dependent variable of the 
        regression. A scalar input implies that the model to be used on 
        the data is implicit. 
    we : array_like, optional 
        If `we` is a scalar, then that value is used for all data points (and 
        all dimensions of the response variable). 
        If `we` is a rank-1 array of length q (the dimensionality of the 
        response variable), then this vector is the diagonal of the covariant 
        weighting matrix for all data points. 
        If `we` is a rank-1 array of length n (the number of data points), then 
        the i'th element is the weight for the i'th response variable 
        observation (single-dimensional only). 
        If `we` is a rank-2 array of shape (q, q), then this is the full 
        covariant weighting matrix broadcast to each observation. 
        If `we` is a rank-2 array of shape (q, n), then `we[:,i]` is the 
        diagonal of the covariant weighting matrix for the i'th observation. 
        If `we` is a rank-3 array of shape (q, q, n), then `we[:,:,i]` is the 
        full specification of the covariant weighting matrix for each 
        observation. 
        If the fit is implicit, then only a positive scalar value is used. 
    wd : array_like, optional 
        If `wd` is a scalar, then that value is used for all data points 
        (and all dimensions of the input variable). If `wd` = 0, then the 
        covariant weighting matrix for each observation is set to the identity 
        matrix (so each dimension of each observation has the same weight). 
        If `wd` is a rank-1 array of length m (the dimensionality of the input 
        variable), then this vector is the diagonal of the covariant weighting 
        matrix for all data points. 
        If `wd` is a rank-1 array of length n (the number of data points), then 
        the i'th element is the weight for the ith input variable observation 
        (single-dimensional only). 
        If `wd` is a rank-2 array of shape (m, m), then this is the full 
        covariant weighting matrix broadcast to each observation. 
        If `wd` is a rank-2 array of shape (m, n), then `wd[:,i]` is the 
        diagonal of the covariant weighting matrix for the ith observation. 
        If `wd` is a rank-3 array of shape (m, m, n), then `wd[:,:,i]` is the 
        full specification of the covariant weighting matrix for each 
        observation. 
    fix : array_like of ints, optional 
        The `fix` argument is the same as ifixx in the class ODR. It is an 
        array of integers with the same shape as data.x that determines which 
        input observations are treated as fixed. One can use a sequence of 
        length m (the dimensionality of the input observations) to fix some 
        dimensions for all observations. A value of 0 fixes the observation, 
        a value &gt; 0 makes it free. 
    meta : dict, optional 
        Free-form dictionary for metadata. 
 
    Notes 
    ----- 
    Each argument is attached to the member of the instance of the same name. 
    The structures of `x` and `y` are described in the Model class docstring. 
    If `y` is an integer, then the Data instance can only be used to fit with 
    implicit models where the dimensionality of the response is equal to the 
    specified value of `y`. 
 
    The `we` argument weights the effect a deviation in the response variable 
    has on the fit. The `wd` argument weights the effect a deviation in the 
    input variable has on the fit. To handle multidimensional inputs and 
    responses easily, the structure of these arguments has the n'th 
    dimensional axis first. These arguments heavily use the structured 
    arguments feature of ODRPACK to conveniently and flexibly support all 
    options. See the ODRPACK User's Guide for a full explanation of how these 
    weights are used in the algorithm. Basically, a higher value of the weight 
    for a particular data point makes a deviation at that point more 
    detrimental to the fit. 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y=</span><span class="s2">None, </span><span class="s1">we=</span><span class="s2">None, </span><span class="s1">wd=</span><span class="s2">None, </span><span class="s1">fix=</span><span class="s2">None, </span><span class="s1">meta=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s1">self.x = _conv(x)</span>

        <span class="s2">if not </span><span class="s1">isinstance(self.x</span><span class="s2">, </span><span class="s1">numpy.ndarray):</span>
            <span class="s2">raise </span><span class="s1">ValueError((</span><span class="s3">&quot;Expected an 'ndarray' of data for 'x', &quot;</span>
                              <span class="s3">&quot;but instead got data of type '{name}'&quot;</span><span class="s1">).format(</span>
                    <span class="s1">name=type(self.x).__name__))</span>

        <span class="s1">self.y = _conv(y)</span>
        <span class="s1">self.we = _conv(we)</span>
        <span class="s1">self.wd = _conv(wd)</span>
        <span class="s1">self.fix = _conv(fix)</span>
        <span class="s1">self.meta = {} </span><span class="s2">if </span><span class="s1">meta </span><span class="s2">is None else </span><span class="s1">meta</span>

    <span class="s2">def </span><span class="s1">set_meta(self</span><span class="s2">, </span><span class="s1">**kwds):</span>
        <span class="s0">&quot;&quot;&quot; Update the metadata dictionary with the keywords and data provided 
        by keywords. 
 
        Examples 
        -------- 
        :: 
 
            data.set_meta(lab=&quot;Ph 7; Lab 26&quot;, title=&quot;Ag110 + Ag108 Decay&quot;) 
        &quot;&quot;&quot;</span>

        <span class="s1">self.meta.update(kwds)</span>

    <span class="s2">def </span><span class="s1">__getattr__(self</span><span class="s2">, </span><span class="s1">attr):</span>
        <span class="s0">&quot;&quot;&quot; Dispatch attribute access to the metadata dictionary. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">self.meta:</span>
            <span class="s2">return </span><span class="s1">self.meta[attr]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">AttributeError(</span><span class="s3">&quot;'%s' not in metadata&quot; </span><span class="s1">% attr)</span>


<span class="s2">class </span><span class="s1">RealData(Data):</span>
    <span class="s0">&quot;&quot;&quot; 
    The data, with weightings as actual standard deviations and/or 
    covariances. 
 
    Parameters 
    ---------- 
    x : array_like 
        Observed data for the independent variable of the regression 
    y : array_like, optional 
        If array-like, observed data for the dependent variable of the 
        regression. A scalar input implies that the model to be used on 
        the data is implicit. 
    sx : array_like, optional 
        Standard deviations of `x`. 
        `sx` are standard deviations of `x` and are converted to weights by 
        dividing 1.0 by their squares. 
    sy : array_like, optional 
        Standard deviations of `y`. 
        `sy` are standard deviations of `y` and are converted to weights by 
        dividing 1.0 by their squares. 
    covx : array_like, optional 
        Covariance of `x` 
        `covx` is an array of covariance matrices of `x` and are converted to 
        weights by performing a matrix inversion on each observation's 
        covariance matrix. 
    covy : array_like, optional 
        Covariance of `y` 
        `covy` is an array of covariance matrices and are converted to 
        weights by performing a matrix inversion on each observation's 
        covariance matrix. 
    fix : array_like, optional 
        The argument and member fix is the same as Data.fix and ODR.ifixx: 
        It is an array of integers with the same shape as `x` that 
        determines which input observations are treated as fixed. One can 
        use a sequence of length m (the dimensionality of the input 
        observations) to fix some dimensions for all observations. A value 
        of 0 fixes the observation, a value &gt; 0 makes it free. 
    meta : dict, optional 
        Free-form dictionary for metadata. 
 
    Notes 
    ----- 
    The weights `wd` and `we` are computed from provided values as follows: 
 
    `sx` and `sy` are converted to weights by dividing 1.0 by their squares. 
    For example, ``wd = 1./numpy.power(`sx`, 2)``. 
 
    `covx` and `covy` are arrays of covariance matrices and are converted to 
    weights by performing a matrix inversion on each observation's covariance 
    matrix. For example, ``we[i] = numpy.linalg.inv(covy[i])``. 
 
    These arguments follow the same structured argument conventions as wd and 
    we only restricted by their natures: `sx` and `sy` can't be rank-3, but 
    `covx` and `covy` can be. 
 
    Only set *either* `sx` or `covx` (not both). Setting both will raise an 
    exception. Same with `sy` and `covy`. 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">x</span><span class="s2">, </span><span class="s1">y=</span><span class="s2">None, </span><span class="s1">sx=</span><span class="s2">None, </span><span class="s1">sy=</span><span class="s2">None, </span><span class="s1">covx=</span><span class="s2">None, </span><span class="s1">covy=</span><span class="s2">None,</span>
                 <span class="s1">fix=</span><span class="s2">None, </span><span class="s1">meta=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s2">if </span><span class="s1">(sx </span><span class="s2">is not None</span><span class="s1">) </span><span class="s2">and </span><span class="s1">(covx </span><span class="s2">is not None</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;cannot set both sx and covx&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">(sy </span><span class="s2">is not None</span><span class="s1">) </span><span class="s2">and </span><span class="s1">(covy </span><span class="s2">is not None</span><span class="s1">):</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;cannot set both sy and covy&quot;</span><span class="s1">)</span>

        <span class="s4"># Set flags for __getattr__</span>
        <span class="s1">self._ga_flags = {}</span>
        <span class="s2">if </span><span class="s1">sx </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._ga_flags[</span><span class="s3">'wd'</span><span class="s1">] = </span><span class="s3">'sx'</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._ga_flags[</span><span class="s3">'wd'</span><span class="s1">] = </span><span class="s3">'covx'</span>
        <span class="s2">if </span><span class="s1">sy </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self._ga_flags[</span><span class="s3">'we'</span><span class="s1">] = </span><span class="s3">'sy'</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self._ga_flags[</span><span class="s3">'we'</span><span class="s1">] = </span><span class="s3">'covy'</span>

        <span class="s1">self.x = _conv(x)</span>

        <span class="s2">if not </span><span class="s1">isinstance(self.x</span><span class="s2">, </span><span class="s1">numpy.ndarray):</span>
            <span class="s2">raise </span><span class="s1">ValueError((</span><span class="s3">&quot;Expected an 'ndarray' of data for 'x', &quot;</span>
                              <span class="s3">&quot;but instead got data of type '{name}'&quot;</span><span class="s1">).format(</span>
                    <span class="s1">name=type(self.x).__name__))</span>

        <span class="s1">self.y = _conv(y)</span>
        <span class="s1">self.sx = _conv(sx)</span>
        <span class="s1">self.sy = _conv(sy)</span>
        <span class="s1">self.covx = _conv(covx)</span>
        <span class="s1">self.covy = _conv(covy)</span>
        <span class="s1">self.fix = _conv(fix)</span>
        <span class="s1">self.meta = {} </span><span class="s2">if </span><span class="s1">meta </span><span class="s2">is None else </span><span class="s1">meta</span>

    <span class="s2">def </span><span class="s1">_sd2wt(self</span><span class="s2">, </span><span class="s1">sd):</span>
        <span class="s0">&quot;&quot;&quot; Convert standard deviation to weights. 
        &quot;&quot;&quot;</span>

        <span class="s2">return </span><span class="s5">1.</span><span class="s1">/numpy.power(sd</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_cov2wt(self</span><span class="s2">, </span><span class="s1">cov):</span>
        <span class="s0">&quot;&quot;&quot; Convert covariance matrix(-ices) to weights. 
        &quot;&quot;&quot;</span>

        <span class="s2">from </span><span class="s1">scipy.linalg </span><span class="s2">import </span><span class="s1">inv</span>

        <span class="s2">if </span><span class="s1">len(cov.shape) == </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">inv(cov)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">weights = numpy.zeros(cov.shape</span><span class="s2">, </span><span class="s1">float)</span>

            <span class="s2">for </span><span class="s1">i </span><span class="s2">in </span><span class="s1">range(cov.shape[-</span><span class="s5">1</span><span class="s1">]):  </span><span class="s4"># n</span>
                <span class="s1">weights[:</span><span class="s2">,</span><span class="s1">:</span><span class="s2">,</span><span class="s1">i] = inv(cov[:</span><span class="s2">,</span><span class="s1">:</span><span class="s2">,</span><span class="s1">i])</span>

            <span class="s2">return </span><span class="s1">weights</span>

    <span class="s2">def </span><span class="s1">__getattr__(self</span><span class="s2">, </span><span class="s1">attr):</span>
        <span class="s1">lookup_tbl = {(</span><span class="s3">'wd'</span><span class="s2">, </span><span class="s3">'sx'</span><span class="s1">): (self._sd2wt</span><span class="s2">, </span><span class="s1">self.sx)</span><span class="s2">,</span>
                      <span class="s1">(</span><span class="s3">'wd'</span><span class="s2">, </span><span class="s3">'covx'</span><span class="s1">): (self._cov2wt</span><span class="s2">, </span><span class="s1">self.covx)</span><span class="s2">,</span>
                      <span class="s1">(</span><span class="s3">'we'</span><span class="s2">, </span><span class="s3">'sy'</span><span class="s1">): (self._sd2wt</span><span class="s2">, </span><span class="s1">self.sy)</span><span class="s2">,</span>
                      <span class="s1">(</span><span class="s3">'we'</span><span class="s2">, </span><span class="s3">'covy'</span><span class="s1">): (self._cov2wt</span><span class="s2">, </span><span class="s1">self.covy)}</span>

        <span class="s2">if </span><span class="s1">attr </span><span class="s2">not in </span><span class="s1">(</span><span class="s3">'wd'</span><span class="s2">, </span><span class="s3">'we'</span><span class="s1">):</span>
            <span class="s2">if </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">self.meta:</span>
                <span class="s2">return </span><span class="s1">self.meta[attr]</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">AttributeError(</span><span class="s3">&quot;'%s' not in metadata&quot; </span><span class="s1">% attr)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">func</span><span class="s2">, </span><span class="s1">arg = lookup_tbl[(attr</span><span class="s2">, </span><span class="s1">self._ga_flags[attr])]</span>

            <span class="s2">if </span><span class="s1">arg </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">func(*(arg</span><span class="s2">,</span><span class="s1">))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return None</span>


<span class="s2">class </span><span class="s1">Model:</span>
    <span class="s0">&quot;&quot;&quot; 
    The Model class stores information about the function you wish to fit. 
 
    It stores the function itself, at the least, and optionally stores 
    functions which compute the Jacobians used during fitting. Also, one 
    can provide a function that will provide reasonable starting values 
    for the fit parameters possibly given the set of data. 
 
    Parameters 
    ---------- 
    fcn : function 
          fcn(beta, x) --&gt; y 
    fjacb : function 
          Jacobian of fcn wrt the fit parameters beta. 
 
          fjacb(beta, x) --&gt; @f_i(x,B)/@B_j 
    fjacd : function 
          Jacobian of fcn wrt the (possibly multidimensional) input 
          variable. 
 
          fjacd(beta, x) --&gt; @f_i(x,B)/@x_j 
    extra_args : tuple, optional 
          If specified, `extra_args` should be a tuple of extra 
          arguments to pass to `fcn`, `fjacb`, and `fjacd`. Each will be called 
          by `apply(fcn, (beta, x) + extra_args)` 
    estimate : array_like of rank-1 
          Provides estimates of the fit parameters from the data 
 
          estimate(data) --&gt; estbeta 
    implicit : boolean 
          If TRUE, specifies that the model 
          is implicit; i.e `fcn(beta, x)` ~= 0 and there is no y data to fit 
          against 
    meta : dict, optional 
          freeform dictionary of metadata for the model 
 
    Notes 
    ----- 
    Note that the `fcn`, `fjacb`, and `fjacd` operate on NumPy arrays and 
    return a NumPy array. The `estimate` object takes an instance of the 
    Data class. 
 
    Here are the rules for the shapes of the argument and return 
    arrays of the callback functions: 
 
    `x` 
        if the input data is single-dimensional, then `x` is rank-1 
        array; i.e., ``x = array([1, 2, 3, ...]); x.shape = (n,)`` 
        If the input data is multi-dimensional, then `x` is a rank-2 array; 
        i.e., ``x = array([[1, 2, ...], [2, 4, ...]]); x.shape = (m, n)``. 
        In all cases, it has the same shape as the input data array passed to 
        `~scipy.odr.odr`. `m` is the dimensionality of the input data, 
        `n` is the number of observations. 
    `y` 
        if the response variable is single-dimensional, then `y` is a 
        rank-1 array, i.e., ``y = array([2, 4, ...]); y.shape = (n,)``. 
        If the response variable is multi-dimensional, then `y` is a rank-2 
        array, i.e., ``y = array([[2, 4, ...], [3, 6, ...]]); y.shape = 
        (q, n)`` where `q` is the dimensionality of the response variable. 
    `beta` 
        rank-1 array of length `p` where `p` is the number of parameters; 
        i.e. ``beta = array([B_1, B_2, ..., B_p])`` 
    `fjacb` 
        if the response variable is multi-dimensional, then the 
        return array's shape is `(q, p, n)` such that ``fjacb(x,beta)[l,k,i] = 
        d f_l(X,B)/d B_k`` evaluated at the ith data point.  If `q == 1`, then 
        the return array is only rank-2 and with shape `(p, n)`. 
    `fjacd` 
        as with fjacb, only the return array's shape is `(q, m, n)` 
        such that ``fjacd(x,beta)[l,j,i] = d f_l(X,B)/d X_j`` at the ith data 
        point.  If `q == 1`, then the return array's shape is `(m, n)`. If 
        `m == 1`, the shape is (q, n). If `m == q == 1`, the shape is `(n,)`. 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">fcn</span><span class="s2">, </span><span class="s1">fjacb=</span><span class="s2">None, </span><span class="s1">fjacd=</span><span class="s2">None,</span>
                 <span class="s1">extra_args=</span><span class="s2">None, </span><span class="s1">estimate=</span><span class="s2">None, </span><span class="s1">implicit=</span><span class="s5">0</span><span class="s2">, </span><span class="s1">meta=</span><span class="s2">None</span><span class="s1">):</span>

        <span class="s1">self.fcn = fcn</span>
        <span class="s1">self.fjacb = fjacb</span>
        <span class="s1">self.fjacd = fjacd</span>

        <span class="s2">if </span><span class="s1">extra_args </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">extra_args = tuple(extra_args)</span>

        <span class="s1">self.extra_args = extra_args</span>
        <span class="s1">self.estimate = estimate</span>
        <span class="s1">self.implicit = implicit</span>
        <span class="s1">self.meta = meta </span><span class="s2">if </span><span class="s1">meta </span><span class="s2">is not None else </span><span class="s1">{}</span>

    <span class="s2">def </span><span class="s1">set_meta(self</span><span class="s2">, </span><span class="s1">**kwds):</span>
        <span class="s0">&quot;&quot;&quot; Update the metadata dictionary with the keywords and data provided 
        here. 
 
        Examples 
        -------- 
        set_meta(name=&quot;Exponential&quot;, equation=&quot;y = a exp(b x) + c&quot;) 
        &quot;&quot;&quot;</span>

        <span class="s1">self.meta.update(kwds)</span>

    <span class="s2">def </span><span class="s1">__getattr__(self</span><span class="s2">, </span><span class="s1">attr):</span>
        <span class="s0">&quot;&quot;&quot; Dispatch attribute access to the metadata. 
        &quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">self.meta:</span>
            <span class="s2">return </span><span class="s1">self.meta[attr]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">AttributeError(</span><span class="s3">&quot;'%s' not in metadata&quot; </span><span class="s1">% attr)</span>


<span class="s2">class </span><span class="s1">Output:</span>
    <span class="s0">&quot;&quot;&quot; 
    The Output class stores the output of an ODR run. 
 
    Attributes 
    ---------- 
    beta : ndarray 
        Estimated parameter values, of shape (q,). 
    sd_beta : ndarray 
        Standard deviations of the estimated parameters, of shape (p,). 
    cov_beta : ndarray 
        Covariance matrix of the estimated parameters, of shape (p,p). 
        Note that this `cov_beta` is not scaled by the residual variance  
        `res_var`, whereas `sd_beta` is. This means  
        ``np.sqrt(np.diag(output.cov_beta * output.res_var))`` is the same  
        result as `output.sd_beta`. 
    delta : ndarray, optional 
        Array of estimated errors in input variables, of same shape as `x`. 
    eps : ndarray, optional 
        Array of estimated errors in response variables, of same shape as `y`. 
    xplus : ndarray, optional 
        Array of ``x + delta``. 
    y : ndarray, optional 
        Array ``y = fcn(x + delta)``. 
    res_var : float, optional 
        Residual variance. 
    sum_square : float, optional 
        Sum of squares error. 
    sum_square_delta : float, optional 
        Sum of squares of delta error. 
    sum_square_eps : float, optional 
        Sum of squares of eps error. 
    inv_condnum : float, optional 
        Inverse condition number (cf. ODRPACK UG p. 77). 
    rel_error : float, optional 
        Relative error in function values computed within fcn. 
    work : ndarray, optional 
        Final work array. 
    work_ind : dict, optional 
        Indices into work for drawing out values (cf. ODRPACK UG p. 83). 
    info : int, optional 
        Reason for returning, as output by ODRPACK (cf. ODRPACK UG p. 38). 
    stopreason : list of str, optional 
        `info` interpreted into English. 
 
    Notes 
    ----- 
    Takes one argument for initialization, the return value from the 
    function `~scipy.odr.odr`. The attributes listed as &quot;optional&quot; above are 
    only present if `~scipy.odr.odr` was run with ``full_output=1``. 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">output):</span>
        <span class="s1">self.beta = output[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s1">self.sd_beta = output[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">self.cov_beta = output[</span><span class="s5">2</span><span class="s1">]</span>

        <span class="s2">if </span><span class="s1">len(output) == </span><span class="s5">4</span><span class="s1">:</span>
            <span class="s4"># full output</span>
            <span class="s1">self.__dict__.update(output[</span><span class="s5">3</span><span class="s1">])</span>
            <span class="s1">self.stopreason = _report_error(self.info)</span>

    <span class="s2">def </span><span class="s1">pprint(self):</span>
        <span class="s0">&quot;&quot;&quot; Pretty-print important results. 
        &quot;&quot;&quot;</span>

        <span class="s1">print(</span><span class="s3">'Beta:'</span><span class="s2">, </span><span class="s1">self.beta)</span>
        <span class="s1">print(</span><span class="s3">'Beta Std Error:'</span><span class="s2">, </span><span class="s1">self.sd_beta)</span>
        <span class="s1">print(</span><span class="s3">'Beta Covariance:'</span><span class="s2">, </span><span class="s1">self.cov_beta)</span>
        <span class="s2">if </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s3">'info'</span><span class="s1">):</span>
            <span class="s1">print(</span><span class="s3">'Residual Variance:'</span><span class="s2">,</span><span class="s1">self.res_var)</span>
            <span class="s1">print(</span><span class="s3">'Inverse Condition #:'</span><span class="s2">, </span><span class="s1">self.inv_condnum)</span>
            <span class="s1">print(</span><span class="s3">'Reason(s) for Halting:'</span><span class="s1">)</span>
            <span class="s2">for </span><span class="s1">r </span><span class="s2">in </span><span class="s1">self.stopreason:</span>
                <span class="s1">print(</span><span class="s3">'  %s' </span><span class="s1">% r)</span>


<span class="s2">class </span><span class="s1">ODR:</span>
    <span class="s0">&quot;&quot;&quot; 
    The ODR class gathers all information and coordinates the running of the 
    main fitting routine. 
 
    Members of instances of the ODR class have the same names as the arguments 
    to the initialization routine. 
 
    Parameters 
    ---------- 
    data : Data class instance 
        instance of the Data class 
    model : Model class instance 
        instance of the Model class 
 
    Other Parameters 
    ---------------- 
    beta0 : array_like of rank-1 
        a rank-1 sequence of initial parameter values. Optional if 
        model provides an &quot;estimate&quot; function to estimate these values. 
    delta0 : array_like of floats of rank-1, optional 
        a (double-precision) float array to hold the initial values of 
        the errors in the input variables. Must be same shape as data.x 
    ifixb : array_like of ints of rank-1, optional 
        sequence of integers with the same length as beta0 that determines 
        which parameters are held fixed. A value of 0 fixes the parameter, 
        a value &gt; 0 makes the parameter free. 
    ifixx : array_like of ints with same shape as data.x, optional 
        an array of integers with the same shape as data.x that determines 
        which input observations are treated as fixed. One can use a sequence 
        of length m (the dimensionality of the input observations) to fix some 
        dimensions for all observations. A value of 0 fixes the observation, 
        a value &gt; 0 makes it free. 
    job : int, optional 
        an integer telling ODRPACK what tasks to perform. See p. 31 of the 
        ODRPACK User's Guide if you absolutely must set the value here. Use the 
        method set_job post-initialization for a more readable interface. 
    iprint : int, optional 
        an integer telling ODRPACK what to print. See pp. 33-34 of the 
        ODRPACK User's Guide if you absolutely must set the value here. Use the 
        method set_iprint post-initialization for a more readable interface. 
    errfile : str, optional 
        string with the filename to print ODRPACK errors to. If the file already 
        exists, an error will be thrown. The `overwrite` argument can be used to 
        prevent this. *Do Not Open This File Yourself!* 
    rptfile : str, optional 
        string with the filename to print ODRPACK summaries to. If the file 
        already exists, an error will be thrown. The `overwrite` argument can be 
        used to prevent this. *Do Not Open This File Yourself!* 
    ndigit : int, optional 
        integer specifying the number of reliable digits in the computation 
        of the function. 
    taufac : float, optional 
        float specifying the initial trust region. The default value is 1. 
        The initial trust region is equal to taufac times the length of the 
        first computed Gauss-Newton step. taufac must be less than 1. 
    sstol : float, optional 
        float specifying the tolerance for convergence based on the relative 
        change in the sum-of-squares. The default value is eps**(1/2) where eps 
        is the smallest value such that 1 + eps &gt; 1 for double precision 
        computation on the machine. sstol must be less than 1. 
    partol : float, optional 
        float specifying the tolerance for convergence based on the relative 
        change in the estimated parameters. The default value is eps**(2/3) for 
        explicit models and ``eps**(1/3)`` for implicit models. partol must be less 
        than 1. 
    maxit : int, optional 
        integer specifying the maximum number of iterations to perform. For 
        first runs, maxit is the total number of iterations performed and 
        defaults to 50. For restarts, maxit is the number of additional 
        iterations to perform and defaults to 10. 
    stpb : array_like, optional 
        sequence (``len(stpb) == len(beta0)``) of relative step sizes to compute 
        finite difference derivatives wrt the parameters. 
    stpd : optional 
        array (``stpd.shape == data.x.shape`` or ``stpd.shape == (m,)``) of relative 
        step sizes to compute finite difference derivatives wrt the input 
        variable errors. If stpd is a rank-1 array with length m (the 
        dimensionality of the input variable), then the values are broadcast to 
        all observations. 
    sclb : array_like, optional 
        sequence (``len(stpb) == len(beta0)``) of scaling factors for the 
        parameters. The purpose of these scaling factors are to scale all of 
        the parameters to around unity. Normally appropriate scaling factors 
        are computed if this argument is not specified. Specify them yourself 
        if the automatic procedure goes awry. 
    scld : array_like, optional 
        array (scld.shape == data.x.shape or scld.shape == (m,)) of scaling 
        factors for the *errors* in the input variables. Again, these factors 
        are automatically computed if you do not provide them. If scld.shape == 
        (m,), then the scaling factors are broadcast to all observations. 
    work : ndarray, optional 
        array to hold the double-valued working data for ODRPACK. When 
        restarting, takes the value of self.output.work. 
    iwork : ndarray, optional 
        array to hold the integer-valued working data for ODRPACK. When 
        restarting, takes the value of self.output.iwork. 
    overwrite : bool, optional 
        If it is True, output files defined by `errfile` and `rptfile` are 
        overwritten. The default is False. 
 
    Attributes 
    ---------- 
    data : Data 
        The data for this fit 
    model : Model 
        The model used in fit 
    output : Output 
        An instance if the Output class containing all of the returned 
        data from an invocation of ODR.run() or ODR.restart() 
 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">data</span><span class="s2">, </span><span class="s1">model</span><span class="s2">, </span><span class="s1">beta0=</span><span class="s2">None, </span><span class="s1">delta0=</span><span class="s2">None, </span><span class="s1">ifixb=</span><span class="s2">None,</span>
        <span class="s1">ifixx=</span><span class="s2">None, </span><span class="s1">job=</span><span class="s2">None, </span><span class="s1">iprint=</span><span class="s2">None, </span><span class="s1">errfile=</span><span class="s2">None, </span><span class="s1">rptfile=</span><span class="s2">None,</span>
        <span class="s1">ndigit=</span><span class="s2">None, </span><span class="s1">taufac=</span><span class="s2">None, </span><span class="s1">sstol=</span><span class="s2">None, </span><span class="s1">partol=</span><span class="s2">None, </span><span class="s1">maxit=</span><span class="s2">None,</span>
        <span class="s1">stpb=</span><span class="s2">None, </span><span class="s1">stpd=</span><span class="s2">None, </span><span class="s1">sclb=</span><span class="s2">None, </span><span class="s1">scld=</span><span class="s2">None, </span><span class="s1">work=</span><span class="s2">None, </span><span class="s1">iwork=</span><span class="s2">None,</span>
        <span class="s1">overwrite=</span><span class="s2">False</span><span class="s1">):</span>

        <span class="s1">self.data = data</span>
        <span class="s1">self.model = model</span>

        <span class="s2">if </span><span class="s1">beta0 </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">if </span><span class="s1">self.model.estimate </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">self.beta0 = _conv(self.model.estimate(self.data))</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                  <span class="s3">&quot;must specify beta0 or provide an estimater with the model&quot;</span>
                <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.beta0 = _conv(beta0)</span>

        <span class="s2">if </span><span class="s1">ifixx </span><span class="s2">is None and </span><span class="s1">data.fix </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">ifixx = data.fix</span>

        <span class="s2">if </span><span class="s1">overwrite:</span>
            <span class="s4"># remove output files for overwriting.</span>
            <span class="s2">if </span><span class="s1">rptfile </span><span class="s2">is not None and </span><span class="s1">os.path.exists(rptfile):</span>
                <span class="s1">os.remove(rptfile)</span>
            <span class="s2">if </span><span class="s1">errfile </span><span class="s2">is not None and </span><span class="s1">os.path.exists(errfile):</span>
                <span class="s1">os.remove(errfile)</span>

        <span class="s1">self.delta0 = _conv(delta0)</span>
        <span class="s4"># These really are 32-bit integers in FORTRAN (gfortran), even on 64-bit</span>
        <span class="s4"># platforms.</span>
        <span class="s4"># XXX: some other FORTRAN compilers may not agree.</span>
        <span class="s1">self.ifixx = _conv(ifixx</span><span class="s2">, </span><span class="s1">dtype=numpy.int32)</span>
        <span class="s1">self.ifixb = _conv(ifixb</span><span class="s2">, </span><span class="s1">dtype=numpy.int32)</span>
        <span class="s1">self.job = job</span>
        <span class="s1">self.iprint = iprint</span>
        <span class="s1">self.errfile = errfile</span>
        <span class="s1">self.rptfile = rptfile</span>
        <span class="s1">self.ndigit = ndigit</span>
        <span class="s1">self.taufac = taufac</span>
        <span class="s1">self.sstol = sstol</span>
        <span class="s1">self.partol = partol</span>
        <span class="s1">self.maxit = maxit</span>
        <span class="s1">self.stpb = _conv(stpb)</span>
        <span class="s1">self.stpd = _conv(stpd)</span>
        <span class="s1">self.sclb = _conv(sclb)</span>
        <span class="s1">self.scld = _conv(scld)</span>
        <span class="s1">self.work = _conv(work)</span>
        <span class="s1">self.iwork = _conv(iwork)</span>

        <span class="s1">self.output = </span><span class="s2">None</span>

        <span class="s1">self._check()</span>

    <span class="s2">def </span><span class="s1">_check(self):</span>
        <span class="s0">&quot;&quot;&quot; Check the inputs for consistency, but don't bother checking things 
        that the builtin function odr will check. 
        &quot;&quot;&quot;</span>

        <span class="s1">x_s = list(self.data.x.shape)</span>

        <span class="s2">if </span><span class="s1">isinstance(self.data.y</span><span class="s2">, </span><span class="s1">numpy.ndarray):</span>
            <span class="s1">y_s = list(self.data.y.shape)</span>
            <span class="s2">if </span><span class="s1">self.model.implicit:</span>
                <span class="s2">raise </span><span class="s1">OdrError(</span><span class="s3">&quot;an implicit model cannot use response data&quot;</span><span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s4"># implicit model with q == self.data.y</span>
            <span class="s1">y_s = [self.data.y</span><span class="s2">, </span><span class="s1">x_s[-</span><span class="s5">1</span><span class="s1">]]</span>
            <span class="s2">if not </span><span class="s1">self.model.implicit:</span>
                <span class="s2">raise </span><span class="s1">OdrError(</span><span class="s3">&quot;an explicit model needs response data&quot;</span><span class="s1">)</span>
            <span class="s1">self.set_job(fit_type=</span><span class="s5">1</span><span class="s1">)</span>

        <span class="s2">if </span><span class="s1">x_s[-</span><span class="s5">1</span><span class="s1">] != y_s[-</span><span class="s5">1</span><span class="s1">]:</span>
            <span class="s2">raise </span><span class="s1">OdrError(</span><span class="s3">&quot;number of observations do not match&quot;</span><span class="s1">)</span>

        <span class="s1">n = x_s[-</span><span class="s5">1</span><span class="s1">]</span>

        <span class="s2">if </span><span class="s1">len(x_s) == </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">m = x_s[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">m = </span><span class="s5">1</span>
        <span class="s2">if </span><span class="s1">len(y_s) == </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">q = y_s[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">q = </span><span class="s5">1</span>

        <span class="s1">p = len(self.beta0)</span>

        <span class="s4"># permissible output array shapes</span>

        <span class="s1">fcn_perms = [(q</span><span class="s2">, </span><span class="s1">n)]</span>
        <span class="s1">fjacd_perms = [(q</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">n)]</span>
        <span class="s1">fjacb_perms = [(q</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">n)]</span>

        <span class="s2">if </span><span class="s1">q == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">fcn_perms.append((n</span><span class="s2">,</span><span class="s1">))</span>
            <span class="s1">fjacd_perms.append((m</span><span class="s2">, </span><span class="s1">n))</span>
            <span class="s1">fjacb_perms.append((p</span><span class="s2">, </span><span class="s1">n))</span>
        <span class="s2">if </span><span class="s1">m == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">fjacd_perms.append((q</span><span class="s2">, </span><span class="s1">n))</span>
        <span class="s2">if </span><span class="s1">p == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">fjacb_perms.append((q</span><span class="s2">, </span><span class="s1">n))</span>
        <span class="s2">if </span><span class="s1">m == q == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">fjacd_perms.append((n</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s2">if </span><span class="s1">p == q == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">fjacb_perms.append((n</span><span class="s2">,</span><span class="s1">))</span>

        <span class="s4"># try evaluating the supplied functions to make sure they provide</span>
        <span class="s4"># sensible outputs</span>

        <span class="s1">arglist = (self.beta0</span><span class="s2">, </span><span class="s1">self.data.x)</span>
        <span class="s2">if </span><span class="s1">self.model.extra_args </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">arglist = arglist + self.model.extra_args</span>
        <span class="s1">res = self.model.fcn(*arglist)</span>

        <span class="s2">if </span><span class="s1">res.shape </span><span class="s2">not in </span><span class="s1">fcn_perms:</span>
            <span class="s1">print(res.shape)</span>
            <span class="s1">print(fcn_perms)</span>
            <span class="s2">raise </span><span class="s1">OdrError(</span><span class="s3">&quot;fcn does not output %s-shaped array&quot; </span><span class="s1">% y_s)</span>

        <span class="s2">if </span><span class="s1">self.model.fjacd </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">res = self.model.fjacd(*arglist)</span>
            <span class="s2">if </span><span class="s1">res.shape </span><span class="s2">not in </span><span class="s1">fjacd_perms:</span>
                <span class="s2">raise </span><span class="s1">OdrError(</span>
                    <span class="s3">&quot;fjacd does not output %s-shaped array&quot; </span><span class="s1">% repr((q</span><span class="s2">, </span><span class="s1">m</span><span class="s2">, </span><span class="s1">n)))</span>
        <span class="s2">if </span><span class="s1">self.model.fjacb </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">res = self.model.fjacb(*arglist)</span>
            <span class="s2">if </span><span class="s1">res.shape </span><span class="s2">not in </span><span class="s1">fjacb_perms:</span>
                <span class="s2">raise </span><span class="s1">OdrError(</span>
                    <span class="s3">&quot;fjacb does not output %s-shaped array&quot; </span><span class="s1">% repr((q</span><span class="s2">, </span><span class="s1">p</span><span class="s2">, </span><span class="s1">n)))</span>

        <span class="s4"># check shape of delta0</span>

        <span class="s2">if </span><span class="s1">self.delta0 </span><span class="s2">is not None and </span><span class="s1">self.delta0.shape != self.data.x.shape:</span>
            <span class="s2">raise </span><span class="s1">OdrError(</span>
                <span class="s3">&quot;delta0 is not a %s-shaped array&quot; </span><span class="s1">% repr(self.data.x.shape))</span>

        <span class="s2">if </span><span class="s1">self.data.x.size == </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">warn((</span><span class="s3">&quot;Empty data detected for ODR instance. &quot;</span>
                  <span class="s3">&quot;Do not expect any fitting to occur&quot;</span><span class="s1">)</span><span class="s2">,</span>
                 <span class="s1">OdrWarning)</span>

    <span class="s2">def </span><span class="s1">_gen_work(self):</span>
        <span class="s0">&quot;&quot;&quot; Generate a suitable work array if one does not already exist. 
        &quot;&quot;&quot;</span>

        <span class="s1">n = self.data.x.shape[-</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">p = self.beta0.shape[</span><span class="s5">0</span><span class="s1">]</span>

        <span class="s2">if </span><span class="s1">len(self.data.x.shape) == </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">m = self.data.x.shape[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">m = </span><span class="s5">1</span>

        <span class="s2">if </span><span class="s1">self.model.implicit:</span>
            <span class="s1">q = self.data.y</span>
        <span class="s2">elif </span><span class="s1">len(self.data.y.shape) == </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">q = self.data.y.shape[</span><span class="s5">0</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">q = </span><span class="s5">1</span>

        <span class="s2">if </span><span class="s1">self.data.we </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">ldwe = ld2we = </span><span class="s5">1</span>
        <span class="s2">elif </span><span class="s1">len(self.data.we.shape) == </span><span class="s5">3</span><span class="s1">:</span>
            <span class="s1">ld2we</span><span class="s2">, </span><span class="s1">ldwe = self.data.we.shape[</span><span class="s5">1</span><span class="s1">:]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">we = self.data.we</span>
            <span class="s1">ldwe = </span><span class="s5">1</span>
            <span class="s1">ld2we = </span><span class="s5">1</span>
            <span class="s2">if </span><span class="s1">we.ndim == </span><span class="s5">1 </span><span class="s2">and </span><span class="s1">q == </span><span class="s5">1</span><span class="s1">:</span>
                <span class="s1">ldwe = n</span>
            <span class="s2">elif </span><span class="s1">we.ndim == </span><span class="s5">2</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">we.shape == (q</span><span class="s2">, </span><span class="s1">q):</span>
                    <span class="s1">ld2we = q</span>
                <span class="s2">elif </span><span class="s1">we.shape == (q</span><span class="s2">, </span><span class="s1">n):</span>
                    <span class="s1">ldwe = n</span>

        <span class="s2">if </span><span class="s1">self.job % </span><span class="s5">10 </span><span class="s1">&lt; </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s4"># ODR not OLS</span>
            <span class="s1">lwork = (</span><span class="s5">18 </span><span class="s1">+ </span><span class="s5">11</span><span class="s1">*p + p*p + m + m*m + </span><span class="s5">4</span><span class="s1">*n*q + </span><span class="s5">6</span><span class="s1">*n*m + </span><span class="s5">2</span><span class="s1">*n*q*p +</span>
                     <span class="s5">2</span><span class="s1">*n*q*m + q*q + </span><span class="s5">5</span><span class="s1">*q + q*(p+m) + ldwe*ld2we*q)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s4"># OLS not ODR</span>
            <span class="s1">lwork = (</span><span class="s5">18 </span><span class="s1">+ </span><span class="s5">11</span><span class="s1">*p + p*p + m + m*m + </span><span class="s5">4</span><span class="s1">*n*q + </span><span class="s5">2</span><span class="s1">*n*m + </span><span class="s5">2</span><span class="s1">*n*q*p +</span>
                     <span class="s5">5</span><span class="s1">*q + q*(p+m) + ldwe*ld2we*q)</span>

        <span class="s2">if </span><span class="s1">isinstance(self.work</span><span class="s2">, </span><span class="s1">numpy.ndarray) </span><span class="s2">and </span><span class="s1">self.work.shape == (lwork</span><span class="s2">,</span><span class="s1">)\</span>
                <span class="s2">and </span><span class="s1">self.work.dtype.str.endswith(</span><span class="s3">'f8'</span><span class="s1">):</span>
            <span class="s4"># the existing array is fine</span>
            <span class="s2">return</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.work = numpy.zeros((lwork</span><span class="s2">,</span><span class="s1">)</span><span class="s2">, </span><span class="s1">float)</span>

    <span class="s2">def </span><span class="s1">set_job(self</span><span class="s2">, </span><span class="s1">fit_type=</span><span class="s2">None, </span><span class="s1">deriv=</span><span class="s2">None, </span><span class="s1">var_calc=</span><span class="s2">None,</span>
        <span class="s1">del_init=</span><span class="s2">None, </span><span class="s1">restart=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; 
        Sets the &quot;job&quot; parameter is a hopefully comprehensible way. 
 
        If an argument is not specified, then the value is left as is. The 
        default value from class initialization is for all of these options set 
        to 0. 
 
        Parameters 
        ---------- 
        fit_type : {0, 1, 2} int 
            0 -&gt; explicit ODR 
 
            1 -&gt; implicit ODR 
 
            2 -&gt; ordinary least-squares 
        deriv : {0, 1, 2, 3} int 
            0 -&gt; forward finite differences 
 
            1 -&gt; central finite differences 
 
            2 -&gt; user-supplied derivatives (Jacobians) with results 
              checked by ODRPACK 
 
            3 -&gt; user-supplied derivatives, no checking 
        var_calc : {0, 1, 2} int 
            0 -&gt; calculate asymptotic covariance matrix and fit 
                 parameter uncertainties (V_B, s_B) using derivatives 
                 recomputed at the final solution 
 
            1 -&gt; calculate V_B and s_B using derivatives from last iteration 
 
            2 -&gt; do not calculate V_B and s_B 
        del_init : {0, 1} int 
            0 -&gt; initial input variable offsets set to 0 
 
            1 -&gt; initial offsets provided by user in variable &quot;work&quot; 
        restart : {0, 1} int 
            0 -&gt; fit is not a restart 
 
            1 -&gt; fit is a restart 
 
        Notes 
        ----- 
        The permissible values are different from those given on pg. 31 of the 
        ODRPACK User's Guide only in that one cannot specify numbers greater than 
        the last value for each variable. 
 
        If one does not supply functions to compute the Jacobians, the fitting 
        procedure will change deriv to 0, finite differences, as a default. To 
        initialize the input variable offsets by yourself, set del_init to 1 and 
        put the offsets into the &quot;work&quot; variable correctly. 
 
        &quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">self.job </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">job_l = [</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">job_l = [self.job // </span><span class="s5">10000 </span><span class="s1">% </span><span class="s5">10</span><span class="s2">,</span>
                     <span class="s1">self.job // </span><span class="s5">1000 </span><span class="s1">% </span><span class="s5">10</span><span class="s2">,</span>
                     <span class="s1">self.job // </span><span class="s5">100 </span><span class="s1">% </span><span class="s5">10</span><span class="s2">,</span>
                     <span class="s1">self.job // </span><span class="s5">10 </span><span class="s1">% </span><span class="s5">10</span><span class="s2">,</span>
                     <span class="s1">self.job % </span><span class="s5">10</span><span class="s1">]</span>

        <span class="s2">if </span><span class="s1">fit_type </span><span class="s2">in </span><span class="s1">(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">):</span>
            <span class="s1">job_l[</span><span class="s5">4</span><span class="s1">] = fit_type</span>
        <span class="s2">if </span><span class="s1">deriv </span><span class="s2">in </span><span class="s1">(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s2">, </span><span class="s5">3</span><span class="s1">):</span>
            <span class="s1">job_l[</span><span class="s5">3</span><span class="s1">] = deriv</span>
        <span class="s2">if </span><span class="s1">var_calc </span><span class="s2">in </span><span class="s1">(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">):</span>
            <span class="s1">job_l[</span><span class="s5">2</span><span class="s1">] = var_calc</span>
        <span class="s2">if </span><span class="s1">del_init </span><span class="s2">in </span><span class="s1">(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">):</span>
            <span class="s1">job_l[</span><span class="s5">1</span><span class="s1">] = del_init</span>
        <span class="s2">if </span><span class="s1">restart </span><span class="s2">in </span><span class="s1">(</span><span class="s5">0</span><span class="s2">, </span><span class="s5">1</span><span class="s1">):</span>
            <span class="s1">job_l[</span><span class="s5">0</span><span class="s1">] = restart</span>

        <span class="s1">self.job = (job_l[</span><span class="s5">0</span><span class="s1">]*</span><span class="s5">10000 </span><span class="s1">+ job_l[</span><span class="s5">1</span><span class="s1">]*</span><span class="s5">1000 </span><span class="s1">+</span>
                    <span class="s1">job_l[</span><span class="s5">2</span><span class="s1">]*</span><span class="s5">100 </span><span class="s1">+ job_l[</span><span class="s5">3</span><span class="s1">]*</span><span class="s5">10 </span><span class="s1">+ job_l[</span><span class="s5">4</span><span class="s1">])</span>

    <span class="s2">def </span><span class="s1">set_iprint(self</span><span class="s2">, </span><span class="s1">init=</span><span class="s2">None, </span><span class="s1">so_init=</span><span class="s2">None,</span>
        <span class="s1">iter=</span><span class="s2">None, </span><span class="s1">so_iter=</span><span class="s2">None, </span><span class="s1">iter_step=</span><span class="s2">None, </span><span class="s1">final=</span><span class="s2">None, </span><span class="s1">so_final=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; Set the iprint parameter for the printing of computation reports. 
 
        If any of the arguments are specified here, then they are set in the 
        iprint member. If iprint is not set manually or with this method, then 
        ODRPACK defaults to no printing. If no filename is specified with the 
        member rptfile, then ODRPACK prints to stdout. One can tell ODRPACK to 
        print to stdout in addition to the specified filename by setting the 
        so_* arguments to this function, but one cannot specify to print to 
        stdout but not a file since one can do that by not specifying a rptfile 
        filename. 
 
        There are three reports: initialization, iteration, and final reports. 
        They are represented by the arguments init, iter, and final 
        respectively.  The permissible values are 0, 1, and 2 representing &quot;no 
        report&quot;, &quot;short report&quot;, and &quot;long report&quot; respectively. 
 
        The argument iter_step (0 &lt;= iter_step &lt;= 9) specifies how often to make 
        the iteration report; the report will be made for every iter_step'th 
        iteration starting with iteration one. If iter_step == 0, then no 
        iteration report is made, regardless of the other arguments. 
 
        If the rptfile is None, then any so_* arguments supplied will raise an 
        exception. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.iprint </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self.iprint = </span><span class="s5">0</span>

        <span class="s1">ip = [self.iprint // </span><span class="s5">1000 </span><span class="s1">% </span><span class="s5">10</span><span class="s2">,</span>
              <span class="s1">self.iprint // </span><span class="s5">100 </span><span class="s1">% </span><span class="s5">10</span><span class="s2">,</span>
              <span class="s1">self.iprint // </span><span class="s5">10 </span><span class="s1">% </span><span class="s5">10</span><span class="s2">,</span>
              <span class="s1">self.iprint % </span><span class="s5">10</span><span class="s1">]</span>

        <span class="s4"># make a list to convert iprint digits to/from argument inputs</span>
        <span class="s4">#                   rptfile, stdout</span>
        <span class="s1">ip2arg = [[</span><span class="s5">0</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">,  </span><span class="s4"># none,  none</span>
                  <span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">,  </span><span class="s4"># short, none</span>
                  <span class="s1">[</span><span class="s5">2</span><span class="s2">, </span><span class="s5">0</span><span class="s1">]</span><span class="s2">,  </span><span class="s4"># long,  none</span>
                  <span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">,  </span><span class="s4"># short, short</span>
                  <span class="s1">[</span><span class="s5">2</span><span class="s2">, </span><span class="s5">1</span><span class="s1">]</span><span class="s2">,  </span><span class="s4"># long,  short</span>
                  <span class="s1">[</span><span class="s5">1</span><span class="s2">, </span><span class="s5">2</span><span class="s1">]</span><span class="s2">,  </span><span class="s4"># short, long</span>
                  <span class="s1">[</span><span class="s5">2</span><span class="s2">, </span><span class="s5">2</span><span class="s1">]]  </span><span class="s4"># long,  long</span>

        <span class="s2">if </span><span class="s1">(self.rptfile </span><span class="s2">is None and</span>
            <span class="s1">(so_init </span><span class="s2">is not None or</span>
             <span class="s1">so_iter </span><span class="s2">is not None or</span>
             <span class="s1">so_final </span><span class="s2">is not None</span><span class="s1">)):</span>
            <span class="s2">raise </span><span class="s1">OdrError(</span>
                <span class="s3">&quot;no rptfile specified, cannot output to stdout twice&quot;</span><span class="s1">)</span>

        <span class="s1">iprint_l = ip2arg[ip[</span><span class="s5">0</span><span class="s1">]] + ip2arg[ip[</span><span class="s5">1</span><span class="s1">]] + ip2arg[ip[</span><span class="s5">3</span><span class="s1">]]</span>

        <span class="s2">if </span><span class="s1">init </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">iprint_l[</span><span class="s5">0</span><span class="s1">] = init</span>
        <span class="s2">if </span><span class="s1">so_init </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">iprint_l[</span><span class="s5">1</span><span class="s1">] = so_init</span>
        <span class="s2">if </span><span class="s1">iter </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">iprint_l[</span><span class="s5">2</span><span class="s1">] = iter</span>
        <span class="s2">if </span><span class="s1">so_iter </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">iprint_l[</span><span class="s5">3</span><span class="s1">] = so_iter</span>
        <span class="s2">if </span><span class="s1">final </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">iprint_l[</span><span class="s5">4</span><span class="s1">] = final</span>
        <span class="s2">if </span><span class="s1">so_final </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">iprint_l[</span><span class="s5">5</span><span class="s1">] = so_final</span>

        <span class="s2">if </span><span class="s1">iter_step </span><span class="s2">in </span><span class="s1">range(</span><span class="s5">10</span><span class="s1">):</span>
            <span class="s4"># 0..9</span>
            <span class="s1">ip[</span><span class="s5">2</span><span class="s1">] = iter_step</span>

        <span class="s1">ip[</span><span class="s5">0</span><span class="s1">] = ip2arg.index(iprint_l[</span><span class="s5">0</span><span class="s1">:</span><span class="s5">2</span><span class="s1">])</span>
        <span class="s1">ip[</span><span class="s5">1</span><span class="s1">] = ip2arg.index(iprint_l[</span><span class="s5">2</span><span class="s1">:</span><span class="s5">4</span><span class="s1">])</span>
        <span class="s1">ip[</span><span class="s5">3</span><span class="s1">] = ip2arg.index(iprint_l[</span><span class="s5">4</span><span class="s1">:</span><span class="s5">6</span><span class="s1">])</span>

        <span class="s1">self.iprint = ip[</span><span class="s5">0</span><span class="s1">]*</span><span class="s5">1000 </span><span class="s1">+ ip[</span><span class="s5">1</span><span class="s1">]*</span><span class="s5">100 </span><span class="s1">+ ip[</span><span class="s5">2</span><span class="s1">]*</span><span class="s5">10 </span><span class="s1">+ ip[</span><span class="s5">3</span><span class="s1">]</span>

    <span class="s2">def </span><span class="s1">run(self):</span>
        <span class="s0">&quot;&quot;&quot; Run the fitting routine with all of the information given and with ``full_output=1``. 
 
        Returns 
        ------- 
        output : Output instance 
            This object is also assigned to the attribute .output . 
        &quot;&quot;&quot;</span>

        <span class="s1">args = (self.model.fcn</span><span class="s2">, </span><span class="s1">self.beta0</span><span class="s2">, </span><span class="s1">self.data.y</span><span class="s2">, </span><span class="s1">self.data.x)</span>
        <span class="s1">kwds = {</span><span class="s3">'full_output'</span><span class="s1">: </span><span class="s5">1</span><span class="s1">}</span>
        <span class="s1">kwd_l = [</span><span class="s3">'ifixx'</span><span class="s2">, </span><span class="s3">'ifixb'</span><span class="s2">, </span><span class="s3">'job'</span><span class="s2">, </span><span class="s3">'iprint'</span><span class="s2">, </span><span class="s3">'errfile'</span><span class="s2">, </span><span class="s3">'rptfile'</span><span class="s2">,</span>
                 <span class="s3">'ndigit'</span><span class="s2">, </span><span class="s3">'taufac'</span><span class="s2">, </span><span class="s3">'sstol'</span><span class="s2">, </span><span class="s3">'partol'</span><span class="s2">, </span><span class="s3">'maxit'</span><span class="s2">, </span><span class="s3">'stpb'</span><span class="s2">,</span>
                 <span class="s3">'stpd'</span><span class="s2">, </span><span class="s3">'sclb'</span><span class="s2">, </span><span class="s3">'scld'</span><span class="s2">, </span><span class="s3">'work'</span><span class="s2">, </span><span class="s3">'iwork'</span><span class="s1">]</span>

        <span class="s2">if </span><span class="s1">self.delta0 </span><span class="s2">is not None and </span><span class="s1">(self.job // </span><span class="s5">10000</span><span class="s1">) % </span><span class="s5">10 </span><span class="s1">== </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s4"># delta0 provided and fit is not a restart</span>
            <span class="s1">self._gen_work()</span>

            <span class="s1">d0 = numpy.ravel(self.delta0)</span>

            <span class="s1">self.work[:len(d0)] = d0</span>

        <span class="s4"># set the kwds from other objects explicitly</span>
        <span class="s2">if </span><span class="s1">self.model.fjacb </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">kwds[</span><span class="s3">'fjacb'</span><span class="s1">] = self.model.fjacb</span>
        <span class="s2">if </span><span class="s1">self.model.fjacd </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">kwds[</span><span class="s3">'fjacd'</span><span class="s1">] = self.model.fjacd</span>
        <span class="s2">if </span><span class="s1">self.data.we </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">kwds[</span><span class="s3">'we'</span><span class="s1">] = self.data.we</span>
        <span class="s2">if </span><span class="s1">self.data.wd </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">kwds[</span><span class="s3">'wd'</span><span class="s1">] = self.data.wd</span>
        <span class="s2">if </span><span class="s1">self.model.extra_args </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">kwds[</span><span class="s3">'extra_args'</span><span class="s1">] = self.model.extra_args</span>

        <span class="s4"># implicitly set kwds from self's members</span>
        <span class="s2">for </span><span class="s1">attr </span><span class="s2">in </span><span class="s1">kwd_l:</span>
            <span class="s1">obj = getattr(self</span><span class="s2">, </span><span class="s1">attr)</span>
            <span class="s2">if </span><span class="s1">obj </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">kwds[attr] = obj</span>

        <span class="s1">self.output = Output(odr(*args</span><span class="s2">, </span><span class="s1">**kwds))</span>

        <span class="s2">return </span><span class="s1">self.output</span>

    <span class="s2">def </span><span class="s1">restart(self</span><span class="s2">, </span><span class="s1">iter=</span><span class="s2">None</span><span class="s1">):</span>
        <span class="s0">&quot;&quot;&quot; Restarts the run with iter more iterations. 
 
        Parameters 
        ---------- 
        iter : int, optional 
            ODRPACK's default for the number of new iterations is 10. 
 
        Returns 
        ------- 
        output : Output instance 
            This object is also assigned to the attribute .output . 
        &quot;&quot;&quot;</span>

        <span class="s2">if </span><span class="s1">self.output </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">OdrError(</span><span class="s3">&quot;cannot restart: run() has not been called before&quot;</span><span class="s1">)</span>

        <span class="s1">self.set_job(restart=</span><span class="s5">1</span><span class="s1">)</span>
        <span class="s1">self.work = self.output.work</span>
        <span class="s1">self.iwork = self.output.iwork</span>

        <span class="s1">self.maxit = iter</span>

        <span class="s2">return </span><span class="s1">self.run()</span>
</pre>
</body>
</html>