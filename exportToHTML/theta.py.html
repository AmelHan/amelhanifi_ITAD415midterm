<html>
<head>
<title>theta.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
theta.py</font>
</center></td></tr></table>
<pre><span class="s0">r&quot;&quot;&quot; 
Implementation of the Theta forecasting method of 
 
Assimakopoulos, V., &amp; Nikolopoulos, K. (2000). The theta model: a decomposition 
approach to forecasting. International journal of forecasting, 16(4), 521-530. 
 
and updates in 
 
Hyndman, R. J., &amp; Billah, B. (2003). Unmasking the Theta method. International 
Journal of Forecasting, 19(2), 287-290. 
 
Fioruci, J. A., Pellegrini, T. R., Louzada, F., &amp; Petropoulos, F. (2015). 
The optimized theta method. arXiv preprint arXiv:1503.03529. 
&quot;&quot;&quot;</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">TYPE_CHECKING</span><span class="s2">, </span><span class="s1">Optional</span><span class="s2">, </span><span class="s1">Tuple</span>

<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">pandas </span><span class="s2">as </span><span class="s1">pd</span>
<span class="s2">from </span><span class="s1">scipy </span><span class="s2">import </span><span class="s1">stats</span>

<span class="s2">from </span><span class="s1">statsmodels.iolib.summary </span><span class="s2">import </span><span class="s1">Summary</span>
<span class="s2">from </span><span class="s1">statsmodels.iolib.table </span><span class="s2">import </span><span class="s1">SimpleTable</span>
<span class="s2">from </span><span class="s1">statsmodels.tools.validation </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">array_like</span><span class="s2">,</span>
    <span class="s1">bool_like</span><span class="s2">,</span>
    <span class="s1">float_like</span><span class="s2">,</span>
    <span class="s1">int_like</span><span class="s2">,</span>
    <span class="s1">string_like</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.deterministic </span><span class="s2">import </span><span class="s1">DeterministicTerm</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.seasonal </span><span class="s2">import </span><span class="s1">seasonal_decompose</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.statespace.exponential_smoothing </span><span class="s2">import </span><span class="s1">(</span>
    <span class="s1">ExponentialSmoothing</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.statespace.sarimax </span><span class="s2">import </span><span class="s1">SARIMAX</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.stattools </span><span class="s2">import </span><span class="s1">acf</span>
<span class="s2">from </span><span class="s1">statsmodels.tsa.tsatools </span><span class="s2">import </span><span class="s1">add_trend</span><span class="s2">, </span><span class="s1">freq_to_period</span>

<span class="s2">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s2">import </span><span class="s1">matplotlib.figure</span>


<span class="s2">def </span><span class="s1">extend_index(steps: int</span><span class="s2">, </span><span class="s1">index: pd.Index) -&gt; pd.Index:</span>
    <span class="s2">return </span><span class="s1">DeterministicTerm._extend_index(index</span><span class="s2">, </span><span class="s1">steps)</span>


<span class="s2">class </span><span class="s1">ThetaModel:</span>
    <span class="s0">r&quot;&quot;&quot; 
    The Theta forecasting model of Assimakopoulos and Nikolopoulos (2000) 
 
    Parameters 
    ---------- 
    endog : array_like, 1d 
        The data to forecast. 
    period : int, default None 
        The period of the data that is used in the seasonality test and 
        adjustment. If None then the period is determined from y's index, 
        if available. 
    deseasonalize : bool, default True 
        A flag indicating whether the deseasonalize the data. If True and 
        use_test is True, the data is only deseasonalized if the null of no 
        seasonal component is rejected. 
    use_test : bool, default True 
        A flag indicating whether test the period-th autocorrelation. If this 
        test rejects using a size of 10%, then decomposition is used. Set to 
        False to skip the test. 
    method : {&quot;auto&quot;, &quot;additive&quot;, &quot;multiplicative&quot;}, default &quot;auto&quot; 
        The model used for the seasonal decomposition. &quot;auto&quot; uses a 
        multiplicative if y is non-negative and all estimated seasonal 
        components are positive. If either of these conditions is False, 
        then it uses an additive decomposition. 
    difference : bool, default False 
        A flag indicating to difference the data before testing for 
        seasonality. 
 
    See Also 
    -------- 
    statsmodels.tsa.statespace.exponential_smoothing.ExponentialSmoothing 
        Exponential smoothing parameter estimation and forecasting 
    statsmodels.tsa.statespace.sarimax.SARIMAX 
        Seasonal ARIMA parameter estimation and forecasting 
 
    Notes 
    ----- 
    The Theta model forecasts the future as a weighted combination of two 
    Theta lines.  This class supports combinations of models with two 
    thetas: 0 and a user-specified choice (default 2). The forecasts are 
    then 
 
    .. math:: 
 
       \hat{X}_{T+h|T} = \frac{\theta-1}{\theta} b_0 
                         \left[h - 1 + \frac{1}{\alpha} 
                         - \frac{(1-\alpha)^T}{\alpha} \right] 
                         + \tilde{X}_{T+h|T} 
 
    where :math:`\tilde{X}_{T+h|T}` is the SES forecast of the endogenous 
    variable using the parameter :math:`\alpha`. :math:`b_0` is the 
    slope of a time trend line fitted to X using the terms 0, 1, ..., T-1. 
 
    The model is estimated in steps: 
 
    1. Test for seasonality 
    2. Deseasonalize if seasonality detected 
    3. Estimate :math:`\alpha` by fitting a SES model to the data and 
       :math:`b_0` by OLS. 
    4. Forecast the series 
    5. Reseasonalize if the data was deseasonalized. 
 
    The seasonality test examines where the autocorrelation at the 
    seasonal period is different from zero. The seasonality is then 
    removed using a seasonal decomposition with a multiplicative trend. 
    If the seasonality estimate is non-positive then an additive trend 
    is used instead. The default deseasonalizing method can be changed 
    using the options. 
 
    References 
    ---------- 
    .. [1] Assimakopoulos, V., &amp; Nikolopoulos, K. (2000). The theta model: a 
       decomposition approach to forecasting. International Journal of 
       Forecasting, 16(4), 521-530. 
    .. [2] Hyndman, R. J., &amp; Billah, B. (2003). Unmasking the Theta method. 
       International Journal of Forecasting, 19(2), 287-290. 
    .. [3] Fioruci, J. A., Pellegrini, T. R., Louzada, F., &amp; Petropoulos, F. 
       (2015). The optimized theta method. arXiv preprint arXiv:1503.03529. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">endog</span><span class="s2">,</span>
        <span class="s1">*</span><span class="s2">,</span>
        <span class="s1">period: Optional[int] = </span><span class="s2">None,</span>
        <span class="s1">deseasonalize: bool = </span><span class="s2">True,</span>
        <span class="s1">use_test: bool = </span><span class="s2">True,</span>
        <span class="s1">method: str = </span><span class="s3">&quot;auto&quot;</span><span class="s2">,</span>
        <span class="s1">difference: bool = </span><span class="s2">False</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self._y = array_like(endog</span><span class="s2">, </span><span class="s3">&quot;endog&quot;</span><span class="s2">, </span><span class="s1">ndim=</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">isinstance(endog</span><span class="s2">, </span><span class="s1">pd.DataFrame):</span>
            <span class="s1">self.endog_orig = endog.iloc[:</span><span class="s2">, </span><span class="s4">0</span><span class="s1">]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">self.endog_orig = endog</span>
        <span class="s1">self._period = int_like(period</span><span class="s2">, </span><span class="s3">&quot;period&quot;</span><span class="s2">, </span><span class="s1">optional=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">self._deseasonalize = bool_like(deseasonalize</span><span class="s2">, </span><span class="s3">&quot;deseasonalize&quot;</span><span class="s1">)</span>
        <span class="s1">self._use_test = (</span>
            <span class="s1">bool_like(use_test</span><span class="s2">, </span><span class="s3">&quot;use_test&quot;</span><span class="s1">) </span><span class="s2">and </span><span class="s1">self._deseasonalize</span>
        <span class="s1">)</span>
        <span class="s1">self._diff = bool_like(difference</span><span class="s2">, </span><span class="s3">&quot;difference&quot;</span><span class="s1">)</span>
        <span class="s1">self._method = string_like(</span>
            <span class="s1">method</span><span class="s2">,</span>
            <span class="s3">&quot;model&quot;</span><span class="s2">,</span>
            <span class="s1">options=(</span><span class="s3">&quot;auto&quot;</span><span class="s2">, </span><span class="s3">&quot;additive&quot;</span><span class="s2">, </span><span class="s3">&quot;multiplicative&quot;</span><span class="s2">, </span><span class="s3">&quot;mul&quot;</span><span class="s2">, </span><span class="s3">&quot;add&quot;</span><span class="s1">)</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">self._method == </span><span class="s3">&quot;auto&quot;</span><span class="s1">:</span>
            <span class="s1">self._method = </span><span class="s3">&quot;mul&quot; </span><span class="s2">if </span><span class="s1">self._y.min() &gt; </span><span class="s4">0 </span><span class="s2">else </span><span class="s3">&quot;add&quot;</span>
        <span class="s2">if </span><span class="s1">self._period </span><span class="s2">is None and </span><span class="s1">self._deseasonalize:</span>
            <span class="s1">idx = getattr(endog</span><span class="s2">, </span><span class="s3">&quot;index&quot;</span><span class="s2">, None</span><span class="s1">)</span>
            <span class="s1">pfreq = </span><span class="s2">None</span>
            <span class="s2">if </span><span class="s1">idx </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">pfreq = getattr(idx</span><span class="s2">, </span><span class="s3">&quot;freq&quot;</span><span class="s2">, None</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s1">pfreq </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s1">pfreq = getattr(idx</span><span class="s2">, </span><span class="s3">&quot;inferred_freq&quot;</span><span class="s2">, None</span><span class="s1">)</span>
            <span class="s2">if </span><span class="s1">pfreq </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">self._period = freq_to_period(pfreq)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span>
                    <span class="s3">&quot;You must specify a period or endog must be a &quot;</span>
                    <span class="s3">&quot;pandas object with a DatetimeIndex with &quot;</span>
                    <span class="s3">&quot;a freq not set to None&quot;</span>
                <span class="s1">)</span>

        <span class="s1">self._has_seasonality = self._deseasonalize</span>

    <span class="s2">def </span><span class="s1">_test_seasonality(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">y = self._y</span>
        <span class="s2">if </span><span class="s1">self._diff:</span>
            <span class="s1">y = np.diff(y)</span>
        <span class="s1">rho = acf(y</span><span class="s2">, </span><span class="s1">nlags=self._period</span><span class="s2">, </span><span class="s1">fft=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">nobs = y.shape[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">stat = nobs * rho[-</span><span class="s4">1</span><span class="s1">] ** </span><span class="s4">2 </span><span class="s1">/ np.sum(rho[:-</span><span class="s4">1</span><span class="s1">] ** </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s5"># CV is 10% from a chi2(1), 1.645**2</span>
        <span class="s1">self._has_seasonality = stat &gt; </span><span class="s4">2.705543454095404</span>

    <span class="s2">def </span><span class="s1">_deseasonalize_data(self) -&gt; Tuple[np.ndarray</span><span class="s2">, </span><span class="s1">np.ndarray]:</span>
        <span class="s1">y = self._y</span>
        <span class="s2">if not </span><span class="s1">self._has_seasonality:</span>
            <span class="s2">return </span><span class="s1">self._y</span><span class="s2">, </span><span class="s1">np.empty(</span><span class="s4">0</span><span class="s1">)</span>

        <span class="s1">res = seasonal_decompose(y</span><span class="s2">, </span><span class="s1">model=self._method</span><span class="s2">, </span><span class="s1">period=self._period)</span>
        <span class="s2">if </span><span class="s1">res.seasonal.min() &lt;= </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">self._method = </span><span class="s3">&quot;add&quot;</span>
            <span class="s1">res = seasonal_decompose(y</span><span class="s2">, </span><span class="s1">model=</span><span class="s3">&quot;add&quot;</span><span class="s2">, </span><span class="s1">period=self._period)</span>
            <span class="s2">return </span><span class="s1">y - res.seasonal</span><span class="s2">, </span><span class="s1">res.seasonal[: self._period]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">y / res.seasonal</span><span class="s2">, </span><span class="s1">res.seasonal[: self._period]</span>

    <span class="s2">def </span><span class="s1">fit(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">use_mle: bool = </span><span class="s2">False, </span><span class="s1">disp: bool = </span><span class="s2">False</span>
    <span class="s1">) -&gt; </span><span class="s3">&quot;ThetaModelResults&quot;</span><span class="s1">:</span>
        <span class="s0">r&quot;&quot;&quot; 
        Estimate model parameters. 
 
        Parameters 
        ---------- 
        use_mle : bool, default False 
            Estimate the parameters using MLE by fitting an ARIMA(0,1,1) with 
            a drift.  If False (the default), estimates parameters using OLS 
            of a constant and a time-trend and by fitting a SES to the model 
            data. 
        disp : bool, default True 
            Display iterative output from fitting the model. 
 
        Notes 
        ----- 
        When using MLE, the parameters are estimated from the ARIMA(0,1,1) 
 
        .. math:: 
 
           X_t = X_{t-1} + b_0 + (\alpha-1)\epsilon_{t-1} + \epsilon_t 
 
        When estimating the model using 2-step estimation, the model 
        parameters are estimated using the OLS regression 
 
        .. math:: 
 
           X_t = a_0 + b_0 (t-1) + \eta_t 
 
        and the SES 
 
        .. math:: 
 
           \tilde{X}_{t+1} = \alpha X_{t} + (1-\alpha)\tilde{X}_{t} 
 
        Returns 
        ------- 
        ThetaModelResult 
            Model results and forecasting 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._deseasonalize </span><span class="s2">and </span><span class="s1">self._use_test:</span>
            <span class="s1">self._test_seasonality()</span>
        <span class="s1">y</span><span class="s2">, </span><span class="s1">seasonal = self._deseasonalize_data()</span>
        <span class="s2">if </span><span class="s1">use_mle:</span>
            <span class="s1">mod = SARIMAX(y</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">&quot;c&quot;</span><span class="s1">)</span>
            <span class="s1">res = mod.fit(disp=disp)</span>
            <span class="s1">params = np.asarray(res.params)</span>
            <span class="s1">alpha = params[</span><span class="s4">1</span><span class="s1">] + </span><span class="s4">1</span>
            <span class="s2">if </span><span class="s1">alpha &gt; </span><span class="s4">1</span><span class="s1">:</span>
                <span class="s1">alpha = </span><span class="s4">0.9998</span>
                <span class="s1">res = mod.fit_constrained({</span><span class="s3">&quot;ma.L1&quot;</span><span class="s1">: alpha - </span><span class="s4">1</span><span class="s1">})</span>
                <span class="s1">params = np.asarray(res.params)</span>
            <span class="s1">b0 = params[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">sigma2 = params[-</span><span class="s4">1</span><span class="s1">]</span>
            <span class="s1">one_step = res.forecast(</span><span class="s4">1</span><span class="s1">) - b0</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">ct = add_trend(y</span><span class="s2">, </span><span class="s3">&quot;ct&quot;</span><span class="s2">, </span><span class="s1">prepend=</span><span class="s2">True</span><span class="s1">)[:</span><span class="s2">, </span><span class="s1">:</span><span class="s4">2</span><span class="s1">]</span>
            <span class="s1">ct[:</span><span class="s2">, </span><span class="s4">1</span><span class="s1">] -= </span><span class="s4">1</span>
            <span class="s1">_</span><span class="s2">, </span><span class="s1">b0 = np.linalg.lstsq(ct</span><span class="s2">, </span><span class="s1">y</span><span class="s2">, </span><span class="s1">rcond=</span><span class="s2">None</span><span class="s1">)[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">res = ExponentialSmoothing(</span>
                <span class="s1">y</span><span class="s2">, </span><span class="s1">initial_level=y[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">, </span><span class="s1">initialization_method=</span><span class="s3">&quot;known&quot;</span>
            <span class="s1">).fit(disp=disp)</span>
            <span class="s1">alpha = res.params[</span><span class="s4">0</span><span class="s1">]</span>
            <span class="s1">sigma2 = </span><span class="s2">None</span>
            <span class="s1">one_step = res.forecast(</span><span class="s4">1</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">ThetaModelResults(</span>
            <span class="s1">b0</span><span class="s2">, </span><span class="s1">alpha</span><span class="s2">, </span><span class="s1">sigma2</span><span class="s2">, </span><span class="s1">one_step</span><span class="s2">, </span><span class="s1">seasonal</span><span class="s2">, </span><span class="s1">use_mle</span><span class="s2">, </span><span class="s1">self</span>
        <span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">deseasonalize(self) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot;Whether to deseasonalize the data&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._deseasonalize</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">period(self) -&gt; int:</span>
        <span class="s0">&quot;&quot;&quot;The period of the seasonality&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._period</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">use_test(self) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot;Whether to test the data for seasonality&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._use_test</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">difference(self) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot;Whether the data is differenced in the seasonality test&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._diff</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">method(self) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot;The method used to deseasonalize the data&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._method</span>


<span class="s2">class </span><span class="s1">ThetaModelResults:</span>
    <span class="s0">&quot;&quot;&quot; 
    Results class from estimated Theta Models. 
 
    Parameters 
    ---------- 
    b0 : float 
        The estimated trend slope. 
    alpha : float 
        The estimated SES parameter. 
    sigma2 : float 
        The estimated residual variance from the SES/IMA model. 
    one_step : float 
        The one-step forecast from the SES. 
    seasonal : ndarray 
        An array of estimated seasonal terms. 
    use_mle : bool 
        A flag indicating that the parameters were estimated using MLE. 
    model : ThetaModel 
        The model used to produce the results. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">b0: float</span><span class="s2">,</span>
        <span class="s1">alpha: float</span><span class="s2">,</span>
        <span class="s1">sigma2: Optional[float]</span><span class="s2">,</span>
        <span class="s1">one_step: float</span><span class="s2">,</span>
        <span class="s1">seasonal: np.ndarray</span><span class="s2">,</span>
        <span class="s1">use_mle: bool</span><span class="s2">,</span>
        <span class="s1">model: ThetaModel</span><span class="s2">,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self._b0 = b0</span>
        <span class="s1">self._alpha = alpha</span>
        <span class="s1">self._sigma2 = sigma2</span>
        <span class="s1">self._one_step = one_step</span>
        <span class="s1">self._nobs = model.endog_orig.shape[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">self._model = model</span>
        <span class="s1">self._seasonal = seasonal</span>
        <span class="s1">self._use_mle = use_mle</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">params(self) -&gt; pd.Series:</span>
        <span class="s0">&quot;&quot;&quot;The forecasting model parameters&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">pd.Series([self._b0</span><span class="s2">, </span><span class="s1">self._alpha]</span><span class="s2">, </span><span class="s1">index=[</span><span class="s3">&quot;b0&quot;</span><span class="s2">, </span><span class="s3">&quot;alpha&quot;</span><span class="s1">])</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">sigma2(self) -&gt; float:</span>
        <span class="s0">&quot;&quot;&quot;The estimated residual variance&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self._sigma2 </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">mod = SARIMAX(self.model._y</span><span class="s2">, </span><span class="s1">order=(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">1</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">, </span><span class="s1">trend=</span><span class="s3">&quot;c&quot;</span><span class="s1">)</span>
            <span class="s1">res = mod.fit(disp=</span><span class="s2">False</span><span class="s1">)</span>
            <span class="s1">self._sigma2 = np.asarray(res.params)[-</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s2">assert </span><span class="s1">self._sigma2 </span><span class="s2">is not None</span>
        <span class="s2">return </span><span class="s1">self._sigma2</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">model(self) -&gt; ThetaModel:</span>
        <span class="s0">&quot;&quot;&quot;The model used to produce the results&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self._model</span>

    <span class="s2">def </span><span class="s1">forecast(self</span><span class="s2">, </span><span class="s1">steps: int = </span><span class="s4">1</span><span class="s2">, </span><span class="s1">theta: float = </span><span class="s4">2</span><span class="s1">) -&gt; pd.Series:</span>
        <span class="s0">r&quot;&quot;&quot; 
        Forecast the model for a given theta 
 
        Parameters 
        ---------- 
        steps : int 
            The number of steps ahead to compute the forecast components. 
        theta : float 
            The theta value to use when computing the weight to combine 
            the trend and the SES forecasts. 
 
        Returns 
        ------- 
        Series 
            A Series containing the forecasts 
 
        Notes 
        ----- 
        The forecast is computed as 
 
        .. math:: 
 
           \hat{X}_{T+h|T} = \frac{\theta-1}{\theta} b_0 
                             \left[h - 1 + \frac{1}{\alpha} 
                             - \frac{(1-\alpha)^T}{\alpha} \right] 
                             + \tilde{X}_{T+h|T} 
 
        where :math:`\tilde{X}_{T+h|T}` is the SES forecast of the endogenous 
        variable using the parameter :math:`\alpha`. :math:`b_0` is the 
        slope of a time trend line fitted to X using the terms 0, 1, ..., T-1. 
 
        This expression follows from [1]_ and [2]_ when the combination 
        weights are restricted to be (theta-1)/theta and 1/theta. This nests 
        the original implementation when theta=2 and the two weights are both 
        1/2. 
 
        References 
        ---------- 
        .. [1] Hyndman, R. J., &amp; Billah, B. (2003). Unmasking the Theta method. 
           International Journal of Forecasting, 19(2), 287-290. 
        .. [2] Fioruci, J. A., Pellegrini, T. R., Louzada, F., &amp; Petropoulos, 
           F. (2015). The optimized theta method. arXiv preprint 
           arXiv:1503.03529. 
        &quot;&quot;&quot;</span>

        <span class="s1">steps = int_like(steps</span><span class="s2">, </span><span class="s3">&quot;steps&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">steps &lt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;steps must be a positive integer&quot;</span><span class="s1">)</span>
        <span class="s1">theta = float_like(theta</span><span class="s2">, </span><span class="s3">&quot;theta&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">theta &lt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;theta must be a float &gt;= 1&quot;</span><span class="s1">)</span>
        <span class="s1">thresh = </span><span class="s4">4.0 </span><span class="s1">/ np.finfo(np.double).eps</span>
        <span class="s1">trend_weight = (theta - </span><span class="s4">1</span><span class="s1">) / theta </span><span class="s2">if </span><span class="s1">theta &lt; thresh </span><span class="s2">else </span><span class="s4">1.0</span>
        <span class="s1">comp = self.forecast_components(steps=steps)</span>
        <span class="s1">fcast = trend_weight * comp.trend + np.asarray(comp.ses)</span>
        <span class="s5"># Re-seasonalize if needed</span>
        <span class="s2">if </span><span class="s1">self.model.deseasonalize:</span>
            <span class="s1">seasonal = np.asarray(comp.seasonal)</span>
            <span class="s2">if </span><span class="s1">self.model.method.startswith(</span><span class="s3">&quot;mul&quot;</span><span class="s1">):</span>
                <span class="s1">fcast *= seasonal</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">fcast += seasonal</span>
        <span class="s1">fcast.name = </span><span class="s3">&quot;forecast&quot;</span>

        <span class="s2">return </span><span class="s1">fcast</span>

    <span class="s2">def </span><span class="s1">forecast_components(self</span><span class="s2">, </span><span class="s1">steps: int = </span><span class="s4">1</span><span class="s1">) -&gt; pd.DataFrame:</span>
        <span class="s0">r&quot;&quot;&quot; 
        Compute the three components of the Theta model forecast 
 
        Parameters 
        ---------- 
        steps : int 
            The number of steps ahead to compute the forecast components. 
 
        Returns 
        ------- 
        DataFrame 
            A DataFrame with three columns: trend, ses and seasonal containing 
            the forecast values of each of the three components. 
 
        Notes 
        ----- 
        For a given value of :math:`\theta`, the deseasonalized forecast is 
        `fcast = w * trend + ses` where :math:`w = \frac{theta - 1}{theta}`. 
        The reseasonalized forecasts are then `seasonal * fcast` if the 
        seasonality is multiplicative or `seasonal + fcast` if the seasonality 
        is additive. 
        &quot;&quot;&quot;</span>
        <span class="s1">steps = int_like(steps</span><span class="s2">, </span><span class="s3">&quot;steps&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">steps &lt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;steps must be a positive integer&quot;</span><span class="s1">)</span>
        <span class="s1">alpha = self._alpha</span>
        <span class="s1">b0 = self._b0</span>
        <span class="s1">nobs = self._nobs</span>
        <span class="s1">h = np.arange(</span><span class="s4">1</span><span class="s2">, </span><span class="s1">steps + </span><span class="s4">1</span><span class="s2">, </span><span class="s1">dtype=np.float64) - </span><span class="s4">1</span>
        <span class="s2">if </span><span class="s1">alpha &gt; </span><span class="s4">0</span><span class="s1">:</span>
            <span class="s1">h += </span><span class="s4">1 </span><span class="s1">/ alpha - ((</span><span class="s4">1 </span><span class="s1">- alpha) ** nobs / alpha)</span>
        <span class="s1">trend = b0 * h</span>
        <span class="s1">ses = self._one_step * np.ones(steps)</span>
        <span class="s2">if </span><span class="s1">self.model.method.startswith(</span><span class="s3">&quot;add&quot;</span><span class="s1">):</span>
            <span class="s1">season = np.zeros(steps)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">season = np.ones(steps)</span>
        <span class="s5"># Re-seasonalize</span>
        <span class="s2">if </span><span class="s1">self.model.deseasonalize:</span>
            <span class="s1">seasonal = self._seasonal</span>
            <span class="s1">period = self.model.period</span>
            <span class="s1">oos_idx = nobs + np.arange(steps)</span>
            <span class="s1">seasonal_locs = oos_idx % period</span>
            <span class="s2">if </span><span class="s1">seasonal.shape[</span><span class="s4">0</span><span class="s1">]:</span>
                <span class="s1">season[:] = seasonal[seasonal_locs]</span>
        <span class="s1">index = getattr(self.model.endog_orig</span><span class="s2">, </span><span class="s3">&quot;index&quot;</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">index </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">index = pd.RangeIndex(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">self.model.endog_orig.shape[</span><span class="s4">0</span><span class="s1">])</span>
        <span class="s1">index = extend_index(steps</span><span class="s2">, </span><span class="s1">index)</span>

        <span class="s1">df = pd.DataFrame(</span>
            <span class="s1">{</span><span class="s3">&quot;trend&quot;</span><span class="s1">: trend</span><span class="s2">, </span><span class="s3">&quot;ses&quot;</span><span class="s1">: ses</span><span class="s2">, </span><span class="s3">&quot;seasonal&quot;</span><span class="s1">: season}</span><span class="s2">, </span><span class="s1">index=index</span>
        <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">df</span>

    <span class="s2">def </span><span class="s1">summary(self) -&gt; Summary:</span>
        <span class="s0">&quot;&quot;&quot; 
        Summarize the model 
 
        Returns 
        ------- 
        Summary 
            This holds the summary table and text, which can be printed or 
            converted to various output formats. 
 
        See Also 
        -------- 
        statsmodels.iolib.summary.Summary 
        &quot;&quot;&quot;</span>
        <span class="s1">model = self.model</span>
        <span class="s1">smry = Summary()</span>

        <span class="s1">model_name = type(model).__name__</span>
        <span class="s1">title = model_name + </span><span class="s3">&quot; Results&quot;</span>
        <span class="s1">method = </span><span class="s3">&quot;MLE&quot; </span><span class="s2">if </span><span class="s1">self._use_mle </span><span class="s2">else </span><span class="s3">&quot;OLS/SES&quot;</span>

        <span class="s1">is_series = isinstance(model.endog_orig</span><span class="s2">, </span><span class="s1">pd.Series)</span>
        <span class="s1">index = getattr(model.endog_orig</span><span class="s2">, </span><span class="s3">&quot;index&quot;</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">is_series </span><span class="s2">and </span><span class="s1">isinstance(index</span><span class="s2">, </span><span class="s1">(pd.DatetimeIndex</span><span class="s2">, </span><span class="s1">pd.PeriodIndex)):</span>
            <span class="s1">sample = [index[</span><span class="s4">0</span><span class="s1">].strftime(</span><span class="s3">&quot;%m-%d-%Y&quot;</span><span class="s1">)]</span>
            <span class="s1">sample += [</span><span class="s3">&quot;- &quot; </span><span class="s1">+ index[-</span><span class="s4">1</span><span class="s1">].strftime(</span><span class="s3">&quot;%m-%d-%Y&quot;</span><span class="s1">)]</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">sample = [str(</span><span class="s4">0</span><span class="s1">)</span><span class="s2">, </span><span class="s1">str(model.endog_orig.shape[</span><span class="s4">0</span><span class="s1">])]</span>

        <span class="s1">dep_name = getattr(model.endog_orig</span><span class="s2">, </span><span class="s3">&quot;name&quot;</span><span class="s2">, </span><span class="s3">&quot;endog&quot;</span><span class="s1">) </span><span class="s2">or </span><span class="s3">&quot;endog&quot;</span>
        <span class="s1">top_left = [</span>
            <span class="s1">(</span><span class="s3">&quot;Dep. Variable:&quot;</span><span class="s2">, </span><span class="s1">[dep_name])</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;Method:&quot;</span><span class="s2">, </span><span class="s1">[method])</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;Date:&quot;</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;Time:&quot;</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;Sample:&quot;</span><span class="s2">, </span><span class="s1">[sample[</span><span class="s4">0</span><span class="s1">]])</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;&quot;</span><span class="s2">, </span><span class="s1">[sample[</span><span class="s4">1</span><span class="s1">]])</span><span class="s2">,</span>
        <span class="s1">]</span>
        <span class="s1">method = (</span>
            <span class="s3">&quot;Multiplicative&quot; </span><span class="s2">if </span><span class="s1">model.method.startswith(</span><span class="s3">&quot;mul&quot;</span><span class="s1">) </span><span class="s2">else </span><span class="s3">&quot;Additive&quot;</span>
        <span class="s1">)</span>
        <span class="s1">top_right = [</span>
            <span class="s1">(</span><span class="s3">&quot;No. Observations:&quot;</span><span class="s2">, </span><span class="s1">[str(self._nobs)])</span><span class="s2">,</span>
            <span class="s1">(</span><span class="s3">&quot;Deseasonalized:&quot;</span><span class="s2">, </span><span class="s1">[str(model.deseasonalize)])</span><span class="s2">,</span>
        <span class="s1">]</span>

        <span class="s2">if </span><span class="s1">model.deseasonalize:</span>
            <span class="s1">top_right.extend(</span>
                <span class="s1">[</span>
                    <span class="s1">(</span><span class="s3">&quot;Deseas. Method:&quot;</span><span class="s2">, </span><span class="s1">[method])</span><span class="s2">,</span>
                    <span class="s1">(</span><span class="s3">&quot;Period:&quot;</span><span class="s2">, </span><span class="s1">[str(model.period)])</span><span class="s2">,</span>
                    <span class="s1">(</span><span class="s3">&quot;&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;&quot;</span><span class="s1">])</span><span class="s2">,</span>
                    <span class="s1">(</span><span class="s3">&quot;&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;&quot;</span><span class="s1">])</span><span class="s2">,</span>
                <span class="s1">]</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">top_right.extend([(</span><span class="s3">&quot;&quot;</span><span class="s2">, </span><span class="s1">[</span><span class="s3">&quot;&quot;</span><span class="s1">])] * </span><span class="s4">4</span><span class="s1">)</span>

        <span class="s1">smry.add_table_2cols(</span>
            <span class="s1">self</span><span class="s2">, </span><span class="s1">gleft=top_left</span><span class="s2">, </span><span class="s1">gright=top_right</span><span class="s2">, </span><span class="s1">title=title</span>
        <span class="s1">)</span>
        <span class="s1">table_fmt = {</span><span class="s3">&quot;data_fmts&quot;</span><span class="s1">: [</span><span class="s3">&quot;%s&quot;</span><span class="s2">, </span><span class="s3">&quot;%#0.4g&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;data_aligns&quot;</span><span class="s1">: </span><span class="s3">&quot;r&quot;</span><span class="s1">}</span>

        <span class="s1">data = np.asarray(self.params)[:</span><span class="s2">, None</span><span class="s1">]</span>
        <span class="s1">st = SimpleTable(</span>
            <span class="s1">data</span><span class="s2">,</span>
            <span class="s1">[</span><span class="s3">&quot;Parameters&quot;</span><span class="s2">, </span><span class="s3">&quot;Estimate&quot;</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">list(self.params.index)</span><span class="s2">,</span>
            <span class="s1">title=</span><span class="s3">&quot;Parameter Estimates&quot;</span><span class="s2">,</span>
            <span class="s1">txt_fmt=table_fmt</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">smry.tables.append(st)</span>

        <span class="s2">return </span><span class="s1">smry</span>

    <span class="s2">def </span><span class="s1">prediction_intervals(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">steps: int = </span><span class="s4">1</span><span class="s2">, </span><span class="s1">theta: float = </span><span class="s4">2</span><span class="s2">, </span><span class="s1">alpha: float = </span><span class="s4">0.05</span>
    <span class="s1">) -&gt; pd.DataFrame:</span>
        <span class="s0">r&quot;&quot;&quot; 
        Parameters 
        ---------- 
        steps : int, default 1 
            The number of steps ahead to compute the forecast components. 
        theta : float, default 2 
            The theta value to use when computing the weight to combine 
            the trend and the SES forecasts. 
        alpha : float, default 0.05 
            Significance level for the confidence intervals. 
 
        Returns 
        ------- 
        DataFrame 
            DataFrame with columns lower and upper 
 
        Notes 
        ----- 
        The variance of the h-step forecast is assumed to follow from the 
        integrated Moving Average structure of the Theta model, and so is 
        :math:`\sigma^2(1 + (h-1)(1 + (\alpha-1)^2)`. The prediction interval 
        assumes that innovations are normally distributed. 
        &quot;&quot;&quot;</span>
        <span class="s1">model_alpha = self.params[</span><span class="s4">1</span><span class="s1">]</span>
        <span class="s1">sigma2_h = (</span>
            <span class="s4">1 </span><span class="s1">+ np.arange(steps) * (</span><span class="s4">1 </span><span class="s1">+ (model_alpha - </span><span class="s4">1</span><span class="s1">) ** </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">) * self.sigma2</span>
        <span class="s1">sigma_h = np.sqrt(sigma2_h)</span>
        <span class="s1">quantile = stats.norm.ppf(alpha / </span><span class="s4">2</span><span class="s1">)</span>
        <span class="s1">predictions = self.forecast(steps</span><span class="s2">, </span><span class="s1">theta)</span>
        <span class="s2">return </span><span class="s1">pd.DataFrame(</span>
            <span class="s1">{</span>
                <span class="s3">&quot;lower&quot;</span><span class="s1">: predictions + sigma_h * quantile</span><span class="s2">,</span>
                <span class="s3">&quot;upper&quot;</span><span class="s1">: predictions + sigma_h * -quantile</span><span class="s2">,</span>
            <span class="s1">}</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">plot_predict(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">steps: int = </span><span class="s4">1</span><span class="s2">,</span>
        <span class="s1">theta: float = </span><span class="s4">2</span><span class="s2">,</span>
        <span class="s1">alpha: Optional[float] = </span><span class="s4">0.05</span><span class="s2">,</span>
        <span class="s1">in_sample: bool = </span><span class="s2">False,</span>
        <span class="s1">fig: Optional[</span><span class="s3">&quot;matplotlib.figure.Figure&quot;</span><span class="s1">] = </span><span class="s2">None,</span>
        <span class="s1">figsize: Tuple[float</span><span class="s2">, </span><span class="s1">float] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; </span><span class="s3">&quot;matplotlib.figure.Figure&quot;</span><span class="s1">:</span>
        <span class="s0">r&quot;&quot;&quot; 
        Plot forecasts, prediction intervals and in-sample values 
 
        Parameters 
        ---------- 
        steps : int, default 1 
            The number of steps ahead to compute the forecast components. 
        theta : float, default 2 
            The theta value to use when computing the weight to combine 
            the trend and the SES forecasts. 
        alpha : {float, None}, default 0.05 
            The tail probability not covered by the confidence interval. Must 
            be in (0, 1). Confidence interval is constructed assuming normally 
            distributed shocks. If None, figure will not show the confidence 
            interval. 
        in_sample : bool, default False 
            Flag indicating whether to include the in-sample period in the 
            plot. 
        fig : Figure, default None 
            An existing figure handle. If not provided, a new figure is 
            created. 
        figsize: tuple[float, float], default None 
            Tuple containing the figure size. 
 
        Returns 
        ------- 
        Figure 
            Figure handle containing the plot. 
 
        Notes 
        ----- 
        The variance of the h-step forecast is assumed to follow from the 
        integrated Moving Average structure of the Theta model, and so is 
        :math:`\sigma^2(\alpha^2 + (h-1))`. The prediction interval assumes 
        that innovations are normally distributed. 
        &quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s1">statsmodels.graphics.utils </span><span class="s2">import </span><span class="s1">_import_mpl</span><span class="s2">, </span><span class="s1">create_mpl_fig</span>

        <span class="s1">_import_mpl()</span>
        <span class="s1">fig = create_mpl_fig(fig</span><span class="s2">, </span><span class="s1">figsize)</span>
        <span class="s2">assert </span><span class="s1">fig </span><span class="s2">is not None</span>
        <span class="s1">predictions = self.forecast(steps</span><span class="s2">, </span><span class="s1">theta)</span>
        <span class="s1">pred_index = predictions.index</span>

        <span class="s1">ax = fig.add_subplot(</span><span class="s4">111</span><span class="s1">)</span>
        <span class="s1">nobs = self.model.endog_orig.shape[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">index = pd.Index(np.arange(nobs))</span>
        <span class="s2">if </span><span class="s1">in_sample:</span>
            <span class="s2">if </span><span class="s1">isinstance(self.model.endog_orig</span><span class="s2">, </span><span class="s1">pd.Series):</span>
                <span class="s1">index = self.model.endog_orig.index</span>
            <span class="s1">ax.plot(index</span><span class="s2">, </span><span class="s1">self.model.endog_orig)</span>
        <span class="s1">ax.plot(pred_index</span><span class="s2">, </span><span class="s1">predictions)</span>
        <span class="s2">if </span><span class="s1">alpha </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">pi = self.prediction_intervals(steps</span><span class="s2">, </span><span class="s1">theta</span><span class="s2">, </span><span class="s1">alpha)</span>
            <span class="s1">label = </span><span class="s3">&quot;{0:.0%} confidence interval&quot;</span><span class="s1">.format(</span><span class="s4">1 </span><span class="s1">- alpha)</span>
            <span class="s1">ax.fill_between(</span>
                <span class="s1">pred_index</span><span class="s2">,</span>
                <span class="s1">pi[</span><span class="s3">&quot;lower&quot;</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">pi[</span><span class="s3">&quot;upper&quot;</span><span class="s1">]</span><span class="s2">,</span>
                <span class="s1">color=</span><span class="s3">&quot;gray&quot;</span><span class="s2">,</span>
                <span class="s1">alpha=</span><span class="s4">0.5</span><span class="s2">,</span>
                <span class="s1">label=label</span><span class="s2">,</span>
            <span class="s1">)</span>

        <span class="s1">ax.legend(loc=</span><span class="s3">&quot;best&quot;</span><span class="s2">, </span><span class="s1">frameon=</span><span class="s2">False</span><span class="s1">)</span>
        <span class="s1">fig.tight_layout(pad=</span><span class="s4">1.0</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">fig</span>
</pre>
</body>
</html>