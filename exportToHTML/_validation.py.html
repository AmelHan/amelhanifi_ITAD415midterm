<html>
<head>
<title>_validation.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #cc7832;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
_validation.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot; 
The :mod:`sklearn.model_selection._validation` module includes classes and 
functions to validate the model. 
&quot;&quot;&quot;</span>

<span class="s2"># Author: Alexandre Gramfort &lt;alexandre.gramfort@inria.fr&gt;</span>
<span class="s2">#         Gael Varoquaux &lt;gael.varoquaux@normalesup.org&gt;</span>
<span class="s2">#         Olivier Grisel &lt;olivier.grisel@ensta.org&gt;</span>
<span class="s2">#         Raghav RV &lt;rvraghav93@gmail.com&gt;</span>
<span class="s2">#         Michal Karbownik &lt;michakarbownik@gmail.com&gt;</span>
<span class="s2"># License: BSD 3 clause</span>


<span class="s3">import </span><span class="s1">numbers</span>
<span class="s3">import </span><span class="s1">time</span>
<span class="s3">import </span><span class="s1">warnings</span>
<span class="s3">from </span><span class="s1">collections </span><span class="s3">import </span><span class="s1">Counter</span>
<span class="s3">from </span><span class="s1">contextlib </span><span class="s3">import </span><span class="s1">suppress</span>
<span class="s3">from </span><span class="s1">functools </span><span class="s3">import </span><span class="s1">partial</span>
<span class="s3">from </span><span class="s1">numbers </span><span class="s3">import </span><span class="s1">Real</span>
<span class="s3">from </span><span class="s1">traceback </span><span class="s3">import </span><span class="s1">format_exc</span>

<span class="s3">import </span><span class="s1">numpy </span><span class="s3">as </span><span class="s1">np</span>
<span class="s3">import </span><span class="s1">scipy.sparse </span><span class="s3">as </span><span class="s1">sp</span>
<span class="s3">from </span><span class="s1">joblib </span><span class="s3">import </span><span class="s1">logger</span>

<span class="s3">from </span><span class="s1">..base </span><span class="s3">import </span><span class="s1">clone</span><span class="s3">, </span><span class="s1">is_classifier</span>
<span class="s3">from </span><span class="s1">..exceptions </span><span class="s3">import </span><span class="s1">FitFailedWarning</span>
<span class="s3">from </span><span class="s1">..metrics </span><span class="s3">import </span><span class="s1">check_scoring</span><span class="s3">, </span><span class="s1">get_scorer_names</span>
<span class="s3">from </span><span class="s1">..metrics._scorer </span><span class="s3">import </span><span class="s1">_check_multimetric_scoring</span><span class="s3">, </span><span class="s1">_MultimetricScorer</span>
<span class="s3">from </span><span class="s1">..preprocessing </span><span class="s3">import </span><span class="s1">LabelEncoder</span>
<span class="s3">from </span><span class="s1">..utils </span><span class="s3">import </span><span class="s1">_safe_indexing</span><span class="s3">, </span><span class="s1">check_random_state</span><span class="s3">, </span><span class="s1">indexable</span>
<span class="s3">from </span><span class="s1">..utils._param_validation </span><span class="s3">import </span><span class="s1">(</span>
    <span class="s1">HasMethods</span><span class="s3">,</span>
    <span class="s1">Integral</span><span class="s3">,</span>
    <span class="s1">Interval</span><span class="s3">,</span>
    <span class="s1">StrOptions</span><span class="s3">,</span>
    <span class="s1">validate_params</span><span class="s3">,</span>
<span class="s1">)</span>
<span class="s3">from </span><span class="s1">..utils.metaestimators </span><span class="s3">import </span><span class="s1">_safe_split</span>
<span class="s3">from </span><span class="s1">..utils.parallel </span><span class="s3">import </span><span class="s1">Parallel</span><span class="s3">, </span><span class="s1">delayed</span>
<span class="s3">from </span><span class="s1">..utils.validation </span><span class="s3">import </span><span class="s1">_check_fit_params</span><span class="s3">, </span><span class="s1">_num_samples</span>
<span class="s3">from </span><span class="s1">._split </span><span class="s3">import </span><span class="s1">check_cv</span>

<span class="s1">__all__ = [</span>
    <span class="s4">&quot;cross_validate&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;cross_val_score&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;cross_val_predict&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;permutation_test_score&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;learning_curve&quot;</span><span class="s3">,</span>
    <span class="s4">&quot;validation_curve&quot;</span><span class="s3">,</span>
<span class="s1">]</span>


<span class="s1">@validate_params(</span>
    <span class="s1">{</span>
        <span class="s4">&quot;estimator&quot;</span><span class="s1">: [HasMethods(</span><span class="s4">&quot;fit&quot;</span><span class="s1">)]</span><span class="s3">,</span>
        <span class="s4">&quot;X&quot;</span><span class="s1">: [</span><span class="s4">&quot;array-like&quot;</span><span class="s3">, </span><span class="s4">&quot;sparse matrix&quot;</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;y&quot;</span><span class="s1">: [</span><span class="s4">&quot;array-like&quot;</span><span class="s3">, None</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;groups&quot;</span><span class="s1">: [</span><span class="s4">&quot;array-like&quot;</span><span class="s3">, None</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;scoring&quot;</span><span class="s1">: [</span>
            <span class="s1">StrOptions(set(get_scorer_names()))</span><span class="s3">,</span>
            <span class="s1">callable</span><span class="s3">,</span>
            <span class="s1">list</span><span class="s3">,</span>
            <span class="s1">tuple</span><span class="s3">,</span>
            <span class="s1">dict</span><span class="s3">,</span>
            <span class="s3">None,</span>
        <span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;cv&quot;</span><span class="s1">: [</span><span class="s4">&quot;cv_object&quot;</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;n_jobs&quot;</span><span class="s1">: [Integral</span><span class="s3">, None</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;verbose&quot;</span><span class="s1">: [</span><span class="s4">&quot;verbose&quot;</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;fit_params&quot;</span><span class="s1">: [dict</span><span class="s3">, None</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;pre_dispatch&quot;</span><span class="s1">: [Integral</span><span class="s3">, </span><span class="s1">str]</span><span class="s3">,</span>
        <span class="s4">&quot;return_train_score&quot;</span><span class="s1">: [</span><span class="s4">&quot;boolean&quot;</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;return_estimator&quot;</span><span class="s1">: [</span><span class="s4">&quot;boolean&quot;</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;return_indices&quot;</span><span class="s1">: [</span><span class="s4">&quot;boolean&quot;</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;error_score&quot;</span><span class="s1">: [StrOptions({</span><span class="s4">&quot;raise&quot;</span><span class="s1">})</span><span class="s3">, </span><span class="s1">Real]</span><span class="s3">,</span>
    <span class="s1">}</span><span class="s3">,</span>
    <span class="s1">prefer_skip_nested_validation=</span><span class="s3">False,  </span><span class="s2"># estimator is not validated yet</span>
<span class="s1">)</span>
<span class="s3">def </span><span class="s1">cross_validate(</span>
    <span class="s1">estimator</span><span class="s3">,</span>
    <span class="s1">X</span><span class="s3">,</span>
    <span class="s1">y=</span><span class="s3">None,</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">groups=</span><span class="s3">None,</span>
    <span class="s1">scoring=</span><span class="s3">None,</span>
    <span class="s1">cv=</span><span class="s3">None,</span>
    <span class="s1">n_jobs=</span><span class="s3">None,</span>
    <span class="s1">verbose=</span><span class="s5">0</span><span class="s3">,</span>
    <span class="s1">fit_params=</span><span class="s3">None,</span>
    <span class="s1">pre_dispatch=</span><span class="s4">&quot;2*n_jobs&quot;</span><span class="s3">,</span>
    <span class="s1">return_train_score=</span><span class="s3">False,</span>
    <span class="s1">return_estimator=</span><span class="s3">False,</span>
    <span class="s1">return_indices=</span><span class="s3">False,</span>
    <span class="s1">error_score=np.nan</span><span class="s3">,</span>
<span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Evaluate metric(s) by cross-validation and also record fit/score times. 
 
    Read more in the :ref:`User Guide &lt;multimetric_cross_validation&gt;`. 
 
    Parameters 
    ---------- 
    estimator : estimator object implementing 'fit' 
        The object to use to fit the data. 
 
    X : {array-like, sparse matrix} of shape (n_samples, n_features) 
        The data to fit. Can be for example a list, or an array. 
 
    y : array-like of shape (n_samples,) or (n_samples, n_outputs), default=None 
        The target variable to try to predict in the case of 
        supervised learning. 
 
    groups : array-like of shape (n_samples,), default=None 
        Group labels for the samples used while splitting the dataset into 
        train/test set. Only used in conjunction with a &quot;Group&quot; :term:`cv` 
        instance (e.g., :class:`GroupKFold`). 
 
    scoring : str, callable, list, tuple, or dict, default=None 
        Strategy to evaluate the performance of the cross-validated model on 
        the test set. 
 
        If `scoring` represents a single score, one can use: 
 
        - a single string (see :ref:`scoring_parameter`); 
        - a callable (see :ref:`scoring`) that returns a single value. 
 
        If `scoring` represents multiple scores, one can use: 
 
        - a list or tuple of unique strings; 
        - a callable returning a dictionary where the keys are the metric 
          names and the values are the metric scores; 
        - a dictionary with metric names as keys and callables a values. 
 
        See :ref:`multimetric_grid_search` for an example. 
 
    cv : int, cross-validation generator or an iterable, default=None 
        Determines the cross-validation splitting strategy. 
        Possible inputs for cv are: 
 
        - None, to use the default 5-fold cross validation, 
        - int, to specify the number of folds in a `(Stratified)KFold`, 
        - :term:`CV splitter`, 
        - An iterable yielding (train, test) splits as arrays of indices. 
 
        For int/None inputs, if the estimator is a classifier and ``y`` is 
        either binary or multiclass, :class:`StratifiedKFold` is used. In all 
        other cases, :class:`KFold` is used. These splitters are instantiated 
        with `shuffle=False` so the splits will be the same across calls. 
 
        Refer :ref:`User Guide &lt;cross_validation&gt;` for the various 
        cross-validation strategies that can be used here. 
 
        .. versionchanged:: 0.22 
            ``cv`` default value if None changed from 3-fold to 5-fold. 
 
    n_jobs : int, default=None 
        Number of jobs to run in parallel. Training the estimator and computing 
        the score are parallelized over the cross-validation splits. 
        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context. 
        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;` 
        for more details. 
 
    verbose : int, default=0 
        The verbosity level. 
 
    fit_params : dict, default=None 
        Parameters to pass to the fit method of the estimator. 
 
    pre_dispatch : int or str, default='2*n_jobs' 
        Controls the number of jobs that get dispatched during parallel 
        execution. Reducing this number can be useful to avoid an 
        explosion of memory consumption when more jobs get dispatched 
        than CPUs can process. This parameter can be: 
 
            - An int, giving the exact number of total jobs that are 
              spawned 
 
            - A str, giving an expression as a function of n_jobs, 
              as in '2*n_jobs' 
 
    return_train_score : bool, default=False 
        Whether to include train scores. 
        Computing training scores is used to get insights on how different 
        parameter settings impact the overfitting/underfitting trade-off. 
        However computing the scores on the training set can be computationally 
        expensive and is not strictly required to select the parameters that 
        yield the best generalization performance. 
 
        .. versionadded:: 0.19 
 
        .. versionchanged:: 0.21 
            Default value was changed from ``True`` to ``False`` 
 
    return_estimator : bool, default=False 
        Whether to return the estimators fitted on each split. 
 
        .. versionadded:: 0.20 
 
    return_indices : bool, default=False 
        Whether to return the train-test indices selected for each split. 
 
        .. versionadded:: 1.3 
 
    error_score : 'raise' or numeric, default=np.nan 
        Value to assign to the score if an error occurs in estimator fitting. 
        If set to 'raise', the error is raised. 
        If a numeric value is given, FitFailedWarning is raised. 
 
        .. versionadded:: 0.20 
 
    Returns 
    ------- 
    scores : dict of float arrays of shape (n_splits,) 
        Array of scores of the estimator for each run of the cross validation. 
 
        A dict of arrays containing the score/time arrays for each scorer is 
        returned. The possible keys for this ``dict`` are: 
 
            ``test_score`` 
                The score array for test scores on each cv split. 
                Suffix ``_score`` in ``test_score`` changes to a specific 
                metric like ``test_r2`` or ``test_auc`` if there are 
                multiple scoring metrics in the scoring parameter. 
            ``train_score`` 
                The score array for train scores on each cv split. 
                Suffix ``_score`` in ``train_score`` changes to a specific 
                metric like ``train_r2`` or ``train_auc`` if there are 
                multiple scoring metrics in the scoring parameter. 
                This is available only if ``return_train_score`` parameter 
                is ``True``. 
            ``fit_time`` 
                The time for fitting the estimator on the train 
                set for each cv split. 
            ``score_time`` 
                The time for scoring the estimator on the test set for each 
                cv split. (Note time for scoring on the train set is not 
                included even if ``return_train_score`` is set to ``True`` 
            ``estimator`` 
                The estimator objects for each cv split. 
                This is available only if ``return_estimator`` parameter 
                is set to ``True``. 
            ``indices`` 
                The train/test positional indices for each cv split. A dictionary 
                is returned where the keys are either `&quot;train&quot;` or `&quot;test&quot;` 
                and the associated values are a list of integer-dtyped NumPy 
                arrays with the indices. Available only if `return_indices=True`. 
 
    See Also 
    -------- 
    cross_val_score : Run cross-validation for single metric evaluation. 
 
    cross_val_predict : Get predictions from each split of cross-validation for 
        diagnostic purposes. 
 
    sklearn.metrics.make_scorer : Make a scorer from a performance metric or 
        loss function. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn import datasets, linear_model 
    &gt;&gt;&gt; from sklearn.model_selection import cross_validate 
    &gt;&gt;&gt; from sklearn.metrics import make_scorer 
    &gt;&gt;&gt; from sklearn.metrics import confusion_matrix 
    &gt;&gt;&gt; from sklearn.svm import LinearSVC 
    &gt;&gt;&gt; diabetes = datasets.load_diabetes() 
    &gt;&gt;&gt; X = diabetes.data[:150] 
    &gt;&gt;&gt; y = diabetes.target[:150] 
    &gt;&gt;&gt; lasso = linear_model.Lasso() 
 
    Single metric evaluation using ``cross_validate`` 
 
    &gt;&gt;&gt; cv_results = cross_validate(lasso, X, y, cv=3) 
    &gt;&gt;&gt; sorted(cv_results.keys()) 
    ['fit_time', 'score_time', 'test_score'] 
    &gt;&gt;&gt; cv_results['test_score'] 
    array([0.3315057 , 0.08022103, 0.03531816]) 
 
    Multiple metric evaluation using ``cross_validate`` 
    (please refer the ``scoring`` parameter doc for more information) 
 
    &gt;&gt;&gt; scores = cross_validate(lasso, X, y, cv=3, 
    ...                         scoring=('r2', 'neg_mean_squared_error'), 
    ...                         return_train_score=True) 
    &gt;&gt;&gt; print(scores['test_neg_mean_squared_error']) 
    [-3635.5... -3573.3... -6114.7...] 
    &gt;&gt;&gt; print(scores['train_r2']) 
    [0.28009951 0.3908844  0.22784907] 
    &quot;&quot;&quot;</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups = indexable(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups)</span>

    <span class="s1">cv = check_cv(cv</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">classifier=is_classifier(estimator))</span>

    <span class="s3">if </span><span class="s1">callable(scoring):</span>
        <span class="s1">scorers = scoring</span>
    <span class="s3">elif </span><span class="s1">scoring </span><span class="s3">is None or </span><span class="s1">isinstance(scoring</span><span class="s3">, </span><span class="s1">str):</span>
        <span class="s1">scorers = check_scoring(estimator</span><span class="s3">, </span><span class="s1">scoring)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">scorers = _check_multimetric_scoring(estimator</span><span class="s3">, </span><span class="s1">scoring)</span>

    <span class="s1">indices = cv.split(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups)</span>
    <span class="s3">if </span><span class="s1">return_indices:</span>
        <span class="s2"># materialize the indices since we need to store them in the returned dict</span>
        <span class="s1">indices = list(indices)</span>

    <span class="s2"># We clone the estimator to make sure that all the folds are</span>
    <span class="s2"># independent, and that it is pickle-able.</span>
    <span class="s1">parallel = Parallel(n_jobs=n_jobs</span><span class="s3">, </span><span class="s1">verbose=verbose</span><span class="s3">, </span><span class="s1">pre_dispatch=pre_dispatch)</span>
    <span class="s1">results = parallel(</span>
        <span class="s1">delayed(_fit_and_score)(</span>
            <span class="s1">clone(estimator)</span><span class="s3">,</span>
            <span class="s1">X</span><span class="s3">,</span>
            <span class="s1">y</span><span class="s3">,</span>
            <span class="s1">scorers</span><span class="s3">,</span>
            <span class="s1">train</span><span class="s3">,</span>
            <span class="s1">test</span><span class="s3">,</span>
            <span class="s1">verbose</span><span class="s3">,</span>
            <span class="s3">None,</span>
            <span class="s1">fit_params</span><span class="s3">,</span>
            <span class="s1">return_train_score=return_train_score</span><span class="s3">,</span>
            <span class="s1">return_times=</span><span class="s3">True,</span>
            <span class="s1">return_estimator=return_estimator</span><span class="s3">,</span>
            <span class="s1">error_score=error_score</span><span class="s3">,</span>
        <span class="s1">)</span>
        <span class="s3">for </span><span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">in </span><span class="s1">indices</span>
    <span class="s1">)</span>

    <span class="s1">_warn_or_raise_about_fit_failures(results</span><span class="s3">, </span><span class="s1">error_score)</span>

    <span class="s2"># For callable scoring, the return type is only know after calling. If the</span>
    <span class="s2"># return type is a dictionary, the error scores can now be inserted with</span>
    <span class="s2"># the correct key.</span>
    <span class="s3">if </span><span class="s1">callable(scoring):</span>
        <span class="s1">_insert_error_scores(results</span><span class="s3">, </span><span class="s1">error_score)</span>

    <span class="s1">results = _aggregate_score_dicts(results)</span>

    <span class="s1">ret = {}</span>
    <span class="s1">ret[</span><span class="s4">&quot;fit_time&quot;</span><span class="s1">] = results[</span><span class="s4">&quot;fit_time&quot;</span><span class="s1">]</span>
    <span class="s1">ret[</span><span class="s4">&quot;score_time&quot;</span><span class="s1">] = results[</span><span class="s4">&quot;score_time&quot;</span><span class="s1">]</span>

    <span class="s3">if </span><span class="s1">return_estimator:</span>
        <span class="s1">ret[</span><span class="s4">&quot;estimator&quot;</span><span class="s1">] = results[</span><span class="s4">&quot;estimator&quot;</span><span class="s1">]</span>

    <span class="s3">if </span><span class="s1">return_indices:</span>
        <span class="s1">ret[</span><span class="s4">&quot;indices&quot;</span><span class="s1">] = {}</span>
        <span class="s1">ret[</span><span class="s4">&quot;indices&quot;</span><span class="s1">][</span><span class="s4">&quot;train&quot;</span><span class="s1">]</span><span class="s3">, </span><span class="s1">ret[</span><span class="s4">&quot;indices&quot;</span><span class="s1">][</span><span class="s4">&quot;test&quot;</span><span class="s1">] = zip(*indices)</span>

    <span class="s1">test_scores_dict = _normalize_score_results(results[</span><span class="s4">&quot;test_scores&quot;</span><span class="s1">])</span>
    <span class="s3">if </span><span class="s1">return_train_score:</span>
        <span class="s1">train_scores_dict = _normalize_score_results(results[</span><span class="s4">&quot;train_scores&quot;</span><span class="s1">])</span>

    <span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">test_scores_dict:</span>
        <span class="s1">ret[</span><span class="s4">&quot;test_%s&quot; </span><span class="s1">% name] = test_scores_dict[name]</span>
        <span class="s3">if </span><span class="s1">return_train_score:</span>
            <span class="s1">key = </span><span class="s4">&quot;train_%s&quot; </span><span class="s1">% name</span>
            <span class="s1">ret[key] = train_scores_dict[name]</span>

    <span class="s3">return </span><span class="s1">ret</span>


<span class="s3">def </span><span class="s1">_insert_error_scores(results</span><span class="s3">, </span><span class="s1">error_score):</span>
    <span class="s0">&quot;&quot;&quot;Insert error in `results` by replacing them inplace with `error_score`. 
 
    This only applies to multimetric scores because `_fit_and_score` will 
    handle the single metric case. 
    &quot;&quot;&quot;</span>
    <span class="s1">successful_score = </span><span class="s3">None</span>
    <span class="s1">failed_indices = []</span>
    <span class="s3">for </span><span class="s1">i</span><span class="s3">, </span><span class="s1">result </span><span class="s3">in </span><span class="s1">enumerate(results):</span>
        <span class="s3">if </span><span class="s1">result[</span><span class="s4">&quot;fit_error&quot;</span><span class="s1">] </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">failed_indices.append(i)</span>
        <span class="s3">elif </span><span class="s1">successful_score </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">successful_score = result[</span><span class="s4">&quot;test_scores&quot;</span><span class="s1">]</span>

    <span class="s3">if </span><span class="s1">isinstance(successful_score</span><span class="s3">, </span><span class="s1">dict):</span>
        <span class="s1">formatted_error = {name: error_score </span><span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">successful_score}</span>
        <span class="s3">for </span><span class="s1">i </span><span class="s3">in </span><span class="s1">failed_indices:</span>
            <span class="s1">results[i][</span><span class="s4">&quot;test_scores&quot;</span><span class="s1">] = formatted_error.copy()</span>
            <span class="s3">if </span><span class="s4">&quot;train_scores&quot; </span><span class="s3">in </span><span class="s1">results[i]:</span>
                <span class="s1">results[i][</span><span class="s4">&quot;train_scores&quot;</span><span class="s1">] = formatted_error.copy()</span>


<span class="s3">def </span><span class="s1">_normalize_score_results(scores</span><span class="s3">, </span><span class="s1">scaler_score_key=</span><span class="s4">&quot;score&quot;</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Creates a scoring dictionary based on the type of `scores`&quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">isinstance(scores[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">dict):</span>
        <span class="s2"># multimetric scoring</span>
        <span class="s3">return </span><span class="s1">_aggregate_score_dicts(scores)</span>
    <span class="s2"># scaler</span>
    <span class="s3">return </span><span class="s1">{scaler_score_key: scores}</span>


<span class="s3">def </span><span class="s1">_warn_or_raise_about_fit_failures(results</span><span class="s3">, </span><span class="s1">error_score):</span>
    <span class="s1">fit_errors = [</span>
        <span class="s1">result[</span><span class="s4">&quot;fit_error&quot;</span><span class="s1">] </span><span class="s3">for </span><span class="s1">result </span><span class="s3">in </span><span class="s1">results </span><span class="s3">if </span><span class="s1">result[</span><span class="s4">&quot;fit_error&quot;</span><span class="s1">] </span><span class="s3">is not None</span>
    <span class="s1">]</span>
    <span class="s3">if </span><span class="s1">fit_errors:</span>
        <span class="s1">num_failed_fits = len(fit_errors)</span>
        <span class="s1">num_fits = len(results)</span>
        <span class="s1">fit_errors_counter = Counter(fit_errors)</span>
        <span class="s1">delimiter = </span><span class="s4">&quot;-&quot; </span><span class="s1">* </span><span class="s5">80 </span><span class="s1">+ </span><span class="s4">&quot;</span><span class="s3">\n</span><span class="s4">&quot;</span>
        <span class="s1">fit_errors_summary = </span><span class="s4">&quot;</span><span class="s3">\n</span><span class="s4">&quot;</span><span class="s1">.join(</span>
            <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">delimiter</span><span class="s3">}{</span><span class="s1">n</span><span class="s3">} </span><span class="s4">fits failed with the following error:</span><span class="s3">\n{</span><span class="s1">error</span><span class="s3">}</span><span class="s4">&quot;</span>
            <span class="s3">for </span><span class="s1">error</span><span class="s3">, </span><span class="s1">n </span><span class="s3">in </span><span class="s1">fit_errors_counter.items()</span>
        <span class="s1">)</span>

        <span class="s3">if </span><span class="s1">num_failed_fits == num_fits:</span>
            <span class="s1">all_fits_failed_message = (</span>
                <span class="s4">f&quot;</span><span class="s3">\n</span><span class="s4">All the </span><span class="s3">{</span><span class="s1">num_fits</span><span class="s3">} </span><span class="s4">fits failed.</span><span class="s3">\n</span><span class="s4">&quot;</span>
                <span class="s4">&quot;It is very likely that your model is misconfigured.</span><span class="s3">\n</span><span class="s4">&quot;</span>
                <span class="s4">&quot;You can try to debug the error by setting error_score='raise'.</span><span class="s3">\n\n</span><span class="s4">&quot;</span>
                <span class="s4">f&quot;Below are more details about the failures:</span><span class="s3">\n{</span><span class="s1">fit_errors_summary</span><span class="s3">}</span><span class="s4">&quot;</span>
            <span class="s1">)</span>
            <span class="s3">raise </span><span class="s1">ValueError(all_fits_failed_message)</span>

        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">some_fits_failed_message = (</span>
                <span class="s4">f&quot;</span><span class="s3">\n{</span><span class="s1">num_failed_fits</span><span class="s3">} </span><span class="s4">fits failed out of a total of </span><span class="s3">{</span><span class="s1">num_fits</span><span class="s3">}</span><span class="s4">.</span><span class="s3">\n</span><span class="s4">&quot;</span>
                <span class="s4">&quot;The score on these train-test partitions for these parameters&quot;</span>
                <span class="s4">f&quot; will be set to </span><span class="s3">{</span><span class="s1">error_score</span><span class="s3">}</span><span class="s4">.</span><span class="s3">\n</span><span class="s4">&quot;</span>
                <span class="s4">&quot;If these failures are not expected, you can try to debug them &quot;</span>
                <span class="s4">&quot;by setting error_score='raise'.</span><span class="s3">\n\n</span><span class="s4">&quot;</span>
                <span class="s4">f&quot;Below are more details about the failures:</span><span class="s3">\n{</span><span class="s1">fit_errors_summary</span><span class="s3">}</span><span class="s4">&quot;</span>
            <span class="s1">)</span>
            <span class="s1">warnings.warn(some_fits_failed_message</span><span class="s3">, </span><span class="s1">FitFailedWarning)</span>


<span class="s3">def </span><span class="s1">cross_val_score(</span>
    <span class="s1">estimator</span><span class="s3">,</span>
    <span class="s1">X</span><span class="s3">,</span>
    <span class="s1">y=</span><span class="s3">None,</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">groups=</span><span class="s3">None,</span>
    <span class="s1">scoring=</span><span class="s3">None,</span>
    <span class="s1">cv=</span><span class="s3">None,</span>
    <span class="s1">n_jobs=</span><span class="s3">None,</span>
    <span class="s1">verbose=</span><span class="s5">0</span><span class="s3">,</span>
    <span class="s1">fit_params=</span><span class="s3">None,</span>
    <span class="s1">pre_dispatch=</span><span class="s4">&quot;2*n_jobs&quot;</span><span class="s3">,</span>
    <span class="s1">error_score=np.nan</span><span class="s3">,</span>
<span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Evaluate a score by cross-validation. 
 
    Read more in the :ref:`User Guide &lt;cross_validation&gt;`. 
 
    Parameters 
    ---------- 
    estimator : estimator object implementing 'fit' 
        The object to use to fit the data. 
 
    X : array-like of shape (n_samples, n_features) 
        The data to fit. Can be for example a list, or an array. 
 
    y : array-like of shape (n_samples,) or (n_samples, n_outputs), \ 
            default=None 
        The target variable to try to predict in the case of 
        supervised learning. 
 
    groups : array-like of shape (n_samples,), default=None 
        Group labels for the samples used while splitting the dataset into 
        train/test set. Only used in conjunction with a &quot;Group&quot; :term:`cv` 
        instance (e.g., :class:`GroupKFold`). 
 
    scoring : str or callable, default=None 
        A str (see model evaluation documentation) or 
        a scorer callable object / function with signature 
        ``scorer(estimator, X, y)`` which should return only 
        a single value. 
 
        Similar to :func:`cross_validate` 
        but only a single metric is permitted. 
 
        If `None`, the estimator's default scorer (if available) is used. 
 
    cv : int, cross-validation generator or an iterable, default=None 
        Determines the cross-validation splitting strategy. 
        Possible inputs for cv are: 
 
        - `None`, to use the default 5-fold cross validation, 
        - int, to specify the number of folds in a `(Stratified)KFold`, 
        - :term:`CV splitter`, 
        - An iterable that generates (train, test) splits as arrays of indices. 
 
        For `int`/`None` inputs, if the estimator is a classifier and `y` is 
        either binary or multiclass, :class:`StratifiedKFold` is used. In all 
        other cases, :class:`KFold` is used. These splitters are instantiated 
        with `shuffle=False` so the splits will be the same across calls. 
 
        Refer :ref:`User Guide &lt;cross_validation&gt;` for the various 
        cross-validation strategies that can be used here. 
 
        .. versionchanged:: 0.22 
            `cv` default value if `None` changed from 3-fold to 5-fold. 
 
    n_jobs : int, default=None 
        Number of jobs to run in parallel. Training the estimator and computing 
        the score are parallelized over the cross-validation splits. 
        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context. 
        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;` 
        for more details. 
 
    verbose : int, default=0 
        The verbosity level. 
 
    fit_params : dict, default=None 
        Parameters to pass to the fit method of the estimator. 
 
    pre_dispatch : int or str, default='2*n_jobs' 
        Controls the number of jobs that get dispatched during parallel 
        execution. Reducing this number can be useful to avoid an 
        explosion of memory consumption when more jobs get dispatched 
        than CPUs can process. This parameter can be: 
 
            - ``None``, in which case all the jobs are immediately 
              created and spawned. Use this for lightweight and 
              fast-running jobs, to avoid delays due to on-demand 
              spawning of the jobs 
 
            - An int, giving the exact number of total jobs that are 
              spawned 
 
            - A str, giving an expression as a function of n_jobs, 
              as in '2*n_jobs' 
 
    error_score : 'raise' or numeric, default=np.nan 
        Value to assign to the score if an error occurs in estimator fitting. 
        If set to 'raise', the error is raised. 
        If a numeric value is given, FitFailedWarning is raised. 
 
        .. versionadded:: 0.20 
 
    Returns 
    ------- 
    scores : ndarray of float of shape=(len(list(cv)),) 
        Array of scores of the estimator for each run of the cross validation. 
 
    See Also 
    -------- 
    cross_validate : To run cross-validation on multiple metrics and also to 
        return train scores, fit times and score times. 
 
    cross_val_predict : Get predictions from each split of cross-validation for 
        diagnostic purposes. 
 
    sklearn.metrics.make_scorer : Make a scorer from a performance metric or 
        loss function. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn import datasets, linear_model 
    &gt;&gt;&gt; from sklearn.model_selection import cross_val_score 
    &gt;&gt;&gt; diabetes = datasets.load_diabetes() 
    &gt;&gt;&gt; X = diabetes.data[:150] 
    &gt;&gt;&gt; y = diabetes.target[:150] 
    &gt;&gt;&gt; lasso = linear_model.Lasso() 
    &gt;&gt;&gt; print(cross_val_score(lasso, X, y, cv=3)) 
    [0.3315057  0.08022103 0.03531816] 
    &quot;&quot;&quot;</span>
    <span class="s2"># To ensure multimetric format is not supported</span>
    <span class="s1">scorer = check_scoring(estimator</span><span class="s3">, </span><span class="s1">scoring=scoring)</span>

    <span class="s1">cv_results = cross_validate(</span>
        <span class="s1">estimator=estimator</span><span class="s3">,</span>
        <span class="s1">X=X</span><span class="s3">,</span>
        <span class="s1">y=y</span><span class="s3">,</span>
        <span class="s1">groups=groups</span><span class="s3">,</span>
        <span class="s1">scoring={</span><span class="s4">&quot;score&quot;</span><span class="s1">: scorer}</span><span class="s3">,</span>
        <span class="s1">cv=cv</span><span class="s3">,</span>
        <span class="s1">n_jobs=n_jobs</span><span class="s3">,</span>
        <span class="s1">verbose=verbose</span><span class="s3">,</span>
        <span class="s1">fit_params=fit_params</span><span class="s3">,</span>
        <span class="s1">pre_dispatch=pre_dispatch</span><span class="s3">,</span>
        <span class="s1">error_score=error_score</span><span class="s3">,</span>
    <span class="s1">)</span>
    <span class="s3">return </span><span class="s1">cv_results[</span><span class="s4">&quot;test_score&quot;</span><span class="s1">]</span>


<span class="s3">def </span><span class="s1">_fit_and_score(</span>
    <span class="s1">estimator</span><span class="s3">,</span>
    <span class="s1">X</span><span class="s3">,</span>
    <span class="s1">y</span><span class="s3">,</span>
    <span class="s1">scorer</span><span class="s3">,</span>
    <span class="s1">train</span><span class="s3">,</span>
    <span class="s1">test</span><span class="s3">,</span>
    <span class="s1">verbose</span><span class="s3">,</span>
    <span class="s1">parameters</span><span class="s3">,</span>
    <span class="s1">fit_params</span><span class="s3">,</span>
    <span class="s1">return_train_score=</span><span class="s3">False,</span>
    <span class="s1">return_parameters=</span><span class="s3">False,</span>
    <span class="s1">return_n_test_samples=</span><span class="s3">False,</span>
    <span class="s1">return_times=</span><span class="s3">False,</span>
    <span class="s1">return_estimator=</span><span class="s3">False,</span>
    <span class="s1">split_progress=</span><span class="s3">None,</span>
    <span class="s1">candidate_progress=</span><span class="s3">None,</span>
    <span class="s1">error_score=np.nan</span><span class="s3">,</span>
<span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Fit estimator and compute scores for a given dataset split. 
 
    Parameters 
    ---------- 
    estimator : estimator object implementing 'fit' 
        The object to use to fit the data. 
 
    X : array-like of shape (n_samples, n_features) 
        The data to fit. 
 
    y : array-like of shape (n_samples,) or (n_samples, n_outputs) or None 
        The target variable to try to predict in the case of 
        supervised learning. 
 
    scorer : A single callable or dict mapping scorer name to the callable 
        If it is a single callable, the return value for ``train_scores`` and 
        ``test_scores`` is a single float. 
 
        For a dict, it should be one mapping the scorer name to the scorer 
        callable object / function. 
 
        The callable object / fn should have signature 
        ``scorer(estimator, X, y)``. 
 
    train : array-like of shape (n_train_samples,) 
        Indices of training samples. 
 
    test : array-like of shape (n_test_samples,) 
        Indices of test samples. 
 
    verbose : int 
        The verbosity level. 
 
    error_score : 'raise' or numeric, default=np.nan 
        Value to assign to the score if an error occurs in estimator fitting. 
        If set to 'raise', the error is raised. 
        If a numeric value is given, FitFailedWarning is raised. 
 
    parameters : dict or None 
        Parameters to be set on the estimator. 
 
    fit_params : dict or None 
        Parameters that will be passed to ``estimator.fit``. 
 
    return_train_score : bool, default=False 
        Compute and return score on training set. 
 
    return_parameters : bool, default=False 
        Return parameters that has been used for the estimator. 
 
    split_progress : {list, tuple} of int, default=None 
        A list or tuple of format (&lt;current_split_id&gt;, &lt;total_num_of_splits&gt;). 
 
    candidate_progress : {list, tuple} of int, default=None 
        A list or tuple of format 
        (&lt;current_candidate_id&gt;, &lt;total_number_of_candidates&gt;). 
 
    return_n_test_samples : bool, default=False 
        Whether to return the ``n_test_samples``. 
 
    return_times : bool, default=False 
        Whether to return the fit/score times. 
 
    return_estimator : bool, default=False 
        Whether to return the fitted estimator. 
 
    Returns 
    ------- 
    result : dict with the following attributes 
        train_scores : dict of scorer name -&gt; float 
            Score on training set (for all the scorers), 
            returned only if `return_train_score` is `True`. 
        test_scores : dict of scorer name -&gt; float 
            Score on testing set (for all the scorers). 
        n_test_samples : int 
            Number of test samples. 
        fit_time : float 
            Time spent for fitting in seconds. 
        score_time : float 
            Time spent for scoring in seconds. 
        parameters : dict or None 
            The parameters that have been evaluated. 
        estimator : estimator object 
            The fitted estimator. 
        fit_error : str or None 
            Traceback str if the fit failed, None if the fit succeeded. 
    &quot;&quot;&quot;</span>
    <span class="s3">if not </span><span class="s1">isinstance(error_score</span><span class="s3">, </span><span class="s1">numbers.Number) </span><span class="s3">and </span><span class="s1">error_score != </span><span class="s4">&quot;raise&quot;</span><span class="s1">:</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span>
            <span class="s4">&quot;error_score must be the string 'raise' or a numeric value. &quot;</span>
            <span class="s4">&quot;(Hint: if using 'raise', please make sure that it has been &quot;</span>
            <span class="s4">&quot;spelled correctly.)&quot;</span>
        <span class="s1">)</span>

    <span class="s1">progress_msg = </span><span class="s4">&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">verbose &gt; </span><span class="s5">2</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">split_progress </span><span class="s3">is not None</span><span class="s1">:</span>
            <span class="s1">progress_msg = </span><span class="s4">f&quot; </span><span class="s3">{</span><span class="s1">split_progress[</span><span class="s5">0</span><span class="s1">]+</span><span class="s5">1</span><span class="s3">}</span><span class="s4">/</span><span class="s3">{</span><span class="s1">split_progress[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">}</span><span class="s4">&quot;</span>
        <span class="s3">if </span><span class="s1">candidate_progress </span><span class="s3">and </span><span class="s1">verbose &gt; </span><span class="s5">9</span><span class="s1">:</span>
            <span class="s1">progress_msg += </span><span class="s4">f&quot;; </span><span class="s3">{</span><span class="s1">candidate_progress[</span><span class="s5">0</span><span class="s1">]+</span><span class="s5">1</span><span class="s3">}</span><span class="s4">/</span><span class="s3">{</span><span class="s1">candidate_progress[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">}</span><span class="s4">&quot;</span>

    <span class="s3">if </span><span class="s1">verbose &gt; </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">parameters </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">params_msg = </span><span class="s4">&quot;&quot;</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">sorted_keys = sorted(parameters)  </span><span class="s2"># Ensure deterministic o/p</span>
            <span class="s1">params_msg = </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(</span><span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">k</span><span class="s3">}</span><span class="s4">=</span><span class="s3">{</span><span class="s1">parameters[k]</span><span class="s3">}</span><span class="s4">&quot; </span><span class="s3">for </span><span class="s1">k </span><span class="s3">in </span><span class="s1">sorted_keys)</span>
    <span class="s3">if </span><span class="s1">verbose &gt; </span><span class="s5">9</span><span class="s1">:</span>
        <span class="s1">start_msg = </span><span class="s4">f&quot;[CV</span><span class="s3">{</span><span class="s1">progress_msg</span><span class="s3">}</span><span class="s4">] START </span><span class="s3">{</span><span class="s1">params_msg</span><span class="s3">}</span><span class="s4">&quot;</span>
        <span class="s1">print(</span><span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">start_msg</span><span class="s3">}{</span><span class="s1">(</span><span class="s5">80 </span><span class="s1">- len(start_msg)) * </span><span class="s4">'.'</span><span class="s3">}</span><span class="s4">&quot;</span><span class="s1">)</span>

    <span class="s2"># Adjust length of sample weights</span>
    <span class="s1">fit_params = fit_params </span><span class="s3">if </span><span class="s1">fit_params </span><span class="s3">is not None else </span><span class="s1">{}</span>
    <span class="s1">fit_params = _check_fit_params(X</span><span class="s3">, </span><span class="s1">fit_params</span><span class="s3">, </span><span class="s1">train)</span>

    <span class="s3">if </span><span class="s1">parameters </span><span class="s3">is not None</span><span class="s1">:</span>
        <span class="s2"># here we clone the parameters, since sometimes the parameters</span>
        <span class="s2"># themselves might be estimators, e.g. when we search over different</span>
        <span class="s2"># estimators in a pipeline.</span>
        <span class="s2"># ref: https://github.com/scikit-learn/scikit-learn/pull/26786</span>
        <span class="s1">estimator = estimator.set_params(**clone(parameters</span><span class="s3">, </span><span class="s1">safe=</span><span class="s3">False</span><span class="s1">))</span>

    <span class="s1">start_time = time.time()</span>

    <span class="s1">X_train</span><span class="s3">, </span><span class="s1">y_train = _safe_split(estimator</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">train)</span>
    <span class="s1">X_test</span><span class="s3">, </span><span class="s1">y_test = _safe_split(estimator</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">test</span><span class="s3">, </span><span class="s1">train)</span>

    <span class="s1">result = {}</span>
    <span class="s3">try</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">y_train </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">estimator.fit(X_train</span><span class="s3">, </span><span class="s1">**fit_params)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">estimator.fit(X_train</span><span class="s3">, </span><span class="s1">y_train</span><span class="s3">, </span><span class="s1">**fit_params)</span>

    <span class="s3">except </span><span class="s1">Exception:</span>
        <span class="s2"># Note fit time as time until error</span>
        <span class="s1">fit_time = time.time() - start_time</span>
        <span class="s1">score_time = </span><span class="s5">0.0</span>
        <span class="s3">if </span><span class="s1">error_score == </span><span class="s4">&quot;raise&quot;</span><span class="s1">:</span>
            <span class="s3">raise</span>
        <span class="s3">elif </span><span class="s1">isinstance(error_score</span><span class="s3">, </span><span class="s1">numbers.Number):</span>
            <span class="s3">if </span><span class="s1">isinstance(scorer</span><span class="s3">, </span><span class="s1">dict):</span>
                <span class="s1">test_scores = {name: error_score </span><span class="s3">for </span><span class="s1">name </span><span class="s3">in </span><span class="s1">scorer}</span>
                <span class="s3">if </span><span class="s1">return_train_score:</span>
                    <span class="s1">train_scores = test_scores.copy()</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">test_scores = error_score</span>
                <span class="s3">if </span><span class="s1">return_train_score:</span>
                    <span class="s1">train_scores = error_score</span>
        <span class="s1">result[</span><span class="s4">&quot;fit_error&quot;</span><span class="s1">] = format_exc()</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">result[</span><span class="s4">&quot;fit_error&quot;</span><span class="s1">] = </span><span class="s3">None</span>

        <span class="s1">fit_time = time.time() - start_time</span>
        <span class="s1">test_scores = _score(estimator</span><span class="s3">, </span><span class="s1">X_test</span><span class="s3">, </span><span class="s1">y_test</span><span class="s3">, </span><span class="s1">scorer</span><span class="s3">, </span><span class="s1">error_score)</span>
        <span class="s1">score_time = time.time() - start_time - fit_time</span>
        <span class="s3">if </span><span class="s1">return_train_score:</span>
            <span class="s1">train_scores = _score(estimator</span><span class="s3">, </span><span class="s1">X_train</span><span class="s3">, </span><span class="s1">y_train</span><span class="s3">, </span><span class="s1">scorer</span><span class="s3">, </span><span class="s1">error_score)</span>

    <span class="s3">if </span><span class="s1">verbose &gt; </span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">total_time = score_time + fit_time</span>
        <span class="s1">end_msg = </span><span class="s4">f&quot;[CV</span><span class="s3">{</span><span class="s1">progress_msg</span><span class="s3">}</span><span class="s4">] END &quot;</span>
        <span class="s1">result_msg = params_msg + (</span><span class="s4">&quot;;&quot; </span><span class="s3">if </span><span class="s1">params_msg </span><span class="s3">else </span><span class="s4">&quot;&quot;</span><span class="s1">)</span>
        <span class="s3">if </span><span class="s1">verbose &gt; </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">isinstance(test_scores</span><span class="s3">, </span><span class="s1">dict):</span>
                <span class="s3">for </span><span class="s1">scorer_name </span><span class="s3">in </span><span class="s1">sorted(test_scores):</span>
                    <span class="s1">result_msg += </span><span class="s4">f&quot; </span><span class="s3">{</span><span class="s1">scorer_name</span><span class="s3">}</span><span class="s4">: (&quot;</span>
                    <span class="s3">if </span><span class="s1">return_train_score:</span>
                        <span class="s1">scorer_scores = train_scores[scorer_name]</span>
                        <span class="s1">result_msg += </span><span class="s4">f&quot;train=</span><span class="s3">{</span><span class="s1">scorer_scores</span><span class="s3">:</span><span class="s4">.3f</span><span class="s3">}</span><span class="s4">, &quot;</span>
                    <span class="s1">result_msg += </span><span class="s4">f&quot;test=</span><span class="s3">{</span><span class="s1">test_scores[scorer_name]</span><span class="s3">:</span><span class="s4">.3f</span><span class="s3">}</span><span class="s4">)&quot;</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">result_msg += </span><span class="s4">&quot;, score=&quot;</span>
                <span class="s3">if </span><span class="s1">return_train_score:</span>
                    <span class="s1">result_msg += </span><span class="s4">f&quot;(train=</span><span class="s3">{</span><span class="s1">train_scores</span><span class="s3">:</span><span class="s4">.3f</span><span class="s3">}</span><span class="s4">, test=</span><span class="s3">{</span><span class="s1">test_scores</span><span class="s3">:</span><span class="s4">.3f</span><span class="s3">}</span><span class="s4">)&quot;</span>
                <span class="s3">else</span><span class="s1">:</span>
                    <span class="s1">result_msg += </span><span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">test_scores</span><span class="s3">:</span><span class="s4">.3f</span><span class="s3">}</span><span class="s4">&quot;</span>
        <span class="s1">result_msg += </span><span class="s4">f&quot; total time=</span><span class="s3">{</span><span class="s1">logger.short_format_time(total_time)</span><span class="s3">}</span><span class="s4">&quot;</span>

        <span class="s2"># Right align the result_msg</span>
        <span class="s1">end_msg += </span><span class="s4">&quot;.&quot; </span><span class="s1">* (</span><span class="s5">80 </span><span class="s1">- len(end_msg) - len(result_msg))</span>
        <span class="s1">end_msg += result_msg</span>
        <span class="s1">print(end_msg)</span>

    <span class="s1">result[</span><span class="s4">&quot;test_scores&quot;</span><span class="s1">] = test_scores</span>
    <span class="s3">if </span><span class="s1">return_train_score:</span>
        <span class="s1">result[</span><span class="s4">&quot;train_scores&quot;</span><span class="s1">] = train_scores</span>
    <span class="s3">if </span><span class="s1">return_n_test_samples:</span>
        <span class="s1">result[</span><span class="s4">&quot;n_test_samples&quot;</span><span class="s1">] = _num_samples(X_test)</span>
    <span class="s3">if </span><span class="s1">return_times:</span>
        <span class="s1">result[</span><span class="s4">&quot;fit_time&quot;</span><span class="s1">] = fit_time</span>
        <span class="s1">result[</span><span class="s4">&quot;score_time&quot;</span><span class="s1">] = score_time</span>
    <span class="s3">if </span><span class="s1">return_parameters:</span>
        <span class="s1">result[</span><span class="s4">&quot;parameters&quot;</span><span class="s1">] = parameters</span>
    <span class="s3">if </span><span class="s1">return_estimator:</span>
        <span class="s1">result[</span><span class="s4">&quot;estimator&quot;</span><span class="s1">] = estimator</span>
    <span class="s3">return </span><span class="s1">result</span>


<span class="s3">def </span><span class="s1">_score(estimator</span><span class="s3">, </span><span class="s1">X_test</span><span class="s3">, </span><span class="s1">y_test</span><span class="s3">, </span><span class="s1">scorer</span><span class="s3">, </span><span class="s1">error_score=</span><span class="s4">&quot;raise&quot;</span><span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Compute the score(s) of an estimator on a given test set. 
 
    Will return a dict of floats if `scorer` is a dict, otherwise a single 
    float is returned. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">isinstance(scorer</span><span class="s3">, </span><span class="s1">dict):</span>
        <span class="s2"># will cache method calls if needed. scorer() returns a dict</span>
        <span class="s1">scorer = _MultimetricScorer(scorers=scorer</span><span class="s3">, </span><span class="s1">raise_exc=(error_score == </span><span class="s4">&quot;raise&quot;</span><span class="s1">))</span>

    <span class="s3">try</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">y_test </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">scores = scorer(estimator</span><span class="s3">, </span><span class="s1">X_test)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">scores = scorer(estimator</span><span class="s3">, </span><span class="s1">X_test</span><span class="s3">, </span><span class="s1">y_test)</span>
    <span class="s3">except </span><span class="s1">Exception:</span>
        <span class="s3">if </span><span class="s1">isinstance(scorer</span><span class="s3">, </span><span class="s1">_MultimetricScorer):</span>
            <span class="s2"># If `_MultimetricScorer` raises exception, the `error_score`</span>
            <span class="s2"># parameter is equal to &quot;raise&quot;.</span>
            <span class="s3">raise</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">error_score == </span><span class="s4">&quot;raise&quot;</span><span class="s1">:</span>
                <span class="s3">raise</span>
            <span class="s3">else</span><span class="s1">:</span>
                <span class="s1">scores = error_score</span>
                <span class="s1">warnings.warn(</span>
                    <span class="s1">(</span>
                        <span class="s4">&quot;Scoring failed. The score on this train-test partition for &quot;</span>
                        <span class="s4">f&quot;these parameters will be set to </span><span class="s3">{</span><span class="s1">error_score</span><span class="s3">}</span><span class="s4">. Details: </span><span class="s3">\n</span><span class="s4">&quot;</span>
                        <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">format_exc()</span><span class="s3">}</span><span class="s4">&quot;</span>
                    <span class="s1">)</span><span class="s3">,</span>
                    <span class="s1">UserWarning</span><span class="s3">,</span>
                <span class="s1">)</span>

    <span class="s2"># Check non-raised error messages in `_MultimetricScorer`</span>
    <span class="s3">if </span><span class="s1">isinstance(scorer</span><span class="s3">, </span><span class="s1">_MultimetricScorer):</span>
        <span class="s1">exception_messages = [</span>
            <span class="s1">(name</span><span class="s3">, </span><span class="s1">str_e) </span><span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">str_e </span><span class="s3">in </span><span class="s1">scores.items() </span><span class="s3">if </span><span class="s1">isinstance(str_e</span><span class="s3">, </span><span class="s1">str)</span>
        <span class="s1">]</span>
        <span class="s3">if </span><span class="s1">exception_messages:</span>
            <span class="s2"># error_score != &quot;raise&quot;</span>
            <span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">str_e </span><span class="s3">in </span><span class="s1">exception_messages:</span>
                <span class="s1">scores[name] = error_score</span>
                <span class="s1">warnings.warn(</span>
                    <span class="s1">(</span>
                        <span class="s4">&quot;Scoring failed. The score on this train-test partition for &quot;</span>
                        <span class="s4">f&quot;these parameters will be set to </span><span class="s3">{</span><span class="s1">error_score</span><span class="s3">}</span><span class="s4">. Details: </span><span class="s3">\n</span><span class="s4">&quot;</span>
                        <span class="s4">f&quot;</span><span class="s3">{</span><span class="s1">str_e</span><span class="s3">}</span><span class="s4">&quot;</span>
                    <span class="s1">)</span><span class="s3">,</span>
                    <span class="s1">UserWarning</span><span class="s3">,</span>
                <span class="s1">)</span>

    <span class="s1">error_msg = </span><span class="s4">&quot;scoring must return a number, got %s (%s) instead. (scorer=%s)&quot;</span>
    <span class="s3">if </span><span class="s1">isinstance(scores</span><span class="s3">, </span><span class="s1">dict):</span>
        <span class="s3">for </span><span class="s1">name</span><span class="s3">, </span><span class="s1">score </span><span class="s3">in </span><span class="s1">scores.items():</span>
            <span class="s3">if </span><span class="s1">hasattr(score</span><span class="s3">, </span><span class="s4">&quot;item&quot;</span><span class="s1">):</span>
                <span class="s3">with </span><span class="s1">suppress(ValueError):</span>
                    <span class="s2"># e.g. unwrap memmapped scalars</span>
                    <span class="s1">score = score.item()</span>
            <span class="s3">if not </span><span class="s1">isinstance(score</span><span class="s3">, </span><span class="s1">numbers.Number):</span>
                <span class="s3">raise </span><span class="s1">ValueError(error_msg % (score</span><span class="s3">, </span><span class="s1">type(score)</span><span class="s3">, </span><span class="s1">name))</span>
            <span class="s1">scores[name] = score</span>
    <span class="s3">else</span><span class="s1">:  </span><span class="s2"># scalar</span>
        <span class="s3">if </span><span class="s1">hasattr(scores</span><span class="s3">, </span><span class="s4">&quot;item&quot;</span><span class="s1">):</span>
            <span class="s3">with </span><span class="s1">suppress(ValueError):</span>
                <span class="s2"># e.g. unwrap memmapped scalars</span>
                <span class="s1">scores = scores.item()</span>
        <span class="s3">if not </span><span class="s1">isinstance(scores</span><span class="s3">, </span><span class="s1">numbers.Number):</span>
            <span class="s3">raise </span><span class="s1">ValueError(error_msg % (scores</span><span class="s3">, </span><span class="s1">type(scores)</span><span class="s3">, </span><span class="s1">scorer))</span>
    <span class="s3">return </span><span class="s1">scores</span>


<span class="s3">def </span><span class="s1">cross_val_predict(</span>
    <span class="s1">estimator</span><span class="s3">,</span>
    <span class="s1">X</span><span class="s3">,</span>
    <span class="s1">y=</span><span class="s3">None,</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">groups=</span><span class="s3">None,</span>
    <span class="s1">cv=</span><span class="s3">None,</span>
    <span class="s1">n_jobs=</span><span class="s3">None,</span>
    <span class="s1">verbose=</span><span class="s5">0</span><span class="s3">,</span>
    <span class="s1">fit_params=</span><span class="s3">None,</span>
    <span class="s1">pre_dispatch=</span><span class="s4">&quot;2*n_jobs&quot;</span><span class="s3">,</span>
    <span class="s1">method=</span><span class="s4">&quot;predict&quot;</span><span class="s3">,</span>
<span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Generate cross-validated estimates for each input data point. 
 
    The data is split according to the cv parameter. Each sample belongs 
    to exactly one test set, and its prediction is computed with an 
    estimator fitted on the corresponding training set. 
 
    Passing these predictions into an evaluation metric may not be a valid 
    way to measure generalization performance. Results can differ from 
    :func:`cross_validate` and :func:`cross_val_score` unless all tests sets 
    have equal size and the metric decomposes over samples. 
 
    Read more in the :ref:`User Guide &lt;cross_validation&gt;`. 
 
    Parameters 
    ---------- 
    estimator : estimator object implementing 'fit' and 'predict' 
        The object to use to fit the data. 
 
    X : array-like of shape (n_samples, n_features) 
        The data to fit. Can be, for example a list, or an array at least 2d. 
 
    y : array-like of shape (n_samples,) or (n_samples, n_outputs), \ 
            default=None 
        The target variable to try to predict in the case of 
        supervised learning. 
 
    groups : array-like of shape (n_samples,), default=None 
        Group labels for the samples used while splitting the dataset into 
        train/test set. Only used in conjunction with a &quot;Group&quot; :term:`cv` 
        instance (e.g., :class:`GroupKFold`). 
 
    cv : int, cross-validation generator or an iterable, default=None 
        Determines the cross-validation splitting strategy. 
        Possible inputs for cv are: 
 
        - None, to use the default 5-fold cross validation, 
        - int, to specify the number of folds in a `(Stratified)KFold`, 
        - :term:`CV splitter`, 
        - An iterable that generates (train, test) splits as arrays of indices. 
 
        For int/None inputs, if the estimator is a classifier and ``y`` is 
        either binary or multiclass, :class:`StratifiedKFold` is used. In all 
        other cases, :class:`KFold` is used. These splitters are instantiated 
        with `shuffle=False` so the splits will be the same across calls. 
 
        Refer :ref:`User Guide &lt;cross_validation&gt;` for the various 
        cross-validation strategies that can be used here. 
 
        .. versionchanged:: 0.22 
            ``cv`` default value if None changed from 3-fold to 5-fold. 
 
    n_jobs : int, default=None 
        Number of jobs to run in parallel. Training the estimator and 
        predicting are parallelized over the cross-validation splits. 
        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context. 
        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;` 
        for more details. 
 
    verbose : int, default=0 
        The verbosity level. 
 
    fit_params : dict, default=None 
        Parameters to pass to the fit method of the estimator. 
 
    pre_dispatch : int or str, default='2*n_jobs' 
        Controls the number of jobs that get dispatched during parallel 
        execution. Reducing this number can be useful to avoid an 
        explosion of memory consumption when more jobs get dispatched 
        than CPUs can process. This parameter can be: 
 
            - None, in which case all the jobs are immediately 
              created and spawned. Use this for lightweight and 
              fast-running jobs, to avoid delays due to on-demand 
              spawning of the jobs 
 
            - An int, giving the exact number of total jobs that are 
              spawned 
 
            - A str, giving an expression as a function of n_jobs, 
              as in '2*n_jobs' 
 
    method : {'predict', 'predict_proba', 'predict_log_proba', \ 
              'decision_function'}, default='predict' 
        The method to be invoked by `estimator`. 
 
    Returns 
    ------- 
    predictions : ndarray 
        This is the result of calling `method`. Shape: 
 
            - When `method` is 'predict' and in special case where `method` is 
              'decision_function' and the target is binary: (n_samples,) 
            - When `method` is one of {'predict_proba', 'predict_log_proba', 
              'decision_function'} (unless special case above): 
              (n_samples, n_classes) 
            - If `estimator` is :term:`multioutput`, an extra dimension 
              'n_outputs' is added to the end of each shape above. 
 
    See Also 
    -------- 
    cross_val_score : Calculate score for each CV split. 
    cross_validate : Calculate one or more scores and timings for each CV 
        split. 
 
    Notes 
    ----- 
    In the case that one or more classes are absent in a training portion, a 
    default score needs to be assigned to all instances for that class if 
    ``method`` produces columns per class, as in {'decision_function', 
    'predict_proba', 'predict_log_proba'}.  For ``predict_proba`` this value is 
    0.  In order to ensure finite output, we approximate negative infinity by 
    the minimum finite float value for the dtype in other cases. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn import datasets, linear_model 
    &gt;&gt;&gt; from sklearn.model_selection import cross_val_predict 
    &gt;&gt;&gt; diabetes = datasets.load_diabetes() 
    &gt;&gt;&gt; X = diabetes.data[:150] 
    &gt;&gt;&gt; y = diabetes.target[:150] 
    &gt;&gt;&gt; lasso = linear_model.Lasso() 
    &gt;&gt;&gt; y_pred = cross_val_predict(lasso, X, y, cv=3) 
    &quot;&quot;&quot;</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups = indexable(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups)</span>

    <span class="s1">cv = check_cv(cv</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">classifier=is_classifier(estimator))</span>
    <span class="s1">splits = list(cv.split(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups))</span>

    <span class="s1">test_indices = np.concatenate([test </span><span class="s3">for </span><span class="s1">_</span><span class="s3">, </span><span class="s1">test </span><span class="s3">in </span><span class="s1">splits])</span>
    <span class="s3">if not </span><span class="s1">_check_is_permutation(test_indices</span><span class="s3">, </span><span class="s1">_num_samples(X)):</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span><span class="s4">&quot;cross_val_predict only works for partitions&quot;</span><span class="s1">)</span>

    <span class="s2"># If classification methods produce multiple columns of output,</span>
    <span class="s2"># we need to manually encode classes to ensure consistent column ordering.</span>
    <span class="s1">encode = (</span>
        <span class="s1">method </span><span class="s3">in </span><span class="s1">[</span><span class="s4">&quot;decision_function&quot;</span><span class="s3">, </span><span class="s4">&quot;predict_proba&quot;</span><span class="s3">, </span><span class="s4">&quot;predict_log_proba&quot;</span><span class="s1">]</span>
        <span class="s3">and </span><span class="s1">y </span><span class="s3">is not None</span>
    <span class="s1">)</span>
    <span class="s3">if </span><span class="s1">encode:</span>
        <span class="s1">y = np.asarray(y)</span>
        <span class="s3">if </span><span class="s1">y.ndim == </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">le = LabelEncoder()</span>
            <span class="s1">y = le.fit_transform(y)</span>
        <span class="s3">elif </span><span class="s1">y.ndim == </span><span class="s5">2</span><span class="s1">:</span>
            <span class="s1">y_enc = np.zeros_like(y</span><span class="s3">, </span><span class="s1">dtype=int)</span>
            <span class="s3">for </span><span class="s1">i_label </span><span class="s3">in </span><span class="s1">range(y.shape[</span><span class="s5">1</span><span class="s1">]):</span>
                <span class="s1">y_enc[:</span><span class="s3">, </span><span class="s1">i_label] = LabelEncoder().fit_transform(y[:</span><span class="s3">, </span><span class="s1">i_label])</span>
            <span class="s1">y = y_enc</span>

    <span class="s2"># We clone the estimator to make sure that all the folds are</span>
    <span class="s2"># independent, and that it is pickle-able.</span>
    <span class="s1">parallel = Parallel(n_jobs=n_jobs</span><span class="s3">, </span><span class="s1">verbose=verbose</span><span class="s3">, </span><span class="s1">pre_dispatch=pre_dispatch)</span>
    <span class="s1">predictions = parallel(</span>
        <span class="s1">delayed(_fit_and_predict)(</span>
            <span class="s1">clone(estimator)</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">train</span><span class="s3">, </span><span class="s1">test</span><span class="s3">, </span><span class="s1">verbose</span><span class="s3">, </span><span class="s1">fit_params</span><span class="s3">, </span><span class="s1">method</span>
        <span class="s1">)</span>
        <span class="s3">for </span><span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">in </span><span class="s1">splits</span>
    <span class="s1">)</span>

    <span class="s1">inv_test_indices = np.empty(len(test_indices)</span><span class="s3">, </span><span class="s1">dtype=int)</span>
    <span class="s1">inv_test_indices[test_indices] = np.arange(len(test_indices))</span>

    <span class="s3">if </span><span class="s1">sp.issparse(predictions[</span><span class="s5">0</span><span class="s1">]):</span>
        <span class="s1">predictions = sp.vstack(predictions</span><span class="s3">, </span><span class="s1">format=predictions[</span><span class="s5">0</span><span class="s1">].format)</span>
    <span class="s3">elif </span><span class="s1">encode </span><span class="s3">and </span><span class="s1">isinstance(predictions[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">list):</span>
        <span class="s2"># `predictions` is a list of method outputs from each fold.</span>
        <span class="s2"># If each of those is also a list, then treat this as a</span>
        <span class="s2"># multioutput-multiclass task. We need to separately concatenate</span>
        <span class="s2"># the method outputs for each label into an `n_labels` long list.</span>
        <span class="s1">n_labels = y.shape[</span><span class="s5">1</span><span class="s1">]</span>
        <span class="s1">concat_pred = []</span>
        <span class="s3">for </span><span class="s1">i_label </span><span class="s3">in </span><span class="s1">range(n_labels):</span>
            <span class="s1">label_preds = np.concatenate([p[i_label] </span><span class="s3">for </span><span class="s1">p </span><span class="s3">in </span><span class="s1">predictions])</span>
            <span class="s1">concat_pred.append(label_preds)</span>
        <span class="s1">predictions = concat_pred</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">predictions = np.concatenate(predictions)</span>

    <span class="s3">if </span><span class="s1">isinstance(predictions</span><span class="s3">, </span><span class="s1">list):</span>
        <span class="s3">return </span><span class="s1">[p[inv_test_indices] </span><span class="s3">for </span><span class="s1">p </span><span class="s3">in </span><span class="s1">predictions]</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">return </span><span class="s1">predictions[inv_test_indices]</span>


<span class="s3">def </span><span class="s1">_fit_and_predict(estimator</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">train</span><span class="s3">, </span><span class="s1">test</span><span class="s3">, </span><span class="s1">verbose</span><span class="s3">, </span><span class="s1">fit_params</span><span class="s3">, </span><span class="s1">method):</span>
    <span class="s0">&quot;&quot;&quot;Fit estimator and predict values for a given dataset split. 
 
    Read more in the :ref:`User Guide &lt;cross_validation&gt;`. 
 
    Parameters 
    ---------- 
    estimator : estimator object implementing 'fit' and 'predict' 
        The object to use to fit the data. 
 
    X : array-like of shape (n_samples, n_features) 
        The data to fit. 
 
        .. versionchanged:: 0.20 
            X is only required to be an object with finite length or shape now 
 
    y : array-like of shape (n_samples,) or (n_samples, n_outputs) or None 
        The target variable to try to predict in the case of 
        supervised learning. 
 
    train : array-like of shape (n_train_samples,) 
        Indices of training samples. 
 
    test : array-like of shape (n_test_samples,) 
        Indices of test samples. 
 
    verbose : int 
        The verbosity level. 
 
    fit_params : dict or None 
        Parameters that will be passed to ``estimator.fit``. 
 
    method : str 
        Invokes the passed method name of the passed estimator. 
 
    Returns 
    ------- 
    predictions : sequence 
        Result of calling 'estimator.method' 
    &quot;&quot;&quot;</span>
    <span class="s2"># Adjust length of sample weights</span>
    <span class="s1">fit_params = fit_params </span><span class="s3">if </span><span class="s1">fit_params </span><span class="s3">is not None else </span><span class="s1">{}</span>
    <span class="s1">fit_params = _check_fit_params(X</span><span class="s3">, </span><span class="s1">fit_params</span><span class="s3">, </span><span class="s1">train)</span>

    <span class="s1">X_train</span><span class="s3">, </span><span class="s1">y_train = _safe_split(estimator</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">train)</span>
    <span class="s1">X_test</span><span class="s3">, </span><span class="s1">_ = _safe_split(estimator</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">test</span><span class="s3">, </span><span class="s1">train)</span>

    <span class="s3">if </span><span class="s1">y_train </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">estimator.fit(X_train</span><span class="s3">, </span><span class="s1">**fit_params)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">estimator.fit(X_train</span><span class="s3">, </span><span class="s1">y_train</span><span class="s3">, </span><span class="s1">**fit_params)</span>
    <span class="s1">func = getattr(estimator</span><span class="s3">, </span><span class="s1">method)</span>
    <span class="s1">predictions = func(X_test)</span>

    <span class="s1">encode = (</span>
        <span class="s1">method </span><span class="s3">in </span><span class="s1">[</span><span class="s4">&quot;decision_function&quot;</span><span class="s3">, </span><span class="s4">&quot;predict_proba&quot;</span><span class="s3">, </span><span class="s4">&quot;predict_log_proba&quot;</span><span class="s1">]</span>
        <span class="s3">and </span><span class="s1">y </span><span class="s3">is not None</span>
    <span class="s1">)</span>

    <span class="s3">if </span><span class="s1">encode:</span>
        <span class="s3">if </span><span class="s1">isinstance(predictions</span><span class="s3">, </span><span class="s1">list):</span>
            <span class="s1">predictions = [</span>
                <span class="s1">_enforce_prediction_order(</span>
                    <span class="s1">estimator.classes_[i_label]</span><span class="s3">,</span>
                    <span class="s1">predictions[i_label]</span><span class="s3">,</span>
                    <span class="s1">n_classes=len(set(y[:</span><span class="s3">, </span><span class="s1">i_label]))</span><span class="s3">,</span>
                    <span class="s1">method=method</span><span class="s3">,</span>
                <span class="s1">)</span>
                <span class="s3">for </span><span class="s1">i_label </span><span class="s3">in </span><span class="s1">range(len(predictions))</span>
            <span class="s1">]</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s2"># A 2D y array should be a binary label indicator matrix</span>
            <span class="s1">n_classes = len(set(y)) </span><span class="s3">if </span><span class="s1">y.ndim == </span><span class="s5">1 </span><span class="s3">else </span><span class="s1">y.shape[</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s1">predictions = _enforce_prediction_order(</span>
                <span class="s1">estimator.classes_</span><span class="s3">, </span><span class="s1">predictions</span><span class="s3">, </span><span class="s1">n_classes</span><span class="s3">, </span><span class="s1">method</span>
            <span class="s1">)</span>
    <span class="s3">return </span><span class="s1">predictions</span>


<span class="s3">def </span><span class="s1">_enforce_prediction_order(classes</span><span class="s3">, </span><span class="s1">predictions</span><span class="s3">, </span><span class="s1">n_classes</span><span class="s3">, </span><span class="s1">method):</span>
    <span class="s0">&quot;&quot;&quot;Ensure that prediction arrays have correct column order 
 
    When doing cross-validation, if one or more classes are 
    not present in the subset of data used for training, 
    then the output prediction array might not have the same 
    columns as other folds. Use the list of class names 
    (assumed to be ints) to enforce the correct column order. 
 
    Note that `classes` is the list of classes in this fold 
    (a subset of the classes in the full training set) 
    and `n_classes` is the number of classes in the full training set. 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">n_classes != len(classes):</span>
        <span class="s1">recommendation = (</span>
            <span class="s4">&quot;To fix this, use a cross-validation &quot;</span>
            <span class="s4">&quot;technique resulting in properly &quot;</span>
            <span class="s4">&quot;stratified folds&quot;</span>
        <span class="s1">)</span>
        <span class="s1">warnings.warn(</span>
            <span class="s4">&quot;Number of classes in training fold ({}) does &quot;</span>
            <span class="s4">&quot;not match total number of classes ({}). &quot;</span>
            <span class="s4">&quot;Results may not be appropriate for your use case. &quot;</span>
            <span class="s4">&quot;{}&quot;</span><span class="s1">.format(len(classes)</span><span class="s3">, </span><span class="s1">n_classes</span><span class="s3">, </span><span class="s1">recommendation)</span><span class="s3">,</span>
            <span class="s1">RuntimeWarning</span><span class="s3">,</span>
        <span class="s1">)</span>
        <span class="s3">if </span><span class="s1">method == </span><span class="s4">&quot;decision_function&quot;</span><span class="s1">:</span>
            <span class="s3">if </span><span class="s1">predictions.ndim == </span><span class="s5">2 </span><span class="s3">and </span><span class="s1">predictions.shape[</span><span class="s5">1</span><span class="s1">] != len(classes):</span>
                <span class="s2"># This handles the case when the shape of predictions</span>
                <span class="s2"># does not match the number of classes used to train</span>
                <span class="s2"># it with. This case is found when sklearn.svm.SVC is</span>
                <span class="s2"># set to `decision_function_shape='ovo'`.</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">&quot;Output shape {} of {} does not match &quot;</span>
                    <span class="s4">&quot;number of classes ({}) in fold. &quot;</span>
                    <span class="s4">&quot;Irregular decision_function outputs &quot;</span>
                    <span class="s4">&quot;are not currently supported by &quot;</span>
                    <span class="s4">&quot;cross_val_predict&quot;</span><span class="s1">.format(predictions.shape</span><span class="s3">, </span><span class="s1">method</span><span class="s3">, </span><span class="s1">len(classes))</span>
                <span class="s1">)</span>
            <span class="s3">if </span><span class="s1">len(classes) &lt;= </span><span class="s5">2</span><span class="s1">:</span>
                <span class="s2"># In this special case, `predictions` contains a 1D array.</span>
                <span class="s3">raise </span><span class="s1">ValueError(</span>
                    <span class="s4">&quot;Only {} class/es in training fold, but {} &quot;</span>
                    <span class="s4">&quot;in overall dataset. This &quot;</span>
                    <span class="s4">&quot;is not supported for decision_function &quot;</span>
                    <span class="s4">&quot;with imbalanced folds. {}&quot;</span><span class="s1">.format(</span>
                        <span class="s1">len(classes)</span><span class="s3">, </span><span class="s1">n_classes</span><span class="s3">, </span><span class="s1">recommendation</span>
                    <span class="s1">)</span>
                <span class="s1">)</span>

        <span class="s1">float_min = np.finfo(predictions.dtype).min</span>
        <span class="s1">default_values = {</span>
            <span class="s4">&quot;decision_function&quot;</span><span class="s1">: float_min</span><span class="s3">,</span>
            <span class="s4">&quot;predict_log_proba&quot;</span><span class="s1">: float_min</span><span class="s3">,</span>
            <span class="s4">&quot;predict_proba&quot;</span><span class="s1">: </span><span class="s5">0</span><span class="s3">,</span>
        <span class="s1">}</span>
        <span class="s1">predictions_for_all_classes = np.full(</span>
            <span class="s1">(_num_samples(predictions)</span><span class="s3">, </span><span class="s1">n_classes)</span><span class="s3">,</span>
            <span class="s1">default_values[method]</span><span class="s3">,</span>
            <span class="s1">dtype=predictions.dtype</span><span class="s3">,</span>
        <span class="s1">)</span>
        <span class="s1">predictions_for_all_classes[:</span><span class="s3">, </span><span class="s1">classes] = predictions</span>
        <span class="s1">predictions = predictions_for_all_classes</span>
    <span class="s3">return </span><span class="s1">predictions</span>


<span class="s3">def </span><span class="s1">_check_is_permutation(indices</span><span class="s3">, </span><span class="s1">n_samples):</span>
    <span class="s0">&quot;&quot;&quot;Check whether indices is a reordering of the array np.arange(n_samples) 
 
    Parameters 
    ---------- 
    indices : ndarray 
        int array to test 
    n_samples : int 
        number of expected elements 
 
    Returns 
    ------- 
    is_partition : bool 
        True iff sorted(indices) is np.arange(n) 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">len(indices) != n_samples:</span>
        <span class="s3">return False</span>
    <span class="s1">hit = np.zeros(n_samples</span><span class="s3">, </span><span class="s1">dtype=bool)</span>
    <span class="s1">hit[indices] = </span><span class="s3">True</span>
    <span class="s3">if not </span><span class="s1">np.all(hit):</span>
        <span class="s3">return False</span>
    <span class="s3">return True</span>


<span class="s1">@validate_params(</span>
    <span class="s1">{</span>
        <span class="s4">&quot;estimator&quot;</span><span class="s1">: [HasMethods(</span><span class="s4">&quot;fit&quot;</span><span class="s1">)]</span><span class="s3">,</span>
        <span class="s4">&quot;X&quot;</span><span class="s1">: [</span><span class="s4">&quot;array-like&quot;</span><span class="s3">, </span><span class="s4">&quot;sparse matrix&quot;</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;y&quot;</span><span class="s1">: [</span><span class="s4">&quot;array-like&quot;</span><span class="s3">, None</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;groups&quot;</span><span class="s1">: [</span><span class="s4">&quot;array-like&quot;</span><span class="s3">, None</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;cv&quot;</span><span class="s1">: [</span><span class="s4">&quot;cv_object&quot;</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;n_permutations&quot;</span><span class="s1">: [Interval(Integral</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, None, </span><span class="s1">closed=</span><span class="s4">&quot;left&quot;</span><span class="s1">)]</span><span class="s3">,</span>
        <span class="s4">&quot;n_jobs&quot;</span><span class="s1">: [Integral</span><span class="s3">, None</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;random_state&quot;</span><span class="s1">: [</span><span class="s4">&quot;random_state&quot;</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;verbose&quot;</span><span class="s1">: [</span><span class="s4">&quot;verbose&quot;</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;scoring&quot;</span><span class="s1">: [StrOptions(set(get_scorer_names()))</span><span class="s3">, </span><span class="s1">callable</span><span class="s3">, None</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;fit_params&quot;</span><span class="s1">: [dict</span><span class="s3">, None</span><span class="s1">]</span><span class="s3">,</span>
    <span class="s1">}</span><span class="s3">,</span>
    <span class="s1">prefer_skip_nested_validation=</span><span class="s3">False,  </span><span class="s2"># estimator is not validated yet</span>
<span class="s1">)</span>
<span class="s3">def </span><span class="s1">permutation_test_score(</span>
    <span class="s1">estimator</span><span class="s3">,</span>
    <span class="s1">X</span><span class="s3">,</span>
    <span class="s1">y</span><span class="s3">,</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">groups=</span><span class="s3">None,</span>
    <span class="s1">cv=</span><span class="s3">None,</span>
    <span class="s1">n_permutations=</span><span class="s5">100</span><span class="s3">,</span>
    <span class="s1">n_jobs=</span><span class="s3">None,</span>
    <span class="s1">random_state=</span><span class="s5">0</span><span class="s3">,</span>
    <span class="s1">verbose=</span><span class="s5">0</span><span class="s3">,</span>
    <span class="s1">scoring=</span><span class="s3">None,</span>
    <span class="s1">fit_params=</span><span class="s3">None,</span>
<span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Evaluate the significance of a cross-validated score with permutations. 
 
    Permutes targets to generate 'randomized data' and compute the empirical 
    p-value against the null hypothesis that features and targets are 
    independent. 
 
    The p-value represents the fraction of randomized data sets where the 
    estimator performed as well or better than in the original data. A small 
    p-value suggests that there is a real dependency between features and 
    targets which has been used by the estimator to give good predictions. 
    A large p-value may be due to lack of real dependency between features 
    and targets or the estimator was not able to use the dependency to 
    give good predictions. 
 
    Read more in the :ref:`User Guide &lt;permutation_test_score&gt;`. 
 
    Parameters 
    ---------- 
    estimator : estimator object implementing 'fit' 
        The object to use to fit the data. 
 
    X : array-like of shape at least 2D 
        The data to fit. 
 
    y : array-like of shape (n_samples,) or (n_samples, n_outputs) or None 
        The target variable to try to predict in the case of 
        supervised learning. 
 
    groups : array-like of shape (n_samples,), default=None 
        Labels to constrain permutation within groups, i.e. ``y`` values 
        are permuted among samples with the same group identifier. 
        When not specified, ``y`` values are permuted among all samples. 
 
        When a grouped cross-validator is used, the group labels are 
        also passed on to the ``split`` method of the cross-validator. The 
        cross-validator uses them for grouping the samples  while splitting 
        the dataset into train/test set. 
 
    cv : int, cross-validation generator or an iterable, default=None 
        Determines the cross-validation splitting strategy. 
        Possible inputs for cv are: 
 
        - `None`, to use the default 5-fold cross validation, 
        - int, to specify the number of folds in a `(Stratified)KFold`, 
        - :term:`CV splitter`, 
        - An iterable yielding (train, test) splits as arrays of indices. 
 
        For `int`/`None` inputs, if the estimator is a classifier and `y` is 
        either binary or multiclass, :class:`StratifiedKFold` is used. In all 
        other cases, :class:`KFold` is used. These splitters are instantiated 
        with `shuffle=False` so the splits will be the same across calls. 
 
        Refer :ref:`User Guide &lt;cross_validation&gt;` for the various 
        cross-validation strategies that can be used here. 
 
        .. versionchanged:: 0.22 
            `cv` default value if `None` changed from 3-fold to 5-fold. 
 
    n_permutations : int, default=100 
        Number of times to permute ``y``. 
 
    n_jobs : int, default=None 
        Number of jobs to run in parallel. Training the estimator and computing 
        the cross-validated score are parallelized over the permutations. 
        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context. 
        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;` 
        for more details. 
 
    random_state : int, RandomState instance or None, default=0 
        Pass an int for reproducible output for permutation of 
        ``y`` values among samples. See :term:`Glossary &lt;random_state&gt;`. 
 
    verbose : int, default=0 
        The verbosity level. 
 
    scoring : str or callable, default=None 
        A single str (see :ref:`scoring_parameter`) or a callable 
        (see :ref:`scoring`) to evaluate the predictions on the test set. 
 
        If `None` the estimator's score method is used. 
 
    fit_params : dict, default=None 
        Parameters to pass to the fit method of the estimator. 
 
        .. versionadded:: 0.24 
 
    Returns 
    ------- 
    score : float 
        The true score without permuting targets. 
 
    permutation_scores : array of shape (n_permutations,) 
        The scores obtained for each permutations. 
 
    pvalue : float 
        The p-value, which approximates the probability that the score would 
        be obtained by chance. This is calculated as: 
 
        `(C + 1) / (n_permutations + 1)` 
 
        Where C is the number of permutations whose score &gt;= the true score. 
 
        The best possible p-value is 1/(n_permutations + 1), the worst is 1.0. 
 
    Notes 
    ----- 
    This function implements Test 1 in: 
 
        Ojala and Garriga. `Permutation Tests for Studying Classifier 
        Performance 
        &lt;http://www.jmlr.org/papers/volume11/ojala10a/ojala10a.pdf&gt;`_. The 
        Journal of Machine Learning Research (2010) vol. 11 
    &quot;&quot;&quot;</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups = indexable(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups)</span>

    <span class="s1">cv = check_cv(cv</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">classifier=is_classifier(estimator))</span>
    <span class="s1">scorer = check_scoring(estimator</span><span class="s3">, </span><span class="s1">scoring=scoring)</span>
    <span class="s1">random_state = check_random_state(random_state)</span>

    <span class="s2"># We clone the estimator to make sure that all the folds are</span>
    <span class="s2"># independent, and that it is pickle-able.</span>
    <span class="s1">score = _permutation_test_score(</span>
        <span class="s1">clone(estimator)</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">, </span><span class="s1">cv</span><span class="s3">, </span><span class="s1">scorer</span><span class="s3">, </span><span class="s1">fit_params=fit_params</span>
    <span class="s1">)</span>
    <span class="s1">permutation_scores = Parallel(n_jobs=n_jobs</span><span class="s3">, </span><span class="s1">verbose=verbose)(</span>
        <span class="s1">delayed(_permutation_test_score)(</span>
            <span class="s1">clone(estimator)</span><span class="s3">,</span>
            <span class="s1">X</span><span class="s3">,</span>
            <span class="s1">_shuffle(y</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">, </span><span class="s1">random_state)</span><span class="s3">,</span>
            <span class="s1">groups</span><span class="s3">,</span>
            <span class="s1">cv</span><span class="s3">,</span>
            <span class="s1">scorer</span><span class="s3">,</span>
            <span class="s1">fit_params=fit_params</span><span class="s3">,</span>
        <span class="s1">)</span>
        <span class="s3">for </span><span class="s1">_ </span><span class="s3">in </span><span class="s1">range(n_permutations)</span>
    <span class="s1">)</span>
    <span class="s1">permutation_scores = np.array(permutation_scores)</span>
    <span class="s1">pvalue = (np.sum(permutation_scores &gt;= score) + </span><span class="s5">1.0</span><span class="s1">) / (n_permutations + </span><span class="s5">1</span><span class="s1">)</span>
    <span class="s3">return </span><span class="s1">score</span><span class="s3">, </span><span class="s1">permutation_scores</span><span class="s3">, </span><span class="s1">pvalue</span>


<span class="s3">def </span><span class="s1">_permutation_test_score(estimator</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">, </span><span class="s1">cv</span><span class="s3">, </span><span class="s1">scorer</span><span class="s3">, </span><span class="s1">fit_params):</span>
    <span class="s0">&quot;&quot;&quot;Auxiliary function for permutation_test_score&quot;&quot;&quot;</span>
    <span class="s2"># Adjust length of sample weights</span>
    <span class="s1">fit_params = fit_params </span><span class="s3">if </span><span class="s1">fit_params </span><span class="s3">is not None else </span><span class="s1">{}</span>
    <span class="s1">avg_score = []</span>
    <span class="s3">for </span><span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">in </span><span class="s1">cv.split(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups):</span>
        <span class="s1">X_train</span><span class="s3">, </span><span class="s1">y_train = _safe_split(estimator</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">train)</span>
        <span class="s1">X_test</span><span class="s3">, </span><span class="s1">y_test = _safe_split(estimator</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">test</span><span class="s3">, </span><span class="s1">train)</span>
        <span class="s1">fit_params = _check_fit_params(X</span><span class="s3">, </span><span class="s1">fit_params</span><span class="s3">, </span><span class="s1">train)</span>
        <span class="s1">estimator.fit(X_train</span><span class="s3">, </span><span class="s1">y_train</span><span class="s3">, </span><span class="s1">**fit_params)</span>
        <span class="s1">avg_score.append(scorer(estimator</span><span class="s3">, </span><span class="s1">X_test</span><span class="s3">, </span><span class="s1">y_test))</span>
    <span class="s3">return </span><span class="s1">np.mean(avg_score)</span>


<span class="s3">def </span><span class="s1">_shuffle(y</span><span class="s3">, </span><span class="s1">groups</span><span class="s3">, </span><span class="s1">random_state):</span>
    <span class="s0">&quot;&quot;&quot;Return a shuffled copy of y eventually shuffle among same groups.&quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">groups </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">indices = random_state.permutation(len(y))</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">indices = np.arange(len(groups))</span>
        <span class="s3">for </span><span class="s1">group </span><span class="s3">in </span><span class="s1">np.unique(groups):</span>
            <span class="s1">this_mask = groups == group</span>
            <span class="s1">indices[this_mask] = random_state.permutation(indices[this_mask])</span>
    <span class="s3">return </span><span class="s1">_safe_indexing(y</span><span class="s3">, </span><span class="s1">indices)</span>


<span class="s1">@validate_params(</span>
    <span class="s1">{</span>
        <span class="s4">&quot;estimator&quot;</span><span class="s1">: [HasMethods([</span><span class="s4">&quot;fit&quot;</span><span class="s1">])]</span><span class="s3">,</span>
        <span class="s4">&quot;X&quot;</span><span class="s1">: [</span><span class="s4">&quot;array-like&quot;</span><span class="s3">, </span><span class="s4">&quot;sparse matrix&quot;</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;y&quot;</span><span class="s1">: [</span><span class="s4">&quot;array-like&quot;</span><span class="s3">, None</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;groups&quot;</span><span class="s1">: [</span><span class="s4">&quot;array-like&quot;</span><span class="s3">, None</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;train_sizes&quot;</span><span class="s1">: [</span><span class="s4">&quot;array-like&quot;</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;cv&quot;</span><span class="s1">: [</span><span class="s4">&quot;cv_object&quot;</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;scoring&quot;</span><span class="s1">: [StrOptions(set(get_scorer_names()))</span><span class="s3">, </span><span class="s1">callable</span><span class="s3">, None</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;exploit_incremental_learning&quot;</span><span class="s1">: [</span><span class="s4">&quot;boolean&quot;</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;n_jobs&quot;</span><span class="s1">: [Integral</span><span class="s3">, None</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;pre_dispatch&quot;</span><span class="s1">: [Integral</span><span class="s3">, </span><span class="s1">str]</span><span class="s3">,</span>
        <span class="s4">&quot;verbose&quot;</span><span class="s1">: [</span><span class="s4">&quot;verbose&quot;</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;shuffle&quot;</span><span class="s1">: [</span><span class="s4">&quot;boolean&quot;</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;random_state&quot;</span><span class="s1">: [</span><span class="s4">&quot;random_state&quot;</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;error_score&quot;</span><span class="s1">: [StrOptions({</span><span class="s4">&quot;raise&quot;</span><span class="s1">})</span><span class="s3">, </span><span class="s1">Real]</span><span class="s3">,</span>
        <span class="s4">&quot;return_times&quot;</span><span class="s1">: [</span><span class="s4">&quot;boolean&quot;</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;fit_params&quot;</span><span class="s1">: [dict</span><span class="s3">, None</span><span class="s1">]</span><span class="s3">,</span>
    <span class="s1">}</span><span class="s3">,</span>
    <span class="s1">prefer_skip_nested_validation=</span><span class="s3">False,  </span><span class="s2"># estimator is not validated yet</span>
<span class="s1">)</span>
<span class="s3">def </span><span class="s1">learning_curve(</span>
    <span class="s1">estimator</span><span class="s3">,</span>
    <span class="s1">X</span><span class="s3">,</span>
    <span class="s1">y</span><span class="s3">,</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">groups=</span><span class="s3">None,</span>
    <span class="s1">train_sizes=np.linspace(</span><span class="s5">0.1</span><span class="s3">, </span><span class="s5">1.0</span><span class="s3">, </span><span class="s5">5</span><span class="s1">)</span><span class="s3">,</span>
    <span class="s1">cv=</span><span class="s3">None,</span>
    <span class="s1">scoring=</span><span class="s3">None,</span>
    <span class="s1">exploit_incremental_learning=</span><span class="s3">False,</span>
    <span class="s1">n_jobs=</span><span class="s3">None,</span>
    <span class="s1">pre_dispatch=</span><span class="s4">&quot;all&quot;</span><span class="s3">,</span>
    <span class="s1">verbose=</span><span class="s5">0</span><span class="s3">,</span>
    <span class="s1">shuffle=</span><span class="s3">False,</span>
    <span class="s1">random_state=</span><span class="s3">None,</span>
    <span class="s1">error_score=np.nan</span><span class="s3">,</span>
    <span class="s1">return_times=</span><span class="s3">False,</span>
    <span class="s1">fit_params=</span><span class="s3">None,</span>
<span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Learning curve. 
 
    Determines cross-validated training and test scores for different training 
    set sizes. 
 
    A cross-validation generator splits the whole dataset k times in training 
    and test data. Subsets of the training set with varying sizes will be used 
    to train the estimator and a score for each training subset size and the 
    test set will be computed. Afterwards, the scores will be averaged over 
    all k runs for each training subset size. 
 
    Read more in the :ref:`User Guide &lt;learning_curve&gt;`. 
 
    Parameters 
    ---------- 
    estimator : object type that implements the &quot;fit&quot; method 
        An object of that type which is cloned for each validation. It must 
        also implement &quot;predict&quot; unless `scoring` is a callable that doesn't 
        rely on &quot;predict&quot; to compute a score. 
 
    X : {array-like, sparse matrix} of shape (n_samples, n_features) 
        Training vector, where `n_samples` is the number of samples and 
        `n_features` is the number of features. 
 
    y : array-like of shape (n_samples,) or (n_samples, n_outputs) or None 
        Target relative to X for classification or regression; 
        None for unsupervised learning. 
 
    groups : array-like of shape (n_samples,), default=None 
        Group labels for the samples used while splitting the dataset into 
        train/test set. Only used in conjunction with a &quot;Group&quot; :term:`cv` 
        instance (e.g., :class:`GroupKFold`). 
 
    train_sizes : array-like of shape (n_ticks,), \ 
            default=np.linspace(0.1, 1.0, 5) 
        Relative or absolute numbers of training examples that will be used to 
        generate the learning curve. If the dtype is float, it is regarded as a 
        fraction of the maximum size of the training set (that is determined 
        by the selected validation method), i.e. it has to be within (0, 1]. 
        Otherwise it is interpreted as absolute sizes of the training sets. 
        Note that for classification the number of samples usually have to 
        be big enough to contain at least one sample from each class. 
 
    cv : int, cross-validation generator or an iterable, default=None 
        Determines the cross-validation splitting strategy. 
        Possible inputs for cv are: 
 
        - None, to use the default 5-fold cross validation, 
        - int, to specify the number of folds in a `(Stratified)KFold`, 
        - :term:`CV splitter`, 
        - An iterable yielding (train, test) splits as arrays of indices. 
 
        For int/None inputs, if the estimator is a classifier and ``y`` is 
        either binary or multiclass, :class:`StratifiedKFold` is used. In all 
        other cases, :class:`KFold` is used. These splitters are instantiated 
        with `shuffle=False` so the splits will be the same across calls. 
 
        Refer :ref:`User Guide &lt;cross_validation&gt;` for the various 
        cross-validation strategies that can be used here. 
 
        .. versionchanged:: 0.22 
            ``cv`` default value if None changed from 3-fold to 5-fold. 
 
    scoring : str or callable, default=None 
        A str (see model evaluation documentation) or 
        a scorer callable object / function with signature 
        ``scorer(estimator, X, y)``. 
 
    exploit_incremental_learning : bool, default=False 
        If the estimator supports incremental learning, this will be 
        used to speed up fitting for different training set sizes. 
 
    n_jobs : int, default=None 
        Number of jobs to run in parallel. Training the estimator and computing 
        the score are parallelized over the different training and test sets. 
        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context. 
        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;` 
        for more details. 
 
    pre_dispatch : int or str, default='all' 
        Number of predispatched jobs for parallel execution (default is 
        all). The option can reduce the allocated memory. The str can 
        be an expression like '2*n_jobs'. 
 
    verbose : int, default=0 
        Controls the verbosity: the higher, the more messages. 
 
    shuffle : bool, default=False 
        Whether to shuffle training data before taking prefixes of it 
        based on``train_sizes``. 
 
    random_state : int, RandomState instance or None, default=None 
        Used when ``shuffle`` is True. Pass an int for reproducible 
        output across multiple function calls. 
        See :term:`Glossary &lt;random_state&gt;`. 
 
    error_score : 'raise' or numeric, default=np.nan 
        Value to assign to the score if an error occurs in estimator fitting. 
        If set to 'raise', the error is raised. 
        If a numeric value is given, FitFailedWarning is raised. 
 
        .. versionadded:: 0.20 
 
    return_times : bool, default=False 
        Whether to return the fit and score times. 
 
    fit_params : dict, default=None 
        Parameters to pass to the fit method of the estimator. 
 
        .. versionadded:: 0.24 
 
    Returns 
    ------- 
    train_sizes_abs : array of shape (n_unique_ticks,) 
        Numbers of training examples that has been used to generate the 
        learning curve. Note that the number of ticks might be less 
        than n_ticks because duplicate entries will be removed. 
 
    train_scores : array of shape (n_ticks, n_cv_folds) 
        Scores on training sets. 
 
    test_scores : array of shape (n_ticks, n_cv_folds) 
        Scores on test set. 
 
    fit_times : array of shape (n_ticks, n_cv_folds) 
        Times spent for fitting in seconds. Only present if ``return_times`` 
        is True. 
 
    score_times : array of shape (n_ticks, n_cv_folds) 
        Times spent for scoring in seconds. Only present if ``return_times`` 
        is True. 
 
    Examples 
    -------- 
    &gt;&gt;&gt; from sklearn.datasets import make_classification 
    &gt;&gt;&gt; from sklearn.tree import DecisionTreeClassifier 
    &gt;&gt;&gt; from sklearn.model_selection import learning_curve 
    &gt;&gt;&gt; X, y = make_classification(n_samples=100, n_features=10, random_state=42) 
    &gt;&gt;&gt; tree = DecisionTreeClassifier(max_depth=4, random_state=42) 
    &gt;&gt;&gt; train_size_abs, train_scores, test_scores = learning_curve( 
    ...     tree, X, y, train_sizes=[0.3, 0.6, 0.9] 
    ... ) 
    &gt;&gt;&gt; for train_size, cv_train_scores, cv_test_scores in zip( 
    ...     train_size_abs, train_scores, test_scores 
    ... ): 
    ...     print(f&quot;{train_size} samples were used to train the model&quot;) 
    ...     print(f&quot;The average train accuracy is {cv_train_scores.mean():.2f}&quot;) 
    ...     print(f&quot;The average test accuracy is {cv_test_scores.mean():.2f}&quot;) 
    24 samples were used to train the model 
    The average train accuracy is 1.00 
    The average test accuracy is 0.85 
    48 samples were used to train the model 
    The average train accuracy is 1.00 
    The average test accuracy is 0.90 
    72 samples were used to train the model 
    The average train accuracy is 1.00 
    The average test accuracy is 0.93 
    &quot;&quot;&quot;</span>
    <span class="s3">if </span><span class="s1">exploit_incremental_learning </span><span class="s3">and not </span><span class="s1">hasattr(estimator</span><span class="s3">, </span><span class="s4">&quot;partial_fit&quot;</span><span class="s1">):</span>
        <span class="s3">raise </span><span class="s1">ValueError(</span>
            <span class="s4">&quot;An estimator must support the partial_fit interface &quot;</span>
            <span class="s4">&quot;to exploit incremental learning&quot;</span>
        <span class="s1">)</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups = indexable(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups)</span>

    <span class="s1">cv = check_cv(cv</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">classifier=is_classifier(estimator))</span>
    <span class="s2"># Store it as list as we will be iterating over the list multiple times</span>
    <span class="s1">cv_iter = list(cv.split(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups))</span>

    <span class="s1">scorer = check_scoring(estimator</span><span class="s3">, </span><span class="s1">scoring=scoring)</span>

    <span class="s1">n_max_training_samples = len(cv_iter[</span><span class="s5">0</span><span class="s1">][</span><span class="s5">0</span><span class="s1">])</span>
    <span class="s2"># Because the lengths of folds can be significantly different, it is</span>
    <span class="s2"># not guaranteed that we use all of the available training data when we</span>
    <span class="s2"># use the first 'n_max_training_samples' samples.</span>
    <span class="s1">train_sizes_abs = _translate_train_sizes(train_sizes</span><span class="s3">, </span><span class="s1">n_max_training_samples)</span>
    <span class="s1">n_unique_ticks = train_sizes_abs.shape[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s3">if </span><span class="s1">verbose &gt; </span><span class="s5">0</span><span class="s1">:</span>
        <span class="s1">print(</span><span class="s4">&quot;[learning_curve] Training set sizes: &quot; </span><span class="s1">+ str(train_sizes_abs))</span>

    <span class="s1">parallel = Parallel(n_jobs=n_jobs</span><span class="s3">, </span><span class="s1">pre_dispatch=pre_dispatch</span><span class="s3">, </span><span class="s1">verbose=verbose)</span>

    <span class="s3">if </span><span class="s1">shuffle:</span>
        <span class="s1">rng = check_random_state(random_state)</span>
        <span class="s1">cv_iter = ((rng.permutation(train)</span><span class="s3">, </span><span class="s1">test) </span><span class="s3">for </span><span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">in </span><span class="s1">cv_iter)</span>

    <span class="s3">if </span><span class="s1">exploit_incremental_learning:</span>
        <span class="s1">classes = np.unique(y) </span><span class="s3">if </span><span class="s1">is_classifier(estimator) </span><span class="s3">else None</span>
        <span class="s1">out = parallel(</span>
            <span class="s1">delayed(_incremental_fit_estimator)(</span>
                <span class="s1">clone(estimator)</span><span class="s3">,</span>
                <span class="s1">X</span><span class="s3">,</span>
                <span class="s1">y</span><span class="s3">,</span>
                <span class="s1">classes</span><span class="s3">,</span>
                <span class="s1">train</span><span class="s3">,</span>
                <span class="s1">test</span><span class="s3">,</span>
                <span class="s1">train_sizes_abs</span><span class="s3">,</span>
                <span class="s1">scorer</span><span class="s3">,</span>
                <span class="s1">verbose</span><span class="s3">,</span>
                <span class="s1">return_times</span><span class="s3">,</span>
                <span class="s1">error_score=error_score</span><span class="s3">,</span>
                <span class="s1">fit_params=fit_params</span><span class="s3">,</span>
            <span class="s1">)</span>
            <span class="s3">for </span><span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">in </span><span class="s1">cv_iter</span>
        <span class="s1">)</span>
        <span class="s1">out = np.asarray(out).transpose((</span><span class="s5">2</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s5">0</span><span class="s1">))</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">train_test_proportions = []</span>
        <span class="s3">for </span><span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">in </span><span class="s1">cv_iter:</span>
            <span class="s3">for </span><span class="s1">n_train_samples </span><span class="s3">in </span><span class="s1">train_sizes_abs:</span>
                <span class="s1">train_test_proportions.append((train[:n_train_samples]</span><span class="s3">, </span><span class="s1">test))</span>

        <span class="s1">results = parallel(</span>
            <span class="s1">delayed(_fit_and_score)(</span>
                <span class="s1">clone(estimator)</span><span class="s3">,</span>
                <span class="s1">X</span><span class="s3">,</span>
                <span class="s1">y</span><span class="s3">,</span>
                <span class="s1">scorer</span><span class="s3">,</span>
                <span class="s1">train</span><span class="s3">,</span>
                <span class="s1">test</span><span class="s3">,</span>
                <span class="s1">verbose</span><span class="s3">,</span>
                <span class="s1">parameters=</span><span class="s3">None,</span>
                <span class="s1">fit_params=fit_params</span><span class="s3">,</span>
                <span class="s1">return_train_score=</span><span class="s3">True,</span>
                <span class="s1">error_score=error_score</span><span class="s3">,</span>
                <span class="s1">return_times=return_times</span><span class="s3">,</span>
            <span class="s1">)</span>
            <span class="s3">for </span><span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">in </span><span class="s1">train_test_proportions</span>
        <span class="s1">)</span>
        <span class="s1">results = _aggregate_score_dicts(results)</span>
        <span class="s1">train_scores = results[</span><span class="s4">&quot;train_scores&quot;</span><span class="s1">].reshape(-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">n_unique_ticks).T</span>
        <span class="s1">test_scores = results[</span><span class="s4">&quot;test_scores&quot;</span><span class="s1">].reshape(-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">n_unique_ticks).T</span>
        <span class="s1">out = [train_scores</span><span class="s3">, </span><span class="s1">test_scores]</span>

        <span class="s3">if </span><span class="s1">return_times:</span>
            <span class="s1">fit_times = results[</span><span class="s4">&quot;fit_time&quot;</span><span class="s1">].reshape(-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">n_unique_ticks).T</span>
            <span class="s1">score_times = results[</span><span class="s4">&quot;score_time&quot;</span><span class="s1">].reshape(-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">n_unique_ticks).T</span>
            <span class="s1">out.extend([fit_times</span><span class="s3">, </span><span class="s1">score_times])</span>

    <span class="s1">ret = train_sizes_abs</span><span class="s3">, </span><span class="s1">out[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">out[</span><span class="s5">1</span><span class="s1">]</span>

    <span class="s3">if </span><span class="s1">return_times:</span>
        <span class="s1">ret = ret + (out[</span><span class="s5">2</span><span class="s1">]</span><span class="s3">, </span><span class="s1">out[</span><span class="s5">3</span><span class="s1">])</span>

    <span class="s3">return </span><span class="s1">ret</span>


<span class="s3">def </span><span class="s1">_translate_train_sizes(train_sizes</span><span class="s3">, </span><span class="s1">n_max_training_samples):</span>
    <span class="s0">&quot;&quot;&quot;Determine absolute sizes of training subsets and validate 'train_sizes'. 
 
    Examples: 
        _translate_train_sizes([0.5, 1.0], 10) -&gt; [5, 10] 
        _translate_train_sizes([5, 10], 10) -&gt; [5, 10] 
 
    Parameters 
    ---------- 
    train_sizes : array-like of shape (n_ticks,) 
        Numbers of training examples that will be used to generate the 
        learning curve. If the dtype is float, it is regarded as a 
        fraction of 'n_max_training_samples', i.e. it has to be within (0, 1]. 
 
    n_max_training_samples : int 
        Maximum number of training samples (upper bound of 'train_sizes'). 
 
    Returns 
    ------- 
    train_sizes_abs : array of shape (n_unique_ticks,) 
        Numbers of training examples that will be used to generate the 
        learning curve. Note that the number of ticks might be less 
        than n_ticks because duplicate entries will be removed. 
    &quot;&quot;&quot;</span>
    <span class="s1">train_sizes_abs = np.asarray(train_sizes)</span>
    <span class="s1">n_ticks = train_sizes_abs.shape[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">n_min_required_samples = np.min(train_sizes_abs)</span>
    <span class="s1">n_max_required_samples = np.max(train_sizes_abs)</span>
    <span class="s3">if </span><span class="s1">np.issubdtype(train_sizes_abs.dtype</span><span class="s3">, </span><span class="s1">np.floating):</span>
        <span class="s3">if </span><span class="s1">n_min_required_samples &lt;= </span><span class="s5">0.0 </span><span class="s3">or </span><span class="s1">n_max_required_samples &gt; </span><span class="s5">1.0</span><span class="s1">:</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;train_sizes has been interpreted as fractions &quot;</span>
                <span class="s4">&quot;of the maximum number of training samples and &quot;</span>
                <span class="s4">&quot;must be within (0, 1], but is within [%f, %f].&quot;</span>
                <span class="s1">% (n_min_required_samples</span><span class="s3">, </span><span class="s1">n_max_required_samples)</span>
            <span class="s1">)</span>
        <span class="s1">train_sizes_abs = (train_sizes_abs * n_max_training_samples).astype(</span>
            <span class="s1">dtype=int</span><span class="s3">, </span><span class="s1">copy=</span><span class="s3">False</span>
        <span class="s1">)</span>
        <span class="s1">train_sizes_abs = np.clip(train_sizes_abs</span><span class="s3">, </span><span class="s5">1</span><span class="s3">, </span><span class="s1">n_max_training_samples)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s3">if </span><span class="s1">(</span>
            <span class="s1">n_min_required_samples &lt;= </span><span class="s5">0</span>
            <span class="s3">or </span><span class="s1">n_max_required_samples &gt; n_max_training_samples</span>
        <span class="s1">):</span>
            <span class="s3">raise </span><span class="s1">ValueError(</span>
                <span class="s4">&quot;train_sizes has been interpreted as absolute &quot;</span>
                <span class="s4">&quot;numbers of training samples and must be within &quot;</span>
                <span class="s4">&quot;(0, %d], but is within [%d, %d].&quot;</span>
                <span class="s1">% (</span>
                    <span class="s1">n_max_training_samples</span><span class="s3">,</span>
                    <span class="s1">n_min_required_samples</span><span class="s3">,</span>
                    <span class="s1">n_max_required_samples</span><span class="s3">,</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

    <span class="s1">train_sizes_abs = np.unique(train_sizes_abs)</span>
    <span class="s3">if </span><span class="s1">n_ticks &gt; train_sizes_abs.shape[</span><span class="s5">0</span><span class="s1">]:</span>
        <span class="s1">warnings.warn(</span>
            <span class="s4">&quot;Removed duplicate entries from 'train_sizes'. Number &quot;</span>
            <span class="s4">&quot;of ticks will be less than the size of &quot;</span>
            <span class="s4">&quot;'train_sizes': %d instead of %d.&quot; </span><span class="s1">% (train_sizes_abs.shape[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">, </span><span class="s1">n_ticks)</span><span class="s3">,</span>
            <span class="s1">RuntimeWarning</span><span class="s3">,</span>
        <span class="s1">)</span>

    <span class="s3">return </span><span class="s1">train_sizes_abs</span>


<span class="s3">def </span><span class="s1">_incremental_fit_estimator(</span>
    <span class="s1">estimator</span><span class="s3">,</span>
    <span class="s1">X</span><span class="s3">,</span>
    <span class="s1">y</span><span class="s3">,</span>
    <span class="s1">classes</span><span class="s3">,</span>
    <span class="s1">train</span><span class="s3">,</span>
    <span class="s1">test</span><span class="s3">,</span>
    <span class="s1">train_sizes</span><span class="s3">,</span>
    <span class="s1">scorer</span><span class="s3">,</span>
    <span class="s1">verbose</span><span class="s3">,</span>
    <span class="s1">return_times</span><span class="s3">,</span>
    <span class="s1">error_score</span><span class="s3">,</span>
    <span class="s1">fit_params</span><span class="s3">,</span>
<span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Train estimator on training subsets incrementally and compute scores.&quot;&quot;&quot;</span>
    <span class="s1">train_scores</span><span class="s3">, </span><span class="s1">test_scores</span><span class="s3">, </span><span class="s1">fit_times</span><span class="s3">, </span><span class="s1">score_times = []</span><span class="s3">, </span><span class="s1">[]</span><span class="s3">, </span><span class="s1">[]</span><span class="s3">, </span><span class="s1">[]</span>
    <span class="s1">partitions = zip(train_sizes</span><span class="s3">, </span><span class="s1">np.split(train</span><span class="s3">, </span><span class="s1">train_sizes)[:-</span><span class="s5">1</span><span class="s1">])</span>
    <span class="s3">if </span><span class="s1">fit_params </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">fit_params = {}</span>
    <span class="s3">if </span><span class="s1">classes </span><span class="s3">is None</span><span class="s1">:</span>
        <span class="s1">partial_fit_func = partial(estimator.partial_fit</span><span class="s3">, </span><span class="s1">**fit_params)</span>
    <span class="s3">else</span><span class="s1">:</span>
        <span class="s1">partial_fit_func = partial(estimator.partial_fit</span><span class="s3">, </span><span class="s1">classes=classes</span><span class="s3">, </span><span class="s1">**fit_params)</span>

    <span class="s3">for </span><span class="s1">n_train_samples</span><span class="s3">, </span><span class="s1">partial_train </span><span class="s3">in </span><span class="s1">partitions:</span>
        <span class="s1">train_subset = train[:n_train_samples]</span>
        <span class="s1">X_train</span><span class="s3">, </span><span class="s1">y_train = _safe_split(estimator</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">train_subset)</span>
        <span class="s1">X_partial_train</span><span class="s3">, </span><span class="s1">y_partial_train = _safe_split(estimator</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">partial_train)</span>
        <span class="s1">X_test</span><span class="s3">, </span><span class="s1">y_test = _safe_split(estimator</span><span class="s3">, </span><span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">test</span><span class="s3">, </span><span class="s1">train_subset)</span>
        <span class="s1">start_fit = time.time()</span>
        <span class="s3">if </span><span class="s1">y_partial_train </span><span class="s3">is None</span><span class="s1">:</span>
            <span class="s1">partial_fit_func(X_partial_train)</span>
        <span class="s3">else</span><span class="s1">:</span>
            <span class="s1">partial_fit_func(X_partial_train</span><span class="s3">, </span><span class="s1">y_partial_train)</span>
        <span class="s1">fit_time = time.time() - start_fit</span>
        <span class="s1">fit_times.append(fit_time)</span>

        <span class="s1">start_score = time.time()</span>

        <span class="s1">test_scores.append(_score(estimator</span><span class="s3">, </span><span class="s1">X_test</span><span class="s3">, </span><span class="s1">y_test</span><span class="s3">, </span><span class="s1">scorer</span><span class="s3">, </span><span class="s1">error_score))</span>
        <span class="s1">train_scores.append(_score(estimator</span><span class="s3">, </span><span class="s1">X_train</span><span class="s3">, </span><span class="s1">y_train</span><span class="s3">, </span><span class="s1">scorer</span><span class="s3">, </span><span class="s1">error_score))</span>

        <span class="s1">score_time = time.time() - start_score</span>
        <span class="s1">score_times.append(score_time)</span>

    <span class="s1">ret = (</span>
        <span class="s1">(train_scores</span><span class="s3">, </span><span class="s1">test_scores</span><span class="s3">, </span><span class="s1">fit_times</span><span class="s3">, </span><span class="s1">score_times)</span>
        <span class="s3">if </span><span class="s1">return_times</span>
        <span class="s3">else </span><span class="s1">(train_scores</span><span class="s3">, </span><span class="s1">test_scores)</span>
    <span class="s1">)</span>

    <span class="s3">return </span><span class="s1">np.array(ret).T</span>


<span class="s1">@validate_params(</span>
    <span class="s1">{</span>
        <span class="s4">&quot;estimator&quot;</span><span class="s1">: [HasMethods([</span><span class="s4">&quot;fit&quot;</span><span class="s1">])]</span><span class="s3">,</span>
        <span class="s4">&quot;X&quot;</span><span class="s1">: [</span><span class="s4">&quot;array-like&quot;</span><span class="s3">, </span><span class="s4">&quot;sparse matrix&quot;</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;y&quot;</span><span class="s1">: [</span><span class="s4">&quot;array-like&quot;</span><span class="s3">, None</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;param_name&quot;</span><span class="s1">: [str]</span><span class="s3">,</span>
        <span class="s4">&quot;param_range&quot;</span><span class="s1">: [</span><span class="s4">&quot;array-like&quot;</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;groups&quot;</span><span class="s1">: [</span><span class="s4">&quot;array-like&quot;</span><span class="s3">, None</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;cv&quot;</span><span class="s1">: [</span><span class="s4">&quot;cv_object&quot;</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;scoring&quot;</span><span class="s1">: [StrOptions(set(get_scorer_names()))</span><span class="s3">, </span><span class="s1">callable</span><span class="s3">, None</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;n_jobs&quot;</span><span class="s1">: [Integral</span><span class="s3">, None</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;pre_dispatch&quot;</span><span class="s1">: [Integral</span><span class="s3">, </span><span class="s1">str]</span><span class="s3">,</span>
        <span class="s4">&quot;verbose&quot;</span><span class="s1">: [</span><span class="s4">&quot;verbose&quot;</span><span class="s1">]</span><span class="s3">,</span>
        <span class="s4">&quot;error_score&quot;</span><span class="s1">: [StrOptions({</span><span class="s4">&quot;raise&quot;</span><span class="s1">})</span><span class="s3">, </span><span class="s1">Real]</span><span class="s3">,</span>
        <span class="s4">&quot;fit_params&quot;</span><span class="s1">: [dict</span><span class="s3">, None</span><span class="s1">]</span><span class="s3">,</span>
    <span class="s1">}</span><span class="s3">,</span>
    <span class="s1">prefer_skip_nested_validation=</span><span class="s3">False,  </span><span class="s2"># estimator is not validated yet</span>
<span class="s1">)</span>
<span class="s3">def </span><span class="s1">validation_curve(</span>
    <span class="s1">estimator</span><span class="s3">,</span>
    <span class="s1">X</span><span class="s3">,</span>
    <span class="s1">y</span><span class="s3">,</span>
    <span class="s1">*</span><span class="s3">,</span>
    <span class="s1">param_name</span><span class="s3">,</span>
    <span class="s1">param_range</span><span class="s3">,</span>
    <span class="s1">groups=</span><span class="s3">None,</span>
    <span class="s1">cv=</span><span class="s3">None,</span>
    <span class="s1">scoring=</span><span class="s3">None,</span>
    <span class="s1">n_jobs=</span><span class="s3">None,</span>
    <span class="s1">pre_dispatch=</span><span class="s4">&quot;all&quot;</span><span class="s3">,</span>
    <span class="s1">verbose=</span><span class="s5">0</span><span class="s3">,</span>
    <span class="s1">error_score=np.nan</span><span class="s3">,</span>
    <span class="s1">fit_params=</span><span class="s3">None,</span>
<span class="s1">):</span>
    <span class="s0">&quot;&quot;&quot;Validation curve. 
 
    Determine training and test scores for varying parameter values. 
 
    Compute scores for an estimator with different values of a specified 
    parameter. This is similar to grid search with one parameter. However, this 
    will also compute training scores and is merely a utility for plotting the 
    results. 
 
    Read more in the :ref:`User Guide &lt;validation_curve&gt;`. 
 
    Parameters 
    ---------- 
    estimator : object type that implements the &quot;fit&quot; method 
        An object of that type which is cloned for each validation. It must 
        also implement &quot;predict&quot; unless `scoring` is a callable that doesn't 
        rely on &quot;predict&quot; to compute a score. 
 
    X : {array-like, sparse matrix} of shape (n_samples, n_features) 
        Training vector, where `n_samples` is the number of samples and 
        `n_features` is the number of features. 
 
    y : array-like of shape (n_samples,) or (n_samples, n_outputs) or None 
        Target relative to X for classification or regression; 
        None for unsupervised learning. 
 
    param_name : str 
        Name of the parameter that will be varied. 
 
    param_range : array-like of shape (n_values,) 
        The values of the parameter that will be evaluated. 
 
    groups : array-like of shape (n_samples,), default=None 
        Group labels for the samples used while splitting the dataset into 
        train/test set. Only used in conjunction with a &quot;Group&quot; :term:`cv` 
        instance (e.g., :class:`GroupKFold`). 
 
    cv : int, cross-validation generator or an iterable, default=None 
        Determines the cross-validation splitting strategy. 
        Possible inputs for cv are: 
 
        - None, to use the default 5-fold cross validation, 
        - int, to specify the number of folds in a `(Stratified)KFold`, 
        - :term:`CV splitter`, 
        - An iterable yielding (train, test) splits as arrays of indices. 
 
        For int/None inputs, if the estimator is a classifier and ``y`` is 
        either binary or multiclass, :class:`StratifiedKFold` is used. In all 
        other cases, :class:`KFold` is used. These splitters are instantiated 
        with `shuffle=False` so the splits will be the same across calls. 
 
        Refer :ref:`User Guide &lt;cross_validation&gt;` for the various 
        cross-validation strategies that can be used here. 
 
        .. versionchanged:: 0.22 
            ``cv`` default value if None changed from 3-fold to 5-fold. 
 
    scoring : str or callable, default=None 
        A str (see model evaluation documentation) or 
        a scorer callable object / function with signature 
        ``scorer(estimator, X, y)``. 
 
    n_jobs : int, default=None 
        Number of jobs to run in parallel. Training the estimator and computing 
        the score are parallelized over the combinations of each parameter 
        value and each cross-validation split. 
        ``None`` means 1 unless in a :obj:`joblib.parallel_backend` context. 
        ``-1`` means using all processors. See :term:`Glossary &lt;n_jobs&gt;` 
        for more details. 
 
    pre_dispatch : int or str, default='all' 
        Number of predispatched jobs for parallel execution (default is 
        all). The option can reduce the allocated memory. The str can 
        be an expression like '2*n_jobs'. 
 
    verbose : int, default=0 
        Controls the verbosity: the higher, the more messages. 
 
    error_score : 'raise' or numeric, default=np.nan 
        Value to assign to the score if an error occurs in estimator fitting. 
        If set to 'raise', the error is raised. 
        If a numeric value is given, FitFailedWarning is raised. 
 
        .. versionadded:: 0.20 
 
    fit_params : dict, default=None 
        Parameters to pass to the fit method of the estimator. 
 
        .. versionadded:: 0.24 
 
    Returns 
    ------- 
    train_scores : array of shape (n_ticks, n_cv_folds) 
        Scores on training sets. 
 
    test_scores : array of shape (n_ticks, n_cv_folds) 
        Scores on test set. 
 
    Notes 
    ----- 
    See :ref:`sphx_glr_auto_examples_model_selection_plot_validation_curve.py` 
    &quot;&quot;&quot;</span>
    <span class="s1">X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups = indexable(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups)</span>

    <span class="s1">cv = check_cv(cv</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">classifier=is_classifier(estimator))</span>
    <span class="s1">scorer = check_scoring(estimator</span><span class="s3">, </span><span class="s1">scoring=scoring)</span>

    <span class="s1">parallel = Parallel(n_jobs=n_jobs</span><span class="s3">, </span><span class="s1">pre_dispatch=pre_dispatch</span><span class="s3">, </span><span class="s1">verbose=verbose)</span>
    <span class="s1">results = parallel(</span>
        <span class="s1">delayed(_fit_and_score)(</span>
            <span class="s1">clone(estimator)</span><span class="s3">,</span>
            <span class="s1">X</span><span class="s3">,</span>
            <span class="s1">y</span><span class="s3">,</span>
            <span class="s1">scorer</span><span class="s3">,</span>
            <span class="s1">train</span><span class="s3">,</span>
            <span class="s1">test</span><span class="s3">,</span>
            <span class="s1">verbose</span><span class="s3">,</span>
            <span class="s1">parameters={param_name: v}</span><span class="s3">,</span>
            <span class="s1">fit_params=fit_params</span><span class="s3">,</span>
            <span class="s1">return_train_score=</span><span class="s3">True,</span>
            <span class="s1">error_score=error_score</span><span class="s3">,</span>
        <span class="s1">)</span>
        <span class="s2"># NOTE do not change order of iteration to allow one time cv splitters</span>
        <span class="s3">for </span><span class="s1">train</span><span class="s3">, </span><span class="s1">test </span><span class="s3">in </span><span class="s1">cv.split(X</span><span class="s3">, </span><span class="s1">y</span><span class="s3">, </span><span class="s1">groups)</span>
        <span class="s3">for </span><span class="s1">v </span><span class="s3">in </span><span class="s1">param_range</span>
    <span class="s1">)</span>
    <span class="s1">n_params = len(param_range)</span>

    <span class="s1">results = _aggregate_score_dicts(results)</span>
    <span class="s1">train_scores = results[</span><span class="s4">&quot;train_scores&quot;</span><span class="s1">].reshape(-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">n_params).T</span>
    <span class="s1">test_scores = results[</span><span class="s4">&quot;test_scores&quot;</span><span class="s1">].reshape(-</span><span class="s5">1</span><span class="s3">, </span><span class="s1">n_params).T</span>

    <span class="s3">return </span><span class="s1">train_scores</span><span class="s3">, </span><span class="s1">test_scores</span>


<span class="s3">def </span><span class="s1">_aggregate_score_dicts(scores):</span>
    <span class="s0">&quot;&quot;&quot;Aggregate the list of dict to dict of np ndarray 
 
    The aggregated output of _aggregate_score_dicts will be a list of dict 
    of form [{'prec': 0.1, 'acc':1.0}, {'prec': 0.1, 'acc':1.0}, ...] 
    Convert it to a dict of array {'prec': np.array([0.1 ...]), ...} 
 
    Parameters 
    ---------- 
 
    scores : list of dict 
        List of dicts of the scores for all scorers. This is a flat list, 
        assumed originally to be of row major order. 
 
    Example 
    ------- 
 
    &gt;&gt;&gt; scores = [{'a': 1, 'b':10}, {'a': 2, 'b':2}, {'a': 3, 'b':3}, 
    ...           {'a': 10, 'b': 10}]                         # doctest: +SKIP 
    &gt;&gt;&gt; _aggregate_score_dicts(scores)                        # doctest: +SKIP 
    {'a': array([1, 2, 3, 10]), 
     'b': array([10, 2, 3, 10])} 
    &quot;&quot;&quot;</span>
    <span class="s3">return </span><span class="s1">{</span>
        <span class="s1">key: (</span>
            <span class="s1">np.asarray([score[key] </span><span class="s3">for </span><span class="s1">score </span><span class="s3">in </span><span class="s1">scores])</span>
            <span class="s3">if </span><span class="s1">isinstance(scores[</span><span class="s5">0</span><span class="s1">][key]</span><span class="s3">, </span><span class="s1">numbers.Number)</span>
            <span class="s3">else </span><span class="s1">[score[key] </span><span class="s3">for </span><span class="s1">score </span><span class="s3">in </span><span class="s1">scores]</span>
        <span class="s1">)</span>
        <span class="s3">for </span><span class="s1">key </span><span class="s3">in </span><span class="s1">scores[</span><span class="s5">0</span><span class="s1">]</span>
    <span class="s1">}</span>
</pre>
</body>
</html>